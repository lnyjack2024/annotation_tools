{"version":3,"file":"canvas-sprite-tiling.min.js","sources":["../../src/TilingSprite.ts"],"sourcesContent":["import { TilingSprite } from '@pixi/sprite-tiling';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasRenderTarget } from '@pixi/utils';\nimport { Matrix, Point } from '@pixi/math';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\nconst worldMatrix = new Matrix();\nconst patternMatrix = new Matrix();\nconst patternRect = [new Point(), new Point(), new Point(), new Point()];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    const texture = this._texture;\n\n    if (!texture.baseTexture.valid)\n    {\n        return;\n    }\n\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    const baseTexture = texture.baseTexture;\n    const source = baseTexture.getDrawableSource();\n    const baseTextureResolution = baseTexture.resolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint)\n    {\n        this._textureID = this._texture._updateID;\n        // cut an object from a spritesheet..\n        const tempCanvas = new CanvasRenderTarget(texture._frame.width,\n            texture._frame.height,\n            baseTextureResolution);\n\n        // Tint the tiling sprite\n        if (this.tint !== 0xFFFFFF)\n        {\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint) as HTMLCanvasElement;\n            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(source,\n                -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n        }\n        this._cachedTint = this.tint;\n        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    renderer.setBlendMode(this.blendMode);\n\n    this.tileTransform.updateLocalTransform();\n    const lt = this.tileTransform.localTransform;\n    const W = this._width;\n    const H = this._height;\n\n    /*\n     * # Implementation Notes\n     *\n     * The tiling transform is not simply a transform on the tiling sprite's local space. If that\n     * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform\n     * on the \"pattern\" coordinates each vertex is assigned.\n     *\n     * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which\n     * is defined as:\n     *\n     * Pattern_Space = Local_Space x inverse(tileTransform)\n     *\n     * In other words,\n     * Local_Space = Pattern_Space x tileTransform\n     *\n     * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.\n     * In other words, the pattern will always \"originate\" from (0, 0) in the space we draw in.\n     *\n     * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes\n     * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.\n     *\n     * ## uvRespectAnchor\n     *\n     * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags\n     * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without\n     * loss of generality: If uvRespectAnchor = true, then\n     *\n     * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means \"maps to\")\n     *\n     * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That\n     * means the invariant under all other transforms are the origins)\n     *\n     * Otherwise,\n     *\n     * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)\n     *\n     * Here the mapping is provided by the tileTransfrom PLUS some \"shift\". This shift is done POST-tileTransform. The shift\n     * is equal to the position of the top-left corner of the tiling sprite in its local space.\n     *\n     * Hence,\n     *\n     * Local_Space = Pattern_Space x tileTransform x shiftTransform\n     */\n\n    // worldMatrix is used to convert from pattern space to world space.\n    //\n    // worldMatrix = tileTransform x shiftTransform x worldTransfrom\n    //             = patternMatrix x worldTransform\n    worldMatrix.identity();\n\n    // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space\n    // and this matrix is used to inverse-map the local space vertices into it.\n    //\n    // patternMatrix = tileTransfrom x shiftTransform\n    patternMatrix.copyFrom(lt);\n\n    // Apply shiftTransform into patternMatrix. See $1.1\n    if (!this.uvRespectAnchor)\n    {\n        patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);\n    }\n\n    patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n    worldMatrix.prepend(patternMatrix);\n    worldMatrix.prepend(transform);\n\n    renderer.setContextTransform(worldMatrix);\n\n    // Fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)\n    const lx = this.anchor.x * -W;\n    const ly = this.anchor.y * -H;\n\n    // Set pattern rect in local space first.\n    patternRect[0].set(lx, ly);\n    patternRect[1].set(lx + W, ly);\n    patternRect[2].set(lx + W, ly + H);\n    patternRect[3].set(lx, ly + H);\n\n    // Map patternRect into pattern space.\n    for (let i = 0; i < 4; i++)\n    {\n        patternMatrix.applyInverse(patternRect[i], patternRect[i]);\n    }\n\n    /*\n     * # Note about verification of theory\n     *\n     * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of\n     * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map\n     * to the top-left corner of the tiling sprite in its local space.\n     */\n\n    context.beginPath();\n    context.moveTo(patternRect[0].x, patternRect[0].y);\n\n    for (let i = 1; i < 4; i++)\n    {\n        context.lineTo(patternRect[i].x, patternRect[i].y);\n    }\n\n    context.closePath();\n    context.fill();\n};\n"],"names":["worldMatrix","Matrix","patternMatrix","patternRect","Point","TilingSprite","prototype","_renderCanvas","renderer","texture","this","_texture","baseTexture","valid","context","transform","worldTransform","source","getDrawableSource","baseTextureResolution","resolution","_textureID","_updateID","_cachedTint","tint","tempCanvas","CanvasRenderTarget","_frame","width","height","_tintedCanvas","canvasUtils","getTintedCanvas","drawImage","x","y","_canvasPattern","createPattern","canvas","globalAlpha","worldAlpha","setBlendMode","blendMode","tileTransform","updateLocalTransform","lt","localTransform","W","_width","H","_height","identity","copyFrom","uvRespectAnchor","translate","anchor","scale","tileScale","prepend","setContextTransform","fillStyle","lx","ly","set","i","applyInverse","beginPath","moveTo","lineTo","closePath","fill"],"mappings":";;;;;;;uMAOA,IAAMA,EAAc,IAAIC,EAClBC,EAAgB,IAAID,EACpBE,EAAc,CAAC,IAAIC,EAAS,IAAIA,EAAS,IAAIA,EAAS,IAAIA,GAUhEC,EAAaC,UAAUC,cAAgB,SAAuBC,GAE1D,IAAMC,EAAUC,KAAKC,SAErB,GAAKF,EAAQG,YAAYC,MAAzB,CAKA,IAAMC,EAAUN,EAASM,QACnBC,EAAYL,KAAKM,eACjBJ,EAAcH,EAAQG,YACtBK,EAASL,EAAYM,oBACrBC,EAAwBP,EAAYQ,WAG1C,GAAIV,KAAKW,aAAeX,KAAKC,SAASW,WAAaZ,KAAKa,cAAgBb,KAAKc,KAC7E,CACId,KAAKW,WAAaX,KAAKC,SAASW,UAEhC,IAAMG,EAAa,IAAIC,EAAmBjB,EAAQkB,OAAOC,MACrDnB,EAAQkB,OAAOE,OACfV,GAGc,WAAdT,KAAKc,MAELd,KAAKoB,cAAgBC,EAAYC,gBAAgBtB,KAAMA,KAAKc,MAC5DC,EAAWX,QAAQmB,UAAUvB,KAAKoB,cAAe,EAAG,IAIpDL,EAAWX,QAAQmB,UAAUhB,GACxBR,EAAQkB,OAAOO,EAAIf,GAAwBV,EAAQkB,OAAOQ,EAAIhB,GAEvET,KAAKa,YAAcb,KAAKc,KACxBd,KAAK0B,eAAiBX,EAAWX,QAAQuB,cAAcZ,EAAWa,OAAQ,UAI9ExB,EAAQyB,YAAc7B,KAAK8B,WAC3BhC,EAASiC,aAAa/B,KAAKgC,WAE3BhC,KAAKiC,cAAcC,uBACnB,IAAMC,EAAKnC,KAAKiC,cAAcG,eACxBC,EAAIrC,KAAKsC,OACTC,EAAIvC,KAAKwC,QAkDflD,EAAYmD,WAMZjD,EAAckD,SAASP,GAGlBnC,KAAK2C,iBAENnD,EAAcoD,WAAW5C,KAAK6C,OAAOrB,EAAIa,GAAIrC,KAAK6C,OAAOpB,EAAIc,GAGjE/C,EAAcsD,MAAM9C,KAAK+C,UAAUvB,EAAIf,EAAuBT,KAAK+C,UAAUtB,EAAIhB,GACjFnB,EAAY0D,QAAQxD,GACpBF,EAAY0D,QAAQ3C,GAEpBP,EAASmD,oBAAoB3D,GAG7Bc,EAAQ8C,UAAYlD,KAAK0B,eAGzB,IAAMyB,EAAKnD,KAAK6C,OAAOrB,GAAKa,EACtBe,EAAKpD,KAAK6C,OAAOpB,GAAKc,EAG5B9C,EAAY,GAAG4D,IAAIF,EAAIC,GACvB3D,EAAY,GAAG4D,IAAIF,EAAKd,EAAGe,GAC3B3D,EAAY,GAAG4D,IAAIF,EAAKd,EAAGe,EAAKb,GAChC9C,EAAY,GAAG4D,IAAIF,EAAIC,EAAKb,GAG5B,IAAK,IAAIe,EAAI,EAAGA,EAAI,EAAGA,IAEnB9D,EAAc+D,aAAa9D,EAAY6D,GAAI7D,EAAY6D,IAW3DlD,EAAQoD,YACRpD,EAAQqD,OAAOhE,EAAY,GAAG+B,EAAG/B,EAAY,GAAGgC,GAEhD,IAAS6B,EAAI,EAAGA,EAAI,EAAGA,IAEnBlD,EAAQsD,OAAOjE,EAAY6D,GAAG9B,EAAG/B,EAAY6D,GAAG7B,GAGpDrB,EAAQuD,YACRvD,EAAQwD"}