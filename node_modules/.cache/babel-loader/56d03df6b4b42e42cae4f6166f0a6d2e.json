{"ast":null,"code":"import { EditorState, convertFromRaw, convertToRaw } from 'draft-js';\nimport { ATOMIC_TYPE } from '../constants';\nexport default function tabCommandHandler(editorState, setEditorState, options) {\n  const selection = editorState.getSelection();\n  const start = selection.getStartKey();\n  const end = selection.getEndKey();\n  const startOffset = selection.getStartOffset();\n  const endOffset = selection.getEndOffset();\n  const multiLineSelected = start !== end;\n  const rangeSelected = multiLineSelected || startOffset !== endOffset;\n  const currentContent = editorState.getCurrentContent();\n  const rawData = convertToRaw(currentContent);\n  const {\n    blocks\n  } = rawData;\n  let started = false;\n  let newStartOffset;\n  let newEndOffset;\n  for (let i = 0; i < blocks.length; i += 1) {\n    const block = blocks[i];\n    if (block.key === start) {\n      started = true;\n    }\n    if (started && block.type !== ATOMIC_TYPE) {\n      const spaceCount = block.text.search(/\\S|$/);\n      const mod = spaceCount % 4;\n      const trimText = block.text.trim();\n      if (multiLineSelected && !trimText) {\n        // force empty line to empty string when multi-line selected\n        block.text = '';\n      } else if (options === null || options === void 0 ? void 0 : options.shift) {\n        const delSpaceCount = spaceCount >= 4 && mod === 0 ? 4 : mod;\n        block.text = block.text.substring(delSpaceCount);\n        if (newStartOffset === undefined) {\n          if (block.key !== start) {\n            newStartOffset = 0;\n          } else if (startOffset > spaceCount) {\n            newStartOffset = startOffset - delSpaceCount;\n          } else {\n            newStartOffset = Math.min(startOffset, spaceCount - delSpaceCount);\n          }\n        }\n        newEndOffset = block.key === end ? endOffset - delSpaceCount : endOffset;\n      } else {\n        const newSpaceCount = 4 - mod;\n        const spaceStr = new Array(newSpaceCount).fill(' ').join('');\n        block.text = `${spaceStr}${block.text}`;\n        if (newStartOffset === undefined) {\n          if (block.key !== start) {\n            newStartOffset = 0;\n          } else if (!rangeSelected || startOffset > spaceCount) {\n            newStartOffset = startOffset + newSpaceCount;\n          } else {\n            newStartOffset = startOffset;\n          }\n        }\n        newEndOffset = block.key === end ? endOffset + newSpaceCount : endOffset;\n      }\n    }\n    if (block.key === end) {\n      started = false;\n      break;\n    }\n  }\n  const state = EditorState.push(editorState, convertFromRaw(rawData), 'insert-characters');\n  const isBackward = selection.getIsBackward();\n  setEditorState(EditorState.forceSelection(state, selection.merge({\n    anchorOffset: isBackward ? newEndOffset : newStartOffset,\n    focusOffset: isBackward ? newStartOffset : newEndOffset\n  })));\n  return 'handled';\n}","map":{"version":3,"names":["EditorState","convertFromRaw","convertToRaw","ATOMIC_TYPE","tabCommandHandler","editorState","setEditorState","options","selection","getSelection","start","getStartKey","end","getEndKey","startOffset","getStartOffset","endOffset","getEndOffset","multiLineSelected","rangeSelected","currentContent","getCurrentContent","rawData","blocks","started","newStartOffset","newEndOffset","i","length","block","key","type","spaceCount","text","search","mod","trimText","trim","shift","delSpaceCount","substring","undefined","Math","min","newSpaceCount","spaceStr","Array","fill","join","state","push","isBackward","getIsBackward","forceSelection","merge","anchorOffset","focusOffset"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/llm/input/command-handlers/tab.ts"],"sourcesContent":["import { DraftHandleValue, EditorState, convertFromRaw, convertToRaw } from 'draft-js';\nimport { ATOMIC_TYPE } from '../constants';\n\nexport default function tabCommandHandler(\n  editorState: EditorState,\n  setEditorState: React.Dispatch<React.SetStateAction<EditorState>>,\n  options?: {\n    shift?: boolean;\n  }\n): DraftHandleValue {\n  const selection = editorState.getSelection();\n  const start = selection.getStartKey();\n  const end = selection.getEndKey();\n  const startOffset = selection.getStartOffset();\n  const endOffset = selection.getEndOffset();\n\n  const multiLineSelected = start !== end;\n  const rangeSelected = multiLineSelected || startOffset !== endOffset;\n\n  const currentContent = editorState.getCurrentContent();\n  const rawData = convertToRaw(currentContent);\n  const { blocks } = rawData;\n\n  let started = false;\n  let newStartOffset;\n  let newEndOffset;\n  for (let i = 0; i < blocks.length; i += 1) {\n    const block = blocks[i];\n    if (block.key === start) {\n      started = true;\n    }\n    if (started && block.type !== ATOMIC_TYPE) {\n      const spaceCount = block.text.search(/\\S|$/);\n      const mod = spaceCount % 4;\n      const trimText = block.text.trim();\n      if (multiLineSelected && !trimText) {\n        // force empty line to empty string when multi-line selected\n        block.text = '';\n      } else if (options?.shift) {\n        const delSpaceCount = (spaceCount >= 4 && mod === 0) ? 4 : mod;\n        block.text = block.text.substring(delSpaceCount);\n        if (newStartOffset === undefined) {\n          if (block.key !== start) {\n            newStartOffset = 0;\n          } else if (startOffset > spaceCount) {\n            newStartOffset = startOffset - delSpaceCount;\n          } else {\n            newStartOffset = Math.min(startOffset, spaceCount - delSpaceCount);\n          }\n        }\n        newEndOffset = block.key === end ? endOffset - delSpaceCount : endOffset;\n      } else {\n        const newSpaceCount = 4 - mod;\n        const spaceStr = new Array(newSpaceCount).fill(' ').join('');\n        block.text = `${spaceStr}${block.text}`;\n        if (newStartOffset === undefined) {\n          if (block.key !== start) {\n            newStartOffset = 0;\n          } else if (!rangeSelected || startOffset > spaceCount) {\n            newStartOffset = startOffset + newSpaceCount;\n          } else {\n            newStartOffset = startOffset;\n          }\n        }\n        newEndOffset = block.key === end ? endOffset + newSpaceCount : endOffset;\n      }\n    }\n    if (block.key === end) {\n      started = false;\n      break;\n    }\n  }\n\n  const state = EditorState.push(editorState, convertFromRaw(rawData), 'insert-characters');\n  const isBackward = selection.getIsBackward();\n  setEditorState(EditorState.forceSelection(state, selection.merge({\n    anchorOffset: isBackward ? newEndOffset : newStartOffset,\n    focusOffset: isBackward ? newStartOffset : newEndOffset,\n  })));\n\n  return 'handled';\n}\n"],"mappings":"AAAA,SAA2BA,WAAW,EAAEC,cAAc,EAAEC,YAAY,QAAQ,UAAU;AACtF,SAASC,WAAW,QAAQ,cAAc;AAE1C,eAAe,SAASC,iBAAiBA,CACvCC,WAAwB,EACxBC,cAAiE,EACjEC,OAEC,EACiB;EAClB,MAAMC,SAAS,GAAGH,WAAW,CAACI,YAAY,CAAC,CAAC;EAC5C,MAAMC,KAAK,GAAGF,SAAS,CAACG,WAAW,CAAC,CAAC;EACrC,MAAMC,GAAG,GAAGJ,SAAS,CAACK,SAAS,CAAC,CAAC;EACjC,MAAMC,WAAW,GAAGN,SAAS,CAACO,cAAc,CAAC,CAAC;EAC9C,MAAMC,SAAS,GAAGR,SAAS,CAACS,YAAY,CAAC,CAAC;EAE1C,MAAMC,iBAAiB,GAAGR,KAAK,KAAKE,GAAG;EACvC,MAAMO,aAAa,GAAGD,iBAAiB,IAAIJ,WAAW,KAAKE,SAAS;EAEpE,MAAMI,cAAc,GAAGf,WAAW,CAACgB,iBAAiB,CAAC,CAAC;EACtD,MAAMC,OAAO,GAAGpB,YAAY,CAACkB,cAAc,CAAC;EAC5C,MAAM;IAAEG;EAAO,CAAC,GAAGD,OAAO;EAE1B,IAAIE,OAAO,GAAG,KAAK;EACnB,IAAIC,cAAc;EAClB,IAAIC,YAAY;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACK,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACzC,MAAME,KAAK,GAAGN,MAAM,CAACI,CAAC,CAAC;IACvB,IAAIE,KAAK,CAACC,GAAG,KAAKpB,KAAK,EAAE;MACvBc,OAAO,GAAG,IAAI;IAChB;IACA,IAAIA,OAAO,IAAIK,KAAK,CAACE,IAAI,KAAK5B,WAAW,EAAE;MACzC,MAAM6B,UAAU,GAAGH,KAAK,CAACI,IAAI,CAACC,MAAM,CAAC,MAAM,CAAC;MAC5C,MAAMC,GAAG,GAAGH,UAAU,GAAG,CAAC;MAC1B,MAAMI,QAAQ,GAAGP,KAAK,CAACI,IAAI,CAACI,IAAI,CAAC,CAAC;MAClC,IAAInB,iBAAiB,IAAI,CAACkB,QAAQ,EAAE;QAClC;QACAP,KAAK,CAACI,IAAI,GAAG,EAAE;MACjB,CAAC,MAAM,IAAI1B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE+B,KAAK,EAAE;QACzB,MAAMC,aAAa,GAAIP,UAAU,IAAI,CAAC,IAAIG,GAAG,KAAK,CAAC,GAAI,CAAC,GAAGA,GAAG;QAC9DN,KAAK,CAACI,IAAI,GAAGJ,KAAK,CAACI,IAAI,CAACO,SAAS,CAACD,aAAa,CAAC;QAChD,IAAId,cAAc,KAAKgB,SAAS,EAAE;UAChC,IAAIZ,KAAK,CAACC,GAAG,KAAKpB,KAAK,EAAE;YACvBe,cAAc,GAAG,CAAC;UACpB,CAAC,MAAM,IAAIX,WAAW,GAAGkB,UAAU,EAAE;YACnCP,cAAc,GAAGX,WAAW,GAAGyB,aAAa;UAC9C,CAAC,MAAM;YACLd,cAAc,GAAGiB,IAAI,CAACC,GAAG,CAAC7B,WAAW,EAAEkB,UAAU,GAAGO,aAAa,CAAC;UACpE;QACF;QACAb,YAAY,GAAGG,KAAK,CAACC,GAAG,KAAKlB,GAAG,GAAGI,SAAS,GAAGuB,aAAa,GAAGvB,SAAS;MAC1E,CAAC,MAAM;QACL,MAAM4B,aAAa,GAAG,CAAC,GAAGT,GAAG;QAC7B,MAAMU,QAAQ,GAAG,IAAIC,KAAK,CAACF,aAAa,CAAC,CAACG,IAAI,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC;QAC5DnB,KAAK,CAACI,IAAI,GAAI,GAAEY,QAAS,GAAEhB,KAAK,CAACI,IAAK,EAAC;QACvC,IAAIR,cAAc,KAAKgB,SAAS,EAAE;UAChC,IAAIZ,KAAK,CAACC,GAAG,KAAKpB,KAAK,EAAE;YACvBe,cAAc,GAAG,CAAC;UACpB,CAAC,MAAM,IAAI,CAACN,aAAa,IAAIL,WAAW,GAAGkB,UAAU,EAAE;YACrDP,cAAc,GAAGX,WAAW,GAAG8B,aAAa;UAC9C,CAAC,MAAM;YACLnB,cAAc,GAAGX,WAAW;UAC9B;QACF;QACAY,YAAY,GAAGG,KAAK,CAACC,GAAG,KAAKlB,GAAG,GAAGI,SAAS,GAAG4B,aAAa,GAAG5B,SAAS;MAC1E;IACF;IACA,IAAIa,KAAK,CAACC,GAAG,KAAKlB,GAAG,EAAE;MACrBY,OAAO,GAAG,KAAK;MACf;IACF;EACF;EAEA,MAAMyB,KAAK,GAAGjD,WAAW,CAACkD,IAAI,CAAC7C,WAAW,EAAEJ,cAAc,CAACqB,OAAO,CAAC,EAAE,mBAAmB,CAAC;EACzF,MAAM6B,UAAU,GAAG3C,SAAS,CAAC4C,aAAa,CAAC,CAAC;EAC5C9C,cAAc,CAACN,WAAW,CAACqD,cAAc,CAACJ,KAAK,EAAEzC,SAAS,CAAC8C,KAAK,CAAC;IAC/DC,YAAY,EAAEJ,UAAU,GAAGzB,YAAY,GAAGD,cAAc;IACxD+B,WAAW,EAAEL,UAAU,GAAG1B,cAAc,GAAGC;EAC7C,CAAC,CAAC,CAAC,CAAC;EAEJ,OAAO,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module"}