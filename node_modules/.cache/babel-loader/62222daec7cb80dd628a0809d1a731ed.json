{"ast":null,"code":"/**\n * This module contains the methods that take one or more\n * tiers or textgrids and returns a modified result.<br /><br />\n *\n * @author Tim Mahrt\n * @since March 25, 2015\n * @module textgrid_modifiers\n */\n\nimport { Textgrid, IntervalTier, PointTier, copyTier } from './textgrid.js';\nclass NonMatchingTiersException extends Error {}\n;\nclass OvershootModificationException extends Error {\n  constructor(tierName, oldEntry, newEntry, min, max, ...args) {\n    super(...args);\n    this.tierName = tierName;\n    this.oldEntry = oldEntry;\n    this.newEntry = newEntry;\n    this.min = min;\n    this.max = max;\n    this.message = `Attempted to change [${oldEntry}] to [${newEntry}] in tier '${tierName}' however, this exceeds the bounds (${min},${max}).`;\n  }\n}\n;\nclass IncorrectArgumentException extends Error {\n  constructor(value, targetValueList, ...args) {\n    super(...args);\n    this.value = value;\n    this.targetValueList = targetValueList;\n    this.message = `Expected value '${this.value}' to be one value in [${this.targetValueList}].`;\n  }\n}\n\n/**\n * Append one textgrid to the end of this one\n * @param {Textgrid} tg1 - the source textgrid\n * @param {Textgrid} tg2 - the textgrid to add on\n * @param {boolean} [onlyMatchingNames=true] - only include tiers that appear in both textgrids\n * @return {Textgrid}\n */\nfunction appendTextgrid(tg1, tg2, onlyMatchingNames = true) {\n  // Get all tier names with no duplicates.  Ordered first by\n  // this textgrid and then by the other textgrid.\n  const combinedTierNameList = tg1.tierNameList.slice(0);\n  for (let i = 0; i < tg2.tierNameList.length; i++) {\n    const tierName = tg2.tierNameList[i];\n    if (!combinedTierNameList.includes(tierName)) {\n      combinedTierNameList.push(tierName);\n    }\n  }\n\n  // Determine the tier names that will be in the final textgrid\n  let finalTierNameList = [];\n  if (onlyMatchingNames === false) {\n    finalTierNameList = combinedTierNameList;\n  } else {\n    for (let i = 0; i < tg2.tierNameList.length; i++) {\n      const tierName = tg2.tierNameList[i];\n      if (tg1.tierNameList.includes(tierName) && tg2.tierNameList.includes(tierName)) {\n        finalTierNameList.push(tierName);\n      }\n    }\n  }\n\n  // Add tiers from this textgrid\n  const retTg = new Textgrid();\n  const minTimestamp = tg1.minTimestamp;\n  const maxTimestamp = tg1.maxTimestamp + tg2.maxTimestamp;\n  for (let i = 0; i < finalTierNameList.length; i++) {\n    const tierName = finalTierNameList[i];\n    if (!tg1.tierNameList.includes(tierName)) continue;\n    let tier = tg1.tierDict[tierName];\n    tier = copyTier(tier, {\n      minTimestamp: minTimestamp,\n      maxTimestamp: maxTimestamp\n    });\n    retTg.addTier(tier);\n  }\n\n  // Add tiers from the other textgrid\n  for (let i = 0; i < finalTierNameList.length; i++) {\n    const tierName = finalTierNameList[i];\n    if (!tg2.tierNameList.includes(tierName)) continue;\n    let tier = tg2.tierDict[tierName];\n    tier = copyTier(tier, {\n      minTimestamp: minTimestamp,\n      maxTimestamp: maxTimestamp\n    });\n    tier = editTierTimestamps(tier, tg1.maxTimestamp);\n    if (!retTg.tierNameList.includes(tierName)) {\n      retTg.addTier(tier);\n    } else {\n      let combinedTier = retTg.tierDict[tierName];\n      let combinedEntryList = combinedTier.entryList;\n      combinedEntryList = combinedEntryList.concat(tier.entryList);\n      combinedTier = copyTier(combinedTier, {\n        entryList: combinedEntryList\n      });\n      retTg.replaceTier(tierName, combinedTier);\n    }\n  }\n  return retTg;\n}\n\n/**\n * Add one tier to the end of another\n * @param {TextgridTier} tier1 - the base tier\n * @param {TextgridTier} tier2 - the tier to add\n * @return {TextgridTier}\n */\nfunction appendTier(tier1, tier2) {\n  if (tier1.tierType !== tier2.tierType) {\n    throw new NonMatchingTiersException('Tier types must match when appending tiers.');\n  }\n  const minTime = tier1.minTimestamp;\n  const maxTime = tier1.maxTimestamp + tier2.maxTimestamp;\n  const appendTier = editTierTimestamps(tier2, tier1.maxTimestamp, true);\n  const entryList = tier1.entryList.concat(appendTier.entryList);\n  return copyTier(tier1, {\n    name: tier1.name,\n    entryList: entryList,\n    minTimestamp: minTime,\n    maxTimestamp: maxTime\n  });\n}\n\n/**\n * Creates a textgrid that only contains intervals from the crop region\n * @param {Textgrid} tg\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} mode - one of 'strict', 'lax', or 'truncated'\n *  If 'strict', only intervals wholly contained by the crop interval will be kept.\n *  If 'lax', partially contained intervals will be kept.\n *  If 'truncated', partially contained intervals will be truncated to fit within the crop region.\n * @param {boolean} rebaseToZero - if true, the all times in entries will be subtracted by the cropStart\n * @return {Textgrid} A new textgrid containing only entries that appear in the crop region.\n */\nfunction cropTextgrid(tg, cropStart, cropEnd, mode, rebaseToZero) {\n  const newTG = new Textgrid();\n  let minT = cropStart;\n  let maxT = cropEnd;\n  if (rebaseToZero === true) {\n    minT = 0;\n    maxT = cropEnd - cropStart;\n  }\n  newTG.minTimestamp = minT;\n  newTG.maxTimestamp = maxT;\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    const tier = tg.tierDict[tierName];\n    const newTier = cropTier(tier, cropStart, cropEnd, mode, rebaseToZero);\n    newTG.addTier(newTier);\n  }\n  return newTG;\n}\n\n/**\n * Creates a new tier containing only entries from inside the crop interval\n * @param {TextgridTier} tier\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} mode - mode is ignored.  This parameter is kept for compatibility with IntervalTier.crop()\n * @param {boolean} rebaseToZero - if true, all times will be subtracted by cropStart\n * @return {TextgridTier} Returns a copy of this tier with only values from the crop region.\n */\nfunction cropTier(tier, cropStart, cropEnd, mode, rebaseToZero) {\n  let croppedTier;\n  if (tier instanceof PointTier) {\n    croppedTier = cropPointTier(tier, cropStart, cropEnd, mode, rebaseToZero);\n  } else if (tier instanceof IntervalTier) {\n    croppedTier = cropIntervalTier(tier, cropStart, cropEnd, mode, rebaseToZero);\n  }\n  return croppedTier;\n}\n\n/**\n * Creates a new tier containing only entries from inside the crop interval\n * @param {PointTier} pointTier\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} mode - mode is ignored.  This parameter is kept for compatibility with IntervalTier.crop()\n * @param {boolean} rebaseToZero - if true, all times will be subtracted by cropStart\n * @return {PointTier} Returns a copy of this tier with only values from the crop region.\n */\nfunction cropPointTier(pointTier, cropStart, cropEnd, mode, rebaseToZero) {\n  let newEntryList = [];\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const timestamp = pointTier.entryList[i][0];\n    if (timestamp >= cropStart && timestamp <= cropEnd) newEntryList.push(pointTier.entryList[i]);\n  }\n  let minT = cropStart;\n  let maxT = cropEnd;\n  if (rebaseToZero === true) {\n    newEntryList = newEntryList.map(entry => [entry[0] - cropStart, entry[1]]);\n    minT = 0;\n    maxT = cropEnd - cropStart;\n  }\n  const subTier = new PointTier(pointTier.name, newEntryList, minT, maxT);\n  return subTier;\n}\n\n/**\n * Creates a new tier with only the entries from the crop region\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} number - one of 'strict', 'lax', or 'truncated'\n    If 'strict', only intervals wholly contained by the crop interval will be kept.\n    If 'lax', partially contained intervals will be kept.\n    If 'truncated', partially contained intervals will be\n        truncated to fit within the crop region.\n * @param {boolean} rebaseToZero - if true the cropped textgrid values will be subtracted by cropStart\n * @return {Textgrid} A copy of this tier with only entries from the crop region\n */\nfunction cropIntervalTier(intervalTier, cropStart, cropEnd, mode, rebaseToZero) {\n  let newEntryList = [];\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const entry = intervalTier.entryList[i];\n    let matchedEntry = null;\n    const intervalStart = entry[0];\n    const intervalEnd = entry[1];\n    const intervalLabel = entry[2];\n\n    // Don't need to investigate if the interval is before or after\n    // the crop region\n    if (intervalEnd <= cropStart || intervalStart >= cropEnd) continue;\n\n    // Determine if the current subEntry is wholly contained\n    // within the superEntry\n    if (intervalStart >= cropStart && intervalEnd <= cropEnd) {\n      matchedEntry = entry;\n    }\n\n    // If it is only partially contained within the superEntry AND\n    // inclusion is 'lax', include it anyways\n    else if (mode === 'lax' && (intervalStart >= cropStart || intervalEnd <= cropEnd)) {\n      matchedEntry = entry;\n    }\n\n    // If not strict, include partial tiers on the edges\n    // -- regardless, record how much information was lost\n    //        - for strict=true, the total time of the cut interval\n    //        - for strict=false, the portion of the interval that lies\n    //            outside the new interval\n\n    // The current interval straddles the end of the new interval\n    else if (intervalStart >= cropStart && intervalEnd > cropEnd) {\n      if (mode === 'truncated') {\n        matchedEntry = [intervalStart, cropEnd, intervalLabel];\n      }\n    }\n\n    // The current interval straddles the start of the new interval\n    else if (intervalStart < cropStart && intervalEnd <= cropEnd) {\n      if (mode === 'truncated') {\n        matchedEntry = [cropStart, intervalEnd, intervalLabel];\n      }\n    }\n\n    // The current interval contains the new interval completely\n    else if (intervalStart <= cropStart && intervalEnd >= cropEnd) {\n      if (mode === 'lax') {\n        matchedEntry = entry;\n      } else if (mode === 'truncated') {\n        matchedEntry = [cropStart, cropEnd, intervalLabel];\n      }\n    }\n    if (matchedEntry !== null) {\n      newEntryList.push(matchedEntry);\n    }\n  }\n  let minT = cropStart;\n  let maxT = cropEnd;\n  if (rebaseToZero === true) {\n    newEntryList = newEntryList.map(entryList => [entryList[0] - cropStart, entryList[1] - cropStart, entryList[2]]);\n    minT = 0;\n    maxT = cropEnd - cropStart;\n  }\n\n  // Create subtier\n  const croppedTier = new IntervalTier(intervalTier.name, newEntryList, minT, maxT);\n  return croppedTier;\n}\n\n/**\n * Modifies all timestamps in the Textgrid and in the contained tiers by a constant amount\n * @param {Textgrid} tg\n * @param {number} offset - the amount to modify all timestamps by\n * @param {boolean} [allowOvershoot=false] - if false and offset pushes a value past maxTimestamp, throw an error; otherwise, lengthen the textgrid\n * @return {Textgrid}\n */\nfunction editTextgridTimestamps(tg, offset, allowOvershoot = false) {\n  const editedTg = new Textgrid();\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    let tier = tg.tierDict[tg.tierNameList[i]];\n    tier = editTierTimestamps(tier, offset, allowOvershoot);\n    editedTg.addTier(tier);\n  }\n  return editedTg;\n}\n\n/**\n * Modifies all timestamps by a constant amount\n * @param {TextgridTier} tier\n * @param {number} offset\n * @param {boolean} [allowOvershoot=false] - if false and offset pushes a value past maxTimestamp, throw an error; otherwise, lengthen the tier\n * @return {TextgridTier}\n */\nfunction editTierTimestamps(tier, offset, allowOvershoot = false) {\n  let editedTier;\n  if (tier instanceof PointTier) {\n    editedTier = editPointTierTimestamps(tier, offset, allowOvershoot);\n  } else if (tier instanceof IntervalTier) {\n    editedTier = editIntervalTierTimestamps(tier, offset, allowOvershoot);\n  }\n  return editedTier;\n}\nfunction editPointTierTimestamps(pointTier, offset, allowOvershoot = false) {\n  const newEntryList = [];\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const entry = pointTier.entryList[i];\n    const newTime = entry[0] + offset;\n    const newEntry = [newTime, entry[1]];\n    if (allowOvershoot === false) {\n      if (newTime < pointTier.minTimestamp || newTime > pointTier.maxTimestamp) {\n        throw new OvershootModificationException(pointTier.name, entry, newEntry, pointTier.minTimestamp, pointTier.maxTimestamp);\n      }\n    }\n    newEntryList.push(newEntry);\n  }\n  const newTimeList = newEntryList.map(entry => entry[0]);\n  let newMin = Math.min(...newTimeList);\n  let newMax = Math.max(...newTimeList);\n  if (pointTier.minTimestamp < newMin) newMin = pointTier.minTimestamp;\n  if (pointTier.maxTimestamp > newMax) newMax = pointTier.maxTimestamp;\n  return new PointTier(pointTier.name, newEntryList, newMin, newMax);\n}\nfunction editIntervalTierTimestamps(intervalTier, offset, allowOvershoot = false) {\n  const newEntryList = [];\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const entry = intervalTier.entryList[i];\n    const newStart = entry[0] + offset;\n    const newStop = entry[1] + offset;\n    const newEntry = [newStart, newStop, entry[2]];\n    if (allowOvershoot === false) {\n      if (newStart < intervalTier.minTimestamp || newStop > intervalTier.maxTimestamp) {\n        throw new OvershootModificationException(intervalTier.name, entry, newEntry, intervalTier.minTimestamp, intervalTier.maxTimestamp);\n      }\n    }\n    newEntryList.push(newEntry);\n  }\n  let newMin = Math.min(...newEntryList.map(entry => entry[0]));\n  let newMax = Math.max(...newEntryList.map(entry => entry[1]));\n  if (intervalTier.minTimestamp < newMin) newMin = intervalTier.minTimestamp;\n  if (intervalTier.maxTimestamp > newMax) newMax = intervalTier.maxTimestamp;\n  return new IntervalTier(intervalTier.name, newEntryList, newMin, newMax);\n}\n\n/**\n * Makes a region in all tiers blank (removes all contained entries)\n * @param {TextgridTier} tg\n * @param {number} start\n * @param {number} stop\n * @param {boolean} doShrink - if true, all values after the erase region will be shifted earlier in time by (stop - start) seconds\n * @return {TextgridTier} A copy of this textgrid without entries in the specified region.\n */\nfunction eraseRegionFromTextgrid(tg, start, stop, doShrink) {\n  const duration = stop - start;\n  let maxTimestamp = tg.maxTimestamp;\n  if (doShrink === true) maxTimestamp -= duration;\n  const newTg = new Textgrid();\n  newTg.minTimestamp = tg.minTimestamp;\n  newTg.maxTimestamp = maxTimestamp;\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    let tier = tg.tierDict[tg.tierNameList[i]];\n    tier = eraseRegionFromTier(tier, start, stop, doShrink, 'truncated');\n    newTg.addTier(tier);\n  }\n  return newTg;\n}\n\n/**\n * Makes a region in a tier blank (removes all contained entries)\n * @param {TextgridTier} tier\n * @param {number} start\n * @param {number} stop\n * @param {boolean} doShrink - if true, all values after the erase region will be shifted earlier in time by (stop - start) seconds\n * @return {TextgridTier} A copy of this tier without entries in the specified region.\n */\nfunction eraseRegionFromTier(tier, start, stop, doShrink, collisionCode) {\n  let retTier;\n  const codeList = ['strict', 'truncated'];\n  if (!codeList.includes(collisionCode)) {\n    throw new IncorrectArgumentException(collisionCode, codeList);\n  }\n\n  // erase region is in the middle of the textgrid\n  if (start > tier.minTimestamp && stop < tier.maxTimestamp) {\n    const leftCrop = cropTier(tier, tier.minTimestamp, start, collisionCode, false);\n    if (doShrink === true) {\n      const rightCrop = cropTier(tier, stop, tier.maxTimestamp, collisionCode, true);\n      retTier = appendTier(leftCrop, rightCrop);\n    } else {\n      const rightCrop = cropTier(tier, stop, tier.maxTimestamp, collisionCode, false);\n      retTier = takeTierUnion(leftCrop, rightCrop);\n    }\n  }\n  // erase region is either at the start or end of the textgrid\n  else {\n    if (start > tier.minTimestamp && stop >= tier.maxTimestamp) {\n      retTier = cropTier(tier, tier.minTimestamp, start, collisionCode, false);\n    } else if (start <= tier.minTimestamp && stop < tier.maxTimestamp) {\n      retTier = cropTier(tier, stop, tier.maxTimestamp, collisionCode, false);\n      if (doShrink === true) {\n        retTier = editTierTimestamps(retTier, -1 * stop, true);\n      }\n    } else {\n      retTier = copyTier(tier, {\n        entryList: []\n      });\n    }\n  }\n  if (doShrink !== true) {\n    retTier.minTimestamp = tier.minTimestamp;\n    retTier.maxTimestamp = tier.maxTimestamp;\n  }\n  return retTier;\n}\n\n/**\n * Inserts a blank region into a textgrid\n * @param {Textgrid} tg\n * @param {number} start\n * @param {number} duration - Note: every item that occurs after /start/ will be pushed back by /duration/ seconds.\n * @param {boolean} collisionCode - if /start/ occurs inside a labeled interval, this determines the behaviour.\n *  Must be one of 'stretch', 'split', or 'no change'\n *  'stretch' - stretches the interval by /duration/ amount\n *  'split' - splits the interval into two--everything to the\n            right of 'start' will be advanced by 'duration' seconds\n *  'no change' - leaves the interval as is with no change\n * @return {Textgrid} A copy of this textgrid with the inserted blank region.\n */\nfunction insertSpaceIntoTextgrid(tg, start, duration, collisionCode) {\n  const newTg = new Textgrid();\n  newTg.minTimestamp = tg.minTimestamp;\n  newTg.maxTimestamp = tg.maxTimestmap + duration;\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    let tier = tg.tierDict[tg.tierNameList[i]];\n    tier = insertSpaceIntoTier(tier, start, duration, collisionCode);\n    newTg.addTier(tier);\n  }\n  return newTg;\n}\n\n/**\n * Inserts a blank region into a tier\n * @param {TextgridTier} tier\n * @param {number} start\n * @param {number} duration - Note: every item that occurs after /start/ will be pushed back by /duration/ seconds.\n * @param {boolean} collisionCode - (unused parameter for point tiers) if /start/ occurs inside a labeled interval, this determines the behaviour.\n *  Must be one of 'stretch', 'split', or 'no change'\n *  'stretch' - stretches the interval by /duration/ amount\n *  'split' - splits the interval into two--everything to the\n            right of 'start' will be advanced by 'duration' seconds\n *  'no change' - leaves the interval as is with no change\n * @return {TextgridTier} A copy of this tier with the inserted blank region.\n */\nfunction insertSpaceIntoTier(tier, start, duration, collisionCode) {\n  let lengthenedTier;\n  if (tier instanceof PointTier) {\n    lengthenedTier = insertSpaceIntoPointTier(tier, start, duration, collisionCode);\n  } else if (tier instanceof IntervalTier) {\n    lengthenedTier = insertSpaceIntoIntervalTier(tier, start, duration, collisionCode);\n  }\n  return lengthenedTier;\n}\nfunction insertSpaceIntoPointTier(pointTier, start, duration, collisionCode) {\n  const newEntryList = [];\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const entry = pointTier.entryList[i];\n    if (entry[0] <= start) {\n      newEntryList.push(entry);\n    } else if (entry[0] > start) {\n      newEntryList.push([entry[0] + duration, entry[1]]);\n    }\n  }\n  return copyTier(pointTier, {\n    entryList: newEntryList,\n    maxTimestamp: pointTier.maxTimestamp + duration\n  });\n}\nfunction insertSpaceIntoIntervalTier(intervalTier, start, duration, collisionCode) {\n  const codeList = ['stretch', 'split', 'no change'];\n  if (!codeList.includes(collisionCode)) {\n    throw new IncorrectArgumentException(collisionCode, codeList);\n  }\n  const newEntryList = [];\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const [entryStart, entryStop, label] = intervalTier.entryList[i];\n    if (entryStop <= start) {\n      newEntryList.push([entryStart, entryStop, label]);\n    } else if (entryStart >= start) {\n      newEntryList.push([entryStart + duration, entryStop + duration, label]);\n    } else if (entryStart <= start && entryStop > start) {\n      if (collisionCode === 'stretch') {\n        newEntryList.push([entryStart, entryStop + duration, label]);\n      } else if (collisionCode === 'split') {\n        newEntryList.push([entryStart, start, label]);\n        newEntryList.push([start + duration, start + duration + (entryStop - start), label]);\n      } else if (collisionCode === 'no change') {\n        newEntryList.push([entryStart, entryStop, label]);\n      }\n    }\n  }\n  return copyTier(intervalTier, {\n    entryList: newEntryList,\n    maxTimestamp: intervalTier.maxTimestamp + duration\n  });\n}\n\n/**\n * Combine tiers in a textgrid.\n * @param {Textgrid} tg\n * @param {Array} [tierNameList=null] - The list of tier names to include in the merge.  If null, all tiers are merged.\n * @param {boolean} [preserveOtherTiers=true] - If true, keep tiers that were not merged.\n *  If false, the return textgrid will only have one merged tier for all interval tiers and one merged tier for all point tiers, if present.\n * @param {string} [intervalTierName='merged intervals']\n * @param {string} [pointTierName='merged points']\n * @return {Textgrid} A copy of the textgrid with the specified tiers merged.\n */\nfunction mergeTextgridTiers(tg, tierNameList = null, preserveOtherTiers = true, intervalTierName = 'merged intervals', pointTierName = 'merged points') {\n  if (tierNameList === null) {\n    tierNameList = tg.tierNameList;\n  }\n\n  // Determine the tiers to merge\n  const intervalTierNameList = [];\n  const pointTierNameList = [];\n  for (let i = 0; i < tierNameList.length; i++) {\n    const tierName = tierNameList[i];\n    const tier = tg.tierDict[tierName];\n    if (tier instanceof IntervalTier) {\n      intervalTierNameList.push(tierName);\n    } else if (tier instanceof PointTier) {\n      pointTierNameList.push(tierName);\n    }\n  }\n\n  // Merge the interval tiers\n  let intervalTier = null;\n  if (intervalTierNameList.length > 0) {\n    intervalTier = tg.tierDict[intervalTierNameList[0]];\n    for (let i = 1; i < intervalTierNameList.length; i++) {\n      intervalTier = takeTierUnion(intervalTier, tg.tierDict[intervalTierNameList[i]]);\n    }\n    intervalTier.name = intervalTierName;\n  }\n\n  // Merge the point tiers\n  let pointTier = null;\n  if (pointTierNameList.length > 0) {\n    pointTier = tg.tierDict[pointTierNameList[0]];\n    for (let i = 1; i < pointTierNameList.length; i++) {\n      pointTier = takeTierUnion(pointTier, tg.tierDict[pointTierNameList[i]]);\n    }\n    pointTier.name = pointTierName;\n  }\n\n  // Add unmerged tiers\n  const tierNamesToKeep = [];\n  if (preserveOtherTiers === true) {\n    for (let i = 0; i < tg.tierNameList.length; i++) {\n      const currTierName = tg.tierNameList[i];\n      if (!tierNameList.includes(currTierName)) tierNamesToKeep.push(currTierName);\n    }\n  }\n\n  // Create the final textgrid to output\n  const retTg = new Textgrid();\n  if (intervalTier !== null) retTg.addTier(intervalTier);\n  if (pointTier !== null) retTg.addTier(pointTier);\n  for (let i = 0; i < tierNamesToKeep.length; i++) {\n    retTg.addTier(tg.tierDict[tierNamesToKeep[i]]);\n  }\n  retTg.minTimestamp = tg.minTimestamp;\n  retTg.maxTimestamp = tg.maxTimestamp;\n  return retTg;\n}\n\n/**\n * Takes the set union of two tiers.\n * All the entries in the second tier will be added to the first.\n * Overlapping entries will be merged together.\n * @params {TextgridTier} tier1 - the base tier\n * @params {TextgridTier} tier2 - the tier to union into the base tier\n * @return {TextgridTier}\n */\nfunction takeTierUnion(tier1, tier2) {\n  const retTier = copyTier(tier1);\n  for (let i = 0; i < tier2.entryList.length; i++) {\n    retTier.insertEntry(tier2.entryList[i], false, 'merge');\n  }\n  retTier.sort();\n  return retTier;\n}\n\n/**\n * Takes the set difference of this tier and the given one.\n * Any overlapping portions of entries with entries in this textgrid\n * will be removed from the returned tier.\n * @params {TextgridTier} tier1 - the base tier\n * @params {TextgridTier} tier2 - the tier to take the difference of with the base tier\n * @return {TextgridTier}\n */\nfunction takeIntervalTierDifference(tier1, tier2) {\n  let retTier = copyTier(tier1);\n  for (let i = 0; i < tier2.entryList.length; i++) {\n    const entry = tier2.entryList[i];\n    retTier = eraseRegionFromTier(retTier, entry[0], entry[1], false, 'truncated');\n  }\n  return retTier;\n}\n\n/**\n * Takes the set intersection of this tier and the given one.\n * Only intervals that exist in both tiers will remain in the\n * returned tier.  If intervals partially overlap, only the overlapping\n * portion will be returned.\n * @params {TextgridTier} tier1 - the base tier\n * @params {TextgridTier} tier2 - the tier to intersect the base tier with\n * @return {TextgridTier}\n */\nfunction takeIntervalTierIntersection(tier1, tier2) {\n  let newEntryList = [];\n  for (let i = 0; i < tier1.entryList.length; i++) {\n    const entry = tier1.entryList[i];\n    const subTier = cropTier(tier2, entry[0], entry[1], 'truncated', false);\n\n    // Combine the labels in the two tiers\n    const stub = entry[2] + '-';\n    const subEntryList = subTier.entryList.map(subEntry => [subEntry[0], subEntry[1], stub + subEntry[2]]);\n    newEntryList = newEntryList.concat(subEntryList);\n  }\n  const name = tier1.name + '-' + tier2.name;\n  const retTier = copyTier(tier1, {\n    name: name,\n    entryList: newEntryList\n  });\n  return retTier;\n}\nexport {\n// functions that modify\nappendTextgrid, appendTier, cropTextgrid, cropTier, editTextgridTimestamps, editTierTimestamps, eraseRegionFromTextgrid, eraseRegionFromTier, insertSpaceIntoTextgrid, insertSpaceIntoTier, mergeTextgridTiers, takeTierUnion, takeIntervalTierDifference, takeIntervalTierIntersection,\n// exceptions\nNonMatchingTiersException, OvershootModificationException, IncorrectArgumentException };","map":{"version":3,"names":["Textgrid","IntervalTier","PointTier","copyTier","NonMatchingTiersException","Error","OvershootModificationException","constructor","tierName","oldEntry","newEntry","min","max","args","message","IncorrectArgumentException","value","targetValueList","appendTextgrid","tg1","tg2","onlyMatchingNames","combinedTierNameList","tierNameList","slice","i","length","includes","push","finalTierNameList","retTg","minTimestamp","maxTimestamp","tier","tierDict","addTier","editTierTimestamps","combinedTier","combinedEntryList","entryList","concat","replaceTier","appendTier","tier1","tier2","tierType","minTime","maxTime","name","cropTextgrid","tg","cropStart","cropEnd","mode","rebaseToZero","newTG","minT","maxT","newTier","cropTier","croppedTier","cropPointTier","cropIntervalTier","pointTier","newEntryList","timestamp","map","entry","subTier","intervalTier","matchedEntry","intervalStart","intervalEnd","intervalLabel","editTextgridTimestamps","offset","allowOvershoot","editedTg","editedTier","editPointTierTimestamps","editIntervalTierTimestamps","newTime","newTimeList","newMin","Math","newMax","newStart","newStop","eraseRegionFromTextgrid","start","stop","doShrink","duration","newTg","eraseRegionFromTier","collisionCode","retTier","codeList","leftCrop","rightCrop","takeTierUnion","insertSpaceIntoTextgrid","maxTimestmap","insertSpaceIntoTier","lengthenedTier","insertSpaceIntoPointTier","insertSpaceIntoIntervalTier","entryStart","entryStop","label","mergeTextgridTiers","preserveOtherTiers","intervalTierName","pointTierName","intervalTierNameList","pointTierNameList","tierNamesToKeep","currTierName","insertEntry","sort","takeIntervalTierDifference","takeIntervalTierIntersection","stub","subEntryList","subEntry"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/praatio/lib/textgrid_modifiers.js"],"sourcesContent":["/**\n * This module contains the methods that take one or more\n * tiers or textgrids and returns a modified result.<br /><br />\n *\n * @author Tim Mahrt\n * @since March 25, 2015\n * @module textgrid_modifiers\n */\n\nimport {\n  Textgrid, IntervalTier, PointTier,\n  copyTier\n} from './textgrid.js';\n\nclass NonMatchingTiersException extends Error {};\n\nclass OvershootModificationException extends Error {\n  constructor (tierName, oldEntry, newEntry, min, max, ...args) {\n    super(...args);\n    this.tierName = tierName;\n    this.oldEntry = oldEntry;\n    this.newEntry = newEntry;\n    this.min = min;\n    this.max = max;\n    this.message = `Attempted to change [${oldEntry}] to [${newEntry}] in tier '${tierName}' however, this exceeds the bounds (${min},${max}).`;\n  }\n};\n\nclass IncorrectArgumentException extends Error {\n  constructor (value, targetValueList, ...args) {\n    super(...args);\n    this.value = value;\n    this.targetValueList = targetValueList;\n    this.message = `Expected value '${this.value}' to be one value in [${this.targetValueList}].`\n  }\n}\n\n/**\n * Append one textgrid to the end of this one\n * @param {Textgrid} tg1 - the source textgrid\n * @param {Textgrid} tg2 - the textgrid to add on\n * @param {boolean} [onlyMatchingNames=true] - only include tiers that appear in both textgrids\n * @return {Textgrid}\n */\nfunction appendTextgrid (tg1, tg2, onlyMatchingNames = true) {\n  // Get all tier names with no duplicates.  Ordered first by\n  // this textgrid and then by the other textgrid.\n  const combinedTierNameList = tg1.tierNameList.slice(0);\n  for (let i = 0; i < tg2.tierNameList.length; i++) {\n    const tierName = tg2.tierNameList[i];\n    if (!combinedTierNameList.includes(tierName)) {\n      combinedTierNameList.push(tierName);\n    }\n  }\n\n  // Determine the tier names that will be in the final textgrid\n  let finalTierNameList = [];\n  if (onlyMatchingNames === false) {\n    finalTierNameList = combinedTierNameList;\n  }\n  else {\n    for (let i = 0; i < tg2.tierNameList.length; i++) {\n      const tierName = tg2.tierNameList[i];\n      if (tg1.tierNameList.includes(tierName) && tg2.tierNameList.includes(tierName)) {\n        finalTierNameList.push(tierName);\n      }\n    }\n  }\n\n  // Add tiers from this textgrid\n  const retTg = new Textgrid();\n  const minTimestamp = tg1.minTimestamp\n  const maxTimestamp = tg1.maxTimestamp + tg2.maxTimestamp\n  for (let i = 0; i < finalTierNameList.length; i++) {\n    const tierName = finalTierNameList[i];\n    if (!tg1.tierNameList.includes(tierName)) continue;\n\n    let tier = tg1.tierDict[tierName];\n    tier = copyTier(tier, { minTimestamp: minTimestamp, maxTimestamp: maxTimestamp });\n    retTg.addTier(tier);\n  }\n\n  // Add tiers from the other textgrid\n  for (let i = 0; i < finalTierNameList.length; i++) {\n    const tierName = finalTierNameList[i];\n    if (!tg2.tierNameList.includes(tierName)) continue;\n\n    let tier = tg2.tierDict[tierName];\n    tier = copyTier(tier, { minTimestamp: minTimestamp, maxTimestamp: maxTimestamp });\n    tier = editTierTimestamps(tier, tg1.maxTimestamp);\n\n    if (!retTg.tierNameList.includes(tierName)) {\n      retTg.addTier(tier);\n    }\n    else {\n      let combinedTier = retTg.tierDict[tierName];\n      let combinedEntryList = combinedTier.entryList;\n      combinedEntryList = combinedEntryList.concat(tier.entryList);\n\n      combinedTier = copyTier(combinedTier, { entryList: combinedEntryList });\n      retTg.replaceTier(tierName, combinedTier);\n    }\n  }\n  return retTg;\n}\n\n/**\n * Add one tier to the end of another\n * @param {TextgridTier} tier1 - the base tier\n * @param {TextgridTier} tier2 - the tier to add\n * @return {TextgridTier}\n */\nfunction appendTier (tier1, tier2) {\n  if (tier1.tierType !== tier2.tierType) {\n    throw new NonMatchingTiersException('Tier types must match when appending tiers.');\n  }\n  const minTime = tier1.minTimestamp;\n  const maxTime = tier1.maxTimestamp + tier2.maxTimestamp;\n\n  const appendTier = editTierTimestamps(tier2, tier1.maxTimestamp, true);\n  const entryList = tier1.entryList.concat(appendTier.entryList);\n\n  return copyTier(\n    tier1,\n    {\n      name: tier1.name,\n      entryList: entryList,\n      minTimestamp: minTime,\n      maxTimestamp: maxTime\n    }\n  );\n}\n\n/**\n * Creates a textgrid that only contains intervals from the crop region\n * @param {Textgrid} tg\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} mode - one of 'strict', 'lax', or 'truncated'\n *  If 'strict', only intervals wholly contained by the crop interval will be kept.\n *  If 'lax', partially contained intervals will be kept.\n *  If 'truncated', partially contained intervals will be truncated to fit within the crop region.\n * @param {boolean} rebaseToZero - if true, the all times in entries will be subtracted by the cropStart\n * @return {Textgrid} A new textgrid containing only entries that appear in the crop region.\n */\nfunction cropTextgrid (tg, cropStart, cropEnd, mode, rebaseToZero) {\n  const newTG = new Textgrid();\n\n  let minT = cropStart;\n  let maxT = cropEnd;\n  if (rebaseToZero === true) {\n    minT = 0;\n    maxT = cropEnd - cropStart;\n  }\n\n  newTG.minTimestamp = minT;\n  newTG.maxTimestamp = maxT;\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    const tier = tg.tierDict[tierName];\n    const newTier = cropTier(tier, cropStart, cropEnd, mode, rebaseToZero);\n    newTG.addTier(newTier);\n  }\n\n  return newTG;\n}\n\n/**\n * Creates a new tier containing only entries from inside the crop interval\n * @param {TextgridTier} tier\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} mode - mode is ignored.  This parameter is kept for compatibility with IntervalTier.crop()\n * @param {boolean} rebaseToZero - if true, all times will be subtracted by cropStart\n * @return {TextgridTier} Returns a copy of this tier with only values from the crop region.\n */\nfunction cropTier (tier, cropStart, cropEnd, mode, rebaseToZero) {\n  let croppedTier;\n  if (tier instanceof PointTier) {\n    croppedTier = cropPointTier(tier, cropStart, cropEnd, mode, rebaseToZero);\n  }\n  else if (tier instanceof IntervalTier) {\n    croppedTier = cropIntervalTier(tier, cropStart, cropEnd, mode, rebaseToZero);\n  }\n  return croppedTier;\n}\n\n/**\n * Creates a new tier containing only entries from inside the crop interval\n * @param {PointTier} pointTier\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} mode - mode is ignored.  This parameter is kept for compatibility with IntervalTier.crop()\n * @param {boolean} rebaseToZero - if true, all times will be subtracted by cropStart\n * @return {PointTier} Returns a copy of this tier with only values from the crop region.\n */\nfunction cropPointTier (pointTier, cropStart, cropEnd, mode, rebaseToZero) {\n  let newEntryList = [];\n\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const timestamp = pointTier.entryList[i][0];\n    if (timestamp >= cropStart && timestamp <= cropEnd) newEntryList.push(pointTier.entryList[i]);\n  }\n\n  let minT = cropStart;\n  let maxT = cropEnd;\n  if (rebaseToZero === true) {\n    newEntryList = newEntryList.map(entry => [entry[0] - cropStart, entry[1]]);\n    minT = 0;\n    maxT = cropEnd - cropStart;\n  }\n\n  const subTier = new PointTier(pointTier.name, newEntryList, minT, maxT);\n  return subTier;\n}\n\n/**\n * Creates a new tier with only the entries from the crop region\n * @param {number} cropStart\n * @param {number} cropEnd\n * @param {string} number - one of 'strict', 'lax', or 'truncated'\n    If 'strict', only intervals wholly contained by the crop interval will be kept.\n    If 'lax', partially contained intervals will be kept.\n    If 'truncated', partially contained intervals will be\n        truncated to fit within the crop region.\n * @param {boolean} rebaseToZero - if true the cropped textgrid values will be subtracted by cropStart\n * @return {Textgrid} A copy of this tier with only entries from the crop region\n */\nfunction cropIntervalTier (intervalTier, cropStart, cropEnd, mode, rebaseToZero) {\n  let newEntryList = [];\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const entry = intervalTier.entryList[i];\n    let matchedEntry = null;\n\n    const intervalStart = entry[0];\n    const intervalEnd = entry[1];\n    const intervalLabel = entry[2];\n\n    // Don't need to investigate if the interval is before or after\n    // the crop region\n    if (intervalEnd <= cropStart || intervalStart >= cropEnd) continue;\n\n    // Determine if the current subEntry is wholly contained\n    // within the superEntry\n    if (intervalStart >= cropStart && intervalEnd <= cropEnd) {\n      matchedEntry = entry;\n    }\n\n    // If it is only partially contained within the superEntry AND\n    // inclusion is 'lax', include it anyways\n    else if (mode === 'lax' && (intervalStart >= cropStart || intervalEnd <= cropEnd)) {\n      matchedEntry = entry;\n    }\n\n    // If not strict, include partial tiers on the edges\n    // -- regardless, record how much information was lost\n    //        - for strict=true, the total time of the cut interval\n    //        - for strict=false, the portion of the interval that lies\n    //            outside the new interval\n\n    // The current interval straddles the end of the new interval\n    else if (intervalStart >= cropStart && intervalEnd > cropEnd) {\n      if (mode === 'truncated') {\n        matchedEntry = [intervalStart, cropEnd, intervalLabel];\n      }\n    }\n\n    // The current interval straddles the start of the new interval\n    else if (intervalStart < cropStart && intervalEnd <= cropEnd) {\n      if (mode === 'truncated') {\n        matchedEntry = [cropStart, intervalEnd, intervalLabel];\n      }\n    }\n\n    // The current interval contains the new interval completely\n    else if (intervalStart <= cropStart && intervalEnd >= cropEnd) {\n      if (mode === 'lax') {\n        matchedEntry = entry;\n      } else if (mode === 'truncated') {\n        matchedEntry = [cropStart, cropEnd, intervalLabel];\n      }\n    }\n\n    if (matchedEntry !== null) {\n      newEntryList.push(matchedEntry);\n    }\n  }\n\n  let minT = cropStart;\n  let maxT = cropEnd;\n  if (rebaseToZero === true) {\n    newEntryList = newEntryList.map(entryList => [entryList[0] - cropStart,\n      entryList[1] - cropStart,\n      entryList[2]\n    ]);\n    minT = 0;\n    maxT = cropEnd - cropStart;\n  }\n\n  // Create subtier\n  const croppedTier = new IntervalTier(intervalTier.name, newEntryList, minT, maxT);\n\n  return croppedTier;\n}\n\n/**\n * Modifies all timestamps in the Textgrid and in the contained tiers by a constant amount\n * @param {Textgrid} tg\n * @param {number} offset - the amount to modify all timestamps by\n * @param {boolean} [allowOvershoot=false] - if false and offset pushes a value past maxTimestamp, throw an error; otherwise, lengthen the textgrid\n * @return {Textgrid}\n */\nfunction editTextgridTimestamps (tg, offset, allowOvershoot = false) {\n  const editedTg = new Textgrid();\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    let tier = tg.tierDict[tg.tierNameList[i]];\n    tier = editTierTimestamps(tier, offset, allowOvershoot);\n    editedTg.addTier(tier);\n  }\n  return editedTg;\n}\n\n/**\n * Modifies all timestamps by a constant amount\n * @param {TextgridTier} tier\n * @param {number} offset\n * @param {boolean} [allowOvershoot=false] - if false and offset pushes a value past maxTimestamp, throw an error; otherwise, lengthen the tier\n * @return {TextgridTier}\n */\nfunction editTierTimestamps (tier, offset, allowOvershoot = false) {\n  let editedTier;\n  if (tier instanceof PointTier) {\n    editedTier = editPointTierTimestamps(tier, offset, allowOvershoot);\n  }\n  else if (tier instanceof IntervalTier) {\n    editedTier = editIntervalTierTimestamps(tier, offset, allowOvershoot);\n  }\n  return editedTier;\n}\n\nfunction editPointTierTimestamps (pointTier, offset, allowOvershoot = false) {\n  const newEntryList = []\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const entry = pointTier.entryList[i];\n    const newTime = entry[0] + offset;\n    const newEntry = [newTime, entry[1]];\n\n    if (allowOvershoot === false) {\n      if (newTime < pointTier.minTimestamp || newTime > pointTier.maxTimestamp) {\n        throw new OvershootModificationException(pointTier.name, entry, newEntry, pointTier.minTimestamp, pointTier.maxTimestamp);\n      }\n    }\n\n    newEntryList.push(newEntry);\n  }\n\n  const newTimeList = newEntryList.map(entry => entry[0]);\n  let newMin = Math.min(...newTimeList);\n  let newMax = Math.max(...newTimeList);\n\n  if (pointTier.minTimestamp < newMin) newMin = pointTier.minTimestamp;\n  if (pointTier.maxTimestamp > newMax) newMax = pointTier.maxTimestamp;\n\n  return new PointTier(pointTier.name, newEntryList, newMin, newMax);\n}\n\nfunction editIntervalTierTimestamps (intervalTier, offset, allowOvershoot = false) {\n  const newEntryList = []\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const entry = intervalTier.entryList[i];\n    const newStart = entry[0] + offset;\n    const newStop = entry[1] + offset;\n    const newEntry = [newStart, newStop, entry[2]];\n\n    if (allowOvershoot === false) {\n      if (newStart < intervalTier.minTimestamp || newStop > intervalTier.maxTimestamp) {\n        throw new OvershootModificationException(intervalTier.name, entry, newEntry, intervalTier.minTimestamp, intervalTier.maxTimestamp);\n      }\n    }\n\n    newEntryList.push(newEntry);\n  }\n\n  let newMin = Math.min(...newEntryList.map(entry => entry[0]));\n  let newMax = Math.max(...newEntryList.map(entry => entry[1]));\n\n  if (intervalTier.minTimestamp < newMin) newMin = intervalTier.minTimestamp;\n  if (intervalTier.maxTimestamp > newMax) newMax = intervalTier.maxTimestamp;\n\n  return new IntervalTier(intervalTier.name, newEntryList, newMin, newMax);\n}\n\n/**\n * Makes a region in all tiers blank (removes all contained entries)\n * @param {TextgridTier} tg\n * @param {number} start\n * @param {number} stop\n * @param {boolean} doShrink - if true, all values after the erase region will be shifted earlier in time by (stop - start) seconds\n * @return {TextgridTier} A copy of this textgrid without entries in the specified region.\n */\nfunction eraseRegionFromTextgrid (tg, start, stop, doShrink) {\n  const duration = stop - start;\n  let maxTimestamp = tg.maxTimestamp;\n  if (doShrink === true) maxTimestamp -= duration;\n\n  const newTg = new Textgrid();\n  newTg.minTimestamp = tg.minTimestamp;\n  newTg.maxTimestamp = maxTimestamp;\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    let tier = tg.tierDict[tg.tierNameList[i]];\n    tier = eraseRegionFromTier(tier, start, stop, doShrink, 'truncated');\n    newTg.addTier(tier);\n  }\n  return newTg;\n}\n\n/**\n * Makes a region in a tier blank (removes all contained entries)\n * @param {TextgridTier} tier\n * @param {number} start\n * @param {number} stop\n * @param {boolean} doShrink - if true, all values after the erase region will be shifted earlier in time by (stop - start) seconds\n * @return {TextgridTier} A copy of this tier without entries in the specified region.\n */\nfunction eraseRegionFromTier (tier, start, stop, doShrink, collisionCode) {\n  let retTier;\n\n  const codeList = ['strict', 'truncated'];\n  if (!codeList.includes(collisionCode)) {\n    throw new IncorrectArgumentException(collisionCode, codeList);\n  }\n\n  // erase region is in the middle of the textgrid\n  if (start > tier.minTimestamp && stop < tier.maxTimestamp) {\n    const leftCrop = cropTier(tier, tier.minTimestamp, start, collisionCode, false);\n\n    if (doShrink === true) {\n      const rightCrop = cropTier(tier, stop, tier.maxTimestamp, collisionCode, true);\n      retTier = appendTier(leftCrop, rightCrop);\n    }\n    else {\n      const rightCrop = cropTier(tier, stop, tier.maxTimestamp, collisionCode, false);\n      retTier = takeTierUnion(leftCrop, rightCrop);\n    }\n  }\n  // erase region is either at the start or end of the textgrid\n  else {\n    if (start > tier.minTimestamp && stop >= tier.maxTimestamp) {\n      retTier = cropTier(tier, tier.minTimestamp, start, collisionCode, false);\n    }\n    else if (start <= tier.minTimestamp && stop < tier.maxTimestamp) {\n      retTier = cropTier(tier, stop, tier.maxTimestamp, collisionCode, false);\n      if (doShrink === true) {\n        retTier = editTierTimestamps(retTier, -1 * stop, true);\n      }\n    }\n    else {\n      retTier = copyTier(tier, { entryList: [] });\n    }\n  }\n\n  if (doShrink !== true) {\n    retTier.minTimestamp = tier.minTimestamp;\n    retTier.maxTimestamp = tier.maxTimestamp;\n  }\n  return retTier;\n}\n\n/**\n * Inserts a blank region into a textgrid\n * @param {Textgrid} tg\n * @param {number} start\n * @param {number} duration - Note: every item that occurs after /start/ will be pushed back by /duration/ seconds.\n * @param {boolean} collisionCode - if /start/ occurs inside a labeled interval, this determines the behaviour.\n *  Must be one of 'stretch', 'split', or 'no change'\n *  'stretch' - stretches the interval by /duration/ amount\n *  'split' - splits the interval into two--everything to the\n            right of 'start' will be advanced by 'duration' seconds\n *  'no change' - leaves the interval as is with no change\n * @return {Textgrid} A copy of this textgrid with the inserted blank region.\n */\nfunction insertSpaceIntoTextgrid (tg, start, duration, collisionCode) {\n  const newTg = new Textgrid();\n  newTg.minTimestamp = tg.minTimestamp;\n  newTg.maxTimestamp = tg.maxTimestmap + duration;\n\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    let tier = tg.tierDict[tg.tierNameList[i]];\n    tier = insertSpaceIntoTier(tier, start, duration, collisionCode);\n    newTg.addTier(tier);\n  }\n\n  return newTg;\n}\n\n/**\n * Inserts a blank region into a tier\n * @param {TextgridTier} tier\n * @param {number} start\n * @param {number} duration - Note: every item that occurs after /start/ will be pushed back by /duration/ seconds.\n * @param {boolean} collisionCode - (unused parameter for point tiers) if /start/ occurs inside a labeled interval, this determines the behaviour.\n *  Must be one of 'stretch', 'split', or 'no change'\n *  'stretch' - stretches the interval by /duration/ amount\n *  'split' - splits the interval into two--everything to the\n            right of 'start' will be advanced by 'duration' seconds\n *  'no change' - leaves the interval as is with no change\n * @return {TextgridTier} A copy of this tier with the inserted blank region.\n */\nfunction insertSpaceIntoTier (tier, start, duration, collisionCode) {\n  let lengthenedTier;\n  if (tier instanceof PointTier) {\n    lengthenedTier = insertSpaceIntoPointTier(tier, start, duration, collisionCode);\n  }\n  else if (tier instanceof IntervalTier) {\n    lengthenedTier = insertSpaceIntoIntervalTier(tier, start, duration, collisionCode);\n  }\n  return lengthenedTier;\n}\n\nfunction insertSpaceIntoPointTier (pointTier, start, duration, collisionCode) {\n  const newEntryList = [];\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const entry = pointTier.entryList[i];\n    if (entry[0] <= start) {\n      newEntryList.push(entry);\n    }\n    else if (entry[0] > start) {\n      newEntryList.push([entry[0] + duration, entry[1]])\n    }\n  }\n\n  return copyTier(pointTier, { entryList: newEntryList, maxTimestamp: pointTier.maxTimestamp + duration })\n}\n\nfunction insertSpaceIntoIntervalTier (intervalTier, start, duration, collisionCode) {\n  const codeList = ['stretch', 'split', 'no change']\n  if (!codeList.includes(collisionCode)) {\n    throw new IncorrectArgumentException(collisionCode, codeList);\n  }\n\n  const newEntryList = [];\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const [entryStart, entryStop, label] = intervalTier.entryList[i];\n    if (entryStop <= start) {\n      newEntryList.push([entryStart, entryStop, label])\n    }\n    else if (entryStart >= start) {\n      newEntryList.push([entryStart + duration, entryStop + duration, label])\n    }\n    else if (entryStart <= start && entryStop > start) {\n      if (collisionCode === 'stretch') {\n        newEntryList.push([entryStart, entryStop + duration, label])\n      }\n      else if (collisionCode === 'split') {\n        newEntryList.push([entryStart, start, label])\n        newEntryList.push([start + duration, start + duration + (entryStop - start), label])\n      }\n      else if (collisionCode === 'no change') {\n        newEntryList.push([entryStart, entryStop, label])\n      }\n    }\n  }\n\n  return copyTier(intervalTier, { entryList: newEntryList, maxTimestamp: intervalTier.maxTimestamp + duration })\n}\n\n/**\n * Combine tiers in a textgrid.\n * @param {Textgrid} tg\n * @param {Array} [tierNameList=null] - The list of tier names to include in the merge.  If null, all tiers are merged.\n * @param {boolean} [preserveOtherTiers=true] - If true, keep tiers that were not merged.\n *  If false, the return textgrid will only have one merged tier for all interval tiers and one merged tier for all point tiers, if present.\n * @param {string} [intervalTierName='merged intervals']\n * @param {string} [pointTierName='merged points']\n * @return {Textgrid} A copy of the textgrid with the specified tiers merged.\n */\nfunction mergeTextgridTiers (tg, tierNameList = null, preserveOtherTiers = true, intervalTierName = 'merged intervals', pointTierName = 'merged points') {\n  if (tierNameList === null) {\n    tierNameList = tg.tierNameList;\n  }\n\n  // Determine the tiers to merge\n  const intervalTierNameList = [];\n  const pointTierNameList = [];\n  for (let i = 0; i < tierNameList.length; i++) {\n    const tierName = tierNameList[i];\n    const tier = tg.tierDict[tierName];\n    if (tier instanceof IntervalTier) {\n      intervalTierNameList.push(tierName);\n    }\n    else if (tier instanceof PointTier) {\n      pointTierNameList.push(tierName);\n    }\n  }\n\n  // Merge the interval tiers\n  let intervalTier = null;\n  if (intervalTierNameList.length > 0) {\n    intervalTier = tg.tierDict[intervalTierNameList[0]];\n    for (let i = 1; i < intervalTierNameList.length; i++) {\n      intervalTier = takeTierUnion(intervalTier, tg.tierDict[intervalTierNameList[i]]);\n    }\n    intervalTier.name = intervalTierName;\n  }\n\n  // Merge the point tiers\n  let pointTier = null;\n  if (pointTierNameList.length > 0) {\n    pointTier = tg.tierDict[pointTierNameList[0]];\n    for (let i = 1; i < pointTierNameList.length; i++) {\n      pointTier = takeTierUnion(pointTier, tg.tierDict[pointTierNameList[i]]);\n    }\n    pointTier.name = pointTierName;\n  }\n\n  // Add unmerged tiers\n  const tierNamesToKeep = []\n  if (preserveOtherTiers === true) {\n    for (let i = 0; i < tg.tierNameList.length; i++) {\n      const currTierName = tg.tierNameList[i];\n      if (!tierNameList.includes(currTierName)) tierNamesToKeep.push(currTierName);\n    }\n  }\n\n  // Create the final textgrid to output\n  const retTg = new Textgrid();\n  if (intervalTier !== null) retTg.addTier(intervalTier);\n  if (pointTier !== null) retTg.addTier(pointTier);\n\n  for (let i = 0; i < tierNamesToKeep.length; i++) {\n    retTg.addTier(tg.tierDict[tierNamesToKeep[i]]);\n  }\n\n  retTg.minTimestamp = tg.minTimestamp;\n  retTg.maxTimestamp = tg.maxTimestamp;\n\n  return retTg;\n}\n\n/**\n * Takes the set union of two tiers.\n * All the entries in the second tier will be added to the first.\n * Overlapping entries will be merged together.\n * @params {TextgridTier} tier1 - the base tier\n * @params {TextgridTier} tier2 - the tier to union into the base tier\n * @return {TextgridTier}\n */\nfunction takeTierUnion (tier1, tier2) {\n  const retTier = copyTier(tier1);\n\n  for (let i = 0; i < tier2.entryList.length; i++) {\n    retTier.insertEntry(tier2.entryList[i], false, 'merge');\n  }\n\n  retTier.sort();\n  return retTier;\n}\n\n/**\n * Takes the set difference of this tier and the given one.\n * Any overlapping portions of entries with entries in this textgrid\n * will be removed from the returned tier.\n * @params {TextgridTier} tier1 - the base tier\n * @params {TextgridTier} tier2 - the tier to take the difference of with the base tier\n * @return {TextgridTier}\n */\nfunction takeIntervalTierDifference (tier1, tier2) {\n  let retTier = copyTier(tier1);\n\n  for (let i = 0; i < tier2.entryList.length; i++) {\n    const entry = tier2.entryList[i];\n    retTier = eraseRegionFromTier(retTier, entry[0], entry[1], false, 'truncated');\n  }\n\n  return retTier;\n}\n\n/**\n * Takes the set intersection of this tier and the given one.\n * Only intervals that exist in both tiers will remain in the\n * returned tier.  If intervals partially overlap, only the overlapping\n * portion will be returned.\n * @params {TextgridTier} tier1 - the base tier\n * @params {TextgridTier} tier2 - the tier to intersect the base tier with\n * @return {TextgridTier}\n */\nfunction takeIntervalTierIntersection (tier1, tier2) {\n  let newEntryList = [];\n  for (let i = 0; i < tier1.entryList.length; i++) {\n    const entry = tier1.entryList[i];\n    const subTier = cropTier(tier2, entry[0], entry[1], 'truncated', false);\n\n    // Combine the labels in the two tiers\n    const stub = entry[2] + '-';\n    const subEntryList = subTier.entryList.map((subEntry) => [subEntry[0], subEntry[1], stub + subEntry[2]]);\n    newEntryList = newEntryList.concat(subEntryList);\n  }\n  const name = tier1.name + '-' + tier2.name;\n  const retTier = copyTier(tier1, { name: name, entryList: newEntryList });\n  return retTier;\n}\n\nexport {\n  // functions that modify\n  appendTextgrid, appendTier,\n  cropTextgrid, cropTier,\n  editTextgridTimestamps, editTierTimestamps,\n  eraseRegionFromTextgrid, eraseRegionFromTier,\n  insertSpaceIntoTextgrid, insertSpaceIntoTier,\n  mergeTextgridTiers,\n  takeTierUnion, takeIntervalTierDifference, takeIntervalTierIntersection,\n  // exceptions\n  NonMatchingTiersException, OvershootModificationException, IncorrectArgumentException\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}