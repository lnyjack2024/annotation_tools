{"ast":null,"code":"import { action, makeObservable, observable, toJS } from 'mobx';\nimport { cloneDeep, isEqual } from 'lodash';\nimport { message } from 'antd';\nimport OntologyStore from './OntologyStore';\nimport ConfigStore from './ConfigStore';\nimport FrameStore from './FrameStore';\nimport InstanceStore from './InstanceStore';\nimport RelationshipStore from './RelationshipStore';\nimport ShapeStore from './ShapeStore';\nimport SegmentationStore from './SegmentationStore';\nimport UndoStore from './UndoStore';\nimport ValidationStore from './ValidationStore';\nimport ReviewsStore from './ReviewStore';\nimport FilterStore from './FilterStore';\nimport GridStore from './GridStore';\nimport ThumbnailStore from './ThumbnailStore';\nimport NIFTIStore from './NIFTIStore';\nimport i18n from '../locales';\nimport { loadInstancesFromResult, getToolTypeFromFrameData } from '../utils';\nimport { ViewMode, Tool, ReviewMode, ShapeModifyType } from '../types';\nimport { ShapeType } from '../../common/shapes/types';\nimport { ShapeRotateMode } from '../../common/shapes/Shape';\nimport StatsTracker from '../../../libs/StatsTracker';\nimport TrackWorker from '../worker/stats-track.worker';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, isTemplatePreview, ToolMode, isAudit } from '../../../utils/tool-mode';\nimport { fetchResultByUrl, removeUndefinedKeys } from '../../../utils';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy.toolMode) || this.config.reviewMode === ReviewMode.REVIEW || this.config.previewMode;\n  }\n\n  /**\n   * is tool annotate allowed\n   */\n  get annotatable() {\n    return !isAnnotationReadonly(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in labeling mode or template preview mode\n   */\n  get isLabeling() {\n    return this.jobProxy.toolMode === ToolMode.LABELING || this.isTemplatePreview;\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in audit mode\n   */\n  get isAudit() {\n    return isAudit(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in template preview mode\n   */\n  get isTemplatePreview() {\n    return isTemplatePreview(this.jobProxy.toolMode);\n  }\n  constructor() {\n    this.ontology = void 0;\n    this.config = void 0;\n    this.frame = void 0;\n    this.instance = void 0;\n    this.relationship = void 0;\n    this.shape = void 0;\n    this.segmentation = void 0;\n    this.undo = void 0;\n    this.validation = void 0;\n    this.review = void 0;\n    this.filter = void 0;\n    this.grid = void 0;\n    this.thumbnail = void 0;\n    this.nifti = void 0;\n    /**\n     * job proxy\n     */\n    this.jobProxy = void 0;\n    /**\n     * stats tracker\n     */\n    this.statsTracker = void 0;\n    /**\n     * resource proxy\n     */\n    this.resourceProxy = void 0;\n    /**\n     * initial data copy\n     */\n    this.initialData = null;\n    /**\n     * initial result link\n     */\n    this.initialLink = '';\n    /**\n     * is tool initialized\n     */\n    this.initialized = false;\n    /**\n     * when screenfull requested\n     */\n    this.fullscreenRequested = false;\n    /**\n     * current mouse position on canvas\n     */\n    this.currPosition = void 0;\n    /**\n     * copied shape info\n     */\n    this.copiedShapeInfo = void 0;\n    /**\n     * proxy resource url\n     * @param resource\n     */\n    this.proxyResource = resource => {\n      if (this.resourceProxy && resource) {\n        return `${this.resourceProxy}?url=${resource}`;\n      }\n      return resource;\n    };\n    /**\n     * get instance statistics\n     */\n    this.getInstanceStatistics = (submit = false) => {\n      const {\n        categories\n      } = this.ontology;\n      const data = {\n        elements: [],\n        categories: categories.map(({\n          className\n        }) => className),\n        shapes: new Set(),\n        summary: {},\n        frameCount: this.frame.frameCount,\n        validFrames: new Set(),\n        annotatedFrames: new Set(),\n        instanceCount: 0,\n        distinctInstanceCount: 0,\n        pixelCount: 0,\n        pixelInnerPolygonCount: 0,\n        pixelOuterPolygonCount: 0\n      };\n      /**\n       * modified elements (by tool type)\n       */\n      const modifiedElements = {};\n      /**\n       * modified frames\n       */\n      const modifiedFrames = new Set();\n      /**\n       * current existing instance ids\n       */\n      const existingInstanceIds = [];\n      /**\n       * update modified stat by modify type\n       * @param type\n       * @param shape\n       * @param frameIndex\n       */\n      const updateModifiedStat = (type, shape, frameIndex) => {\n        if (!modifiedElements[`${shape}`]) {\n          modifiedElements[`${shape}`] = {\n            shape,\n            count: 0,\n            create: 0,\n            update: 0,\n            delete: 0\n          };\n        }\n        modifiedElements[`${shape}`].count += 1;\n        if (type === ShapeModifyType.CREATE) {\n          modifiedElements[`${shape}`].create += 1;\n        } else if (type === ShapeModifyType.UPDATE) {\n          modifiedElements[`${shape}`].update += 1;\n        } else if (type === ShapeModifyType.DELETE) {\n          modifiedElements[`${shape}`].delete += 1;\n        }\n        if (frameIndex !== undefined) {\n          modifiedFrames.add(frameIndex);\n        }\n      };\n      /**\n       * update modified stat for deleted frames\n       * @param deletedFrames\n       */\n      const updateDeleteStatByFrames = deletedFrames => {\n        for (let i = 0; i < deletedFrames.length; i += 1) {\n          const frame = deletedFrames[i];\n          const shape = getToolTypeFromFrameData(frame);\n          updateModifiedStat(ShapeModifyType.DELETE, shape, frame.frameIndex);\n        }\n      };\n      /**\n       * update modified stat for deleted cameras\n       * @param deletedCameras\n       */\n      const updateDeleteStatByCameras = deletedCameras => {\n        for (let i = 0; i < deletedCameras.length; i += 1) {\n          updateDeleteStatByFrames(deletedCameras[i].frames);\n        }\n      };\n      /**\n       * update modified stat for delete items\n       * @param deletedItems\n       */\n      const updateDeleteStatByItems = deletedItems => {\n        for (let i = 0; i < deletedItems.length; i += 1) {\n          updateDeleteStatByCameras(deletedItems[i].cameras);\n        }\n      };\n      /**\n       * update modified stat for delete instances\n       * @param deletedInstances\n       */\n      const updateDeleteStatByInstances = deletedInstances => {\n        for (let i = 0; i < deletedInstances.length; i += 1) {\n          updateDeleteStatByItems(deletedInstances[i].children);\n        }\n      };\n      const {\n        instances: originInstances,\n        frames: originFrames,\n        attributes: originAttributes\n      } = this.initialData || {};\n      const instances = Object.values(this.instance.instances);\n      for (let i = 0; i < instances.length; i += 1) {\n        var _originInstance$child;\n        const {\n          id,\n          category,\n          items: objItems,\n          attributes\n        } = instances[i];\n        // save to existing instances\n        existingInstanceIds.push(id);\n        // get origin instance info (only when submit task)\n        const originInstance = submit ? originInstances === null || originInstances === void 0 ? void 0 : originInstances.find(instance => instance.id === id) : undefined;\n        const originItemsRemained = new Set(originInstance === null || originInstance === void 0 ? void 0 : (_originInstance$child = originInstance.children) === null || _originInstance$child === void 0 ? void 0 : _originInstance$child.map(child => child.id));\n        const items = Object.values(objItems);\n        const instanceFrames = new Set();\n        for (let j = 0; j < items.length; j += 1) {\n          var _originInstance$child2, _originItem$cameras;\n          const item = items[j];\n          // get origin instance item\n          const originItem = originInstance === null || originInstance === void 0 ? void 0 : (_originInstance$child2 = originInstance.children) === null || _originInstance$child2 === void 0 ? void 0 : _originInstance$child2.find(child => child.id === item.id);\n          const originCamerasRemained = new Set(originItem === null || originItem === void 0 ? void 0 : (_originItem$cameras = originItem.cameras) === null || _originItem$cameras === void 0 ? void 0 : _originItem$cameras.map(c => c.camera));\n          const cameras = Object.values(item.cameras);\n          for (let k = 0; k < cameras.length; k += 1) {\n            var _originItem$cameras2, _originCamera$frames;\n            const camera = cameras[k];\n            // get origin camera data\n            const originCamera = originItem === null || originItem === void 0 ? void 0 : (_originItem$cameras2 = originItem.cameras) === null || _originItem$cameras2 === void 0 ? void 0 : _originItem$cameras2.find(c => c.camera === camera.camera);\n            const originFramesRemained = new Set(originCamera === null || originCamera === void 0 ? void 0 : (_originCamera$frames = originCamera.frames) === null || _originCamera$frames === void 0 ? void 0 : _originCamera$frames.map(f => f.frameIndex));\n            const frames = Object.values(camera.frames);\n            for (let l = 0; l < frames.length; l += 1) {\n              const frame = frames[l];\n              const shape = getToolTypeFromFrameData(frame);\n              data.shapes.add(shape);\n              const key = `${shape}_${category}`;\n              if (!data.summary[key]) {\n                data.summary[key] = {\n                  ids: [id],\n                  category,\n                  shape,\n                  count: 1,\n                  distinctCount: 0\n                };\n              } else {\n                data.summary[key].count += 1;\n                if (!data.summary[key].ids.includes(id)) {\n                  data.summary[key].distinctCount += 1;\n                  data.summary[key].ids.push(id);\n                }\n              }\n              instanceFrames.add(frame.frameIndex);\n              data.annotatedFrames.add(frame.frameIndex);\n              data.elements.push({\n                id,\n                shape,\n                frame: frame.frameIndex + 1,\n                category,\n                label: attributes\n              });\n              if (frame.shapeType === ShapeType.PIXEL) {\n                var _ref;\n                data.pixelCount += 1;\n                const shapeData = frame.shape;\n                const polygons = (_ref = shapeData) === null || _ref === void 0 ? void 0 : _ref.polygons;\n                polygons.forEach(polygon => {\n                  const polygonLen = polygon ? polygon.length : 0;\n                  if (polygonLen > 0) {\n                    data.pixelOuterPolygonCount += 1;\n                  }\n                  if (polygonLen > 1) {\n                    data.pixelInnerPolygonCount += polygonLen - 1;\n                  }\n                });\n              }\n              if (submit) {\n                var _originCamera$frames2;\n                // check modified when submit task\n                const originFrame = originCamera === null || originCamera === void 0 ? void 0 : (_originCamera$frames2 = originCamera.frames) === null || _originCamera$frames2 === void 0 ? void 0 : _originCamera$frames2.find(f => f.frameIndex === frame.frameIndex);\n                if (!originFrame) {\n                  updateModifiedStat(ShapeModifyType.CREATE, shape, frame.frameIndex);\n                } else if (!isEqual(originFrame, removeUndefinedKeys(frame.toJSON({\n                  minify: this.config.minify,\n                  noLock: true\n                })))) {\n                  updateModifiedStat(ShapeModifyType.UPDATE, shape, frame.frameIndex);\n                }\n              }\n              // remove from remained frames set\n              originFramesRemained.delete(frame.frameIndex);\n            }\n            if (submit && originFramesRemained.size > 0) {\n              // has deleted shape\n              const deletedFrames = originCamera.frames.filter(f => originFramesRemained.has(f.frameIndex));\n              updateDeleteStatByFrames(deletedFrames);\n            }\n            // remove from remained cameras set\n            originCamerasRemained.delete(camera.camera);\n          }\n          if (submit && originCamerasRemained.size > 0) {\n            // has deleted camera\n            const deletedCameras = originItem.cameras.filter(c => originCamerasRemained.has(c.camera));\n            updateDeleteStatByCameras(deletedCameras);\n          }\n          // remove from remained instance items set\n          originItemsRemained.delete(item.id);\n        }\n        data.instanceCount += instanceFrames.size;\n        data.distinctInstanceCount += 1;\n        if (submit && originItemsRemained.size > 0) {\n          // has deleted items\n          const deletedItems = originInstance.children.filter(item => originItemsRemained.has(item.id));\n          updateDeleteStatByItems(deletedItems);\n        }\n      }\n      if (submit && originInstances) {\n        // check any deleted instance when submit task\n        const deletedInstances = originInstances.filter(instance => existingInstanceIds.indexOf(instance.id) < 0);\n        updateDeleteStatByInstances(deletedInstances);\n      }\n      const {\n        cameraNames,\n        attributes,\n        frameAttributes,\n        frameCount,\n        isCommonFrameValid\n      } = this.frame;\n      Array.from({\n        length: frameCount\n      }).forEach((_, index) => {\n        if (isCommonFrameValid(index)) {\n          data.validFrames.add(index);\n        }\n        if (submit && !modifiedFrames.has(index)) {\n          var _originAttributes$fra, _originAttributes$fra2;\n          // check attributes updated when task submit (only for frames that shapes not modified)\n          const frameAttrs = frameAttributes[index] || {};\n          const originFrameAttrs = (originAttributes === null || originAttributes === void 0 ? void 0 : (_originAttributes$fra = originAttributes.frames) === null || _originAttributes$fra === void 0 ? void 0 : (_originAttributes$fra2 = _originAttributes$fra.find(f => f.frameIndex === index)) === null || _originAttributes$fra2 === void 0 ? void 0 : _originAttributes$fra2.attributes) || {};\n          if (!isEqual(frameAttrs, originFrameAttrs)) {\n            // frame attributes updated\n            modifiedFrames.add(index);\n          } else {\n            cameraNames.some(cameraName => {\n              var _originFrames$find;\n              const {\n                rotation: cameraRotation = 0,\n                attributes: cameraAttrs = {}\n              } = attributes[cameraName][index] || {};\n              const {\n                rotation: originCameraRotation = 0,\n                attributes: originCameraAttrs = {}\n              } = (originFrames === null || originFrames === void 0 ? void 0 : (_originFrames$find = originFrames.find(c => c.camera === cameraName)) === null || _originFrames$find === void 0 ? void 0 : _originFrames$find.frames.find(f => f.frameIndex === index)) || {};\n              if (cameraRotation !== originCameraRotation || !isEqual(cameraAttrs, originCameraAttrs)) {\n                // camera rotation or attributes updated\n                modifiedFrames.add(index);\n                return true;\n              }\n              return false;\n            });\n          }\n        }\n      });\n      return {\n        ...data,\n        shapes: Array.from(data.shapes),\n        summary: Object.values(data.summary).map(({\n          category,\n          shape,\n          count,\n          distinctCount\n        }) => ({\n          category,\n          shape,\n          count,\n          distinctCount\n        })),\n        annotatedFrames: Array.from(data.annotatedFrames),\n        validFrames: Array.from(data.validFrames),\n        annotatedFrameCount: data.annotatedFrames.size,\n        validFrameCount: data.validFrames.size,\n        ...(submit && {\n          modifiedElements: Object.values(modifiedElements),\n          modifiedFrames: Array.from(modifiedFrames)\n        })\n      };\n    };\n    /**\n     * save file\n     * @param file\n     */\n    this.saveFile = file => this.jobProxy.saveFile(file);\n    /**\n     * delete selected shape point or instance if possible\n     */\n    this.delete = () => {\n      if (this.readonly || this.config.isAnyModalOpened || this.shape.isDrawing) {\n        return;\n      }\n      this.cancelShapeWorking();\n      if (this.config.viewMode === ViewMode.DEFAULT) {\n        this.shape.delete();\n      } else if (this.config.viewMode === ViewMode.GRID) {\n        this.grid.delete();\n      }\n    };\n    /**\n     * add instance item to current frame\n     * @param instanceItem\n     * @param camera\n     */\n    this.addToCurrentFrame = (instanceItem, camera = this.frame.currentCamera) => {\n      if (this.config.viewMode === ViewMode.DEFAULT) {\n        this.shape.addShapeToInstanceItem(instanceItem, camera);\n      } else if (this.config.viewMode === ViewMode.GRID) {\n        this.grid.addShapeToInstanceItem(instanceItem, camera);\n      }\n    };\n    /**\n     * add instance to current frame\n     * @param instance\n     * @param camera\n     */\n    this.addToCurrentFrameByInstance = (instance, camera = this.frame.currentCamera) => {\n      if (this.config.viewMode === ViewMode.DEFAULT) {\n        this.shape.addShapesToInstance(instance, camera);\n      } else if (this.config.viewMode === ViewMode.GRID) {\n        this.grid.addShapesToInstance(instance, camera);\n      }\n    };\n    /**\n     * add all instances to current frame\n     * @param instances\n     * @param camera\n     */\n    this.addToCurrentFrameForAllInstances = instances => {\n      if (this.config.viewMode === ViewMode.DEFAULT) {\n        this.shape.addShapesToInstances(instances);\n      } else if (this.config.viewMode === ViewMode.GRID) {\n        this.grid.addShapesToInstances(instances);\n      }\n    };\n    /**\n     * move shape up\n     * @param toTop\n     */\n    this.moveFront = (toTop = false) => {\n      var _this$shape$selectedS;\n      if (this.readonly || this.config.isAnyModalOpened || this.config.viewMode === ViewMode.GRID || !this.instance.isSingleSelected || this.shape.isDrawing || ((_this$shape$selectedS = this.shape.selectedShapes[0]) === null || _this$shape$selectedS === void 0 ? void 0 : _this$shape$selectedS.shapeType) === ShapeType.PIXEL) {\n        return;\n      }\n      this.cancelShapeWorking();\n      this.shape.moveFront(toTop);\n    };\n    /**\n     * move shape down\n     * @param toBottom\n     */\n    this.moveBack = (toBottom = false) => {\n      var _this$shape$selectedS2;\n      if (this.readonly || this.config.isAnyModalOpened || this.config.viewMode === ViewMode.GRID || !this.instance.isSingleSelected || this.shape.isDrawing || ((_this$shape$selectedS2 = this.shape.selectedShapes[0]) === null || _this$shape$selectedS2 === void 0 ? void 0 : _this$shape$selectedS2.shapeType) === ShapeType.PIXEL) {\n        return;\n      }\n      this.cancelShapeWorking();\n      this.shape.moveBack(toBottom);\n    };\n    /**\n     * copy shape\n     */\n    this.copy = () => {\n      let selectedShape;\n      if (this.config.viewMode === ViewMode.DEFAULT) {\n        const {\n          selectedShapes\n        } = this.shape;\n        if (selectedShapes.length === 1) {\n          selectedShape = selectedShapes[0];\n        }\n      } else if (this.config.viewMode === ViewMode.GRID) {\n        selectedShape = this.grid.getCurrentSelectedShape();\n      }\n      if (selectedShape && selectedShape.shapeType !== ShapeType.PIXEL) {\n        this.copiedShapeInfo = {\n          shapeType: selectedShape.shapeType,\n          shape: selectedShape.getData()\n        };\n        message.success(i18n.translate('SHAPE_COPIED'));\n      }\n    };\n    /**\n     * paste shape\n     */\n    this.paste = () => {\n      var _this$frame$currentCa;\n      if (this.copiedShapeInfo && this.currPosition && !((_this$frame$currentCa = this.frame.currentCameraView) === null || _this$frame$currentCa === void 0 ? void 0 : _this$frame$currentCa.imageLoadError)) {\n        const {\n          shapeType,\n          shape\n        } = this.copiedShapeInfo;\n        let container;\n        let imageBounds;\n        if (this.config.viewMode === ViewMode.DEFAULT) {\n          container = this.shape.currentLayer;\n          imageBounds = this.frame.imageBounds;\n        }\n        if (container && imageBounds) {\n          const instanceItem = this.instance.getInstanceItemForPaste(shapeType);\n          if (!instanceItem) {\n            message.warning(i18n.translate('SHAPE_PASTE_CANCEL'));\n            return;\n          }\n          const {\n            tools = []\n          } = instanceItem.categoryItemRef;\n          const isOCRTool = tools[0].type === Tool.OCR || tools[0].type === Tool.OCR_POLYGON;\n          const isFormulaTool = tools[0].type === Tool.FORMULA_POLYGON;\n          const prevBasicInfo = instanceItem.instance.getBasicInfo();\n          const pastedShape = this.shape.createShape(container, imageBounds, instanceItem.colorConfig.color, instanceItem.instance.category, instanceItem.name, instanceItem, shapeType, shape, shapeType === ShapeType.PIXEL ? 0 : this.frame.getNextShapeOrder(), instanceItem.label);\n          instanceItem.setShapeColorConifg({\n            fillColor: pastedShape.fillColor,\n            edgeColor: pastedShape.borderColor,\n            pointColor: pastedShape.vertexColor,\n            color: instanceItem.colorConfig.color\n          });\n          const centerX = (pastedShape.shapeBounds.left + pastedShape.shapeBounds.right) / 2;\n          const centerY = (pastedShape.shapeBounds.top + pastedShape.shapeBounds.bottom) / 2;\n          pastedShape.updatePosition(pastedShape.position.x - centerX + this.currPosition.x, pastedShape.position.y - centerY + this.currPosition.y);\n          const {\n            autoInterpolation,\n            activeLayerIndex\n          } = this.config;\n          const {\n            prevState,\n            currState\n          } = instanceItem.addShape(this.frame.currentCamera, this.frame.currentFrame, autoInterpolation && shapeType !== ShapeType.PIXEL, shapeType, pastedShape.getData(), activeLayerIndex, pastedShape.order, isOCRTool, isFormulaTool);\n          const basicInfo = instanceItem.instance.getBasicInfo();\n          this.undo.push({\n            instances: prevState ? [{\n              ...prevBasicInfo,\n              children: [prevState]\n            }] : []\n          }, {\n            instances: currState ? [{\n              ...basicInfo,\n              children: [currState]\n            }] : []\n          });\n          if (this.config.viewMode === ViewMode.DEFAULT) {\n            this.shape.addShapeListeners(pastedShape);\n            this.shape.shapes[pastedShape.uid] = {\n              shape: pastedShape,\n              camera: this.frame.currentCamera,\n              instanceItem\n            };\n          } else {\n            pastedShape.destroy();\n          }\n          message.success(i18n.translate('SHAPE_PASTED'));\n          this.instance.selectInstanceItem(instanceItem);\n          this.instance.autoOpenAttributesModal();\n        }\n      }\n    };\n    /**\n     * cancel shape working status, including merge, cut and set relationship\n     */\n    this.cancelShapeWorking = () => {\n      // cancel merge\n      this.shape.clearPending();\n      // cancel cutting\n      this.shape.endShapeCutting();\n      // cancel appending\n      this.shape.endShapeAppending();\n      // cancel updating\n      this.shape.finishUpdateShape();\n      // cancel multi resize\n      this.shape.exitMultiShapesResize();\n      // cancel set relationship\n      this.relationship.cancel();\n      // cancel pixel shape updating\n      this.segmentation.cancelUpdate();\n      // cancel pixel shape switching\n      this.segmentation.cancelSwitch();\n      // reset pixel selected segment index\n      this.segmentation.updateSelectedSegmentIndex(-1);\n    };\n    this.toggleAddMode = () => {\n      if (this.config.reviewMode === ReviewMode.LABELING) {\n        this.config.setAddMode(!this.config.addMode);\n      } else {\n        this.review.setAddMode(!this.review.addMode);\n      }\n    };\n    this.activateTool = num => {\n      if (this.config.reviewMode === ReviewMode.LABELING) {\n        this.ontology.activateCategoryItemByIndex(num === 0 ? 9 : num - 1);\n      } else {\n        this.review.activateReviewByHotkey(num);\n      }\n    };\n    this.openAttributesModal = () => {\n      if (this.readonly || this.shape.isDrawing) {\n        return;\n      }\n\n      // open point attributes modal\n      const {\n        selectedShapes,\n        selectedPointIndex,\n        shapes\n      } = this.shape;\n      if (selectedShapes.length === 1 && selectedPointIndex >= 0) {\n        const selectedShape = selectedShapes[0];\n        const {\n          instanceItem\n        } = shapes[selectedShape.uid];\n        const frameData = instanceItem.cameras[this.frame.currentCamera].frames[this.frame.currentFrame];\n        const {\n          pointLabelConfig\n        } = instanceItem.categoryItemRef;\n        if (frameData && pointLabelConfig) {\n          this.config.setPointAttributesModalVisible(true);\n          return;\n        }\n      }\n\n      // open instance & items attributes modal\n      if (this.instance.isMultiSelected) {\n        this.config.setMultiAttributesModalVisible(true);\n      } else if (this.instance.selectedInstanceAttributesEnabled) {\n        this.config.setAttributesModalVisible(true);\n      }\n    };\n    this.unselect = event => {\n      if (!event.shiftKey && !(event.ctrlKey && this.config.preferences.shapeRotateMode === ShapeRotateMode.CTRL)) {\n        this.shape.unselectShape();\n      }\n      this.review.unselectReview();\n    };\n    this.openContextMenu = (position, selectedFrames) => {\n      if (this.readonly || this.frame.isPlaying || this.config.isWorkingOnAnyShape) {\n        return;\n      }\n      this.config.setContextMenuVisible(true, position, selectedFrames);\n    };\n    this.ontology = new OntologyStore(this);\n    this.config = new ConfigStore(this);\n    this.frame = new FrameStore(this);\n    this.instance = new InstanceStore(this);\n    this.relationship = new RelationshipStore(this);\n    this.shape = new ShapeStore(this);\n    this.segmentation = new SegmentationStore(this);\n    this.undo = new UndoStore(this);\n    this.validation = new ValidationStore(this);\n    this.filter = new FilterStore(this);\n    this.review = new ReviewsStore(this);\n    this.thumbnail = new ThumbnailStore(this);\n    this.grid = new GridStore(this);\n    makeObservable(this, {\n      initialized: observable,\n      init: action\n    });\n  }\n  async init(payload) {\n    let initError = '';\n    const appendError = msg => {\n      initError = `${initError ? '; ' : ''}${msg}`;\n    };\n\n    // init common stores\n    this.config.init(payload);\n    this.ontology.init(payload);\n    // init relationship settings\n    this.relationship.init(payload);\n\n    // load frames\n    await this.frame.init(payload);\n    try {\n      this.thumbnail.init();\n    } catch (error) {\n      throw new Error('thumbnail init error');\n    }\n\n    // load result & init instances\n    try {\n      await this.loadResult(payload);\n    } catch (e) {\n      appendError(i18n.translate('ANNOTATION_DATA_LOAD_ERROR'));\n    }\n\n    // load & init reviews\n    try {\n      await this.loadReviews(payload);\n    } catch (e) {\n      appendError(i18n.translate('REVIEW_DATA_LOAD_ERROR'));\n    }\n\n    // init shapes\n    this.shape.init(payload);\n    this.initialized = true;\n\n    // throw error\n    if (initError) {\n      throw new Error(initError);\n    }\n  }\n  initNIFTIStore() {\n    this.nifti = new NIFTIStore(this);\n  }\n\n  /**\n   * start tracking stats\n   */\n  startTrackingStats() {\n    const {\n      workerId: currentWorkerId,\n      trackingStats\n    } = this.jobProxy;\n    if (currentWorkerId && trackingStats && this.annotatable && !this.isAudit && !this.isTemplatePreview) {\n      // label enabled & not audit & template preview mode\n      const trackWorker = new TrackWorker();\n      this.statsTracker = new StatsTracker({\n        trackWorker,\n        currentWorkerId,\n        trackingStats\n      });\n    }\n  }\n\n  /**\n   * request tracking stats\n   * @param data\n   * @param isSubmit\n   */\n  async requestTrackingStats(dataStr, isSubmit) {\n    var _this$statsTracker;\n    await ((_this$statsTracker = this.statsTracker) === null || _this$statsTracker === void 0 ? void 0 : _this$statsTracker.request(dataStr, isSubmit));\n  }\n  terminate() {\n    this.validation.terminate();\n  }\n  /**\n   * load annotation result\n   * @param payload\n   */\n  async loadResult(payload) {\n    const savedResult = await this.jobProxy.loadSavedResult();\n    const reviewFromResult = await this.jobProxy.loadReviewFrom();\n\n    // copy initial data\n    if (reviewFromResult) {\n      this.initialData = cloneDeep({\n        instances: reviewFromResult.instances,\n        frames: reviewFromResult.frames,\n        relationships: reviewFromResult.relationships,\n        attributes: reviewFromResult.attributes\n      });\n    }\n    let result = savedResult || reviewFromResult;\n    let fromPreAnnotation = false;\n    if (!result && payload.pre_annotation) {\n      try {\n        const res = await fetchResultByUrl(payload.pre_annotation);\n        if (res) {\n          result = res;\n          fromPreAnnotation = true;\n        }\n      } catch (e) {\n        // load error\n      }\n    }\n    this.initialLink = this.jobProxy.reviewFrom || payload.pre_annotation;\n    if (!result) {\n      return;\n    }\n    if (result.auditId) {\n      this.jobProxy.setAuditId(result.auditId);\n    }\n    // set frame attributes\n    this.frame.initAttributes(result);\n    // set tool configs\n    this.frame.initToolConfig(result.toolConfig);\n    // load instance\n    this.instance.init(loadInstancesFromResult(result), fromPreAnnotation);\n    // load relationships\n    this.relationship.initRelationships(result.relationships);\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const {\n      resultLink\n    } = await this.saveResultPure(submit);\n    return resultLink;\n  }\n\n  /**\n   * save annotation result (actual)\n   */\n  async saveResultPure(submit = false, useEncodeWorker = false) {\n    if (submit) {\n      // generate if no image width & height\n      await this.frame.fixImageSize();\n    }\n    // statistics\n    const statData = this.getInstanceStatistics(submit);\n    const statistics = await this.jobProxy.saveResultStat(statData, submit);\n    // label result\n    const instances = this.instance.instancesJSON({\n      minify: this.config.minify,\n      noLock: true\n    });\n    const frames = this.frame.framesJSON();\n    const relationships = this.relationship.relationshipsJSON();\n    const attributes = {\n      ...this.frame.attributesJSON()\n    };\n    const result = {\n      auditId: this.jobProxy.auditFileId,\n      instances,\n      frames,\n      relationships,\n      attributes,\n      statistics,\n      templateConfig: this.jobProxy.templateConfig,\n      toolConfig: {\n        cameraFilters: toJS(this.frame.cameraFilters)\n      },\n      annotatedFrameCount: statData.annotatedFrameCount\n    };\n    // label result str\n    const resultStr = JSON.stringify(result);\n    // request stats tracking\n    await this.requestTrackingStats(resultStr, submit);\n    // save result\n    const resultLink = await this.jobProxy.saveResult(resultStr, submit, useEncodeWorker);\n    return {\n      result: resultStr,\n      resultLink\n    };\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload) {\n    const reviewsResult = (await this.jobProxy.loadReviewsFromReview()) || (await this.jobProxy.loadReviewsFromAudit());\n    this.review.setInitialData(reviewsResult);\n    const savedResult = await this.jobProxy.loadSavedReviews();\n    const result = savedResult || reviewsResult;\n    this.review.init(payload, (result === null || result === void 0 ? void 0 : result.reviews) || result);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews(submit = false) {\n    const reviews = this.review.reviewsJSON();\n    const statData = this.review.getReviewStatistics(submit);\n    const statistics = await this.jobProxy.saveReviewStat(statData, submit);\n    return this.jobProxy.saveReviews({\n      reviews,\n      review_statistics: statistics\n    }, submit);\n  }\n}\nconst rootStore = new RootStore();\nexport default rootStore;","map":{"version":3,"names":["action","makeObservable","observable","toJS","cloneDeep","isEqual","message","OntologyStore","ConfigStore","FrameStore","InstanceStore","RelationshipStore","ShapeStore","SegmentationStore","UndoStore","ValidationStore","ReviewsStore","FilterStore","GridStore","ThumbnailStore","NIFTIStore","i18n","loadInstancesFromResult","getToolTypeFromFrameData","ViewMode","Tool","ReviewMode","ShapeModifyType","ShapeType","ShapeRotateMode","StatsTracker","TrackWorker","isAnnotationReadonly","isReviewEditable","isRework","isPreview","isTemplatePreview","ToolMode","isAudit","fetchResultByUrl","removeUndefinedKeys","RootStore","readonly","jobProxy","toolMode","config","reviewMode","REVIEW","previewMode","annotatable","reviewable","isLabeling","LABELING","constructor","ontology","frame","instance","relationship","shape","segmentation","undo","validation","review","filter","grid","thumbnail","nifti","statsTracker","resourceProxy","initialData","initialLink","initialized","fullscreenRequested","currPosition","copiedShapeInfo","proxyResource","resource","getInstanceStatistics","submit","categories","data","elements","map","className","shapes","Set","summary","frameCount","validFrames","annotatedFrames","instanceCount","distinctInstanceCount","pixelCount","pixelInnerPolygonCount","pixelOuterPolygonCount","modifiedElements","modifiedFrames","existingInstanceIds","updateModifiedStat","type","frameIndex","count","create","update","delete","CREATE","UPDATE","DELETE","undefined","add","updateDeleteStatByFrames","deletedFrames","i","length","updateDeleteStatByCameras","deletedCameras","frames","updateDeleteStatByItems","deletedItems","cameras","updateDeleteStatByInstances","deletedInstances","children","instances","originInstances","originFrames","attributes","originAttributes","Object","values","_originInstance$child","id","category","items","objItems","push","originInstance","find","originItemsRemained","child","instanceFrames","j","_originInstance$child2","_originItem$cameras","item","originItem","originCamerasRemained","c","camera","k","_originItem$cameras2","_originCamera$frames","originCamera","originFramesRemained","f","l","key","ids","distinctCount","includes","label","shapeType","PIXEL","_ref","shapeData","polygons","forEach","polygon","polygonLen","_originCamera$frames2","originFrame","toJSON","minify","noLock","size","has","indexOf","cameraNames","frameAttributes","isCommonFrameValid","Array","from","_","index","_originAttributes$fra","_originAttributes$fra2","frameAttrs","originFrameAttrs","some","cameraName","_originFrames$find","rotation","cameraRotation","cameraAttrs","originCameraRotation","originCameraAttrs","annotatedFrameCount","validFrameCount","saveFile","file","isAnyModalOpened","isDrawing","cancelShapeWorking","viewMode","DEFAULT","GRID","addToCurrentFrame","instanceItem","currentCamera","addShapeToInstanceItem","addToCurrentFrameByInstance","addShapesToInstance","addToCurrentFrameForAllInstances","addShapesToInstances","moveFront","toTop","_this$shape$selectedS","isSingleSelected","selectedShapes","moveBack","toBottom","_this$shape$selectedS2","copy","selectedShape","getCurrentSelectedShape","getData","success","translate","paste","_this$frame$currentCa","currentCameraView","imageLoadError","container","imageBounds","currentLayer","getInstanceItemForPaste","warning","tools","categoryItemRef","isOCRTool","OCR","OCR_POLYGON","isFormulaTool","FORMULA_POLYGON","prevBasicInfo","getBasicInfo","pastedShape","createShape","colorConfig","color","name","getNextShapeOrder","setShapeColorConifg","fillColor","edgeColor","borderColor","pointColor","vertexColor","centerX","shapeBounds","left","right","centerY","top","bottom","updatePosition","position","x","y","autoInterpolation","activeLayerIndex","prevState","currState","addShape","currentFrame","order","basicInfo","addShapeListeners","uid","destroy","selectInstanceItem","autoOpenAttributesModal","clearPending","endShapeCutting","endShapeAppending","finishUpdateShape","exitMultiShapesResize","cancel","cancelUpdate","cancelSwitch","updateSelectedSegmentIndex","toggleAddMode","setAddMode","addMode","activateTool","num","activateCategoryItemByIndex","activateReviewByHotkey","openAttributesModal","selectedPointIndex","frameData","pointLabelConfig","setPointAttributesModalVisible","isMultiSelected","setMultiAttributesModalVisible","selectedInstanceAttributesEnabled","setAttributesModalVisible","unselect","event","shiftKey","ctrlKey","preferences","shapeRotateMode","CTRL","unselectShape","unselectReview","openContextMenu","selectedFrames","isPlaying","isWorkingOnAnyShape","setContextMenuVisible","init","payload","initError","appendError","msg","error","Error","loadResult","e","loadReviews","initNIFTIStore","startTrackingStats","workerId","currentWorkerId","trackingStats","trackWorker","requestTrackingStats","dataStr","isSubmit","_this$statsTracker","request","terminate","savedResult","loadSavedResult","reviewFromResult","loadReviewFrom","relationships","result","fromPreAnnotation","pre_annotation","res","reviewFrom","auditId","setAuditId","initAttributes","initToolConfig","toolConfig","initRelationships","saveResult","resultLink","saveResultPure","useEncodeWorker","fixImageSize","statData","statistics","saveResultStat","instancesJSON","framesJSON","relationshipsJSON","attributesJSON","auditFileId","templateConfig","cameraFilters","resultStr","JSON","stringify","reviewsResult","loadReviewsFromReview","loadReviewsFromAudit","setInitialData","loadSavedReviews","reviews","saveReviews","reviewsJSON","getReviewStatistics","saveReviewStat","review_statistics","rootStore"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/RootStore.ts"],"sourcesContent":["import { action, makeObservable, observable, toJS } from 'mobx';\nimport { cloneDeep, isEqual } from 'lodash';\nimport { message } from 'antd';\nimport OntologyStore from './OntologyStore';\nimport ConfigStore from './ConfigStore';\nimport FrameStore from './FrameStore';\nimport InstanceStore from './InstanceStore';\nimport RelationshipStore from './RelationshipStore';\nimport ShapeStore from './ShapeStore';\nimport SegmentationStore from './SegmentationStore';\nimport UndoStore from './UndoStore';\nimport ValidationStore from './ValidationStore';\nimport ReviewsStore from './ReviewStore';\nimport FilterStore from './FilterStore';\nimport GridStore from './GridStore';\nimport ThumbnailStore from './ThumbnailStore';\nimport NIFTIStore from './NIFTIStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport i18n from '../locales';\nimport { loadInstancesFromResult, getToolTypeFromFrameData } from '../utils';\nimport { Payload, ViewMode, Tool, Statistic, ReviewMode, ShapeModifyType, ModifiedStat, Instance as IInstance, InstanceItem as IInstanceItem, FrameData, CameraData, FrameAttributes, CameraFrameAttributes, CommonFrameAttributes, LabelResult, TrackingStatsData } from '../types';\nimport { ShapeType, ShapeData } from '../../common/shapes/types';\nimport { ShapeRotateMode } from '../../common/shapes/Shape';\nimport { PixelData } from '../../common/shapes/Pixel';\nimport JobProxy from '../../../libs/JobProxy';\nimport StatsTracker from '../../../libs/StatsTracker';\nimport TrackWorker from '../worker/stats-track.worker';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, isTemplatePreview, ToolMode, isAudit } from '../../../utils/tool-mode';\nimport { fetchResultByUrl, removeUndefinedKeys } from '../../../utils';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  ontology: OntologyStore;\n\n  config: ConfigStore;\n\n  frame: FrameStore;\n\n  instance: InstanceStore;\n\n  relationship: RelationshipStore;\n\n  shape: ShapeStore;\n\n  segmentation: SegmentationStore;\n\n  undo: UndoStore;\n\n  validation: ValidationStore;\n\n  review: ReviewsStore;\n\n  filter: FilterStore;\n\n  grid: GridStore;\n\n  thumbnail: ThumbnailStore;\n\n  nifti?: NIFTIStore;\n\n  /**\n   * job proxy\n   */\n  jobProxy?: JobProxy;\n\n  /**\n   * stats tracker\n   */\n  statsTracker?: StatsTracker<TrackingStatsData>;\n\n  /**\n   * resource proxy\n   */\n  resourceProxy?: string;\n\n  /**\n   * initial data copy\n   */\n  initialData: any = null;\n\n  /**\n   * initial result link\n   */\n  initialLink = '';\n\n  /**\n   * is tool initialized\n   */\n  initialized = false;\n\n  /**\n   * when screenfull requested\n   */\n  fullscreenRequested = false;\n\n  /**\n   * current mouse position on canvas\n   */\n  currPosition?: {\n    x: number;\n    y: number;\n  };\n\n  /**\n   * copied shape info\n   */\n  copiedShapeInfo?: {\n    shapeType: ShapeType;\n    shape: ShapeData;\n  };\n\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy!.toolMode)\n      || this.config.reviewMode === ReviewMode.REVIEW\n      || this.config.previewMode;\n  }\n\n  /**\n   * is tool annotate allowed\n   */\n  get annotatable() {\n    return !isAnnotationReadonly(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in labeling mode or template preview mode\n   */\n  get isLabeling() {\n    return this.jobProxy!.toolMode === ToolMode.LABELING || this.isTemplatePreview;\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in audit mode\n   */\n  get isAudit() {\n    return isAudit(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in template preview mode\n   */\n  get isTemplatePreview() {\n    return isTemplatePreview(this.jobProxy!.toolMode);\n  }\n\n  constructor() {\n    this.ontology = new OntologyStore(this);\n    this.config = new ConfigStore(this);\n    this.frame = new FrameStore(this);\n    this.instance = new InstanceStore(this);\n    this.relationship = new RelationshipStore(this);\n    this.shape = new ShapeStore(this);\n    this.segmentation = new SegmentationStore(this);\n    this.undo = new UndoStore(this);\n    this.validation = new ValidationStore(this);\n    this.filter = new FilterStore(this);\n    this.review = new ReviewsStore(this);\n    this.thumbnail = new ThumbnailStore(this);\n    this.grid = new GridStore(this);\n\n    makeObservable(this, {\n      initialized: observable,\n      init: action,\n    });\n  }\n\n  async init(payload: Payload) {\n    let initError = '';\n    const appendError = (msg: string) => {\n      initError = `${initError ? '; ' : ''}${msg}`;\n    };\n\n    // init common stores\n    this.config.init(payload);\n    this.ontology.init(payload);\n    // init relationship settings\n    this.relationship.init(payload);\n\n    // load frames\n    await this.frame.init(payload);\n    try {\n      this.thumbnail.init();\n    } catch (error) {\n      throw new Error('thumbnail init error');\n    }\n\n    // load result & init instances\n    try {\n      await this.loadResult(payload);\n    } catch (e) {\n      appendError(i18n.translate('ANNOTATION_DATA_LOAD_ERROR'));\n    }\n\n    // load & init reviews\n    try {\n      await this.loadReviews(payload);\n    } catch (e) {\n      appendError(i18n.translate('REVIEW_DATA_LOAD_ERROR'));\n    }\n\n    // init shapes\n    this.shape.init(payload);\n    this.initialized = true;\n\n    // throw error\n    if (initError) {\n      throw new Error(initError);\n    }\n  }\n\n  initNIFTIStore() {\n    this.nifti = new NIFTIStore(this);\n  }\n\n  /**\n   * start tracking stats\n   */\n  startTrackingStats() {\n    const { workerId: currentWorkerId, trackingStats } = this.jobProxy!;\n    if (currentWorkerId && trackingStats\n      && this.annotatable && !this.isAudit && !this.isTemplatePreview) {\n      // label enabled & not audit & template preview mode\n      const trackWorker = new TrackWorker();\n      this.statsTracker = new StatsTracker({\n        trackWorker,\n        currentWorkerId,\n        trackingStats,\n      });\n    }\n  }\n\n  /**\n   * request tracking stats\n   * @param data\n   * @param isSubmit\n   */\n  async requestTrackingStats(dataStr: string, isSubmit?: boolean) {\n    await this.statsTracker?.request(dataStr, isSubmit);\n  }\n\n  terminate() {\n    this.validation.terminate();\n  }\n\n  /**\n   * proxy resource url\n   * @param resource\n   */\n  proxyResource = (resource: string) => {\n    if (this.resourceProxy && resource) {\n      return `${this.resourceProxy}?url=${resource}`;\n    }\n    return resource;\n  };\n\n  /**\n   * load annotation result\n   * @param payload\n   */\n  async loadResult(payload: Payload) {\n    const savedResult = await this.jobProxy!.loadSavedResult();\n    const reviewFromResult = await this.jobProxy!.loadReviewFrom();\n\n    // copy initial data\n    if (reviewFromResult) {\n      this.initialData = cloneDeep({\n        instances: reviewFromResult.instances,\n        frames: reviewFromResult.frames,\n        relationships: reviewFromResult.relationships,\n        attributes: reviewFromResult.attributes,\n      });\n    }\n\n    let result = savedResult || reviewFromResult;\n    let fromPreAnnotation = false;\n    if (!result && payload.pre_annotation) {\n      try {\n        const res = await fetchResultByUrl(payload.pre_annotation);\n        if (res) {\n          result = res;\n          fromPreAnnotation = true;\n        }\n      } catch (e) {\n        // load error\n      }\n    }\n\n    this.initialLink = this.jobProxy!.reviewFrom || payload.pre_annotation;\n\n    if (!result) {\n      return;\n    }\n    if (result.auditId) {\n      this.jobProxy!.setAuditId(result.auditId);\n    }\n    // set frame attributes\n    this.frame.initAttributes(result);\n    // set tool configs\n    this.frame.initToolConfig(result.toolConfig);\n    // load instance\n    this.instance.init(loadInstancesFromResult(result), fromPreAnnotation);\n    // load relationships\n    this.relationship.initRelationships(result.relationships);\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const { resultLink } = await this.saveResultPure(submit);\n    return resultLink;\n  }\n\n  /**\n   * save annotation result (actual)\n   */\n  async saveResultPure(submit = false, useEncodeWorker = false) {\n    if (submit) {\n      // generate if no image width & height\n      await this.frame.fixImageSize();\n    }\n    // statistics\n    const statData = this.getInstanceStatistics(submit);\n    const statistics = await this.jobProxy!.saveResultStat(statData, submit);\n    // label result\n    const instances = this.instance.instancesJSON({\n      minify: this.config.minify,\n      noLock: true,\n    });\n    const frames = this.frame.framesJSON();\n    const relationships = this.relationship.relationshipsJSON();\n    const attributes = {\n      ...this.frame.attributesJSON(),\n    };\n    const result: LabelResult = {\n      auditId: this.jobProxy!.auditFileId,\n      instances,\n      frames,\n      relationships,\n      attributes,\n      statistics,\n      templateConfig: this.jobProxy!.templateConfig,\n      toolConfig: {\n        cameraFilters: toJS(this.frame.cameraFilters),\n      },\n      annotatedFrameCount: statData.annotatedFrameCount,\n    };\n    // label result str\n    const resultStr = JSON.stringify(result);\n    // request stats tracking\n    await this.requestTrackingStats(resultStr, submit);\n    // save result\n    const resultLink = await this.jobProxy!.saveResult(resultStr, submit, useEncodeWorker);\n    return {\n      result: resultStr,\n      resultLink,\n    };\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload: Payload) {\n    const reviewsResult = await this.jobProxy!.loadReviewsFromReview() || await this.jobProxy!.loadReviewsFromAudit();\n    this.review.setInitialData(reviewsResult);\n    const savedResult = await this.jobProxy!.loadSavedReviews();\n    const result = savedResult || reviewsResult;\n    this.review.init(payload, result?.reviews || result);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews(submit = false) {\n    const reviews = this.review.reviewsJSON();\n    const statData = this.review.getReviewStatistics(submit);\n    const statistics = await this.jobProxy!.saveReviewStat(statData, submit);\n    return this.jobProxy!.saveReviews({\n      reviews,\n      review_statistics: statistics,\n    }, submit);\n  }\n\n  /**\n   * get instance statistics\n   */\n  getInstanceStatistics = (submit = false) => {\n    const { categories } = this.ontology;\n    const data: Statistic = {\n      elements: [],\n      categories: categories.map(({ className }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: this.frame.frameCount,\n      validFrames: new Set(),\n      annotatedFrames: new Set(),\n      instanceCount: 0,\n      distinctInstanceCount: 0,\n      pixelCount: 0,\n      pixelInnerPolygonCount: 0,\n      pixelOuterPolygonCount: 0,\n    };\n    /**\n     * modified elements (by tool type)\n     */\n    const modifiedElements: {\n      [shape: string]: ModifiedStat;\n    } = {};\n    /**\n     * modified frames\n     */\n    const modifiedFrames = new Set<number>();\n    /**\n     * current existing instance ids\n     */\n    const existingInstanceIds: string[] = [];\n    /**\n     * update modified stat by modify type\n     * @param type\n     * @param shape\n     * @param frameIndex\n     */\n    const updateModifiedStat = (type: ShapeModifyType, shape?: Tool, frameIndex?: number) => {\n      if (!modifiedElements[`${shape}`]) {\n        modifiedElements[`${shape}`] = {\n          shape,\n          count: 0,\n          create: 0,\n          update: 0,\n          delete: 0,\n        };\n      }\n      modifiedElements[`${shape}`].count += 1;\n      if (type === ShapeModifyType.CREATE) {\n        modifiedElements[`${shape}`].create += 1;\n      } else if (type === ShapeModifyType.UPDATE) {\n        modifiedElements[`${shape}`].update += 1;\n      } else if (type === ShapeModifyType.DELETE) {\n        modifiedElements[`${shape}`].delete += 1;\n      }\n      if (frameIndex !== undefined) {\n        modifiedFrames.add(frameIndex);\n      }\n    };\n    /**\n     * update modified stat for deleted frames\n     * @param deletedFrames\n     */\n    const updateDeleteStatByFrames = (deletedFrames: FrameData[]) => {\n      for (let i = 0; i < deletedFrames.length; i += 1) {\n        const frame = deletedFrames[i];\n        const shape = getToolTypeFromFrameData(frame);\n        updateModifiedStat(ShapeModifyType.DELETE, shape, frame.frameIndex);\n      }\n    };\n    /**\n     * update modified stat for deleted cameras\n     * @param deletedCameras\n     */\n    const updateDeleteStatByCameras = (deletedCameras: CameraData[]) => {\n      for (let i = 0; i < deletedCameras.length; i += 1) {\n        updateDeleteStatByFrames(deletedCameras[i].frames);\n      }\n    };\n    /**\n     * update modified stat for delete items\n     * @param deletedItems\n     */\n    const updateDeleteStatByItems = (deletedItems: IInstanceItem[]) => {\n      for (let i = 0; i < deletedItems.length; i += 1) {\n        updateDeleteStatByCameras(deletedItems[i].cameras);\n      }\n    };\n    /**\n     * update modified stat for delete instances\n     * @param deletedInstances\n     */\n    const updateDeleteStatByInstances = (deletedInstances: IInstance[]) => {\n      for (let i = 0; i < deletedInstances.length; i += 1) {\n        updateDeleteStatByItems(deletedInstances[i].children);\n      }\n    };\n\n    const {\n      instances: originInstances,\n      frames: originFrames,\n      attributes: originAttributes,\n    } = this.initialData || {};\n\n    const instances = Object.values(this.instance.instances);\n    for (let i = 0; i < instances.length; i += 1) {\n      const { id, category, items: objItems, attributes } = instances[i];\n      // save to existing instances\n      existingInstanceIds.push(id);\n      // get origin instance info (only when submit task)\n      const originInstance: IInstance | undefined = submit\n        ? originInstances?.find((instance: IInstance) => instance.id === id)\n        : undefined;\n      const originItemsRemained = new Set(originInstance?.children?.map((child) => child.id));\n\n      const items = Object.values(objItems);\n      const instanceFrames = new Set();\n      for (let j = 0; j < items.length; j += 1) {\n        const item = items[j];\n        // get origin instance item\n        const originItem = originInstance?.children?.find((child) => child.id === item.id);\n        const originCamerasRemained = new Set(originItem?.cameras?.map((c) => c.camera));\n\n        const cameras = Object.values(item.cameras);\n        for (let k = 0; k < cameras.length; k += 1) {\n          const camera = cameras[k];\n          // get origin camera data\n          const originCamera = originItem?.cameras?.find((c) => c.camera === camera.camera);\n          const originFramesRemained = new Set(originCamera?.frames?.map((f) => f.frameIndex));\n\n          const frames = Object.values(camera.frames);\n          for (let l = 0; l < frames.length; l += 1) {\n            const frame = frames[l];\n            const shape = getToolTypeFromFrameData(frame);\n            data.shapes.add(shape);\n            const key = `${shape}_${category}`;\n            if (!data.summary[key]) {\n              data.summary[key] = {\n                ids: [id],\n                category,\n                shape,\n                count: 1,\n                distinctCount: 0,\n              };\n            } else {\n              data.summary[key].count += 1;\n              if (!data.summary[key].ids.includes(id)) {\n                data.summary[key].distinctCount += 1;\n                data.summary[key].ids.push(id);\n              }\n            }\n            instanceFrames.add(frame.frameIndex);\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push({\n              id,\n              shape,\n              frame: frame.frameIndex + 1,\n              category,\n              label: attributes,\n            });\n            if (frame.shapeType === ShapeType.PIXEL) {\n              data.pixelCount += 1;\n              const shapeData = frame.shape;\n              const polygons = (shapeData as PixelData)?.polygons;\n              polygons.forEach((polygon) => {\n                const polygonLen = polygon ? polygon.length : 0;\n                if (polygonLen > 0) {\n                  data.pixelOuterPolygonCount += 1;\n                }\n                if (polygonLen > 1) {\n                  data.pixelInnerPolygonCount += (polygonLen - 1);\n                }\n              });\n            }\n\n            if (submit) {\n              // check modified when submit task\n              const originFrame = originCamera?.frames?.find((f) => f.frameIndex === frame.frameIndex);\n              if (!originFrame) {\n                updateModifiedStat(ShapeModifyType.CREATE, shape, frame.frameIndex);\n              } else if (!isEqual(originFrame, removeUndefinedKeys(frame.toJSON({ minify: this.config.minify, noLock: true })))) {\n                updateModifiedStat(ShapeModifyType.UPDATE, shape, frame.frameIndex);\n              }\n            }\n            // remove from remained frames set\n            originFramesRemained.delete(frame.frameIndex);\n          }\n\n          if (submit && originFramesRemained.size > 0) {\n            // has deleted shape\n            const deletedFrames = originCamera!.frames.filter((f) => originFramesRemained.has(f.frameIndex));\n            updateDeleteStatByFrames(deletedFrames);\n          }\n          // remove from remained cameras set\n          originCamerasRemained.delete(camera.camera);\n        }\n\n        if (submit && originCamerasRemained.size > 0) {\n          // has deleted camera\n          const deletedCameras = originItem!.cameras.filter((c) => originCamerasRemained.has(c.camera));\n          updateDeleteStatByCameras(deletedCameras);\n        }\n        // remove from remained instance items set\n        originItemsRemained.delete(item.id);\n      }\n      data.instanceCount += instanceFrames.size;\n      data.distinctInstanceCount += 1;\n\n      if (submit && originItemsRemained.size > 0) {\n        // has deleted items\n        const deletedItems = originInstance!.children.filter((item) => originItemsRemained.has(item.id));\n        updateDeleteStatByItems(deletedItems);\n      }\n    }\n\n    if (submit && originInstances) {\n      // check any deleted instance when submit task\n      const deletedInstances = originInstances.filter((instance: IInstance) => existingInstanceIds.indexOf(instance.id) < 0);\n      updateDeleteStatByInstances(deletedInstances);\n    }\n\n    const { cameraNames, attributes, frameAttributes, frameCount, isCommonFrameValid } = this.frame;\n    Array.from({ length: frameCount }).forEach((_, index) => {\n      if (isCommonFrameValid(index)) {\n        data.validFrames.add(index);\n      }\n      if (submit && !modifiedFrames.has(index)) {\n        // check attributes updated when task submit (only for frames that shapes not modified)\n        const frameAttrs = frameAttributes[index] || {};\n        const originFrameAttrs = originAttributes?.frames?.find((f: CommonFrameAttributes) => f.frameIndex === index)?.attributes || {};\n        if (!isEqual(frameAttrs, originFrameAttrs)) {\n          // frame attributes updated\n          modifiedFrames.add(index);\n        } else {\n          cameraNames.some((cameraName) => {\n            const {\n              rotation: cameraRotation = 0,\n              attributes: cameraAttrs = {},\n            } = attributes[cameraName][index] || {};\n            const {\n              rotation: originCameraRotation = 0,\n              attributes: originCameraAttrs = {},\n            } = originFrames?.find((c: CameraFrameAttributes) => c.camera === cameraName)?.frames.find((f: FrameAttributes) => f.frameIndex === index) || {};\n            if (cameraRotation !== originCameraRotation || !isEqual(cameraAttrs, originCameraAttrs)) {\n              // camera rotation or attributes updated\n              modifiedFrames.add(index);\n              return true;\n            }\n            return false;\n          });\n        }\n      }\n    });\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({ category, shape, count, distinctCount }) => ({\n        category,\n        shape,\n        count,\n        distinctCount,\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      validFrames: Array.from(data.validFrames),\n      annotatedFrameCount: data.annotatedFrames.size,\n      validFrameCount: data.validFrames.size,\n      ...submit && {\n        modifiedElements: Object.values(modifiedElements),\n        modifiedFrames: Array.from(modifiedFrames),\n      },\n    };\n  };\n\n  /**\n   * save file\n   * @param file\n   */\n  saveFile = (file: File) => this.jobProxy!.saveFile(file);\n\n  /**\n   * delete selected shape point or instance if possible\n   */\n  delete = () => {\n    if (this.readonly || this.config.isAnyModalOpened || this.shape.isDrawing) {\n      return;\n    }\n    this.cancelShapeWorking();\n    if (this.config.viewMode === ViewMode.DEFAULT) {\n      this.shape.delete();\n    } else if (this.config.viewMode === ViewMode.GRID) {\n      this.grid.delete();\n    }\n  };\n\n  /**\n   * add instance item to current frame\n   * @param instanceItem\n   * @param camera\n   */\n  addToCurrentFrame = (instanceItem: InstanceItem, camera = this.frame.currentCamera) => {\n    if (this.config.viewMode === ViewMode.DEFAULT) {\n      this.shape.addShapeToInstanceItem(instanceItem, camera);\n    } else if (this.config.viewMode === ViewMode.GRID) {\n      this.grid.addShapeToInstanceItem(instanceItem, camera);\n    }\n  };\n\n  /**\n   * add instance to current frame\n   * @param instance\n   * @param camera\n   */\n  addToCurrentFrameByInstance = (instance: Instance, camera = this.frame.currentCamera) => {\n    if (this.config.viewMode === ViewMode.DEFAULT) {\n      this.shape.addShapesToInstance(instance, camera);\n    } else if (this.config.viewMode === ViewMode.GRID) {\n      this.grid.addShapesToInstance(instance, camera);\n    }\n  };\n\n  /**\n   * add all instances to current frame\n   * @param instances\n   * @param camera\n   */\n  addToCurrentFrameForAllInstances = (instances: Instance[]) => {\n    if (this.config.viewMode === ViewMode.DEFAULT) {\n      this.shape.addShapesToInstances(instances);\n    } else if (this.config.viewMode === ViewMode.GRID) {\n      this.grid.addShapesToInstances(instances);\n    }\n  };\n\n  /**\n   * move shape up\n   * @param toTop\n   */\n  moveFront = (toTop = false) => {\n    if (\n      this.readonly ||\n      this.config.isAnyModalOpened ||\n      this.config.viewMode === ViewMode.GRID ||\n      !this.instance.isSingleSelected ||\n      this.shape.isDrawing ||\n      this.shape.selectedShapes[0]?.shapeType === ShapeType.PIXEL\n    ) {\n      return;\n    }\n    this.cancelShapeWorking();\n    this.shape.moveFront(toTop);\n  };\n\n  /**\n   * move shape down\n   * @param toBottom\n   */\n  moveBack = (toBottom = false) => {\n    if (\n      this.readonly ||\n      this.config.isAnyModalOpened ||\n      this.config.viewMode === ViewMode.GRID ||\n      !this.instance.isSingleSelected ||\n      this.shape.isDrawing ||\n      this.shape.selectedShapes[0]?.shapeType === ShapeType.PIXEL\n    ) {\n      return;\n    }\n    this.cancelShapeWorking();\n    this.shape.moveBack(toBottom);\n  };\n\n  /**\n   * copy shape\n   */\n  copy = () => {\n    let selectedShape;\n    if (this.config.viewMode === ViewMode.DEFAULT) {\n      const { selectedShapes } = this.shape;\n      if (selectedShapes.length === 1) {\n        selectedShape = selectedShapes[0];\n      }\n    } else if (this.config.viewMode === ViewMode.GRID) {\n      selectedShape = this.grid.getCurrentSelectedShape();\n    }\n\n    if (selectedShape && selectedShape.shapeType !== ShapeType.PIXEL) {\n      this.copiedShapeInfo = {\n        shapeType: selectedShape.shapeType,\n        shape: selectedShape.getData(),\n      };\n      message.success(i18n.translate('SHAPE_COPIED'));\n    }\n  };\n\n  /**\n   * paste shape\n   */\n  paste = () => {\n    if (this.copiedShapeInfo && this.currPosition && !this.frame.currentCameraView?.imageLoadError) {\n      const { shapeType, shape } = this.copiedShapeInfo;\n\n      let container;\n      let imageBounds;\n      if (this.config.viewMode === ViewMode.DEFAULT) {\n        container = this.shape.currentLayer;\n        imageBounds = this.frame.imageBounds;\n      }\n      if (container && imageBounds) {\n        const instanceItem = this.instance.getInstanceItemForPaste(shapeType);\n        if (!instanceItem) {\n          message.warning(i18n.translate('SHAPE_PASTE_CANCEL'));\n          return;\n        }\n\n        const { tools = [] } = instanceItem.categoryItemRef;\n        const isOCRTool = tools[0].type === Tool.OCR || tools[0].type === Tool.OCR_POLYGON;\n        const isFormulaTool = tools[0].type === Tool.FORMULA_POLYGON;\n        const prevBasicInfo = instanceItem.instance.getBasicInfo();\n\n        const pastedShape = this.shape.createShape(\n          container,\n          imageBounds,\n          instanceItem.colorConfig.color,\n          instanceItem.instance.category,\n          instanceItem.name,\n          instanceItem,\n          shapeType,\n          shape,\n          shapeType === ShapeType.PIXEL ? 0 : this.frame.getNextShapeOrder(),\n          instanceItem.label,\n        );\n        instanceItem.setShapeColorConifg({\n          fillColor: pastedShape.fillColor,\n          edgeColor: pastedShape.borderColor,\n          pointColor: pastedShape.vertexColor,\n          color: instanceItem.colorConfig.color\n        });\n        const centerX = (pastedShape.shapeBounds.left + pastedShape.shapeBounds.right) / 2;\n        const centerY = (pastedShape.shapeBounds.top + pastedShape.shapeBounds.bottom) / 2;\n        pastedShape.updatePosition(\n          pastedShape.position.x - centerX + this.currPosition.x,\n          pastedShape.position.y - centerY + this.currPosition.y,\n        );\n        const { autoInterpolation, activeLayerIndex } = this.config;\n        const { prevState, currState } = instanceItem.addShape(\n          this.frame.currentCamera,\n          this.frame.currentFrame,\n          autoInterpolation && shapeType !== ShapeType.PIXEL,\n          shapeType,\n          pastedShape.getData(),\n          activeLayerIndex,\n          pastedShape.order,\n          isOCRTool,\n          isFormulaTool,\n        );\n        const basicInfo = instanceItem.instance.getBasicInfo();\n        this.undo.push({\n          instances: prevState ? [{ ...prevBasicInfo, children: [prevState] }] : [],\n        }, {\n          instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n        });\n\n        if (this.config.viewMode === ViewMode.DEFAULT) {\n          this.shape.addShapeListeners(pastedShape);\n          this.shape.shapes[pastedShape.uid] = { shape: pastedShape, camera: this.frame.currentCamera, instanceItem };\n        } else {\n          pastedShape.destroy();\n        }\n\n        message.success(i18n.translate('SHAPE_PASTED'));\n        this.instance.selectInstanceItem(instanceItem);\n        this.instance.autoOpenAttributesModal();\n      }\n    }\n  };\n\n  /**\n   * cancel shape working status, including merge, cut and set relationship\n   */\n  cancelShapeWorking = () => {\n    // cancel merge\n    this.shape.clearPending();\n    // cancel cutting\n    this.shape.endShapeCutting();\n    // cancel appending\n    this.shape.endShapeAppending();\n    // cancel updating\n    this.shape.finishUpdateShape();\n    // cancel multi resize\n    this.shape.exitMultiShapesResize();\n    // cancel set relationship\n    this.relationship.cancel();\n    // cancel pixel shape updating\n    this.segmentation.cancelUpdate();\n    // cancel pixel shape switching\n    this.segmentation.cancelSwitch();\n    // reset pixel selected segment index\n    this.segmentation.updateSelectedSegmentIndex(-1);\n  };\n\n  toggleAddMode = () => {\n    if (this.config.reviewMode === ReviewMode.LABELING) {\n      this.config.setAddMode(!this.config.addMode);\n    } else {\n      this.review.setAddMode(!this.review.addMode);\n    }\n  };\n\n  activateTool = (num: number) => {\n    if (this.config.reviewMode === ReviewMode.LABELING) {\n      this.ontology.activateCategoryItemByIndex(num === 0 ? 9 : num - 1);\n    } else {\n      this.review.activateReviewByHotkey(num);\n    }\n  };\n\n  openAttributesModal = () => {\n    if (this.readonly || this.shape.isDrawing) {\n      return;\n    }\n\n    // open point attributes modal\n    const { selectedShapes, selectedPointIndex, shapes } = this.shape;\n    if (selectedShapes.length === 1 && selectedPointIndex >= 0) {\n      const selectedShape = selectedShapes[0];\n      const { instanceItem } = shapes[selectedShape.uid];\n      const frameData = instanceItem.cameras[this.frame.currentCamera].frames[this.frame.currentFrame];\n      const { pointLabelConfig } = instanceItem.categoryItemRef;\n      if (frameData && pointLabelConfig) {\n        this.config.setPointAttributesModalVisible(true);\n        return;\n      }\n    }\n\n    // open instance & items attributes modal\n    if (this.instance.isMultiSelected) {\n      this.config.setMultiAttributesModalVisible(true);\n    } else if (this.instance.selectedInstanceAttributesEnabled) {\n      this.config.setAttributesModalVisible(true);\n    }\n  };\n\n  unselect = (event: MouseEvent) => {\n    if (!event.shiftKey && !(event.ctrlKey && this.config.preferences.shapeRotateMode === ShapeRotateMode.CTRL)) {\n      this.shape.unselectShape();\n    }\n    this.review.unselectReview();\n  };\n\n  openContextMenu = (position: { x: number; y: number }, selectedFrames?: number[]) => {\n    if (this.readonly || this.frame.isPlaying || this.config.isWorkingOnAnyShape) {\n      return;\n    }\n    this.config.setContextMenuVisible(true, position, selectedFrames);\n  };\n}\n\nconst rootStore = new RootStore();\nexport default rootStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}