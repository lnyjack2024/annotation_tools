{"ast":null,"code":"import _applyDecoratedDescriptor from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nvar _class,\n  _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/components/Helper/Region.tsx\";\nimport React from 'react';\nimport { makeObservable, reaction, computed } from 'mobx';\nimport hexToRgba from 'hex-to-rgba';\nimport rootStore from '../../store/RootStore';\nimport { Align, Style } from '../../types';\nimport { wrapText } from '../../utils';\nimport eventBus, { EventAction } from '../../utils/event';\nlet Region = (_class = class Region extends React.Component {\n  constructor(props) {\n    super(props);\n    this.ratio = 1;\n    this.lineWidth = 1;\n    this.canvasRef = React.createRef();\n    this.ctx = null;\n    /**\n     * reaction disposer\n     */\n    this.reactionDisposer = void 0;\n    this.setupRegionCanvas = () => {\n      this.ratio = window.devicePixelRatio;\n      this.ctx = this.canvasRef.current.getContext('2d');\n    };\n    this.drawRegion = () => {\n      const {\n        displayBuffer: {\n          start,\n          precent\n        }\n      } = rootStore.analyse;\n      this.updateRegion(start, precent);\n    };\n    this.updateRegion = (start, precent) => {\n      const canvas = this.canvasRef.current;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = rect.width * this.ratio;\n      canvas.height = rect.height * this.ratio;\n      this.drawSelectedRegion(start, precent);\n    };\n    this.drawSelectedRegion = (start, precent) => {\n      if (this.ctx) {\n        this.ctx.beginPath();\n        this.ctx.setLineDash([]);\n        this.ctx.strokeStyle = Style.ACTIVE;\n        this.ctx.lineWidth = this.lineWidth * this.ratio;\n        const {\n          analyse: {\n            selectedTime\n          },\n          instance: {\n            selectedInstance\n          }\n        } = rootStore;\n        const {\n          atlasHeight,\n          atlasWidth,\n          margin,\n          timelineHeight,\n          duration\n        } = this.props.ratioPlacement;\n        const lineHeight = atlasHeight + timelineHeight;\n        const time = Style.FONTSIZE * this.ratio;\n        const accuracy = this.lineWidth * this.ratio;\n        const selectedRegion = rootStore.analyse.selectedRegion || ((selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.start) === selectedTime ? selectedInstance : undefined);\n        if (((selectedRegion === null || selectedRegion === void 0 ? void 0 : selectedRegion.start) || (selectedRegion === null || selectedRegion === void 0 ? void 0 : selectedRegion.start) === 0) && (selectedRegion === null || selectedRegion === void 0 ? void 0 : selectedRegion.end)) {\n          const startX = atlasWidth * ((selectedRegion.start / duration - start) / precent) + margin;\n          const endX = atlasWidth * ((selectedRegion.end / duration - start) / precent) + margin;\n          const isStartVisible = startX >= margin - accuracy && startX < margin + atlasWidth + accuracy;\n          const isEndVisible = endX > margin - accuracy && endX <= margin + atlasWidth + accuracy;\n          if (isStartVisible || isEndVisible || startX < margin && endX > margin + atlasWidth) {\n            if (isStartVisible) {\n              this.ctx.moveTo(startX, 0);\n              this.ctx.lineTo(startX, lineHeight);\n              wrapText(this.ctx, selectedRegion.start.toFixed(6), startX - 5, time, Align.RIGHT, Style.ACTIVE, 14);\n            }\n            if (isEndVisible) {\n              this.ctx.moveTo(endX, 0);\n              this.ctx.lineTo(endX, lineHeight);\n              wrapText(this.ctx, selectedRegion.end.toFixed(6), endX + 5, time, Align.LEFT, Style.ACTIVE, 14);\n            }\n            const rectStartX = isStartVisible ? startX : margin;\n            const rectEndX = isEndVisible ? endX : margin + atlasWidth;\n            const rectWidth = rectEndX - rectStartX;\n            this.ctx.fillStyle = hexToRgba(Style.ACTIVE, Style.DEFAULT_ALPHA);\n            this.ctx.fillRect(rectStartX, 0, rectWidth, timelineHeight + atlasHeight);\n            wrapText(this.ctx, (selectedRegion.end - selectedRegion.start).toFixed(6), (rectEndX + rectStartX) / 2, time, Align.CENTER, Style.FILL, 14);\n          }\n        }\n        if (selectedTime) {\n          const startX = atlasWidth * ((selectedTime / duration - start) / precent) + margin;\n          if (startX > margin - accuracy && startX < atlasWidth + margin + accuracy) {\n            this.ctx.moveTo(startX, 0);\n            this.ctx.lineTo(startX, lineHeight);\n            wrapText(this.ctx, selectedTime.toFixed(6), startX + 5, time, Align.LEFT, Style.ACTIVE, 14);\n          }\n        }\n        this.ctx.stroke();\n      }\n    };\n    makeObservable(this, {});\n    this.reactionDisposer = reaction(() => this.changeData, () => {\n      this.drawRegion();\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get changeData() {\n    return {\n      placement: rootStore.analyse.placement,\n      selectedRegion: rootStore.analyse.selectedRegion,\n      selectedTime: rootStore.analyse.selectedTime,\n      selectedInstance: rootStore.instance.selectedInstance\n    };\n  }\n  componentDidMount() {\n    this.setupRegionCanvas();\n    this.drawRegion();\n    eventBus.on(EventAction.DISPLAY_CHANGE, ({\n      start,\n      end\n    }) => {\n      this.updateRegion(start, end - start);\n    });\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: this.canvasRef,\n      style: {\n        pointerEvents: 'none'\n      },\n      className: \"absoluteTopLeftZeroW100H100\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 125,\n        columnNumber: 7\n      }\n    });\n  }\n}, _applyDecoratedDescriptor(_class.prototype, \"changeData\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"changeData\"), _class.prototype), _class);\n;\nexport default Region;","map":{"version":3,"names":["React","makeObservable","reaction","computed","hexToRgba","rootStore","Align","Style","wrapText","eventBus","EventAction","Region","_class","Component","constructor","props","ratio","lineWidth","canvasRef","createRef","ctx","reactionDisposer","setupRegionCanvas","window","devicePixelRatio","current","getContext","drawRegion","displayBuffer","start","precent","analyse","updateRegion","canvas","rect","getBoundingClientRect","width","height","drawSelectedRegion","beginPath","setLineDash","strokeStyle","ACTIVE","selectedTime","instance","selectedInstance","atlasHeight","atlasWidth","margin","timelineHeight","duration","ratioPlacement","lineHeight","time","FONTSIZE","accuracy","selectedRegion","undefined","end","startX","endX","isStartVisible","isEndVisible","moveTo","lineTo","toFixed","RIGHT","LEFT","rectStartX","rectEndX","rectWidth","fillStyle","DEFAULT_ALPHA","fillRect","CENTER","FILL","stroke","changeData","placement","componentDidMount","on","DISPLAY_CHANGE","render","createElement","ref","style","pointerEvents","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","_applyDecoratedDescriptor","prototype","Object","getOwnPropertyDescriptor"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/components/Helper/Region.tsx"],"sourcesContent":["import React from 'react';\nimport { makeObservable, reaction, IReactionDisposer, computed } from 'mobx';\nimport hexToRgba from 'hex-to-rgba';\nimport rootStore from '../../store/RootStore';\nimport { Align, Style } from '../../types';\nimport { wrapText } from '../../utils';\nimport eventBus, { EventAction } from '../../utils/event';\n\ninterface RegionProps {\n  ratioPlacement: {[key: string]: number};\n}\n\nclass Region extends React.Component<RegionProps> {\n  ratio = 1;\n\n  lineWidth = 1;\n\n  canvasRef: React.RefObject<HTMLCanvasElement> = React.createRef();\n\n  ctx: CanvasRenderingContext2D | null = null;\n\n  /**\n   * reaction disposer\n   */\n  reactionDisposer: IReactionDisposer;\n\n  constructor(props: RegionProps) {\n    super(props);\n    makeObservable(this, {});\n\n    this.reactionDisposer = reaction(\n      () => this.changeData,\n      () => {\n        this.drawRegion();\n      },\n    );\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  @computed get changeData() {\n    return {\n      placement: rootStore.analyse.placement,\n      selectedRegion: rootStore.analyse.selectedRegion,\n      selectedTime: rootStore.analyse.selectedTime,\n      selectedInstance: rootStore.instance.selectedInstance,\n    };\n  }\n\n  componentDidMount() {\n    this.setupRegionCanvas();\n    this.drawRegion();\n    eventBus.on(EventAction.DISPLAY_CHANGE, ({ start, end }) => {\n      this.updateRegion(start, end - start);\n    });\n  }\n\n  setupRegionCanvas = () => {\n    this.ratio = window.devicePixelRatio;\n    this.ctx = this.canvasRef.current!.getContext('2d') as CanvasRenderingContext2D;\n  };\n\n  drawRegion = () => {\n    const { displayBuffer: { start, precent } } = rootStore.analyse;\n    this.updateRegion(start, precent);\n  };\n\n  updateRegion = (start: number, precent: number) => {\n    const canvas = this.canvasRef.current! as HTMLCanvasElement;\n    const rect = canvas.getBoundingClientRect();\n    canvas.width = rect.width * this.ratio;\n    canvas.height = rect.height * this.ratio;\n    this.drawSelectedRegion(start, precent);\n  };\n\n  drawSelectedRegion = (start: number, precent: number) => {\n    if (this.ctx) {\n      this.ctx.beginPath();\n      this.ctx.setLineDash([]);\n      this.ctx.strokeStyle = Style.ACTIVE;\n      this.ctx.lineWidth = this.lineWidth * this.ratio;\n      const { analyse: { selectedTime }, instance: { selectedInstance } } = rootStore;\n      const { atlasHeight, atlasWidth, margin, timelineHeight, duration } = this.props.ratioPlacement;\n      const lineHeight = atlasHeight + timelineHeight;\n      const time = Style.FONTSIZE * this.ratio;\n      const accuracy = this.lineWidth * this.ratio;\n      const selectedRegion = rootStore.analyse.selectedRegion || (selectedInstance?.start === selectedTime ? selectedInstance : undefined);\n      if ((selectedRegion?.start || selectedRegion?.start === 0) && selectedRegion?.end) {\n        const startX = atlasWidth * ((selectedRegion.start / duration - start) / precent) + margin;\n        const endX = atlasWidth * ((selectedRegion.end / duration - start) / precent) + margin;\n        const isStartVisible = startX >= margin - accuracy && startX < margin + atlasWidth + accuracy;\n        const isEndVisible = endX > margin - accuracy && endX <= margin + atlasWidth + accuracy;\n        if (isStartVisible || isEndVisible || (startX < margin && endX > margin + atlasWidth)) {\n          if (isStartVisible) {\n            this.ctx.moveTo(startX, 0);\n            this.ctx.lineTo(startX, lineHeight);\n            wrapText(this.ctx, selectedRegion.start.toFixed(6), startX - 5, time, Align.RIGHT, Style.ACTIVE, 14);\n          }\n          if (isEndVisible) {\n            this.ctx.moveTo(endX, 0);\n            this.ctx.lineTo(endX, lineHeight);\n            wrapText(this.ctx, selectedRegion.end.toFixed(6), endX + 5, time, Align.LEFT, Style.ACTIVE, 14);\n          }\n          const rectStartX = isStartVisible ? startX : margin;\n          const rectEndX = isEndVisible ? endX : (margin + atlasWidth);\n          const rectWidth = rectEndX - rectStartX;\n          this.ctx.fillStyle = hexToRgba(Style.ACTIVE, Style.DEFAULT_ALPHA);\n          this.ctx.fillRect(rectStartX, 0, rectWidth, timelineHeight + atlasHeight);\n          wrapText(this.ctx, (selectedRegion.end - selectedRegion.start).toFixed(6), (rectEndX + rectStartX) / 2, time, Align.CENTER, Style.FILL, 14);\n        }\n      }\n      if (selectedTime) {\n        const startX = atlasWidth * ((selectedTime / duration - start) / precent) + margin;\n        if (startX > margin - accuracy && startX < atlasWidth + margin + accuracy) {\n          this.ctx.moveTo(startX, 0);\n          this.ctx.lineTo(startX, lineHeight);\n          wrapText(this.ctx, selectedTime.toFixed(6), startX + 5, time, Align.LEFT, Style.ACTIVE, 14);\n        }\n      }\n      this.ctx.stroke();\n    }\n  };\n\n  render() {\n    return (\n      <canvas\n        ref={this.canvasRef}\n        style={{ pointerEvents: 'none' }}\n        className=\"absoluteTopLeftZeroW100H100\"\n      />\n    );\n  }\n};\n\nexport default Region;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}