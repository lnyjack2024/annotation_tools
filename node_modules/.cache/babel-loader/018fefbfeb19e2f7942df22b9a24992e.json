{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport FrameData from './FrameData';\nimport { getLastKeyFrames, getNextKeyFrames, getShapeFromFrames, predictShapeData } from '../utils';\n/**\n * camera data\n * @class\n */\nexport default class CameraData {\n  /**\n   * shape frame status (keyframe or not)\n   * @getter\n   */\n  get frameStatus() {\n    const status = {};\n    Object.values(this.frames).forEach(({\n      frameIndex,\n      isKeyFrame\n    }) => {\n      status[frameIndex] = isKeyFrame;\n    });\n    return status;\n  }\n\n  /**\n   * no frame\n   * @getter\n   */\n  get isEmpty() {\n    return Object.keys(this.frames).length <= 0;\n  }\n  constructor({\n    camera,\n    frames = [],\n    instanceItem,\n    getNextShapeOrder\n  }) {\n    /**\n     * camera name\n     * @member\n     */\n    this.camera = void 0;\n    this.instanceItem = void 0;\n    /**\n     * shape frame data\n     * @member\n     */\n    this.frames = {};\n    /**\n     * get next shape order\n     * @member\n     */\n    this.getNextShapeOrder = void 0;\n    makeAutoObservable(this, {\n      camera: false,\n      isEmpty: false,\n      getNextShapeOrder: false\n    }, {\n      autoBind: true\n    });\n    this.instanceItem = instanceItem;\n    this.getNextShapeOrder = getNextShapeOrder;\n    this.camera = camera;\n    frames.forEach(frame => this.createFrameFromData(frame));\n  }\n\n  /**\n   * create frame from structured frame data\n   * @param frameData\n   */\n  createFrameFromData({\n    frameIndex,\n    isKeyFrame,\n    shapeType,\n    shape,\n    order,\n    attributes\n  }) {\n    const frame = new FrameData({\n      frameIndex,\n      isKeyFrame,\n      shapeType,\n      shape,\n      order,\n      attributes\n    });\n    this.frames[frameIndex] = frame;\n  }\n\n  /**\n   * update frames from structured data\n   * @param frames\n   */\n  updateFramesFromData(frames) {\n    const prevFrames = {};\n    const currFrames = {};\n    frames.forEach(({\n      frameIndex,\n      isKeyFrame,\n      shapeType,\n      shape,\n      order,\n      attributes\n    }, i) => {\n      if (this.frames[frameIndex] && !prevFrames[frameIndex]) {\n        prevFrames[frameIndex] = this.frames[frameIndex].toJSON();\n      }\n      this.createFrameFromData({\n        frameIndex,\n        isKeyFrame,\n        shapeType,\n        shape,\n        order,\n        attributes\n      });\n      const isRangeStart = i === 0 || i > 0 && frames[i].frameIndex - frames[i - 1].frameIndex > 1;\n      const isRangeEnd = i === frames.length - 1 || i < frames.length - 1 && frames[i + 1].frameIndex - frames[i].frameIndex > 1;\n      if (isRangeStart || isRangeEnd) {\n        this.frames[frameIndex].isKeyFrame = true;\n        if (isRangeStart && this.frames[frameIndex - 1]) {\n          if (!prevFrames[frameIndex - 1]) {\n            prevFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n          }\n          this.frames[frameIndex - 1].isKeyFrame = true;\n          currFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n        }\n        if (isRangeEnd && this.frames[frameIndex + 1]) {\n          if (!prevFrames[frameIndex + 1]) {\n            prevFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n          }\n          this.frames[frameIndex + 1].isKeyFrame = true;\n          currFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n        }\n      }\n      currFrames[frameIndex] = this.frames[frameIndex].toJSON();\n    });\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * set attributes in frame\n   * @param frames\n   * @param attributes with ocr text\n   */\n  setAttributes(frames, {\n    attributes\n  }) {\n    const prevState = [];\n    const currState = [];\n    frames.forEach(frameIndex => {\n      if (this.frames[frameIndex]) {\n        prevState.push(this.frames[frameIndex].toJSON());\n        if (attributes) {\n          this.frames[frameIndex].attributes = cloneDeep(attributes);\n        }\n        currState.push(this.frames[frameIndex].toJSON());\n      }\n    });\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * set attributes by frame\n   * @param frameAttributesMap\n   */\n  setAttributesByFrame(frameAttributesMap) {\n    const prevState = [];\n    const currState = [];\n    Object.keys(frameAttributesMap).forEach(key => {\n      const frameIndex = Number(key);\n      const {\n        attributes\n      } = frameAttributesMap[frameIndex];\n      if (this.frames[frameIndex]) {\n        prevState.push(this.frames[frameIndex].toJSON());\n        if (attributes) {\n          this.frames[frameIndex].attributes = cloneDeep(attributes);\n        }\n        currState.push(this.frames[frameIndex].toJSON());\n      }\n    });\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * add shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   */\n  addShape(frameIndex, interpolation, shapeType, shapeData, order, attributes) {\n    this.createFrameFromData({\n      frameIndex,\n      isKeyFrame: true,\n      shapeType,\n      shape: shapeData,\n      order,\n      attributes\n    });\n    const keyFrame = this.getNearestKeyFrame(frameIndex);\n    if (keyFrame >= 0) {\n      var _instance$dynamicAttr, _instance$dynamicAttr2, _instance$dynamicAttr3;\n      this.frames[frameIndex].attributes = cloneDeep(this.frames[keyFrame].attributes);\n      const {\n        instance\n      } = this.instanceItem;\n      const keyFrameDynamicAttributes = (_instance$dynamicAttr = instance.dynamicAttributes) === null || _instance$dynamicAttr === void 0 ? void 0 : (_instance$dynamicAttr2 = _instance$dynamicAttr[this.camera]) === null || _instance$dynamicAttr2 === void 0 ? void 0 : (_instance$dynamicAttr3 = _instance$dynamicAttr2[keyFrame]) === null || _instance$dynamicAttr3 === void 0 ? void 0 : _instance$dynamicAttr3.attributes;\n      instance.setDynamicAttributesByCamera(this.camera, [{\n        frameIndex,\n        attributes: keyFrameDynamicAttributes\n      }]);\n    }\n    let prevState = [];\n    let currState = [this.frames[frameIndex].toJSON()];\n    if (interpolation) {\n      const affectedState = this.interpolate(frameIndex, true);\n      prevState = [...prevState, ...affectedState.prevState];\n      currState = [...currState, ...affectedState.currState];\n    }\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * update shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(frameIndex, interpolation, shapeType, shapeData, order, attributes) {\n    if (this.frames[frameIndex]) {\n      // update\n      let prevState = [this.frames[frameIndex].toJSON()];\n      this.frames[frameIndex].isKeyFrame = true;\n      this.frames[frameIndex].shapeType = shapeType;\n      this.frames[frameIndex].shape = shapeData;\n      if (order !== undefined) {\n        this.frames[frameIndex].order = order;\n      }\n      if (attributes) {\n        this.frames[frameIndex].attributes = cloneDeep(attributes);\n      }\n      let currState = [this.frames[frameIndex].toJSON()];\n      if (interpolation) {\n        const affectedState = this.interpolate(frameIndex);\n        prevState = [...prevState, ...affectedState.prevState];\n        currState = [...currState, ...affectedState.currState];\n      }\n      return this.formatChangedState(prevState, currState);\n    }\n\n    // add\n    return this.addShape(frameIndex, interpolation, shapeType, shapeData, order, attributes);\n  }\n\n  /**\n   * predict shape\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(frameIndex, imageBounds, useNearest = false) {\n    let shapeInfo = predictShapeData(frameIndex, this.frames, imageBounds);\n    if (useNearest && !shapeInfo) {\n      const nearestFrame = this.getNearestKeyFrame(frameIndex);\n      if (nearestFrame >= 0) {\n        const {\n          shapeType,\n          shape\n        } = this.frames[nearestFrame];\n        shapeInfo = {\n          shapeType,\n          shape\n        };\n      }\n    }\n    return shapeInfo;\n  }\n\n  /**\n   * interpolation\n   * @param frameIndex\n   * @param shouldInsert\n   */\n  interpolate(frameIndex, shouldInsert = false) {\n    const prevState = [];\n    const currState = [];\n    const {\n      shapeType\n    } = this.frames[frameIndex];\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    const updateFrameData = (frame, shape, insert, frameData) => {\n      if (this.frames[frame]) {\n        prevState.push(this.frames[frame].toJSON());\n        this.frames[frame].isKeyFrame = false;\n        this.frames[frame].shape = shape;\n        this.frames[frame].shapeType = shapeType;\n        currState.push(this.frames[frame].toJSON());\n      } else if (insert) {\n        this.createFrameFromData({\n          frameIndex: frame,\n          isKeyFrame: false,\n          shapeType,\n          shape,\n          ...(this.getNextShapeOrder && {\n            order: this.getNextShapeOrder(frame, this.camera)\n          }),\n          ...(frameData && frameData.attributes && {\n            attributes: frameData.attributes\n          })\n        });\n        currState.push(this.frames[frame].toJSON());\n      }\n    };\n    const updateInstanceDynamicAttributes = (frameStart, frameEnd, insert, keyFrameDynamicAttributes) => {\n      if (insert) {\n        const updateArr = [];\n        for (let index = frameStart; index < frameEnd; index += 1) {\n          updateArr.push({\n            frameIndex: index,\n            attributes: keyFrameDynamicAttributes\n          });\n        }\n        const {\n          instance\n        } = this.instanceItem;\n        instance.setDynamicAttributesByCamera(this.camera, updateArr);\n      }\n    };\n    const {\n      instance\n    } = this.instanceItem;\n    if (lastKeyFrame !== undefined && this.frames[lastKeyFrame].shapeType === shapeType) {\n      var _instance$dynamicAttr4, _instance$dynamicAttr5, _instance$dynamicAttr6;\n      for (let i = lastKeyFrame + 1; i < frameIndex; i += 1) {\n        const {\n          shape\n        } = getShapeFromFrames(this.frames, lastKeyFrame, frameIndex, lastKeyFrame, i);\n        updateFrameData(i, shape, shouldInsert, this.frames[lastKeyFrame]);\n      }\n      const keyFrameDynamicAttributes = (_instance$dynamicAttr4 = instance.dynamicAttributes) === null || _instance$dynamicAttr4 === void 0 ? void 0 : (_instance$dynamicAttr5 = _instance$dynamicAttr4[this.camera]) === null || _instance$dynamicAttr5 === void 0 ? void 0 : (_instance$dynamicAttr6 = _instance$dynamicAttr5[lastKeyFrame]) === null || _instance$dynamicAttr6 === void 0 ? void 0 : _instance$dynamicAttr6.attributes;\n      if (instance.categoryRef.labelConfigDynamic && keyFrameDynamicAttributes) {\n        updateInstanceDynamicAttributes(lastKeyFrame + 1, frameIndex, shouldInsert, keyFrameDynamicAttributes);\n      }\n    }\n    if (nextKeyFrame !== undefined && this.frames[nextKeyFrame].shapeType === shapeType) {\n      for (let i = frameIndex + 1; i < nextKeyFrame; i += 1) {\n        const {\n          shape\n        } = getShapeFromFrames(this.frames, frameIndex, nextKeyFrame, frameIndex, i);\n        updateFrameData(i, shape, false);\n      }\n    }\n    return {\n      prevState,\n      currState\n    };\n  }\n\n  /**\n   * remove from frames\n   * @param frames\n   */\n  remove(frames) {\n    const prevFrames = {};\n    const currFrames = {};\n    for (let i = 0; i < frames.length; i += 1) {\n      const deleteFrame = frames[i];\n      const prevFrame = deleteFrame - 1;\n      const nextFrame = deleteFrame + 1;\n\n      // delete\n      if (this.frames[deleteFrame] && !prevFrames[deleteFrame]) {\n        prevFrames[deleteFrame] = this.frames[deleteFrame].toJSON();\n      }\n      delete this.frames[deleteFrame];\n      delete currFrames[deleteFrame];\n      const {\n        instance\n      } = this.instanceItem;\n      instance.deleteDynamicAttributesByCamera(this.camera, frames, this.instanceItem.id);\n\n      // set prev & next frame to key frame\n      if (this.frames[prevFrame]) {\n        if (!prevFrames[prevFrame]) {\n          prevFrames[prevFrame] = this.frames[prevFrame].toJSON();\n        }\n        this.frames[prevFrame].isKeyFrame = true;\n        currFrames[prevFrame] = this.frames[prevFrame].toJSON();\n      }\n      if (this.frames[nextFrame]) {\n        if (!prevFrames[nextFrame]) {\n          prevFrames[nextFrame] = this.frames[nextFrame].toJSON();\n        }\n        this.frames[nextFrame].isKeyFrame = true;\n        currFrames[nextFrame] = this.frames[nextFrame].toJSON();\n      }\n    }\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * get nearest key frame index\n   * @param frameIndex\n   */\n  getNearestKeyFrame(frameIndex) {\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    if (lastKeyFrame !== undefined) {\n      return lastKeyFrame;\n    }\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    if (nextKeyFrame !== undefined) {\n      return nextKeyFrame;\n    }\n    return -1;\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON() {\n    return {\n      camera: this.camera,\n      frames: Object.values(this.frames).map(frame => frame.toJSON())\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState, currState) {\n    return {\n      ...(prevState.length > 0 && {\n        prevState: {\n          camera: this.camera,\n          frames: [...prevState]\n        }\n      }),\n      ...(currState.length > 0 && {\n        currState: {\n          camera: this.camera,\n          frames: [...currState]\n        }\n      })\n    };\n  }\n}","map":{"version":3,"names":["makeAutoObservable","cloneDeep","FrameData","getLastKeyFrames","getNextKeyFrames","getShapeFromFrames","predictShapeData","CameraData","frameStatus","status","Object","values","frames","forEach","frameIndex","isKeyFrame","isEmpty","keys","length","constructor","camera","instanceItem","getNextShapeOrder","autoBind","frame","createFrameFromData","shapeType","shape","order","attributes","updateFramesFromData","prevFrames","currFrames","i","toJSON","isRangeStart","isRangeEnd","formatChangedState","setAttributes","prevState","currState","push","setAttributesByFrame","frameAttributesMap","key","Number","addShape","interpolation","shapeData","keyFrame","getNearestKeyFrame","_instance$dynamicAttr","_instance$dynamicAttr2","_instance$dynamicAttr3","instance","keyFrameDynamicAttributes","dynamicAttributes","setDynamicAttributesByCamera","affectedState","interpolate","updateShape","undefined","predictShape","imageBounds","useNearest","shapeInfo","nearestFrame","shouldInsert","lastKeyFrame","nextKeyFrame","updateFrameData","insert","frameData","updateInstanceDynamicAttributes","frameStart","frameEnd","updateArr","index","_instance$dynamicAttr4","_instance$dynamicAttr5","_instance$dynamicAttr6","categoryRef","labelConfigDynamic","remove","deleteFrame","prevFrame","nextFrame","deleteDynamicAttributesByCamera","id","map"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/model/CameraData.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport FrameData from './FrameData';\nimport { getLastKeyFrames, getNextKeyFrames, getShapeFromFrames, predictShapeData } from '../utils';\nimport { CameraData as ICameraData, FrameData as IFrameData } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\nimport InstanceItem from './InstanceItem';\n\ninterface ChangedState {\n  prevState?: ICameraData;\n  currState?: ICameraData;\n}\n\ninterface CameraDataOptions extends ICameraData {\n  instanceItem: InstanceItem;\n  getNextShapeOrder?: (frameIndex: number, camera: string) => number;\n}\n\n/**\n * camera data\n * @class\n */\nexport default class CameraData {\n  /**\n   * camera name\n   * @member\n   */\n  camera: string;\n\n  instanceItem: InstanceItem;\n\n  /**\n   * shape frame data\n   * @member\n   */\n  frames: { [frameIndex: number]: FrameData } = {};\n\n  /**\n   * get next shape order\n   * @member\n   */\n  getNextShapeOrder?: (frameIndex: number, camera: string) => number;\n\n  /**\n   * shape frame status (keyframe or not)\n   * @getter\n   */\n  get frameStatus() {\n    const status: { [frameIndex: number]: boolean } = {};\n    Object.values(this.frames).forEach(({ frameIndex, isKeyFrame }) => {\n      status[frameIndex] = isKeyFrame;\n    });\n    return status;\n  }\n\n  /**\n   * no frame\n   * @getter\n   */\n  get isEmpty() {\n    return Object.keys(this.frames).length <= 0;\n  }\n\n  constructor({ camera, frames = [], instanceItem, getNextShapeOrder }: CameraDataOptions) {\n    makeAutoObservable(this, {\n      camera: false,\n      isEmpty: false,\n      getNextShapeOrder: false,\n    }, {\n      autoBind: true,\n    });\n    this.instanceItem = instanceItem;\n    this.getNextShapeOrder = getNextShapeOrder;\n    this.camera = camera;\n    frames.forEach((frame) => this.createFrameFromData(frame));\n  }\n\n  /**\n   * create frame from structured frame data\n   * @param frameData\n   */\n  createFrameFromData({ frameIndex, isKeyFrame, shapeType, shape, order, attributes }: IFrameData) {\n    const frame = new FrameData({\n      frameIndex,\n      isKeyFrame,\n      shapeType,\n      shape,\n      order,\n      attributes,\n    });\n    this.frames[frameIndex] = frame;\n  }\n\n  /**\n   * update frames from structured data\n   * @param frames\n   */\n  updateFramesFromData(frames: IFrameData[]) {\n    const prevFrames: { [frameIndex: number]: IFrameData } = {};\n    const currFrames: { [frameIndex: number]: IFrameData } = {};\n    frames.forEach(({ frameIndex, isKeyFrame, shapeType, shape, order, attributes }, i) => {\n      if (this.frames[frameIndex] && !prevFrames[frameIndex]) {\n        prevFrames[frameIndex] = this.frames[frameIndex].toJSON();\n      }\n      this.createFrameFromData({ frameIndex, isKeyFrame, shapeType, shape, order, attributes });\n\n      const isRangeStart = i === 0 || (i > 0 && frames[i].frameIndex - frames[i - 1].frameIndex > 1);\n      const isRangeEnd = i === frames.length - 1 || (i < frames.length - 1 && frames[i + 1].frameIndex - frames[i].frameIndex > 1);\n      if (isRangeStart || isRangeEnd) {\n        this.frames[frameIndex].isKeyFrame = true;\n        if (isRangeStart && this.frames[frameIndex - 1]) {\n          if (!prevFrames[frameIndex - 1]) {\n            prevFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n          }\n          this.frames[frameIndex - 1].isKeyFrame = true;\n          currFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n        }\n        if (isRangeEnd && this.frames[frameIndex + 1]) {\n          if (!prevFrames[frameIndex + 1]) {\n            prevFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n          }\n          this.frames[frameIndex + 1].isKeyFrame = true;\n          currFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n        }\n      }\n\n      currFrames[frameIndex] = this.frames[frameIndex].toJSON();\n    });\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * set attributes in frame\n   * @param frames\n   * @param attributes with ocr text\n   */\n  setAttributes(frames: number[], { attributes }: { attributes?: any }) {\n    const prevState: IFrameData[] = [];\n    const currState: IFrameData[] = [];\n    frames.forEach((frameIndex) => {\n      if (this.frames[frameIndex]) {\n        prevState.push(this.frames[frameIndex].toJSON());\n        if (attributes) {\n          this.frames[frameIndex].attributes = cloneDeep(attributes);\n        }\n        currState.push(this.frames[frameIndex].toJSON());\n      }\n    });\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * set attributes by frame\n   * @param frameAttributesMap\n   */\n  setAttributesByFrame(frameAttributesMap: { [frameIndex: number]: { attributes?: any } }) {\n    const prevState: IFrameData[] = [];\n    const currState: IFrameData[] = [];\n    Object.keys(frameAttributesMap).forEach((key) => {\n      const frameIndex = Number(key);\n      const { attributes } = frameAttributesMap[frameIndex];\n      if (this.frames[frameIndex]) {\n        prevState.push(this.frames[frameIndex].toJSON());\n        if (attributes) {\n          this.frames[frameIndex].attributes = cloneDeep(attributes);\n        }\n        currState.push(this.frames[frameIndex].toJSON());\n      }\n    });\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * add shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   */\n  addShape(frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, attributes?: any): ChangedState {\n    this.createFrameFromData({\n      frameIndex,\n      isKeyFrame: true,\n      shapeType,\n      shape: shapeData,\n      order,\n      attributes,\n    });\n\n    const keyFrame = this.getNearestKeyFrame(frameIndex);\n    if (keyFrame >= 0) {\n      this.frames[frameIndex].attributes = cloneDeep(this.frames[keyFrame].attributes);\n      const { instance } = this.instanceItem;\n      const keyFrameDynamicAttributes = instance.dynamicAttributes?.[this.camera]?.[keyFrame]?.attributes;\n      instance.setDynamicAttributesByCamera(this.camera, [{ frameIndex, attributes: keyFrameDynamicAttributes }]);\n    }\n\n    let prevState: IFrameData[] = [];\n    let currState: IFrameData[] = [this.frames[frameIndex].toJSON()];\n    if (interpolation) {\n      const affectedState = this.interpolate(frameIndex, true);\n      prevState = [...prevState, ...affectedState.prevState];\n      currState = [...currState, ...affectedState.currState];\n    }\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * update shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, attributes?: any) {\n    if (this.frames[frameIndex]) {\n      // update\n      let prevState: IFrameData[] = [this.frames[frameIndex].toJSON()];\n      this.frames[frameIndex].isKeyFrame = true;\n      this.frames[frameIndex].shapeType = shapeType;\n      this.frames[frameIndex].shape = shapeData;\n      if (order !== undefined) {\n        this.frames[frameIndex].order = order;\n      }\n      if (attributes) {\n        this.frames[frameIndex].attributes = cloneDeep(attributes);\n      }\n      let currState: IFrameData[] = [this.frames[frameIndex].toJSON()];\n\n      if (interpolation) {\n        const affectedState = this.interpolate(frameIndex);\n        prevState = [...prevState, ...affectedState.prevState];\n        currState = [...currState, ...affectedState.currState];\n      }\n      return this.formatChangedState(prevState, currState);\n    }\n\n    // add\n    return this.addShape(frameIndex, interpolation, shapeType, shapeData, order, attributes);\n  }\n\n  /**\n   * predict shape\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(frameIndex: number, imageBounds?: { top: number; right: number; bottom: number; left: number }, useNearest = false) {\n    let shapeInfo = predictShapeData(frameIndex, this.frames, imageBounds);\n    if (useNearest && !shapeInfo) {\n      const nearestFrame = this.getNearestKeyFrame(frameIndex);\n      if (nearestFrame >= 0) {\n        const { shapeType, shape } = this.frames[nearestFrame];\n        shapeInfo = { shapeType, shape };\n      }\n    }\n    return shapeInfo;\n  }\n\n  /**\n   * interpolation\n   * @param frameIndex\n   * @param shouldInsert\n   */\n  interpolate(frameIndex: number, shouldInsert = false) {\n    const prevState: IFrameData[] = [];\n    const currState: IFrameData[] = [];\n\n    const { shapeType } = this.frames[frameIndex];\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    const updateFrameData = (frame: number, shape: ShapeData, insert: boolean, frameData?: FrameData) => {\n      if (this.frames[frame]) {\n        prevState.push(this.frames[frame].toJSON());\n        this.frames[frame].isKeyFrame = false;\n        this.frames[frame].shape = shape;\n        this.frames[frame].shapeType = shapeType;\n        currState.push(this.frames[frame].toJSON());\n      } else if (insert) {\n        this.createFrameFromData({\n          frameIndex: frame,\n          isKeyFrame: false,\n          shapeType,\n          shape,\n          ...this.getNextShapeOrder && { order: this.getNextShapeOrder(frame, this.camera) },\n          ...(frameData && frameData.attributes && { attributes: frameData.attributes }),\n        });\n        currState.push(this.frames[frame].toJSON());\n      }\n    };\n\n    const updateInstanceDynamicAttributes = (frameStart: number, frameEnd: number, insert: boolean, keyFrameDynamicAttributes?: any) => {\n      if (insert) {\n        const updateArr = [];\n        for (let index = frameStart; index < frameEnd; index += 1) {\n          updateArr.push({\n            frameIndex: index,\n            attributes: keyFrameDynamicAttributes\n          });\n        }\n        const { instance } = this.instanceItem;\n        instance.setDynamicAttributesByCamera(this.camera, updateArr);\n      }\n    };\n    const { instance } = this.instanceItem;\n    if (lastKeyFrame !== undefined && this.frames[lastKeyFrame].shapeType === shapeType) {\n      for (let i = lastKeyFrame + 1; i < frameIndex; i += 1) {\n        const { shape } = getShapeFromFrames(this.frames, lastKeyFrame, frameIndex, lastKeyFrame, i);\n        updateFrameData(i, shape, shouldInsert, this.frames[lastKeyFrame]);\n      }\n      const keyFrameDynamicAttributes = instance.dynamicAttributes?.[this.camera]?.[lastKeyFrame]?.attributes;\n      if (instance.categoryRef.labelConfigDynamic && keyFrameDynamicAttributes) {\n        updateInstanceDynamicAttributes(lastKeyFrame + 1, frameIndex, shouldInsert, keyFrameDynamicAttributes);\n      }\n    }\n    if (nextKeyFrame !== undefined && this.frames[nextKeyFrame].shapeType === shapeType) {\n      for (let i = frameIndex + 1; i < nextKeyFrame; i += 1) {\n        const { shape } = getShapeFromFrames(this.frames, frameIndex, nextKeyFrame, frameIndex, i);\n        updateFrameData(i, shape, false);\n      }\n    }\n\n    return { prevState, currState };\n  }\n\n  /**\n   * remove from frames\n   * @param frames\n   */\n  remove(frames: number[]) {\n    const prevFrames: { [frameIndex: number]: IFrameData } = {};\n    const currFrames: { [frameIndex: number]: IFrameData } = {};\n    for (let i = 0; i < frames.length; i += 1) {\n      const deleteFrame = frames[i];\n      const prevFrame = deleteFrame - 1;\n      const nextFrame = deleteFrame + 1;\n\n      // delete\n      if (this.frames[deleteFrame] && !prevFrames[deleteFrame]) {\n        prevFrames[deleteFrame] = this.frames[deleteFrame].toJSON();\n      }\n      delete this.frames[deleteFrame];\n      delete currFrames[deleteFrame];\n\n      const { instance } = this.instanceItem;\n      instance.deleteDynamicAttributesByCamera(this.camera, frames, this.instanceItem.id);\n\n      // set prev & next frame to key frame\n      if (this.frames[prevFrame]) {\n        if (!prevFrames[prevFrame]) {\n          prevFrames[prevFrame] = this.frames[prevFrame].toJSON();\n        }\n        this.frames[prevFrame].isKeyFrame = true;\n        currFrames[prevFrame] = this.frames[prevFrame].toJSON();\n      }\n      if (this.frames[nextFrame]) {\n        if (!prevFrames[nextFrame]) {\n          prevFrames[nextFrame] = this.frames[nextFrame].toJSON();\n        }\n        this.frames[nextFrame].isKeyFrame = true;\n        currFrames[nextFrame] = this.frames[nextFrame].toJSON();\n      }\n    }\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * get nearest key frame index\n   * @param frameIndex\n   */\n  getNearestKeyFrame(frameIndex: number) {\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    if (lastKeyFrame !== undefined) {\n      return lastKeyFrame;\n    }\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    if (nextKeyFrame !== undefined) {\n      return nextKeyFrame;\n    }\n    return -1;\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON(): ICameraData {\n    return {\n      camera: this.camera,\n      frames: Object.values(this.frames).map((frame) => frame.toJSON()),\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState: IFrameData[], currState: IFrameData[]): ChangedState {\n    return {\n      ...prevState.length > 0 && {\n        prevState: { camera: this.camera, frames: [...prevState] },\n      },\n      ...currState.length > 0 && {\n        currState: { camera: this.camera, frames: [...currState] },\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}