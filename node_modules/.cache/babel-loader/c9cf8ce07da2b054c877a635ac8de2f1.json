{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/canvas/GridCanvas.tsx\";\nimport React from 'react';\nimport { Point, Graphics, Texture, Rectangle } from 'pixi.js';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport imageLoader from 'blueimp-load-image';\nimport { debounce } from 'lodash';\nimport GridContainer, { EventAction } from './GridContainer';\nimport Shape from '../Shape';\nimport Anchor from '../anchors/Anchor';\nimport './Canvas.css';\nconst scrollBarContainerSize = 16;\nconst scrollBarSize = 10;\nexport default class GridCanvas extends React.Component {\n  /**\n   * current grid height\n   */\n  get currentGridHeight() {\n    return this.currentGridWidth / 4 * 3;\n  }\n\n  /**\n   * vertical scroll bar\n   */\n\n  /**\n   * all grids actual height\n   */\n  get allGridsHeight() {\n    const lastGridIndex = this.props.grids.length - 1;\n    const lastRowIndex = Math.floor(lastGridIndex / this.colCount);\n    return (lastRowIndex + 1) * this.currentGridHeight;\n  }\n\n  /**\n   * renderer view size\n   */\n  get viewSize() {\n    return {\n      width: this.props.app.renderer.width / window.devicePixelRatio,\n      height: this.props.app.renderer.height / window.devicePixelRatio\n    };\n  }\n  constructor(props) {\n    super(props);\n    /**\n     * application dom container\n     */\n    this.container = void 0;\n    /**\n     * cached textures\n     */\n    this.cachedTextures = {};\n    /**\n     * cached grids\n     */\n    this.cachedGrids = {};\n    /**\n     * visible grids index\n     */\n    this.visibleGrids = [];\n    /**\n     * selected grid index\n     */\n    this.selectedGridIndex = -1;\n    /**\n     * visible columns count\n     */\n    this.colCount = 4;\n    /**\n     * visible rows count\n     */\n    this.rowCount = 3;\n    /**\n     * base grid width\n     */\n    this.gridWidthBase = this.props.gridWidth || 400;\n    /**\n     * current grid width\n     */\n    this.currentGridWidth = 400;\n    this.scrollY = new Graphics();\n    /**\n     * scroll offset\n     */\n    this.scrollYOffset = 0;\n    /**\n     * is mouse down on vertical scroll bar\n     */\n    this.isScrollYDown = false;\n    /**\n     * scroll y offset when mouse down\n     */\n    this.scrollYDownOffset = 0;\n    /**\n     * point y when mouse down\n     */\n    this.scrollYDownStart = 0;\n    /**\n     * get grid view container & image bounds\n     * @param gridIndex\n     * @returns\n     */\n    this.getGrid = gridIndex => this.cachedGrids[gridIndex] && !this.cachedGrids[gridIndex].imageLoadError ? {\n      container: this.cachedGrids[gridIndex].view,\n      imageBounds: this.cachedGrids[gridIndex].imageBounds\n    } : undefined;\n    /**\n     * get shapes in grid\n     * @param gridIndex\n     * @returns\n     */\n    this.getGridShapes = gridIndex => {\n      var _this$cachedGrids$gri;\n      return ((_this$cachedGrids$gri = this.cachedGrids[gridIndex]) === null || _this$cachedGrids$gri === void 0 ? void 0 : _this$cachedGrids$gri.shapes) || [];\n    };\n    /**\n     * set shapes in grid\n     * @param gridIndex\n     * @param shapes\n     */\n    this.setGridShapes = (gridIndex, shapes) => {\n      const grid = this.cachedGrids[gridIndex];\n      if (grid) {\n        grid.setShapes(shapes);\n      }\n    };\n    /**\n     * remove and destroy grid\n     * @param grid\n     */\n    this.destroyGrid = grid => {\n      this.props.app.stage.removeChild(grid);\n      // grid.destroy({ children: true, texture: true, baseTexture: true });\n    };\n    /**\n     * batch cache image texture\n     */\n    this.batchCacher = debounce(gridIndexes => {\n      const {\n        grids\n      } = this.props;\n      gridIndexes.forEach(gridIndex => {\n        if (grids[gridIndex] && !this.isTextureCacheValid(gridIndex)) {\n          if (grids[gridIndex].imageUrl) {\n            imageLoader(grids[gridIndex].imageUrl, data => {\n              if (!(data instanceof Event && data.type === 'error')) {\n                const texture = Texture.from(data);\n                this.setTextureCache(gridIndex, texture);\n              }\n            }, {\n              canvas: true,\n              orientation: true,\n              crossOrigin: 'anonymous'\n            });\n          }\n        }\n      });\n    }, 100);\n    /**\n     * resize\n     */\n    this.resize = () => {\n      if (this.container.current) {\n        const {\n          clientWidth,\n          clientHeight\n        } = this.container.current;\n        this.props.app.renderer.resize(clientWidth, clientHeight);\n        this.props.app.render();\n        this.updateCanvas();\n      }\n    };\n    /**\n     * wheel\n     */\n    this.wheel = event => {\n      const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this.mapStageToLocalPosition(point);\n      const someGridWheeled = Object.values(this.cachedGrids).some(grid => grid.wheel(event.nativeEvent, localPoint));\n      if (!someGridWheeled) {\n        this.scroll(this.scrollYOffset + event.deltaY);\n      }\n    };\n    /**\n     * when grid pointer down\n     * @param grid\n     */\n    this.onGridPointerDown = (grid, point) => {\n      // set selected\n      const gridIndex = Number(grid.id);\n      this.props.onGridSelected(gridIndex);\n      // start create if possible\n      const shape = this.props.addShape(point, grid.view, grid.imageBounds, grid.viewScale);\n      if (shape instanceof Shape) {\n        grid.shapes.push(shape);\n      } else if (shape instanceof Anchor) {\n        grid.reviews.push(shape);\n      }\n    };\n    /**\n     * scroll y mouse down\n     * @param event\n     */\n    this.handleScrollYDown = event => {\n      this.isScrollYDown = true;\n      this.scrollYDownOffset = this.scrollYOffset;\n      this.scrollYDownStart = event.data.getLocalPosition(this.props.app.stage).y;\n    };\n    /**\n     * scroll y mouse move\n     * @param event\n     */\n    this.handleMouseMove = event => {\n      if (this.isScrollYDown) {\n        const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n        const localPoint = this.mapStageToLocalPosition(point);\n        const scrollOffset = (localPoint.y - this.scrollYDownStart) * (this.allGridsHeight / this.viewSize.height);\n        this.scroll(this.scrollYDownOffset + scrollOffset);\n      }\n    };\n    /**\n     * scroll y mouse up\n     */\n    this.handleMouseUp = () => {\n      this.isScrollYDown = false;\n      this.scrollYDownOffset = 0;\n      this.scrollYDownStart = 0;\n    };\n    /**\n     * handle canvas mouse move\n     * @param event\n     */\n    this.mouseMove = event => {\n      if (!this.props.onGridMouseMove) {\n        return;\n      }\n      let localPoint = null;\n      const selectedGrid = this.cachedGrids[this.selectedGridIndex];\n      if (selectedGrid) {\n        const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n        if (selectedGrid.getBounds().contains(point.x, point.y)) {\n          localPoint = selectedGrid.view.toLocal(point);\n        }\n      }\n      this.props.onGridMouseMove(localPoint);\n    };\n    this.container = React.createRef();\n  }\n  componentDidMount() {\n    if (this.container.current) {\n      new ResizeObserver(this.resize).observe(this.container.current);\n      this.props.app.renderer.on('resolution-changed', this.resize);\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n    }\n  }\n  componentWillUnmount() {\n    this.props.app.renderer.off('resolution-changed', this.resize);\n    // remove scroll bar\n    this.props.app.stage.removeChild(this.scrollY);\n    // remove cached grids\n    Object.values(this.cachedGrids).forEach(this.destroyGrid);\n    this.cachedGrids = {};\n    // reset\n    this.visibleGrids = [];\n    this.selectedGridIndex = -1;\n  }\n  /**\n   * create grid, and add to stage\n   */\n  createGrid() {\n    const grid = new GridContainer();\n    grid.on(EventAction.POINTERDOWN, this.onGridPointerDown);\n    this.props.app.stage.addChild(grid);\n    return grid;\n  }\n\n  /**\n   * set texture cache\n   * @param gridIndex\n   * @param texture\n   */\n  setTextureCache(gridIndex, texture) {\n    // if (this.cachedTextures[gridIndex]) {\n    //   this.cachedTextures[gridIndex].destroy(true);\n    // }\n    this.cachedTextures[gridIndex] = texture;\n  }\n\n  /**\n   * is texture cache valid\n   * @param gridIndex\n   */\n  isTextureCacheValid(gridIndex) {\n    return this.cachedTextures[gridIndex] && this.cachedTextures[gridIndex].valid;\n  }\n\n  /**\n   * recalc the col count & row count & grid size (when canvas mount, resize)\n   */\n  updateCanvas(gridWidth) {\n    if (gridWidth !== undefined) {\n      this.gridWidthBase = gridWidth;\n    }\n    const {\n      width,\n      height\n    } = this.viewSize;\n    this.colCount = this.props.columns === undefined ? Math.ceil(width / this.gridWidthBase) : this.props.columns;\n    if (this.props.columns === undefined) {\n      // not fixed columns, update current grid width by container width and col count\n      this.currentGridWidth = width / this.colCount;\n    }\n    this.rowCount = Math.ceil(height / this.currentGridHeight);\n    this.setupGrids();\n  }\n\n  /**\n   * load images\n   */\n  loadImages() {\n    const {\n      grids\n    } = this.props;\n    this.visibleGrids.forEach(gridIndex => {\n      if (grids[gridIndex] && !this.isTextureCacheValid(gridIndex)) {\n        if (grids[gridIndex].imageUrl) {\n          imageLoader(grids[gridIndex].imageUrl, data => {\n            const grid = this.cachedGrids[gridIndex];\n            if (grid) {\n              let width = -1;\n              let height = -1;\n              if (data instanceof Event && data.type === 'error') {\n                grid.setImageLoadError(true);\n              } else {\n                const texture = Texture.from(data);\n                width = texture.width;\n                height = texture.height;\n                this.setTextureCache(gridIndex, texture);\n                // update grid\n                grid.setImage(texture);\n                grid.setShapes(this.props.createShapesForGrid(gridIndex, grid.view, grid.imageBounds));\n                if (this.props.createReviewsForGrid) {\n                  grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n                }\n              }\n              if (this.props.onImageLoad) {\n                this.props.onImageLoad(gridIndex, width, height);\n              }\n            }\n          }, {\n            canvas: true,\n            orientation: true,\n            crossOrigin: 'anonymous'\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * reset visible grids\n   * @param start\n   */\n  setVisibleGrids(start) {\n    const size = this.colCount * (this.rowCount + 1);\n    this.visibleGrids = Array.from({\n      length: size\n    }).map((_, index) => start + index);\n    // load more images\n    this.loadImages();\n  }\n\n  /**\n   * setup grids\n   */\n  setupGrids() {\n    const {\n      grids\n    } = this.props;\n    let currentGrid;\n    if (this.selectedGridIndex >= 0) {\n      currentGrid = this.selectedGridIndex;\n    } else if (this.visibleGrids.length > 0) {\n      currentGrid = this.visibleGrids[0];\n    } else {\n      // first loaded\n      this.selectedGridIndex = grids.findIndex(g => g.defaultSelected === true);\n      currentGrid = this.selectedGridIndex;\n    }\n    let currentStartGrid = 0;\n    this.scrollYOffset = 0;\n    if (this.allGridsHeight > this.viewSize.height) {\n      const currentRow = Math.floor(Math.max(currentGrid, 0) / this.colCount);\n      currentStartGrid = currentRow * this.colCount;\n      this.scrollYOffset = currentRow * this.currentGridHeight;\n      if (this.scrollYOffset > this.allGridsHeight - this.viewSize.height) {\n        const newScrollYOffset = this.allGridsHeight - this.viewSize.height;\n        const diff = this.scrollYOffset - newScrollYOffset;\n        this.scrollYOffset = newScrollYOffset;\n        currentStartGrid -= Math.ceil(diff / this.currentGridHeight) * this.colCount;\n      }\n    }\n    this.setVisibleGrids(currentStartGrid);\n    this.updateGrids(true);\n    this.setGridSelected(this.selectedGridIndex);\n\n    // cache grids\n    this.cacheGrids();\n  }\n\n  /**\n   * update grids\n   * @param resize\n   */\n  updateGrids(resize = false) {\n    const {\n      grids\n    } = this.props;\n\n    // remove invisible grids\n    Object.keys(this.cachedGrids).forEach(key => {\n      const gridIndex = Number(key);\n      if (!this.visibleGrids.includes(gridIndex) || gridIndex < 0 || gridIndex >= grids.length) {\n        this.destroyGrid(this.cachedGrids[gridIndex]);\n        delete this.cachedGrids[gridIndex];\n      }\n    });\n\n    // update visible grids\n    this.visibleGrids.forEach((gridIndex, index) => {\n      if (grids[gridIndex]) {\n        const {\n          imageUrl,\n          imageRotation = 0,\n          title = '',\n          info = '',\n          borderColor,\n          selectedStyle\n        } = grids[gridIndex];\n        let grid = this.cachedGrids[gridIndex];\n        const gridCached = grid !== undefined;\n        if (!gridCached) {\n          grid = this.createGrid();\n          grid.id = `${gridIndex}`;\n          grid.title.text = title;\n          grid.info.text = info;\n          if (borderColor !== undefined) {\n            grid.borderColor = borderColor;\n          }\n          if (selectedStyle !== undefined) {\n            grid.selectedStyle = selectedStyle;\n          }\n          this.cachedGrids[gridIndex] = grid;\n        }\n        if (!imageUrl) {\n          grid.setImageLoadError(true);\n        }\n        // update rotation\n        grid.imageRotation = imageRotation;\n        // update position\n        const offsetX = index % this.colCount * this.currentGridWidth;\n        const offsetY = Math.floor(index / this.colCount) * this.currentGridHeight - this.scrollYOffset % this.currentGridHeight;\n        grid.position.set(offsetX, offsetY);\n        // update size\n        grid.setSize(this.currentGridWidth, this.currentGridHeight);\n        if (!gridCached && this.isTextureCacheValid(gridIndex)) {\n          grid.setImage(this.cachedTextures[gridIndex]);\n          grid.setShapes(this.props.createShapesForGrid(gridIndex, grid.view, grid.imageBounds));\n          if (this.props.createReviewsForGrid) {\n            grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n          }\n        }\n        if (resize) {\n          grid.fitShapes();\n        }\n      }\n    });\n    this.updateScrollY();\n  }\n\n  /**\n   * update shapes in visible grids\n   * @param updatedGrids\n   */\n  updateShapes(updatedGrids) {\n    const grids = updatedGrids || this.props.grids;\n    Object.keys(this.cachedGrids).forEach(key => {\n      const gridIndex = Number(key);\n      if (grids[gridIndex]) {\n        const {\n          imageRotation = 0,\n          info = '',\n          borderColor,\n          selectedStyle\n        } = grids[gridIndex];\n        const grid = this.cachedGrids[gridIndex];\n        if (borderColor !== undefined) {\n          grid.borderColor = borderColor;\n        }\n        if (selectedStyle !== undefined) {\n          grid.selectedStyle = selectedStyle;\n        }\n        grid.imageRotation = imageRotation;\n        grid.setInfo(info);\n        grid.setShapes(this.props.createShapesForGrid(gridIndex, grid.view, grid.imageBounds));\n        if (this.props.createReviewsForGrid) {\n          grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n        }\n      }\n    });\n  }\n\n  /**\n   * update review anchors\n   */\n  updateReviews() {\n    const {\n      grids\n    } = this.props;\n    Object.keys(this.cachedGrids).forEach(key => {\n      const gridIndex = Number(key);\n      if (grids[gridIndex]) {\n        const grid = this.cachedGrids[gridIndex];\n        if (this.props.createReviewsForGrid) {\n          grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n        }\n      }\n    });\n  }\n\n  /**\n   * fit shapes in all grids\n   */\n  fitShapes() {\n    Object.values(this.cachedGrids).forEach(grid => {\n      grid.fitShapes();\n    });\n  }\n\n  /**\n   * update grid style\n   * @param gridIndex optional when no specific grid should be updated\n   */\n  updateStyle(gridIndex) {\n    const {\n      grids\n    } = this.props;\n    const update = gIndex => {\n      const grid = this.cachedGrids[gIndex];\n      if (grid && grids[gIndex]) {\n        const {\n          borderColor,\n          selectedStyle\n        } = grids[gIndex];\n        if (borderColor !== undefined) {\n          grid.borderColor = borderColor;\n        }\n        if (selectedStyle !== undefined) {\n          grid.selectedStyle = selectedStyle;\n        }\n      }\n    };\n    if (gridIndex !== undefined) {\n      // only update one grid\n      update(gridIndex);\n    } else {\n      // update all visible grids\n      Object.keys(this.cachedGrids).forEach(key => {\n        const gIndex = Number(key);\n        update(gIndex);\n      });\n    }\n  }\n\n  /**\n   * update vertical scroll bar\n   */\n  updateScrollY() {\n    const {\n      width,\n      height\n    } = this.viewSize;\n    if (this.allGridsHeight > height) {\n      // has vertical scroll bar\n      this.props.app.stage.addChild(this.scrollY);\n      this.scrollY.position.set(width - scrollBarContainerSize, 0);\n      const scrollSize = Math.max(height / this.allGridsHeight * height, 48);\n      const scrollOffset = this.scrollYOffset / this.allGridsHeight * height;\n      const scrollRect = new Rectangle((scrollBarContainerSize - scrollBarSize) / 2, scrollOffset, scrollBarSize, scrollSize);\n      this.scrollY.hitArea = scrollRect;\n      // draw scroll bar\n      this.scrollY.clear();\n      this.scrollY.beginFill(0x00000, 0.48);\n      this.scrollY.drawRect(0, 0, scrollBarContainerSize, height);\n      this.scrollY.beginFill(0xFFFFFF, 0.6);\n      this.scrollY.drawRoundedRect(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height, 5);\n      this.scrollY.endFill();\n      // add scroll bar listener\n      this.scrollY.interactive = true;\n      this.scrollY.on('pointerdown', this.handleScrollYDown);\n      document.addEventListener('mousemove', this.handleMouseMove);\n      document.addEventListener('mouseup', this.handleMouseUp);\n    } else {\n      this.props.app.stage.removeChild(this.scrollY);\n      this.scrollY.off('pointerdown', this.handleScrollYDown);\n      document.removeEventListener('mousemove', this.handleMouseMove);\n      document.removeEventListener('mouseup', this.handleMouseUp);\n    }\n  }\n\n  /**\n   * cache grids\n   */\n  cacheGrids(cacheNext = true, cachePrev = true) {\n    let nextGrids = [];\n    let prevGrids = [];\n    if (cacheNext) {\n      // next grids\n      const nextStart = this.visibleGrids[0] + this.visibleGrids.length;\n      nextGrids = Array.from({\n        length: this.colCount\n      }).map((_, index) => nextStart + index);\n    }\n    if (cachePrev) {\n      // prev grids\n      const prevStart = this.visibleGrids[0] - this.colCount;\n      prevGrids = Array.from({\n        length: this.colCount\n      }).map((_, index) => prevStart + index);\n    }\n\n    // preload images\n    const indexes = [...nextGrids, ...prevGrids];\n    if (indexes.length > 0) {\n      this.batchCacher(indexes);\n    }\n  }\n  /**\n   * scroll\n   * @param deltaY\n   */\n  scroll(newScrollY) {\n    // scroll y\n    if (this.allGridsHeight <= this.viewSize.height) {\n      return;\n    }\n    const lastScrollYOffset = this.scrollYOffset;\n    const lastRow = Math.floor(this.scrollYOffset / this.currentGridHeight);\n    this.scrollYOffset = newScrollY;\n    if (this.scrollYOffset < 0) {\n      this.scrollYOffset = 0;\n    } else if (this.scrollYOffset > this.allGridsHeight - this.viewSize.height) {\n      this.scrollYOffset = this.allGridsHeight - this.viewSize.height;\n    }\n    if (this.scrollYOffset !== lastScrollYOffset) {\n      // scroll\n      const currentRow = Math.floor(this.scrollYOffset / this.currentGridHeight);\n      const currentStartGridIndex = currentRow * this.colCount;\n      const scrollDown = currentRow > lastRow;\n      const scrollUp = currentRow < lastRow;\n      this.setVisibleGrids(currentStartGridIndex);\n      this.updateGrids();\n      this.setGridSelected(this.selectedGridIndex);\n      this.cacheGrids(scrollDown, scrollUp);\n    }\n  }\n\n  /**\n   * scroll to specific grid\n   * @param gridIndex\n   */\n  scrollTo(gridIndex) {\n    if (!this.visibleGrids.includes(gridIndex) || this.visibleGrids.slice(-this.colCount).includes(gridIndex) && Math.floor(this.visibleGrids[this.visibleGrids.length - 1] / this.colCount) * this.currentGridHeight - this.scrollYOffset % this.currentGridHeight > this.viewSize.height) {\n      this.visibleGrids = [];\n      this.setupGrids();\n    }\n  }\n\n  /**\n   * set grid selected\n   * @param gridIndex\n   */\n  setGridSelected(gridIndex) {\n    this.selectedGridIndex = gridIndex;\n    Object.values(this.cachedGrids).forEach(grid => {\n      grid.selected = false;\n    });\n    if (this.cachedGrids[gridIndex]) {\n      this.cachedGrids[gridIndex].selected = true;\n      if (this.props.onSelectedGridChanged) {\n        const {\n          left,\n          top\n        } = this.container.current.getBoundingClientRect();\n        this.props.onSelectedGridChanged(gridIndex, this.cachedGrids[gridIndex].view, {\n          x: left,\n          y: top\n        });\n      }\n    }\n  }\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x, y) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point) {\n    return this.props.app.stage.toLocal(point);\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"canvas-container\",\n      ref: this.container,\n      style: {\n        ...this.props.style,\n        width: '100%',\n        height: '100%'\n      },\n      onWheel: this.wheel,\n      onMouseMove: this.mouseMove,\n      onContextMenu: e => e.preventDefault(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 746,\n        columnNumber: 7\n      }\n    });\n  }\n}","map":{"version":3,"names":["React","Point","Graphics","Texture","Rectangle","ResizeObserver","imageLoader","debounce","GridContainer","EventAction","Shape","Anchor","scrollBarContainerSize","scrollBarSize","GridCanvas","Component","currentGridHeight","currentGridWidth","allGridsHeight","lastGridIndex","props","grids","length","lastRowIndex","Math","floor","colCount","viewSize","width","app","renderer","window","devicePixelRatio","height","constructor","container","cachedTextures","cachedGrids","visibleGrids","selectedGridIndex","rowCount","gridWidthBase","gridWidth","scrollY","scrollYOffset","isScrollYDown","scrollYDownOffset","scrollYDownStart","getGrid","gridIndex","imageLoadError","view","imageBounds","undefined","getGridShapes","_this$cachedGrids$gri","shapes","setGridShapes","grid","setShapes","destroyGrid","stage","removeChild","batchCacher","gridIndexes","forEach","isTextureCacheValid","imageUrl","data","Event","type","texture","from","setTextureCache","canvas","orientation","crossOrigin","resize","current","clientWidth","clientHeight","render","updateCanvas","wheel","event","point","mapScreenToStagePosition","clientX","clientY","localPoint","mapStageToLocalPosition","someGridWheeled","Object","values","some","nativeEvent","scroll","deltaY","onGridPointerDown","Number","id","onGridSelected","shape","addShape","viewScale","push","reviews","handleScrollYDown","getLocalPosition","y","handleMouseMove","scrollOffset","handleMouseUp","mouseMove","onGridMouseMove","selectedGrid","getBounds","contains","x","toLocal","createRef","componentDidMount","observe","on","appendChild","componentWillUnmount","off","createGrid","POINTERDOWN","addChild","valid","columns","ceil","setupGrids","loadImages","setImageLoadError","setImage","createShapesForGrid","createReviewsForGrid","setReviews","onImageLoad","setVisibleGrids","start","size","Array","map","_","index","currentGrid","findIndex","g","defaultSelected","currentStartGrid","currentRow","max","newScrollYOffset","diff","updateGrids","setGridSelected","cacheGrids","keys","key","includes","imageRotation","title","info","borderColor","selectedStyle","gridCached","text","offsetX","offsetY","position","set","setSize","fitShapes","updateScrollY","updateShapes","updatedGrids","setInfo","updateReviews","updateStyle","update","gIndex","scrollSize","scrollRect","hitArea","clear","beginFill","drawRect","drawRoundedRect","endFill","interactive","document","addEventListener","removeEventListener","cacheNext","cachePrev","nextGrids","prevGrids","nextStart","prevStart","indexes","newScrollY","lastScrollYOffset","lastRow","currentStartGridIndex","scrollDown","scrollUp","scrollTo","slice","selected","onSelectedGridChanged","left","top","getBoundingClientRect","plugins","interaction","mapPositionToPoint","createElement","className","ref","style","onWheel","onMouseMove","onContextMenu","e","preventDefault","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/canvas/GridCanvas.tsx"],"sourcesContent":["import React from 'react';\nimport { Application, Container, Point, Graphics, Texture, Rectangle, InteractionEvent } from 'pixi.js';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport imageLoader from 'blueimp-load-image';\nimport { debounce } from 'lodash';\nimport GridContainer, { EventAction, SelectedStyle } from './GridContainer';\nimport { ShapeData } from '../types';\nimport Shape from '../Shape';\nimport Anchor from '../anchors/Anchor';\nimport './Canvas.css';\n\ninterface GridItem {\n  imageUrl: string;\n  imageRotation?: number;\n  title: string;\n  info?: string;\n  borderColor?: number;\n  selectedStyle?: SelectedStyle;\n  defaultSelected?: boolean;\n}\n\ninterface GridCanvasProps {\n  style?: React.CSSProperties;\n  app: Application;\n  columns?: number; // if provided, grids will show specific columns in one row, otherwise, will fit the view\n  grids: GridItem[];\n  gridWidth?: number;\n  addShape: (point: Point, container: Container, imageBounds: { left: number; top: number; right: number; bottom: number; }, viewScale?: number) => Shape<ShapeData> | Anchor | null;\n  createShapesForGrid: (index: number, container: Container, imageBounds: { left: number; top: number; right: number; bottom: number; }) => Shape<ShapeData>[];\n  createReviewsForGrid?: (index: number, container: Container, viewScale: number) => Anchor[];\n  onGridSelected: (index: number) => void;\n  onGridMouseMove?: (point: Point | null) => void;\n  onSelectedGridChanged?: (index: number, container: Container, offset: { x: number; y: number }) => void;\n  onImageLoad?: (index: number, width: number, height: number) => void;\n}\n\nconst scrollBarContainerSize = 16;\nconst scrollBarSize = 10;\n\nexport default class GridCanvas extends React.Component<GridCanvasProps> {\n  /**\n   * application dom container\n   */\n  container: React.RefObject<HTMLDivElement>;\n\n  /**\n   * cached textures\n   */\n  cachedTextures: { [gridIndex: number]: Texture } = {};\n\n  /**\n   * cached grids\n   */\n  cachedGrids: { [gridIndex: number]: GridContainer } = {};\n\n  /**\n   * visible grids index\n   */\n  visibleGrids: number[] = [];\n\n  /**\n   * selected grid index\n   */\n  selectedGridIndex = -1;\n\n  /**\n   * visible columns count\n   */\n  colCount = 4;\n\n  /**\n   * visible rows count\n   */\n  rowCount = 3;\n\n  /**\n   * base grid width\n   */\n  gridWidthBase = this.props.gridWidth || 400;\n\n  /**\n   * current grid width\n   */\n  currentGridWidth = 400;\n\n  /**\n   * current grid height\n   */\n  get currentGridHeight() {\n    return (this.currentGridWidth / 4) * 3;\n  }\n\n  /**\n   * vertical scroll bar\n   */\n  scrollY = new Graphics();\n\n  /**\n   * scroll offset\n   */\n  scrollYOffset = 0;\n\n  /**\n   * is mouse down on vertical scroll bar\n   */\n  isScrollYDown = false;\n\n  /**\n   * scroll y offset when mouse down\n   */\n  scrollYDownOffset = 0;\n\n  /**\n   * point y when mouse down\n   */\n  scrollYDownStart = 0;\n\n  /**\n   * all grids actual height\n   */\n  get allGridsHeight() {\n    const lastGridIndex = this.props.grids.length - 1;\n    const lastRowIndex = Math.floor(lastGridIndex / this.colCount);\n    return (lastRowIndex + 1) * this.currentGridHeight;\n  }\n\n  /**\n   * renderer view size\n   */\n  get viewSize() {\n    return {\n      width: this.props.app.renderer.width / window.devicePixelRatio,\n      height: this.props.app.renderer.height / window.devicePixelRatio,\n    };\n  }\n\n  constructor(props: GridCanvasProps) {\n    super(props);\n    this.container = React.createRef();\n  }\n\n  componentDidMount() {\n    if (this.container.current) {\n      new ResizeObserver(this.resize).observe(this.container.current);\n      this.props.app.renderer.on('resolution-changed', this.resize);\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.app.renderer.off('resolution-changed', this.resize);\n    // remove scroll bar\n    this.props.app.stage.removeChild(this.scrollY);\n    // remove cached grids\n    Object.values(this.cachedGrids).forEach(this.destroyGrid);\n    this.cachedGrids = {};\n    // reset\n    this.visibleGrids = [];\n    this.selectedGridIndex = -1;\n  }\n\n  /**\n   * get grid view container & image bounds\n   * @param gridIndex\n   * @returns\n   */\n  getGrid = (gridIndex: number) => (this.cachedGrids[gridIndex] && !this.cachedGrids[gridIndex].imageLoadError ? {\n    container: this.cachedGrids[gridIndex].view,\n    imageBounds: this.cachedGrids[gridIndex].imageBounds,\n  } : undefined);\n\n  /**\n   * get shapes in grid\n   * @param gridIndex\n   * @returns\n   */\n  getGridShapes = (gridIndex: number) => this.cachedGrids[gridIndex]?.shapes || [];\n\n  /**\n   * set shapes in grid\n   * @param gridIndex\n   * @param shapes\n   */\n  setGridShapes = (gridIndex: number, shapes: Shape<ShapeData>[]) => {\n    const grid = this.cachedGrids[gridIndex];\n    if (grid) {\n      grid.setShapes(shapes);\n    }\n  };\n\n  /**\n   * remove and destroy grid\n   * @param grid\n   */\n  destroyGrid = (grid: GridContainer) => {\n    this.props.app.stage.removeChild(grid);\n    // grid.destroy({ children: true, texture: true, baseTexture: true });\n  };\n\n  /**\n   * create grid, and add to stage\n   */\n  createGrid() {\n    const grid = new GridContainer();\n    grid.on(EventAction.POINTERDOWN, this.onGridPointerDown);\n    this.props.app.stage.addChild(grid);\n    return grid;\n  }\n\n  /**\n   * set texture cache\n   * @param gridIndex\n   * @param texture\n   */\n  setTextureCache(gridIndex: number, texture: Texture) {\n    // if (this.cachedTextures[gridIndex]) {\n    //   this.cachedTextures[gridIndex].destroy(true);\n    // }\n    this.cachedTextures[gridIndex] = texture;\n  }\n\n  /**\n   * is texture cache valid\n   * @param gridIndex\n   */\n  isTextureCacheValid(gridIndex: number) {\n    return this.cachedTextures[gridIndex] && this.cachedTextures[gridIndex].valid;\n  }\n\n  /**\n   * recalc the col count & row count & grid size (when canvas mount, resize)\n   */\n  updateCanvas(gridWidth?: number) {\n    if (gridWidth !== undefined) {\n      this.gridWidthBase = gridWidth;\n    }\n\n    const { width, height } = this.viewSize;\n    this.colCount = this.props.columns === undefined ? Math.ceil(width / this.gridWidthBase) : this.props.columns;\n    if (this.props.columns === undefined) {\n      // not fixed columns, update current grid width by container width and col count\n      this.currentGridWidth = width / this.colCount;\n    }\n    this.rowCount = Math.ceil(height / this.currentGridHeight);\n    this.setupGrids();\n  }\n\n  /**\n   * load images\n   */\n  loadImages() {\n    const { grids } = this.props;\n    this.visibleGrids.forEach((gridIndex) => {\n      if (grids[gridIndex] && !this.isTextureCacheValid(gridIndex)) {\n        if (grids[gridIndex].imageUrl) {\n          imageLoader(grids[gridIndex].imageUrl, (data) => {\n            const grid = this.cachedGrids[gridIndex];\n            if (grid) {\n              let width = -1;\n              let height = -1;\n              if (data instanceof Event && data.type === 'error') {\n                grid.setImageLoadError(true);\n              } else {\n                const texture = Texture.from(data as HTMLCanvasElement);\n                width = texture.width;\n                height = texture.height;\n                this.setTextureCache(gridIndex, texture);\n                // update grid\n                grid.setImage(texture);\n                grid.setShapes(this.props.createShapesForGrid(gridIndex, grid.view, grid.imageBounds));\n                if (this.props.createReviewsForGrid) {\n                  grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n                }\n              }\n              if (this.props.onImageLoad) {\n                this.props.onImageLoad(gridIndex, width, height);\n              }\n            }\n          }, {\n            canvas: true,\n            orientation: true,\n            crossOrigin: 'anonymous',\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * reset visible grids\n   * @param start\n   */\n  setVisibleGrids(start: number) {\n    const size = this.colCount * (this.rowCount + 1);\n    this.visibleGrids = Array.from({ length: size }).map((_, index) => start + index);\n    // load more images\n    this.loadImages();\n  }\n\n  /**\n   * setup grids\n   */\n  setupGrids() {\n    const { grids } = this.props;\n\n    let currentGrid;\n    if (this.selectedGridIndex >= 0) {\n      currentGrid = this.selectedGridIndex;\n    } else if (this.visibleGrids.length > 0) {\n      currentGrid = this.visibleGrids[0];\n    } else {\n      // first loaded\n      this.selectedGridIndex = grids.findIndex((g) => g.defaultSelected === true);\n      currentGrid = this.selectedGridIndex;\n    }\n    let currentStartGrid = 0;\n    this.scrollYOffset = 0;\n    if (this.allGridsHeight > this.viewSize.height) {\n      const currentRow = Math.floor(Math.max(currentGrid, 0) / this.colCount);\n      currentStartGrid = currentRow * this.colCount;\n      this.scrollYOffset = currentRow * this.currentGridHeight;\n      if (this.scrollYOffset > this.allGridsHeight - this.viewSize.height) {\n        const newScrollYOffset = this.allGridsHeight - this.viewSize.height;\n        const diff = this.scrollYOffset - newScrollYOffset;\n        this.scrollYOffset = newScrollYOffset;\n        currentStartGrid -= Math.ceil(diff / this.currentGridHeight) * this.colCount;\n      }\n    }\n    this.setVisibleGrids(currentStartGrid);\n    this.updateGrids(true);\n    this.setGridSelected(this.selectedGridIndex);\n\n    // cache grids\n    this.cacheGrids();\n  }\n\n  /**\n   * update grids\n   * @param resize\n   */\n  updateGrids(resize = false) {\n    const { grids } = this.props;\n\n    // remove invisible grids\n    Object.keys(this.cachedGrids).forEach((key) => {\n      const gridIndex = Number(key);\n      if (!this.visibleGrids.includes(gridIndex) || gridIndex < 0 || gridIndex >= grids.length) {\n        this.destroyGrid(this.cachedGrids[gridIndex]);\n        delete this.cachedGrids[gridIndex];\n      }\n    });\n\n    // update visible grids\n    this.visibleGrids.forEach((gridIndex, index) => {\n      if (grids[gridIndex]) {\n        const { imageUrl, imageRotation = 0, title = '', info = '', borderColor, selectedStyle } = grids[gridIndex];\n\n        let grid = this.cachedGrids[gridIndex];\n        const gridCached = grid !== undefined;\n        if (!gridCached) {\n          grid = this.createGrid();\n          grid.id = `${gridIndex}`;\n          grid.title.text = title;\n          grid.info.text = info;\n          if (borderColor !== undefined) {\n            grid.borderColor = borderColor;\n          }\n          if (selectedStyle !== undefined) {\n            grid.selectedStyle = selectedStyle;\n          }\n          this.cachedGrids[gridIndex] = grid;\n        }\n\n        if (!imageUrl) {\n          grid.setImageLoadError(true);\n        }\n        // update rotation\n        grid.imageRotation = imageRotation;\n        // update position\n        const offsetX = (index % this.colCount) * this.currentGridWidth;\n        const offsetY = Math.floor(index / this.colCount) * this.currentGridHeight - (this.scrollYOffset % this.currentGridHeight);\n        grid.position.set(offsetX, offsetY);\n        // update size\n        grid.setSize(this.currentGridWidth, this.currentGridHeight);\n        if (!gridCached && this.isTextureCacheValid(gridIndex)) {\n          grid.setImage(this.cachedTextures[gridIndex]);\n          grid.setShapes(this.props.createShapesForGrid(gridIndex, grid.view, grid.imageBounds));\n          if (this.props.createReviewsForGrid) {\n            grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n          }\n        }\n\n        if (resize) {\n          grid.fitShapes();\n        }\n      }\n    });\n    this.updateScrollY();\n  }\n\n  /**\n   * update shapes in visible grids\n   * @param updatedGrids\n   */\n  updateShapes(updatedGrids?: GridItem[]) {\n    const grids = updatedGrids || this.props.grids;\n    Object.keys(this.cachedGrids).forEach((key) => {\n      const gridIndex = Number(key);\n      if (grids[gridIndex]) {\n        const { imageRotation = 0, info = '', borderColor, selectedStyle } = grids[gridIndex];\n        const grid = this.cachedGrids[gridIndex];\n        if (borderColor !== undefined) {\n          grid.borderColor = borderColor;\n        }\n        if (selectedStyle !== undefined) {\n          grid.selectedStyle = selectedStyle;\n        }\n        grid.imageRotation = imageRotation;\n        grid.setInfo(info);\n        grid.setShapes(this.props.createShapesForGrid(gridIndex, grid.view, grid.imageBounds));\n        if (this.props.createReviewsForGrid) {\n          grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n        }\n      }\n    });\n  }\n\n  /**\n   * update review anchors\n   */\n  updateReviews() {\n    const { grids } = this.props;\n    Object.keys(this.cachedGrids).forEach((key) => {\n      const gridIndex = Number(key);\n      if (grids[gridIndex]) {\n        const grid = this.cachedGrids[gridIndex];\n        if (this.props.createReviewsForGrid) {\n          grid.setReviews(this.props.createReviewsForGrid(gridIndex, grid.view, grid.viewScale));\n        }\n      }\n    });\n  }\n\n  /**\n   * fit shapes in all grids\n   */\n  fitShapes() {\n    Object.values(this.cachedGrids).forEach((grid) => {\n      grid.fitShapes();\n    });\n  }\n\n  /**\n   * update grid style\n   * @param gridIndex optional when no specific grid should be updated\n   */\n  updateStyle(gridIndex?: number) {\n    const { grids } = this.props;\n    const update = (gIndex: number) => {\n      const grid = this.cachedGrids[gIndex];\n      if (grid && grids[gIndex]) {\n        const { borderColor, selectedStyle } = grids[gIndex];\n        if (borderColor !== undefined) {\n          grid.borderColor = borderColor;\n        }\n        if (selectedStyle !== undefined) {\n          grid.selectedStyle = selectedStyle;\n        }\n      }\n    };\n\n    if (gridIndex !== undefined) {\n      // only update one grid\n      update(gridIndex);\n    } else {\n      // update all visible grids\n      Object.keys(this.cachedGrids).forEach((key) => {\n        const gIndex = Number(key);\n        update(gIndex);\n      });\n    }\n  }\n\n  /**\n   * update vertical scroll bar\n   */\n  updateScrollY() {\n    const { width, height } = this.viewSize;\n    if (this.allGridsHeight > height) {\n      // has vertical scroll bar\n      this.props.app.stage.addChild(this.scrollY);\n      this.scrollY.position.set(width - scrollBarContainerSize, 0);\n      const scrollSize = Math.max((height / this.allGridsHeight) * height, 48);\n      const scrollOffset = (this.scrollYOffset / this.allGridsHeight) * height;\n      const scrollRect = new Rectangle((scrollBarContainerSize - scrollBarSize) / 2, scrollOffset, scrollBarSize, scrollSize);\n      this.scrollY.hitArea = scrollRect;\n      // draw scroll bar\n      this.scrollY.clear();\n      this.scrollY.beginFill(0x00000, 0.48);\n      this.scrollY.drawRect(0, 0, scrollBarContainerSize, height);\n      this.scrollY.beginFill(0xFFFFFF, 0.6);\n      this.scrollY.drawRoundedRect(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height, 5);\n      this.scrollY.endFill();\n      // add scroll bar listener\n      this.scrollY.interactive = true;\n      this.scrollY.on('pointerdown', this.handleScrollYDown);\n      document.addEventListener('mousemove', this.handleMouseMove);\n      document.addEventListener('mouseup', this.handleMouseUp);\n    } else {\n      this.props.app.stage.removeChild(this.scrollY);\n      this.scrollY.off('pointerdown', this.handleScrollYDown);\n      document.removeEventListener('mousemove', this.handleMouseMove);\n      document.removeEventListener('mouseup', this.handleMouseUp);\n    }\n  }\n\n  /**\n   * cache grids\n   */\n  cacheGrids(cacheNext = true, cachePrev = true) {\n    let nextGrids: number[] = [];\n    let prevGrids: number[] = [];\n\n    if (cacheNext) {\n      // next grids\n      const nextStart = this.visibleGrids[0] + this.visibleGrids.length;\n      nextGrids = Array.from({ length: this.colCount }).map((_, index) => nextStart + index);\n    }\n\n    if (cachePrev) {\n      // prev grids\n      const prevStart = this.visibleGrids[0] - this.colCount;\n      prevGrids = Array.from({ length: this.colCount }).map((_, index) => prevStart + index);\n    }\n\n    // preload images\n    const indexes = [...nextGrids, ...prevGrids];\n    if (indexes.length > 0) {\n      this.batchCacher(indexes);\n    }\n  }\n\n  /**\n   * batch cache image texture\n   */\n  batchCacher = debounce((gridIndexes: number[]) => {\n    const { grids } = this.props;\n    gridIndexes.forEach((gridIndex) => {\n      if (grids[gridIndex] && !this.isTextureCacheValid(gridIndex)) {\n        if (grids[gridIndex].imageUrl) {\n          imageLoader(grids[gridIndex].imageUrl, (data) => {\n            if (!(data instanceof Event && data.type === 'error')) {\n              const texture = Texture.from(data as HTMLCanvasElement);\n              this.setTextureCache(gridIndex, texture);\n            }\n          }, {\n            canvas: true,\n            orientation: true,\n            crossOrigin: 'anonymous',\n          });\n        }\n      }\n    });\n  }, 100);\n\n  /**\n   * resize\n   */\n  resize = () => {\n    if (this.container.current) {\n      const { clientWidth, clientHeight } = this.container.current;\n      this.props.app.renderer.resize(clientWidth, clientHeight);\n      this.props.app.render();\n      this.updateCanvas();\n    }\n  };\n\n  /**\n   * wheel\n   */\n  wheel = (event: React.WheelEvent) => {\n    const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n    const localPoint = this.mapStageToLocalPosition(point);\n    const someGridWheeled = Object.values(this.cachedGrids).some((grid) => grid.wheel(event.nativeEvent, localPoint));\n    if (!someGridWheeled) {\n      this.scroll(this.scrollYOffset + event.deltaY);\n    }\n  };\n\n  /**\n   * scroll\n   * @param deltaY\n   */\n  scroll(newScrollY: number) {\n    // scroll y\n    if (this.allGridsHeight <= this.viewSize.height) {\n      return;\n    }\n\n    const lastScrollYOffset = this.scrollYOffset;\n    const lastRow = Math.floor(this.scrollYOffset / this.currentGridHeight);\n\n    this.scrollYOffset = newScrollY;\n    if (this.scrollYOffset < 0) {\n      this.scrollYOffset = 0;\n    } else if (this.scrollYOffset > this.allGridsHeight - this.viewSize.height) {\n      this.scrollYOffset = this.allGridsHeight - this.viewSize.height;\n    }\n\n    if (this.scrollYOffset !== lastScrollYOffset) {\n      // scroll\n      const currentRow = Math.floor(this.scrollYOffset / this.currentGridHeight);\n      const currentStartGridIndex = currentRow * this.colCount;\n      const scrollDown = currentRow > lastRow;\n      const scrollUp = currentRow < lastRow;\n      this.setVisibleGrids(currentStartGridIndex);\n      this.updateGrids();\n      this.setGridSelected(this.selectedGridIndex);\n      this.cacheGrids(scrollDown, scrollUp);\n    }\n  }\n\n  /**\n   * scroll to specific grid\n   * @param gridIndex\n   */\n  scrollTo(gridIndex: number) {\n    if (\n      !this.visibleGrids.includes(gridIndex) ||\n      (this.visibleGrids.slice(-this.colCount).includes(gridIndex) && Math.floor(this.visibleGrids[this.visibleGrids.length - 1] / this.colCount) * this.currentGridHeight - (this.scrollYOffset % this.currentGridHeight) > this.viewSize.height)\n    ) {\n      this.visibleGrids = [];\n      this.setupGrids();\n    }\n  }\n\n  /**\n   * set grid selected\n   * @param gridIndex\n   */\n  setGridSelected(gridIndex: number) {\n    this.selectedGridIndex = gridIndex;\n    Object.values(this.cachedGrids).forEach((grid) => {\n      grid.selected = false;\n    });\n    if (this.cachedGrids[gridIndex]) {\n      this.cachedGrids[gridIndex].selected = true;\n\n      if (this.props.onSelectedGridChanged) {\n        const { left, top } = this.container.current!.getBoundingClientRect();\n        this.props.onSelectedGridChanged(gridIndex, this.cachedGrids[gridIndex].view, { x: left, y: top });\n      }\n    }\n  }\n\n  /**\n   * when grid pointer down\n   * @param grid\n   */\n  onGridPointerDown = (grid: GridContainer, point: Point) => {\n    // set selected\n    const gridIndex = Number(grid.id);\n    this.props.onGridSelected(gridIndex);\n    // start create if possible\n    const shape = this.props.addShape(point, grid.view, grid.imageBounds, grid.viewScale);\n    if (shape instanceof Shape) {\n      grid.shapes.push(shape);\n    } else if (shape instanceof Anchor) {\n      grid.reviews.push(shape);\n    }\n  };\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x: number, y: number) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point: Point) {\n    return this.props.app.stage.toLocal(point);\n  }\n\n  /**\n   * scroll y mouse down\n   * @param event\n   */\n  handleScrollYDown = (event: InteractionEvent) => {\n    this.isScrollYDown = true;\n    this.scrollYDownOffset = this.scrollYOffset;\n    this.scrollYDownStart = event.data.getLocalPosition(this.props.app.stage).y;\n  };\n\n  /**\n   * scroll y mouse move\n   * @param event\n   */\n  handleMouseMove = (event: MouseEvent) => {\n    if (this.isScrollYDown) {\n      const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this.mapStageToLocalPosition(point);\n      const scrollOffset = (localPoint.y - this.scrollYDownStart) * (this.allGridsHeight / this.viewSize.height);\n      this.scroll(this.scrollYDownOffset + scrollOffset);\n    }\n  };\n\n  /**\n   * scroll y mouse up\n   */\n  handleMouseUp = () => {\n    this.isScrollYDown = false;\n    this.scrollYDownOffset = 0;\n    this.scrollYDownStart = 0;\n  };\n\n  /**\n   * handle canvas mouse move\n   * @param event\n   */\n  mouseMove = (event: React.MouseEvent) => {\n    if (!this.props.onGridMouseMove) {\n      return;\n    }\n    let localPoint = null;\n    const selectedGrid = this.cachedGrids[this.selectedGridIndex];\n    if (selectedGrid) {\n      const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      if (selectedGrid.getBounds().contains(point.x, point.y)) {\n        localPoint = selectedGrid.view.toLocal(point);\n      }\n    }\n    this.props.onGridMouseMove(localPoint);\n  };\n\n  render() {\n    return (\n      <div\n        className=\"canvas-container\"\n        ref={this.container}\n        style={{ ...this.props.style, width: '100%', height: '100%' }}\n        onWheel={this.wheel}\n        onMouseMove={this.mouseMove}\n        onContextMenu={(e) => e.preventDefault()}\n      />\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}