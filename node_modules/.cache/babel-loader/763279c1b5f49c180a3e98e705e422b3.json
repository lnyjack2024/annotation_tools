{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { Container, Graphics, Point, Text, utils as PIXIUtils } from 'pixi.js';\nimport Layer from './Layer';\nimport ShapeGraphics from './ShapeGraphics';\nimport { ShapeType, ShapeVertexType, ShapeLineType } from './types';\nimport { findIntersections } from './utils';\nimport Cursor from '../Cursor';\nimport { computeRotatedPosition } from '../../../utils/math';\nexport let EventAction = /*#__PURE__*/function (EventAction) {\n  EventAction[\"SELECTED\"] = \"selected\";\n  EventAction[\"VERTEX_SELECTED\"] = \"vertex-selected\";\n  EventAction[\"FINISHED\"] = \"finished\";\n  EventAction[\"REMOVED\"] = \"removed\";\n  EventAction[\"CHANGED\"] = \"changed\";\n  EventAction[\"DRAGGING\"] = \"dragging\";\n  EventAction[\"RESIZING\"] = \"resizing\";\n  EventAction[\"POINTER_OVER\"] = \"pointer-over\";\n  EventAction[\"POINTER_OUT\"] = \"pointer-out\";\n  EventAction[\"RECOGNITION\"] = \"recognition\";\n  return EventAction;\n}({});\nexport let BorderStyle = /*#__PURE__*/function (BorderStyle) {\n  BorderStyle[\"SOLID\"] = \"solid\";\n  BorderStyle[\"DASHED\"] = \"dashed\";\n  return BorderStyle;\n}({});\nexport let UserDataMode = /*#__PURE__*/function (UserDataMode) {\n  UserDataMode[\"HIDE\"] = \"hide\";\n  UserDataMode[\"HOVER\"] = \"hover\";\n  UserDataMode[\"ALWAYS\"] = \"always\";\n  return UserDataMode;\n}({});\n/**\n * Shape base\n * @class\n */\nexport default class Shape {\n  /**\n   * global snapping point (not on self shape)\n   * @getter\n   */\n  get globalSnappingPoint() {\n    return this.container instanceof Layer ? this.container.snappingPoint : this.app.stage.snappingPoint;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get area() {\n    return NaN;\n  }\n\n  // TODO: make pivot as abstract getter & setter\n  // eslint-disable-next-line class-methods-use-this\n  get pivot() {\n    return new Point(0, 0);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  set pivot(p) {}\n\n  /**\n   * get position\n   * @getter\n   */\n\n  /**\n   * set position\n   * @setter\n   */\n\n  /**\n   * shape bounds\n   * @getter\n   */\n\n  /**\n   * get color\n   * @getter\n   */\n  get color() {\n    return this._color;\n  }\n\n  /**\n   * set color\n   * @setter\n   */\n  set color(color) {\n    const shouldUpdate = this._color !== color;\n    this._color = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get fill color\n   * @getter\n   */\n  get fillColor() {\n    return this._fillColor;\n  }\n\n  /**\n   * set fill colo\n   * @setter\n   */\n  set fillColor(color) {\n    const shouldUpdate = this._fillColor !== color;\n    this._fillColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border color\n   * @getter\n   */\n  get borderColor() {\n    return this._borderColor;\n  }\n\n  /**\n   * set border color\n   * @setter\n   */\n  set borderColor(color) {\n    const shouldUpdate = this._borderColor !== color;\n    this._borderColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border type\n   * @getter\n   */\n  get borderType() {\n    return this._borderType;\n  }\n\n  /**\n   * set border type\n   * @setter\n   */\n  set borderType(type) {\n    const shouldUpdate = this._borderType !== type;\n    this._borderType = type;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border bold\n   * @getter\n   */\n  get borderBold() {\n    return this._borderBold;\n  }\n\n  /**\n   * set border bold\n   * @setter\n   */\n  set borderBold(bold) {\n    const shouldUpdate = this._borderBold !== bold;\n    this._borderBold = bold;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex color\n   * @getter\n   */\n  get vertexColor() {\n    return this._vertexColor;\n  }\n\n  /**\n   * set vertex color\n   * @setter\n   */\n  set vertexColor(color) {\n    const shouldUpdate = this._vertexColor !== color;\n    this._vertexColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex color\n   * @getter\n   */\n  get vertexType() {\n    return this._vertexType;\n  }\n\n  /**\n   * set vertex color\n   * @setter\n   */\n  set vertexType(type) {\n    const shouldUpdate = this._vertexType !== type;\n    this._vertexType = type;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get display border color\n   * @getter\n   */\n  get displayBorderColor() {\n    if (this.selected) {\n      return this.selectedColor;\n    }\n    if (this.hovered) {\n      return this.hoveredColor;\n    }\n    return this.borderColor;\n  }\n\n  /**\n   * get display vertex color\n   * @getter\n   */\n  get displayVertexColor() {\n    if (this.selected && this.vertexColor === this.color) {\n      return 0x222222;\n    }\n    return this.vertexColor;\n  }\n\n  /**\n   * get alpha\n   * @getter\n   */\n  get alpha() {\n    return this._alpha;\n  }\n\n  /**\n   * set alpha\n   * @setter\n   */\n  set alpha(alpha) {\n    const newAlpha = alpha > 0 ? alpha : 0.005; // for transparent shape, interactions can't be fired\n    const shouldUpdate = this._alpha !== newAlpha;\n    this._alpha = newAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get label\n   * @getter\n   */\n  get label() {\n    return this._label;\n  }\n\n  /**\n   * set label\n   * @setter\n   */\n  set label(label) {\n    this._label = label;\n    this.drawShapeLabel();\n  }\n\n  /**\n   * get border width\n   * @getter\n   */\n  get borderWidth() {\n    return this._borderWidth;\n  }\n\n  /**\n   * set border width\n   * @setter\n   */\n  set borderWidth(borderWidth) {\n    const shouldUpdate = this._borderWidth !== borderWidth;\n    this._borderWidth = borderWidth;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border alpha\n   * @getter\n   */\n  get borderAlpha() {\n    return this._borderAlpha;\n  }\n\n  /**\n   * set border alpha\n   * @setter\n   */\n  set borderAlpha(borderAlpha) {\n    const shouldUpdate = this._borderAlpha !== borderAlpha;\n    this._borderAlpha = borderAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border style\n   * @getter\n   */\n  get borderStyle() {\n    return this._borderStyle;\n  }\n\n  /**\n   * set border style\n   * @setter\n   */\n  set borderStyle(borderStyle) {\n    const shouldUpdate = this._borderStyle !== borderStyle;\n    this._borderStyle = borderStyle;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex\n   * @getter\n   */\n  get showVertex() {\n    return this._showVertex;\n  }\n\n  /**\n   * set show vertex\n   * @setter\n   */\n  set showVertex(showVertex) {\n    const shouldUpdate = this._showVertex !== showVertex;\n    this._showVertex = showVertex;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex order\n   * @getter\n   */\n  get showVertexOrder() {\n    return this._showVertexOrder;\n  }\n\n  /**\n   * set show vertex order\n   * @setter\n   */\n  set showVertexOrder(showVertexOrder) {\n    const shouldUpdate = this._showVertexOrder !== showVertexOrder;\n    this._showVertexOrder = showVertexOrder;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex size\n   * @getter\n   */\n  get vertexSize() {\n    return this._vertexSize;\n  }\n\n  /**\n   * set vertex size\n   * @setter\n   */\n  set vertexSize(vertexSize) {\n    const shouldUpdate = this._vertexSize !== vertexSize;\n    this._vertexSize = vertexSize;\n    if (shouldUpdate && this.showVertex) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex start\n   * @getter\n   */\n  get vertexStart() {\n    return this._vertexStart;\n  }\n\n  /**\n   * set vertex start\n   * @setter\n   */\n  set vertexStart(vertexStart) {\n    const shouldUpdate = this._vertexStart !== vertexStart;\n    this._vertexStart = vertexStart;\n    if (shouldUpdate && this.showVertexOrder) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get order\n   * @getter\n   */\n  get order() {\n    return this._order;\n  }\n\n  /**\n   * set order\n   * @setter\n   */\n  set order(order) {\n    this._order = order;\n    this._updateShapeContainerOrder();\n    if (this.labelDom) {\n      this.labelDom.zIndex = order;\n    }\n  }\n\n  /**\n   * get visible\n   * @getter\n   */\n  get visible() {\n    return this._visible;\n  }\n\n  /**\n   * set visible\n   * @setter\n   */\n  set visible(visible) {\n    const shouldUpdate = this._visible !== visible;\n    this._visible = visible;\n    if (shouldUpdate) {\n      this.instance.visible = visible;\n      this.instance.interactive = visible ? this.interactive : false;\n      this.labelContainer.visible = visible;\n      this.vertexesContainer.visible = visible;\n      this.userDataContainer.visible = visible;\n      this.controlsContainer.visible = visible;\n      if (this.labelDom) {\n        this.labelDom.visible = visible;\n      }\n    }\n  }\n\n  /**\n   * get interactive\n   * @getter\n   */\n  get interactive() {\n    return this._interactive;\n  }\n\n  /**\n   * set interactive\n   * @setter\n   */\n  set interactive(interactive) {\n    this._interactive = interactive;\n    if (this.instance) {\n      this.instance.interactive = interactive;\n    }\n    this._controls.forEach(c => {\n      c.control.interactive = interactive;\n    });\n    if (!interactive) {\n      this.selected = false;\n      this.hovered = false;\n    }\n  }\n\n  /**\n   * get editable\n   * @getter\n   */\n  get editable() {\n    return this._editable;\n  }\n\n  /**\n   * set editable\n   * @setter\n   */\n  set editable(editable) {\n    this._editable = editable;\n    this.drawShape();\n  }\n\n  /**\n   * get draggable\n   * @getter\n   */\n  get draggable() {\n    return this._draggable;\n  }\n\n  /**\n   * set draggable\n   * @setter\n   */\n  set draggable(draggable) {\n    this._draggable = this._defaultDraggable && draggable;\n  }\n\n  /**\n   * get rotatable\n   * @getter\n   */\n  get rotatable() {\n    return this._rotatable;\n  }\n\n  /**\n   * set rotatable\n   * @setter\n   */\n  set rotatable(rotatable) {\n    this._rotatable = rotatable;\n  }\n\n  /**\n   * get shape finished\n   * @getter\n   */\n  get finished() {\n    return this._finished;\n  }\n\n  /**\n   * get selected\n   * @getter\n   */\n  get selected() {\n    return this._selected;\n  }\n\n  /**\n   * set selected\n   * @setter\n   */\n  set selected(selected) {\n    const shouldUpdate = this._selected !== selected;\n    this._selected = selected;\n    this._updateShapeContainerOrder();\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get hovered\n   * @getter\n   */\n  get hovered() {\n    return this._hovered;\n  }\n\n  /**\n   * set hovered\n   * @setter\n   */\n  set hovered(hovered) {\n    const shouldUpdate = this._hovered !== hovered;\n    this._hovered = hovered;\n    if (shouldUpdate) {\n      this.userDataContainer.visible = hovered && this.userDataMode === UserDataMode.HOVER || this.userDataMode === UserDataMode.ALWAYS;\n      this.drawShape();\n      this._emit(hovered ? EventAction.POINTER_OVER : EventAction.POINTER_OUT);\n    }\n    // should update stage cursor because instance cursor not show when covered by others\n    if (hovered) {\n      this.instance.cursor = this.editable && this.draggable ? Cursor.MOVE : Cursor.POINTER;\n    } else {\n      this.instance.cursor = Cursor.DEFAULT;\n    }\n  }\n\n  /**\n   * get scale\n   * @getter\n   */\n  get scale() {\n    return this._scale;\n  }\n\n  /**\n   * set scale\n   * @setter\n   */\n  set scale(scale) {\n    const shouldUpdate = this._scale !== scale;\n    this._scale = scale;\n    this._controls.forEach(c => {\n      // eslint-disable-next-line no-param-reassign\n      c.scale = scale;\n    });\n    if (this._rotateControl) {\n      this._rotateControl.scale = scale;\n    }\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get rotation\n   * @getter\n   */\n  get rotation() {\n    return this._rotation;\n  }\n\n  /**\n   * set rotation\n   * @setter\n   */\n  set rotation(rotation) {\n    this._rotation = rotation;\n    this._updatePosition();\n    this.drawShape();\n  }\n\n  /**\n   * get user data mode\n   * @getter\n   */\n  get userDataMode() {\n    return this._userDataMode;\n  }\n\n  /**\n   * set user data mode\n   * @setter\n   */\n  set userDataMode(mode) {\n    this._userDataMode = mode;\n    this.userDataContainer.visible = this._userDataMode === UserDataMode.ALWAYS;\n  }\n\n  /**\n   * user data formatter\n   */\n\n  constructor({\n    app,\n    container,\n    scale,\n    color,\n    fillColor,\n    borderColor,\n    borderType,\n    borderBold,\n    vertexColor,\n    vertexType,\n    selectedColor,\n    alpha,\n    label,\n    borderWidth,\n    borderAlpha,\n    borderStyle,\n    showVertex,\n    showVertexOrder,\n    vertexSize,\n    vertexStart,\n    bounds,\n    draggable = true,\n    rotatable = false,\n    labelDom,\n    userDataFormatter\n  }) {\n    /**\n     * shape type\n     */\n    this.shapeType = void 0;\n    /**\n     * unique id\n     * @member {string}\n     */\n    this.uid = uuidv4();\n    /**\n     * PIXI instance\n     * @member {ShapeGraphics}\n     */\n    this.instance = new ShapeGraphics(this);\n    /**\n     * PIXI application\n     * @member {PIXI.Application}\n     */\n    this.app = void 0;\n    /**\n     * PIXI container\n     * @member {PIXI.Container | Layer}\n     */\n    this.container = void 0;\n    /**\n     * origin colors from shape options\n     */\n    this.originColors = {\n      color: 0,\n      fillColor: 0,\n      borderColor: 0,\n      vertexColor: 0\n    };\n    /**\n     * selected border color\n     * @member {number}\n     */\n    this.selectedColor = 0xFFFF00;\n    /**\n     * hovered border color\n     * @member {number}\n     */\n    this.hoveredColor = 0xCCCCCC;\n    /**\n     * bounds need check when drawing, resizing, moving\n     */\n    this.bounds = null;\n    /**\n     * shape container\n     * @member {PIXI.Container}\n     */\n    this.shapeContainer = new Container();\n    /**\n     * controls container\n     * @member {PIXI.Container}\n     */\n    this.controlsContainer = new Container();\n    /**\n     * label container\n     * @member {PIXI.Container}\n     */\n    this.labelContainer = new Container();\n    /**\n     * label dom\n     * @member {Label}\n     */\n    this.labelDom = void 0;\n    /**\n     * container to show shape vertexes\n     * @member {PIXI.Container}\n     */\n    this.vertexesContainer = new Container();\n    /**\n     * container to show user defined data\n     * @member {PIXI.Container}\n     */\n    this.userDataContainer = new Container();\n    /**\n     * is shape destroyed\n     * @member {boolean}\n     */\n    this.destroyed = false;\n    /**\n     * is shape resizing\n     * @member {boolean}\n     */\n    this.resizing = false;\n    /**\n     * is shape dragging\n     * @member {boolean}\n     */\n    this.dragging = false;\n    /**\n     * custom data\n     * @member {any}\n     */\n    this.data = void 0;\n    /**\n     * events emitter\n     * @private {PIXI.utils.EventEmitter}\n     */\n    this._eventEmitter = new PIXIUtils.EventEmitter();\n    /**\n     * controls\n     * @protected {Control[]}\n     */\n    this._controls = [];\n    /**\n     * rotate_btn\n     * @protected {ControlRotation}\n     */\n    this._rotateControl = void 0;\n    /**\n     * color\n     * @protected {number}\n     */\n    this._color = 0;\n    /**\n     * fill color\n     * @protected {number}\n     */\n    this._fillColor = 0;\n    /**\n     * border color\n     * @protected {number}\n     */\n    this._borderColor = 0;\n    /**\n     * border type\n     * @protected {ShapeLineType}\n     */\n    this._borderType = ShapeLineType.STRAIGHT;\n    /**\n     * border bold\n     * @protected {boolean}\n     */\n    this._borderBold = false;\n    /**\n     * vertex color\n     * @protected {number}\n     */\n    this._vertexColor = 0;\n    /**\n     * vertex type\n     * @protected {ShapeVertexType}\n     */\n    this._vertexType = ShapeVertexType.DOT;\n    /**\n     * shape alpha\n     * @protected {number}\n     */\n    this._alpha = 0.5;\n    /**\n     * shape label\n     * @protected {string}\n     */\n    this._label = '';\n    /**\n     * shape border width\n     * @protected {number}\n     */\n    this._borderWidth = 1;\n    /**\n     * shape border alpha\n     * @protected {number}\n     */\n    this._borderAlpha = 1;\n    /**\n     * shape border style\n     * @protected {BorderStyle}\n     */\n    this._borderStyle = BorderStyle.SOLID;\n    /**\n     * show shape vertex\n     * @protected {boolean}\n     */\n    this._showVertex = false;\n    /**\n     * show shape vertex order\n     * @protected {boolean}\n     */\n    this._showVertexOrder = false;\n    /**\n     * shape vertex dot size\n     * @protected {number}\n     */\n    this._vertexSize = 4;\n    /**\n     * shape vertex start number\n     * @protected {number}\n     */\n    this._vertexStart = 0;\n    /**\n     * shape z-index\n     * @protected {number}\n     */\n    this._order = 0;\n    /**\n     * is shape visible\n     * @protected {boolean}\n     */\n    this._visible = true;\n    /**\n     * is shape interactive\n     * @protected {boolean}\n     */\n    this._interactive = true;\n    /**\n     * is shape editable\n     * @protected {boolean}\n     */\n    this._editable = true;\n    /**\n     * is shape draggable\n     * @protected {boolean}\n     */\n    this._draggable = true;\n    /**\n     * is shape rotatable\n     * @protected {boolean}\n     */\n    this._rotatable = false;\n    /**\n     * is shape drawing finished\n     * @protected {boolean}\n     */\n    this._finished = true;\n    /**\n     * is shape selected\n     * @protected {boolean}\n     */\n    this._selected = false;\n    /**\n     * is shape hovered\n     * @protected {boolean}\n     */\n    this._hovered = false;\n    /**\n     * shape scale factor\n     * @protected {boolean}\n     */\n    this._scale = 1;\n    /**\n     * shape rotation\n     * @protected {number}\n     */\n    this._rotation = 0;\n    /**\n     * user data display mode\n     * @protected {UserDataMode}\n     */\n    this._userDataMode = UserDataMode.HIDE;\n    /**\n     * point when snapping\n     * @protected {Point}\n     */\n    this._snappingPoint = null;\n    /**\n     * is ctrl key down\n     * @protected {boolean}\n     */\n    this._ctrlKey = false;\n    /**\n     * default shape draggable\n     * @private {boolean}\n     */\n    this._defaultDraggable = true;\n    /**\n     * mouse position when click to drag\n     * @private {Point}\n     */\n    this._dragPoint = null;\n    /**\n     * instance position when click to drag\n     * @private {Point}\n     */\n    this._dragPosistion = null;\n    /**\n     * is instance been dragged\n     * @private {boolean}\n     */\n    this._dragged = false;\n    /**\n     * last pivot\n     * @private {Point|undefined}\n     */\n    this._lastPivot = void 0;\n    this.userDataFormatter = void 0;\n    /**\n     * process pointerdown\n     * @param event\n     * @param frontTargets\n     */\n    this.processPointerDown = (event, frontTargets = []) => {\n      if (event.data.button === 2) {\n        return;\n      }\n      if (this.hovered) {\n        event.stopPropagation();\n        const p = event.data.getLocalPosition(this.container);\n        if (this.draggable) {\n          this._dragPoint = new Point(p.x, p.y);\n          this._dragPosistion = this.position;\n          this._dragged = false;\n        }\n        this.selected = true;\n        this._emit(EventAction.SELECTED, p);\n        // disable controls interactivity when first pointer down to selected (avoid bugs when start dragging on controls)\n        this._controls.forEach(c => {\n          c.control.interactive = false;\n        });\n      }\n      if (!this._snappingPoint) {\n        // if upper shapes has snapping point, do not propogating\n        this._continuePropogating(event, frontTargets, 'processPointerDown');\n      }\n    };\n    /**\n     * process pointerup\n     * @param event\n     * @param frontTargets\n     */\n    this.processPointerUp = (event, frontTargets = []) => {\n      // re-active controls when pointer up\n      this._controls.forEach(c => {\n        c.control.interactive = true;\n      });\n      this.dragging = false;\n      this._dragPoint = null;\n      this._dragPosistion = null;\n      if (this._dragged) {\n        this._changed();\n        this._dragged = false;\n      }\n      this._continuePropogating(event, frontTargets, 'processPointerUp');\n    };\n    /**\n     * process pointermove\n     * @param event\n     */\n    this.processPointerMove = event => {\n      if (this.editable && this.selected && this.snap(event)) {\n        // snapping\n        this.instance.cursor = Cursor.DEFAULT;\n      } else if (this.editable && this.selected && this._dragPoint && this._dragPosistion) {\n        // dragging\n        this._dragged = true;\n        this._ctrlKey = event.data.originalEvent.ctrlKey;\n        const point = event.data.getLocalPosition(this.container);\n        const originX = this.position.x;\n        const originY = this.position.y;\n        const position = new Point(this._dragPosistion.x + (point.x - this._dragPoint.x), this._dragPosistion.y + (point.y - this._dragPoint.y));\n        // prefer to use global snapping point if moving a dot\n        this.position = this.shapeType === ShapeType.DOT && this.globalSnappingPoint ? this.globalSnappingPoint : position;\n        this._keepInstanceInBounds();\n        this._updatePosition();\n        this._dragging({\n          deltaX: this.position.x - originX,\n          deltaY: this.position.y - originY\n        });\n      }\n    };\n    /**\n     * process app mouse down\n     */\n    this.processGlobalMouseDown = () => {\n      if (this._snappingPoint) {\n        const success = this.addSnappingPointToShape();\n        if (success) {\n          // set selected\n          this.selected = true;\n          this._emit(EventAction.SELECTED);\n          // ignore drag start\n          this._dragPoint = null;\n          this._dragPosistion = null;\n        }\n      }\n    };\n    this.instance.on('pointerdown', this.processPointerDown);\n    this.instance.on('pointerup', this.processPointerUp);\n    this.instance.on('pointerupoutside', this.processPointerUp);\n    this.instance.on('pointermove', this.processPointerMove);\n    this.app = app;\n    this.app.view.addEventListener('mousedown', this.processGlobalMouseDown, false);\n    this.container = container || app.stage;\n    this.instance.interactive = this.interactive;\n    this.labelContainer.interactive = false;\n    this.vertexesContainer.interactive = false;\n    this.userDataContainer.interactive = false;\n    this.controlsContainer.zIndex = 9999;\n    this.shapeContainer.addChild(this.instance);\n    this.shapeContainer.addChild(this.labelContainer);\n    this.shapeContainer.addChild(this.vertexesContainer);\n    this.shapeContainer.addChild(this.userDataContainer);\n    this.container.addChild(this.shapeContainer);\n    this.container.addChild(this.controlsContainer);\n    this._scale = scale || app.stage.scale.x;\n    this.userDataMode = UserDataMode.HIDE;\n    if (color !== undefined) {\n      this._color = color;\n      this._fillColor = color;\n      this._borderColor = color;\n      this._vertexColor = color;\n    }\n    if (fillColor !== undefined) {\n      this._fillColor = fillColor; // reset fill color\n    }\n    if (borderColor !== undefined) {\n      this._borderColor = borderColor;\n    }\n    if (borderType !== undefined) {\n      this._borderType = borderType;\n    }\n    if (borderBold !== undefined) {\n      this._borderBold = borderBold;\n    }\n    if (vertexColor !== undefined) {\n      this._vertexColor = vertexColor;\n    }\n    if (vertexType !== undefined) {\n      this._vertexType = vertexType;\n    }\n    this.originColors = {\n      color: this._color,\n      fillColor: this._fillColor,\n      borderColor: this._borderColor,\n      vertexColor: this._vertexColor\n    };\n    if (selectedColor !== undefined) {\n      this.selectedColor = selectedColor;\n    }\n    if (alpha !== undefined) {\n      this._alpha = alpha > 0 ? alpha : 0.005;\n    }\n    if (label !== undefined) {\n      this._label = label;\n    }\n    if (borderWidth !== undefined) {\n      this._borderWidth = borderWidth;\n    }\n    if (borderAlpha !== undefined) {\n      this._borderAlpha = borderAlpha;\n    }\n    if (borderStyle !== undefined) {\n      this._borderStyle = borderStyle;\n    }\n    if (showVertex !== undefined) {\n      this._showVertex = showVertex;\n    }\n    if (showVertexOrder !== undefined) {\n      this._showVertexOrder = showVertexOrder;\n    }\n    if (vertexSize !== undefined) {\n      this._vertexSize = vertexSize;\n    }\n    if (vertexStart !== undefined) {\n      this._vertexStart = vertexStart;\n    }\n    if (bounds !== undefined) {\n      this.bounds = bounds;\n    }\n    this._defaultDraggable = draggable;\n    this._draggable = draggable;\n    this._rotatable = rotatable;\n    this.labelDom = labelDom;\n    if (userDataFormatter) {\n      this.userDataFormatter = userDataFormatter;\n    }\n  }\n\n  /**\n   * update container position\n   * @protected\n   */\n  _updatePosition(resize = false) {\n    const pivot = this.pivot.clone();\n    if (resize && this._lastPivot) {\n      // resize change pivot\n      const rotatedPivot = computeRotatedPosition(this._lastPivot, pivot, this.rotation);\n      pivot.x = rotatedPivot.x;\n      pivot.y = rotatedPivot.y;\n      this.pivot = pivot;\n    }\n    this.shapeContainer.pivot.set(pivot.x, pivot.y);\n    this.shapeContainer.position.set(pivot.x, pivot.y);\n    this.shapeContainer.rotation = this.rotation;\n    this._lastPivot = pivot.clone();\n    this.controlsContainer.pivot.set(pivot.x, pivot.y);\n    this.controlsContainer.position.set(pivot.x, pivot.y);\n    this.controlsContainer.rotation = this.rotation;\n  }\n  /**\n   * propogating event to back shapes\n   * @param event\n   * @param frontTargets\n   * @param funcName\n   */\n  _continuePropogating(event, frontTargets, funcName) {\n    this.instance.interactive = false;\n    const {\n      interaction\n    } = this.app.renderer.plugins;\n    const hit = interaction.hitTest(event.data.global);\n    if (hit && hit instanceof ShapeGraphics && !frontTargets.includes(this.instance)) {\n      hit.shape[funcName](event, [...frontTargets, this.instance]);\n    }\n    this.instance.interactive = true;\n  }\n  /**\n   * actual draw the shape on canvas\n   */\n  /**\n   * start shape create\n   * @param point create start point\n   * @param options options used for creation\n   */\n  /**\n   * get label position of the shape\n   */\n  /**\n   * get shape data\n   */\n  /**\n   * get shape Geo JSON (multi polygon)\n   */\n  /**\n   * delete selected points in shape, default reture false and can be overwritten in sub class\n   */\n  deleteSelectedPoints() {\n    return false; // false means no point deleted\n  }\n\n  /**\n   * snap to shape vertexes or edges\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point, tolerance) {\n    return null;\n  }\n\n  /**\n   * snap to shape edges\n   * @param point\n   */\n  snap(event) {\n    this._snappingPoint = null;\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    return false;\n  }\n\n  /**\n   * draw shape label\n   */\n  drawShapeLabel() {\n    this.labelContainer.removeChildren();\n    const borderOffset = this.shapeType !== ShapeType.DOT ? this.borderWidth / 2 : 0;\n    const vertexOffset = (this.shapeType === ShapeType.POLYGON || this.shapeType === ShapeType.LINE || this.shapeType === ShapeType.ARROW || this.shapeType === ShapeType.RECTANGLE) && this.showVertex ? this.vertexSize : 0;\n    if (this.labelDom) {\n      // use dom to render\n      if (this.label) {\n        this.labelDom.text = this.label;\n        this.labelDom.zIndex = this.order;\n        const position = this.getLabelPosition();\n        const globalPosition = this.container.toGlobal({\n          x: position.x,\n          y: position.y - (borderOffset + vertexOffset) / this.scale\n        });\n        const globalPivot = this.container.toGlobal(this.pivot);\n        this.labelDom.setPosition(globalPosition, globalPivot, this.rotation);\n      }\n      return;\n    }\n    if (this.label) {\n      const {\n        x,\n        y\n      } = this.getLabelPosition();\n      this.labelContainer.position.x = x;\n      this.labelContainer.position.y = y - (18 + borderOffset + vertexOffset) / this.scale;\n      this.labelContainer.scale.set(1 / this.scale);\n      const text = new Text(` ${this.label} `, {\n        fontSize: 14,\n        lineHeight: 18,\n        fill: '#FFFFFF'\n      });\n      const {\n        width,\n        height\n      } = text.getBounds();\n      const bounds = new Graphics();\n      bounds.beginFill(0, 0.6);\n      bounds.drawRect(0, 0, width, height);\n      bounds.endFill();\n      this.labelContainer.addChild(bounds);\n      this.labelContainer.addChild(text);\n    }\n  }\n\n  /**\n   * finish shape create\n   * @protected\n   */\n  _finish() {\n    if (!this.destroyed) {\n      this._finished = true;\n      this.drawShape();\n      this._emit(EventAction.FINISHED);\n    }\n  }\n\n  /**\n   * remove shape from canvas\n   * @protected\n   */\n  _remove() {\n    this._emit(EventAction.REMOVED);\n    this.destroy();\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  _changed() {\n    this._emit(EventAction.CHANGED, this.getData());\n  }\n\n  /**\n   * when shape is been dragging\n   * @param data\n   * @protected\n   */\n  _dragging(data) {\n    this.dragging = true;\n    this._emit(EventAction.DRAGGING, {\n      ...data\n    });\n  }\n\n  /**\n   * when shape is reszing\n   * @param data\n   * @protected\n   */\n  _resizing(data) {\n    this.resizing = true;\n    this._emit(EventAction.RESIZING, {\n      ...data\n    });\n  }\n\n  /**\n   * get global position\n   * @returns\n   */\n  getGlobalPosition() {\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.shapeBounds;\n    const center = new Point(left + (right - left) / 2, top + (bottom - top) / 2);\n    const {\n      x,\n      y\n    } = this.container.toGlobal(center);\n    return {\n      x,\n      y\n    };\n  }\n\n  /**\n   * find intersections\n   * @param shapes\n   */\n  findIntersections(shapes) {\n    const currentShapeData = this.getAreaAsGeoJSON();\n    const filteredShapes = shapes.filter(s => s.uid !== this.uid);\n    return findIntersections(currentShapeData, this.shapeBounds, this.shapeType, filteredShapes);\n  }\n\n  /**\n   * update shape position\n   * @param x\n   * @param y\n   */\n  updatePosition(x, y) {\n    this.position = new Point(x, y);\n    this._keepInstanceInBounds();\n    this._updatePosition();\n  }\n\n  /**\n   * destroy shape\n   */\n  destroy() {\n    if (this.destroyed) {\n      return;\n    }\n    this.app.view.removeEventListener('mousedown', this.processGlobalMouseDown, false);\n    // remove all listeners\n    Object.values(EventAction).forEach(action => {\n      this.off(action);\n    });\n    // remove control points\n    this._controls.forEach(c => {\n      c.destroy();\n    });\n    this._controls = [];\n    this.container.removeChild(this.controlsContainer);\n    this.controlsContainer.destroy({\n      children: true,\n      texture: true,\n      baseTexture: true\n    });\n    // remove rotation control\n    if (this._rotateControl) {\n      this._rotateControl.destroy();\n    }\n    // destroy shapeContainer\n    this.container.removeChild(this.shapeContainer);\n    this.shapeContainer.destroy({\n      children: true,\n      texture: true,\n      baseTexture: true\n    });\n    // remove dom if possible\n    if (this.labelDom) {\n      this.labelDom.remove();\n      this.labelDom = undefined;\n    }\n    // remove data\n    if (this.data) {\n      this.data = undefined;\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * remove controls\n   */\n  removeControls() {\n    // remove control points\n    this._controls.forEach(c => {\n      c.remove();\n    });\n    this._controls = [];\n  }\n\n  /**\n   * emit event\n   * @protected\n   * @param eventName\n   */\n  _emit(eventName, ...args) {\n    this._eventEmitter.emit(eventName, this, ...args);\n  }\n\n  /**\n   * add listener\n   * @param eventName\n   * @param callback\n   */\n  on(eventName, callback) {\n    this._eventEmitter.on(eventName, callback);\n    return this;\n  }\n\n  /**\n   * remove listener\n   * @param eventName\n   * @param callback\n   */\n  off(eventName, callback) {\n    if (callback) {\n      this._eventEmitter.removeListener(eventName, callback);\n    } else {\n      this._eventEmitter.removeAllListeners(eventName);\n    }\n    return this;\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @protected\n   * @param x screen position x\n   * @param y screen position y\n   */\n  _mapScreenToStagePosition(x, y) {\n    const point = new Point();\n    this.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @protected\n   * @param point\n   */\n  _mapStageToLocalPosition(point) {\n    return this.container.toLocal(point);\n  }\n\n  /**\n   * keep point inside boundary\n   * @param point\n   */\n  _keepPointInBounds(point) {\n    if (!this.bounds) {\n      return point;\n    }\n    let {\n      x,\n      y\n    } = point;\n    const {\n      top,\n      right,\n      bottom,\n      left\n    } = this.bounds;\n    if (x < left) {\n      x = left;\n    } else if (x > right) {\n      x = right;\n    }\n    if (y < top) {\n      y = top;\n    } else if (y > bottom) {\n      y = bottom;\n    }\n    return new Point(x, y);\n  }\n\n  /**\n   * keep instance inside boundary\n   */\n  _keepInstanceInBounds() {\n    if (!this.bounds) {\n      return;\n    }\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = this.shapeBounds;\n    const {\n      left: bLeft,\n      top: bTop,\n      right: bRight,\n      bottom: bBottom\n    } = this.bounds;\n    const position = {\n      x: this.position.x,\n      y: this.position.y\n    };\n    if (left < bLeft) {\n      position.x += -left;\n    } else if (right > bRight) {\n      position.x -= right - bRight;\n    }\n    if (top < bTop) {\n      position.y += -top;\n    } else if (bottom > bBottom) {\n      position.y -= bottom - bBottom;\n    }\n    if (this.position.x !== position.x || this.position.y !== position.y) {\n      this.position = new Point(position.x, position.y);\n    }\n  }\n\n  /**\n   * update shape container order\n   */\n  _updateShapeContainerOrder() {\n    this.shapeContainer.zIndex = this.selected ? 9999 : this.order;\n  }\n}","map":{"version":3,"names":["v4","uuidv4","Container","Graphics","Point","Text","utils","PIXIUtils","Layer","ShapeGraphics","ShapeType","ShapeVertexType","ShapeLineType","findIntersections","Cursor","computeRotatedPosition","EventAction","BorderStyle","UserDataMode","Shape","globalSnappingPoint","container","snappingPoint","app","stage","area","NaN","pivot","p","color","_color","shouldUpdate","drawShape","fillColor","_fillColor","borderColor","_borderColor","borderType","_borderType","type","borderBold","_borderBold","bold","vertexColor","_vertexColor","vertexType","_vertexType","displayBorderColor","selected","selectedColor","hovered","hoveredColor","displayVertexColor","alpha","_alpha","newAlpha","label","_label","drawShapeLabel","borderWidth","_borderWidth","borderAlpha","_borderAlpha","borderStyle","_borderStyle","showVertex","_showVertex","showVertexOrder","_showVertexOrder","vertexSize","_vertexSize","vertexStart","_vertexStart","order","_order","_updateShapeContainerOrder","labelDom","zIndex","visible","_visible","instance","interactive","labelContainer","vertexesContainer","userDataContainer","controlsContainer","_interactive","_controls","forEach","c","control","editable","_editable","draggable","_draggable","_defaultDraggable","rotatable","_rotatable","finished","_finished","_selected","_hovered","userDataMode","HOVER","ALWAYS","_emit","POINTER_OVER","POINTER_OUT","cursor","MOVE","POINTER","DEFAULT","scale","_scale","_rotateControl","rotation","_rotation","_updatePosition","_userDataMode","mode","constructor","bounds","userDataFormatter","shapeType","uid","originColors","shapeContainer","destroyed","resizing","dragging","data","_eventEmitter","EventEmitter","STRAIGHT","DOT","SOLID","HIDE","_snappingPoint","_ctrlKey","_dragPoint","_dragPosistion","_dragged","_lastPivot","processPointerDown","event","frontTargets","button","stopPropagation","getLocalPosition","x","y","position","SELECTED","_continuePropogating","processPointerUp","_changed","processPointerMove","snap","originalEvent","ctrlKey","point","originX","originY","_keepInstanceInBounds","_dragging","deltaX","deltaY","processGlobalMouseDown","success","addSnappingPointToShape","on","view","addEventListener","addChild","undefined","resize","clone","rotatedPivot","set","funcName","interaction","renderer","plugins","hit","hitTest","global","includes","shape","deleteSelectedPoints","snapToPoint","tolerance","removeChildren","borderOffset","vertexOffset","POLYGON","LINE","ARROW","RECTANGLE","text","getLabelPosition","globalPosition","toGlobal","globalPivot","setPosition","fontSize","lineHeight","fill","width","height","getBounds","beginFill","drawRect","endFill","_finish","FINISHED","_remove","REMOVED","destroy","CHANGED","getData","DRAGGING","_resizing","RESIZING","getGlobalPosition","left","right","top","bottom","shapeBounds","center","shapes","currentShapeData","getAreaAsGeoJSON","filteredShapes","filter","s","updatePosition","removeEventListener","Object","values","action","off","removeChild","children","texture","baseTexture","remove","removeControls","eventName","args","emit","callback","removeListener","removeAllListeners","_mapScreenToStagePosition","mapPositionToPoint","_mapStageToLocalPosition","toLocal","_keepPointInBounds","bLeft","bTop","bRight","bBottom"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/Shape.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { Application, Container, Graphics, InteractionEvent, Point, Text, utils as PIXIUtils } from 'pixi.js';\nimport { Geom } from 'polygon-clipping';\nimport Layer from './Layer';\nimport ShapeGraphics from './ShapeGraphics';\nimport { ShapeType, ShapeData, ShapeVertexType, ShapeLineType } from './types';\nimport Control from './controls/Control';\nimport ControlRotation from './controls/ControlRotation';\nimport Label from './label/Label';\nimport { findIntersections } from './utils';\nimport Cursor from '../Cursor';\nimport { computeRotatedPosition } from '../../../utils/math';\n\nexport enum EventAction {\n  SELECTED = 'selected',\n  VERTEX_SELECTED = 'vertex-selected',\n  FINISHED = 'finished',\n  REMOVED = 'removed',\n  CHANGED = 'changed',\n  DRAGGING = 'dragging',\n  RESIZING = 'resizing',\n  POINTER_OVER = 'pointer-over',\n  POINTER_OUT = 'pointer-out',\n  RECOGNITION = 'recognition',\n}\n\nexport enum BorderStyle {\n  SOLID = 'solid',\n  DASHED = 'dashed',\n}\n\nexport enum UserDataMode {\n  HIDE = 'hide',\n  HOVER = 'hover',\n  ALWAYS = 'always',\n}\n\ninterface Bounds {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface ShapeOptions {\n  app: Application;\n  container?: Container;\n  scale?: number;\n  color?: number; // default for vertexes, edges & fill\n  fillColor?: number; // specially for fill (use color if not given)\n  borderColor?: number;\n  borderType?: ShapeLineType;\n  borderBold?: boolean;\n  vertexColor?: number;\n  vertexType?: ShapeVertexType;\n  selectedColor?: number;\n  alpha?: number;\n  label?: string;\n  borderWidth?: number;\n  borderAlpha?: number;\n  borderStyle?: BorderStyle;\n  showVertex?: boolean;\n  showVertexOrder?: boolean;\n  vertexSize?: number;\n  vertexStart?: number;\n  bounds?: Bounds;\n  draggable?: boolean;\n  rotatable?: boolean;\n  labelDom?: Label;\n  userDataFormatter?: (userData: any) => string;\n}\n\n/**\n * Shape base\n * @class\n */\nexport default abstract class Shape<T> {\n  /**\n   * shape type\n   */\n  abstract shapeType: ShapeType;\n\n  /**\n   * unique id\n   * @member {string}\n   */\n  uid = uuidv4();\n\n  /**\n   * PIXI instance\n   * @member {ShapeGraphics}\n   */\n  instance = new ShapeGraphics<T>(this);\n\n  /**\n   * PIXI application\n   * @member {PIXI.Application}\n   */\n  app: Application;\n\n  /**\n   * PIXI container\n   * @member {PIXI.Container | Layer}\n   */\n  container: Container | Layer;\n\n  /**\n   * origin colors from shape options\n   */\n  originColors: {\n    color: number;\n    fillColor: number;\n    borderColor: number;\n    vertexColor: number;\n  } = {\n    color: 0,\n    fillColor: 0,\n    borderColor: 0,\n    vertexColor: 0,\n  };\n\n  /**\n   * selected border color\n   * @member {number}\n   */\n  selectedColor = 0xFFFF00;\n\n  /**\n   * hovered border color\n   * @member {number}\n   */\n  hoveredColor = 0xCCCCCC;\n\n  /**\n   * bounds need check when drawing, resizing, moving\n   */\n  bounds: Bounds | null = null;\n\n  /**\n   * shape container\n   * @member {PIXI.Container}\n   */\n  shapeContainer = new Container();\n\n  /**\n   * controls container\n   * @member {PIXI.Container}\n   */\n  controlsContainer = new Container();\n\n  /**\n   * label container\n   * @member {PIXI.Container}\n   */\n  labelContainer = new Container();\n\n  /**\n   * label dom\n   * @member {Label}\n   */\n  labelDom?: Label;\n\n  /**\n   * container to show shape vertexes\n   * @member {PIXI.Container}\n   */\n  vertexesContainer = new Container();\n\n  /**\n   * container to show user defined data\n   * @member {PIXI.Container}\n   */\n  userDataContainer = new Container();\n\n  /**\n   * is shape destroyed\n   * @member {boolean}\n   */\n  destroyed = false;\n\n  /**\n   * is shape resizing\n   * @member {boolean}\n   */\n  resizing = false;\n\n  /**\n   * is shape dragging\n   * @member {boolean}\n   */\n  dragging = false;\n\n  /**\n   * custom data\n   * @member {any}\n   */\n  data: any;\n\n  /**\n   * events emitter\n   * @private {PIXI.utils.EventEmitter}\n   */\n  private _eventEmitter = new PIXIUtils.EventEmitter();\n\n  /**\n   * controls\n   * @protected {Control[]}\n   */\n  protected _controls: Control[] = [];\n\n  /**\n   * rotate_btn\n   * @protected {ControlRotation}\n   */\n  protected _rotateControl?: ControlRotation;\n\n  /**\n   * color\n   * @protected {number}\n   */\n  protected _color = 0;\n\n  /**\n   * fill color\n   * @protected {number}\n   */\n  protected _fillColor = 0;\n\n  /**\n   * border color\n   * @protected {number}\n   */\n  protected _borderColor = 0;\n\n  /**\n   * border type\n   * @protected {ShapeLineType}\n   */\n  protected _borderType = ShapeLineType.STRAIGHT;\n\n  /**\n   * border bold\n   * @protected {boolean}\n   */\n  protected _borderBold = false;\n\n  /**\n   * vertex color\n   * @protected {number}\n   */\n  protected _vertexColor = 0;\n\n  /**\n   * vertex type\n   * @protected {ShapeVertexType}\n   */\n  protected _vertexType = ShapeVertexType.DOT;\n\n  /**\n   * shape alpha\n   * @protected {number}\n   */\n  protected _alpha = 0.5;\n\n  /**\n   * shape label\n   * @protected {string}\n   */\n  protected _label = '';\n\n  /**\n   * shape border width\n   * @protected {number}\n   */\n  protected _borderWidth = 1;\n\n  /**\n   * shape border alpha\n   * @protected {number}\n   */\n  protected _borderAlpha = 1;\n\n  /**\n   * shape border style\n   * @protected {BorderStyle}\n   */\n  protected _borderStyle = BorderStyle.SOLID;\n\n  /**\n   * show shape vertex\n   * @protected {boolean}\n   */\n  protected _showVertex = false;\n\n  /**\n   * show shape vertex order\n   * @protected {boolean}\n   */\n  protected _showVertexOrder = false;\n\n  /**\n   * shape vertex dot size\n   * @protected {number}\n   */\n  protected _vertexSize = 4;\n\n  /**\n   * shape vertex start number\n   * @protected {number}\n   */\n  protected _vertexStart = 0;\n\n  /**\n   * shape z-index\n   * @protected {number}\n   */\n  protected _order = 0;\n\n  /**\n   * is shape visible\n   * @protected {boolean}\n   */\n  protected _visible = true;\n\n  /**\n   * is shape interactive\n   * @protected {boolean}\n   */\n  protected _interactive = true;\n\n  /**\n   * is shape editable\n   * @protected {boolean}\n   */\n  protected _editable = true;\n\n  /**\n   * is shape draggable\n   * @protected {boolean}\n   */\n  protected _draggable = true;\n\n  /**\n   * is shape rotatable\n   * @protected {boolean}\n   */\n  protected _rotatable = false;\n\n  /**\n   * is shape drawing finished\n   * @protected {boolean}\n   */\n  protected _finished = true;\n\n  /**\n   * is shape selected\n   * @protected {boolean}\n   */\n  protected _selected = false;\n\n  /**\n   * is shape hovered\n   * @protected {boolean}\n   */\n  protected _hovered = false;\n\n  /**\n   * shape scale factor\n   * @protected {boolean}\n   */\n  protected _scale = 1;\n\n  /**\n   * shape rotation\n   * @protected {number}\n   */\n  protected _rotation = 0;\n\n  /**\n   * user data display mode\n   * @protected {UserDataMode}\n   */\n  protected _userDataMode = UserDataMode.HIDE;\n\n  /**\n   * point when snapping\n   * @protected {Point}\n   */\n  protected _snappingPoint: Point | null = null;\n\n  /**\n   * is ctrl key down\n   * @protected {boolean}\n   */\n  protected _ctrlKey = false;\n\n  /**\n   * default shape draggable\n   * @private {boolean}\n   */\n  private _defaultDraggable = true;\n\n  /**\n   * mouse position when click to drag\n   * @private {Point}\n   */\n  private _dragPoint: Point | null = null;\n\n  /**\n   * instance position when click to drag\n   * @private {Point}\n   */\n  private _dragPosistion: Point | null = null;\n\n  /**\n   * is instance been dragged\n   * @private {boolean}\n   */\n  private _dragged = false;\n\n  /**\n   * last pivot\n   * @private {Point|undefined}\n   */\n  private _lastPivot: Point | undefined;\n\n  /**\n   * global snapping point (not on self shape)\n   * @getter\n   */\n  get globalSnappingPoint() {\n    return this.container instanceof Layer ? this.container.snappingPoint : (this.app.stage as Layer).snappingPoint;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get area() {\n    return NaN;\n  }\n\n  // TODO: make pivot as abstract getter & setter\n  // eslint-disable-next-line class-methods-use-this\n  get pivot() {\n    return new Point(0, 0);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  set pivot(p: Point) {}\n\n  /**\n   * get position\n   * @getter\n   */\n  abstract get position(): Point;\n\n  /**\n   * set position\n   * @setter\n   */\n  abstract set position(point: Point);\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  abstract get shapeBounds(): { left: number, top: number, right: number, bottom: number };\n\n  /**\n   * get color\n   * @getter\n   */\n  get color() {\n    return this._color;\n  }\n\n  /**\n   * set color\n   * @setter\n   */\n  set color(color: number) {\n    const shouldUpdate = this._color !== color;\n    this._color = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get fill color\n   * @getter\n   */\n  get fillColor() {\n    return this._fillColor;\n  }\n\n  /**\n   * set fill colo\n   * @setter\n   */\n  set fillColor(color: number) {\n    const shouldUpdate = this._fillColor !== color;\n    this._fillColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border color\n   * @getter\n   */\n  get borderColor() {\n    return this._borderColor;\n  }\n\n  /**\n   * set border color\n   * @setter\n   */\n  set borderColor(color: number) {\n    const shouldUpdate = this._borderColor !== color;\n    this._borderColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border type\n   * @getter\n   */\n  get borderType() {\n    return this._borderType;\n  }\n\n  /**\n   * set border type\n   * @setter\n   */\n  set borderType(type: ShapeLineType) {\n    const shouldUpdate = this._borderType !== type;\n    this._borderType = type;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border bold\n   * @getter\n   */\n  get borderBold() {\n    return this._borderBold;\n  }\n\n  /**\n   * set border bold\n   * @setter\n   */\n  set borderBold(bold: boolean) {\n    const shouldUpdate = this._borderBold !== bold;\n    this._borderBold = bold;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex color\n   * @getter\n   */\n  get vertexColor() {\n    return this._vertexColor;\n  }\n\n  /**\n   * set vertex color\n   * @setter\n   */\n  set vertexColor(color: number) {\n    const shouldUpdate = this._vertexColor !== color;\n    this._vertexColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex color\n   * @getter\n   */\n  get vertexType() {\n    return this._vertexType;\n  }\n\n  /**\n   * set vertex color\n   * @setter\n   */\n  set vertexType(type: ShapeVertexType) {\n    const shouldUpdate = this._vertexType !== type;\n    this._vertexType = type;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get display border color\n   * @getter\n   */\n  get displayBorderColor() {\n    if (this.selected) {\n      return this.selectedColor;\n    }\n    if (this.hovered) {\n      return this.hoveredColor;\n    }\n    return this.borderColor;\n  }\n\n  /**\n   * get display vertex color\n   * @getter\n   */\n  get displayVertexColor() {\n    if (this.selected && this.vertexColor === this.color) {\n      return 0x222222;\n    }\n    return this.vertexColor;\n  }\n\n  /**\n   * get alpha\n   * @getter\n   */\n  get alpha() {\n    return this._alpha;\n  }\n\n  /**\n   * set alpha\n   * @setter\n   */\n  set alpha(alpha: number) {\n    const newAlpha = alpha > 0 ? alpha : 0.005; // for transparent shape, interactions can't be fired\n    const shouldUpdate = this._alpha !== newAlpha;\n    this._alpha = newAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get label\n   * @getter\n   */\n  get label() {\n    return this._label;\n  }\n\n  /**\n   * set label\n   * @setter\n   */\n  set label(label: string) {\n    this._label = label;\n    this.drawShapeLabel();\n  }\n\n  /**\n   * get border width\n   * @getter\n   */\n  get borderWidth() {\n    return this._borderWidth;\n  }\n\n  /**\n   * set border width\n   * @setter\n   */\n  set borderWidth(borderWidth: number) {\n    const shouldUpdate = this._borderWidth !== borderWidth;\n    this._borderWidth = borderWidth;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border alpha\n   * @getter\n   */\n  get borderAlpha() {\n    return this._borderAlpha;\n  }\n\n  /**\n   * set border alpha\n   * @setter\n   */\n  set borderAlpha(borderAlpha: number) {\n    const shouldUpdate = this._borderAlpha !== borderAlpha;\n    this._borderAlpha = borderAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border style\n   * @getter\n   */\n  get borderStyle() {\n    return this._borderStyle;\n  }\n\n  /**\n   * set border style\n   * @setter\n   */\n  set borderStyle(borderStyle: BorderStyle) {\n    const shouldUpdate = this._borderStyle !== borderStyle;\n    this._borderStyle = borderStyle;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex\n   * @getter\n   */\n  get showVertex() {\n    return this._showVertex;\n  }\n\n  /**\n   * set show vertex\n   * @setter\n   */\n  set showVertex(showVertex: boolean) {\n    const shouldUpdate = this._showVertex !== showVertex;\n    this._showVertex = showVertex;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex order\n   * @getter\n   */\n  get showVertexOrder() {\n    return this._showVertexOrder;\n  }\n\n  /**\n   * set show vertex order\n   * @setter\n   */\n  set showVertexOrder(showVertexOrder: boolean) {\n    const shouldUpdate = this._showVertexOrder !== showVertexOrder;\n    this._showVertexOrder = showVertexOrder;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex size\n   * @getter\n   */\n  get vertexSize() {\n    return this._vertexSize;\n  }\n\n  /**\n   * set vertex size\n   * @setter\n   */\n  set vertexSize(vertexSize: number) {\n    const shouldUpdate = this._vertexSize !== vertexSize;\n    this._vertexSize = vertexSize;\n    if (shouldUpdate && this.showVertex) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get vertex start\n   * @getter\n   */\n  get vertexStart() {\n    return this._vertexStart;\n  }\n\n  /**\n   * set vertex start\n   * @setter\n   */\n  set vertexStart(vertexStart: number) {\n    const shouldUpdate = this._vertexStart !== vertexStart;\n    this._vertexStart = vertexStart;\n    if (shouldUpdate && this.showVertexOrder) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get order\n   * @getter\n   */\n  get order() {\n    return this._order;\n  }\n\n  /**\n   * set order\n   * @setter\n   */\n  set order(order: number) {\n    this._order = order;\n    this._updateShapeContainerOrder();\n    if (this.labelDom) {\n      this.labelDom.zIndex = order;\n    }\n  }\n\n  /**\n   * get visible\n   * @getter\n   */\n  get visible() {\n    return this._visible;\n  }\n\n  /**\n   * set visible\n   * @setter\n   */\n  set visible(visible: boolean) {\n    const shouldUpdate = this._visible !== visible;\n    this._visible = visible;\n    if (shouldUpdate) {\n      this.instance.visible = visible;\n      this.instance.interactive = visible ? this.interactive : false;\n      this.labelContainer.visible = visible;\n      this.vertexesContainer.visible = visible;\n      this.userDataContainer.visible = visible;\n      this.controlsContainer.visible = visible;\n      if (this.labelDom) {\n        this.labelDom.visible = visible;\n      }\n    }\n  }\n\n  /**\n   * get interactive\n   * @getter\n   */\n  get interactive() {\n    return this._interactive;\n  }\n\n  /**\n   * set interactive\n   * @setter\n   */\n  set interactive(interactive: boolean) {\n    this._interactive = interactive;\n    if (this.instance) {\n      this.instance.interactive = interactive;\n    }\n    this._controls.forEach((c) => {\n      c.control.interactive = interactive;\n    });\n    if (!interactive) {\n      this.selected = false;\n      this.hovered = false;\n    }\n  }\n\n  /**\n   * get editable\n   * @getter\n   */\n  get editable() {\n    return this._editable;\n  }\n\n  /**\n   * set editable\n   * @setter\n   */\n  set editable(editable: boolean) {\n    this._editable = editable;\n    this.drawShape();\n  }\n\n  /**\n   * get draggable\n   * @getter\n   */\n  get draggable() {\n    return this._draggable;\n  }\n\n  /**\n   * set draggable\n   * @setter\n   */\n  set draggable(draggable: boolean) {\n    this._draggable = this._defaultDraggable && draggable;\n  }\n\n  /**\n   * get rotatable\n   * @getter\n   */\n  get rotatable() {\n    return this._rotatable;\n  }\n\n  /**\n   * set rotatable\n   * @setter\n   */\n  set rotatable(rotatable: boolean) {\n    this._rotatable = rotatable;\n  }\n\n  /**\n   * get shape finished\n   * @getter\n   */\n  get finished() {\n    return this._finished;\n  }\n\n  /**\n   * get selected\n   * @getter\n   */\n  get selected() {\n    return this._selected;\n  }\n\n  /**\n   * set selected\n   * @setter\n   */\n  set selected(selected: boolean) {\n    const shouldUpdate = this._selected !== selected;\n    this._selected = selected;\n    this._updateShapeContainerOrder();\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get hovered\n   * @getter\n   */\n  get hovered() {\n    return this._hovered;\n  }\n\n  /**\n   * set hovered\n   * @setter\n   */\n  set hovered(hovered: boolean) {\n    const shouldUpdate = this._hovered !== hovered;\n    this._hovered = hovered;\n    if (shouldUpdate) {\n      this.userDataContainer.visible = (hovered && this.userDataMode === UserDataMode.HOVER) || this.userDataMode === UserDataMode.ALWAYS;\n      this.drawShape();\n      this._emit(hovered ? EventAction.POINTER_OVER : EventAction.POINTER_OUT);\n    }\n    // should update stage cursor because instance cursor not show when covered by others\n    if (hovered) {\n      this.instance.cursor = this.editable && this.draggable ? Cursor.MOVE : Cursor.POINTER;\n    } else {\n      this.instance.cursor = Cursor.DEFAULT;\n    }\n  }\n\n  /**\n   * get scale\n   * @getter\n   */\n  get scale() {\n    return this._scale;\n  }\n\n  /**\n   * set scale\n   * @setter\n   */\n  set scale(scale: number) {\n    const shouldUpdate = this._scale !== scale;\n    this._scale = scale;\n    this._controls.forEach((c) => {\n      // eslint-disable-next-line no-param-reassign\n      c.scale = scale;\n    });\n    if (this._rotateControl) {\n      this._rotateControl.scale = scale;\n    }\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get rotation\n   * @getter\n   */\n  get rotation() {\n    return this._rotation;\n  }\n\n  /**\n   * set rotation\n   * @setter\n   */\n  set rotation(rotation: number) {\n    this._rotation = rotation;\n    this._updatePosition();\n    this.drawShape();\n  }\n\n  /**\n   * get user data mode\n   * @getter\n   */\n  get userDataMode() {\n    return this._userDataMode;\n  }\n\n  /**\n   * set user data mode\n   * @setter\n   */\n  set userDataMode(mode) {\n    this._userDataMode = mode;\n    this.userDataContainer.visible = this._userDataMode === UserDataMode.ALWAYS;\n  }\n\n  /**\n   * user data formatter\n   */\n  userDataFormatter?: (userData: any) => string;\n\n  constructor({\n    app,\n    container,\n    scale,\n    color,\n    fillColor,\n    borderColor,\n    borderType,\n    borderBold,\n    vertexColor,\n    vertexType,\n    selectedColor,\n    alpha,\n    label,\n    borderWidth,\n    borderAlpha,\n    borderStyle,\n    showVertex,\n    showVertexOrder,\n    vertexSize,\n    vertexStart,\n    bounds,\n    draggable = true,\n    rotatable = false,\n    labelDom,\n    userDataFormatter,\n  }: ShapeOptions) {\n    this.instance.on('pointerdown', this.processPointerDown);\n    this.instance.on('pointerup', this.processPointerUp);\n    this.instance.on('pointerupoutside', this.processPointerUp);\n    this.instance.on('pointermove', this.processPointerMove);\n\n    this.app = app;\n    this.app.view.addEventListener('mousedown', this.processGlobalMouseDown, false);\n\n    this.container = container || app.stage;\n    this.instance.interactive = this.interactive;\n    this.labelContainer.interactive = false;\n    this.vertexesContainer.interactive = false;\n    this.userDataContainer.interactive = false;\n    this.controlsContainer.zIndex = 9999;\n    this.shapeContainer.addChild(this.instance);\n    this.shapeContainer.addChild(this.labelContainer);\n    this.shapeContainer.addChild(this.vertexesContainer);\n    this.shapeContainer.addChild(this.userDataContainer);\n    this.container.addChild(this.shapeContainer);\n    this.container.addChild(this.controlsContainer);\n\n    this._scale = scale || app.stage.scale.x;\n    this.userDataMode = UserDataMode.HIDE;\n    if (color !== undefined) {\n      this._color = color;\n      this._fillColor = color;\n      this._borderColor = color;\n      this._vertexColor = color;\n    }\n    if (fillColor !== undefined) {\n      this._fillColor = fillColor; // reset fill color\n    }\n    if (borderColor !== undefined) {\n      this._borderColor = borderColor;\n    }\n    if (borderType !== undefined) {\n      this._borderType = borderType;\n    }\n    if (borderBold !== undefined) {\n      this._borderBold = borderBold;\n    }\n    if (vertexColor !== undefined) {\n      this._vertexColor = vertexColor;\n    }\n    if (vertexType !== undefined) {\n      this._vertexType = vertexType;\n    }\n    this.originColors = {\n      color: this._color,\n      fillColor: this._fillColor,\n      borderColor: this._borderColor,\n      vertexColor: this._vertexColor,\n    };\n    if (selectedColor !== undefined) {\n      this.selectedColor = selectedColor;\n    }\n    if (alpha !== undefined) {\n      this._alpha = alpha > 0 ? alpha : 0.005;\n    }\n    if (label !== undefined) {\n      this._label = label;\n    }\n    if (borderWidth !== undefined) {\n      this._borderWidth = borderWidth;\n    }\n    if (borderAlpha !== undefined) {\n      this._borderAlpha = borderAlpha;\n    }\n    if (borderStyle !== undefined) {\n      this._borderStyle = borderStyle;\n    }\n    if (showVertex !== undefined) {\n      this._showVertex = showVertex;\n    }\n    if (showVertexOrder !== undefined) {\n      this._showVertexOrder = showVertexOrder;\n    }\n    if (vertexSize !== undefined) {\n      this._vertexSize = vertexSize;\n    }\n    if (vertexStart !== undefined) {\n      this._vertexStart = vertexStart;\n    }\n    if (bounds !== undefined) {\n      this.bounds = bounds;\n    }\n    this._defaultDraggable = draggable;\n    this._draggable = draggable;\n    this._rotatable = rotatable;\n    this.labelDom = labelDom;\n\n    if (userDataFormatter) {\n      this.userDataFormatter = userDataFormatter;\n    }\n  }\n\n  /**\n   * update container position\n   * @protected\n   */\n  protected _updatePosition(resize = false) {\n    const pivot = this.pivot.clone();\n    if (resize && this._lastPivot) {\n      // resize change pivot\n      const rotatedPivot = computeRotatedPosition(this._lastPivot, pivot, this.rotation);\n      pivot.x = rotatedPivot.x;\n      pivot.y = rotatedPivot.y;\n      this.pivot = pivot;\n    }\n    this.shapeContainer.pivot.set(pivot.x, pivot.y);\n    this.shapeContainer.position.set(pivot.x, pivot.y);\n    this.shapeContainer.rotation = this.rotation;\n    this._lastPivot = pivot.clone();\n\n    this.controlsContainer.pivot.set(pivot.x, pivot.y);\n    this.controlsContainer.position.set(pivot.x, pivot.y);\n    this.controlsContainer.rotation = this.rotation;\n  };\n\n  /**\n   * propogating event to back shapes\n   * @param event\n   * @param frontTargets\n   * @param funcName\n   */\n  private _continuePropogating(\n    event: InteractionEvent,\n    frontTargets: Graphics[],\n    funcName: 'processPointerDown' | 'processPointerUp',\n  ) {\n    this.instance.interactive = false;\n    const { interaction } = this.app.renderer.plugins;\n    const hit = interaction.hitTest(event.data.global);\n    if (hit && hit instanceof ShapeGraphics && !frontTargets.includes(this.instance)) {\n      hit.shape[funcName](event, [...frontTargets, this.instance]);\n    }\n    this.instance.interactive = true;\n  }\n\n  /**\n   * process pointerdown\n   * @param event\n   * @param frontTargets\n   */\n  processPointerDown = (event: InteractionEvent, frontTargets: Graphics[] = []) => {\n    if (event.data.button === 2) {\n      return;\n    }\n\n    if (this.hovered) {\n      event.stopPropagation();\n      const p = event.data.getLocalPosition(this.container);\n      if (this.draggable) {\n        this._dragPoint = new Point(p.x, p.y);\n        this._dragPosistion = this.position;\n        this._dragged = false;\n      }\n      this.selected = true;\n      this._emit(EventAction.SELECTED, p);\n      // disable controls interactivity when first pointer down to selected (avoid bugs when start dragging on controls)\n      this._controls.forEach((c) => {\n        c.control.interactive = false;\n      });\n    }\n\n    if (!this._snappingPoint) { // if upper shapes has snapping point, do not propogating\n      this._continuePropogating(event, frontTargets, 'processPointerDown');\n    }\n  };\n\n  /**\n   * process pointerup\n   * @param event\n   * @param frontTargets\n   */\n  processPointerUp = (event: InteractionEvent, frontTargets: Graphics[] = []) => {\n    // re-active controls when pointer up\n    this._controls.forEach((c) => {\n      c.control.interactive = true;\n    });\n    this.dragging = false;\n    this._dragPoint = null;\n    this._dragPosistion = null;\n    if (this._dragged) {\n      this._changed();\n      this._dragged = false;\n    }\n    this._continuePropogating(event, frontTargets, 'processPointerUp');\n  };\n\n  /**\n   * process pointermove\n   * @param event\n   */\n  processPointerMove = (event: InteractionEvent) => {\n    if (this.editable && this.selected && this.snap(event)) {\n      // snapping\n      this.instance.cursor = Cursor.DEFAULT;\n    } else if (this.editable && this.selected && this._dragPoint && this._dragPosistion) {\n      // dragging\n      this._dragged = true;\n      this._ctrlKey = event.data.originalEvent.ctrlKey;\n      const point = event.data.getLocalPosition(this.container);\n      const originX = this.position.x;\n      const originY = this.position.y;\n      const position = new Point(\n        this._dragPosistion.x + (point.x - this._dragPoint.x),\n        this._dragPosistion.y + (point.y - this._dragPoint.y),\n      );\n      // prefer to use global snapping point if moving a dot\n      this.position = (this.shapeType === ShapeType.DOT && this.globalSnappingPoint) ? this.globalSnappingPoint : position;\n      this._keepInstanceInBounds();\n      this._updatePosition();\n      this._dragging({ deltaX: this.position.x - originX, deltaY: this.position.y - originY });\n    }\n  };\n\n  /**\n   * process app mouse down\n   */\n  processGlobalMouseDown = () => {\n    if (this._snappingPoint) {\n      const success = this.addSnappingPointToShape();\n      if (success) {\n        // set selected\n        this.selected = true;\n        this._emit(EventAction.SELECTED);\n        // ignore drag start\n        this._dragPoint = null;\n        this._dragPosistion = null;\n      }\n    }\n  };\n\n  /**\n   * actual draw the shape on canvas\n   */\n  abstract drawShape(): void;\n\n  /**\n   * start shape create\n   * @param point create start point\n   * @param options options used for creation\n   */\n  abstract create(point?: Point, options?: any): void;\n\n  /**\n   * get label position of the shape\n   */\n  abstract getLabelPosition(): Point;\n\n  /**\n   * get shape data\n   */\n  abstract getData(): T;\n\n  /**\n   * get shape Geo JSON (multi polygon)\n   */\n  abstract getAreaAsGeoJSON(): Geom;\n\n  /**\n   * delete selected points in shape, default reture false and can be overwritten in sub class\n   */\n  deleteSelectedPoints() {\n    return false; // false means no point deleted\n  }\n\n  /**\n   * snap to shape vertexes or edges\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point: Point, tolerance?: number): Point | null {\n    return null;\n  }\n\n  /**\n   * snap to shape edges\n   * @param point\n   */\n  snap(event: InteractionEvent) {\n    this._snappingPoint = null;\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    return false;\n  }\n\n  /**\n   * draw shape label\n   */\n  drawShapeLabel() {\n    this.labelContainer.removeChildren();\n\n    const borderOffset = this.shapeType !== ShapeType.DOT ? this.borderWidth / 2 : 0;\n    const vertexOffset = (\n      this.shapeType === ShapeType.POLYGON ||\n      this.shapeType === ShapeType.LINE ||\n      this.shapeType === ShapeType.ARROW ||\n      this.shapeType === ShapeType.RECTANGLE\n    ) && this.showVertex ? this.vertexSize : 0;\n    if (this.labelDom) {\n      // use dom to render\n      if (this.label) {\n        this.labelDom.text = this.label;\n        this.labelDom.zIndex = this.order;\n\n        const position = this.getLabelPosition();\n        const globalPosition = this.container.toGlobal({ x: position.x, y: position.y - (borderOffset + vertexOffset) / this.scale });\n        const globalPivot = this.container.toGlobal(this.pivot);\n        this.labelDom.setPosition(globalPosition, globalPivot, this.rotation);\n      }\n      return;\n    }\n\n    if (this.label) {\n      const { x, y } = this.getLabelPosition();\n      this.labelContainer.position.x = x;\n      this.labelContainer.position.y = y - (18 + borderOffset + vertexOffset) / this.scale;\n      this.labelContainer.scale.set(1 / this.scale);\n\n      const text = new Text(` ${this.label} `, {\n        fontSize: 14,\n        lineHeight: 18,\n        fill: '#FFFFFF',\n      });\n\n      const { width, height } = text.getBounds();\n      const bounds = new Graphics();\n      bounds.beginFill(0, 0.6);\n      bounds.drawRect(0, 0, width, height);\n      bounds.endFill();\n      this.labelContainer.addChild(bounds);\n      this.labelContainer.addChild(text);\n    }\n  }\n\n  /**\n   * finish shape create\n   * @protected\n   */\n  protected _finish() {\n    if (!this.destroyed) {\n      this._finished = true;\n      this.drawShape();\n      this._emit(EventAction.FINISHED);\n    }\n  }\n\n  /**\n   * remove shape from canvas\n   * @protected\n   */\n  protected _remove() {\n    this._emit(EventAction.REMOVED);\n    this.destroy();\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  protected _changed() {\n    this._emit(EventAction.CHANGED, this.getData());\n  }\n\n  /**\n   * when shape is been dragging\n   * @param data\n   * @protected\n   */\n  protected _dragging(data?: { deltaX: number; deltaY: number }) {\n    this.dragging = true;\n    this._emit(EventAction.DRAGGING, { ...data });\n  }\n\n  /**\n   * when shape is reszing\n   * @param data\n   * @protected\n   */\n  protected _resizing(data?: { deltaX: number; deltaY: number }) {\n    this.resizing = true;\n    this._emit(EventAction.RESIZING, { ...data });\n  }\n\n  /**\n   * get global position\n   * @returns\n   */\n  getGlobalPosition() {\n    const { left, right, top, bottom } = this.shapeBounds;\n    const center = new Point(left + (right - left) / 2, top + (bottom - top) / 2);\n    const { x, y } = this.container.toGlobal(center);\n    return { x, y };\n  }\n\n  /**\n   * find intersections\n   * @param shapes\n   */\n  findIntersections(shapes: Shape<ShapeData>[]) {\n    const currentShapeData = this.getAreaAsGeoJSON();\n    const filteredShapes = shapes.filter((s) => s.uid !== this.uid);\n    return findIntersections(currentShapeData, this.shapeBounds, this.shapeType, filteredShapes);\n  }\n\n  /**\n   * update shape position\n   * @param x\n   * @param y\n   */\n  updatePosition(x: number, y: number) {\n    this.position = new Point(x, y);\n    this._keepInstanceInBounds();\n    this._updatePosition();\n  }\n\n  /**\n   * destroy shape\n   */\n  destroy() {\n    if (this.destroyed) {\n      return;\n    }\n    this.app.view.removeEventListener('mousedown', this.processGlobalMouseDown, false);\n    // remove all listeners\n    Object.values(EventAction).forEach((action) => {\n      this.off(action);\n    });\n    // remove control points\n    this._controls.forEach((c) => {\n      c.destroy();\n    });\n    this._controls = [];\n    this.container.removeChild(this.controlsContainer);\n    this.controlsContainer.destroy({\n      children: true,\n      texture: true,\n      baseTexture: true,\n    });\n    // remove rotation control\n    if (this._rotateControl) {\n      this._rotateControl.destroy();\n    }\n    // destroy shapeContainer\n    this.container.removeChild(this.shapeContainer);\n    this.shapeContainer.destroy({\n      children: true,\n      texture: true,\n      baseTexture: true,\n    });\n    // remove dom if possible\n    if (this.labelDom) {\n      this.labelDom.remove();\n      this.labelDom = undefined;\n    }\n    // remove data\n    if (this.data) {\n      this.data = undefined;\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * remove controls\n   */\n  removeControls() {\n    // remove control points\n    this._controls.forEach((c) => {\n      c.remove();\n    });\n    this._controls = [];\n  }\n\n  /**\n   * emit event\n   * @protected\n   * @param eventName\n   */\n  protected _emit(eventName: string, ...args: any[]) {\n    this._eventEmitter.emit(eventName, this, ...args);\n  }\n\n  /**\n   * add listener\n   * @param eventName\n   * @param callback\n   */\n  on(eventName: string, callback: (shape: Shape<T>, ...args: any[]) => void) {\n    this._eventEmitter.on(eventName, callback);\n    return this;\n  }\n\n  /**\n   * remove listener\n   * @param eventName\n   * @param callback\n   */\n  off(eventName: string, callback?: (shape: Shape<T>, ...args: any[]) => void) {\n    if (callback) {\n      this._eventEmitter.removeListener(eventName, callback);\n    } else {\n      this._eventEmitter.removeAllListeners(eventName);\n    }\n    return this;\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @protected\n   * @param x screen position x\n   * @param y screen position y\n   */\n  protected _mapScreenToStagePosition(x: number, y: number) {\n    const point = new Point();\n    this.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @protected\n   * @param point\n   */\n  protected _mapStageToLocalPosition(point: Point) {\n    return this.container.toLocal(point);\n  }\n\n  /**\n   * keep point inside boundary\n   * @param point\n   */\n  protected _keepPointInBounds(point: Point) {\n    if (!this.bounds) {\n      return point;\n    }\n    let { x, y } = point;\n    const { top, right, bottom, left } = this.bounds;\n    if (x < left) {\n      x = left;\n    } else if (x > right) {\n      x = right;\n    }\n    if (y < top) {\n      y = top;\n    } else if (y > bottom) {\n      y = bottom;\n    }\n    return new Point(x, y);\n  }\n\n  /**\n   * keep instance inside boundary\n   */\n  protected _keepInstanceInBounds() {\n    if (!this.bounds) {\n      return;\n    }\n    const { left, top, right, bottom } = this.shapeBounds;\n    const { left: bLeft, top: bTop, right: bRight, bottom: bBottom } = this.bounds;\n    const position = {\n      x: this.position.x,\n      y: this.position.y,\n    };\n    if (left < bLeft) {\n      position.x += -left;\n    } else if (right > bRight) {\n      position.x -= (right - bRight);\n    }\n    if (top < bTop) {\n      position.y += -top;\n    } else if (bottom > bBottom) {\n      position.y -= (bottom - bBottom);\n    }\n    if (this.position.x !== position.x || this.position.y !== position.y) {\n      this.position = new Point(position.x, position.y);\n    }\n  }\n\n  /**\n   * update shape container order\n   */\n  private _updateShapeContainerOrder() {\n    this.shapeContainer.zIndex = this.selected ? 9999 : this.order;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}