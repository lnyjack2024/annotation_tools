{"ast":null,"code":"import _initializerDefineProperty from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\nvar _dec,\n  _class,\n  _class2,\n  _descriptor,\n  _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/components/Canvas.tsx\";\n/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable, computed } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport { debounce } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { Spin, Button } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool from '../tools/Tool';\nimport { AttributesMode } from '../store/SettingsStore';\nimport rootStore from '../store/RootStore';\nimport formatMessage from '../locales';\nimport { CategoryPathShape, LandmarkEditType, LabelStyle } from '../types';\nimport Cursor from '../../common/Cursor';\nimport { resetAttrLabelPosition, getValuesLabel, resizeLabel } from '../utils';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport './Canvas.scss';\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 12;\nexport const POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  KEYPOINT: 'keypoint',\n  PATH: 'path',\n  KEYPOINT_BOX: 'keypoint_box',\n  INSTANCE: 'instance',\n  GROUP: 'group',\n  RECTANGLE_POINT: 'rectangle_point',\n  RECTANGLE_PATH: 'rectangle_path',\n  RECTANGLE_GROUP: 'rectangle_group',\n  RECTANGLE: 'rectangle',\n  WARNGIN: 'warning'\n};\nvar LabelType = /*#__PURE__*/function (LabelType) {\n  LabelType[\"KEYPOINT\"] = \"keypoint\";\n  LabelType[\"OBJECT\"] = \"object\";\n  return LabelType;\n}(LabelType || {});\nlet Canvas = (_dec = action.bound, observer(_class = (_class2 = class Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    _initializerDefineProperty(this, \"cursor\", _descriptor, this);\n    this.canvas = React.createRef();\n    this.canvasContainer = React.createRef();\n    this.imageCanvas = void 0;\n    this.imageData = void 0;\n    this.raster = void 0;\n    this.rasterLayer = void 0;\n    this.gridLayer = void 0;\n    this.labelLayer = void 0;\n    this.attrLayer = void 0;\n    this.mainLayer = void 0;\n    this.warningLayer = void 0;\n    this.tool = void 0;\n    this.hits = void 0;\n    this.selectedHit = void 0;\n    this.warningBtn = void 0;\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    this.smoothPath = null;\n    this.shownLabel = null;\n    this.fillOpacity = 0.3;\n    this.resizeObserve = null;\n    this.catchZoom = void 0;\n    this.prevRaster = null;\n    this.updateGroupBoxdebounced = void 0;\n    this.resizeDebounced = void 0;\n    this.paperZoom = 1;\n    this.currentWarnings = [];\n    this.resize = (isWindow = false) => {\n      if (this.canvasContainer.current) {\n        // set view size\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n        const viewCenter = new Paper.Point({\n          x: viewWidth / 2,\n          y: viewHeight / 2\n        });\n        if (this.catchZoom) {\n          const {\n            center,\n            zoom\n          } = this.catchZoom;\n          if (isWindow) {\n            Paper.view.center = viewCenter;\n            this.catchZoom.center = viewCenter;\n          } else {\n            Paper.view.center = center;\n          }\n          Paper.view.zoom = zoom;\n        } else {\n          Paper.view.center = viewCenter;\n          Paper.view.zoom = 1;\n        }\n        if (this.imageCanvas && this.raster) {\n          // resize image\n          const {\n            width: imgWidth,\n            height: imgHeight\n          } = this.imageCanvas;\n          const viewRatio = viewWidth / viewHeight;\n          const imgRatio = imgWidth / imgHeight;\n          const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n          const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n          const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n          const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n          // apply matrix to all layers\n          Paper.project.layers.forEach(layer => {\n            layer.matrix = matrix;\n          });\n          // reset image center\n          this.raster.position = new Paper.Point({\n            x: imgWidth / 2,\n            y: imgHeight / 2\n          });\n          this.paperZoom = this.rasterLayer ? Paper.view.zoom * this.rasterLayer.matrix.scaling.x : Paper.view.zoom;\n        }\n        this.resizeContent();\n      }\n    };\n    this.resizeContent = () => {\n      if (this.resizeDebounced) {\n        this.resizeDebounced();\n      } else {\n        this.resizeDebounced = debounce(() => {\n          this.resizeGrid();\n          this.resizeShapes();\n          this.drawWarnings();\n        }, 50);\n      }\n    };\n    this.zoom = (event, zoom) => {\n      if (this.canvasContainer.current) {\n        const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n        const viewPosition = Paper.view.viewToProject(mousePosition);\n        const oldZoom = Paper.view.zoom;\n        const oldCenter = Paper.view.center;\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        let newZoom = event && event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n        newZoom = zoom || newZoom;\n        if (newZoom <= 1) {\n          Paper.view.center = new Paper.Point({\n            x: viewWidth / 2,\n            y: viewHeight / 2\n          });\n        }\n        newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n        if (newZoom !== Paper.view.zoom) {\n          Paper.view.zoom = newZoom;\n          const zoomScale = oldZoom / newZoom;\n          const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n          Paper.view.center = Paper.view.center.add(offset);\n        }\n        this.catchZoom = {\n          zoom: newZoom,\n          center: Paper.view.center\n        };\n        this.paperZoom = newZoom * this.rasterLayer.matrix.scaling.x;\n        this.resizeContent();\n      }\n    };\n    this.drag = center => {\n      this.catchZoom = this.catchZoom ? {\n        ...this.catchZoom,\n        center\n      } : {\n        zoom: Paper.view.zoom,\n        center\n      };\n    };\n    this.fitSelected = (instanceId, groupName) => {\n      const groupBox = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (groupBox && this.mainLayer && this.canvasContainer.current) {\n        const {\n          center,\n          width,\n          height\n        } = groupBox.bounds;\n        if (width === 0 || height === 0) return;\n        const point = this.mainLayer.localToGlobal(center);\n        const {\n          width: viewWidth,\n          height: viewHeight\n        } = this.mainLayer.bounds;\n        let zoom = width / height > viewWidth / viewHeight ? viewWidth / width : viewHeight / height;\n        zoom = Math.min(18, Math.max(zoom, 1));\n        Paper.view.zoom = zoom;\n        Paper.view.center = point;\n        this.catchZoom = {\n          zoom,\n          center: point\n        };\n        this.paperZoom = this.rasterLayer ? zoom * this.rasterLayer.matrix.scaling.x : zoom;\n        this.resizeContent();\n      } else {\n        this.resize();\n      }\n    };\n    this.debounceUpdateGroupBox = (instanceId, category, groupName) => {\n      if (this.updateGroupBoxdebounced && this.updateGroupBoxdebounced.instanceId === instanceId && this.updateGroupBoxdebounced.category === category && this.updateGroupBoxdebounced.groupName === groupName) {\n        this.updateGroupBoxdebounced.fun();\n      } else {\n        if (this.updateGroupBoxdebounced) {\n          this.updateGroupBoxdebounced.fun.cancel();\n        }\n        this.updateGroupBoxdebounced = {\n          instanceId,\n          category,\n          groupName,\n          fun: debounce(() => {\n            this.updateGroupBox(instanceId, category, groupName);\n          }, 200)\n        };\n      }\n    };\n    this.clearHits = () => {\n      this.hits = undefined;\n    };\n    this.updateGroupBox = (instanceId, category, groupName) => {\n      let boundRect = this.getShapeByGroup();\n      const {\n        selectedShapeStatus\n      } = this.props;\n      let isRemovebound = false;\n      if (instanceId) {\n        if (instanceId !== selectedShapeStatus.instanceId || groupName !== selectedShapeStatus.groupName) return;\n        const groupConntainer = this.getGroupContainerByGroupName(instanceId, groupName);\n        const points = groupConntainer && groupConntainer.children.filter(v => v.type === CategoryPathShape.CIRCLE).map(v => [v.position.x, v.position.y]);\n        if (points && points.length > 0) {\n          const xList = points.map(v => v[0]);\n          const yList = points.map(v => v[1]);\n          const minX = Math.min(...xList);\n          const maxX = Math.max(...xList);\n          const minY = Math.min(...yList);\n          const maxY = Math.max(...yList);\n          if (this.mainLayer) {\n            const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n            if (boundRect) {\n              boundRect.remove();\n            }\n            const range = rootStore.setting.pointSize * 3 / zoom;\n            const strokeWitdth = rootStore.setting.lineWidth / zoom;\n            boundRect = new Paper.Shape.Rectangle({\n              point: [minX - range, minY - range],\n              size: [maxX - minX + 2 * range, maxY - minY + 2 * range],\n              strokeColor: new Paper.Color('#FFE600'),\n              strokeWidth: strokeWitdth\n            });\n            boundRect.data.type = SHAPE_TYPE.KEYPOINT_BOX;\n            this.mainLayer.addChild(boundRect);\n            const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n            const instance = this.props.getInstance(instanceId);\n            const content = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''} ${(instance === null || instance === void 0 ? void 0 : instance.number) || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n            const labelGroup = this.getLabelByKey('', '', SHAPE_TYPE.KEYPOINT_BOX);\n            if (labelGroup) {\n              labelGroup.remove();\n            }\n            this.addLabel(content, {\n              x: minX - range,\n              y: minY - range - strokeWitdth * 2,\n              width: maxX - minX + 2 * range,\n              height: maxY - minY + 2 * range\n            }, {\n              instanceId: '',\n              category: '',\n              groupName: ''\n            }, SHAPE_TYPE.KEYPOINT_BOX, true, SHAPE_TYPE.KEYPOINT_BOX);\n          }\n        } else {\n          isRemovebound = true;\n        }\n      } else {\n        isRemovebound = true;\n      }\n      if (isRemovebound && boundRect) {\n        boundRect.remove();\n        this.removeLabel('', '', SHAPE_TYPE.KEYPOINT_BOX);\n      }\n    };\n    makeObservable(this);\n  }\n  get activeTool() {\n    var _this$props$ontologyG;\n    let tool = '';\n    switch ((_this$props$ontologyG = this.props.ontologyGroup) === null || _this$props$ontologyG === void 0 ? void 0 : _this$props$ontologyG.type) {\n      case LandmarkEditType.KEYPOINT:\n        tool = CategoryPathShape.CIRCLE;\n        break;\n      case LandmarkEditType.RECTANGLE:\n        tool = CategoryPathShape.RECTANGLE;\n        break;\n      default:\n        break;\n    }\n    return tool;\n  }\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', e => e.preventDefault(), false);\n    }\n    if (this.canvasContainer.current) {\n      this.resizeObserve = new ResizeObserver(() => {\n        this.resize(true);\n      });\n      this.resizeObserve.observe(this.canvasContainer.current);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.image !== this.props.image) {\n      this.loadImage();\n    }\n\n    // default instances\n    if (JSON.stringify(prevProps.defaultInstances) !== JSON.stringify(this.props.defaultInstances)) {\n      const defaultInstances = Object.values(this.props.defaultInstances).filter(instance => instance && !prevProps.defaultInstances[instance.id]);\n      if (defaultInstances.length > 0) {\n        defaultInstances.forEach(instance => {\n          var _this$mainLayer;\n          const instanceContainer = new Paper.Group();\n          (_this$mainLayer = this.mainLayer) === null || _this$mainLayer === void 0 ? void 0 : _this$mainLayer.addChild(instanceContainer);\n          instanceContainer.data = {\n            instanceId: instance.id,\n            category: instance.category,\n            type: SHAPE_TYPE.INSTANCE\n          };\n          instance.children.forEach(group => {\n            const groupContainer = new Paper.Group();\n            groupContainer.data = {\n              groupName: group.name,\n              type: SHAPE_TYPE.GROUP,\n              instanceId: instance.id,\n              category: instance.category,\n              displayColor: instance.displayColor || POINT_COLOR\n            };\n            instanceContainer.addChild(groupContainer);\n          });\n        });\n      }\n    }\n\n    // change frame & undo & redo to update points\n    if (JSON.stringify(prevProps.updatedShapes) !== JSON.stringify(this.props.updatedShapes) && this.props.updatedShapes.length > 0) {\n      this.updateShapes();\n    }\n    if (JSON.stringify(prevProps.updatedCategories) !== JSON.stringify(this.props.updatedCategories) && this.props.updatedCategories.length > 0) {\n      this.props.updatedCategories.forEach(({\n        pointCategory,\n        frameIndex,\n        instanceId,\n        groupName,\n        category\n      }) => {\n        if (frameIndex === this.props.currentFrame) {\n          const container = {\n            instanceId,\n            groupName,\n            category\n          };\n          const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n        }\n      });\n      this.props.onCategoriesUpdated();\n    }\n\n    // selected changes\n    if (JSON.stringify(prevProps.selectedShapeStatus) !== JSON.stringify(this.props.selectedShapeStatus)) {\n      if (this.selectedPoints.length <= 0 || this.selectedRectangles.length <= 0) {\n        if (prevProps.selectedShapeStatus && prevProps.selectedShapeStatus.id !== undefined) {\n          const {\n            instanceId,\n            groupName,\n            id,\n            shapeType\n          } = prevProps.selectedShapeStatus;\n          if (!this.isShapeInSelectedShapes(instanceId, groupName, id)) {\n            if (shapeType === LandmarkEditType.KEYPOINT) {\n              this.setPointSelected(instanceId, groupName, id, false);\n            } else {\n              this.selectShape(instanceId, groupName, id, false);\n            }\n          }\n        }\n      }\n      const {\n        instanceId,\n        category,\n        groupName,\n        id,\n        shapeType\n      } = this.props.selectedShapeStatus;\n      if (id !== undefined) {\n        this.setMultiShapesUnselected();\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          this.setPointSelected(instanceId, groupName, id, true);\n        } else {\n          this.selectShape(instanceId, groupName, id);\n        }\n      }\n      if (prevProps.selectedShapeStatus.instanceId !== instanceId || prevProps.selectedShapeStatus.groupName !== groupName) {\n        this.updateGroupBox(instanceId, category, groupName);\n      }\n    }\n    if ((prevProps.selectedShapeInfo || {}).pointCategory !== (this.props.selectedShapeInfo || {}).pointCategory) {\n      this.clearSmooth();\n    }\n    if (JSON.stringify(prevProps.warnings) !== JSON.stringify(this.props.warnings) || prevProps.undoPointer !== this.props.undoPointer || this.props.updatedShapes.length > 0) {\n      this.currentWarnings = this.props.warnings.filter(warning => warning.frames[0] === this.props.currentFrame);\n      this.drawWarnings();\n    }\n  }\n  componentWillUnmount() {\n    if (this.resizeObserve) {\n      this.resizeObserve.disconnect();\n      this.resizeObserve = null;\n    }\n  }\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = true;\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = rootStore.setting.isGridVisible;\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n    this.attrLayer = new Paper.Layer();\n    this.attrLayer.applyMatrix = false;\n    this.attrLayer.visible = false;\n    this.warningLayer = new Paper.Layer();\n    this.warningLayer.applyMatrix = false;\n    this.warningLayer.visible = false;\n    Paper.view.onMouseMove = this.hitTest;\n  }\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n  loadImage() {\n    if (this.rasterLayer && this.props.image) {\n      this.rasterLayer.activate();\n      this.props.changeLoading(true);\n      if (this.raster) {\n        this.prevRaster = this.raster;\n      }\n      imageLoader(this.props.image, c => {\n        var _canvas$getContext;\n        const canvas = c;\n        this.imageCanvas = canvas;\n        this.imageData = (_canvas$getContext = canvas.getContext('2d')) === null || _canvas$getContext === void 0 ? void 0 : _canvas$getContext.getImageData(0, 0, canvas.width, canvas.height);\n        this.raster = new Paper.Raster(this.props.image);\n        this.raster.visible = false;\n        this.raster.onLoad = () => {\n          var _this$gridLayer, _this$gridLayer$child;\n          this.resize(); // resize to fit the container\n          if (!((_this$gridLayer = this.gridLayer) === null || _this$gridLayer === void 0 ? void 0 : (_this$gridLayer$child = _this$gridLayer.children) === null || _this$gridLayer$child === void 0 ? void 0 : _this$gridLayer$child.length)) {\n            this.addGrid(); // add grid to image\n            this.labelLayer.visible = rootStore.setting.labelMode;\n            this.mainLayer.visible = true;\n            this.warningLayer.visible = true;\n            this.attrLayer.visible = true;\n          }\n          // when onload, show all layers\n          this.raster.visible = true;\n          if (this.prevRaster) {\n            this.prevRaster.remove();\n          }\n          this.props.changeLoading(false);\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous'\n      });\n    }\n  }\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const {\n        brightness,\n        contrast,\n        saturation,\n        lightness,\n        hue,\n        rescale\n      } = rootStore.setting.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      const {\n        width,\n        height\n      } = this.imageCanvas;\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({\n        length: rows\n      }).forEach((_, index) => {\n        var _this$gridLayer2;\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer2 = this.gridLayer) === null || _this$gridLayer2 === void 0 ? void 0 : _this$gridLayer2.addChild(path);\n      });\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({\n        length: cols\n      }).forEach((_, index) => {\n        var _this$gridLayer3;\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer3 = this.gridLayer) === null || _this$gridLayer3 === void 0 ? void 0 : _this$gridLayer3.addChild(path);\n      });\n    }\n  }\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach(path => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n  isShapeInSelectedShapes(instanceId, groupName, index) {\n    return this.selectedPoints.findIndex(p => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0 || this.selectedRectangles.findIndex(p => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0;\n  }\n  isPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const {\n      bounds: {\n        x,\n        y,\n        width,\n        height\n      }\n    } = this.rasterLayer;\n    return localPoint.x >= 0 && localPoint.x <= x + width && localPoint.y >= 0 && localPoint.y <= y + height;\n  }\n  getPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n     if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n  getInstanceContainerByInstaceId(instaceId) {\n    var _this$mainLayer2;\n    return (_this$mainLayer2 = this.mainLayer) === null || _this$mainLayer2 === void 0 ? void 0 : _this$mainLayer2.children.find(i => i.data.type === SHAPE_TYPE.INSTANCE && i.data.instanceId === instaceId);\n  }\n  getGroupContainerByGroupName(instaceId, groupName) {\n    const instance = this.getInstanceContainerByInstaceId(instaceId);\n    return instance === null || instance === void 0 ? void 0 : instance.children.find(g => g.data.type === SHAPE_TYPE.GROUP && g.data.groupName === groupName);\n  }\n  getShapeByKey(instaceId, groupName, key) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.RECTANGLE_GROUP && p.data.id === key || p.data.type === SHAPE_TYPE.KEYPOINT && p.data.index === key);\n  }\n  getLabelByKey(instanceId, groupName, key) {\n    var _this$labelLayer;\n    return (_this$labelLayer = this.labelLayer) === null || _this$labelLayer === void 0 ? void 0 : _this$labelLayer.children.find(l => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === key);\n  }\n  getAttrLabelByKey(instanceId, groupName, key) {\n    var _this$attrLayer;\n    return (_this$attrLayer = this.attrLayer) === null || _this$attrLayer === void 0 ? void 0 : _this$attrLayer.children.find(l => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === `attr-${key}`);\n  }\n  getShapeByGroup() {\n    var _this$mainLayer3;\n    return (_this$mainLayer3 = this.mainLayer) === null || _this$mainLayer3 === void 0 ? void 0 : _this$mainLayer3.children.find(l => l.data.type === SHAPE_TYPE.KEYPOINT_BOX);\n  }\n  getPathByCategory(instaceId, groupName, pointCategory) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.PATH && p.data.pointCategory === pointCategory);\n  }\n  getPointsByCategory(instaceId, groupName, pointCategory) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.filter(p => p.data.type === SHAPE_TYPE.KEYPOINT && p.data.pointCategory === pointCategory);\n  }\n  canAddShape() {\n    if (this.props.isReview || this.props.readonly || !rootStore.review.drawMode) return false;\n    if (this.mainLayer && this.props.selectedShapeInfo) {\n      if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.RECTANGLE) {\n        if (this.props.ontologyGroup && this.props.ontologyGroup.count > 0) {\n          return this.props.annotatedPointOrShapeCount < this.props.ontologyGroup.count;\n        }\n      } else if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.KEYPOINT) {\n        const {\n          instanceId,\n          groupName,\n          id\n        } = this.props.selectedShapeStatus;\n        if (id === undefined || id < 0) return false;\n        const point = this.getShapeByKey(instanceId, groupName, id);\n        return !point;\n      }\n    }\n    return false;\n  }\n  containerAddPoint(groupData, point, pointCategory, index, isKeyPoint, visible = true, attributes) {\n    const {\n      instanceId,\n      groupName\n    } = groupData;\n    const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n    this.addKeypointShape(point, pointCategory, index, isKeyPoint, groupContainer, visible, attributes);\n  }\n  addKeypoint(point) {\n    if (this.mainLayer && this.props.selectedShapeInfo && this.props.selectedShapeStatus && this.props.selectedInstance) {\n      const {\n        id,\n        shapeType,\n        frameIndex\n      } = this.props.selectedShapeStatus;\n      const index = shapeType === LandmarkEditType.KEYPOINT && id || 0;\n      const {\n        x,\n        y\n      } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory,\n        isKeyPoint\n      } = this.props.selectedShapeInfo;\n      const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n      const groupData = {\n        instanceId,\n        groupName,\n        type: LandmarkEditType.KEYPOINT,\n        category: this.props.selectedInstance.category\n      };\n      this.containerAddPoint(groupData, newPoint, pointCategory, index, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n        const container = {\n          instanceId,\n          category,\n          groupName\n        };\n        otherPoints = this.updateCirclePath(pointCategory, true, container);\n      }\n      this.props.handleShapesChange([{\n        frameIndex,\n        instanceId,\n        category,\n        groupName,\n        index,\n        shapeType: LandmarkEditType.KEYPOINT,\n        shape: {\n          pointCategory,\n          isKeyPoint,\n          position: {\n            x,\n            y\n          },\n          visible: true // default is visible when point added\n        }\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyShape(); // move next\n    }\n  }\n  addKeypointShape(point, pointCategory, pointIndex, isKeyPoint, groupContainer, visible, attributes) {\n    if (!groupContainer) return;\n    const {\n      instanceId,\n      groupName,\n      category\n    } = groupContainer.data;\n    if (this.mainLayer) {\n      var _groupInfo$point_labe;\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: (rootStore.setting.pointSize + 1) / zoom,\n        fillColor: visible ? pointColor : '#3d424d',\n        strokeColor: '#ffffff',\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white'\n      });\n      pointCircle.data = {\n        frameIndex: this.props.selectedShapeStatus.frameIndex,\n        type: SHAPE_TYPE.KEYPOINT,\n        cursor: Cursor.MOVE,\n        pointCategory,\n        index: pointIndex,\n        isKeyPoint,\n        visible,\n        instanceId,\n        groupName,\n        category\n      };\n      groupContainer.addChild(pointCircle);\n\n      // add point to path\n      const groupData = rootStore.ontology.getGroupData(category, groupName);\n      const categoryData = groupData && groupData.categories && groupData.categories.find(v => v.name === pointCategory) || undefined;\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      const lineColor = (categoryData === null || categoryData === void 0 ? void 0 : categoryData.isConnect) === false ? new Paper.Color('rgba(0,0,0,0)') : new Paper.Color((categoryData === null || categoryData === void 0 ? void 0 : categoryData.displayColor) || POINT_COLOR);\n      let index = 0;\n      if (path) {\n        if (!path.data.isCircle) {\n          index = path.data.points.findIndex(p => pointIndex < p);\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: rootStore.setting.lineWidth / zoom,\n          strokeColor: lineColor,\n          selectedColor: lineColor\n        });\n        path.data.type = SHAPE_TYPE.PATH;\n        path.data.pointCategory = pointCategory;\n        path.data.points = [pointIndex];\n        path.data.instanceId = groupContainer.data.instanceId;\n        path.data.groupName = groupContainer.data.groupName;\n        groupContainer.addChild(path);\n      }\n      path.sendToBack();\n      if (path === this.smoothPath) {\n        path.smooth({\n          from: index - 1,\n          to: index + 1,\n          type: 'continuous'\n        });\n        path.fullySelected = true;\n      }\n      if (groupData && groupData.lines) {\n        const lines = groupData.lines.filter(v => v.points.indexOf(pointIndex) >= 0);\n        const linesData = [];\n        lines.forEach(connectPoints => {\n          if (connectPoints) {\n            const {\n              points,\n              color\n            } = connectPoints;\n            const isSource = pointIndex === points[0];\n            const otherEnd = this.getShapeByKey(instanceId, groupName, isSource ? points[1] : points[0]);\n            if (otherEnd) {\n              const segments = isSource ? [segment, otherEnd.position] : [otherEnd.position, segment];\n              const line = new Paper.Path({\n                segments,\n                strokeWidth: rootStore.setting.lineWidth / zoom,\n                strokeColor: color,\n                selectedColor: color\n              });\n              line.data.type = SHAPE_TYPE.PATH;\n              line.data.pointCategory = `${points[0]}-${points[1]}`;\n              line.data.points = points;\n              line.data.instanceId = groupContainer.data.instanceId;\n              line.data.groupName = groupContainer.data.groupName;\n              groupContainer.addChild(line);\n            }\n            linesData.push({\n              isSource,\n              fromTo: `${points[0]}-${points[1]}`\n            });\n          }\n        });\n        pointCircle.data.lines = linesData;\n      }\n      this.debounceUpdateGroupBox(instanceId, category, groupName);\n      const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n      const label = `${visible ? 1 : 0}-${pointIndex}`;\n      let attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$point_labe = groupInfo.point_label_config) === null || _groupInfo$point_labe === void 0 ? void 0 : _groupInfo$point_labe.fields, attributes, rootStore.setting.labelItems);\n      attrsLabel = `${rootStore.setting.displayPointIndex ? `${pointIndex}` : ''}${rootStore.setting.displayPointIndex && attrsLabel ? ';' : ''}${attrsLabel}`;\n      this.addLabel(label, {\n        x: point.x,\n        y: point.y,\n        width: rootStore.setting.pointSize / zoom,\n        height: rootStore.setting.pointSize / zoom\n      }, {\n        instanceId,\n        category,\n        groupName\n      }, pointIndex, visible, SHAPE_TYPE.KEYPOINT, attrsLabel);\n    }\n  }\n  removePointShape(containerData, pointIndex) {\n    const {\n      instanceId,\n      category,\n      groupName\n    } = containerData;\n    if (this.mainLayer) {\n      const point = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (point) {\n        const {\n          lines,\n          pointCategory\n        } = point.data;\n        point.remove();\n        // remove pointCategory path\n        const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n        if (path && !path.data.isCircle) {\n          const index = path.data.points.findIndex(p => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n        // remove group connect path\n        if (lines) {\n          lines.forEach(({\n            fromTo\n          }) => {\n            const line = this.getPathByCategory(instanceId, groupName, fromTo);\n            if (line) {\n              line.remove();\n            }\n          });\n        }\n      }\n      this.updateGroupBox(instanceId, category, groupName);\n    }\n    this.removeLabel(instanceId, groupName, pointIndex);\n  }\n  resizeShapes() {\n    var _this$labelLayer2, _this$attrLayer2;\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      this.mainLayer.children.forEach(instance => {\n        if (instance.children && instance.children.length > 0) {\n          instance.children.forEach(group => {\n            if (group.children) {\n              group.children.forEach(path => {\n                if (path.data.type === SHAPE_TYPE.KEYPOINT) {\n                  path.set({\n                    radius: rootStore.setting.pointSize / this.paperZoom\n                  });\n                  path.strokeWidth = 1 / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.PATH) {\n                  path.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.RECTANGLE_GROUP && path.children) {\n                  path.children.forEach(shape => {\n                    if (shape.data.type === SHAPE_TYPE.RECTANGLE_POINT) {\n                      shape.set({\n                        radius: rootStore.setting.pointSize / 2 / this.paperZoom\n                      });\n                    } else if (shape.data.type === SHAPE_TYPE.RECTANGLE_PATH) {\n                      shape.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                    }\n                  });\n                }\n              });\n            }\n          });\n        } else if (instance.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          instance.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n        }\n      });\n    }\n    if (((_this$labelLayer2 = this.labelLayer) === null || _this$labelLayer2 === void 0 ? void 0 : _this$labelLayer2.children) && this.labelLayer.children.length > 0) {\n      this.labelLayer.children.forEach(label => {\n        const {\n          zoom: oldZoom,\n          width,\n          height,\n          point\n        } = label.data;\n        resizeLabel({\n          width,\n          height,\n          zoom: this.paperZoom,\n          fontSize: FONT_SIZE\n        }, oldZoom, point, label, 'label');\n      });\n    }\n    if (((_this$attrLayer2 = this.attrLayer) === null || _this$attrLayer2 === void 0 ? void 0 : _this$attrLayer2.children) && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach(label => {\n        const {\n          zoom: oldZoom,\n          width,\n          height,\n          point\n        } = label.data;\n        resizeLabel({\n          width,\n          height,\n          zoom: this.paperZoom,\n          fontSize: FONT_SIZE\n        }, oldZoom, point, label, 'attr');\n      });\n    }\n    const {\n      instanceId,\n      groupName,\n      id\n    } = this.props.selectedShapeStatus;\n    this.setPointSelected(instanceId, groupName, id, true);\n  }\n  cleanLayer() {\n    if (this.mainLayer) {\n      var _this$mainLayer$child;\n      (_this$mainLayer$child = this.mainLayer.children) === null || _this$mainLayer$child === void 0 ? void 0 : _this$mainLayer$child.forEach(container => {\n        if (container.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          container.remove();\n        } else {\n          var _container$children;\n          (_container$children = container.children) === null || _container$children === void 0 ? void 0 : _container$children.forEach(group => {\n            group === null || group === void 0 ? void 0 : group.removeChildren();\n          });\n        }\n      });\n    }\n    if (this.labelLayer) {\n      this.labelLayer.removeChildren();\n    }\n    if (this.attrLayer) {\n      this.attrLayer.removeChildren();\n    }\n    if (this.warningLayer) {\n      this.warningLayer.removeChildren();\n    }\n  }\n  addLabel(content, shape, groupInfo, key, visible, shapeType, attrsLabel) {\n    if (this.labelLayer) {\n      const {\n        instanceId,\n        groupName\n      } = groupInfo;\n      const fontSize = FONT_SIZE / this.paperZoom;\n      const label = new Paper.PointText({\n        content,\n        fontSize,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#000000',\n        shadowBlur: 2 / this.paperZoom,\n        shadowOffset: 2 / this.paperZoom\n      });\n      const width = label.bounds.width + fontSize / 2;\n      const height = label.bounds.height + fontSize / 2;\n      const labelRect = new Paper.Shape.Rectangle({\n        size: [width, height],\n        fillColor: rootStore.setting.labelBgColor\n      });\n      label.position.x = labelRect.bounds.width / 2;\n      label.position.y = labelRect.bounds.height / 2;\n      const labelGroup = new Paper.Group();\n      labelGroup.data = {\n        point: [shape.x, shape.y],\n        instanceId,\n        groupName,\n        key,\n        type: shapeType === SHAPE_TYPE.KEYPOINT ? LabelType.KEYPOINT : LabelType.OBJECT,\n        zoom: this.paperZoom,\n        height,\n        width\n      };\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        labelGroup.addChild(labelRect);\n      }\n      labelGroup.addChild(label);\n      this.labelLayer.addChild(labelGroup);\n      labelGroup.position.x = shape.x + labelRect.bounds.width / 2;\n      labelGroup.position.y = shape.y - labelRect.bounds.height / 2 - rootStore.setting.lineWidth / this.paperZoom;\n      if (shapeType !== SHAPE_TYPE.KEYPOINT_BOX && this.attrLayer) {\n        let center = {\n          x: shape.x,\n          y: shape.y\n        };\n        if (SHAPE_TYPE.RECTANGLE) {\n          center = {\n            x: shape.x + shape.width / 2,\n            y: shape.y + shape.height / 2\n          };\n        }\n        const arrtLabelGroup = labelGroup.clone();\n        arrtLabelGroup.data.key = `attr-${arrtLabelGroup.data.key}`;\n        arrtLabelGroup.data.point = [center.x, center.y];\n        arrtLabelGroup.children.slice(-1)[0].fillColor = new Paper.Color('#ffffff');\n        arrtLabelGroup.children.slice(-1)[0].content = '';\n        this.attrLayer.addChild(arrtLabelGroup);\n        if (attrsLabel) {\n          this.updateLabelContent(arrtLabelGroup, attrsLabel, shapeType);\n        } else {\n          arrtLabelGroup.visible = false;\n        }\n      }\n    }\n  }\n  updateLabel(instanceId, groupName, key, position, center, type) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [position.x, position.y];\n        label.position.x = position.x + label.bounds.width / 2;\n        label.position.y = position.y - label.bounds.height / 2;\n      }\n    }\n    if (this.attrLayer) {\n      if (type === LandmarkEditType.KEYPOINT) {\n        if (rootStore.setting.activePointAttributesMode === AttributesMode.HOVER) return;\n      } else if (rootStore.setting.activeAttributesMode === AttributesMode.HOVER) {\n        return;\n      }\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [center.x, center.y];\n        label.position.x = center.x;\n        label.position.y = center.y;\n      }\n    }\n  }\n  updateAttributeLabel(instanceId, category, groupName, key, attributes, instanceNum) {\n    const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n    let label = '';\n    if (typeof key === 'number') {\n      var _groupInfo$point_labe2;\n      label = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$point_labe2 = groupInfo.point_label_config) === null || _groupInfo$point_labe2 === void 0 ? void 0 : _groupInfo$point_labe2.fields, attributes, rootStore.setting.pointLabelItems);\n      label = `${rootStore.setting.displayPointIndex ? `${key}` : ''}${rootStore.setting.displayPointIndex && label ? ';' : ''}${label}`;\n    } else {\n      var _groupInfo$label_conf;\n      const categoryLabel = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''}  ${instanceNum || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n      label = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf = groupInfo.label_config) === null || _groupInfo$label_conf === void 0 ? void 0 : _groupInfo$label_conf.fields, attributes, rootStore.setting.labelItems);\n      label = `${rootStore.setting.displayCategory ? `${categoryLabel}` : ''}${rootStore.setting.displayCategory && label ? ';' : ''}${label}`;\n    }\n    const attrLayer = this.getAttrLabelByKey(instanceId, groupName, key);\n    if (attrLayer) {\n      if (label) {\n        this.updateLabelContent(attrLayer, label, SHAPE_TYPE.KEYPOINT);\n      } else {\n        attrLayer.visible = false;\n      }\n    }\n  }\n  updateLabelContent(label, content, shapeType) {\n    if (this.attrLayer && label) {\n      const zoom = Paper.view.zoom * this.attrLayer.matrix.scaling.x;\n      const labelText = label.children.slice(-1)[0];\n      labelText.content = content;\n      const {\n        width,\n        height\n      } = labelText.bounds;\n      const fontSize = FONT_SIZE / zoom;\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        label.children[0].size.height = height + fontSize / 2;\n        label.children[0].size.width = width + fontSize / 2;\n      }\n      label.data.width = label.children[0].bounds.width;\n      label.data.height = label.children[0].bounds.height;\n      label.data.zoom = this.paperZoom;\n      let visible = false;\n      if (shapeType === SHAPE_TYPE.KEYPOINT) {\n        visible = rootStore.setting.activePointAttributesMode === AttributesMode.ALWAYS;\n      } else if (SHAPE_TYPE.RECTANGLE) {\n        visible = rootStore.setting.activeAttributesMode === AttributesMode.ALWAYS;\n      }\n      if (visible) {\n        const {\n          point\n        } = label.data;\n        resetAttrLabelPosition(label, {\n          x: point[0],\n          y: point[1]\n        }, visible);\n      } else {\n        label.visible = false;\n      }\n    }\n  }\n  updatelabelVisible(activeMode, type = 'object') {\n    var _this$attrLayer3;\n    if (this.shownLabel) {\n      this.shownLabel.visible = false;\n      this.shownLabel = null;\n    }\n    if (((_this$attrLayer3 = this.attrLayer) === null || _this$attrLayer3 === void 0 ? void 0 : _this$attrLayer3.children) && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach(label => {\n        const {\n          type: labelType\n        } = label.data;\n        if (type === labelType) {\n          label.visible = activeMode === AttributesMode.ALWAYS;\n        }\n      });\n    }\n  }\n  removeLabel(instanceId, groupName, key) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n  updateShapes() {\n    this.props.updatedShapes.forEach(updatedShape => {\n      if (updatedShape.frameIndex !== this.props.currentFrame) return;\n      switch (updatedShape.shapeType) {\n        case LandmarkEditType.KEYPOINT:\n          this.updatePoint(updatedShape);\n          break;\n        case LandmarkEditType.RECTANGLE:\n          this.updateRectangle(updatedShape);\n          break;\n        default:\n          break;\n      }\n    });\n    this.props.onShapesUpdated();\n  }\n  updateRectangle(updateShape) {\n    const {\n      instanceId,\n      groupName,\n      category,\n      id,\n      shape\n    } = updateShape;\n    if (id !== undefined) {\n      const rectangle = shape;\n      const currRectangle = this.getShapeByKey(instanceId, groupName, id);\n      if (currRectangle) {\n        // alreay exist, should update\n        if (rectangle === undefined) {\n          // delete\n          this.removeRectangle(instanceId, groupName, id);\n        } else if (rectangle.x) {\n          const {\n            x,\n            y,\n            width,\n            height,\n            displayColor\n          } = rectangle;\n          // update position\n          this.drawRectangle({\n            x,\n            y,\n            width,\n            height,\n            displayColor\n          }, {\n            instanceId,\n            category,\n            groupName\n          }, id);\n        }\n      } else if (rectangle) {\n        //  has been removed, should add\n        const {\n          x,\n          y,\n          width,\n          height,\n          displayColor\n        } = rectangle;\n        const path = new Paper.Path();\n        path.data.id = id;\n        path.add(new Paper.Point(x, y));\n        path.add(new Paper.Point(x + width, y));\n        path.add(new Paper.Point(x + width, y + height));\n        path.add(new Paper.Point(x, y + height));\n        path.closed = true;\n        this.addRectangle(path, {\n          instanceId,\n          groupName,\n          category,\n          shapeType: LandmarkEditType.RECTANGLE,\n          displayColor\n        }, false);\n      }\n    }\n  }\n  updatePoint(updateShape) {\n    const {\n      frameIndex,\n      instanceId,\n      groupName,\n      category,\n      index,\n      shape\n    } = updateShape;\n    if (index !== undefined) {\n      let updatedCategorie;\n      const point = shape;\n      const currPoint = this.getShapeByKey(instanceId, groupName, index);\n      if (currPoint) {\n        const currCategory = currPoint.data.pointCategory;\n        updatedCategorie = {\n          pointCategory: currCategory,\n          frameIndex,\n          instanceId,\n          groupName,\n          category\n        };\n        const groupData = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(groupData, index);\n        } else if (point.position && point.pointCategory) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          this.updatePath(currPoint, point.position);\n          // update visible\n          if (point.visible !== undefined && currPoint.data.visible !== point.visible) {\n            this.changeVisibleStyle(currPoint, index, groupData, point.visible);\n          }\n          if (rootStore.setting.activePointAttributesMode !== AttributesMode.HIDE) {\n            this.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n          this.debounceUpdateGroupBox(instanceId, category, groupName);\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const {\n          position,\n          pointCategory,\n          isKeyPoint,\n          visible,\n          attributes\n        } = point;\n        if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          updatedCategorie = {\n            pointCategory,\n            frameIndex,\n            instanceId,\n            groupName,\n            category\n          };\n          const groupData = {\n            instanceId,\n            groupName,\n            type: LandmarkEditType.KEYPOINT,\n            category\n          };\n          this.containerAddPoint(groupData, new Paper.Point(position.x, position.y), pointCategory, index, isKeyPoint, visible, attributes);\n        }\n      }\n      if (updatedCategorie) {\n        const {\n          pointCategory,\n          ...newContainer\n        } = updatedCategorie;\n        const categoryKey = `${frameIndex}_${newContainer.instanceId}_${newContainer.groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, newContainer);\n        }\n      }\n    }\n  }\n  updatePath(point, position) {\n    const {\n      instanceId,\n      groupName,\n      pointCategory,\n      index,\n      lines\n    } = point.data;\n    const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n    if (path && !path.data.isCircle) {\n      const segmentIndex = path.data.points.findIndex(p => p === index);\n      path.segments[segmentIndex].point.x = position.x;\n      path.segments[segmentIndex].point.y = position.y;\n    }\n    // change connect line position\n    if (lines) {\n      lines.forEach(({\n        isSource,\n        fromTo\n      }) => {\n        const line = this.getPathByCategory(instanceId, groupName, fromTo);\n        if (line && point.position) {\n          let n = isSource ? 0 : 1;\n          if (!line.segments[n]) {\n            n = 0;\n          }\n          line.segments[n].point.x = position.x;\n          line.segments[n].point.y = position.y;\n        }\n      });\n    }\n    this.updateLabel(instanceId, groupName, index, position, position, LandmarkEditType.KEYPOINT);\n  }\n  setPointSelected(instanceId, groupName, index, selected) {\n    var _this$mainLayer4;\n    if (((_this$mainLayer4 = this.mainLayer) === null || _this$mainLayer4 === void 0 ? void 0 : _this$mainLayer4.children) && this.mainLayer.children.length > 0) {\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      if (point) {\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          point.strokeWidth = 3 / zoom;\n          point.radius = (rootStore.setting.pointSize + 1) / zoom;\n        } else {\n          point.radius = rootStore.setting.pointSize / zoom;\n          point.strokeWidth = 1 / zoom;\n        }\n      }\n    }\n  }\n  setMultiShapesSelected(selectedShapes, type) {\n    if (selectedShapes.length > 0) {\n      const {\n        instanceId,\n        groupName\n      } = selectedShapes[0].data;\n      this.props.selectGroup(instanceId, groupName, false);\n      this.props.setSelectedShape(undefined);\n    }\n    if (type === CategoryPathShape.CIRCLE) {\n      this.selectedPoints = selectedShapes.sort((a, b) => a.data.index - b.data.index);\n      this.props.setMultiSelectedShape(this.selectedPoints.map(point => point.data.index));\n      this.selectedPoints.forEach(point => {\n        const pData = point.data;\n        this.setPointSelected(pData.instanceId, pData.groupName, pData.index, true);\n      });\n    } else {\n      this.selectedRectangles = selectedShapes;\n      this.selectedRectangles.forEach(rectangle => {\n        const rData = rectangle.data;\n        this.selectShape(rData.instanceId, rData.groupName, rData.id);\n      });\n    }\n  }\n  setMultiShapesUnselected() {\n    this.selectedPoints.forEach(point => {\n      const {\n        instanceId,\n        groupName,\n        index\n      } = point.data;\n      this.setPointSelected(instanceId, groupName, index, false);\n    });\n    this.selectedRectangles.forEach(rectangle => {\n      const {\n        instanceId,\n        groupName,\n        id\n      } = rectangle.data;\n      this.selectShape(instanceId, groupName, id, false);\n    });\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    this.props.setMultiSelectedShape([]);\n  }\n  updatePointsPosition(shapes) {\n    this.props.handleShapesChange(shapes);\n    this.updateGroupBox(shapes[0].instanceId, shapes[0].category, shapes[0].groupName);\n  }\n\n  // resize and drag, change label position\n  updateRectanglePosition(shapes) {\n    this.props.handleShapesChange(shapes);\n    if (this.labelLayer) {\n      shapes.forEach(({\n        instanceId,\n        groupName,\n        id,\n        shape\n      }) => {\n        if (id && shape && shape.x) {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = shape;\n          this.updateLabel(instanceId, groupName, id, {\n            x,\n            y\n          }, {\n            x: x + width / 2,\n            y: y + height / 2\n          }, LandmarkEditType.RECTANGLE);\n        }\n      });\n    }\n  }\n  deleteSelectedPoints() {\n    const updatedCategories = [];\n    const points = (this.selectedPoints.length > 0 ? this.selectedPoints.map(p => ({\n      frameIndex: this.props.currentFrame,\n      instanceId: p.data.instanceId,\n      category: p.data.category,\n      groupName: p.data.groupName,\n      index: p.data.index,\n      shapeType: LandmarkEditType.KEYPOINT\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.KEYPOINT\n    }]).filter(selectedShapeStatus => {\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        index\n      } = selectedShapeStatus;\n      const point = typeof index === 'number' && this.getShapeByKey(instanceId, groupName, index);\n      if (point && point.data) {\n        const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${point.data.pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          const path = this.getPathByCategory(instanceId, groupName, point.data.pointCategory);\n          const instance = this.getInstanceContainerByInstaceId(instanceId);\n          if (instance && path && path.data.isCircle) {\n            const group = rootStore.ontology.getGroupData(instance.data.category, groupName);\n            const pointCategory = group && group.categories && group.categories.length && group.categories.find(c => c.name === point.data.pointCategory);\n            if (pointCategory) {\n              const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n              const pIndex1 = sortedKeys[0];\n              const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n              if (index !== pIndex1 && index !== pIndex2) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n      return !!point;\n    });\n    this.props.handleShapesRemove(points);\n    points.forEach(({\n      frameIndex,\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const instance = this.getInstanceContainerByInstaceId(instanceId);\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      if (instance && point && !updatedCategories.includes(point.data.pointCategory)) {\n        updatedCategories.push({\n          pointCategory: point.data.pointCategory,\n          frameIndex,\n          instanceId,\n          groupName,\n          category: instance.data.category\n        });\n      }\n      this.removePointShape({\n        instanceId,\n        category,\n        groupName\n      }, index);\n    });\n    updatedCategories.forEach(({\n      frameIndex,\n      pointCategory,\n      ...container\n    }) => {\n      const categoryKey = `${frameIndex}_${container.instanceId}_${container.groupName}_${pointCategory}`;\n      this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n    });\n    this.selectedPoints = [];\n  }\n  deleteSelectedRectangle() {\n    const rectangles = (this.selectedRectangles.length > 0 ? this.selectedRectangles.map(rect => ({\n      frameIndex: rect.data.frameIndex,\n      instanceId: rect.data.instanceId,\n      category: rect.data.category,\n      groupName: rect.data.groupName,\n      id: rect.data.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      id: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    }]).filter(v => typeof v.id === 'string');\n    this.props.handleShapesRemove(rectangles);\n    rectangles.forEach(({\n      instanceId,\n      groupName,\n      id\n    }) => {\n      this.removeRectangle(instanceId, groupName, id);\n    });\n    this.selectedRectangles = [];\n  }\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ? this.selectedPoints.map(p => p.data) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id\n    }].filter(v => v.shapeType === LandmarkEditType.KEYPOINT);\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      this.changeVisibleStyle(point, index, {\n        instanceId,\n        category,\n        groupName\n      }, !point.data.visible);\n    });\n    this.props.togglePointsVisibility(points);\n  }\n  changeVisibleStyle(point, index, groupData, visible) {\n    const {\n      instanceId,\n      groupName\n    } = groupData;\n    const labelGroup = this.getLabelByKey(instanceId, groupName, index);\n    if (point) {\n      let fillColor = POINT_COLOR;\n      let strokeColor = '#ffffff';\n      if (visible) {\n        fillColor = point.data.isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      } else {\n        fillColor = '#3d424d';\n        strokeColor = point.data.isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      }\n      point.data.visible = visible;\n      point.fillColor = new Paper.Color(fillColor);\n      point.strokeColor = new Paper.Color(strokeColor);\n    }\n    if (this.labelLayer && labelGroup) {\n      const label = labelGroup.children.length === 2 ? labelGroup.children[1] : labelGroup.children[0];\n      label.content = `${visible ? '1' : '0'}-${index}`;\n      label.fillColor = new Paper.Color(visible ? 'white' : 'red');\n    }\n  }\n  hitTest(event) {\n    var _this$tool;\n    if (this.mainLayer && !((_this$tool = this.tool) === null || _this$tool === void 0 ? void 0 : _this$tool.mouseDown)) {\n      var _hit;\n      this.cursor = Cursor.DEFAULT;\n      const isDrawPoint = this.props.selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT;\n      if (this.canAddShape()) {\n        this.cursor = isDrawPoint ? Cursor.POINTER : Cursor.CROSSHAIR;\n      }\n      if (this.selectedHit) {\n        this.selectedHit.selected = false;\n      }\n      const hits = this.mainLayer.hitTestAll(event.point, {\n        fill: true,\n        selected: false,\n        handles: true,\n        stroke: true,\n        tolerance: 10 / this.paperZoom,\n        match: ht => {\n          if (ht && ht.item && (ht.item.data.type === undefined || ht.item.data.type === SHAPE_TYPE.KEYPOINT_BOX)) {\n            return false;\n          }\n          return true;\n        }\n      });\n      let hit;\n      for (let i = 0; i < hits.length; i += 1) {\n        const h = hits[i];\n        const {\n          type\n        } = h.item.data;\n        if (!type || type !== SHAPE_TYPE.INSTANCE && type !== SHAPE_TYPE.GROUP && type !== SHAPE_TYPE.KEYPOINT_BOX && type !== SHAPE_TYPE.RECTANGLE_GROUP && (type !== SHAPE_TYPE.PATH || type === SHAPE_TYPE.PATH && ['handle-in', 'handle-out'].includes(h.type))) {\n          // select point | rectangle | rectangle control | path handle\n          if (type === SHAPE_TYPE.RECTANGLE || type === SHAPE_TYPE.RECTANGLE_POINT || type === SHAPE_TYPE.RECTANGLE_PATH) {\n            if (i === 0 && !this.canAddShape()) {\n              hit = h;\n            }\n          } else {\n            hit = h;\n            if (type === SHAPE_TYPE.KEYPOINT) {\n              break;\n            }\n          }\n        }\n      }\n      if (((_hit = hit) === null || _hit === void 0 ? void 0 : _hit.item) && !event.event.ctrlKey) {\n        var _hit$item$data, _hit$item$data2, _hit$item$data3, _hit$item$data4, _hit$item$data5;\n        if (!this.isShapeInSelectedShapes((_hit$item$data = hit.item.data) === null || _hit$item$data === void 0 ? void 0 : _hit$item$data.instanceId, (_hit$item$data2 = hit.item.data) === null || _hit$item$data2 === void 0 ? void 0 : _hit$item$data2.groupName, (_hit$item$data3 = hit.item.data) === null || _hit$item$data3 === void 0 ? void 0 : _hit$item$data3.index) && ((_hit$item$data4 = hit.item.data) === null || _hit$item$data4 === void 0 ? void 0 : _hit$item$data4.index) !== this.props.selectedShapeStatus.id && ((_hit$item$data5 = hit.item.data) === null || _hit$item$data5 === void 0 ? void 0 : _hit$item$data5.id) !== this.props.selectedShapeStatus.id) {\n          this.selectedHit = hit.item;\n          hit.item.selected = true;\n        }\n        if (hit.item.data.cursor) {\n          this.cursor = hit.item.data.cursor;\n        } else {\n          this.cursor = Cursor.MOVE;\n        }\n        this.showShapeLabel(hit, event.point);\n      } else if (this.shownLabel) {\n        const {\n          point\n        } = this.shownLabel.data;\n        resetAttrLabelPosition(this.shownLabel, {\n          x: point[0],\n          y: point[1]\n        }, false);\n      }\n      this.hits = hit;\n      if (this.currentWarnings.length > 0) {\n        var _this$warningLayer;\n        this.warningBtn = (_this$warningLayer = this.warningLayer) === null || _this$warningLayer === void 0 ? void 0 : _this$warningLayer.hitTest(event.point);\n      }\n      if (this.smoothPath) {\n        this.smoothPath.fullySelected = true;\n      }\n    }\n  }\n  showShapeLabel(hits, point) {\n    var _label$children;\n    const localPoint = this.getPointInImage(Paper.view.projectToView(point));\n    const {\n      data\n    } = hits.item;\n    let label;\n    if (data.type === SHAPE_TYPE.KEYPOINT && rootStore.setting.activePointAttributesMode === AttributesMode.HOVER) {\n      label = this.getAttrLabelByKey(data.instanceId, data.groupName, data.index);\n    } else if ((data.type === SHAPE_TYPE.RECTANGLE || data.type === SHAPE_TYPE.RECTANGLE_PATH || data.type === SHAPE_TYPE.RECTANGLE_POINT) && hits.item.parent && rootStore.setting.activeAttributesMode === AttributesMode.HOVER) {\n      const {\n        instanceId,\n        groupName,\n        id\n      } = hits.item.parent.data;\n      label = this.getAttrLabelByKey(instanceId, groupName, id);\n    }\n    if (label && ((_label$children = label.children) === null || _label$children === void 0 ? void 0 : _label$children.slice(-1)[0]).content) {\n      if (this.shownLabel) {\n        if (JSON.stringify(label) !== JSON.stringify(this.shownLabel)) {\n          const {\n            point: position\n          } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, {\n            x: position[0],\n            y: position[1]\n          }, false);\n          this.shownLabel = label;\n        }\n      } else {\n        this.shownLabel = label;\n      }\n      this.shownLabel.visible = true;\n      this.shownLabel.position.x = localPoint.x + 50 / Paper.view.zoom;\n      this.shownLabel.position.y = localPoint.y + 50 / Paper.view.zoom;\n    }\n  }\n  getNewPointsByKeyPointRange(path, startKey, endKey, instanceId, groupName) {\n    const startPosition = this.getShapeByKey(instanceId, groupName, startKey).position;\n    const endPosition = this.getShapeByKey(instanceId, groupName, endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    let newPoints = {}; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints = {\n        ...newPoints,\n        [base + 1]: nextPoint\n      };\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n  getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData) {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = parentData;\n    const updatedShapes = [];\n    const indexs = Object.keys(newPoints).map(v => Number(v));\n    for (let index = 0; index < indexs.length; index += 1) {\n      const pointIndex = indexs[index];\n      const existingPoint = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (newPoints[pointIndex]) {\n        const {\n          x,\n          y\n        } = newPoints[pointIndex];\n        const pointInfo = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index: pointIndex,\n          shapeType: LandmarkEditType.KEYPOINT\n        };\n        if (existingPoint) {\n          if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n            // update position\n            existingPoint.position.x = x;\n            existingPoint.position.y = y;\n            this.updatePath(existingPoint, {\n              x,\n              y\n            });\n            updatedShapes.push({\n              ...pointInfo,\n              shape: {\n                position: {\n                  x,\n                  y\n                }\n              }\n            });\n          }\n        } else {\n          // add new point\n          const isKeyPoint = pointCategory.keys.includes(pointIndex);\n          const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n          this.addKeypointShape(new Paper.Point(x, y), pointCategory.name, pointIndex, isKeyPoint, groupContainer, true);\n          updatedShapes.push({\n            ...pointInfo,\n            shape: {\n              pointCategory: pointCategory.name,\n              isKeyPoint,\n              position: {\n                x,\n                y\n              },\n              visible: true\n            }\n          });\n        }\n      }\n    }\n    return updatedShapes;\n  }\n  autoAdjust(point = this.props.selectedShapeStatus) {\n    if (this.props.selectedShapeInfo) {\n      const {\n        id\n      } = point;\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory: categoryName\n      } = this.props.selectedShapeInfo;\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName); // pointCategory path\n      const pointCategory = this.props.categories.find(c => c.name === categoryName); // pointCategory definition\n      if (path && pointCategory && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex;\n        let nextKeyPointIndex;\n        const {\n          points = []\n        } = path.data;\n        const {\n          keys = []\n        } = pointCategory;\n        const keysWithTwoSides = [...(keys.includes(points[0]) ? [] : [points[0]]), ...keys, ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]])].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex(key => key > Number(id));\n        if (keyIndex < 0) {\n          // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex, instanceId, groupName);\n          const parentData = {\n            instanceId,\n            category,\n            groupName\n          };\n          const updatedShapes = this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData);\n          if (updatedShapes.length > 0) {\n            this.props.handleShapesChange(updatedShapes);\n          }\n        }\n      }\n    }\n  }\n  switchSmoothMode() {\n    if (this.props.selectedShapeInfo) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory: categoryName\n      } = this.props.selectedShapeInfo;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName);\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      if (path && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const pointCategory = this.props.categories.find(c => c.name === categoryName);\n          if (pointCategory) {\n            const keyPoints = pointCategory.keys.filter(k => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedShapes = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i], instanceId, groupName);\n              const parentData = {\n                instanceId,\n                category,\n                groupName\n              };\n              updatedShapes = [...updatedShapes, ...this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData)];\n            }\n            if (updatedShapes.length > 0) {\n              this.props.handleShapesChange(updatedShapes);\n            }\n          }\n          this.clearSmooth();\n        } else {\n          // start\n          path.fullySelected = true;\n          path.smooth({\n            type: 'continuous'\n          });\n          this.smoothPath = path;\n        }\n      }\n    }\n  }\n  clearSmooth() {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach(seg => {\n        seg.clearHandles();\n      });\n      this.smoothPath = null;\n    }\n  }\n  setCategoryAsCircle() {\n    if (this.props.selectedShapeInfo) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory\n      } = this.props.selectedShapeInfo;\n      if (pointCategory) {\n        const container = {\n          instanceId,\n          category,\n          groupName\n        };\n        const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, false, container);\n          this.props.setCategoryPathShape(categoryKey);\n        } else {\n          const updatedShapes = this.updateCirclePath(pointCategory, true, container);\n          this.props.setCategoryPathShape(categoryKey, CategoryPathShape.CIRCLE, updatedShapes);\n        }\n      }\n    }\n  }\n  updateCirclePath(categoryName, isCirclePath = true, container) {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = container;\n    const updatedShapes = [];\n    const path = this.getPathByCategory(instanceId, groupName, categoryName);\n    const categoryData = rootStore.ontology.getCategoryData(category, groupName, categoryName);\n    const lineColor = (categoryData === null || categoryData === void 0 ? void 0 : categoryData.isConnect) === false ? new Paper.Color('rgba(0,0,0,0)') : new Paper.Color((categoryData === null || categoryData === void 0 ? void 0 : categoryData.displayColor) || POINT_COLOR);\n    if (path && categoryData) {\n      const categoryPoints = this.getPointsByCategory(instanceId, groupName, categoryName);\n      if (categoryPoints) {\n        const sortedKeys = [...categoryData.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find(p => p.data.index === pIndex1);\n        const point2 = categoryPoints.find(p => p.data.index === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (point1 && point2 && isCirclePath) {\n          // is a circle & key points all exist\n          const centerX = (point1.position.x + point2.position.x) / 2;\n          const centerY = (point1.position.y + point2.position.y) / 2;\n          const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n          const newPath = new Paper.CompoundPath({\n            children: [new Paper.Path.Circle({\n              center: [centerX, centerY],\n              radius\n            }), new Paper.Path.Line({\n              from: [point1.position.x, point1.position.y],\n              to: [point2.position.x, point2.position.y]\n            }), new Paper.Path.Line({\n              from: new Paper.Point(computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point1.position, Math.PI / 2)),\n              to: new Paper.Point(computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point1.position, -Math.PI / 2))\n            })],\n            strokeWidth: rootStore.setting.lineWidth / zoom,\n            strokeColor: lineColor,\n            selectedColor: lineColor\n          });\n          newPath.data = {\n            ...path.data,\n            isCircle: true,\n            instanceId,\n            groupName\n          };\n          path.replaceWith(newPath);\n\n          // update all points in this pointCategory\n          const update = (index, position) => {\n            const existingPoint = this.getShapeByKey(instanceId, groupName, index);\n            const pointInfo = {\n              frameIndex: this.props.selectedShapeStatus.frameIndex,\n              instanceId,\n              category,\n              groupName,\n              index,\n              shapeType: LandmarkEditType.KEYPOINT\n            };\n            if (existingPoint) {\n              // update position\n              existingPoint.position.x = position.x;\n              existingPoint.position.y = position.y;\n              this.updatePath(existingPoint, position);\n              updatedShapes.push({\n                ...pointInfo,\n                shape: {\n                  position: {\n                    x: position.x,\n                    y: position.y\n                  }\n                }\n              });\n            } else {\n              const isKeyPoint = categoryData.keys.includes(index);\n              const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n              this.addKeypointShape(new Paper.Point(position.x, position.y), categoryData.name, index, isKeyPoint, groupContainer, true);\n              updatedShapes.push({\n                ...pointInfo,\n                shape: {\n                  pointCategory: categoryData.name,\n                  isKeyPoint,\n                  position: {\n                    x: position.x,\n                    y: position.y\n                  },\n                  visible: true\n                }\n              });\n            }\n          };\n          const [start, end] = categoryData.range;\n          for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n            const radians = Math.PI / (pIndex2 - pIndex1) * (i - pIndex1);\n            const position = computeRotatedPosition({\n              x: centerX,\n              y: centerY\n            }, point1.position, radians);\n            update(i, position);\n          }\n          for (let i = pIndex2 + 1; i <= end; i += 1) {\n            const radians = Math.PI / (end + 1 - pIndex2) * (i - pIndex2);\n            const position = computeRotatedPosition({\n              x: centerX,\n              y: centerY\n            }, point2.position, radians);\n            update(i, position);\n          }\n          for (let i = start; i < pIndex1; i += 1) {\n            const radians = Math.PI / (end + 1 - pIndex2) * (start - pIndex1);\n            const position = computeRotatedPosition({\n              x: centerX,\n              y: centerY\n            }, point1.position, radians);\n            update(i, position);\n          }\n        } else {\n          const points = [...categoryPoints].sort((a, b) => a.data.index - b.data.index);\n          const newPath = new Paper.Path({\n            segments: points.map(p => p.position),\n            strokeWidth: rootStore.setting.lineWidth / zoom,\n            strokeColor: lineColor,\n            selectedColor: lineColor\n          });\n          newPath.data = {\n            ...path.data,\n            isCircle: false,\n            points: points.map(p => p.data.index)\n          };\n          path.replaceWith(newPath);\n        }\n      }\n    }\n    return updatedShapes;\n  }\n  addRectangle(path, groupInfo, add = true) {\n    if (this.mainLayer) {\n      const {\n        displayColor,\n        instanceId,\n        category,\n        groupName\n      } = groupInfo;\n      const {\n        data: {\n          id\n        },\n        segments\n      } = path;\n      const rectData = {\n        x: segments[0].point.x,\n        y: segments[0].point.y,\n        width: segments[2].point.x - segments[0].point.x,\n        height: segments[2].point.y - segments[0].point.y,\n        displayColor\n      };\n      this.drawRectangle(rectData, {\n        instanceId,\n        category,\n        groupName\n      }, id);\n      if (add) {\n        this.props.setNextEmptyShape();\n      }\n    }\n  }\n  getAlphaColor(color, opacity = this.fillOpacity) {\n    return hexToRgba(color, opacity);\n  }\n  drawRectangle(rectData, groupData, id, visible = true) {\n    if (this.props.selectedShapeInfo && this.mainLayer) {\n      const {\n        x,\n        y,\n        width,\n        height,\n        displayColor\n      } = rectData;\n      const {\n        instanceId,\n        category,\n        groupName\n      } = groupData;\n      let instanceContainer = this.getInstanceContainerByInstaceId(instanceId);\n      let groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (!instanceContainer) {\n        var _this$mainLayer5;\n        instanceContainer = new Paper.Group();\n        instanceContainer.data = {\n          instanceId,\n          name: category,\n          type: SHAPE_TYPE.INSTANCE\n        };\n        (_this$mainLayer5 = this.mainLayer) === null || _this$mainLayer5 === void 0 ? void 0 : _this$mainLayer5.addChild(instanceContainer);\n      }\n      if (!instanceContainer || !groupContainer) {\n        groupContainer = new Paper.Group();\n        groupContainer.data = {\n          groupName,\n          category,\n          type: SHAPE_TYPE.GROUP,\n          instanceId\n        };\n        instanceContainer.addChild(groupContainer);\n      }\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      let rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox) {\n        rectangleBox.removeChildren();\n      } else {\n        rectangleBox = new Paper.Group();\n        rectangleBox.data = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          id,\n          groupName,\n          category,\n          type: SHAPE_TYPE.RECTANGLE_GROUP,\n          instanceId,\n          displayColor,\n          visible\n        };\n        groupContainer.addChild(rectangleBox);\n      }\n      const rectangle = new Paper.Shape.Rectangle({\n        point: [x, y],\n        size: [width, height],\n        fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n        strokeWidth: rootStore.setting.lineWidth / zoom\n      });\n      rectangle.data = {\n        parentShape: id,\n        cursor: Cursor.MOVE,\n        type: SHAPE_TYPE.RECTANGLE\n      };\n      rectangleBox.addChild(rectangle);\n      this.selectShape(instanceId, groupName, id, id === this.props.selectedShapeStatus.id);\n      if (this.labelLayer) {\n        var _instance$children$fi, _groupInfo$label_conf2;\n        const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n        const instance = this.props.getInstance(instanceId);\n        const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[this.props.currentFrame];\n        const label = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''} ${(instance === null || instance === void 0 ? void 0 : instance.number) || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n        let attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf2 = groupInfo.label_config) === null || _groupInfo$label_conf2 === void 0 ? void 0 : _groupInfo$label_conf2.fields, group === null || group === void 0 ? void 0 : group.attributes, rootStore.setting.labelItems);\n        attrsLabel = `${rootStore.setting.displayCategory ? `${label};` : ''}${rootStore.setting.displayCategory && attrsLabel ? ';' : ''}${attrsLabel}`;\n        const labelGroup = this.getLabelByKey(instanceId, groupName, id);\n        if (labelGroup) {\n          this.updateLabel(instanceId, groupName, id, {\n            x,\n            y\n          }, {\n            x: x + width / 2,\n            y: y + height / 2\n          }, LandmarkEditType.RECTANGLE);\n        } else {\n          this.addLabel(label, {\n            x,\n            y,\n            width,\n            height\n          }, {\n            instanceId,\n            category,\n            groupName\n          }, id, visible, SHAPE_TYPE.RECTANGLE, attrsLabel);\n        }\n      }\n    }\n  }\n  removeRectangle(instanceId, groupName, id) {\n    const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n    if (rectangleBox) {\n      rectangleBox.removeChildren();\n      rectangleBox.remove();\n      this.removeLabel(instanceId, groupName, id);\n    }\n  }\n  selectShape(instanceId, groupName, id, selected = true) {\n    if (this.mainLayer) {\n      const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox && rectangleBox.children) {\n        const {\n          bounds: {\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            x,\n            y,\n            height,\n            width\n          }\n        } = rectangleBox.children[0];\n        const points = [topLeft, topRight, bottomRight, bottomLeft];\n        const {\n          displayColor\n        } = rectangleBox.data;\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          const radius = rootStore.setting.pointSize / 2 / zoom;\n          const newColor = new Paper.Color(displayColor || POINT_COLOR);\n          points.forEach((point, index) => {\n            const sourceSeg = new Paper.Segment(point);\n            const targetSeg = index + 1 >= points.length ? new Paper.Segment(points[0]) : new Paper.Segment(points[index + 1]);\n            const lineBar = new Paper.Path({\n              segments: [sourceSeg, targetSeg],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              fillColor: newColor,\n              strokeColor: newColor,\n              selectedColor: newColor\n            });\n            lineBar.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_PATH,\n              controlIndex: index\n            };\n            rectangleBox.addChild(lineBar);\n          });\n          points.forEach((point, index) => {\n            const control = new Paper.Shape.Circle(point, radius);\n            control.strokeColor = newColor;\n            control.strokeWidth = rootStore.setting.lineWidth / zoom;\n            control.fillColor = newColor;\n            control.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_POINT,\n              controlIndex: index,\n              displayColor\n            };\n            rectangleBox.addChild(control);\n          });\n        } else {\n          rectangleBox.removeChildren();\n          const rectangle = new Paper.Shape.Rectangle({\n            point: [x, y],\n            size: [width, height],\n            fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n            strokeWidth: rootStore.setting.lineWidth / zoom\n          });\n          rectangle.data = {\n            parentShape: id,\n            cursor: Cursor.MOVE,\n            type: SHAPE_TYPE.RECTANGLE\n          };\n          rectangleBox.addChild(rectangle);\n        }\n      }\n    }\n  }\n  drawWarnings() {\n    var _this$warningLayer2;\n    (_this$warningLayer2 = this.warningLayer) === null || _this$warningLayer2 === void 0 ? void 0 : _this$warningLayer2.removeChildren();\n    if (this.warningLayer && !!this.props.warnings.length) {\n      const strokeWitdth = rootStore.setting.lineWidth * 2 / this.paperZoom;\n      const warningIconSize = rootStore.setting.pointSize * 6 / this.paperZoom;\n      this.currentWarnings.forEach(warning => {\n        const {\n          id,\n          groupName,\n          shapeIds\n        } = warning;\n        const shapes = [];\n        shapeIds.forEach(shapeId => {\n          const shape = this.getShapeByKey(id, groupName, shapeId);\n          if (shape) {\n            shapes.push(shape);\n            if (shape.data.type !== SHAPE_TYPE.RECTANGLE_GROUP) {\n              const {\n                x,\n                y,\n                width,\n                height\n              } = shape.bounds;\n              const boundRect = new Paper.Shape.Rectangle({\n                point: [x - strokeWitdth, y - strokeWitdth],\n                size: [width + 2 * strokeWitdth, height + 2 * strokeWitdth],\n                strokeColor: new Paper.Color('#DC4624'),\n                strokeWidth: strokeWitdth\n              });\n              this.warningLayer.addChild(boundRect);\n            }\n          }\n        });\n        let position = [];\n        if (shapes.length > 1) {\n          const minXList = [];\n          const maxXList = [];\n          const minYList = [];\n          const maxYList = [];\n          shapes.forEach(({\n            bounds: {\n              x,\n              y,\n              width,\n              height\n            }\n          }) => {\n            minXList.push(x - strokeWitdth);\n            maxXList.push(x + width + strokeWitdth);\n            minYList.push(y - strokeWitdth);\n            maxYList.push(y + height + strokeWitdth);\n          });\n          const minX = Math.min(...minXList);\n          const maxX = Math.max(...maxXList);\n          const minY = Math.min(...minYList);\n          const maxY = Math.max(...maxYList);\n          const boundRect = new Paper.Shape.Rectangle({\n            point: [minX - 2 * strokeWitdth, minY - 2 * strokeWitdth],\n            size: [maxX - minX + 4 * strokeWitdth, maxY - minY + 4 * strokeWitdth],\n            strokeColor: new Paper.Color('#DC4624'),\n            strokeWidth: strokeWitdth\n          });\n          this.warningLayer.addChild(boundRect);\n          position = [minX - warningIconSize / 2, minY - warningIconSize / 2];\n        } else if (shapes.length === 1) {\n          position = [shapes[0].bounds.x - warningIconSize / 2, shapes[0].bounds.y - warningIconSize / 2];\n        }\n        if (shapes.length > 0) {\n          const warningIcon = new Paper.Shape.Circle({\n            center: new Paper.Point(position[0], position[1]),\n            radius: warningIconSize / 3,\n            fillColor: '#DC4624'\n          });\n          const text = new Paper.PointText({\n            content: '!',\n            fontSize: FONT_SIZE / this.paperZoom,\n            fontWeight: '700',\n            fillColor: 'white'\n          });\n          warningIcon.data = {\n            instanceId: id,\n            groupName,\n            shapeIds\n          };\n          text.data = {\n            instanceId: id,\n            groupName,\n            shapeIds\n          };\n          text.position.x = position[0];\n          text.position.y = position[1];\n          this.warningLayer.addChild(warningIcon);\n          this.warningLayer.addChild(text);\n        }\n      });\n    }\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.canvasContainer,\n      className: \"canvas\",\n      style: {\n        cursor: this.cursor\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2138,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: this.canvas,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2143,\n        columnNumber: 9\n      }\n    }), this.props.isReview && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"layer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2145,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tip\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2146,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2147,\n        columnNumber: 15\n      }\n    }, formatMessage('ORIGINAL_DATA')), /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2148,\n        columnNumber: 15\n      }\n    }, formatMessage('REVIEW_TIP')), /*#__PURE__*/React.createElement(Button, {\n      className: \"close\",\n      onClick: this.props.setReview,\n      size: \"small\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2149,\n        columnNumber: 15\n      }\n    }, formatMessage('REVIEW_CLOSE', {\n      values: {\n        shortcut: 'Ctrl+V'\n      }\n    })))), this.props.loading && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"loading\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2156,\n        columnNumber: 11\n      }\n    }, !this.raster && /*#__PURE__*/React.createElement(Spin, {\n      indicator: /*#__PURE__*/React.createElement(LoadingOutlined, {\n        style: {\n          fontSize: 100,\n          color: '#00bad3'\n        },\n        spin: true,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2157,\n          columnNumber: 47\n        }\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2157,\n        columnNumber: 30\n      }\n    })));\n  }\n}, _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"cursor\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return Cursor.DEFAULT;\n  }\n}), _applyDecoratedDescriptor(_class2.prototype, \"activeTool\", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, \"activeTool\"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, \"hitTest\", [_dec], Object.getOwnPropertyDescriptor(_class2.prototype, \"hitTest\"), _class2.prototype), _class2)) || _class);\nexport default Canvas;","map":{"version":3,"names":["React","observable","action","makeObservable","computed","observer","Paper","debounce","hexToRgba","imageLoader","ImageFilters","ResizeObserver","Spin","Button","LoadingOutlined","Tool","AttributesMode","rootStore","formatMessage","CategoryPathShape","LandmarkEditType","LabelStyle","Cursor","resetAttrLabelPosition","getValuesLabel","resizeLabel","computeRotatedPosition","ZOOM_MIN","ZOOM_MAX","GRID_GAP","GRID_LINE_WIDTH","FONT_SIZE","POINT_COLOR","KEY_POINT_COLOR","SHAPE_TYPE","KEYPOINT","PATH","KEYPOINT_BOX","INSTANCE","GROUP","RECTANGLE_POINT","RECTANGLE_PATH","RECTANGLE_GROUP","RECTANGLE","WARNGIN","LabelType","Canvas","_dec","bound","_class","_class2","Component","constructor","props","_initializerDefineProperty","_descriptor","canvas","createRef","canvasContainer","imageCanvas","imageData","raster","rasterLayer","gridLayer","labelLayer","attrLayer","mainLayer","warningLayer","tool","hits","selectedHit","warningBtn","selectedPoints","selectedRectangles","smoothPath","shownLabel","fillOpacity","resizeObserve","catchZoom","prevRaster","updateGroupBoxdebounced","resizeDebounced","paperZoom","currentWarnings","resize","isWindow","current","offsetWidth","viewWidth","offsetHeight","viewHeight","view","viewSize","Size","viewCenter","Point","x","y","center","zoom","width","imgWidth","height","imgHeight","viewRatio","imgRatio","scaleFactor","offsetX","offsetY","matrix","Matrix","translate","scale","project","layers","forEach","layer","position","scaling","resizeContent","resizeGrid","resizeShapes","drawWarnings","event","mousePosition","viewPosition","viewToProject","oldZoom","oldCenter","newZoom","deltaY","Math","max","min","zoomScale","offset","subtract","multiply","add","drag","fitSelected","instanceId","groupName","groupBox","getGroupContainerByGroupName","bounds","point","localToGlobal","debounceUpdateGroupBox","category","fun","cancel","updateGroupBox","clearHits","undefined","boundRect","getShapeByGroup","selectedShapeStatus","isRemovebound","groupConntainer","points","children","filter","v","type","CIRCLE","map","length","xList","yList","minX","maxX","minY","maxY","remove","range","setting","pointSize","strokeWitdth","lineWidth","Shape","Rectangle","size","strokeColor","Color","strokeWidth","data","addChild","groupInfo","ontology","getGroupData","instance","getInstance","content","class_display_name","number","display_name","name","labelGroup","getLabelByKey","addLabel","removeLabel","activeTool","_this$props$ontologyG","ontologyGroup","componentDidMount","setup","setupLayers","setupTools","addEventListener","e","preventDefault","observe","componentDidUpdate","prevProps","image","loadImage","JSON","stringify","defaultInstances","Object","values","id","_this$mainLayer","instanceContainer","Group","group","groupContainer","displayColor","updatedShapes","updateShapes","updatedCategories","pointCategory","frameIndex","currentFrame","container","categoryKey","updateCirclePath","categoryPathShapes","onCategoriesUpdated","shapeType","isShapeInSelectedShapes","setPointSelected","selectShape","setMultiShapesUnselected","selectedShapeInfo","clearSmooth","warnings","undoPointer","warning","frames","componentWillUnmount","disconnect","Layer","applyMatrix","visible","isGridVisible","onMouseMove","hitTest","activate","changeLoading","c","_canvas$getContext","getContext","getImageData","Raster","onLoad","_this$gridLayer","_this$gridLayer$child","addGrid","labelMode","orientation","crossOrigin","updateFilters","brightness","contrast","saturation","lightness","hue","rescale","filters","BrightnessContrastPhotoshop","Rescale","HSLAdjustment","setImageData","rows","ceil","Array","from","_","index","_this$gridLayer2","path","Path","Line","to","dashed","cols","_this$gridLayer3","baseWidth","dashArray","findIndex","p","isPointInImage","localPoint","globalToLocal","getPointInImage","getInstanceContainerByInstaceId","instaceId","_this$mainLayer2","find","i","g","getShapeByKey","key","_this$labelLayer","l","getAttrLabelByKey","_this$attrLayer","_this$mainLayer3","getPathByCategory","getPointsByCategory","canAddShape","isReview","readonly","review","drawMode","count","annotatedPointOrShapeCount","containerAddPoint","groupData","isKeyPoint","attributes","addKeypointShape","addKeypoint","selectedInstance","newPoint","otherPoints","handleShapesChange","shape","setNextEmptyShape","pointIndex","_groupInfo$point_labe","pointColor","pointCircle","Circle","radius","fillColor","selectedColor","cursor","MOVE","categoryData","categories","segment","Segment","lineColor","isConnect","isCircle","push","insert","splice","segments","sendToBack","smooth","fullySelected","lines","indexOf","linesData","connectPoints","color","isSource","otherEnd","line","fromTo","label","attrsLabel","point_label_config","fields","labelItems","displayPointIndex","removePointShape","containerData","removeSegment","_this$labelLayer2","_this$attrLayer2","set","fontSize","cleanLayer","_this$mainLayer$child","_container$children","removeChildren","PointText","shadowColor","shadowBlur","shadowOffset","labelRect","labelBgColor","OBJECT","labelStyle","DEFAULT","arrtLabelGroup","clone","slice","updateLabelContent","updateLabel","activePointAttributesMode","HOVER","activeAttributesMode","updateAttributeLabel","instanceNum","_groupInfo$point_labe2","pointLabelItems","_groupInfo$label_conf","categoryLabel","label_config","displayCategory","labelText","ALWAYS","updatelabelVisible","activeMode","_this$attrLayer3","labelType","updatedShape","updatePoint","updateRectangle","onShapesUpdated","updateShape","rectangle","currRectangle","removeRectangle","drawRectangle","closed","addRectangle","updatedCategorie","currPoint","currCategory","updatePath","changeVisibleStyle","HIDE","newContainer","segmentIndex","n","selected","_this$mainLayer4","setMultiShapesSelected","selectedShapes","selectGroup","setSelectedShape","sort","a","b","setMultiSelectedShape","pData","rData","updatePointsPosition","shapes","updateRectanglePosition","deleteSelectedPoints","sortedKeys","keys","pIndex1","pIndex2","handleShapesRemove","includes","deleteSelectedRectangle","rectangles","rect","toggleSelectedPointVisibility","togglePointsVisibility","_this$tool","mouseDown","_hit","isDrawPoint","POINTER","CROSSHAIR","hitTestAll","fill","handles","stroke","tolerance","match","ht","item","hit","h","ctrlKey","_hit$item$data","_hit$item$data2","_hit$item$data3","_hit$item$data4","_hit$item$data5","showShapeLabel","_this$warningLayer","_label$children","projectToView","parent","getNewPointsByKeyPointRange","startKey","endKey","startPosition","endPosition","segmentLength","getOffsetOf","newPoints","base","basePoint","baseOffset","nextPoint","getPointAt","getUpdatedPointsByNewPoints","parentData","indexs","Number","existingPoint","pointInfo","autoAdjust","categoryName","prevKeyPointIndex","nextKeyPointIndex","keysWithTwoSides","keyIndex","switchSmoothMode","keyPoints","k","seg","clearHandles","setCategoryAsCircle","setCategoryPathShape","isCirclePath","getCategoryData","categoryPoints","point1","point2","centerX","centerY","sqrt","newPath","CompoundPath","PI","replaceWith","update","start","end","radians","rectData","getAlphaColor","opacity","_this$mainLayer5","rectangleBox","parentShape","_instance$children$fi","_groupInfo$label_conf2","topLeft","topRight","bottomRight","bottomLeft","newColor","sourceSeg","targetSeg","lineBar","NS_RESIZE","EW_RESIZE","controlIndex","control","NWSE_RESIZE","NESW_RESIZE","_this$warningLayer2","warningIconSize","shapeIds","shapeId","minXList","maxXList","minYList","maxYList","warningIcon","text","fontWeight","render","createElement","ref","className","style","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","onClick","setReview","shortcut","loading","indicator","spin","_applyDecoratedDescriptor","prototype","configurable","enumerable","writable","initializer","getOwnPropertyDescriptor"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/components/Canvas.tsx"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable, computed } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport { debounce } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { Spin, Button } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool, { ToolEventExtend, ToolProps } from '../tools/Tool';\nimport { OntologyChild } from '../store/OntologyStore';\nimport { AttributesMode } from '../store/SettingsStore';\nimport rootStore from '../store/RootStore';\nimport formatMessage from '../locales';\nimport {\n  Point, PointStatus, CategoryItem, CategoryPathShape,\n  Group, LandmarkEditType, ShapeInfo, GroupInfo, InstanceAct,\n  PointInfo, UpdatedShape, Rectangle, KeypointCategoryProps,\n  LabelStyle\n} from '../types';\nimport Cursor from '../../common/Cursor';\nimport { resetAttrLabelPosition, getValuesLabel, resizeLabel } from '../utils';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport { IWarning } from '../../common/tabs-menu/Validator';\nimport './Canvas.scss';\n\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 12;\nexport const POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  KEYPOINT: 'keypoint',\n  PATH: 'path',\n  KEYPOINT_BOX: 'keypoint_box',\n  INSTANCE: 'instance',\n  GROUP: 'group',\n  RECTANGLE_POINT: 'rectangle_point',\n  RECTANGLE_PATH: 'rectangle_path',\n  RECTANGLE_GROUP: 'rectangle_group',\n  RECTANGLE: 'rectangle',\n  WARNGIN: 'warning'\n};\n\nenum LabelType {\n  KEYPOINT='keypoint',\n  OBJECT='object'\n}\n\ninterface Props {\n  image: string;\n  readonly: boolean;\n  loading: boolean;\n  currentFrame: number;\n  isReview: boolean;\n  categories: CategoryItem[];\n  updatedShapes: UpdatedShape[];\n  updatedCategories: KeypointCategoryProps[];\n  defaultInstances: {[id: string]: InstanceAct};\n  selectedInstance?: InstanceAct;\n  selectedGroupName?: string;\n  ontologyGroup?: OntologyChild;\n  annotatedPointOrShapeCount: number;\n  selectedShapeStatus: ShapeInfo;\n  selectedShapeInfo: PointInfo | GroupInfo | null;\n  categoryPathShapes: {[categoryName: string]: CategoryPathShape};\n  warnings: IWarning[];\n  undoPointer: number;\n  changeLoading: (loading: boolean) => void;\n  selectGroup: (groupId: string, name: string, isFit?: boolean) => void;\n  setSelectedShape: (selectedIndex?: number | string, data?: Group) => void;\n  setMultiSelectedShape: (selectedIds: number[] | string[]) => void;\n  handleShapesChange: (shape: UpdatedShape[]) => void;\n  handleShapesRemove: (shape: UpdatedShape[]) => void;\n  togglePointsVisibility: (points: PointStatus[]) => void;\n  setNextEmptyShape: () => void;\n  onShapesUpdated: () => void;\n  onCategoriesUpdated: () => void;\n  editShapeForm: () => void;\n  editGroupForm: () => void;\n  onSave: () => void;\n  setCategoryPathShape: (categoryName: string, type?: CategoryPathShape, updatedShapes?: UpdatedShape[]) => void;\n  getInstance: (id: string) => InstanceAct | undefined;\n  handleUndo: () => void;\n  handleRedo: () => void;\n  setReview: () => void;\n  handleChangeDrawMode: (mode: boolean) => void;\n}\n\n@observer\nclass Canvas extends React.Component<Props> {\n  @observable cursor = Cursor.DEFAULT;\n\n  canvas: React.RefObject<HTMLCanvasElement> = React.createRef();\n\n  canvasContainer: React.RefObject<HTMLDivElement> = React.createRef();\n\n  imageCanvas: HTMLCanvasElement | undefined;\n\n  imageData: ImageData | undefined;\n\n  raster: paper.Raster | undefined;\n\n  rasterLayer: paper.Layer | undefined;\n\n  gridLayer: paper.Layer | undefined;\n\n  labelLayer: paper.Layer | undefined;\n\n  attrLayer: paper.Layer | undefined;\n\n  mainLayer: paper.Layer | undefined;\n\n  warningLayer: paper.Layer | undefined;\n\n  tool: ToolProps | undefined;\n\n  hits: paper.HitResult | undefined;\n\n  selectedHit: paper.Item | undefined;\n\n  warningBtn: paper.HitResult | undefined;\n\n  selectedPoints: paper.Shape[] = [];\n\n  selectedRectangles: paper.Group[] = [];\n\n  smoothPath: paper.Path | null = null;\n\n  shownLabel: paper.Group | null = null;\n\n  fillOpacity = 0.3;\n\n  resizeObserve: ResizeObserver | null = null;\n\n  catchZoom: { zoom: number, center: paper.Point } | undefined;\n\n  prevRaster: paper.Raster | null = null;\n\n  updateGroupBoxdebounced: any;\n\n  resizeDebounced: any;\n\n  paperZoom = 1;\n\n  currentWarnings: IWarning[] = [];\n\n  constructor(props: Props) {\n    super(props);\n    makeObservable(this);\n  }\n\n  @computed get activeTool() {\n    let tool = '';\n    switch (this.props.ontologyGroup?.type) {\n      case LandmarkEditType.KEYPOINT:\n        tool = CategoryPathShape.CIRCLE;\n        break;\n      case LandmarkEditType.RECTANGLE:\n        tool = CategoryPathShape.RECTANGLE;\n        break;\n      default:\n        break;\n    }\n    return tool;\n  }\n\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', (e) => e.preventDefault(), false);\n    }\n    if (this.canvasContainer.current) {\n      this.resizeObserve = new ResizeObserver(() => { this.resize(true); });\n      this.resizeObserve.observe(this.canvasContainer.current);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.image !== this.props.image) {\n      this.loadImage();\n    }\n\n    // default instances\n    if (JSON.stringify(prevProps.defaultInstances) !== JSON.stringify(this.props.defaultInstances)) {\n      const defaultInstances = Object.values(this.props.defaultInstances).filter((instance) => instance && !prevProps.defaultInstances[instance.id]);\n      if (defaultInstances.length > 0) {\n        defaultInstances.forEach((instance) => {\n          const instanceContainer = new Paper.Group();\n          this.mainLayer?.addChild(instanceContainer);\n          instanceContainer.data = {\n            instanceId: instance.id,\n            category: instance.category,\n            type: SHAPE_TYPE.INSTANCE,\n          };\n          instance.children.forEach((group) => {\n            const groupContainer = new Paper.Group();\n            groupContainer.data = {\n              groupName: group.name,\n              type: SHAPE_TYPE.GROUP,\n              instanceId: instance.id,\n              category: instance.category,\n              displayColor: instance.displayColor || POINT_COLOR,\n            };\n            instanceContainer.addChild(groupContainer);\n          });\n        });\n      }\n    }\n\n    // change frame & undo & redo to update points\n    if (\n      JSON.stringify(prevProps.updatedShapes) !== JSON.stringify(this.props.updatedShapes) &&\n      this.props.updatedShapes.length > 0\n    ) {\n      this.updateShapes();\n    }\n    if (\n      JSON.stringify(prevProps.updatedCategories) !== JSON.stringify(this.props.updatedCategories) &&\n      this.props.updatedCategories.length > 0\n    ) {\n      this.props.updatedCategories.forEach(({ pointCategory, frameIndex, instanceId, groupName, category }) => {\n        if (frameIndex === this.props.currentFrame) {\n          const container = { instanceId, groupName, category };\n          const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n        }\n      });\n      this.props.onCategoriesUpdated();\n    }\n\n    // selected changes\n    if (JSON.stringify(prevProps.selectedShapeStatus) !== JSON.stringify(this.props.selectedShapeStatus)) {\n      if (this.selectedPoints.length <= 0 || this.selectedRectangles.length <= 0) {\n        if (prevProps.selectedShapeStatus && prevProps.selectedShapeStatus.id !== undefined) {\n          const { instanceId, groupName, id, shapeType } = prevProps.selectedShapeStatus;\n          if (!this.isShapeInSelectedShapes(instanceId, groupName, id)) {\n            if (shapeType === LandmarkEditType.KEYPOINT) {\n              this.setPointSelected(instanceId, groupName, id as number, false);\n            } else {\n              this.selectShape(instanceId, groupName, id as string, false);\n            }\n          }\n        }\n      }\n      const { instanceId, category, groupName, id, shapeType } = this.props.selectedShapeStatus;\n      if (id !== undefined) {\n        this.setMultiShapesUnselected();\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          this.setPointSelected(instanceId, groupName, id as number, true);\n        } else {\n          this.selectShape(instanceId, groupName, id as string);\n        }\n      }\n      if (\n        prevProps.selectedShapeStatus.instanceId !== instanceId ||\n        prevProps.selectedShapeStatus.groupName !== groupName\n      ) {\n        this.updateGroupBox(instanceId, category, groupName);\n      }\n    }\n    if ((prevProps.selectedShapeInfo as PointInfo || {}).pointCategory !== (this.props.selectedShapeInfo as PointInfo || {}).pointCategory) {\n      this.clearSmooth();\n    }\n    if (\n      JSON.stringify(prevProps.warnings) !== JSON.stringify(this.props.warnings) ||\n      prevProps.undoPointer !== this.props.undoPointer ||\n      this.props.updatedShapes.length > 0\n    ) {\n      this.currentWarnings = this.props.warnings.filter((warning) => warning.frames[0] === this.props.currentFrame);\n      this.drawWarnings();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.resizeObserve) {\n      this.resizeObserve.disconnect();\n      this.resizeObserve = null;\n    }\n  }\n\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = true;\n\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = rootStore.setting.isGridVisible;\n\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n\n    this.attrLayer = new Paper.Layer();\n    this.attrLayer.applyMatrix = false;\n    this.attrLayer.visible = false;\n\n    this.warningLayer = new Paper.Layer();\n    this.warningLayer.applyMatrix = false;\n    this.warningLayer.visible = false;\n\n    Paper.view.onMouseMove = this.hitTest;\n  }\n\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n\n  loadImage() {\n    if (this.rasterLayer && this.props.image) {\n      this.rasterLayer.activate();\n      this.props.changeLoading(true);\n      if (this.raster) {\n        this.prevRaster = this.raster;\n      }\n      imageLoader(this.props.image, (c) => {\n        const canvas = c as HTMLCanvasElement;\n        this.imageCanvas = canvas;\n        this.imageData = canvas.getContext('2d')?.getImageData(0, 0, canvas.width, canvas.height);\n\n        this.raster = new Paper.Raster(this.props.image);\n        this.raster!.visible = false;\n        this.raster!.onLoad = () => {\n          this.resize(); // resize to fit the container\n          if (!this.gridLayer?.children?.length) {\n            this.addGrid(); // add grid to image\n            this.labelLayer!.visible = rootStore.setting.labelMode;\n            this.mainLayer!.visible = true;\n            this.warningLayer!.visible = true;\n            this.attrLayer!.visible = true;\n          }\n          // when onload, show all layers\n          this.raster!.visible = true;\n          if (this.prevRaster) {\n            this.prevRaster.remove();\n          }\n          this.props.changeLoading(false);\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous',\n      });\n    }\n  }\n\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const { brightness, contrast, saturation, lightness, hue, rescale } = rootStore.setting.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n\n  resize = (isWindow = false) => {\n    if (this.canvasContainer.current) {\n      // set view size\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n      const viewCenter = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      if (this.catchZoom) {\n        const { center, zoom } = this.catchZoom;\n        if (isWindow) {\n          Paper.view.center = viewCenter;\n          this.catchZoom.center = viewCenter;\n        } else {\n          Paper.view.center = center;\n        }\n        Paper.view.zoom = zoom;\n      } else {\n        Paper.view.center = viewCenter;\n        Paper.view.zoom = 1;\n      }\n\n      if (this.imageCanvas && this.raster) {\n        // resize image\n        const { width: imgWidth, height: imgHeight } = this.imageCanvas;\n        const viewRatio = viewWidth / viewHeight;\n        const imgRatio = imgWidth / imgHeight;\n        const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n        const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n        const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n        const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n        // apply matrix to all layers\n        Paper.project.layers.forEach((layer) => {\n          layer.matrix = matrix;\n        });\n        // reset image center\n        this.raster.position = new Paper.Point({ x: imgWidth / 2, y: imgHeight / 2 });\n        this.paperZoom = this.rasterLayer ? Paper.view.zoom * this.rasterLayer.matrix.scaling.x : Paper.view.zoom;\n      }\n      this.resizeContent();\n    }\n  };\n\n  resizeContent = () => {\n    if (this.resizeDebounced) {\n      this.resizeDebounced();\n    } else {\n      this.resizeDebounced = debounce(() => {\n        this.resizeGrid();\n        this.resizeShapes();\n        this.drawWarnings();\n      }, 50);\n    }\n  };\n\n  zoom = (event: WheelEvent, zoom?: number) => {\n    if (this.canvasContainer.current) {\n      const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n      const viewPosition = Paper.view.viewToProject(mousePosition);\n      const oldZoom = Paper.view.zoom;\n      const oldCenter = Paper.view.center;\n\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      let newZoom = event && event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n      newZoom = zoom || newZoom;\n      if (newZoom <= 1) {\n        Paper.view.center = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      }\n      newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n      if (newZoom !== Paper.view.zoom) {\n        Paper.view.zoom = newZoom;\n        const zoomScale = oldZoom / newZoom;\n        const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n        Paper.view.center = Paper.view.center.add(offset);\n      }\n      this.catchZoom = { zoom: newZoom, center: Paper.view.center };\n      this.paperZoom = newZoom * this.rasterLayer!.matrix.scaling.x;\n      this.resizeContent();\n    }\n  };\n\n  drag = (center: paper.Point) => {\n    this.catchZoom = this.catchZoom ? {\n      ...this.catchZoom,\n      center,\n    } : {\n      zoom: Paper.view.zoom,\n      center\n    };\n  };\n\n  fitSelected = (instanceId: string, groupName: string) => {\n    const groupBox = this.getGroupContainerByGroupName(instanceId, groupName);\n    if (groupBox && this.mainLayer && this.canvasContainer.current) {\n      const { center, width, height } = groupBox.bounds;\n      if (width === 0 || height === 0) return;\n      const point = this.mainLayer.localToGlobal(center);\n      const { width: viewWidth, height: viewHeight } = this.mainLayer.bounds;\n\n      let zoom = width / height > viewWidth / viewHeight ? viewWidth / width : viewHeight / height;\n      zoom = Math.min(18, Math.max(zoom, 1));\n      Paper.view.zoom = zoom;\n      Paper.view.center = point;\n      this.catchZoom = { zoom, center: point };\n      this.paperZoom = this.rasterLayer ? zoom * this.rasterLayer.matrix.scaling.x : zoom;\n      this.resizeContent();\n    } else {\n      this.resize();\n    }\n  };\n\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      const { width, height } = this.imageCanvas;\n\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({ length: rows }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({ length: cols }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n    }\n  }\n\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach((path) => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n\n  isShapeInSelectedShapes(instanceId: string, groupName: string, index: number | string | undefined) {\n    return this.selectedPoints.findIndex((p) => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0 ||\n    this.selectedRectangles.findIndex((p) => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0;\n  }\n\n  isPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const { bounds: { x, y, width, height } } = this.rasterLayer;\n    return localPoint.x >= 0 && localPoint.x <= (x + width) && localPoint.y >= 0 && localPoint.y <= (y + height);\n  }\n\n  getPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n\n    if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n\n  getInstanceContainerByInstaceId(instaceId: string) {\n    return this.mainLayer?.children.find((i) => i.data.type === SHAPE_TYPE.INSTANCE && i.data.instanceId === instaceId) as paper.Group;\n  }\n\n  getGroupContainerByGroupName(instaceId: string, groupName: string) {\n    const instance = this.getInstanceContainerByInstaceId(instaceId);\n    return instance?.children.find((g) => g.data.type === SHAPE_TYPE.GROUP && g.data.groupName === groupName) as paper.Group;\n  }\n\n  getShapeByKey(instaceId: string, groupName: string, key: string | number) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => (p.data.type === SHAPE_TYPE.RECTANGLE_GROUP && p.data.id === key) ||\n      (p.data.type === SHAPE_TYPE.KEYPOINT && p.data.index === key)) as paper.Group | paper.Shape;\n  }\n\n  getLabelByKey(instanceId: string, groupName: string, key: number | string) {\n    return this.labelLayer?.children.find((l) => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === key) as paper.Group;\n  }\n\n  getAttrLabelByKey(instanceId: string, groupName: string, key: number | string) {\n    return this.attrLayer?.children.find((l) => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === `attr-${key}`) as paper.Group;\n  }\n\n  getShapeByGroup() {\n    return this.mainLayer?.children.find((l) => l.data.type === SHAPE_TYPE.KEYPOINT_BOX);\n  }\n\n  getPathByCategory(instaceId: string, groupName: string, pointCategory: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => p.data.type === SHAPE_TYPE.PATH && p.data.pointCategory === pointCategory) as paper.Path;\n  }\n\n  getPointsByCategory(instaceId: string, groupName: string, pointCategory: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.filter((p) => p.data.type === SHAPE_TYPE.KEYPOINT && p.data.pointCategory === pointCategory);\n  }\n\n  canAddShape() {\n    if (this.props.isReview || this.props.readonly || !rootStore.review.drawMode) return false;\n    if (this.mainLayer && this.props.selectedShapeInfo) {\n      if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.RECTANGLE) {\n        if (this.props.ontologyGroup && this.props.ontologyGroup.count > 0) {\n          return this.props.annotatedPointOrShapeCount < this.props.ontologyGroup.count;\n        }\n      } else if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.KEYPOINT) {\n        const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n        if (id === undefined || id < 0) return false;\n        const point = this.getShapeByKey(instanceId, groupName, id as number);\n        return !point;\n      }\n    }\n    return false;\n  }\n\n  containerAddPoint(groupData: GroupInfo, point: paper.Point, pointCategory: string, index: number, isKeyPoint: boolean, visible = true, attributes?: any) {\n    const { instanceId, groupName } = groupData;\n    const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n    this.addKeypointShape(point, pointCategory, index, isKeyPoint, groupContainer, visible, attributes);\n  };\n\n  addKeypoint(point: paper.Point) {\n    if (this.mainLayer && this.props.selectedShapeInfo && this.props.selectedShapeStatus && this.props.selectedInstance) {\n      const { id, shapeType, frameIndex } = this.props.selectedShapeStatus;\n      const index = (shapeType === LandmarkEditType.KEYPOINT && id as number) || 0;\n      const { x, y } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const { instanceId, category, groupName, pointCategory, isKeyPoint } = this.props.selectedShapeInfo as PointInfo;\n\n      const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n      const groupData = { instanceId, groupName, type: LandmarkEditType.KEYPOINT, category: this.props.selectedInstance.category };\n      this.containerAddPoint(groupData, newPoint, pointCategory, index, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n        const container: Group = { instanceId, category, groupName };\n        otherPoints = this.updateCirclePath(pointCategory, true, container);\n      }\n      this.props.handleShapesChange([{\n        frameIndex,\n        instanceId,\n        category,\n        groupName,\n        index,\n        shapeType: LandmarkEditType.KEYPOINT,\n        shape: {\n          pointCategory,\n          isKeyPoint,\n          position: { x, y },\n          visible: true, // default is visible when point added\n        },\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyShape(); // move next\n    }\n  }\n\n  addKeypointShape(point: paper.Point, pointCategory: string, pointIndex: number, isKeyPoint: boolean, groupContainer: paper.Group, visible: boolean, attributes?: any) {\n    if (!groupContainer) return;\n    const { instanceId, groupName, category } = groupContainer.data;\n    if (this.mainLayer) {\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: (rootStore.setting.pointSize + 1) / zoom,\n        fillColor: visible ? pointColor : '#3d424d',\n        strokeColor: '#ffffff',\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white',\n      });\n      pointCircle.data = {\n        frameIndex: this.props.selectedShapeStatus.frameIndex,\n        type: SHAPE_TYPE.KEYPOINT,\n        cursor: Cursor.MOVE,\n        pointCategory,\n        index: pointIndex,\n        isKeyPoint,\n        visible,\n        instanceId,\n        groupName,\n        category,\n      };\n      groupContainer.addChild(pointCircle);\n\n      // add point to path\n      const groupData = rootStore.ontology.getGroupData(category, groupName);\n      const categoryData = (groupData && groupData.categories && groupData.categories.find((v) => v.name === pointCategory)) || undefined;\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      const lineColor = categoryData?.isConnect === false ?\n        new Paper.Color('rgba(0,0,0,0)') :\n        new Paper.Color(categoryData?.displayColor || POINT_COLOR);\n      let index = 0;\n      if (path) {\n        if (!path.data.isCircle) {\n          index = path.data.points.findIndex((p: number) => pointIndex < p);\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: rootStore.setting.lineWidth / zoom,\n          strokeColor: lineColor,\n          selectedColor: lineColor,\n        });\n        path.data.type = SHAPE_TYPE.PATH;\n        path.data.pointCategory = pointCategory;\n        path.data.points = [pointIndex];\n        path.data.instanceId = groupContainer.data.instanceId;\n        path.data.groupName = groupContainer.data.groupName;\n        groupContainer.addChild(path);\n      }\n      path.sendToBack();\n\n      if (path === this.smoothPath) {\n        path.smooth({ from: index - 1, to: index + 1, type: 'continuous' });\n        path.fullySelected = true;\n      }\n      if (groupData && groupData.lines) {\n        const lines = groupData.lines.filter((v) => v.points.indexOf(pointIndex) >= 0);\n        const linesData: {isSource: boolean, fromTo: string}[] = [];\n        lines.forEach((connectPoints) => {\n          if (connectPoints) {\n            const { points, color } = connectPoints;\n            const isSource = pointIndex === points[0];\n            const otherEnd = this.getShapeByKey(instanceId, groupName, isSource ? points[1] : points[0]);\n            if (otherEnd) {\n              const segments = isSource ? [segment, otherEnd.position] : [otherEnd.position, segment];\n              const line = new Paper.Path({\n                segments,\n                strokeWidth: rootStore.setting.lineWidth / zoom,\n                strokeColor: color,\n                selectedColor: color,\n              });\n              line.data.type = SHAPE_TYPE.PATH;\n              line.data.pointCategory = `${points[0]}-${points[1]}`;\n              line.data.points = points;\n              line.data.instanceId = groupContainer.data.instanceId;\n              line.data.groupName = groupContainer.data.groupName;\n              groupContainer.addChild(line);\n            }\n            linesData.push({\n              isSource,\n              fromTo: `${points[0]}-${points[1]}`\n            });\n          }\n        });\n        pointCircle.data.lines = linesData;\n      }\n      this.debounceUpdateGroupBox(instanceId, category, groupName);\n      const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n      const label = `${visible ? 1 : 0}-${pointIndex}`;\n      let attrsLabel = getValuesLabel(groupInfo?.point_label_config?.fields, attributes, rootStore.setting.labelItems);\n      attrsLabel = `${rootStore.setting.displayPointIndex ? `${pointIndex}` : ''}${rootStore.setting.displayPointIndex && attrsLabel ? ';' : ''}${attrsLabel}`;\n\n      this.addLabel(\n        label,\n        { x: point.x, y: point.y, width: rootStore.setting.pointSize / zoom, height: rootStore.setting.pointSize / zoom },\n        { instanceId, category, groupName },\n        pointIndex,\n        visible,\n        SHAPE_TYPE.KEYPOINT,\n        attrsLabel\n      );\n    }\n  }\n\n  debounceUpdateGroupBox = (instanceId: string, category: string, groupName: string) => {\n    if (\n      this.updateGroupBoxdebounced &&\n      this.updateGroupBoxdebounced.instanceId === instanceId &&\n      this.updateGroupBoxdebounced.category === category &&\n      this.updateGroupBoxdebounced.groupName === groupName\n    ) {\n      this.updateGroupBoxdebounced.fun();\n    } else {\n      if (this.updateGroupBoxdebounced) {\n        this.updateGroupBoxdebounced.fun.cancel();\n      }\n      this.updateGroupBoxdebounced = {\n        instanceId,\n        category,\n        groupName,\n        fun: debounce(() => { this.updateGroupBox(instanceId, category, groupName); }, 200)\n      };\n    }\n  };\n\n  removePointShape(containerData: Group, pointIndex: number) {\n    const { instanceId, category, groupName } = containerData;\n    if (this.mainLayer) {\n      const point = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (point) {\n        const { lines, pointCategory } = point.data;\n        point.remove();\n        // remove pointCategory path\n        const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n        if (path && !path.data.isCircle) {\n          const index = path.data.points.findIndex((p: number) => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n        // remove group connect path\n        if (lines) {\n          (lines as { isSource: boolean, fromTo: string }[]).forEach(({ fromTo }) => {\n            const line = this.getPathByCategory(instanceId, groupName, fromTo);\n            if (line) {\n              line.remove();\n            }\n          });\n        }\n      }\n      this.updateGroupBox(instanceId, category, groupName);\n    }\n    this.removeLabel(instanceId, groupName, pointIndex);\n  }\n\n  resizeShapes() {\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      this.mainLayer.children.forEach((instance) => {\n        if (instance.children && instance.children.length > 0) {\n          instance.children.forEach((group) => {\n            if (group.children) {\n              group.children.forEach((path) => {\n                if (path.data.type === SHAPE_TYPE.KEYPOINT) {\n                  path.set({ radius: rootStore.setting.pointSize / this.paperZoom });\n                  path.strokeWidth = 1 / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.PATH) {\n                  path.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.RECTANGLE_GROUP && path.children) {\n                  path.children.forEach((shape) => {\n                    if (shape.data.type === SHAPE_TYPE.RECTANGLE_POINT) {\n                      shape.set({ radius: (rootStore.setting.pointSize / 2) / this.paperZoom });\n                    } else if (shape.data.type === SHAPE_TYPE.RECTANGLE_PATH) {\n                      shape.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                    }\n                  });\n                }\n              });\n            }\n          });\n        } else if (instance.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          instance.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n        }\n      });\n    }\n    if (this.labelLayer?.children && this.labelLayer.children.length > 0) {\n      this.labelLayer.children.forEach((label) => {\n        const { zoom: oldZoom, width, height, point } = label.data;\n        resizeLabel({ width, height, zoom: this.paperZoom, fontSize: FONT_SIZE }, oldZoom, point, label, 'label');\n      });\n    }\n\n    if (this.attrLayer?.children && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach((label) => {\n        const { zoom: oldZoom, width, height, point } = label.data;\n        resizeLabel({ width, height, zoom: this.paperZoom, fontSize: FONT_SIZE }, oldZoom, point, label, 'attr');\n      });\n    }\n    const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n    this.setPointSelected(instanceId, groupName, id as number, true);\n  }\n\n  cleanLayer() {\n    if (this.mainLayer) {\n      this.mainLayer.children?.forEach((container) => {\n        if (container.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          container.remove();\n        } else {\n          container.children?.forEach((group) => {\n            group?.removeChildren();\n          });\n        }\n      });\n    }\n    if (this.labelLayer) {\n      this.labelLayer.removeChildren();\n    }\n\n    if (this.attrLayer) {\n      this.attrLayer.removeChildren();\n    }\n\n    if (this.warningLayer) {\n      this.warningLayer.removeChildren();\n    }\n  }\n\n  addLabel(content: string, shape: {x: number, y: number, width: number, height: number}, groupInfo: Group, key: number | string, visible: boolean, shapeType: string, attrsLabel?: string) {\n    if (this.labelLayer) {\n      const { instanceId, groupName } = groupInfo;\n      const fontSize = FONT_SIZE / this.paperZoom;\n      const label = new Paper.PointText({\n        content,\n        fontSize,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#000000',\n        shadowBlur: 2 / this.paperZoom,\n        shadowOffset: 2 / this.paperZoom,\n      });\n      const width = label.bounds.width + fontSize / 2;\n      const height = label.bounds.height + fontSize / 2;\n      const labelRect = new Paper.Shape.Rectangle({\n        size: [width, height],\n        fillColor: rootStore.setting.labelBgColor,\n      });\n      label.position.x = labelRect.bounds.width / 2;\n      label.position.y = labelRect.bounds.height / 2;\n\n      const labelGroup = new Paper.Group();\n      labelGroup.data = {\n        point: [shape.x, shape.y],\n        instanceId,\n        groupName,\n        key,\n        type: shapeType === SHAPE_TYPE.KEYPOINT ? LabelType.KEYPOINT : LabelType.OBJECT,\n        zoom: this.paperZoom,\n        height,\n        width\n      };\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        labelGroup.addChild(labelRect);\n      }\n      labelGroup.addChild(label);\n      this.labelLayer.addChild(labelGroup);\n      labelGroup.position.x = shape.x + labelRect.bounds.width / 2;\n      labelGroup.position.y = shape.y - labelRect.bounds.height / 2 - rootStore.setting.lineWidth / this.paperZoom;\n\n      if (shapeType !== SHAPE_TYPE.KEYPOINT_BOX && this.attrLayer) {\n        let center = { x: shape.x, y: shape.y };\n\n        if (SHAPE_TYPE.RECTANGLE) {\n          center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 };\n        }\n        const arrtLabelGroup = labelGroup.clone();\n        arrtLabelGroup.data.key = `attr-${arrtLabelGroup.data.key}`;\n        arrtLabelGroup.data.point = [center.x, center.y];\n        arrtLabelGroup.children.slice(-1)[0].fillColor = new Paper.Color('#ffffff');\n        (arrtLabelGroup.children.slice(-1)[0] as paper.PointText).content = '';\n        this.attrLayer.addChild(arrtLabelGroup);\n        if (attrsLabel) {\n          this.updateLabelContent(arrtLabelGroup, attrsLabel, shapeType);\n        } else {\n          arrtLabelGroup.visible = false;\n        }\n      }\n    }\n  }\n\n  updateLabel(instanceId: string, groupName: string, key: number | string, position: { x: number, y: number }, center: { x: number, y: number }, type: LandmarkEditType) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [position.x, position.y];\n        label.position.x = position.x + label.bounds.width / 2;\n        label.position.y = position.y - label.bounds.height / 2;\n      }\n    }\n    if (this.attrLayer) {\n      if (type === LandmarkEditType.KEYPOINT) {\n        if (rootStore.setting.activePointAttributesMode === AttributesMode.HOVER) return;\n      } else if (rootStore.setting.activeAttributesMode === AttributesMode.HOVER) {\n        return;\n      }\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [center.x, center.y];\n        label.position.x = center.x;\n        label.position.y = center.y;\n      }\n    }\n  }\n\n  updateAttributeLabel(instanceId: string, category: string, groupName: string, key: number | string, attributes: any, instanceNum?: number) {\n    const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n    let label = '';\n    if (typeof key === 'number') {\n      label = getValuesLabel(groupInfo?.point_label_config?.fields, attributes, rootStore.setting.pointLabelItems);\n      label = `${rootStore.setting.displayPointIndex ? `${key}` : ''}${rootStore.setting.displayPointIndex && label ? ';' : ''}${label}`;\n    } else {\n      const categoryLabel = `${groupInfo?.class_display_name || ''}  ${instanceNum || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n      label = getValuesLabel(groupInfo?.label_config?.fields, attributes, rootStore.setting.labelItems);\n      label = `${rootStore.setting.displayCategory ? `${categoryLabel}` : ''}${rootStore.setting.displayCategory && label ? ';' : ''}${label}`;\n    }\n    const attrLayer = this.getAttrLabelByKey(instanceId, groupName, key);\n    if (attrLayer) {\n      if (label) {\n        this.updateLabelContent(attrLayer, label, SHAPE_TYPE.KEYPOINT);\n      } else {\n        attrLayer.visible = false;\n      }\n    }\n  }\n\n  updateLabelContent(label: paper.Group, content: string, shapeType: string) {\n    if (this.attrLayer && label) {\n      const zoom = Paper.view.zoom * this.attrLayer.matrix.scaling.x;\n      const labelText = label.children.slice(-1)[0];\n      (labelText as paper.PointText).content = content;\n      const { width, height } = labelText.bounds;\n      const fontSize = FONT_SIZE / zoom;\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        (label.children[0] as paper.Shape).size.height = height + fontSize / 2;\n        (label.children[0] as paper.Shape).size.width = width + fontSize / 2;\n      }\n      label.data.width = label.children[0].bounds.width;\n      label.data.height = label.children[0].bounds.height;\n      label.data.zoom = this.paperZoom;\n\n      let visible = false;\n      if (shapeType === SHAPE_TYPE.KEYPOINT) {\n        visible = rootStore.setting.activePointAttributesMode === AttributesMode.ALWAYS;\n      } else if (SHAPE_TYPE.RECTANGLE) {\n        visible = rootStore.setting.activeAttributesMode === AttributesMode.ALWAYS;\n      }\n      if (visible) {\n        const { point } = label.data;\n        resetAttrLabelPosition(label, { x: point[0], y: point[1] }, visible);\n      } else {\n        label.visible = false;\n      }\n    }\n  }\n\n  updatelabelVisible(activeMode: AttributesMode, type = 'object') {\n    if (this.shownLabel) {\n      this.shownLabel.visible = false;\n      this.shownLabel = null;\n    }\n    if (this.attrLayer?.children && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach((label) => {\n        const { type: labelType } = label.data;\n        if (type === labelType) {\n          label.visible = activeMode === AttributesMode.ALWAYS;\n        }\n      });\n    }\n  }\n\n  removeLabel(instanceId: string, groupName: string, key: string | number) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n\n  updateShapes() {\n    this.props.updatedShapes.forEach((updatedShape) => {\n      if (updatedShape.frameIndex !== this.props.currentFrame) return;\n      switch (updatedShape.shapeType) {\n        case LandmarkEditType.KEYPOINT:\n          this.updatePoint(updatedShape);\n          break;\n        case LandmarkEditType.RECTANGLE:\n          this.updateRectangle(updatedShape);\n          break;\n        default:\n          break;\n      }\n    });\n    this.props.onShapesUpdated();\n  }\n\n  updateRectangle(updateShape: UpdatedShape) {\n    const { instanceId, groupName, category, id, shape } = updateShape;\n    if (id !== undefined) {\n      const rectangle = shape as Rectangle;\n      const currRectangle = this.getShapeByKey(instanceId, groupName, id);\n      if (currRectangle) {\n        // alreay exist, should update\n        if (rectangle === undefined) {\n          // delete\n          this.removeRectangle(instanceId, groupName, id);\n        } else if (rectangle.x) {\n          const { x, y, width, height, displayColor } = rectangle;\n          // update position\n          this.drawRectangle({ x, y, width, height, displayColor }, { instanceId, category, groupName }, id);\n        }\n      } else if (rectangle) {\n        //  has been removed, should add\n        const { x, y, width, height, displayColor } = rectangle;\n        const path = new Paper.Path();\n        path.data.id = id;\n        path.add(new Paper.Point(x, y));\n        path.add(new Paper.Point(x + width, y));\n        path.add(new Paper.Point(x + width, y + height));\n        path.add(new Paper.Point(x, y + height));\n        path.closed = true;\n        this.addRectangle(path, { instanceId, groupName, category, shapeType: LandmarkEditType.RECTANGLE, displayColor }, false);\n      }\n    }\n  }\n\n  updatePoint(updateShape: UpdatedShape) {\n    const { frameIndex, instanceId, groupName, category, index, shape } = updateShape;\n    if (index !== undefined) {\n      let updatedCategorie: KeypointCategoryProps | undefined;\n      const point = shape as Point;\n      const currPoint = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      if (currPoint) {\n        const currCategory = currPoint.data.pointCategory;\n        updatedCategorie = { pointCategory: currCategory, frameIndex, instanceId, groupName, category };\n        const groupData = { frameIndex, instanceId, category, groupName };\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(groupData, index);\n        } else if (point.position && point.pointCategory) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          this.updatePath(currPoint, point.position);\n          // update visible\n          if (point.visible !== undefined && currPoint.data.visible !== point.visible) {\n            this.changeVisibleStyle(currPoint, index, groupData, point.visible);\n          }\n          if (rootStore.setting.activePointAttributesMode !== AttributesMode.HIDE) {\n            this.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n          this.debounceUpdateGroupBox(instanceId, category, groupName);\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const { position, pointCategory, isKeyPoint, visible, attributes } = point;\n        if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          updatedCategorie = { pointCategory, frameIndex, instanceId, groupName, category };\n          const groupData = { instanceId, groupName, type: LandmarkEditType.KEYPOINT, category };\n          this.containerAddPoint(groupData, new Paper.Point(position.x, position.y), pointCategory, index, isKeyPoint, visible, attributes);\n        }\n      }\n      if (updatedCategorie) {\n        const { pointCategory, ...newContainer } = updatedCategorie;\n        const categoryKey = `${frameIndex}_${newContainer.instanceId}_${newContainer.groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, newContainer);\n        }\n      }\n    }\n  }\n\n  updatePath(\n    point: paper.Shape,\n    position: { x: number, y: number },\n  ) {\n    const { instanceId, groupName, pointCategory, index, lines } = point.data;\n    const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n    if (path && !path.data.isCircle) {\n      const segmentIndex = path.data.points.findIndex((p: number) => p === index);\n      path.segments[segmentIndex].point.x = position.x;\n      path.segments[segmentIndex].point.y = position.y;\n    }\n    // change connect line position\n    if (lines) {\n      (lines as {isSource: boolean, fromTo: string}[]).forEach(({ isSource, fromTo }) => {\n        const line = this.getPathByCategory(instanceId, groupName, fromTo);\n        if (line && point.position) {\n          let n = isSource ? 0 : 1;\n          if (!line.segments[n]) {\n            n = 0;\n          }\n          line.segments[n].point.x = position.x;\n          line.segments[n].point.y = position.y;\n        }\n      });\n    }\n    this.updateLabel(\n      instanceId,\n      groupName,\n      index,\n      position,\n      position,\n      LandmarkEditType.KEYPOINT\n    );\n  }\n\n  setPointSelected(instanceId: string, groupName: string, index: number, selected: boolean) {\n    if (this.mainLayer?.children && this.mainLayer.children.length > 0) {\n      const point = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      if (point) {\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          point.strokeWidth = 3 / zoom;\n          point.radius = (rootStore.setting.pointSize + 1) / zoom;\n        } else {\n          point.radius = rootStore.setting.pointSize / zoom;\n          point.strokeWidth = 1 / zoom;\n        }\n      }\n    }\n  }\n\n  setMultiShapesSelected(selectedShapes: (paper.Shape | paper.Group)[], type: CategoryPathShape) {\n    if (selectedShapes.length > 0) {\n      const { instanceId, groupName } = selectedShapes[0].data;\n      this.props.selectGroup(instanceId, groupName, false);\n      this.props.setSelectedShape(undefined);\n    }\n    if (type === CategoryPathShape.CIRCLE) {\n      this.selectedPoints = (selectedShapes as paper.Shape[]).sort((a, b) => a.data.index - b.data.index);\n      this.props.setMultiSelectedShape(this.selectedPoints.map((point) => (point as paper.Shape).data.index));\n      this.selectedPoints.forEach((point) => {\n        const pData = point.data;\n        this.setPointSelected(pData.instanceId, pData.groupName, pData.index, true);\n      });\n    } else {\n      this.selectedRectangles = selectedShapes as paper.Group[];\n      this.selectedRectangles.forEach((rectangle) => {\n        const rData = rectangle.data;\n        this.selectShape(rData.instanceId, rData.groupName, rData.id);\n      });\n    }\n  }\n\n  setMultiShapesUnselected() {\n    this.selectedPoints.forEach((point) => {\n      const { instanceId, groupName, index } = point.data;\n      this.setPointSelected(instanceId, groupName, index, false);\n    });\n    this.selectedRectangles.forEach((rectangle) => {\n      const { instanceId, groupName, id } = rectangle.data;\n      this.selectShape(instanceId, groupName, id, false);\n    });\n\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    this.props.setMultiSelectedShape([]);\n  }\n\n  updatePointsPosition(shapes: UpdatedShape[]) {\n    this.props.handleShapesChange(shapes);\n    this.updateGroupBox(shapes[0].instanceId, shapes[0].category, shapes[0].groupName);\n  }\n\n  // resize and drag, change label position\n  updateRectanglePosition(shapes: UpdatedShape[]) {\n    this.props.handleShapesChange(shapes);\n    if (this.labelLayer) {\n      shapes.forEach(({ instanceId, groupName, id, shape }) => {\n        if (id && shape && (shape as Rectangle).x) {\n          const { x, y, width, height } = shape as Rectangle;\n          this.updateLabel(\n            instanceId,\n            groupName,\n            id,\n            { x, y },\n            { x: x + width / 2, y: y + height / 2 },\n            LandmarkEditType.RECTANGLE\n          );\n        }\n      });\n    }\n  }\n\n  deleteSelectedPoints() {\n    const updatedCategories: KeypointCategoryProps[] = [];\n    const points = (this.selectedPoints.length > 0 ? this.selectedPoints.map((p) => ({\n      frameIndex: this.props.currentFrame,\n      instanceId: p.data.instanceId,\n      category: p.data.category,\n      groupName: p.data.groupName,\n      index: p.data.index,\n      shapeType: LandmarkEditType.KEYPOINT\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.KEYPOINT\n    }]).filter((selectedShapeStatus) => {\n      const { frameIndex, instanceId, groupName, index } = selectedShapeStatus;\n      const point = typeof index === 'number' && this.getShapeByKey(instanceId, groupName, index);\n      if (point && point.data) {\n        const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${point.data.pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          const path = this.getPathByCategory(instanceId, groupName, point.data.pointCategory);\n          const instance = this.getInstanceContainerByInstaceId(instanceId);\n          if (instance && path && path.data.isCircle) {\n            const group = rootStore.ontology.getGroupData(instance.data.category, groupName);\n            const pointCategory = group && group.categories && group.categories.length && group.categories.find((c) => c.name === point.data.pointCategory);\n            if (pointCategory) {\n              const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n              const pIndex1 = sortedKeys[0];\n              const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n              if (index !== pIndex1 && index !== pIndex2) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n      return !!point;\n    });\n    this.props.handleShapesRemove(points);\n    points.forEach(({ frameIndex, instanceId, category, groupName, index }) => {\n      const instance = this.getInstanceContainerByInstaceId(instanceId);\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      if (instance && point && !updatedCategories.includes(point.data.pointCategory)) {\n        updatedCategories.push({ pointCategory: point.data.pointCategory, frameIndex, instanceId, groupName, category: instance.data.category });\n      }\n      this.removePointShape({ instanceId, category, groupName }, index);\n    });\n    updatedCategories.forEach(({ frameIndex, pointCategory, ...container }) => {\n      const categoryKey = `${frameIndex}_${container.instanceId}_${container.groupName}_${pointCategory}`;\n      this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n    });\n    this.selectedPoints = [];\n  }\n\n  deleteSelectedRectangle() {\n    const rectangles = (this.selectedRectangles.length > 0 ? this.selectedRectangles.map((rect) => ({\n      frameIndex: rect.data.frameIndex,\n      instanceId: rect.data.instanceId,\n      category: rect.data.category,\n      groupName: rect.data.groupName,\n      id: rect.data.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      id: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    }]).filter((v) => typeof v.id === 'string');\n    this.props.handleShapesRemove(rectangles);\n    rectangles.forEach(({ instanceId, groupName, id }) => {\n      this.removeRectangle(instanceId, groupName, id);\n    });\n    this.selectedRectangles = [];\n  };\n\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ?\n      this.selectedPoints.map((p) => p.data) :\n      [{ ...this.props.selectedShapeStatus, index: this.props.selectedShapeStatus.id }]\n        .filter((v) => v.shapeType === LandmarkEditType.KEYPOINT);\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      this.changeVisibleStyle(point, index, { instanceId, category, groupName }, !point.data.visible);\n    });\n    this.props.togglePointsVisibility(points);\n  }\n\n  changeVisibleStyle(point: paper.Shape, index: number, groupData: Group, visible: boolean) {\n    const { instanceId, groupName } = groupData;\n    const labelGroup = this.getLabelByKey(instanceId, groupName, index);\n    if (point) {\n      let fillColor = POINT_COLOR;\n      let strokeColor = '#ffffff';\n      if (visible) {\n        fillColor = point.data.isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      } else {\n        fillColor = '#3d424d';\n        strokeColor = point.data.isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      }\n      point.data.visible = visible;\n      point.fillColor = new Paper.Color(fillColor);\n      point.strokeColor = new Paper.Color(strokeColor);\n    }\n    if (this.labelLayer && labelGroup) {\n      const label = labelGroup.children.length === 2 ? labelGroup.children[1] : labelGroup.children[0];\n      (label as paper.PointText).content = `${visible ? '1' : '0'}-${index}`;\n      label.fillColor = new Paper.Color(visible ? 'white' : 'red');\n    }\n  }\n\n  @action.bound\n  hitTest(event: ToolEventExtend) {\n    if (this.mainLayer && !this.tool?.mouseDown) {\n      this.cursor = Cursor.DEFAULT;\n      const isDrawPoint = this.props.selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT;\n      if (this.canAddShape()) {\n        this.cursor = isDrawPoint ? Cursor.POINTER : Cursor.CROSSHAIR;\n      }\n      if (this.selectedHit) {\n        this.selectedHit.selected = false;\n      }\n\n      const hits = this.mainLayer.hitTestAll(event.point, {\n        fill: true,\n        selected: false,\n        handles: true,\n        stroke: true,\n        tolerance: 10 / this.paperZoom,\n        match: (ht: any) => {\n          if (ht && ht.item && (ht.item.data.type === undefined || ht.item.data.type === SHAPE_TYPE.KEYPOINT_BOX)) {\n            return false;\n          }\n          return true;\n        }\n      });\n      let hit: paper.HitResult | undefined;\n      for (let i = 0; i < hits.length; i += 1) {\n        const h = hits[i];\n        const { type } = h.item.data;\n        if (\n          !type ||\n          (type !== SHAPE_TYPE.INSTANCE &&\n          type !== SHAPE_TYPE.GROUP &&\n          type !== SHAPE_TYPE.KEYPOINT_BOX &&\n          type !== SHAPE_TYPE.RECTANGLE_GROUP) &&\n          (\n            type !== SHAPE_TYPE.PATH ||\n            (type === SHAPE_TYPE.PATH && ['handle-in', 'handle-out'].includes(h.type)))\n        ) {\n          // select point | rectangle | rectangle control | path handle\n          if ((type === SHAPE_TYPE.RECTANGLE || type === SHAPE_TYPE.RECTANGLE_POINT || type === SHAPE_TYPE.RECTANGLE_PATH)) {\n            if ((i === 0) && !this.canAddShape()) {\n              hit = h;\n            }\n          } else {\n            hit = h;\n            if (type === SHAPE_TYPE.KEYPOINT) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (hit?.item && !event.event.ctrlKey) {\n        if (\n          !this.isShapeInSelectedShapes(hit.item.data?.instanceId, hit.item.data?.groupName, hit.item.data?.index) &&\n          hit.item.data?.index !== this.props.selectedShapeStatus.id &&\n          hit.item.data?.id !== this.props.selectedShapeStatus.id\n        ) {\n          this.selectedHit = hit.item;\n          hit.item.selected = true;\n        }\n        if (hit.item.data.cursor) {\n          this.cursor = hit.item.data.cursor;\n        } else {\n          this.cursor = Cursor.MOVE;\n        }\n        this.showShapeLabel(hit, event.point);\n      } else if (this.shownLabel) {\n        const { point } = this.shownLabel.data;\n        resetAttrLabelPosition(this.shownLabel, { x: point[0], y: point[1] }, false);\n      }\n      this.hits = hit;\n      if (this.currentWarnings.length > 0) {\n        this.warningBtn = this.warningLayer?.hitTest(event.point);\n      }\n\n      if (this.smoothPath) {\n        this.smoothPath.fullySelected = true;\n      }\n    }\n  }\n\n  clearHits = () => {\n    this.hits = undefined;\n  };\n\n  showShapeLabel(hits: paper.HitResult, point: paper.Point) {\n    const localPoint = this.getPointInImage(Paper.view.projectToView(point));\n    const { data } = hits.item;\n    let label;\n    if (data.type === SHAPE_TYPE.KEYPOINT && rootStore.setting.activePointAttributesMode === AttributesMode.HOVER) {\n      (label = this.getAttrLabelByKey(data.instanceId, data.groupName, data.index));\n    } else if (\n      (data.type === SHAPE_TYPE.RECTANGLE || data.type === SHAPE_TYPE.RECTANGLE_PATH || data.type === SHAPE_TYPE.RECTANGLE_POINT) &&\n      hits.item.parent &&\n      rootStore.setting.activeAttributesMode === AttributesMode.HOVER\n    ) {\n      const { instanceId, groupName, id } = hits.item.parent.data;\n      (label = this.getAttrLabelByKey(instanceId, groupName, id));\n    }\n    if (label && (label.children?.slice(-1)[0] as paper.PointText).content) {\n      if (this.shownLabel) {\n        if (JSON.stringify(label) !== JSON.stringify(this.shownLabel)) {\n          const { point: position } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, { x: position[0], y: position[1] }, false);\n          this.shownLabel = label;\n        }\n      } else {\n        this.shownLabel = label;\n      }\n      this.shownLabel.visible = true;\n      this.shownLabel.position.x = localPoint.x + 50 / Paper.view.zoom;\n      this.shownLabel.position.y = localPoint.y + 50 / Paper.view.zoom;\n    }\n  }\n\n  getNewPointsByKeyPointRange(path: paper.Path, startKey: number, endKey: number, instanceId: string, groupName: string) {\n    const startPosition = this.getShapeByKey(instanceId, groupName, startKey).position;\n    const endPosition = this.getShapeByKey(instanceId, groupName, endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    let newPoints = {}; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints = {\n        ...newPoints,\n        [base + 1]: nextPoint\n      };\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n\n  getUpdatedPointsByNewPoints(newPoints: {[index: number]: paper.Point}, pointCategory: CategoryItem, parentData: Group) {\n    const { instanceId, groupName, category } = parentData;\n    const updatedShapes: UpdatedShape[] = [];\n    const indexs = Object.keys(newPoints).map((v) => Number(v));\n    for (let index = 0; index < indexs.length; index += 1) {\n      const pointIndex = indexs[index];\n      const existingPoint = this.getShapeByKey(instanceId, groupName, pointIndex) as paper.Shape;\n      if (newPoints[pointIndex]) {\n        const { x, y } = newPoints[pointIndex];\n        const pointInfo = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index: pointIndex,\n          shapeType: LandmarkEditType.KEYPOINT,\n        };\n        if (existingPoint) {\n          if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n            // update position\n            existingPoint.position.x = x;\n            existingPoint.position.y = y;\n\n            this.updatePath(existingPoint, { x, y });\n            updatedShapes.push({\n              ...pointInfo,\n              shape: {\n                position: { x, y }\n              },\n            });\n          }\n        } else {\n          // add new point\n          const isKeyPoint = pointCategory.keys.includes(pointIndex);\n          const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n\n          this.addKeypointShape(new Paper.Point(x, y), pointCategory.name, pointIndex, isKeyPoint, groupContainer, true);\n          updatedShapes.push({\n            ...pointInfo,\n            shape: {\n              pointCategory: pointCategory.name,\n              isKeyPoint,\n              position: { x, y },\n              visible: true,\n            },\n          });\n        }\n      }\n    }\n    return updatedShapes;\n  }\n\n  autoAdjust(point = this.props.selectedShapeStatus) {\n    if (this.props.selectedShapeInfo) {\n      const { id } = point;\n      const { instanceId, category, groupName, pointCategory: categoryName } = this.props.selectedShapeInfo as PointInfo;\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName); // pointCategory path\n      const pointCategory = this.props.categories.find((c) => c.name === categoryName); // pointCategory definition\n      if (path && pointCategory && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex: number | undefined;\n        let nextKeyPointIndex: number | undefined;\n        const { points = [] } = path.data;\n        const { keys = [] } = pointCategory;\n        const keysWithTwoSides = [\n          ...(keys.includes(points[0]) ? [] : [points[0]]),\n          ...keys,\n          ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]]),\n        ].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex((key) => key > Number(id));\n        if (keyIndex < 0) { // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex, instanceId, groupName);\n          const parentData = { instanceId, category, groupName };\n          const updatedShapes = this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData);\n          if (updatedShapes.length > 0) {\n            this.props.handleShapesChange(updatedShapes);\n          }\n        }\n      }\n    }\n  }\n\n  switchSmoothMode() {\n    if (this.props.selectedShapeInfo) {\n      const { instanceId, category, groupName, pointCategory: categoryName } = this.props.selectedShapeInfo as PointInfo;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName);\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      if (path && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const pointCategory = this.props.categories.find((c) => c.name === categoryName);\n          if (pointCategory) {\n            const keyPoints = pointCategory.keys.filter((k) => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedShapes: UpdatedShape[] = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i], instanceId, groupName);\n              const parentData = { instanceId, category, groupName };\n              updatedShapes = [\n                ...updatedShapes,\n                ...this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData),\n              ];\n            }\n            if (updatedShapes.length > 0) {\n              this.props.handleShapesChange(updatedShapes);\n            }\n          }\n          this.clearSmooth();\n        } else {\n          // start\n          path.fullySelected = true;\n          path.smooth({ type: 'continuous' });\n          this.smoothPath = path;\n        }\n      }\n    }\n  }\n\n  clearSmooth() {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach((seg) => {\n        seg.clearHandles();\n      });\n      this.smoothPath = null;\n    }\n  }\n\n  setCategoryAsCircle() {\n    if (this.props.selectedShapeInfo) {\n      const { instanceId, category, groupName, pointCategory } = this.props.selectedShapeInfo as PointInfo;\n      if (pointCategory) {\n        const container: Group = { instanceId, category, groupName };\n        const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, false, container);\n          this.props.setCategoryPathShape(categoryKey);\n        } else {\n          const updatedShapes = this.updateCirclePath(pointCategory, true, container);\n          this.props.setCategoryPathShape(categoryKey, CategoryPathShape.CIRCLE, updatedShapes);\n        }\n      }\n    }\n  }\n\n  updateCirclePath(categoryName: string, isCirclePath = true, container: Group) {\n    const { instanceId, groupName, category } = container;\n    const updatedShapes: UpdatedShape[] = [];\n    const path = this.getPathByCategory(instanceId, groupName, categoryName);\n    const categoryData = rootStore.ontology.getCategoryData(category, groupName, categoryName);\n    const lineColor = categoryData?.isConnect === false ?\n      new Paper.Color('rgba(0,0,0,0)') :\n      new Paper.Color(categoryData?.displayColor || POINT_COLOR);\n    if (path && categoryData) {\n      const categoryPoints = this.getPointsByCategory(instanceId, groupName, categoryName);\n      if (categoryPoints) {\n        const sortedKeys = [...categoryData.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find((p) => p.data.index === pIndex1);\n        const point2 = categoryPoints.find((p) => p.data.index === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer!.matrix.scaling.x;\n        if (point1 && point2 && isCirclePath) {\n          // is a circle & key points all exist\n          const centerX = (point1.position.x + point2.position.x) / 2;\n          const centerY = (point1.position.y + point2.position.y) / 2;\n          const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n          const newPath = new Paper.CompoundPath({\n            children: [\n              new Paper.Path.Circle({\n                center: [centerX, centerY],\n                radius,\n              }),\n              new Paper.Path.Line({\n                from: [point1.position.x, point1.position.y],\n                to: [point2.position.x, point2.position.y],\n              }),\n              new Paper.Path.Line({\n                from: new Paper.Point(computeRotatedPosition({ x: centerX, y: centerY }, point1.position, Math.PI / 2)),\n                to: new Paper.Point(computeRotatedPosition({ x: centerX, y: centerY }, point1.position, -Math.PI / 2)),\n              }),\n            ],\n            strokeWidth: rootStore.setting.lineWidth / zoom,\n            strokeColor: lineColor,\n            selectedColor: lineColor,\n          });\n          newPath.data = { ...path.data, isCircle: true, instanceId, groupName };\n          path.replaceWith(newPath);\n\n          // update all points in this pointCategory\n          const update = (index: number, position: { x: number; y: number }) => {\n            const existingPoint = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n            const pointInfo = {\n              frameIndex: this.props.selectedShapeStatus.frameIndex,\n              instanceId,\n              category,\n              groupName,\n              index,\n              shapeType: LandmarkEditType.KEYPOINT,\n            };\n            if (existingPoint) {\n              // update position\n              existingPoint.position.x = position.x;\n              existingPoint.position.y = position.y;\n              this.updatePath(existingPoint, position);\n              updatedShapes.push({\n                ...pointInfo,\n                shape: {\n                  position: { x: position.x, y: position.y }\n                },\n              });\n            } else {\n              const isKeyPoint = categoryData.keys.includes(index);\n              const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n\n              this.addKeypointShape(new Paper.Point(position.x, position.y), categoryData.name, index, isKeyPoint, groupContainer, true);\n              updatedShapes.push({\n                ...pointInfo,\n                shape: {\n                  pointCategory: categoryData.name,\n                  isKeyPoint,\n                  position: { x: position.x, y: position.y },\n                  visible: true,\n                },\n              });\n            }\n          };\n          const [start, end] = categoryData.range;\n          for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n            const radians = (Math.PI / (pIndex2 - pIndex1)) * (i - pIndex1);\n            const position = computeRotatedPosition({ x: centerX, y: centerY }, point1.position, radians);\n            update(i, position);\n          }\n          for (let i = pIndex2 + 1; i <= end; i += 1) {\n            const radians = (Math.PI / (end + 1 - pIndex2)) * (i - pIndex2);\n            const position = computeRotatedPosition({ x: centerX, y: centerY }, point2.position, radians);\n            update(i, position);\n          }\n          for (let i = start; i < pIndex1; i += 1) {\n            const radians = (Math.PI / (end + 1 - pIndex2)) * (start - pIndex1);\n            const position = computeRotatedPosition({ x: centerX, y: centerY }, point1.position, radians);\n            update(i, position);\n          }\n        } else {\n          const points = [...categoryPoints].sort((a, b) => a.data.index - b.data.index);\n          const newPath = new Paper.Path({\n            segments: points.map((p) => p.position),\n            strokeWidth: rootStore.setting.lineWidth / zoom,\n            strokeColor: lineColor,\n            selectedColor: lineColor,\n          });\n          newPath.data = { ...path.data, isCircle: false, points: points.map((p) => p.data.index) };\n          path.replaceWith(newPath);\n        }\n      }\n    }\n    return updatedShapes;\n  }\n\n  updateGroupBox = (instanceId: string, category: string, groupName: string) => {\n    let boundRect = this.getShapeByGroup();\n    const { selectedShapeStatus } = this.props;\n    let isRemovebound = false;\n    if (instanceId) {\n      if (\n        instanceId !== selectedShapeStatus.instanceId ||\n        groupName !== selectedShapeStatus.groupName\n      ) return;\n      const groupConntainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      const points = groupConntainer && groupConntainer.children\n        .filter((v: any) => v.type === CategoryPathShape.CIRCLE)\n        .map((v) => [v.position.x, v.position.y]);\n      if (points && points.length > 0) {\n        const xList = points.map((v) => v[0]);\n        const yList = points.map((v) => v[1]);\n        const minX = Math.min(...xList);\n        const maxX = Math.max(...xList);\n        const minY = Math.min(...yList);\n        const maxY = Math.max(...yList);\n        if (this.mainLayer) {\n          const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n          if (boundRect) {\n            boundRect.remove();\n          }\n          const range = (rootStore.setting.pointSize * 3) / zoom;\n          const strokeWitdth = rootStore.setting.lineWidth / zoom;\n          boundRect = new Paper.Shape.Rectangle({\n            point: [minX - range, minY - range],\n            size: [maxX - minX + 2 * range, maxY - minY + 2 * range],\n            strokeColor: new Paper.Color('#FFE600'),\n            strokeWidth: strokeWitdth\n          });\n          boundRect.data.type = SHAPE_TYPE.KEYPOINT_BOX;\n          this.mainLayer.addChild(boundRect);\n          const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n          const instance = this.props.getInstance(instanceId);\n          const content = `${groupInfo?.class_display_name || ''} ${instance?.number || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n\n          const labelGroup = this.getLabelByKey('', '', SHAPE_TYPE.KEYPOINT_BOX);\n          if (labelGroup) {\n            labelGroup.remove();\n          }\n\n          this.addLabel(\n            content,\n            { x: minX - range, y: minY - range - strokeWitdth * 2, width: maxX - minX + 2 * range, height: maxY - minY + 2 * range },\n            { instanceId: '', category: '', groupName: '' },\n            SHAPE_TYPE.KEYPOINT_BOX,\n            true,\n            SHAPE_TYPE.KEYPOINT_BOX\n          );\n        }\n      } else {\n        isRemovebound = true;\n      }\n    } else {\n      isRemovebound = true;\n    }\n    if (isRemovebound && boundRect) {\n      boundRect.remove();\n      this.removeLabel('', '', SHAPE_TYPE.KEYPOINT_BOX);\n    }\n  };\n\n  addRectangle(path: paper.Path, groupInfo: GroupInfo, add = true) {\n    if (this.mainLayer) {\n      const { displayColor, instanceId, category, groupName } = groupInfo;\n      const { data: { id }, segments } = path;\n      const rectData = {\n        x: segments[0].point.x,\n        y: segments[0].point.y,\n        width: segments[2].point.x - segments[0].point.x,\n        height: segments[2].point.y - segments[0].point.y,\n        displayColor,\n      };\n      this.drawRectangle(rectData, { instanceId, category, groupName }, id);\n      if (add) {\n        this.props.setNextEmptyShape();\n      }\n    }\n  }\n\n  getAlphaColor(color: string, opacity = this.fillOpacity) {\n    return hexToRgba(color, opacity);\n  }\n\n  drawRectangle(\n    rectData: {x: number, y: number, width: number, height: number, displayColor?: string},\n    groupData: Group,\n    id: string,\n    visible = true\n  ) {\n    if (this.props.selectedShapeInfo && this.mainLayer) {\n      const { x, y, width, height, displayColor } = rectData;\n      const { instanceId, category, groupName } = groupData;\n      let instanceContainer = this.getInstanceContainerByInstaceId(instanceId);\n      let groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (!instanceContainer) {\n        instanceContainer = new Paper.Group();\n        instanceContainer.data = {\n          instanceId,\n          name: category,\n          type: SHAPE_TYPE.INSTANCE,\n        };\n        this.mainLayer?.addChild(instanceContainer);\n      }\n      if (!instanceContainer || !groupContainer) {\n        groupContainer = new Paper.Group();\n        groupContainer.data = {\n          groupName,\n          category,\n          type: SHAPE_TYPE.GROUP,\n          instanceId,\n        };\n        instanceContainer.addChild(groupContainer);\n      }\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      let rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox) {\n        rectangleBox.removeChildren();\n      } else {\n        rectangleBox = new Paper.Group();\n        rectangleBox.data = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          id,\n          groupName,\n          category,\n          type: SHAPE_TYPE.RECTANGLE_GROUP,\n          instanceId,\n          displayColor,\n          visible,\n        };\n        groupContainer.addChild(rectangleBox);\n      }\n      const rectangle = new Paper.Shape.Rectangle({\n        point: [x, y],\n        size: [width, height],\n        fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n        strokeWidth: rootStore.setting.lineWidth / zoom\n      });\n      rectangle.data = {\n        parentShape: id,\n        cursor: Cursor.MOVE,\n        type: SHAPE_TYPE.RECTANGLE\n      };\n      rectangleBox.addChild(rectangle);\n      this.selectShape(instanceId, groupName, id, id === this.props.selectedShapeStatus.id);\n      if (this.labelLayer) {\n        const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n        const instance = this.props.getInstance(instanceId);\n        const group = instance?.children.find((g) => g.name === groupName)?.frames[this.props.currentFrame];\n        const label = `${groupInfo?.class_display_name || ''} ${instance?.number || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n        let attrsLabel = getValuesLabel(groupInfo?.label_config?.fields, group?.attributes, rootStore.setting.labelItems);\n        attrsLabel = `${rootStore.setting.displayCategory ? `${label};` : ''}${rootStore.setting.displayCategory && attrsLabel ? ';' : ''}${attrsLabel}`;\n        const labelGroup = this.getLabelByKey(instanceId, groupName, id);\n        if (labelGroup) {\n          this.updateLabel(\n            instanceId,\n            groupName,\n            id,\n            { x, y },\n            { x: x + width / 2, y: y + height / 2 },\n            LandmarkEditType.RECTANGLE\n          );\n        } else {\n          this.addLabel(\n            label,\n            { x, y, width, height },\n            { instanceId, category, groupName },\n            id,\n            visible,\n            SHAPE_TYPE.RECTANGLE,\n            attrsLabel\n          );\n        }\n      }\n    }\n  }\n\n  removeRectangle(instanceId: string, groupName: string, id: string) {\n    const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n    if (rectangleBox) {\n      rectangleBox.removeChildren();\n      rectangleBox.remove();\n      this.removeLabel(instanceId, groupName, id);\n    }\n  }\n\n  selectShape(instanceId: string, groupName: string, id: string, selected = true) {\n    if (this.mainLayer) {\n      const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox && rectangleBox.children) {\n        const { bounds: { topLeft, topRight, bottomRight, bottomLeft, x, y, height, width } } = rectangleBox.children[0];\n        const points = [topLeft, topRight, bottomRight, bottomLeft];\n        const { displayColor } = rectangleBox.data;\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          const radius = (rootStore.setting.pointSize / 2) / zoom;\n          const newColor = new Paper.Color(displayColor || POINT_COLOR);\n          points.forEach((point, index) => {\n            const sourceSeg = new Paper.Segment(point);\n            const targetSeg = index + 1 >= points.length ?\n              new Paper.Segment(points[0]) :\n              new Paper.Segment(points[index + 1]);\n\n            const lineBar = new Paper.Path({\n              segments: [sourceSeg, targetSeg],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              fillColor: newColor,\n              strokeColor: newColor,\n              selectedColor: newColor,\n            });\n            lineBar.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_PATH,\n              controlIndex: index,\n            };\n            rectangleBox.addChild(lineBar);\n          });\n          points.forEach((point, index) => {\n            const control = new Paper.Shape.Circle(point, radius);\n            control.strokeColor = newColor;\n            control.strokeWidth = rootStore.setting.lineWidth / zoom;\n            control.fillColor = newColor;\n            control.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_POINT,\n              controlIndex: index,\n              displayColor\n            };\n            rectangleBox.addChild(control);\n          });\n        } else {\n          rectangleBox.removeChildren();\n          const rectangle = new Paper.Shape.Rectangle({\n            point: [x, y],\n            size: [width, height],\n            fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n            strokeWidth: rootStore.setting.lineWidth / zoom\n          });\n          rectangle.data = {\n            parentShape: id,\n            cursor: Cursor.MOVE,\n            type: SHAPE_TYPE.RECTANGLE\n          };\n          rectangleBox.addChild(rectangle);\n        }\n      }\n    }\n  }\n\n  drawWarnings() {\n    this.warningLayer?.removeChildren();\n    if (this.warningLayer && !!this.props.warnings.length) {\n      const strokeWitdth = (rootStore.setting.lineWidth * 2) / this.paperZoom;\n      const warningIconSize = (rootStore.setting.pointSize * 6) / this.paperZoom;\n      this.currentWarnings.forEach((warning) => {\n        const { id, groupName, shapeIds } = warning;\n        const shapes: paper.Item[] = [];\n        shapeIds!.forEach((shapeId) => {\n          const shape = this.getShapeByKey(id, groupName!, shapeId);\n          if (shape) {\n            shapes.push(shape);\n            if (shape.data.type !== SHAPE_TYPE.RECTANGLE_GROUP) {\n              const { x, y, width, height } = shape.bounds;\n              const boundRect = new Paper.Shape.Rectangle({\n                point: [x - strokeWitdth, y - strokeWitdth],\n                size: [width + 2 * strokeWitdth, height + 2 * strokeWitdth],\n                strokeColor: new Paper.Color('#DC4624'),\n                strokeWidth: strokeWitdth\n              });\n              this.warningLayer!.addChild(boundRect);\n            }\n          }\n        });\n        let position: number[] = [];\n        if (shapes.length > 1) {\n          const minXList: number[] = [];\n          const maxXList: number[] = [];\n          const minYList: number[] = [];\n          const maxYList: number[] = [];\n          shapes.forEach(({ bounds: { x, y, width, height } }) => {\n            minXList.push(x - strokeWitdth);\n            maxXList.push(x + width + strokeWitdth);\n            minYList.push(y - strokeWitdth);\n            maxYList.push(y + height + strokeWitdth);\n          });\n          const minX = Math.min(...minXList);\n          const maxX = Math.max(...maxXList);\n          const minY = Math.min(...minYList);\n          const maxY = Math.max(...maxYList);\n          const boundRect = new Paper.Shape.Rectangle({\n            point: [minX - 2 * strokeWitdth, minY - 2 * strokeWitdth],\n            size: [maxX - minX + 4 * strokeWitdth, maxY - minY + 4 * strokeWitdth],\n            strokeColor: new Paper.Color('#DC4624'),\n            strokeWidth: strokeWitdth\n          });\n          this.warningLayer!.addChild(boundRect);\n          position = [minX - warningIconSize / 2, minY - warningIconSize / 2];\n        } else if (shapes.length === 1) {\n          position = [shapes[0].bounds.x - warningIconSize / 2, shapes[0].bounds.y - warningIconSize / 2];\n        }\n        if (shapes.length > 0) {\n          const warningIcon = new Paper.Shape.Circle({\n            center: new Paper.Point(position[0], position[1]),\n            radius: warningIconSize / 3,\n            fillColor: '#DC4624',\n          });\n          const text = new Paper.PointText({\n            content: '!',\n            fontSize: FONT_SIZE / this.paperZoom,\n            fontWeight: '700',\n            fillColor: 'white',\n          });\n          warningIcon.data = { instanceId: id, groupName, shapeIds };\n          text.data = { instanceId: id, groupName, shapeIds };\n          text.position.x = position[0];\n          text.position.y = position[1];\n          this.warningLayer!.addChild(warningIcon);\n          this.warningLayer!.addChild(text);\n        }\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div\n        ref={this.canvasContainer}\n        className=\"canvas\"\n        style={{ cursor: this.cursor }}\n      >\n        <canvas ref={this.canvas} />\n        {this.props.isReview && (\n          <div className=\"layer\">\n            <div className=\"tip\">\n              <span>{formatMessage('ORIGINAL_DATA')}</span>\n              <span>{formatMessage('REVIEW_TIP')}</span>\n              <Button className=\"close\" onClick={this.props.setReview} size=\"small\">\n                {formatMessage('REVIEW_CLOSE', { values: { shortcut: 'Ctrl+V' } })}\n              </Button>\n            </div>\n          </div>\n        )}\n        {(this.props.loading) && (\n          <div className=\"loading\">\n            {!this.raster && <Spin indicator={<LoadingOutlined style={{ fontSize: 100, color: '#00bad3' }} spin />} />}\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default Canvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}