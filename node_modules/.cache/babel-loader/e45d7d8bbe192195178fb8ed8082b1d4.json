{"ast":null,"code":"import{v4 as uuidv4}from'uuid';import{Base64}from'js-base64';import{utils as formUtils}from'@appen-china/easy-form';import{FieldControlType}from'@appen-china/easy-form/es/types';import{Tool}from'./types';import{DEFAULT_CAMERA_NAME,DEFAULT_CATEGORY_ITEM}from'./constants';import{fetchResultByUrl}from'../../utils';import{computeRotatedPosition}from'../../utils/math';import{ShapeType}from'../common/shapes/types';import{precise}from'../common/shapes/utils';/**\n * parse frames\n * @param frames\n */export function parseFrames(frames){if(typeof frames==='string'){return frames.split(',').map(f=>f.trim());}return[...frames];}/**\n * parse frames config from frames\n * @param frames\n */function parseFramesFromFrames(frames){if(typeof frames==='string'&&frames||Array.isArray(frames)){const defaultCamera={camera:DEFAULT_CAMERA_NAME,frames:parseFrames(frames)};return[defaultCamera];}return null;}/**\n * parse frames from payload\n * @param payload\n */export async function parseFramesByPaylod(_ref){let{frames,base_url}=_ref;const parseFromFrames=parseFramesFromFrames(frames);if(parseFromFrames!==null){return parseFromFrames;}if(base_url){try{const res=await fetchResultByUrl(base_url);if(res){const parseFromFramesResult=parseFramesFromFrames(res.frames);if(parseFromFramesResult!==null){return parseFromFramesResult;}}}catch(e){// fetch error\n}}return[{camera:DEFAULT_CAMERA_NAME,frames:[]}];}/**\n * load instance from result\n * @param result\n */export function loadInstancesFromResult(result){const instances=[];if(result&&result.instances&&Array.isArray(result.instances)){result.instances.forEach(instance=>{if(instance.frames){// legacy data\nconst defaultCamera={camera:DEFAULT_CAMERA_NAME,frames:instance.frames};const defaultItem={id:uuidv4(),name:DEFAULT_CATEGORY_ITEM,number:1,cameras:[defaultCamera]};const newInstance={id:instance.id,category:instance.category,number:instance.number,children:[defaultItem]};instances.push(newInstance);// TODO: fix string points attribute for rectangle\n}else{instances.push(instance);}});}return instances;}/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */export function predictShapeData(currentFrame,frames,bounds){// when shape already exists\nif(frames[currentFrame]){return null;}const prevKeyFrameIndexes=getLastKeyFrames(2,currentFrame,frames);const nextKeyFrameIndexes=getNextKeyFrames(1,currentFrame,frames);if(nextKeyFrameIndexes.length===1&&prevKeyFrameIndexes.length>=1){// prev & next has key frames\nconst[startFrame]=prevKeyFrameIndexes;const[endFrame]=nextKeyFrameIndexes;if(frames[startFrame].shapeType===frames[endFrame].shapeType){// same shape, use the range, else continue\nreturn getShapeFromFrames(frames,startFrame,endFrame,startFrame,currentFrame);}}if(nextKeyFrameIndexes.length<=0&&prevKeyFrameIndexes.length>=1){// no next key frame\nif(prevKeyFrameIndexes.length===1||frames[prevKeyFrameIndexes[0]].shapeType!==frames[prevKeyFrameIndexes[1]].shapeType){// just 1 prev key frame, or two prev key frame shapes are not same\nconst{shapeType,shape}=frames[prevKeyFrameIndexes[0]];return{shapeType,shape};}}if(prevKeyFrameIndexes.length===2){// has 2 prev key frames\nconst[endFrame,startFrame]=prevKeyFrameIndexes;const{shapeType,shape}=getShapeFromFrames(frames,startFrame,endFrame,endFrame,currentFrame);if(!bounds||checkShapeInBounds(shape,shapeType,bounds)){return{shapeType,shape};}}else if(prevKeyFrameIndexes.length===1){// has 1 prev key frame\nconst{shapeType,shape}=frames[prevKeyFrameIndexes[0]];return{shapeType,shape};}return null;}/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */export function getLastKeyFrames(count,currentFrame,frames){// find last n key frames\nlet i=currentFrame-1;const keyFrameIndexes=[];const minFrame=Math.min(...Object.values(frames).map(f=>f.frameIndex));while(i>=minFrame&&keyFrameIndexes.length<count){if(frames[i]&&frames[i].isKeyFrame){// find a key frame\nkeyFrameIndexes.push(i);}i-=1;}return keyFrameIndexes;}/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */export function getNextKeyFrames(count,currentFrame,frames){// find next n key frames\nlet i=currentFrame+1;const keyFrameIndexes=[];const maxFrame=Math.max(...Object.values(frames).map(f=>f.frameIndex));while(i<=maxFrame&&keyFrameIndexes.length<count){if(frames[i]&&frames[i].isKeyFrame){// find a key frame\nkeyFrameIndexes.push(i);}i+=1;}return keyFrameIndexes;}/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */export function getShapeFromFrames(frames,startFrame,endFrame,baseFrame,currentFrame){const frameShapeType=frames[baseFrame].shapeType;const shapeInfo={shapeType:frameShapeType,shape:frames[baseFrame].shape};if(Object.values(frames).filter(f=>f.frameIndex>=startFrame&&f.frameIndex<=endFrame).some(f=>f.shapeType!==frameShapeType)){// shape type changes between start & end, can't calculate offsets\nreturn shapeInfo;}const startShape=frames[startFrame].shape;const endShape=frames[endFrame].shape;const baseShape=frames[baseFrame].shape;const frameScale=(currentFrame-baseFrame)/(endFrame-startFrame);switch(frameShapeType){case ShapeType.RECTANGLE:{const shape=calculate(startShape,endShape,baseShape,frameScale);const right=precise(shape.x+shape.width);const bottom=precise(shape.y+shape.height);const points=[{x:shape.x,y:shape.y},{x:right,y:shape.y},{x:right,y:bottom},{x:shape.x,y:bottom}];if(shape.rotation){points.forEach(p=>{const point=computeRotatedPosition({x:shape.x+shape.width/2,y:shape.y+shape.height/2},p,shape.rotation);p.x=precise(point.x);p.y=precise(point.y);});}shape.points=points;shapeInfo.shape={...shape};break;}case ShapeType.DOT:{shapeInfo.shape=calculate(startShape,endShape,baseShape,frameScale);break;}default:}return shapeInfo;}/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */function calculate(start,end,base,scale){const calculatedObject={};Object.keys(base).forEach(key=>{if(start[key]!==undefined&&end[key]!==undefined){calculatedObject[key]=precise(base[key]+(end[key]-start[key])*scale);}});return calculatedObject;}/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */export function checkShapeInBounds(shape,shapeType,bounds){switch(shapeType){case ShapeType.RECTANGLE:case ShapeType.POLYGON:case ShapeType.LINE:{const points=shape.points;const allX=points.map(p=>p.x);const allY=points.map(p=>p.y);const left=Math.min(...allX);const right=Math.max(...allX);const top=Math.min(...allY);const bottom=Math.max(...allY);return left>=bounds.left&&top>=bounds.top&&right<=bounds.right&&bottom<=bounds.bottom;}case ShapeType.DOT:{const{x,y}=shape;return x<=bounds.right&&y<=bounds.bottom&&x>=bounds.left&&y>=bounds.top;}default:}return true;}/**\n * get shape type by tool name\n * @param tool\n */export function getShapeTypeByTool(tool){switch(tool){case Tool.RECTANGLE:return ShapeType.RECTANGLE;case Tool.POLYGON:return ShapeType.POLYGON;case Tool.LINE:return ShapeType.LINE;case Tool.DOT:return ShapeType.DOT;default:}return undefined;}/**\n * get tool type from frame data\n * @param shape\n */export function getToolTypeFromFrameData(shape){switch(shape.shapeType){case ShapeType.POLYGON:return Tool.POLYGON;case ShapeType.RECTANGLE:return Tool.RECTANGLE;case ShapeType.LINE:return Tool.LINE;case ShapeType.DOT:return Tool.DOT;default:}return undefined;}/**\n * parse label config\n * @param labelConfigStr\n */export function parseLabelConfig(labelConfigStr){if(labelConfigStr){try{const labelConfig=JSON.parse(Base64.decode(labelConfigStr));return labelConfig;}catch(e){// parse error\n}}return undefined;}/**\n * set initial values for fields\n * @param fields\n * @param values\n */export function setInitialValues(fields,values){return fields.map(field=>({...field,...(values&&values[field.name]!==undefined&&{defaultValue:values[field.name]})}));}/**\n * parse fields (with options), return a name-field map\n * @param config\n */export function parseFields(config){const map={};((config===null||config===void 0?void 0:config.fields)||[]).forEach(field=>{const{name,label,type,valueType,options=[]}=field;const newField={name,type,label};if(type===FieldControlType.RADIO||type===FieldControlType.SELECT||type===FieldControlType.CHECKBOX){// has options\nnewField.options=formUtils.parseOptions(options,valueType);}map[name]=newField;});return map;}/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */export function getUpperShape(targetShape,shapes){let upperShape;for(let i=0;i<shapes.length;i+=1){const shape=shapes[i];if(shape.order>targetShape.order){// upper\nif(!upperShape){upperShape=shape;}else if(upperShape.order>shape.order){upperShape=shape;}}}return upperShape;}/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */export function getUnderShape(targetShape,shapes){let underShape;for(let i=0;i<shapes.length;i+=1){const shape=shapes[i];if(shape.order<targetShape.order){// under\nif(!underShape){underShape=shape;}else if(underShape.order<shape.order){underShape=shape;}}}return underShape;}/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */export function preciseShapeByType(shapeType,shapeData){switch(shapeType){case ShapeType.RECTANGLE:{const{rotation}=shapeData;preciseData(shapeData);if(rotation!==undefined){shapeData.rotation=rotation;}break;}case ShapeType.POLYGON:case ShapeType.LINE:case ShapeType.DOT:preciseData(shapeData);break;default:}}/**\n * precise data\n * @param data\n */export function preciseData(data){if(Array.isArray(data)){// array\ndata.forEach((item,i)=>{if(typeof item==='number'){data[i]=precise(item);}else{preciseData(item);}});}else if(typeof data==='object'&&data!==null){// object\nconst allKeys=Object.keys(data);allKeys.forEach(key=>{const keyData=data[key];if(typeof keyData==='number'){data[key]=precise(keyData);}else{preciseData(keyData);}});}}/**\n * get field option label\n * @param value\n * @param options\n */export function getFieldOptionLabel(value,options){const option=options.find(o=>o.value===value);return(option===null||option===void 0?void 0:option.label)||\"\".concat(value);}/**\n * get field display label\n * @param value\n * @param field\n */export function getFieldDisplayLabel(fieldValue,field){let displayValue='';if(fieldValue!==undefined&&fieldValue!==null){if(field===null||field===void 0?void 0:field.options){displayValue=Array.isArray(fieldValue)?\"\".concat(fieldValue.map(v=>getFieldOptionLabel(v,field.options))):getFieldOptionLabel(fieldValue,field.options);}else{displayValue=\"\".concat(fieldValue);}}return displayValue;}","map":{"version":3,"names":["v4","uuidv4","Base64","utils","formUtils","FieldControlType","Tool","DEFAULT_CAMERA_NAME","DEFAULT_CATEGORY_ITEM","fetchResultByUrl","computeRotatedPosition","ShapeType","precise","parseFrames","frames","split","map","f","trim","parseFramesFromFrames","Array","isArray","defaultCamera","camera","parseFramesByPaylod","_ref","base_url","parseFromFrames","res","parseFromFramesResult","e","loadInstancesFromResult","result","instances","forEach","instance","defaultItem","id","name","number","cameras","newInstance","category","children","push","predictShapeData","currentFrame","bounds","prevKeyFrameIndexes","getLastKeyFrames","nextKeyFrameIndexes","getNextKeyFrames","length","startFrame","endFrame","shapeType","getShapeFromFrames","shape","checkShapeInBounds","count","i","keyFrameIndexes","minFrame","Math","min","Object","values","frameIndex","isKeyFrame","maxFrame","max","baseFrame","frameShapeType","shapeInfo","filter","some","startShape","endShape","baseShape","frameScale","RECTANGLE","calculate","right","x","width","bottom","y","height","points","rotation","p","point","DOT","start","end","base","scale","calculatedObject","keys","key","undefined","POLYGON","LINE","allX","allY","left","top","getShapeTypeByTool","tool","getToolTypeFromFrameData","parseLabelConfig","labelConfigStr","labelConfig","JSON","parse","decode","setInitialValues","fields","field","defaultValue","parseFields","config","label","type","valueType","options","newField","RADIO","SELECT","CHECKBOX","parseOptions","getUpperShape","targetShape","shapes","upperShape","order","getUnderShape","underShape","preciseShapeByType","shapeData","preciseData","data","item","allKeys","keyData","getFieldOptionLabel","value","option","find","o","concat","getFieldDisplayLabel","fieldValue","displayValue","v"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/utils.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { Base64 } from 'js-base64';\nimport { utils as formUtils } from '@appen-china/easy-form';\nimport { Field, FieldControlType, FieldOption, FieldValue } from '@appen-china/easy-form/es/types';\nimport { Instance, InstanceItem, CameraData, FrameData, Tool, LabelConfig, FieldConfig } from './types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_CATEGORY_ITEM } from './constants';\nimport { fetchResultByUrl } from '../../utils';\nimport { computeRotatedPosition } from '../../utils/math';\nimport { ShapeData, ShapeType } from '../common/shapes/types';\nimport type Shape from '../common/shapes/Shape';\nimport { RectangleData } from '../common/shapes/Rectangle';\nimport { DotData } from '../common/shapes/Dot';\nimport { PolygonData } from '../common/shapes/Polygon';\nimport { LineData } from '../common/shapes/Line';\nimport { precise } from '../common/shapes/utils';\n\n/**\n * parse frames\n * @param frames\n */\nexport function parseFrames(frames: string | string[]) {\n  if (typeof frames === 'string') {\n    return frames.split(',').map((f) => f.trim());\n  }\n  return [...frames];\n}\n\n/**\n * parse frames config from frames\n * @param frames\n */\nfunction parseFramesFromFrames(frames: unknown) {\n  if ((typeof frames === 'string' && frames) || Array.isArray(frames)) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      frames: parseFrames(frames),\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames from payload\n * @param payload\n */\nexport async function parseFramesByPaylod({ frames, base_url }: {\n  frames?: string | string[];\n  base_url?: string;\n}) {\n  const parseFromFrames = parseFramesFromFrames(frames);\n  if (parseFromFrames !== null) {\n    return parseFromFrames;\n  }\n\n  if (base_url) {\n    try {\n      const res: any = await fetchResultByUrl(base_url);\n      if (res) {\n        const parseFromFramesResult = parseFramesFromFrames(res.frames);\n        if (parseFromFramesResult !== null) {\n          return parseFromFramesResult;\n        }\n      }\n    } catch (e) {\n      // fetch error\n    }\n  }\n  return [{\n    camera: DEFAULT_CAMERA_NAME,\n    frames: [],\n  }];\n}\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result: any) {\n  const instances: Instance[] = [];\n\n  if (result && result.instances && Array.isArray(result.instances)) {\n    result.instances.forEach((instance: any) => {\n      if (instance.frames) {\n        // legacy data\n        const defaultCamera: CameraData = {\n          camera: DEFAULT_CAMERA_NAME,\n          frames: instance.frames,\n        };\n        const defaultItem: InstanceItem = {\n          id: uuidv4(),\n          name: DEFAULT_CATEGORY_ITEM,\n          number: 1,\n          cameras: [defaultCamera],\n        };\n        const newInstance: Instance = {\n          id: instance.id,\n          category: instance.category,\n          number: instance.number,\n          children: [defaultItem],\n        };\n        instances.push(newInstance);\n        // TODO: fix string points attribute for rectangle\n      } else {\n        instances.push(instance);\n      }\n    });\n  }\n\n  return instances;\n}\n\n/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */\nexport function predictShapeData(\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n  bounds?: { top: number; right: number; bottom: number; left: number },\n) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame);\n    }\n  }\n\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n      return { shapeType, shape };\n    }\n  }\n\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const { shapeType, shape } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return { shapeType, shape };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n    return { shapeType, shape };\n  }\n\n  return null;\n}\n\n/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getLastKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map((f) => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getNextKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map((f) => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */\nexport function getShapeFromFrames(\n  frames: {[frameIndex: number]: FrameData},\n  startFrame: number,\n  endFrame: number,\n  baseFrame: number,\n  currentFrame: number,\n) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape,\n  };\n\n  if (Object.values(frames).filter((f) => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some((f) => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE: {\n      const shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as RectangleData;\n      const right = precise(shape.x + shape.width);\n      const bottom = precise(shape.y + shape.height);\n      const points = [\n        { x: shape.x, y: shape.y },\n        { x: right, y: shape.y },\n        { x: right, y: bottom },\n        { x: shape.x, y: bottom },\n      ];\n      if (shape.rotation) {\n        points.forEach((p) => {\n          const point = computeRotatedPosition({ x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }, p, shape.rotation as number);\n          p.x = precise(point.x);\n          p.y = precise(point.y);\n        });\n      }\n\n      shape.points = points;\n      shapeInfo.shape = { ...shape };\n      break;\n    }\n    case ShapeType.DOT: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as DotData;\n      break;\n    }\n    default:\n  }\n\n  return shapeInfo;\n}\n\n/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */\nfunction calculate(\n  start: {[key: string]: number},\n  end: {[key: string]: number},\n  base: {[key: string]: number},\n  scale: number,\n) {\n  const calculatedObject: {[key: string]: number} = {};\n  Object.keys(base).forEach((key) => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = precise(base[key] + (end[key] - start[key]) * scale);\n    }\n  });\n  return calculatedObject;\n}\n\n/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */\nexport function checkShapeInBounds(\n  shape: ShapeData,\n  shapeType: ShapeType,\n  bounds: { top: number; right: number; bottom: number; left: number },\n) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n    case ShapeType.POLYGON:\n    case ShapeType.LINE: {\n      const points = (shape as RectangleData | PolygonData | LineData).points as { x: number; y: number }[];\n      const allX = points.map((p) => p.x);\n      const allY = points.map((p) => p.y);\n      const left = Math.min(...allX);\n      const right = Math.max(...allX);\n      const top = Math.min(...allY);\n      const bottom = Math.max(...allY);\n      return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n    }\n    case ShapeType.DOT: {\n      const { x, y } = shape as DotData;\n      return x <= bounds.right && y <= bounds.bottom && x >= bounds.left && y >= bounds.top;\n    }\n    default:\n  }\n  return true;\n}\n\n/**\n * get shape type by tool name\n * @param tool\n */\nexport function getShapeTypeByTool(tool: Tool): ShapeType | undefined {\n  switch (tool) {\n    case Tool.RECTANGLE:\n      return ShapeType.RECTANGLE;\n    case Tool.POLYGON:\n      return ShapeType.POLYGON;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * get tool type from frame data\n * @param shape\n */\nexport function getToolTypeFromFrameData(shape: FrameData) {\n  switch (shape.shapeType) {\n    case ShapeType.POLYGON:\n      return Tool.POLYGON;\n    case ShapeType.RECTANGLE:\n      return Tool.RECTANGLE;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * parse label config\n * @param labelConfigStr\n */\nexport function parseLabelConfig(labelConfigStr?: string) {\n  if (labelConfigStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(labelConfigStr));\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields: Field[], values: any) {\n  return fields.map((field) => ({\n    ...field,\n    ...values && values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config?: LabelConfig) {\n  const map: { [fieldName: string]: FieldConfig } = {};\n  (config?.fields || []).forEach((field) => {\n    const { name, label, type, valueType, options = [] } = field;\n    const newField: FieldConfig = { name, type, label };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUpperShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let upperShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order > targetShape.order) { // upper\n      if (!upperShape) {\n        upperShape = shape;\n      } else if (upperShape.order > shape.order) {\n        upperShape = shape;\n      }\n    }\n  }\n  return upperShape;\n}\n\n/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUnderShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let underShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order < targetShape.order) { // under\n      if (!underShape) {\n        underShape = shape;\n      } else if (underShape.order < shape.order) {\n        underShape = shape;\n      }\n    }\n  }\n  return underShape;\n}\n\n/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */\nexport function preciseShapeByType(shapeType: ShapeType, shapeData: ShapeData) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE: {\n      const { rotation } = shapeData as RectangleData;\n      preciseData(shapeData);\n      if (rotation !== undefined) {\n        (shapeData as RectangleData).rotation = rotation;\n      }\n      break;\n    }\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n    case ShapeType.DOT:\n      preciseData(shapeData);\n      break;\n    default:\n  }\n}\n\n/**\n * precise data\n * @param data\n */\nexport function preciseData(data: any) {\n  if (Array.isArray(data)) {\n    // array\n    data.forEach((item, i) => {\n      if (typeof item === 'number') {\n        data[i] = precise(item);\n      } else {\n        preciseData(item);\n      }\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    // object\n    const allKeys = Object.keys(data);\n    allKeys.forEach((key) => {\n      const keyData = data[key];\n      if (typeof keyData === 'number') {\n        data[key] = precise(keyData);\n      } else {\n        preciseData(keyData);\n      }\n    });\n  }\n}\n\n/**\n * get field option label\n * @param value\n * @param options\n */\nexport function getFieldOptionLabel(value: FieldValue, options: FieldOption[]) {\n  const option = options.find((o) => o.value === value);\n  return option?.label || `${value}`;\n}\n\n/**\n * get field display label\n * @param value\n * @param field\n */\nexport function getFieldDisplayLabel(fieldValue: FieldValue | FieldValue[], field?: FieldConfig) {\n  let displayValue = '';\n  if (fieldValue !== undefined && fieldValue !== null) {\n    if (field?.options) {\n      displayValue = Array.isArray(fieldValue)\n        ? `${fieldValue.map((v) => getFieldOptionLabel(v, field.options!))}`\n        : getFieldOptionLabel(fieldValue, field.options);\n    } else {\n      displayValue = `${fieldValue}`;\n    }\n  }\n  return displayValue;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}