{"ast":null,"code":"import rootStore from '../../store/RootStore';\nimport Shape from './Shape';\nimport Cursor from '../../../common/Cursor';\nimport { ShapeAction } from '../../utils/event';\nexport default class Segment extends Shape {\n  constructor(props) {\n    super(props);\n    /**\n     * process pointerdown\n     * @param event\n     * @param frontTargets\n     */\n    this.processPointerDown = event => {\n      if (event.data.button === 2) {\n        return;\n      }\n      this.selectShape(this.id);\n    };\n    /**\n     * process pointerup\n     * @param event\n     * @param frontTargets\n     */\n    this.processPointerUp = () => {\n      this._dragPosistion = null;\n      if (this._dragged) {\n        this._changed();\n        this._dragged = false;\n      }\n    };\n    /**\n     * process pointermove\n     * @param event\n     */\n    this.processPointerMove = () => {};\n    /**\n     * process app mouse down\n     */\n    this.processGlobalMouseDown = () => {};\n    this.instance.on('pointerdown', this.processPointerDown);\n    this.instance.on('pointerup', this.processPointerUp);\n    this.instance.on('pointerupoutside', this.processPointerUp);\n    this.instance.on('pointermove', this.processPointerMove);\n    this.instance.cursor = Cursor.POINTER;\n    this.instance.interactive = true;\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  _changed() {\n    this._emit(ShapeAction.CHANGED, this.getData());\n  }\n  /**\n   * draw\n   */\n  drawShape() {\n    this.instance.clear();\n    this.clearText();\n    if (this.control) {\n      this.control.remove();\n    }\n    let start = this.startX;\n    let end = this._endX;\n    const {\n      placement: {\n        atlasWidth\n      }\n    } = rootStore.analyse;\n    const startVisible = start > 0 && start < atlasWidth;\n    if (startVisible) {\n      this._initControl();\n    }\n    const endVisible = end > 0 && end <= atlasWidth;\n    let visible = true;\n    if (!startVisible && endVisible) {\n      start = 0;\n    } else if (startVisible && !endVisible) {\n      end = atlasWidth;\n    } else if (start <= 0 && end >= atlasWidth) {\n      start = 0;\n      end = atlasWidth;\n    } else if (!startVisible && !endVisible) {\n      visible = false;\n    }\n    if (visible) {\n      this._drawFill(start, end);\n      this.drawText();\n    }\n  }\n\n  /**\n   * draw fill\n   */\n  _drawFill(start, end) {\n    this.instance.beginFill(this.selected ? this.selectedColor : this.reviewBackgroundColor || this.color);\n    this.instance.drawRect(start, this._y, end - start - 1, this._height - 1);\n    this.instance.endFill();\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      start: this.start,\n      end: this.end,\n      text: this.text\n    };\n  }\n}","map":{"version":3,"names":["rootStore","Shape","Cursor","ShapeAction","Segment","constructor","props","processPointerDown","event","data","button","selectShape","id","processPointerUp","_dragPosistion","_dragged","_changed","processPointerMove","processGlobalMouseDown","instance","on","cursor","POINTER","interactive","_emit","CHANGED","getData","drawShape","clear","clearText","control","remove","start","startX","end","_endX","placement","atlasWidth","analyse","startVisible","_initControl","endVisible","visible","_drawFill","drawText","beginFill","selected","selectedColor","reviewBackgroundColor","color","drawRect","_y","_height","endFill","text"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/common/shapes/Segment.ts"],"sourcesContent":["import { Application, Container, InteractionEvent } from 'pixi.js';\nimport rootStore from '../../store/RootStore';\nimport Shape from './Shape';\nimport Cursor from '../../../common/Cursor';\nimport { AnnotationType, ReviewResult } from '../../types';\nimport { ShapeAction } from '../../utils/event';\n\nexport interface SegmentData {\n  start: number;\n  end: number;\n  text: string | undefined;\n}\n\nexport interface SegmentOptions {\n  id: string;\n  app: Application;\n  start: number;\n  end: number;\n  container: Container;\n  shapeType: AnnotationType;\n  category: string;\n  categoryIndex: number;\n  color?: number;\n  selectedColor?: number;\n  text?: string;\n  reviewResult?: ReviewResult;\n  selectShape: (id: string) => void;\n  positionListener: (start: number) => void;\n  moveShape: (shapes: Shape<unknown>[]) => void;\n  getPrevShape: (category: string, start: number) => { prev?: Shape<unknown>; next?: Shape<unknown>; };\n  getSameAndAdjoinTimeShapes: (time: number) => {\n    sameTimeShapes: Shape<unknown>[];\n    adjoinTimeShapes: {\n      prev: Shape<unknown> | undefined;\n      next: Shape<unknown> | undefined;\n    }[];\n  };\n}\n\nexport default class Segment extends Shape<SegmentData> {\n  constructor(props: SegmentOptions) {\n    super(props);\n    this.instance.on('pointerdown', this.processPointerDown);\n    this.instance.on('pointerup', this.processPointerUp);\n    this.instance.on('pointerupoutside', this.processPointerUp);\n    this.instance.on('pointermove', this.processPointerMove);\n    this.instance.cursor = Cursor.POINTER;\n    this.instance.interactive = true;\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  protected _changed() {\n    this._emit(ShapeAction.CHANGED, this.getData());\n  }\n\n  /**\n   * process pointerdown\n   * @param event\n   * @param frontTargets\n   */\n  processPointerDown = (event: InteractionEvent) => {\n    if (event.data.button === 2) {\n      return;\n    }\n    this.selectShape(this.id);\n  };\n\n  /**\n   * process pointerup\n   * @param event\n   * @param frontTargets\n   */\n  processPointerUp = () => {\n    this._dragPosistion = null;\n\n    if (this._dragged) {\n      this._changed();\n      this._dragged = false;\n    }\n  };\n\n  /**\n   * process pointermove\n   * @param event\n   */\n  processPointerMove = () => {\n\n  };\n\n  /**\n   * process app mouse down\n   */\n  processGlobalMouseDown = () => {\n\n  };\n\n  /**\n   * draw\n   */\n  drawShape() {\n    this.instance.clear();\n    this.clearText();\n    if (this.control) {\n      this.control.remove();\n    }\n    let start = this.startX;\n    let end = this._endX;\n    const {\n      placement: { atlasWidth },\n    } = rootStore.analyse;\n    const startVisible = start > 0 && start < atlasWidth;\n    if (startVisible) {\n      this._initControl();\n    }\n    const endVisible = end > 0 && end <= atlasWidth;\n    let visible = true;\n    if (!startVisible && endVisible) {\n      start = 0;\n    } else if (startVisible && !endVisible) {\n      end = atlasWidth;\n    } else if (start <= 0 && end >= atlasWidth) {\n      start = 0;\n      end = atlasWidth;\n    } else if (!startVisible && !endVisible) {\n      visible = false;\n    }\n    if (visible) {\n      this._drawFill(start, end);\n      this.drawText();\n    }\n  }\n\n  /**\n   * draw fill\n   */\n  private _drawFill(start: number, end: number) {\n    this.instance.beginFill(this.selected ? this.selectedColor : (this.reviewBackgroundColor || this.color));\n    this.instance.drawRect(start, this._y, end - start - 1, this._height - 1);\n    this.instance.endFill();\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      start: this.start,\n      end: this.end!,\n      text: this.text,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}