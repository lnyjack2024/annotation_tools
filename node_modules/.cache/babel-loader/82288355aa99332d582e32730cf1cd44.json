{"ast":null,"code":"/* eslint-disable no-bitwise */\nimport * as alawmulaw from 'alawmulaw';\nimport WaveDrawer from './waveDrawer';\nimport WavDecoder from './utils/wav-decoder';\nimport Observer from './utils/observer';\nimport WebAudio from './webaudio';\nimport { setStyle } from './utils';\nimport TimelinePlugin from './Timeline';\nimport RegionPlugin from './Region';\nimport AnalysePlugin from './Analyse';\nimport { parseAlawPcmToAudioData } from '../../../../utils/pcm';\nexport let DrawType = /*#__PURE__*/function (DrawType) {\n  DrawType[\"INIT\"] = \"init\";\n  DrawType[\"RESIZE\"] = \"resize\";\n  DrawType[\"SCROLL\"] = \"scroll\";\n  DrawType[\"ZOOM\"] = \"zoom\";\n  return DrawType;\n}({});\nexport let PluginType = /*#__PURE__*/function (PluginType) {\n  PluginType[\"TIMELINE\"] = \"timeline\";\n  PluginType[\"REGION\"] = \"region\";\n  PluginType[\"ANALYSE\"] = \"analyse\";\n  return PluginType;\n}({});\n;\nexport let OffsetType = /*#__PURE__*/function (OffsetType) {\n  OffsetType[\"OVERALL\"] = \"overall\";\n  OffsetType[\"CHANNEL\"] = \"channel\";\n  return OffsetType;\n}({});\nexport default class Wave extends Observer {\n  constructor({\n    container,\n    source,\n    ...options\n  }) {\n    super();\n    this.isReady = false;\n    this.params = void 0;\n    /**\n     * draw peaks\n     */\n    this.peaks = [];\n    this.drawer = void 0;\n    this.isDestroyed = false;\n    /**\n     * source file arraybuffer\n     */\n    this.arraybuffer = new ArrayBuffer(0);\n    /**\n     * source file audiobuffer\n     */\n    this.sourceBuffer = null;\n    /**\n     * draw audiobuffer\n     */\n    this.buffer = null;\n    /**\n     * multi channels peaks\n     */\n    this.splitPeaks = [];\n    /**\n     * merged channel peaks\n     */\n    this.mergedPeaks = [];\n    /**\n     * chanel count\n     */\n    this.channelCount = 0;\n    /**\n     * zoom\n     */\n    this.pxPerSec = 1;\n    /**\n     * selected time\n     */\n    this.currentTime = 0;\n    /**\n     * wave width\n     */\n    this.width = 0;\n    /**\n     * wave height\n     */\n    this.height = 0;\n    /**\n     * waveform center\n     */\n    this.center = 0.5;\n    /**\n     * visible range precent\n     */\n    this.displayRange = {\n      start: 0,\n      end: 1\n    };\n    /**\n     * wave plugins\n     */\n    this.plugins = {};\n    this.initialisedPluginList = {};\n    this.backend = void 0;\n    this.isMuted = false;\n    // Used to save the current volume when muting so we can\n    this.savedVolume = 0;\n    this.hideChannels = [];\n    this.visibleChannelCount = 0;\n    this.channelOptions = [];\n    this.offsetOverall = 0;\n    this.offsetChannels = [];\n    // Loads audio using Web Audio buffer backend.\n    this.loadBuffer = async url => {\n      const tail = url.split('.').pop();\n      const arrayBuffer = await fetch(url).then(data => data.arrayBuffer());\n      this.loadArrayBuffer(arrayBuffer, tail);\n    };\n    // Decode buffer and load\n    this.loadArrayBuffer = async (arraybuffer, format) => {\n      this.arraybuffer = arraybuffer;\n      let audioBuffer = null;\n      if (format === 'wav') {\n        const decodeData = WavDecoder.decodeSync(arraybuffer);\n        audioBuffer = new AudioBuffer({\n          numberOfChannels: decodeData.numberOfChannels,\n          sampleRate: decodeData.sampleRate,\n          length: decodeData.length\n        });\n        for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n          const audioChannelBuffer = audioBuffer.getChannelData(i);\n          for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n            audioChannelBuffer[j] = decodeData.channelData[i][j];\n          }\n        }\n      } else if (format === 'alaw') {\n        const alawOriginData = new Uint8Array(arraybuffer);\n        const decodeAlaw = alawmulaw.alaw.decode(alawOriginData);\n        audioBuffer = parseAlawPcmToAudioData(decodeAlaw.buffer);\n      } else {\n        const audioCtx = new AudioContext();\n        audioBuffer = await audioCtx.decodeAudioData(arraybuffer);\n      }\n      if (audioBuffer) {\n        this.channelCount = audioBuffer.numberOfChannels;\n        this.visibleChannelCount = this.channelCount;\n        this.buffer = audioBuffer;\n        this.setSourceBuffer();\n        this.fireEvent('load');\n        this.init();\n      }\n    };\n    this.redraw = type => {\n      const {\n        clientWidth\n      } = this.params.container;\n      if (this.width !== clientWidth && type === DrawType.RESIZE || type !== DrawType.RESIZE) {\n        const {\n          start,\n          end\n        } = this.displayRange;\n        this.width = clientWidth;\n        const length = this.pxPerSec * this.width;\n        this.setLength(clientWidth);\n        this.initPeaks(length, Math.floor(length * start), Math.floor(length * end));\n      }\n      if (this.drawer) {\n        this.drawBuffer();\n      }\n    };\n    this.scroll = ({\n      start,\n      end\n    }) => {\n      this.displayRange = {\n        start,\n        end\n      };\n      this.center = (start + end) / 2;\n      this.redraw(DrawType.SCROLL);\n    };\n    this.params = {\n      container,\n      audioRate: 1,\n      autoCenter: true,\n      waveColor: '#A1A1A1',\n      disabledColor: '#A2A2A3',\n      backgroundColor: '#343846',\n      selectedBackgoundColor: '#000000',\n      cursorColor: '#34CBD1',\n      cursorWidth: 1,\n      duration: 0,\n      zoomEnabled: true,\n      mediaType: 'audio',\n      normalize: true,\n      pixelRatio: 1,\n      splitChannels: false,\n      ...options\n    };\n    if (source) {\n      this.loadBuffer(source);\n    }\n  }\n  // copy audiobuffer use for offset\n  setSourceBuffer() {\n    if (this.buffer) {\n      this.sourceBuffer = new AudioBuffer({\n        numberOfChannels: this.buffer.numberOfChannels,\n        sampleRate: this.buffer.sampleRate,\n        length: this.buffer.length\n      });\n      for (let i = 0; i < this.channelCount; i += 1) {\n        this.sourceBuffer.copyToChannel(this.buffer.getChannelData(i), i, 0);\n      }\n    }\n  }\n\n  // offset channel\n  handleOffsetChannel(channel, seconds, type = OffsetType.CHANNEL) {\n    if (this.buffer && this.sourceBuffer) {\n      const offset = seconds + seconds + this.offsetOverall;\n      const frameCount = Math.abs(this.sourceBuffer.sampleRate * offset);\n      const fillArray = new Float32Array(frameCount);\n      const audioChannelBuffer = this.sourceBuffer.getChannelData(channel);\n      const result = new Float32Array(audioChannelBuffer.length);\n      if (offset > 0) {\n        const channelArray = audioChannelBuffer.slice(0, audioChannelBuffer.length - frameCount);\n        result.set(fillArray, 0);\n        result.set(channelArray, fillArray.length);\n      } else if (offset < 0) {\n        const channelArray = audioChannelBuffer.slice(frameCount);\n        result.set(channelArray, 0);\n        result.set(fillArray, channelArray.length);\n      } else {\n        result.set(audioChannelBuffer, 0);\n      }\n      this.pause();\n      this.setCurrentTime(0);\n      this.buffer.copyToChannel(result, channel, 0);\n      if (type === OffsetType.CHANNEL) {\n        this.offsetChannels[channel] = seconds;\n        this.handleOffset();\n      }\n    }\n  }\n  handleOffsetOverall(seconds) {\n    this.offsetOverall = seconds;\n    for (let i = 0; i < this.channelCount; i += 1) {\n      this.handleOffsetChannel(i, this.offsetChannels[i] || 0, OffsetType.OVERALL);\n    }\n    this.handleOffset();\n  }\n  handleOffset() {\n    var _this$backend;\n    (_this$backend = this.backend) === null || _this$backend === void 0 ? void 0 : _this$backend.load(this.buffer);\n    this.redraw(DrawType.INIT);\n  }\n  init() {\n    var _this$backend2;\n    this.createBackend();\n    this.createDrawer();\n    (_this$backend2 = this.backend) === null || _this$backend2 === void 0 ? void 0 : _this$backend2.load(this.buffer);\n    this.registerPlugins(this.params.plugins);\n    this.isReady = true;\n    this.fireEvent('ready', this.channelCount);\n    this.redraw(DrawType.INIT);\n    this.on('redraw', () => {\n      this.redraw(DrawType.RESIZE);\n    });\n  }\n  setHeight(height) {\n    this.height = height;\n  }\n  createDrawer() {\n    const {\n      container,\n      backgroundColor,\n      selectedBackgoundColor,\n      pixelRatio,\n      splitChannels,\n      splitChannelsOptions,\n      channels\n    } = this.params;\n    this.drawer = new WaveDrawer({\n      wave: this,\n      container,\n      backgroundColor,\n      selectedBackgoundColor,\n      pixelRatio,\n      splitChannels,\n      splitChannelsOptions,\n      channels,\n      normalize: this.params.normalize\n    });\n    this.setDrawIndex([]);\n  }\n\n  /**\n   * Get the correct peaks for current wave view-port and render wave\n   *\n   * @private\n   */\n  drawBuffer() {\n    var _this$drawer;\n    const peaks = this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;\n    (_this$drawer = this.drawer) === null || _this$drawer === void 0 ? void 0 : _this$drawer.drawPeaks(peaks, this.width, this.height);\n    this.fireEvent('draw', this.displayRange);\n  }\n  getDuration() {\n    var _this$backend3;\n    return ((_this$backend3 = this.backend) === null || _this$backend3 === void 0 ? void 0 : _this$backend3.getDuration()) || 0;\n  }\n\n  // Set the rendered length (different from the length of the audio)\n  setLength(length) {\n    // No resize, we can preserve the cached peaks.\n    if (this.mergedPeaks && length === 2 * this.mergedPeaks.length - 1 + 2) {\n      return;\n    }\n    this.splitPeaks = [];\n    this.mergedPeaks = [];\n    // Set the last element of the sparse array so the peak arrays are\n    // appropriately sized for other calculations.\n    const channels = this.buffer ? this.buffer.numberOfChannels : 1;\n    let c;\n    for (c = 0; c < channels; c += 1) {\n      this.splitPeaks[c] = [];\n      this.splitPeaks[c][2 * (length - 1)] = 0;\n      this.splitPeaks[c][2 * (length - 1) + 1] = 0;\n    }\n    this.mergedPeaks[2 * (length - 1)] = 0;\n    this.mergedPeaks[2 * (length - 1) + 1] = 0;\n  }\n\n  // Compute the max and min value of the waveform when broken into <length> subranges.\n  initPeaks(length, _first, _last) {\n    if (!this.buffer) {\n      return;\n    }\n    const first = _first || 0;\n    const last = _last || length - 1;\n    const sampleSize = this.buffer.length / length;\n    const sampleStep = ~~(sampleSize / 10) || 1;\n    const channels = this.buffer.numberOfChannels;\n    let c;\n    for (c = 0; c < channels; c += 1) {\n      const peaks = this.splitPeaks[c];\n      const chan = this.buffer.getChannelData(c);\n      let i;\n      for (i = first; i <= last; i += 1) {\n        const start = ~~(i * sampleSize);\n        const end = ~~(start + sampleSize);\n        /**\n         * Initialize the max and min to the first sample of this\n         * subrange, so that even if the samples are entirely\n         * on one side of zero, we still return the true max and\n         * min values in the subrange.\n         */\n        let min = chan[start];\n        let max = min;\n        let j;\n        for (j = start; j < end; j += sampleStep) {\n          const value = chan[j];\n          if (value > max) {\n            max = value;\n          }\n          if (value < min) {\n            min = value;\n          }\n        }\n        const n = i - first;\n        peaks[2 * n] = max;\n        peaks[2 * n + 1] = min;\n        if (c === 0 || max > this.mergedPeaks[2 * n]) {\n          this.mergedPeaks[2 * n] = max;\n        }\n        if (c === 0 || min < this.mergedPeaks[2 * n + 1]) {\n          this.mergedPeaks[2 * n + 1] = min;\n        }\n      }\n    }\n  }\n  zoom(pxPerSec = 1, cursorPrecent) {\n    const {\n      start\n    } = this.displayRange;\n    let newstart = start + (pxPerSec - this.pxPerSec) / pxPerSec * (cursorPrecent - start);\n    newstart = newstart <= 0 ? 0 : newstart;\n    let newend = newstart + 1 / pxPerSec;\n    if (newend >= 1) {\n      newend = 1;\n      newstart = newend - 1 / pxPerSec;\n    }\n    this.displayRange = {\n      start: newstart,\n      end: newend\n    };\n    this.pxPerSec = pxPerSec;\n    this.center = (newstart + newend) / 2;\n    this.fireEvent('zoom', this.displayRange);\n    this.redraw(DrawType.ZOOM);\n  }\n\n  /**\n   * Add and initialise array of plugins,\n   * this function is called in the init function of wavesurfer\n   */\n  registerPlugins(plugins) {\n    if (plugins) {\n      const names = Object.keys(plugins);\n      // first instantiate all the plugins\n      names.forEach(name => this.addPlugin(name, plugins[name]));\n\n      // now run the init functions\n      names.forEach(name => {\n        // in that case you would manually use initPlugins()\n        this.initPlugin(name);\n      });\n      this.fireEvent('plugins-registered', plugins);\n    }\n    return this;\n  }\n\n  /**\n   * Add a plugin object to wavesurfer\n   */\n  addPlugin(name, options) {\n    if (!name) {\n      throw new Error('Plugin does not have a name!');\n    }\n    if (!options) {\n      throw new Error(`Plugin ${name} is missing required parameters!`);\n    }\n    if (Object.keys(PluginType).indexOf(name.toUpperCase()) < 0) {\n      throw new Error(`Plugin ${name} does not have an instance property!`);\n    }\n\n    /**\n     * Instantiated plugin classes are added as a property of the wavesurfer\n     * instance\n     * @type {Object}\n     */\n    if (name === PluginType.TIMELINE) {\n      this.plugins.timeline = new TimelinePlugin(options);\n    } else if (name === PluginType.REGION) {\n      this.plugins.region = new RegionPlugin(options);\n    } else if (name === PluginType.ANALYSE) {\n      this.plugins.analyse = new AnalysePlugin(options);\n    }\n    this.fireEvent('plugin-added', name);\n    return this;\n  }\n\n  // Initialise a plugin\n  initPlugin(name) {\n    var _this$plugins$name;\n    if (!this.plugins[name]) {\n      throw new Error(`Plugin ${name} has not been added yet!`);\n    }\n    if (this.initialisedPluginList[name]) {\n      // destroy any already initialised plugins\n      this.destroyPlugin(name);\n    }\n    (_this$plugins$name = this.plugins[name]) === null || _this$plugins$name === void 0 ? void 0 : _this$plugins$name.init(this);\n    this.initialisedPluginList[name] = true;\n    this.fireEvent('plugin-initialised', name);\n    return this;\n  }\n\n  // Destroy a plugin\n  destroyPlugin(name) {\n    if (!this.plugins[name] || !this.plugins[name]) {\n      throw new Error(`Plugin ${name} has not been added yet and cannot be destroyed!`);\n    }\n    if (!this.initialisedPluginList[name]) {\n      throw new Error(`Plugin ${name} is not active and cannot be destroyed!`);\n    }\n    if (typeof this.plugins[name].destroy !== 'function') {\n      throw new Error(`Plugin ${name} does not have a destroy function!`);\n    }\n    this.plugins[name].destroy();\n    delete this.initialisedPluginList[name];\n    this.fireEvent('plugin-destroyed', name);\n    return this;\n  }\n\n  /**\n   * Destroy all initialised plugins. Convenience function to use when\n   * wavesurfer is removed\n   */\n  destroyAllPlugins() {\n    Object.keys(this.initialisedPluginList).forEach(name => this.destroyPlugin(name));\n  }\n\n  /**\n   * Create the backend\n   *\n   * @private\n   * @emits WaveSurfer#backend-created\n   */\n  createBackend() {\n    var _this$backend5, _this$backend6, _this$backend7, _this$backend8, _this$backend9;\n    if (this.backend) {\n      var _this$backend4;\n      (_this$backend4 = this.backend) === null || _this$backend4 === void 0 ? void 0 : _this$backend4.destroy();\n    }\n    this.backend = new WebAudio({\n      ...this.params,\n      wave: this\n    });\n    (_this$backend5 = this.backend) === null || _this$backend5 === void 0 ? void 0 : _this$backend5.init();\n    this.fireEvent('backend-created', this.backend);\n    (_this$backend6 = this.backend) === null || _this$backend6 === void 0 ? void 0 : _this$backend6.on('finish', () => {\n      this.fireEvent('finish');\n    });\n    (_this$backend7 = this.backend) === null || _this$backend7 === void 0 ? void 0 : _this$backend7.on('play', () => {\n      this.fireEvent('play');\n      if (this.plugins.timeline.currentTimeLine) {\n        setStyle(this.plugins.timeline.currentTimeLine, {\n          opacity: '1'\n        });\n      }\n    });\n    (_this$backend8 = this.backend) === null || _this$backend8 === void 0 ? void 0 : _this$backend8.on('pause', () => {\n      this.fireEvent('pause');\n      if (this.plugins.timeline.currentTimeLine) {\n        setStyle(this.plugins.timeline.currentTimeLine, {\n          opacity: '0'\n        });\n      }\n    });\n    (_this$backend9 = this.backend) === null || _this$backend9 === void 0 ? void 0 : _this$backend9.on('audioprocess', time => {\n      var _ref;\n      (_ref = this.plugins.timeline) === null || _ref === void 0 ? void 0 : _ref.renderTimeline();\n      this.fireEvent('audioprocess', time);\n    });\n  }\n\n  /**\n   * Get the current playback position\n   */\n  getCurrentTime() {\n    var _this$backend0;\n    return ((_this$backend0 = this.backend) === null || _this$backend0 === void 0 ? void 0 : _this$backend0.getCurrentTime()) || 0;\n  }\n  moveCurrentTime(duration) {\n    this.setCurrentTime(this.getCurrentTime() + duration);\n  }\n\n  /**\n   * Set the current play time in seconds.\n   */\n  setCurrentTime(_seconds) {\n    var _ref2;\n    const duration = this.getDuration();\n    let seconds = _seconds;\n    if (seconds >= duration) {\n      seconds = duration;\n    } else if (seconds < 0) {\n      seconds = 0;\n    }\n    this.seekTo(seconds / this.getDuration());\n    this.fireEvent('change-time', seconds);\n    (_ref2 = this.plugins.timeline) === null || _ref2 === void 0 ? void 0 : _ref2.renderTimeline();\n  }\n\n  /**\n   * Starts playback from the current position. Optional start and end\n   * measured in seconds can be used to set the range of audio to play.\n   *\n   * @param {?number} start Position to start at\n   * @param {?number} end Position to end at\n   * @emits WaveSurfer#interaction\n   * @return {Promise} Result of the backend play method\n   * @example\n   * // play from second 1 to 5\n   * wavesurfer.play(1, 5);\n   */\n  play(start, end) {\n    return this.soloPlay(undefined, start, end);\n  }\n  soloPlay(channelIndex, start, end) {\n    var _this$backend1;\n    if (this.getCurrentTime() === this.getDuration()) {\n      this.setCurrentTime(0);\n    }\n    this.setChannelOptions(this.channelOptions, channelIndex !== undefined, channelIndex);\n    this.fireEvent('interaction', () => this.play(start, end));\n    return (_this$backend1 = this.backend) === null || _this$backend1 === void 0 ? void 0 : _this$backend1.play(start, end);\n  }\n\n  /**\n   * Set a point in seconds for playback to stop at.\n   *\n   * @param {number} position Position (in seconds) to stop at\n   */\n  setPlayEnd(position) {\n    var _this$backend10;\n    (_this$backend10 = this.backend) === null || _this$backend10 === void 0 ? void 0 : _this$backend10.setPlayEnd(position);\n  }\n\n  /**\n   * Stops and pauses playback\n   *\n   * @example wavesurfer.pause();\n   * @return {Promise} Result of the backend pause method\n   */\n  pause() {\n    var _this$backend11;\n    if (!((_this$backend11 = this.backend) === null || _this$backend11 === void 0 ? void 0 : _this$backend11.isPaused())) {\n      var _this$backend12;\n      return (_this$backend12 = this.backend) === null || _this$backend12 === void 0 ? void 0 : _this$backend12.pause();\n    }\n  }\n\n  /**\n   * Toggle playback\n   *\n   * @example wavesurfer.playPause();\n   * @return {Promise} Result of the backend play or pause method\n   */\n  playPause() {\n    var _this$backend13;\n    return ((_this$backend13 = this.backend) === null || _this$backend13 === void 0 ? void 0 : _this$backend13.isPaused()) ? this.play() : this.pause();\n  }\n\n  /**\n  * Get the current playback state\n  *\n  * @example const isPlaying = wavesurfer.isPlaying();\n  * @return {boolean} False if paused, true if playing\n  */\n  isPlaying() {\n    var _this$backend14;\n    return !((_this$backend14 = this.backend) === null || _this$backend14 === void 0 ? void 0 : _this$backend14.isPaused());\n  }\n\n  /**\n  * Skip backward\n  *\n  * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n  * is used\n  * @example wavesurfer.skipBackward();\n  */\n  skipBackward(seconds) {\n    this.skip(-(seconds || 0));\n  }\n\n  /**\n  * Skip forward\n  *\n  * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n  * is used\n  * @example wavesurfer.skipForward();\n  */\n  skipForward(seconds) {\n    this.skip(seconds);\n  }\n\n  /**\n   * Skip a number of seconds from the current position (use a negative value\n   * to go backwards).\n   *\n   * @param {number} offset Amount to skip back or forwards\n   * @example\n   * // go back 2 seconds\n   * wavesurfer.skip(-2);\n   */\n  skip(offset) {\n    const duration = this.getDuration() || 1;\n    let position = this.getCurrentTime() || 0;\n    position = Math.max(0, Math.min(duration, position + (offset || 0)));\n    this.seekAndCenter(position / duration);\n  }\n\n  /**\n   * Seeks to a position and centers the view\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @example\n   * // seek and go to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekAndCenter(progress) {\n    this.seekTo(progress);\n  }\n\n  /**\n   * Seeks to a position\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @emits WaveSurfer#interaction\n   * @emits WaveSurfer#seek\n   * @example\n   * // seek to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekTo(progress) {\n    var _this$backend15, _this$backend17;\n    this.fireEvent('interaction', () => this.seekTo(progress));\n    const paused = (_this$backend15 = this.backend) === null || _this$backend15 === void 0 ? void 0 : _this$backend15.isPaused();\n    if (!paused) {\n      var _this$backend16;\n      (_this$backend16 = this.backend) === null || _this$backend16 === void 0 ? void 0 : _this$backend16.pause();\n    }\n\n    // avoid small scrolls while paused seeking\n    (_this$backend17 = this.backend) === null || _this$backend17 === void 0 ? void 0 : _this$backend17.seekTo(progress * this.getDuration(), undefined);\n    if (!paused) {\n      var _this$backend18;\n      (_this$backend18 = this.backend) === null || _this$backend18 === void 0 ? void 0 : _this$backend18.play(undefined, undefined);\n    }\n    this.fireEvent('seek', progress);\n  }\n\n  /**\n   * Stops and goes to the beginning.\n   *\n   * @example wavesurfer.stop();\n   */\n  stop() {\n    this.pause();\n    this.seekTo(0);\n  }\n\n  /**\n   * Sets the ID of the audio device to use for output and returns a Promise.\n   *\n   * @param {string} deviceId String value representing underlying output\n   * device\n   * @returns {Promise} `Promise` that resolves to `undefined` when there are\n   * no errors detected.\n   */\n  setSinkId(deviceId) {\n    var _this$backend19;\n    return (_this$backend19 = this.backend) === null || _this$backend19 === void 0 ? void 0 : _this$backend19.setSinkId(deviceId);\n  }\n\n  /**\n   * Set the playback volume.\n   *\n   * @param {number} newVolume A value between 0 and 1, 0 being no\n   * @param {number} channelIndex channel index\n   * volume and 1 being full volume.\n   * @emits WaveSurfer#volume\n   */\n  setVolume(newVolume, channelIndex) {\n    var _this$backend20;\n    (_this$backend20 = this.backend) === null || _this$backend20 === void 0 ? void 0 : _this$backend20.setVolume(newVolume, channelIndex);\n    this.fireEvent('volume', newVolume);\n  }\n\n  /**\n   * Get the playback volume.\n   *\n   * @return {number} A value between 0 and 1, 0 being no\n   * volume and 1 being full volume.\n   */\n  getVolume() {\n    var _this$backend21;\n    return (_this$backend21 = this.backend) === null || _this$backend21 === void 0 ? void 0 : _this$backend21.getVolume();\n  }\n\n  /**\n   * Set the playback rate.\n   *\n   * @param {number} rate A positive number. E.g. 0.5 means half the normal\n   * speed, 2 means double speed and so on.\n   * @example wavesurfer.setPlaybackRate(2);\n   */\n  setPlaybackRate(rate) {\n    var _this$backend22, _this$backend23;\n    const scheduledPause = (_this$backend22 = this.backend) === null || _this$backend22 === void 0 ? void 0 : _this$backend22.scheduledPause;\n    const currentTime = this.getCurrentTime();\n    (_this$backend23 = this.backend) === null || _this$backend23 === void 0 ? void 0 : _this$backend23.setPlaybackRate(rate);\n    this.setCurrentTime(currentTime);\n    if (scheduledPause) {\n      this.setPlayEnd(scheduledPause);\n    }\n  }\n\n  /**\n   * Get the playback rate.\n   *\n   * @return {number} The current playback rate.\n   */\n  getPlaybackRate() {\n    var _this$backend24;\n    return (_this$backend24 = this.backend) === null || _this$backend24 === void 0 ? void 0 : _this$backend24.getPlaybackRate();\n  }\n  getPlayEnd() {\n    var _this$backend25;\n    return (_this$backend25 = this.backend) === null || _this$backend25 === void 0 ? void 0 : _this$backend25.getPlayEnd();\n  }\n\n  /**\n   * Toggle the volume on and off. If not currently muted it will save the\n   * current volume value and turn the volume off. If currently muted then it\n   * will restore the volume to the saved value, and then rest the saved\n   * value.\n   *\n   * @example wavesurfer.toggleMute();\n   */\n  toggleMute(channelIndex) {\n    this.setMute(!this.isMuted, channelIndex);\n  }\n\n  /**\n   * Enable or disable muted audio\n   *\n   * @param {boolean} mute Specify `true` to mute audio.\n   * @param {number} channelIndex\n   * @emits WaveSurfer#volume\n   * @emits WaveSurfer#mute\n   * @example\n   * // unmute\n   * wavesurfer.setMute(false);\n   * console.log(wavesurfer.getMute()) // logs false\n   */\n  setMute(mute, channelIndex) {\n    // ignore all muting requests if the audio is already in that state\n    if (mute === this.isMuted) {\n      this.fireEvent('mute', this.isMuted);\n      return;\n    }\n    if (mute) {\n      var _this$backend26, _this$backend27;\n      // If currently not muted then save current volume,\n      // turn off the volume and update the mute properties\n      this.savedVolume = ((_this$backend26 = this.backend) === null || _this$backend26 === void 0 ? void 0 : _this$backend26.getVolume()) || 0;\n      (_this$backend27 = this.backend) === null || _this$backend27 === void 0 ? void 0 : _this$backend27.setVolume(0, channelIndex);\n      this.isMuted = true;\n      this.fireEvent('volume', 0);\n    } else {\n      var _this$backend28;\n      // If currently muted then restore to the saved volume\n      // and update the mute properties\n      (_this$backend28 = this.backend) === null || _this$backend28 === void 0 ? void 0 : _this$backend28.setVolume(this.savedVolume, channelIndex);\n      this.isMuted = false;\n      this.fireEvent('volume', this.savedVolume);\n    }\n    this.fireEvent('mute', this.isMuted);\n  }\n\n  /**\n  * Get the current mute status.\n  *\n  * @example const isMuted = wavesurfer.getMute();\n  * @return {boolean} Current mute status\n  */\n  getMute() {\n    return this.isMuted;\n  }\n\n  /**\n   * Remove events, elements and disconnect WebAudio nodes.\n   *\n   * @emits WaveSurfer#destroy\n   */\n  destroy() {\n    this.destroyAllPlugins();\n    this.fireEvent('destroy');\n    this.isDestroyed = true;\n    this.isReady = false;\n    this.buffer = null;\n  }\n  setHideChannels(hideChannels) {\n    this.setDrawIndex(hideChannels);\n    this.redraw(DrawType.RESIZE);\n  }\n  setDrawIndex(hideChannels) {\n    var _this$drawer2;\n    this.hideChannels = hideChannels;\n    const channels = Array.from({\n      length: this.channelCount\n    }).map((v, i) => i);\n    const filteredChannels = channels.filter(v => hideChannels.indexOf(v) < 0);\n    const drawIndex = {};\n    channels.forEach(i => {\n      drawIndex[i] = filteredChannels.indexOf(i);\n    });\n    (_this$drawer2 = this.drawer) === null || _this$drawer2 === void 0 ? void 0 : _this$drawer2.setDrawIndex(drawIndex);\n    this.visibleChannelCount = filteredChannels.length;\n  }\n  setChannelOptions(options, isSolo, channelIndex) {\n    this.channelOptions = options;\n    options.forEach(({\n      volume,\n      mute,\n      index\n    }) => {\n      var _this$backend29;\n      const isMute = mute || isSolo && channelIndex !== undefined && index !== channelIndex;\n      (_this$backend29 = this.backend) === null || _this$backend29 === void 0 ? void 0 : _this$backend29.setVolume(isMute ? 0 : volume, index);\n    });\n  }\n}","map":{"version":3,"names":["alawmulaw","WaveDrawer","WavDecoder","Observer","WebAudio","setStyle","TimelinePlugin","RegionPlugin","AnalysePlugin","parseAlawPcmToAudioData","DrawType","PluginType","OffsetType","Wave","constructor","container","source","options","isReady","params","peaks","drawer","isDestroyed","arraybuffer","ArrayBuffer","sourceBuffer","buffer","splitPeaks","mergedPeaks","channelCount","pxPerSec","currentTime","width","height","center","displayRange","start","end","plugins","initialisedPluginList","backend","isMuted","savedVolume","hideChannels","visibleChannelCount","channelOptions","offsetOverall","offsetChannels","loadBuffer","url","tail","split","pop","arrayBuffer","fetch","then","data","loadArrayBuffer","format","audioBuffer","decodeData","decodeSync","AudioBuffer","numberOfChannels","sampleRate","length","i","audioChannelBuffer","getChannelData","j","channelData","alawOriginData","Uint8Array","decodeAlaw","alaw","decode","audioCtx","AudioContext","decodeAudioData","setSourceBuffer","fireEvent","init","redraw","type","clientWidth","RESIZE","setLength","initPeaks","Math","floor","drawBuffer","scroll","SCROLL","audioRate","autoCenter","waveColor","disabledColor","backgroundColor","selectedBackgoundColor","cursorColor","cursorWidth","duration","zoomEnabled","mediaType","normalize","pixelRatio","splitChannels","copyToChannel","handleOffsetChannel","channel","seconds","CHANNEL","offset","frameCount","abs","fillArray","Float32Array","result","channelArray","slice","set","pause","setCurrentTime","handleOffset","handleOffsetOverall","OVERALL","_this$backend","load","INIT","_this$backend2","createBackend","createDrawer","registerPlugins","on","setHeight","splitChannelsOptions","channels","wave","setDrawIndex","_this$drawer","drawPeaks","getDuration","_this$backend3","c","_first","_last","first","last","sampleSize","sampleStep","chan","min","max","value","n","zoom","cursorPrecent","newstart","newend","ZOOM","names","Object","keys","forEach","name","addPlugin","initPlugin","Error","indexOf","toUpperCase","TIMELINE","timeline","REGION","region","ANALYSE","analyse","_this$plugins$name","destroyPlugin","destroy","destroyAllPlugins","_this$backend5","_this$backend6","_this$backend7","_this$backend8","_this$backend9","_this$backend4","currentTimeLine","opacity","time","_ref","renderTimeline","getCurrentTime","_this$backend0","moveCurrentTime","_seconds","_ref2","seekTo","play","soloPlay","undefined","channelIndex","_this$backend1","setChannelOptions","setPlayEnd","position","_this$backend10","_this$backend11","isPaused","_this$backend12","playPause","_this$backend13","isPlaying","_this$backend14","skipBackward","skip","skipForward","seekAndCenter","progress","_this$backend15","_this$backend17","paused","_this$backend16","_this$backend18","stop","setSinkId","deviceId","_this$backend19","setVolume","newVolume","_this$backend20","getVolume","_this$backend21","setPlaybackRate","rate","_this$backend22","_this$backend23","scheduledPause","getPlaybackRate","_this$backend24","getPlayEnd","_this$backend25","toggleMute","setMute","mute","_this$backend26","_this$backend27","_this$backend28","getMute","setHideChannels","_this$drawer2","Array","from","map","v","filteredChannels","filter","drawIndex","isSolo","volume","index","_this$backend29","isMute"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/common/Wave/index.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport * as alawmulaw from 'alawmulaw';\nimport WaveDrawer from './waveDrawer';\nimport WavDecoder from './utils/wav-decoder';\nimport Observer from './utils/observer';\nimport WebAudio from './webaudio';\nimport { setStyle } from './utils';\nimport TimelinePlugin, { TimelineOptions } from './Timeline';\nimport RegionPlugin, { RegionOptions } from './Region';\nimport AnalysePlugin, { AnalyseOptions } from './Analyse';\nimport { parseAlawPcmToAudioData } from '../../../../utils/pcm';\nimport { ChannelOptions, Channel, CustomChannelOptions } from './types';\n\nexport enum DrawType {\n  INIT = 'init',\n  RESIZE = 'resize',\n  SCROLL = 'scroll',\n  ZOOM = 'zoom',\n}\n\nexport enum PluginType {\n  TIMELINE = 'timeline',\n  REGION = 'region',\n  ANALYSE = 'analyse',\n};\n\nexport enum OffsetType {\n  OVERALL = 'overall',\n  CHANNEL = 'channel',\n}\n\ntype PluginOptions = TimelineOptions | RegionOptions | AnalyseOptions;\n\nexport type Plugins = {\n  [PluginType.REGION]?: RegionPlugin,\n  [PluginType.TIMELINE]?: TimelinePlugin,\n  [PluginType.ANALYSE]?: AnalysePlugin,\n};\n\ninterface WaveOptions {\n  container: HTMLElement;\n  source?: string;\n  audioContext: AudioContext;\n  audioRate?: number;\n  autoCenter?: boolean;\n  waveColor?: string;\n  disabledColor?: string;\n  backgroundColor?: string;\n  selectedBackgoundColor?: string;\n  cursorColor?: string;\n  cursorWidth?: number;\n  duration?: number;\n  height?: number;\n  zoomEnabled?: boolean;\n  scrollEnabled?: boolean;\n  mediaType?: string;\n  normalize?: boolean;\n  pixelRatio?: number;\n  splitChannels?: boolean;\n  splitChannelsOptions?: ChannelOptions;\n  channels: Channel[];\n  plugins?: {[key in PluginType]?: PluginOptions};\n}\n\ninterface WaveParams {\n  container: HTMLElement;\n  audioContext: AudioContext;\n  audioRate: number;\n  autoCenter: boolean;\n  waveColor: string;\n  disabledColor: string;\n  backgroundColor: string;\n  selectedBackgoundColor: string;\n  cursorColor: string;\n  cursorWidth: number;\n  duration: number;\n  zoomEnabled: boolean;\n  mediaType: string;\n  normalize: boolean;\n  pixelRatio: number;\n  splitChannels: boolean;\n  splitChannelsOptions?: ChannelOptions;\n  channels: Channel[];\n  plugins?: {[key in PluginType]?: PluginOptions};\n}\n\nexport default class Wave extends Observer {\n  isReady = false;\n\n  params: WaveParams;\n\n  /**\n   * draw peaks\n   */\n  peaks: number[] | number[][] = [];\n\n  drawer?: WaveDrawer;\n\n  isDestroyed = false;\n\n  /**\n   * source file arraybuffer\n   */\n  arraybuffer: ArrayBuffer = new ArrayBuffer(0);\n\n  /**\n   * source file audiobuffer\n   */\n  sourceBuffer: AudioBuffer | null = null;\n\n  /**\n   * draw audiobuffer\n   */\n  buffer: AudioBuffer | null = null;\n\n  /**\n   * multi channels peaks\n   */\n  splitPeaks: number[][] = [];\n\n  /**\n   * merged channel peaks\n   */\n  mergedPeaks: number[] = [];\n\n  /**\n   * chanel count\n   */\n  channelCount = 0;\n\n  /**\n   * zoom\n   */\n  pxPerSec = 1;\n\n  /**\n   * selected time\n   */\n  currentTime = 0;\n\n  /**\n   * wave width\n   */\n  width = 0;\n\n  /**\n   * wave height\n   */\n  height = 0;\n\n  /**\n   * waveform center\n   */\n  center = 0.5;\n\n  /**\n   * visible range precent\n   */\n  displayRange = {\n    start: 0,\n    end: 1,\n  };\n\n  /**\n   * wave plugins\n   */\n  plugins: Plugins = {};\n\n  initialisedPluginList: {[key in PluginType]?: boolean} = {};\n\n  backend?: WebAudio;\n\n  isMuted = false;\n\n  // Used to save the current volume when muting so we can\n  savedVolume = 0;\n\n  hideChannels: number[] = [];\n\n  visibleChannelCount = 0;\n\n  channelOptions: CustomChannelOptions[] = [];\n\n  offsetOverall = 0;\n\n  offsetChannels: number[] = [];\n\n  constructor({ container, source, ...options }: WaveOptions) {\n    super();\n    this.params = {\n      container,\n      audioRate: 1,\n      autoCenter: true,\n      waveColor: '#A1A1A1',\n      disabledColor: '#A2A2A3',\n      backgroundColor: '#343846',\n      selectedBackgoundColor: '#000000',\n      cursorColor: '#34CBD1',\n      cursorWidth: 1,\n      duration: 0,\n      zoomEnabled: true,\n      mediaType: 'audio',\n      normalize: true,\n      pixelRatio: 1,\n      splitChannels: false,\n      ...options,\n    };\n    if (source) {\n      this.loadBuffer(source);\n    }\n  }\n\n  // Loads audio using Web Audio buffer backend.\n  loadBuffer = async (url: string) => {\n    const tail = url.split('.').pop();\n    const arrayBuffer = await fetch(url)\n      .then((data) => data.arrayBuffer());\n    this.loadArrayBuffer(arrayBuffer, tail);\n  };\n\n  // Decode buffer and load\n  loadArrayBuffer = async (arraybuffer: ArrayBuffer, format?: string) => {\n    this.arraybuffer = arraybuffer;\n    let audioBuffer: AudioBuffer | null = null;\n    if (format === 'wav') {\n      const decodeData = WavDecoder.decodeSync(arraybuffer);\n      audioBuffer = new AudioBuffer({\n        numberOfChannels: decodeData.numberOfChannels,\n        sampleRate: decodeData.sampleRate,\n        length: decodeData.length,\n      });\n      for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n        const audioChannelBuffer = audioBuffer.getChannelData(i);\n        for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n          audioChannelBuffer[j] = decodeData.channelData[i][j];\n        }\n      }\n    } else if (format === 'alaw') {\n      const alawOriginData = new Uint8Array(arraybuffer);\n      const decodeAlaw = alawmulaw.alaw.decode(alawOriginData);\n      audioBuffer = parseAlawPcmToAudioData(decodeAlaw.buffer);\n    } else {\n      const audioCtx = new AudioContext();\n      audioBuffer = await audioCtx.decodeAudioData(arraybuffer);\n    }\n    if (audioBuffer) {\n      this.channelCount = audioBuffer.numberOfChannels;\n      this.visibleChannelCount = this.channelCount;\n      this.buffer = audioBuffer;\n      this.setSourceBuffer();\n      this.fireEvent('load');\n      this.init();\n    }\n  };\n\n  // copy audiobuffer use for offset\n  setSourceBuffer() {\n    if (this.buffer) {\n      this.sourceBuffer = new AudioBuffer({\n        numberOfChannels: this.buffer.numberOfChannels,\n        sampleRate: this.buffer.sampleRate,\n        length: this.buffer.length,\n      });\n      for (let i = 0; i < this.channelCount; i += 1) {\n        this.sourceBuffer.copyToChannel(this.buffer.getChannelData(i), i, 0);\n      }\n    }\n  }\n\n  // offset channel\n  handleOffsetChannel(channel: number, seconds: number, type = OffsetType.CHANNEL) {\n    if (this.buffer && this.sourceBuffer) {\n      const offset = seconds + seconds + this.offsetOverall;\n      const frameCount = Math.abs(this.sourceBuffer.sampleRate * offset);\n      const fillArray = new Float32Array(frameCount);\n      const audioChannelBuffer = this.sourceBuffer.getChannelData(channel);\n      const result = new Float32Array(audioChannelBuffer.length);\n      if (offset > 0) {\n        const channelArray = audioChannelBuffer.slice(0, audioChannelBuffer.length - frameCount);\n        result.set(fillArray, 0);\n        result.set(channelArray, fillArray.length);\n      } else if (offset < 0) {\n        const channelArray = audioChannelBuffer.slice(frameCount);\n        result.set(channelArray, 0);\n        result.set(fillArray, channelArray.length);\n      } else {\n        result.set(audioChannelBuffer, 0);\n      }\n      this.pause();\n      this.setCurrentTime(0);\n      this.buffer.copyToChannel(result, channel, 0);\n      if (type === OffsetType.CHANNEL) {\n        this.offsetChannels[channel] = seconds;\n        this.handleOffset();\n      }\n    }\n  }\n\n  handleOffsetOverall(seconds: number) {\n    this.offsetOverall = seconds;\n    for (let i = 0; i < this.channelCount; i += 1) {\n      this.handleOffsetChannel(i, this.offsetChannels[i] || 0, OffsetType.OVERALL);\n    }\n    this.handleOffset();\n  }\n\n  handleOffset() {\n    this.backend?.load(this.buffer!);\n    this.redraw(DrawType.INIT);\n  }\n\n  init() {\n    this.createBackend();\n    this.createDrawer();\n    this.backend?.load(this.buffer!);\n    this.registerPlugins(this.params.plugins);\n    this.isReady = true;\n    this.fireEvent('ready', this.channelCount);\n    this.redraw(DrawType.INIT);\n    this.on('redraw', () => {\n      this.redraw(DrawType.RESIZE);\n    });\n  }\n\n  setHeight(height: number) {\n    this.height = height;\n  }\n\n  redraw = (type?: DrawType) => {\n    const { clientWidth } = this.params.container;\n    if ((this.width !== clientWidth && type === DrawType.RESIZE) || type !== DrawType.RESIZE) {\n      const { start, end } = this.displayRange;\n      this.width = clientWidth;\n      const length = this.pxPerSec * this.width;\n      this.setLength(clientWidth);\n      this.initPeaks(length, Math.floor(length * start), Math.floor(length * end));\n    }\n\n    if (this.drawer) {\n      this.drawBuffer();\n    }\n  };\n\n  scroll = ({ start, end }: { start: number; end: number }) => {\n    this.displayRange = {\n      start,\n      end,\n    };\n    this.center = (start + end) / 2;\n    this.redraw(DrawType.SCROLL);\n  };\n\n  createDrawer() {\n    const {\n      container, backgroundColor, selectedBackgoundColor, pixelRatio,\n      splitChannels, splitChannelsOptions, channels,\n    } = this.params;\n    this.drawer = new WaveDrawer({\n      wave: this,\n      container,\n      backgroundColor,\n      selectedBackgoundColor,\n      pixelRatio,\n      splitChannels,\n      splitChannelsOptions,\n      channels,\n      normalize: this.params.normalize,\n    });\n    this.setDrawIndex([]);\n  }\n\n  /**\n   * Get the correct peaks for current wave view-port and render wave\n   *\n   * @private\n   */\n  drawBuffer() {\n    const peaks = this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;\n    this.drawer?.drawPeaks(peaks, this.width, this.height);\n    this.fireEvent('draw', this.displayRange);\n  }\n\n  getDuration() {\n    return this.backend?.getDuration() || 0;\n  }\n\n  // Set the rendered length (different from the length of the audio)\n  setLength(length: number) {\n    // No resize, we can preserve the cached peaks.\n    if (this.mergedPeaks && length === 2 * this.mergedPeaks.length - 1 + 2) {\n      return;\n    }\n\n    this.splitPeaks = [];\n    this.mergedPeaks = [];\n    // Set the last element of the sparse array so the peak arrays are\n    // appropriately sized for other calculations.\n    const channels = this.buffer ? this.buffer.numberOfChannels : 1;\n    let c;\n    for (c = 0; c < channels; c += 1) {\n      this.splitPeaks[c] = [];\n      this.splitPeaks[c][2 * (length - 1)] = 0;\n      this.splitPeaks[c][2 * (length - 1) + 1] = 0;\n    }\n    this.mergedPeaks[2 * (length - 1)] = 0;\n    this.mergedPeaks[2 * (length - 1) + 1] = 0;\n  }\n\n  // Compute the max and min value of the waveform when broken into <length> subranges.\n  initPeaks(length: number, _first?: number, _last?: number) {\n    if (!this.buffer) {\n      return;\n    }\n    const first = _first || 0;\n    const last = _last || length - 1;\n\n    const sampleSize = this.buffer.length / length;\n    const sampleStep = ~~(sampleSize / 10) || 1;\n    const channels = this.buffer.numberOfChannels;\n    let c;\n\n    for (c = 0; c < channels; c += 1) {\n      const peaks = this.splitPeaks[c];\n      const chan = this.buffer.getChannelData(c);\n      let i;\n      for (i = first; i <= last; i += 1) {\n        const start = ~~(i * sampleSize);\n        const end = ~~(start + sampleSize);\n        /**\n         * Initialize the max and min to the first sample of this\n         * subrange, so that even if the samples are entirely\n         * on one side of zero, we still return the true max and\n         * min values in the subrange.\n         */\n        let min = chan[start];\n        let max = min;\n        let j;\n\n        for (j = start; j < end; j += sampleStep) {\n          const value = chan[j];\n\n          if (value > max) {\n            max = value;\n          }\n\n          if (value < min) {\n            min = value;\n          }\n        }\n        const n = i - first;\n        peaks[2 * n] = max;\n        peaks[2 * n + 1] = min;\n        if (c === 0 || max > this.mergedPeaks[2 * n]) {\n          this.mergedPeaks[2 * n] = max;\n        }\n        if (c === 0 || min < this.mergedPeaks[2 * n + 1]) {\n          this.mergedPeaks[2 * n + 1] = min;\n        }\n      }\n    }\n  }\n\n  zoom(pxPerSec = 1, cursorPrecent: number) {\n    const { start } = this.displayRange;\n    let newstart = start + ((pxPerSec - this.pxPerSec) / pxPerSec) * (cursorPrecent - start);\n    newstart = newstart <= 0 ? 0 : newstart;\n    let newend = newstart + 1 / pxPerSec;\n    if (newend >= 1) {\n      newend = 1;\n      newstart = newend - 1 / pxPerSec;\n    }\n    this.displayRange = {\n      start: newstart,\n      end: newend\n    };\n    this.pxPerSec = pxPerSec;\n    this.center = (newstart + newend) / 2;\n    this.fireEvent('zoom', this.displayRange);\n    this.redraw(DrawType.ZOOM);\n  }\n\n  /**\n   * Add and initialise array of plugins,\n   * this function is called in the init function of wavesurfer\n   */\n  registerPlugins(plugins?: {[key in PluginType]?: PluginOptions}) {\n    if (plugins) {\n      const names = Object.keys(plugins) as PluginType[];\n      // first instantiate all the plugins\n      names.forEach((name) => this.addPlugin(name, plugins[name]));\n\n      // now run the init functions\n      names.forEach((name) => {\n        // in that case you would manually use initPlugins()\n        this.initPlugin(name);\n      });\n      this.fireEvent('plugins-registered', plugins);\n    }\n    return this;\n  }\n\n  /**\n   * Add a plugin object to wavesurfer\n   */\n  addPlugin(name: string, options?: PluginOptions) {\n    if (!name) {\n      throw new Error('Plugin does not have a name!');\n    }\n    if (!options) {\n      throw new Error(`Plugin ${name} is missing required parameters!`);\n    }\n    if (Object.keys(PluginType).indexOf(name.toUpperCase()) < 0) {\n      throw new Error(\n        `Plugin ${name} does not have an instance property!`\n      );\n    }\n\n    /**\n     * Instantiated plugin classes are added as a property of the wavesurfer\n     * instance\n     * @type {Object}\n     */\n    if (name === PluginType.TIMELINE) {\n      this.plugins.timeline = new TimelinePlugin(options as TimelineOptions);\n    } else if (name === PluginType.REGION) {\n      this.plugins.region = new RegionPlugin(options as RegionOptions);\n    } else if (name === PluginType.ANALYSE) {\n      this.plugins.analyse = new AnalysePlugin(options as AnalyseOptions);\n    }\n    this.fireEvent('plugin-added', name);\n    return this;\n  }\n\n  // Initialise a plugin\n  initPlugin(name: PluginType) {\n    if (!this.plugins[name]) {\n      throw new Error(`Plugin ${name} has not been added yet!`);\n    }\n    if (this.initialisedPluginList[name]) {\n      // destroy any already initialised plugins\n      this.destroyPlugin(name);\n    }\n\n    this.plugins[name]?.init(this);\n\n    this.initialisedPluginList[name] = true;\n    this.fireEvent('plugin-initialised', name);\n    return this;\n  }\n\n  // Destroy a plugin\n  destroyPlugin(name: PluginType) {\n    if (!this.plugins[name] || !this.plugins[name]) {\n      throw new Error(\n        `Plugin ${name} has not been added yet and cannot be destroyed!`\n      );\n    }\n    if (!this.initialisedPluginList[name]) {\n      throw new Error(\n        `Plugin ${name} is not active and cannot be destroyed!`\n      );\n    }\n    if (typeof this.plugins[name]!.destroy !== 'function') {\n      throw new Error(`Plugin ${name} does not have a destroy function!`);\n    }\n\n    this.plugins[name]!.destroy();\n    delete this.initialisedPluginList[name];\n    this.fireEvent('plugin-destroyed', name);\n    return this;\n  }\n\n  /**\n   * Destroy all initialised plugins. Convenience function to use when\n   * wavesurfer is removed\n   */\n  destroyAllPlugins() {\n    Object.keys(this.initialisedPluginList).forEach((name) => this.destroyPlugin(name as PluginType));\n  }\n\n  /**\n   * Create the backend\n   *\n   * @private\n   * @emits WaveSurfer#backend-created\n   */\n  createBackend() {\n    if (this.backend) {\n      this.backend?.destroy();\n    }\n\n    this.backend = new WebAudio({\n      ...this.params,\n      wave: this,\n    });\n    this.backend?.init();\n    this.fireEvent('backend-created', this.backend);\n\n    this.backend?.on('finish', () => {\n      this.fireEvent('finish');\n    });\n    this.backend?.on('play', () => {\n      this.fireEvent('play');\n      if ((this.plugins.timeline as TimelinePlugin).currentTimeLine) {\n        setStyle((this.plugins.timeline as TimelinePlugin).currentTimeLine as HTMLElement, {\n          opacity: '1'\n        });\n      }\n    });\n    this.backend?.on('pause', () => {\n      this.fireEvent('pause');\n      if ((this.plugins.timeline as TimelinePlugin).currentTimeLine) {\n        setStyle((this.plugins.timeline as TimelinePlugin).currentTimeLine as HTMLElement, {\n          opacity: '0'\n        });\n      }\n    });\n\n    this.backend?.on('audioprocess', (time: number) => {\n      (this.plugins.timeline as TimelinePlugin)?.renderTimeline();\n      this.fireEvent('audioprocess', time);\n    });\n  }\n\n  /**\n   * Get the current playback position\n   */\n  getCurrentTime() {\n    return this.backend?.getCurrentTime() || 0;\n  }\n\n  moveCurrentTime(duration: number) {\n    this.setCurrentTime(this.getCurrentTime() + duration);\n  }\n\n  /**\n   * Set the current play time in seconds.\n   */\n  setCurrentTime(_seconds: number) {\n    const duration = this.getDuration();\n    let seconds = _seconds;\n    if (seconds >= duration) {\n      seconds = duration;\n    } else if (seconds < 0) {\n      seconds = 0;\n    }\n    this.seekTo(seconds / this.getDuration());\n    this.fireEvent('change-time', seconds);\n\n    (this.plugins.timeline as TimelinePlugin)?.renderTimeline();\n  }\n\n  /**\n   * Starts playback from the current position. Optional start and end\n   * measured in seconds can be used to set the range of audio to play.\n   *\n   * @param {?number} start Position to start at\n   * @param {?number} end Position to end at\n   * @emits WaveSurfer#interaction\n   * @return {Promise} Result of the backend play method\n   * @example\n   * // play from second 1 to 5\n   * wavesurfer.play(1, 5);\n   */\n  play(start?: number, end?: number) {\n    return this.soloPlay(undefined, start, end);\n  }\n\n  soloPlay(channelIndex?: number, start?: number, end?: number) {\n    if (this.getCurrentTime() === this.getDuration()) {\n      this.setCurrentTime(0);\n    }\n    this.setChannelOptions(this.channelOptions, channelIndex !== undefined, channelIndex);\n    this.fireEvent('interaction', () => this.play(start, end));\n    return this.backend?.play(start, end);\n  }\n\n  /**\n   * Set a point in seconds for playback to stop at.\n   *\n   * @param {number} position Position (in seconds) to stop at\n   */\n  setPlayEnd(position: number) {\n    this.backend?.setPlayEnd(position);\n  }\n\n  /**\n   * Stops and pauses playback\n   *\n   * @example wavesurfer.pause();\n   * @return {Promise} Result of the backend pause method\n   */\n  pause() {\n    if (!this.backend?.isPaused()) {\n      return this.backend?.pause();\n    }\n  }\n\n  /**\n   * Toggle playback\n   *\n   * @example wavesurfer.playPause();\n   * @return {Promise} Result of the backend play or pause method\n   */\n  playPause() {\n    return this.backend?.isPaused() ? this.play() : this.pause();\n  }\n\n  /**\n * Get the current playback state\n *\n * @example const isPlaying = wavesurfer.isPlaying();\n * @return {boolean} False if paused, true if playing\n */\n  isPlaying() {\n    return !this.backend?.isPaused();\n  }\n\n  /**\n * Skip backward\n *\n * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n * is used\n * @example wavesurfer.skipBackward();\n */\n  skipBackward(seconds?: number) {\n    this.skip(-(seconds || 0));\n  }\n\n  /**\n * Skip forward\n *\n * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n * is used\n * @example wavesurfer.skipForward();\n */\n  skipForward(seconds?: number) {\n    this.skip(seconds);\n  }\n\n  /**\n   * Skip a number of seconds from the current position (use a negative value\n   * to go backwards).\n   *\n   * @param {number} offset Amount to skip back or forwards\n   * @example\n   * // go back 2 seconds\n   * wavesurfer.skip(-2);\n   */\n  skip(offset?: number) {\n    const duration = this.getDuration() || 1;\n    let position = this.getCurrentTime() || 0;\n    position = Math.max(0, Math.min(duration, position + (offset || 0)));\n    this.seekAndCenter(position / duration);\n  }\n\n  /**\n   * Seeks to a position and centers the view\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @example\n   * // seek and go to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekAndCenter(progress: number) {\n    this.seekTo(progress);\n  }\n\n  /**\n   * Seeks to a position\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @emits WaveSurfer#interaction\n   * @emits WaveSurfer#seek\n   * @example\n   * // seek to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekTo(progress: number) {\n    this.fireEvent('interaction', () => this.seekTo(progress));\n    const paused = this.backend?.isPaused();\n\n    if (!paused) {\n      this.backend?.pause();\n    }\n\n    // avoid small scrolls while paused seeking\n    this.backend?.seekTo(progress * this.getDuration(), undefined);\n\n    if (!paused) {\n      this.backend?.play(undefined, undefined);\n    }\n    this.fireEvent('seek', progress);\n  }\n\n  /**\n   * Stops and goes to the beginning.\n   *\n   * @example wavesurfer.stop();\n   */\n  stop() {\n    this.pause();\n    this.seekTo(0);\n  }\n\n  /**\n   * Sets the ID of the audio device to use for output and returns a Promise.\n   *\n   * @param {string} deviceId String value representing underlying output\n   * device\n   * @returns {Promise} `Promise` that resolves to `undefined` when there are\n   * no errors detected.\n   */\n  setSinkId(deviceId: string) {\n    return this.backend?.setSinkId(deviceId);\n  }\n\n  /**\n   * Set the playback volume.\n   *\n   * @param {number} newVolume A value between 0 and 1, 0 being no\n   * @param {number} channelIndex channel index\n   * volume and 1 being full volume.\n   * @emits WaveSurfer#volume\n   */\n  setVolume(newVolume: number, channelIndex: number) {\n    this.backend?.setVolume(newVolume, channelIndex);\n    this.fireEvent('volume', newVolume);\n  }\n\n  /**\n   * Get the playback volume.\n   *\n   * @return {number} A value between 0 and 1, 0 being no\n   * volume and 1 being full volume.\n   */\n  getVolume() {\n    return this.backend?.getVolume();\n  }\n\n  /**\n   * Set the playback rate.\n   *\n   * @param {number} rate A positive number. E.g. 0.5 means half the normal\n   * speed, 2 means double speed and so on.\n   * @example wavesurfer.setPlaybackRate(2);\n   */\n  setPlaybackRate(rate: number) {\n    const scheduledPause = this.backend?.scheduledPause;\n    const currentTime = this.getCurrentTime();\n    this.backend?.setPlaybackRate(rate);\n    this.setCurrentTime(currentTime);\n    if (scheduledPause) {\n      this.setPlayEnd(scheduledPause);\n    }\n  }\n\n  /**\n   * Get the playback rate.\n   *\n   * @return {number} The current playback rate.\n   */\n  getPlaybackRate() {\n    return this.backend?.getPlaybackRate();\n  }\n\n  getPlayEnd() {\n    return this.backend?.getPlayEnd();\n  }\n\n  /**\n   * Toggle the volume on and off. If not currently muted it will save the\n   * current volume value and turn the volume off. If currently muted then it\n   * will restore the volume to the saved value, and then rest the saved\n   * value.\n   *\n   * @example wavesurfer.toggleMute();\n   */\n  toggleMute(channelIndex: number) {\n    this.setMute(!this.isMuted, channelIndex);\n  }\n\n  /**\n   * Enable or disable muted audio\n   *\n   * @param {boolean} mute Specify `true` to mute audio.\n   * @param {number} channelIndex\n   * @emits WaveSurfer#volume\n   * @emits WaveSurfer#mute\n   * @example\n   * // unmute\n   * wavesurfer.setMute(false);\n   * console.log(wavesurfer.getMute()) // logs false\n   */\n  setMute(mute: boolean, channelIndex: number) {\n    // ignore all muting requests if the audio is already in that state\n    if (mute === this.isMuted) {\n      this.fireEvent('mute', this.isMuted);\n      return;\n    }\n\n    if (mute) {\n      // If currently not muted then save current volume,\n      // turn off the volume and update the mute properties\n      this.savedVolume = this.backend?.getVolume() || 0;\n      this.backend?.setVolume(0, channelIndex);\n      this.isMuted = true;\n      this.fireEvent('volume', 0);\n    } else {\n      // If currently muted then restore to the saved volume\n      // and update the mute properties\n      this.backend?.setVolume(this.savedVolume, channelIndex);\n      this.isMuted = false;\n      this.fireEvent('volume', this.savedVolume);\n    }\n    this.fireEvent('mute', this.isMuted);\n  }\n\n  /**\n * Get the current mute status.\n *\n * @example const isMuted = wavesurfer.getMute();\n * @return {boolean} Current mute status\n */\n  getMute() {\n    return this.isMuted;\n  }\n\n  /**\n   * Remove events, elements and disconnect WebAudio nodes.\n   *\n   * @emits WaveSurfer#destroy\n   */\n  destroy() {\n    this.destroyAllPlugins();\n    this.fireEvent('destroy');\n    this.isDestroyed = true;\n    this.isReady = false;\n    this.buffer = null;\n  }\n\n  setHideChannels(hideChannels: number[]) {\n    this.setDrawIndex(hideChannels);\n    this.redraw(DrawType.RESIZE);\n  }\n\n  setDrawIndex(hideChannels: number[]) {\n    this.hideChannels = hideChannels;\n    const channels = Array.from({ length: this.channelCount }).map((v, i) => i);\n    const filteredChannels = channels.filter((v) => hideChannels.indexOf(v) < 0);\n    const drawIndex:{ [channelIndex: number]: number} = {};\n    channels.forEach((i) => {\n      drawIndex[i] = filteredChannels.indexOf(i);\n    });\n    this.drawer?.setDrawIndex(drawIndex);\n    this.visibleChannelCount = filteredChannels.length;\n  }\n\n  setChannelOptions(options: CustomChannelOptions[], isSolo?: boolean, channelIndex?: number) {\n    this.channelOptions = options;\n    options.forEach(({ volume, mute, index }) => {\n      const isMute = mute || (isSolo && channelIndex !== undefined && index !== channelIndex);\n      this.backend?.setVolume(isMute ? 0 : volume, index);\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}