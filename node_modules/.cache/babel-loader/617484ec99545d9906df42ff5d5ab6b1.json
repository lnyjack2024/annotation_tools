{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/**\n * An exported Crunker audio object.\n */\n\n/**\n * Crunker is the simple way to merge, concatenate, play, export and download audio files using the Web Audio API.\n */\nexport default class Crunker {\n  /**\n   * Creates a new instance of Crunker with the provided options.\n   */\n  constructor({\n    sampleRate = 44100\n  } = {}) {\n    this._sampleRate = void 0;\n    this._context = void 0;\n    this._sampleRate = sampleRate;\n    this._context = this._createContext();\n  }\n\n  /**\n   * Creates Crunker's internal AudioContext.\n   *\n   * @internal\n   */\n  _createContext() {\n    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;\n    return new AudioContext({\n      sampleRate: this._sampleRate\n    });\n  }\n\n  /**\n   *\n   * The internal AudioContext used by Crunker.\n   */\n  get context() {\n    return this._context;\n  }\n\n  /**\n   * Asynchronously fetches multiple audio files and returns an array of AudioBuffers.\n   */\n  async fetchAudio(...filepaths) {\n    // eslint-disable-next-line\n    return await Promise.all(filepaths.map(async filepath => {\n      let buffer;\n      if (filepath instanceof File || filepath instanceof Blob) {\n        buffer = await filepath.arrayBuffer();\n      } else {\n        buffer = await fetch(filepath).then(response => {\n          if (response.headers.has('Content-Type') && !response.headers.get('Content-Type').includes('audio/')) {\n            console.warn(`Crunker: Attempted to fetch an audio file, but its MIME type is \\`${response.headers.get('Content-Type').split(';')[0]}\\`. We'll try and continue anyway. (file: \"${filepath}\")`);\n          }\n          return response.arrayBuffer();\n        });\n      }\n      // eslint-disable-next-line\n      return await this._context.decodeAudioData(buffer);\n    }));\n  }\n\n  /**\n   * Merges (layers) multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806278-968f0680-d186-11ea-9cb5-8ef2606ffcc7.png)\n   */\n  mergeAudio(buffers, isMergeChannel = true) {\n    const output = this._context.createBuffer(isMergeChannel ? this._maxNumberOfChannels(buffers) : this._countOfChannels(buffers), this._sampleRate * this._maxDuration(buffers), this._sampleRate);\n    let currentChannel = -1;\n    buffers.forEach(buffer => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber += 1) {\n        currentChannel = isMergeChannel ? channelNumber : currentChannel + 1;\n        const outputData = output.getChannelData(currentChannel);\n        const bufferData = buffer.getChannelData(channelNumber);\n        for (let i = buffer.getChannelData(channelNumber).length - 1; i >= 0; i -= 1) {\n          outputData[i] += bufferData[i];\n        }\n        output.getChannelData(currentChannel).set(outputData);\n      }\n    });\n    return output;\n  }\n\n  /**\n   * Concatenates multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806297-9d1d7e00-d186-11ea-8cd2-c64cb0324845.png)\n   */\n  concatAudio(buffers) {\n    const output = this._context.createBuffer(this._maxNumberOfChannels(buffers), this._totalLength(buffers), this._sampleRate);\n    let offset = 0;\n    buffers.forEach(buffer => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber += 1) {\n        output.getChannelData(channelNumber).set(buffer.getChannelData(channelNumber), offset);\n      }\n      offset += buffer.length;\n    });\n    return output;\n  }\n\n  /**\n   * Pads a specified AudioBuffer with silence from a specified start time,\n   * for a specified length of time.\n   *\n   * Accepts float values as well as whole integers.\n   *\n   * @param buffer AudioBuffer to pad\n   * @param padStart Time to start padding (in seconds)\n   * @param seconds Duration to pad for (in seconds)\n   */\n  padAudio(buffer, padStart = 0, seconds = 0) {\n    if (seconds === 0) return buffer;\n    if (padStart < 0) throw new Error('Crunker: Parameter \"padStart\" in padAudio must be positive');\n    if (seconds < 0) throw new Error('Crunker: Parameter \"seconds\" in padAudio must be positive');\n    const updatedBuffer = this._context.createBuffer(buffer.numberOfChannels, Math.ceil(buffer.length + seconds * buffer.sampleRate), buffer.sampleRate);\n    for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber += 1) {\n      const channelData = buffer.getChannelData(channelNumber);\n      updatedBuffer.getChannelData(channelNumber).set(channelData.subarray(0, Math.ceil(padStart * buffer.sampleRate) + 1), 0);\n      updatedBuffer.getChannelData(channelNumber).set(channelData.subarray(Math.ceil(padStart * buffer.sampleRate) + 2, updatedBuffer.length + 1), Math.ceil((padStart + seconds) * buffer.sampleRate));\n    }\n    return updatedBuffer;\n  }\n\n  /**\n   * Plays the provided AudioBuffer in an AudioBufferSourceNode.\n   */\n  play(buffer) {\n    const source = this._context.createBufferSource();\n    source.buffer = buffer;\n    source.connect(this._context.destination);\n    source.start();\n    return source;\n  }\n\n  /**\n   * Exports the specified AudioBuffer to a Blob, Object URI and HTMLAudioElement.\n   *\n   * Note that changing the MIME type does not change the actual file format. The\n   * file format will **always** be a WAVE file due to how audio is stored in the\n   * browser.\n   *\n   * @param buffer Buffer to export\n   * @param type MIME type (default: `audio/wav`)\n   */\n  export(buffer, type = 'audio/wav') {\n    const recorded = this._interleave(buffer);\n    const dataview = this._writeHeaders(recorded);\n    const audioBlob = new Blob([dataview], {\n      type\n    });\n    return {\n      blob: audioBlob,\n      url: this._renderURL(audioBlob),\n      element: this._renderAudioElement(audioBlob)\n    };\n  }\n\n  /**\n   * Downloads the provided Blob.\n   *\n   * @param blob Blob to download\n   * @param filename An optional file name to use for the download (default: `crunker`)\n   */\n  download(blob, filename = 'crunker') {\n    const a = document.createElement('a');\n    a.style.display = 'none';\n    a.href = this._renderURL(blob);\n    a.download = `${filename}.${blob.type.split('/')[1]}`;\n    a.click();\n    return a;\n  }\n\n  /**\n   * Executes a callback if the browser does not support the Web Audio API.\n   *\n   * Returns the result of the callback, or `undefined` if the Web Audio API is supported.\n   *\n   * @param callback callback to run if the browser does not support the Web Audio API\n   */\n  notSupported(callback) {\n    return this._isSupported() ? undefined : callback();\n  }\n\n  /**\n   * Closes Crunker's internal AudioContext.\n   */\n  close() {\n    this._context.close();\n    return this;\n  }\n\n  /**\n   * Returns the largest duration of the longest AudioBuffer.\n   *\n   * @internal\n   */\n  _maxDuration(buffers) {\n    return Math.max(...buffers.map(buffer => buffer.duration));\n  }\n\n  /**\n   * Returns the largest number of channels in an array of AudioBuffers.\n   *\n   * @internal\n   */\n  _maxNumberOfChannels(buffers) {\n    return Math.max(...buffers.map(buffer => buffer.numberOfChannels));\n  }\n\n  /**\n   * Returns the largest number of channels in an array of AudioBuffers.\n   *\n   * @internal\n   */\n  _countOfChannels(buffers) {\n    return buffers.map(buffer => buffer.numberOfChannels).reduce((count, n) => count + n, 0);\n  }\n\n  /**\n   * Returns the sum of the lengths of an array of AudioBuffers.\n   *\n   * @internal\n   */\n  _totalLength(buffers) {\n    return buffers.map(buffer => buffer.length).reduce((a, b) => a + b, 0);\n  }\n\n  /**\n   * Returns whether the browser supports the Web Audio API.\n   *\n   * @internal\n   */\n  _isSupported() {\n    return 'AudioContext' in window || 'webkitAudioContext' in window || 'mozAudioContext' in window;\n  }\n\n  /**\n   * Writes the WAV headers for the specified Float32Array.\n   *\n   * Returns a DataView containing the WAV headers and file content.\n   *\n   * @internal\n   */\n  _writeHeaders(buffer) {\n    const arrayBuffer = new ArrayBuffer(44 + buffer.length * 2);\n    const view = new DataView(arrayBuffer);\n    this._writeString(view, 0, 'RIFF');\n    view.setUint32(4, 32 + buffer.length * 2, true);\n    this._writeString(view, 8, 'WAVE');\n    this._writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 2, true);\n    view.setUint32(24, this._sampleRate, true);\n    view.setUint32(28, this._sampleRate * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    this._writeString(view, 36, 'data');\n    view.setUint32(40, buffer.length * 2, true);\n    return this._floatTo16BitPCM(view, buffer, 44);\n  }\n\n  /**\n   * Converts a Float32Array to 16-bit PCM.\n   *\n   * @internal\n   */\n  _floatTo16BitPCM(dataview, buffer, offset) {\n    for (let i = 0; i < buffer.length; i += 1, offset += 2) {\n      const tmp = Math.max(-1, Math.min(1, buffer[i]));\n      dataview.setInt16(offset, tmp < 0 ? tmp * 0x8000 : tmp * 0x7fff, true);\n    }\n    return dataview;\n  }\n\n  /**\n   * Writes a string to a DataView at the specified offset.\n   *\n   * @internal\n   */\n  _writeString(dataview, offset, header) {\n    for (let i = 0; i < header.length; i += 1) {\n      dataview.setUint8(offset + i, header.charCodeAt(i));\n    }\n  }\n\n  /**\n   * Converts an AudioBuffer to a Float32Array.\n   *\n   * @internal\n   */\n  _interleave(input) {\n    const buffer = input.getChannelData(0);\n    const length = buffer.length * 2;\n    const result = new Float32Array(length);\n    let index = 0;\n    let inputIndex = 0;\n    while (index < length) {\n      result[index += 1] = buffer[inputIndex];\n      result[index += 1] = buffer[inputIndex];\n      inputIndex += 1;\n    }\n    return result;\n  }\n\n  /**\n   * Creates an HTMLAudioElement whose source is the specified Blob.\n   *\n   * @internal\n   */\n  _renderAudioElement(blob) {\n    const audio = document.createElement('audio');\n    audio.controls = true;\n    audio.src = this._renderURL(blob);\n    return audio;\n  }\n\n  /**\n   * Creates an Object URL for the specified Blob.\n   *\n   * @internal\n   */\n  _renderURL(blob) {\n    return (window.URL || window.webkitURL).createObjectURL(blob);\n  }\n}","map":{"version":3,"names":["Crunker","constructor","sampleRate","_sampleRate","_context","_createContext","window","AudioContext","webkitAudioContext","mozAudioContext","context","fetchAudio","filepaths","Promise","all","map","filepath","buffer","File","Blob","arrayBuffer","fetch","then","response","headers","has","get","includes","console","warn","split","decodeAudioData","mergeAudio","buffers","isMergeChannel","output","createBuffer","_maxNumberOfChannels","_countOfChannels","_maxDuration","currentChannel","forEach","channelNumber","numberOfChannels","outputData","getChannelData","bufferData","i","length","set","concatAudio","_totalLength","offset","padAudio","padStart","seconds","Error","updatedBuffer","Math","ceil","channelData","subarray","play","source","createBufferSource","connect","destination","start","export","type","recorded","_interleave","dataview","_writeHeaders","audioBlob","blob","url","_renderURL","element","_renderAudioElement","download","filename","a","document","createElement","style","display","href","click","notSupported","callback","_isSupported","undefined","close","max","duration","reduce","count","n","b","ArrayBuffer","view","DataView","_writeString","setUint32","setUint16","_floatTo16BitPCM","tmp","min","setInt16","header","setUint8","charCodeAt","input","result","Float32Array","index","inputIndex","audio","controls","src","URL","webkitURL","createObjectURL"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/utils/crunker.ts"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n\nexport interface CrunkerConstructorOptions {\n  /**\n   * Sample rate for Crunker's internal audio context.\n   *\n   * @default 44100\n   */\n  sampleRate: number;\n}\n\nexport type CrunkerInputTypes = string | File | Blob;\n\n/**\n * An exported Crunker audio object.\n */\nexport interface ExportedCrunkerAudio {\n  blob: Blob;\n  url: string;\n  element: HTMLAudioElement;\n}\n\n/**\n * Crunker is the simple way to merge, concatenate, play, export and download audio files using the Web Audio API.\n */\nexport default class Crunker {\n  private readonly _sampleRate: number;\n\n  private readonly _context: AudioContext;\n\n  /**\n   * Creates a new instance of Crunker with the provided options.\n   */\n  constructor({ sampleRate = 44100 }: Partial<CrunkerConstructorOptions> = {}) {\n    this._sampleRate = sampleRate;\n    this._context = this._createContext();\n  }\n\n  /**\n   * Creates Crunker's internal AudioContext.\n   *\n   * @internal\n   */\n  private _createContext(): AudioContext {\n    window.AudioContext = window.AudioContext || (window as any).webkitAudioContext || (window as any).mozAudioContext;\n    return new AudioContext({ sampleRate: this._sampleRate });\n  }\n\n  /**\n   *\n   * The internal AudioContext used by Crunker.\n   */\n  get context(): AudioContext {\n    return this._context;\n  }\n\n  /**\n   * Asynchronously fetches multiple audio files and returns an array of AudioBuffers.\n   */\n  async fetchAudio(...filepaths: CrunkerInputTypes[]): Promise<AudioBuffer[]> {\n    // eslint-disable-next-line\n    return await Promise.all(\n      filepaths.map(async (filepath) => {\n        let buffer: ArrayBuffer;\n        if (filepath instanceof File || filepath instanceof Blob) {\n          buffer = await filepath.arrayBuffer();\n        } else {\n          buffer = await fetch(filepath).then((response) => {\n            if (response.headers.has('Content-Type') && !response.headers.get('Content-Type')!.includes('audio/')) {\n              console.warn(\n                `Crunker: Attempted to fetch an audio file, but its MIME type is \\`${\n                  response.headers.get('Content-Type')!.split(';')[0]\n                }\\`. We'll try and continue anyway. (file: \"${filepath}\")`\n              );\n            }\n\n            return response.arrayBuffer();\n          });\n        }\n        // eslint-disable-next-line\n        return await this._context.decodeAudioData(buffer);\n      })\n    );\n  }\n\n  /**\n   * Merges (layers) multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806278-968f0680-d186-11ea-9cb5-8ef2606ffcc7.png)\n   */\n  mergeAudio(buffers: AudioBuffer[], isMergeChannel = true): AudioBuffer {\n    const output = this._context.createBuffer(\n      isMergeChannel ? this._maxNumberOfChannels(buffers) : this._countOfChannels(buffers),\n      this._sampleRate * this._maxDuration(buffers),\n      this._sampleRate\n    );\n\n    let currentChannel = -1;\n    buffers.forEach((buffer) => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber += 1) {\n        currentChannel = isMergeChannel ? channelNumber : currentChannel + 1;\n        const outputData = output.getChannelData(currentChannel);\n        const bufferData = buffer.getChannelData(channelNumber);\n\n        for (let i = buffer.getChannelData(channelNumber).length - 1; i >= 0; i -= 1) {\n          outputData[i] += bufferData[i];\n        }\n        output.getChannelData(currentChannel).set(outputData);\n      }\n    });\n\n    return output;\n  }\n\n  /**\n   * Concatenates multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806297-9d1d7e00-d186-11ea-8cd2-c64cb0324845.png)\n   */\n  concatAudio(buffers: AudioBuffer[]): AudioBuffer {\n    const output = this._context.createBuffer(\n      this._maxNumberOfChannels(buffers),\n      this._totalLength(buffers),\n      this._sampleRate\n    );\n    let offset = 0;\n\n    buffers.forEach((buffer) => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber += 1) {\n        output.getChannelData(channelNumber).set(buffer.getChannelData(channelNumber), offset);\n      }\n\n      offset += buffer.length;\n    });\n\n    return output;\n  }\n\n  /**\n   * Pads a specified AudioBuffer with silence from a specified start time,\n   * for a specified length of time.\n   *\n   * Accepts float values as well as whole integers.\n   *\n   * @param buffer AudioBuffer to pad\n   * @param padStart Time to start padding (in seconds)\n   * @param seconds Duration to pad for (in seconds)\n   */\n  padAudio(buffer: AudioBuffer, padStart = 0, seconds = 0): AudioBuffer {\n    if (seconds === 0) return buffer;\n\n    if (padStart < 0) throw new Error('Crunker: Parameter \"padStart\" in padAudio must be positive');\n    if (seconds < 0) throw new Error('Crunker: Parameter \"seconds\" in padAudio must be positive');\n\n    const updatedBuffer = this._context.createBuffer(\n      buffer.numberOfChannels,\n      Math.ceil(buffer.length + seconds * buffer.sampleRate),\n      buffer.sampleRate\n    );\n\n    for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber += 1) {\n      const channelData = buffer.getChannelData(channelNumber);\n      updatedBuffer\n        .getChannelData(channelNumber)\n        .set(channelData.subarray(0, Math.ceil(padStart * buffer.sampleRate) + 1), 0);\n\n      updatedBuffer\n        .getChannelData(channelNumber)\n        .set(\n          channelData.subarray(Math.ceil(padStart * buffer.sampleRate) + 2, updatedBuffer.length + 1),\n          Math.ceil((padStart + seconds) * buffer.sampleRate)\n        );\n    }\n\n    return updatedBuffer;\n  }\n\n  /**\n   * Plays the provided AudioBuffer in an AudioBufferSourceNode.\n   */\n  play(buffer: AudioBuffer): AudioBufferSourceNode {\n    const source = this._context.createBufferSource();\n\n    source.buffer = buffer;\n    source.connect(this._context.destination);\n    source.start();\n\n    return source;\n  }\n\n  /**\n   * Exports the specified AudioBuffer to a Blob, Object URI and HTMLAudioElement.\n   *\n   * Note that changing the MIME type does not change the actual file format. The\n   * file format will **always** be a WAVE file due to how audio is stored in the\n   * browser.\n   *\n   * @param buffer Buffer to export\n   * @param type MIME type (default: `audio/wav`)\n   */\n  export(buffer: AudioBuffer, type = 'audio/wav'): ExportedCrunkerAudio {\n    const recorded = this._interleave(buffer);\n    const dataview = this._writeHeaders(recorded);\n    const audioBlob = new Blob([dataview], { type });\n\n    return {\n      blob: audioBlob,\n      url: this._renderURL(audioBlob),\n      element: this._renderAudioElement(audioBlob),\n    };\n  }\n\n  /**\n   * Downloads the provided Blob.\n   *\n   * @param blob Blob to download\n   * @param filename An optional file name to use for the download (default: `crunker`)\n   */\n  download(blob: Blob, filename = 'crunker'): HTMLAnchorElement {\n    const a = document.createElement('a');\n\n    a.style.display = 'none';\n    a.href = this._renderURL(blob);\n    a.download = `${filename}.${blob.type.split('/')[1]}`;\n    a.click();\n\n    return a;\n  }\n\n  /**\n   * Executes a callback if the browser does not support the Web Audio API.\n   *\n   * Returns the result of the callback, or `undefined` if the Web Audio API is supported.\n   *\n   * @param callback callback to run if the browser does not support the Web Audio API\n   */\n  notSupported<T>(callback: () => T): T | undefined {\n    return this._isSupported() ? undefined : callback();\n  }\n\n  /**\n   * Closes Crunker's internal AudioContext.\n   */\n  close(): this {\n    this._context.close();\n    return this;\n  }\n\n  /**\n   * Returns the largest duration of the longest AudioBuffer.\n   *\n   * @internal\n   */\n  private _maxDuration(buffers: AudioBuffer[]): number {\n    return Math.max(...buffers.map((buffer) => buffer.duration));\n  }\n\n  /**\n   * Returns the largest number of channels in an array of AudioBuffers.\n   *\n   * @internal\n   */\n  private _maxNumberOfChannels(buffers: AudioBuffer[]): number {\n    return Math.max(...buffers.map((buffer) => buffer.numberOfChannels));\n  }\n\n  /**\n   * Returns the largest number of channels in an array of AudioBuffers.\n   *\n   * @internal\n   */\n  private _countOfChannels(buffers: AudioBuffer[]): number {\n    return buffers.map((buffer) => buffer.numberOfChannels).reduce((count, n) => count + n, 0);\n  }\n\n  /**\n   * Returns the sum of the lengths of an array of AudioBuffers.\n   *\n   * @internal\n   */\n  private _totalLength(buffers: AudioBuffer[]): number {\n    return buffers.map((buffer) => buffer.length).reduce((a, b) => a + b, 0);\n  }\n\n  /**\n   * Returns whether the browser supports the Web Audio API.\n   *\n   * @internal\n   */\n  private _isSupported(): boolean {\n    return 'AudioContext' in window || 'webkitAudioContext' in window || 'mozAudioContext' in window;\n  }\n\n  /**\n   * Writes the WAV headers for the specified Float32Array.\n   *\n   * Returns a DataView containing the WAV headers and file content.\n   *\n   * @internal\n   */\n  private _writeHeaders(buffer: Float32Array): DataView {\n    const arrayBuffer = new ArrayBuffer(44 + buffer.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    this._writeString(view, 0, 'RIFF');\n    view.setUint32(4, 32 + buffer.length * 2, true);\n    this._writeString(view, 8, 'WAVE');\n    this._writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, 2, true);\n    view.setUint32(24, this._sampleRate, true);\n    view.setUint32(28, this._sampleRate * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    this._writeString(view, 36, 'data');\n    view.setUint32(40, buffer.length * 2, true);\n\n    return this._floatTo16BitPCM(view, buffer, 44);\n  }\n\n  /**\n   * Converts a Float32Array to 16-bit PCM.\n   *\n   * @internal\n   */\n  private _floatTo16BitPCM(dataview: DataView, buffer: Float32Array, offset: number): DataView {\n    for (let i = 0; i < buffer.length; i += 1, offset += 2) {\n      const tmp = Math.max(-1, Math.min(1, buffer[i]));\n      dataview.setInt16(offset, tmp < 0 ? tmp * 0x8000 : tmp * 0x7fff, true);\n    }\n\n    return dataview;\n  }\n\n  /**\n   * Writes a string to a DataView at the specified offset.\n   *\n   * @internal\n   */\n  private _writeString(dataview: DataView, offset: number, header: string): void {\n    for (let i = 0; i < header.length; i += 1) {\n      dataview.setUint8(offset + i, header.charCodeAt(i));\n    }\n  }\n\n  /**\n   * Converts an AudioBuffer to a Float32Array.\n   *\n   * @internal\n   */\n  private _interleave(input: AudioBuffer): Float32Array {\n    const buffer = input.getChannelData(0);\n    const length = buffer.length * 2;\n    const result = new Float32Array(length);\n\n    let index = 0;\n    let inputIndex = 0;\n\n    while (index < length) {\n      result[index += 1] = buffer[inputIndex];\n      result[index += 1] = buffer[inputIndex];\n      inputIndex += 1;\n    }\n    return result;\n  }\n\n  /**\n   * Creates an HTMLAudioElement whose source is the specified Blob.\n   *\n   * @internal\n   */\n  private _renderAudioElement(blob: Blob): HTMLAudioElement {\n    const audio = document.createElement('audio');\n\n    audio.controls = true;\n    audio.src = this._renderURL(blob);\n\n    return audio;\n  }\n\n  /**\n   * Creates an Object URL for the specified Blob.\n   *\n   * @internal\n   */\n  private _renderURL(blob: Blob): string {\n    return (window.URL || window.webkitURL).createObjectURL(blob);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}