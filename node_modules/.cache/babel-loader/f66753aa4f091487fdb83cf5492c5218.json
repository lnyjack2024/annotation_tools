{"ast":null,"code":"import _initializerDefineProperty from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\nvar _class,\n  _class2,\n  _descriptor,\n  _descriptor2,\n  _descriptor3,\n  _descriptor4,\n  _descriptor5,\n  _descriptor6,\n  _descriptor7,\n  _descriptor8,\n  _descriptor9,\n  _descriptor0,\n  _descriptor1,\n  _descriptor10,\n  _descriptor11,\n  _descriptor12,\n  _descriptor13,\n  _descriptor14,\n  _descriptor15,\n  _VideoTracking,\n  _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking/index.tsx\";\nimport React from 'react';\nimport { message, notification } from 'antd';\nimport { observable, computed, toJS, makeObservable } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { cloneDeep, mapValues, isEqual } from 'lodash';\nimport AutoSaver from '../common/AutoSaver';\nimport LayoutWrapper from '../common/layout/LayoutWrapper';\nimport AppWrapper from '../common/shapes/wrapper/AppWrapper';\nimport Canvas from '../common/shapes/canvas/Canvas';\nimport ShapeFactory from '../common/shapes/ShapeFactory';\nimport { ShapeType } from '../common/shapes/types';\nimport { BorderStyle, EventAction } from '../common/shapes/Shape';\nimport Polygon from '../common/shapes/Polygon';\nimport Line from '../common/shapes/Line';\nimport Rectangle, { RectType } from '../common/shapes/Rectangle';\nimport Label from '../common/shapes/label/Label';\nimport Cursor from '../common/Cursor';\nimport GridView from './components/GridView';\nimport Toolbar from './components/Toolbar';\nimport Sidebar from './components/Sidebar';\nimport Attributes from './components/Attributes';\nimport FrameControl from './components/FrameControl';\nimport InstanceMove from './components/InstanceMove';\nimport Review from './components/Review';\nimport Validator from './components/Validator';\nimport LabelViewer from './components/LabelViewer';\nimport GridTool from './components/GridTool';\nimport bindKeyboardEvents from './keyboard-events';\nimport UndoStore from './store/UndoStore';\nimport SettingsStore from './store/SettingsStore';\nimport RelationshipsStore from './store/RelationshipsStore';\nimport ReviewsStore from './store/ReviewsStore';\nimport FramesStore from './store/FramesStore';\nimport { Tool, ViewMode, LabelItem } from './types';\nimport { parseFramesByPaylod, loadInstancesFromResult, predictShapeData, getLastKeyFrames, getNextKeyFrames, getShapeFromFrames, getSnapshot, getShapeTypeByTool, getToolTypeFromFrameData } from './utils';\nimport { methods } from './payload';\nimport i18n from './locales';\nimport loader from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly, isReviewEditable } from '../../utils/tool-mode';\nimport 'antd/es/message/style/index.css';\nimport './index.scss';\nexport let VideoTracking = observer(_class = (_class2 = (_VideoTracking = class VideoTracking extends React.Component {\n  constructor(props) {\n    super(props);\n    /**\n     * frame image urls\n     */\n    _initializerDefineProperty(this, \"frames\", _descriptor, this);\n    /**\n     * current frame index\n     */\n    _initializerDefineProperty(this, \"currentFrame\", _descriptor2, this);\n    /**\n     * current tool\n     */\n    _initializerDefineProperty(this, \"currentTool\", _descriptor3, this);\n    /**\n     * frame loading\n     */\n    _initializerDefineProperty(this, \"loading\", _descriptor4, this);\n    /**\n     * add mode, true means adding active\n     */\n    _initializerDefineProperty(this, \"addMode\", _descriptor5, this);\n    /**\n     * show shape labels or not\n     */\n    _initializerDefineProperty(this, \"labelMode\", _descriptor6, this);\n    /**\n     * current cursor\n     */\n    _initializerDefineProperty(this, \"cursor\", _descriptor7, this);\n    /**\n     * selected category class_name (status cross frames)\n     */\n    _initializerDefineProperty(this, \"selectedCategoryName\", _descriptor8, this);\n    /**\n     * selected instance id (status cross frames)\n     */\n    _initializerDefineProperty(this, \"selectedInstanceId\", _descriptor9, this);\n    /**\n     * selected instance frame status (used for frame control render)\n     */\n    _initializerDefineProperty(this, \"selectedInstanceFrames\", _descriptor0, this);\n    /**\n     * instances in current frame (used for sidebar render)\n     */\n    _initializerDefineProperty(this, \"currentInstancesMap\", _descriptor1, this);\n    /**\n     * category instances (used for sidebar render)\n     */\n    _initializerDefineProperty(this, \"categoryInstancesMap\", _descriptor10, this);\n    /**\n     * current selected instance shape attributes\n     */\n    _initializerDefineProperty(this, \"currentAttributes\", _descriptor11, this);\n    /**\n     * current selected instance shape snapshot\n     */\n    _initializerDefineProperty(this, \"currentSnapshot\", _descriptor12, this);\n    /**\n     * currently hovered shape\n     */\n    _initializerDefineProperty(this, \"hoveredShapeId\", _descriptor13, this);\n    /**\n     * whether instance move modal is open\n     */\n    _initializerDefineProperty(this, \"instanceMoving\", _descriptor14, this);\n    /**\n     * frame control height (default is 48 + 56 = 104)\n     */\n    _initializerDefineProperty(this, \"frameControlHeight\", _descriptor15, this);\n    /**\n     * all instances\n     */\n    this.instances = {};\n    /**\n     * frame instances\n     */\n    this.frameInstances = [];\n    /**\n     * initial data copy\n     */\n    this.initialData = null;\n    /**\n     * shape instances in current frame\n     */\n    this.shapes = [];\n    /**\n     * shape instance map (used for shape select & instance select)\n     */\n    this.shapeInstanceMap = {};\n    /**\n     * currently drawing shape\n     */\n    this.drawingShape = null;\n    /**\n     * currently selected shape\n     */\n    this.selectedShape = null;\n    /**\n     * predicted selected instance shape in current frame\n     */\n    this.predictedShape = null;\n    /**\n     * predicted selected instance shape type\n     */\n    this.predictedShapeType = null;\n    /**\n     * current image\n     */\n    this.image = null;\n    /**\n     * image preloader\n     */\n    this.imagePreloader = null;\n    /**\n     * shape labels container\n     */\n    this.labelsContainer = React.createRef();\n    /**\n     * canvas reference\n     */\n    this.canvasRef = React.createRef();\n    /**\n     * grid view reference\n     */\n    this.gridsRef = React.createRef();\n    /**\n     * label viewer\n     */\n    this.labelRef = React.createRef();\n    /**\n     * attributes reference\n     */\n    this.attributesRef = React.createRef();\n    /**\n     * auto saver reference\n     */\n    this.saverRef = React.createRef();\n    /**\n     * validator reference\n     */\n    this.validatorRef = React.createRef();\n    /**\n     * grid tool reference\n     */\n    this.gridToolRef = React.createRef();\n    /**\n     * keyboard events\n     */\n    this.removeKeyboardEvents = () => {};\n    this.loadResult = async frameCount => {\n      const result = await this.props.jobProxy.loadResult();\n      if (!result) {\n        return;\n      }\n      if (result.auditId) {\n        this.props.jobProxy.setAuditId(result.auditId);\n      }\n      const {\n        instances,\n        frameInstances,\n        categoryInstancesMap\n      } = loadInstancesFromResult(result, frameCount);\n      this.instances = instances;\n      this.frameInstances = frameInstances;\n      this.categoryInstancesMap = categoryInstancesMap;\n      RelationshipsStore.setInitialData(result.relationships, instances);\n      FramesStore.setInitialData(result.frames);\n      // copy initial data\n      const reviewFrom = await this.props.jobProxy.loadReviewFrom();\n      if (reviewFrom) {\n        this.initialData = cloneDeep({\n          instances: reviewFrom.instances,\n          relationships: reviewFrom.relationships,\n          frames: reviewFrom.frames\n        });\n      }\n    };\n    this.getStatistics = () => {\n      const reviews = {};\n      ReviewsStore.getReviewsForSave().forEach(review => {\n        if (!reviews[review.instanceId]) {\n          reviews[review.instanceId] = {};\n        }\n        reviews[review.instanceId][review.frameIndex] = review.result;\n      });\n      const shapes = {};\n      Object.values(this.instances).forEach(instance => {\n        Object.values(instance.frames).forEach(frame => {\n          let review;\n          if (reviews[instance.id]) {\n            review = reviews[instance.id][frame.frameIndex];\n          }\n          const shape = `${getToolTypeFromFrameData(frame)}`;\n          if (!shapes[shape]) {\n            shapes[shape] = {\n              rejected: 0,\n              approved: 0\n            };\n          }\n          if (review === 'reject') {\n            shapes[shape].rejected += 1;\n          } else {\n            shapes[shape].approved += 1;\n          }\n        });\n      });\n      return {\n        shapes\n      };\n    };\n    this.saveResult = async (type = 'submit') => {\n      if (type === 'submit') {\n        var _this$saverRef$curren;\n        (_this$saverRef$curren = this.saverRef.current) === null || _this$saverRef$curren === void 0 ? void 0 : _this$saverRef$curren.disableLeaveCheck();\n        if (SettingsStore.submitCheck) {\n          // validate before submit\n          const passed = await this.triggerValidation();\n          if (!passed) {\n            throw new Error(i18n.translate('SUBMIT_CHECK_FAIL'));\n          }\n        }\n      }\n      const allInstances = Object.values(this.instances).map(instance => ({\n        ...instance,\n        frames: Object.values(instance.frames)\n      }));\n      return this.props.jobProxy.saveResult({\n        auditId: this.props.jobProxy.auditId,\n        instances: allInstances,\n        relationships: RelationshipsStore.getRelationshipsForSave(),\n        frames: FramesStore.getFramesForSave()\n      }, type === 'submit');\n    };\n    this.loadReviews = async () => {\n      const reviews = await this.props.jobProxy.loadReviews();\n      ReviewsStore.setInitialData(reviews);\n    };\n    this.saveReviews = (type = 'submit') => {\n      if (type === 'submit') {\n        var _this$saverRef$curren2;\n        (_this$saverRef$curren2 = this.saverRef.current) === null || _this$saverRef$curren2 === void 0 ? void 0 : _this$saverRef$curren2.disableLeaveCheck();\n      }\n      const reviews = ReviewsStore.getReviewsForSave();\n      return this.props.jobProxy.saveReviews(reviews);\n    };\n    this.save = async (isAutoSave = false) => {\n      const {\n        toolMode\n      } = this.props.jobProxy;\n      if (this.frames.length <= 0 || isPreview(toolMode)) {\n        // not rendered, or is preview mode\n        return;\n      }\n      const promises = [];\n      if (!isAnnotationReadonly(toolMode)) {\n        promises.push(this.saveResult('temp'));\n      }\n      if (isReviewEditable(toolMode)) {\n        promises.push(this.saveReviews('temp'));\n      }\n      if (promises.length > 0) {\n        try {\n          var _this$saverRef$curren3;\n          await Promise.all(promises);\n          message.success(i18n.translate(isAutoSave ? 'SAVE_AUTO_SUCCESS' : 'SAVE_SUCCESS'));\n          // update tempSaved flag\n          (_this$saverRef$curren3 = this.saverRef.current) === null || _this$saverRef$curren3 === void 0 ? void 0 : _this$saverRef$curren3.setTempSaved(true);\n        } catch (e) {\n          if (!isAutoSave) {\n            message.error(i18n.translate('SAVE_FAIL'));\n          } else {\n            throw e;\n          }\n        }\n      }\n    };\n    this.isModified = () => {\n      const currInstances = Object.values(this.instances).map(instance => ({\n        ...instance,\n        frames: Object.values(instance.frames)\n      }));\n      const currRelationships = RelationshipsStore.getRelationshipsForSave();\n      const currFrames = FramesStore.getFramesForSave();\n      const {\n        instances = [],\n        relationships = [],\n        frames = []\n      } = this.initialData || {};\n      return !isEqual(currInstances, instances) || !isEqual(currRelationships, relationships) || !isEqual(currFrames, frames);\n    };\n    /**\n     * chhange current tool\n     * @param tool\n     */\n    this.changeCurrentTool = tool => {\n      this.currentTool = tool;\n      if (!this.addMode) {\n        this.changeAddMode(true);\n      }\n    };\n    /**\n     * change add mode\n     * @param addMode\n     * @param forceChange\n     */\n    this.changeAddMode = (addMode, forceChange = false) => {\n      var _this$attributesRef$c;\n      if (!forceChange && (this.readonly || this.instanceMoving || ((_this$attributesRef$c = this.attributesRef.current) === null || _this$attributesRef$c === void 0 ? void 0 : _this$attributesRef$c.modalVisible) || !!ReviewsStore.currentInstanceId)) {\n        return;\n      }\n      this.addMode = addMode;\n      // change cursor\n      this.cursor = addMode ? Cursor.CROSSHAIR : Cursor.DEFAULT;\n      // change other shapes interactive\n      this.shapes.forEach(shape => {\n        shape.interactive = !addMode;\n      });\n      // remove drawing shape if needed\n      if (!addMode && this.drawingShape) {\n        this.drawingShape.destroy();\n        this.drawingShape = null;\n      }\n      // hide or show predict shape\n      if (this.selectedInstanceId) {\n        this.predict(addMode ? undefined : this.instances[this.selectedInstanceId]);\n      }\n    };\n    /**\n     * change label mode\n     * @param labelMode\n     */\n    this.changeLabelMode = labelMode => {\n      if (this.labelMode !== labelMode) {\n        this.labelMode = labelMode;\n        this.shapes.forEach(shape => {\n          const intance = this.instances[this.shapeInstanceMap[shape.uid]];\n          shape.label = this.labelMode ? this.getInstanceLabel(intance) : '';\n        });\n        if (this.predictedShape) {\n          this.predictedShape.label = this.labelMode ? this.getInstanceLabel(this.instances[this.selectedInstanceId]) : '';\n        }\n        if (this.labelsContainer.current) {\n          this.labelsContainer.current.style.display = labelMode ? 'block' : 'none';\n        }\n      }\n    };\n    /**\n     * set current frame\n     * @param frame\n     */\n    this.setFrame = frame => {\n      if (this.currentFrame !== frame) {\n        var _this$imagePreloader;\n        this.currentFrame = frame;\n        if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n          this.loading = true;\n        } else {\n          this.setupFrameData();\n        }\n        (_this$imagePreloader = this.imagePreloader) === null || _this$imagePreloader === void 0 ? void 0 : _this$imagePreloader.preload(this.currentFrame);\n      }\n    };\n    /**\n     * setup frame data\n     */\n    this.setupFrameData = () => {\n      // remove all current shapes\n      this.clearShapes();\n\n      // close modals\n      this.setInstanceMoving(false);\n      // turn off add mode\n      this.changeAddMode(false, true);\n      // reset temp relationship\n      RelationshipsStore.resetTempRelationship();\n\n      // add shapes in current frame\n      this.currentInstancesMap = this.frameInstances[this.currentFrame].reduce((acc, curr) => ({\n        ...acc,\n        [curr]: true\n      }), {});\n    };\n    /**\n     * setup frame shapes\n     */\n    this.setupFrame = (_, image) => {\n      this.image = image;\n\n      // setup frame data\n      this.setupFrameData();\n      // create frame shapes\n      this.frameInstances[this.currentFrame].forEach(instanceId => {\n        const instance = this.instances[instanceId];\n        const category = this.getCategory(instance.category);\n        if (category) {\n          const shape = this.createShape(category.display_color, this.getInstanceLabel(instance), instance.frames[this.currentFrame].shapeType, instance.frames[this.currentFrame].shape);\n          if (this.readonly) {\n            shape.editable = false;\n          }\n          this.addShapeListeners(shape);\n          this.shapes.push(shape);\n          this.shapeInstanceMap[shape.uid] = instance.id;\n        }\n      });\n      if (this.selectedInstanceId) {\n        this.selectInstance(this.selectedInstanceId);\n      }\n      this.updateHiddenShapes();\n      this.updateLabels();\n      this.loading = false;\n    };\n    /**\n     * create shape label dom\n     */\n    this.createShapeLabel = () => {\n      const shapeLabel = new Label({\n        className: 'instance-label'\n      });\n      shapeLabel.addToContainer(this.labelsContainer.current);\n      return shapeLabel;\n    };\n    /**\n     * create shape instance\n     * @param hexColor\n     * @param label\n     * @param shapeType\n     * @param shapeData\n     * @param shapeContainer\n     * @param imageBounds\n     */\n    this.createShape = (hexColor, label, shapeType, shapeData, shapeContainer, imageBounds = this.imageBounds) => {\n      const useCurrent = shapeType === undefined;\n      const color = parseInt(hexColor.substr(1), 16);\n      const currentShapeType = shapeType || this.currentShapeType;\n      const shape = ShapeFactory.getShape(currentShapeType, {\n        app: this.props.app,\n        container: shapeContainer,\n        color,\n        selectedColor: 0xFF0000,\n        alpha: 0.2,\n        ...(SettingsStore.boundaryCheck && {\n          bounds: imageBounds\n        }),\n        ...(this.labelMode && {\n          label\n        }),\n        ...shapeData,\n        ...(useCurrent && this.currentTool === Tool.CENTERLINE_RECTANGLE && {\n          centerLineEnabled: true\n        }),\n        ...(useCurrent && this.currentTool === Tool.FOUR_DOTS_RECTANGLE && {\n          rectType: RectType.FOUR_DOTS_RECT\n        }),\n        rotatable: SettingsStore.rotatable,\n        ...(SettingsStore.viewMode === ViewMode.DEFAULT && {\n          labelDom: this.createShapeLabel()\n        }),\n        userDataFormatter: this.formatPointLabel\n      });\n      if (shapeData && currentShapeType === ShapeType.RECTANGLE) {\n        shape.rotation = shapeData.rotation || 0;\n      }\n      shape.userDataMode = SettingsStore.activePointAttributesMode;\n      return shape;\n    };\n    /**\n     * click to draw a shape\n     * @param point\n     * @param shapeContainer\n     * @param imageBounds\n     */\n    this.addShape = (point, shapeContainer, imageBounds) => {\n      if (this.addMode && !this.drawingShape) {\n        this.drawingShape = this.createShape(this.selectedCategory.display_color, undefined, undefined, undefined, shapeContainer, imageBounds);\n\n        // add listeners\n        this.drawingShape.on(EventAction.FINISHED, shape => {\n          // remove listeners after creating\n          shape.off(EventAction.FINISHED);\n          shape.off(EventAction.REMOVED);\n          // drawing finished\n          const instance = this.getCurrentInstance();\n          const storeId = UndoStore.preserve({\n            instances: [instance]\n          });\n          if (this.labelMode) {\n            shape.label = this.getInstanceLabel(instance);\n          }\n          this.addShapeToCurrentFrame(shape, instance, this.currentTool === Tool.OCR || this.currentTool === Tool.OCR_POLYGON);\n          this.drawingShape = null;\n          this.changeAddMode(false, true);\n          UndoStore.save(storeId, {\n            instances: [instance]\n          });\n          if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n            this.addShapeListeners(shape);\n          } else {\n            var _this$gridsRef$curren;\n            (_this$gridsRef$curren = this.gridsRef.current) === null || _this$gridsRef$curren === void 0 ? void 0 : _this$gridsRef$curren.update();\n          }\n        });\n        this.drawingShape.on(EventAction.REMOVED, () => {\n          this.drawingShape = null;\n        });\n        // start create\n        let options;\n        if (this.currentTool === Tool.GRID && this.gridToolRef.current) {\n          const colsCount = this.gridToolRef.current.getColsCount();\n          const rowsCount = this.gridToolRef.current.getRowsCount();\n          options = {\n            cols: colsCount,\n            rows: rowsCount\n          };\n        }\n        this.drawingShape.create(point, options);\n        return this.drawingShape;\n      }\n      return null;\n    };\n    /**\n     * select shape by click canvas\n     * @param shape\n     */\n    this.selectShape = (shape, isManual) => {\n      if (!this.selectedShape || this.selectedShape.uid !== shape.uid) {\n        // selected shape changes\n        if (this.selectedShape) {\n          this.selectedShape.selected = false;\n        }\n        this.selectedShape = shape;\n        this.selectedShape.selected = true;\n        this.setSelectedInstance(this.shapeInstanceMap[this.selectedShape.uid], isManual);\n      }\n    };\n    /**\n     * unselect shape by click canvas\n     */\n    this.unselectShape = () => {\n      if (this.addMode) {\n        return;\n      }\n      if (this.selectedShape) {\n        this.selectedShape.selected = false;\n      }\n      this.selectedShape = null;\n      this.setSelectedInstance('');\n    };\n    /**\n     * on shape changed\n     * @param instanceId\n     * @param shape\n     * @param shapeType\n     * @param shapeData\n     */\n    this.updateShapeForInstance = (instanceId, shape, shapeData, shapeType) => {\n      const instance = this.instances[instanceId];\n      const {\n        frames\n      } = instance;\n      const storeId = UndoStore.preserve({\n        instances: [instance]\n      });\n      if (!frames[this.currentFrame]) {\n        this.addShapeToCurrentFrame(shape, instance, undefined, true, shapeType || this.predictedShapeType, shapeData);\n        shape.borderStyle = BorderStyle.SOLID;\n        this.predictedShape = null;\n        this.predictedShapeType = null;\n      } else {\n        frames[this.currentFrame].isKeyFrame = true;\n        frames[this.currentFrame].shape = shapeData;\n        this.selectedInstanceFrames[this.currentFrame] = true;\n        this.interpolate(instance);\n      }\n      UndoStore.save(storeId, {\n        instances: [instance]\n      });\n      if (frames[this.currentFrame].isOCR) {\n        this.setCurrentSnapshot(shapeData);\n      }\n    };\n    /**\n     * add shape to instance\n     * @param instanceId\n     * @param shapeContainer\n     * @param imageBounds\n     */\n    this.addShapeToInstance = (instanceId, shapeContainer, imageBounds = this.imageBounds) => {\n      const instance = this.instances[instanceId];\n      const stackId = UndoStore.preserve({\n        instances: [instance]\n      });\n      if (this.selectedInstanceId === instanceId && this.predictedShape && this.predictedShapeType) {\n        this.addShapeToCurrentFrame(this.predictedShape, instance, undefined, true, this.predictedShapeType);\n        this.predictedShape.borderStyle = BorderStyle.SOLID;\n        this.predictedShape = null;\n        this.predictedShapeType = null;\n        UndoStore.save(stackId, {\n          instances: [instance]\n        });\n      } else {\n        let shapeInfo = predictShapeData(this.currentFrame, instance.frames, imageBounds);\n        if (!shapeInfo) {\n          const lastFrame = Object.keys(instance.frames).pop();\n          if (lastFrame) {\n            const {\n              shapeType,\n              shape\n            } = instance.frames[parseInt(lastFrame, 10)];\n            shapeInfo = {\n              shapeType,\n              shape\n            };\n          }\n        }\n        if (shapeInfo) {\n          const shape = this.createShape(this.selectedCategory.display_color, this.getInstanceLabel(instance), shapeInfo.shapeType, shapeInfo.shape, shapeContainer, imageBounds);\n          this.addShapeToCurrentFrame(shape, instance, undefined, true, shapeInfo.shapeType, shapeInfo.shape);\n          UndoStore.save(stackId, {\n            instances: [instance]\n          });\n          if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n            this.addShapeListeners(shape);\n          }\n          return shape;\n        }\n      }\n      return null;\n    };\n    /**\n     * delete selected shape points or shape instance from current frame\n     */\n    this.delete = () => {\n      if (!this.readonly && this.selectedInstanceId) {\n        if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n          const shape = this.getShapeByInstance(this.selectedInstanceId);\n          if (shape) {\n            const pointsDeleted = shape.deleteSelectedPoints();\n            if (!pointsDeleted) {\n              this.deleteShapeFromInstance(this.selectedInstanceId, [this.currentFrame]);\n              this.updateLabels();\n            }\n          }\n        } else {\n          var _this$gridsRef$curren2;\n          (_this$gridsRef$curren2 = this.gridsRef.current) === null || _this$gridsRef$curren2 === void 0 ? void 0 : _this$gridsRef$curren2.delete(this.currentFrame, this.selectedInstanceId);\n        }\n      }\n    };\n    /**\n     * delete shape in frames\n     * @param instanceId instance id\n     * @param frames affected frame indexes\n     */\n    this.deleteShapeFromInstance = (instanceId, frames) => {\n      const instance = this.instances[instanceId];\n      const storeId = UndoStore.preserve({\n        instances: [instance],\n        relationships: RelationshipsStore.getRelationshipsForSave(),\n        reviews: ReviewsStore.getReviewsForSave()\n      });\n      for (let i = 0; i < frames.length; i += 1) {\n        const deleteFrame = frames[i];\n        // remove from instance\n        delete instance.frames[deleteFrame];\n        // remove from frames\n        const instanceIndex = this.frameInstances[deleteFrame].indexOf(instanceId);\n        if (instanceIndex >= 0) {\n          this.frameInstances[deleteFrame].splice(instanceIndex, 1);\n        }\n        // is current frame, need remove shape and update state\n        if (deleteFrame === this.currentFrame) {\n          const shape = this.getShapeByInstance(instanceId);\n          if (shape) {\n            this.removeShape(shape);\n            delete this.shapeInstanceMap[shape.uid];\n          }\n          delete this.currentInstancesMap[instance.id];\n        }\n        // set prev & next frame to key frame\n        if (instance.frames[deleteFrame - 1]) {\n          instance.frames[deleteFrame - 1].isKeyFrame = true;\n        }\n        if (instance.frames[deleteFrame + 1]) {\n          instance.frames[deleteFrame + 1].isKeyFrame = true;\n        }\n        // delete related relationships if needed\n        RelationshipsStore.deleteRelationshipByInstance(instanceId, deleteFrame);\n        // delete related reviews if needed\n        ReviewsStore.deleteReviewByInstance(instanceId, deleteFrame);\n      }\n      // update instance frames\n      this.selectedInstanceFrames = mapValues(instance.frames, 'isKeyFrame');\n      // no frame exists\n      if (Object.keys(instance.frames).length <= 0) {\n        // remove instance\n        delete this.instances[instanceId];\n        delete this.categoryInstancesMap[instance.category][instance.id];\n        if (this.selectedInstanceId === instanceId) {\n          this.setSelectedInstance(''); // unselect\n        }\n      }\n      this.predict(instance);\n      UndoStore.save(storeId, {\n        instances: [instance],\n        relationships: RelationshipsStore.getRelationshipsForSave(),\n        reviews: ReviewsStore.getReviewsForSave()\n      });\n    };\n    /**\n     * delete shape from instance by type\n     * @param instanceId\n     * @param type\n     */\n    this.deleteShapeFromInstanceByType = (instanceId, type = 'current') => {\n      switch (type) {\n        case 'current':\n          this.deleteShapeFromInstance(instanceId, [this.currentFrame]);\n          break;\n        case 'key':\n          {\n            const nextKeyFrames = getNextKeyFrames(1, this.currentFrame, this.instances[instanceId].frames);\n            const nextKeyFrame = nextKeyFrames.length === 1 ? nextKeyFrames[0] : this.frames.length - 1;\n            this.deleteShapeFromInstance(instanceId, Array.from({\n              length: nextKeyFrame - this.currentFrame\n            }).map((_, index) => this.currentFrame + index));\n            break;\n          }\n        case 'following':\n          this.deleteShapeFromInstance(instanceId, Array.from({\n            length: this.frames.length - this.currentFrame\n          }).map((_, index) => this.currentFrame + index));\n          break;\n        case 'all':\n          this.deleteShapeFromInstance(instanceId, Array.from({\n            length: this.frames.length\n          }).map((_, index) => index));\n          break;\n        default:\n      }\n    };\n    /**\n     * select instance\n     * @param instanceId\n     * @param isManual\n     */\n    this.selectInstance = (instanceId, isManual) => {\n      this.setSelectedInstance(instanceId, isManual);\n      // select shape\n      const shape = this.getShapeByInstance(instanceId);\n      if (this.selectedShape) {\n        this.selectedShape.selected = false;\n      }\n      if (shape) {\n        this.selectedShape = shape;\n        this.selectedShape.selected = true;\n      } else {\n        this.selectedShape = null;\n      }\n    };\n    /**\n     * get instance label\n     * @param instance\n     */\n    this.getInstanceLabel = instance => {\n      const category = this.getCategory(instance.category);\n      return `${(category === null || category === void 0 ? void 0 : category.display_name) || (category === null || category === void 0 ? void 0 : category.class_name) || instance.category} ${instance.number}`;\n    };\n    /**\n     * select category\n     * @param categoryName\n     */\n    this.selectCategory = categoryName => {\n      if (this.selectedCategoryName !== categoryName) {\n        this.selectedCategoryName = categoryName;\n        if (this.selectedInstanceId) {\n          this.selectInstance('');\n        }\n      }\n    };\n    /**\n     * get category object\n     * @param categoryName\n     */\n    this.getCategory = categoryName => this.props.ontology.find(o => o.class_name === categoryName);\n    /**\n     * move instance to target category & number in frames\n     * @param instanceId instance to be moved\n     * @param category target category\n     * @param number target number\n     * @param frames affected frames\n     */\n    this.move = (instanceId, category, number, frames) => {\n      const currentInstance = this.instances[instanceId];\n      const targetInstance = number < 0 ? this.createInstance(this.getCategory(category)) : this.getInstanceByNumber(category, number);\n      if (currentInstance && targetInstance) {\n        const storeId = UndoStore.preserve({\n          instances: [currentInstance, targetInstance],\n          relationships: RelationshipsStore.getRelationshipsForSave()\n        });\n        const currentInstancesMap = {\n          ...this.currentInstancesMap\n        };\n        frames.forEach((frameIndex, i) => {\n          targetInstance.frames[frameIndex] = {\n            ...currentInstance.frames[frameIndex]\n          };\n          delete currentInstance.frames[frameIndex];\n          RelationshipsStore.switchRelationshipInstance(instanceId, targetInstance.id, frameIndex);\n          const isRangeStart = i === 0 || i > 0 && frames[i] - frames[i - 1] > 1;\n          const isRangeEnd = i === frames.length - 1 || i < frames.length - 1 && frames[i + 1] - frames[i] > 1;\n          if (isRangeStart || isRangeEnd) {\n            if (isRangeStart && currentInstance.frames[frameIndex - 1]) {\n              currentInstance.frames[frameIndex - 1].isKeyFrame = true;\n            }\n            if (isRangeEnd && currentInstance.frames[frameIndex + 1]) {\n              currentInstance.frames[frameIndex + 1].isKeyFrame = true;\n            }\n            targetInstance.frames[frameIndex].isKeyFrame = true;\n            if (isRangeStart && targetInstance.frames[frameIndex - 1]) {\n              targetInstance.frames[frameIndex - 1].isKeyFrame = true;\n            }\n            if (isRangeEnd && targetInstance.frames[frameIndex + 1]) {\n              targetInstance.frames[frameIndex + 1].isKeyFrame = true;\n            }\n          }\n          // update frame instances mapping\n          const index = this.frameInstances[frameIndex].indexOf(instanceId);\n          if (index >= 0) {\n            this.frameInstances[frameIndex].splice(index, 1);\n          }\n          if (this.frameInstances[frameIndex].indexOf(targetInstance.id) < 0) {\n            this.frameInstances[frameIndex].push(targetInstance.id);\n          }\n          if (frameIndex === this.currentFrame) {\n            // update shapes mapping\n            const targetShape = this.getShapeByInstance(targetInstance.id);\n            if (targetShape) {\n              this.removeShape(targetShape);\n              delete this.shapeInstanceMap[targetShape.uid];\n            }\n            const shape = this.getShapeByInstance(instanceId);\n            if (shape) {\n              if (this.labelMode) {\n                shape.label = this.getInstanceLabel(targetInstance);\n              }\n              const targetCategory = this.getCategory(category);\n              if (targetCategory) {\n                shape.color = parseInt(targetCategory.display_color.substr(1), 16);\n              }\n              this.shapeInstanceMap[shape.uid] = targetInstance.id;\n            }\n            // update current instances mapping\n            currentInstancesMap[targetInstance.id] = true;\n            delete currentInstancesMap[instanceId];\n          }\n        });\n        this.currentInstancesMap = currentInstancesMap;\n        this.setSelectedInstance(targetInstance.id);\n        if (Object.keys(currentInstance.frames).length <= 0) {\n          // remove current instance if no frame exists\n          delete this.instances[instanceId];\n          delete this.categoryInstancesMap[currentInstance.category][instanceId];\n        }\n        UndoStore.save(storeId, {\n          instances: [currentInstance, targetInstance],\n          relationships: RelationshipsStore.getRelationshipsForSave()\n        });\n      }\n      this.setInstanceMoving(false);\n      this.updateLabels();\n    };\n    /**\n     * set values to instance to specific frame\n     * @param values\n     * @param applyAll\n     * @param instanceId\n     * @param frame\n     */\n    this.setAttributes = (values, applyAll, instanceId = this.selectedInstanceId, frame = this.currentFrame) => {\n      const instance = this.instances[instanceId];\n      if (instance) {\n        const {\n          frames\n        } = instance;\n        const allFrames = Object.keys(frames).map(f => parseInt(f, 10));\n        const index = allFrames.indexOf(frame);\n        if (index >= 0) {\n          const storeId = UndoStore.preserve({\n            instances: [instance]\n          });\n          const {\n            isOCR,\n            OCRText,\n            ...attributes\n          } = values;\n          allFrames.slice(index, applyAll ? allFrames.length : index + 1).forEach(f => {\n            if (SettingsStore.labelConfig || frames[f].isOCR) {\n              frames[f].isOCR = isOCR;\n              frames[f].OCRText = OCRText;\n              if (SettingsStore.labelConfig) {\n                frames[f].attributes = {\n                  ...attributes\n                };\n              }\n              if (f === this.currentFrame) {\n                this.currentAttributes = {\n                  ...values\n                };\n              }\n            }\n          });\n          UndoStore.save(storeId, {\n            instances: [instance]\n          });\n          this.updateLabels();\n        }\n      }\n    };\n    /**\n     * set current attributes (with OCR)\n     */\n    this.setCurrentAttributes = () => {\n      this.currentAttributes = null;\n      const instance = this.instances[this.selectedInstanceId];\n      if (instance) {\n        const {\n          frames\n        } = instance;\n        const currentFrameData = frames[this.currentFrame];\n        if (currentFrameData && (SettingsStore.labelConfig || currentFrameData.isOCR)) {\n          this.currentAttributes = {\n            ...(SettingsStore.labelConfig && currentFrameData.attributes),\n            // append ocr attributes\n            isOCR: currentFrameData.isOCR,\n            OCRText: currentFrameData.OCRText\n          };\n        }\n      }\n    };\n    /**\n     * set current snapshot (for OCR)\n     */\n    this.setCurrentSnapshot = async shape => {\n      try {\n        const url = await getSnapshot(this.frames[this.currentFrame], shape);\n        this.currentSnapshot = url;\n      } catch (e) {\n        this.currentSnapshot = '';\n      }\n    };\n    /**\n     * update data (used for undo / redo)\n     * @param curr\n     * @param prev\n     */\n    this.updateData = (curr, prev) => {\n      var _prev$instances, _curr$instances;\n      const currentSelectedInstance = this.selectedInstanceId;\n      const currentInstancesMap = {\n        ...this.currentInstancesMap\n      };\n      const categoryInstancesMap = {\n        ...this.categoryInstancesMap\n      };\n      const isGridView = SettingsStore.viewMode === ViewMode.GRID;\n      (_prev$instances = prev.instances) === null || _prev$instances === void 0 ? void 0 : _prev$instances.forEach(instance => {\n        if (instance) {\n          // update instances\n          delete this.instances[instance.id];\n          Object.values(instance.frames).forEach(({\n            frameIndex\n          }) => {\n            const index = this.frameInstances[frameIndex].findIndex(i => i === instance.id);\n            if (index >= 0) {\n              this.frameInstances[frameIndex].splice(index, 1);\n            }\n          });\n          delete currentInstancesMap[instance.id];\n          delete categoryInstancesMap[instance.category][instance.id];\n          if (!isGridView) {\n            // remove shape\n            const shape = this.getShapeByInstance(instance.id);\n            if (shape) {\n              this.removeShape(shape);\n              delete this.shapeInstanceMap[shape.uid];\n            }\n          }\n          // unselect\n          if (currentSelectedInstance === instance.id) {\n            this.setSelectedInstance('');\n          }\n        }\n      });\n      (_curr$instances = curr.instances) === null || _curr$instances === void 0 ? void 0 : _curr$instances.forEach(instance => {\n        if (instance && instance.frames && Object.keys(instance.frames).length > 0) {\n          this.instances[instance.id] = instance;\n          Object.values(instance.frames).forEach(({\n            frameIndex\n          }) => {\n            if (this.frameInstances[frameIndex].findIndex(i => i === instance.id) < 0) {\n              this.frameInstances[frameIndex].push(instance.id);\n            }\n          });\n          currentInstancesMap[instance.id] = instance.frames[this.currentFrame] !== undefined;\n          if (!categoryInstancesMap[instance.category]) {\n            categoryInstancesMap[instance.category] = {};\n          }\n          categoryInstancesMap[instance.category][instance.id] = instance.number;\n          const currFrameData = instance.frames[this.currentFrame];\n          if (currFrameData !== undefined) {\n            // readd shape\n            const category = this.getCategory(instance.category);\n            if (category && !isGridView) {\n              const newShape = this.createShape(category.display_color, this.getInstanceLabel(instance), currFrameData.shapeType, currFrameData.shape);\n              this.addShapeListeners(newShape);\n              this.shapes.push(newShape);\n              this.shapeInstanceMap[newShape.uid] = instance.id;\n              if (currentSelectedInstance === instance.id) {\n                this.selectShape(newShape);\n              }\n            }\n          }\n          if (currentSelectedInstance === instance.id) {\n            this.setSelectedInstance(instance.id);\n          }\n        }\n      });\n      this.currentInstancesMap = currentInstancesMap;\n      this.categoryInstancesMap = categoryInstancesMap;\n      if (curr.relationships) {\n        RelationshipsStore.setInitialData(curr.relationships, this.instances);\n      }\n      if (prev.frames || curr.frames) {\n        var _prev$frames, _curr$frames;\n        const currFrameAttributes = toJS(FramesStore.attributes);\n        (_prev$frames = prev.frames) === null || _prev$frames === void 0 ? void 0 : _prev$frames.forEach(frame => {\n          // remove\n          delete currFrameAttributes[frame.frameIndex];\n        });\n        (_curr$frames = curr.frames) === null || _curr$frames === void 0 ? void 0 : _curr$frames.forEach(frame => {\n          // readd\n          currFrameAttributes[frame.frameIndex] = frame;\n        });\n        FramesStore.attributes = currFrameAttributes;\n      }\n      if (curr.reviews) {\n        ReviewsStore.setInitialData(curr.reviews);\n      }\n      if (isGridView) {\n        var _this$gridsRef$curren3;\n        (_this$gridsRef$curren3 = this.gridsRef.current) === null || _this$gridsRef$curren3 === void 0 ? void 0 : _this$gridsRef$curren3.update();\n      }\n      this.updateLabels();\n    };\n    /**\n     * set view mode\n     * @param viewMode\n     */\n    this.setViewMode = viewMode => {\n      if (SettingsStore.viewMode !== viewMode) {\n        SettingsStore.viewMode = viewMode;\n        this.clearShapes();\n      }\n    };\n    /**\n     * set active attributes mode\n     * @param activeMode\n     * @param type point or shape\n     */\n    this.setActiveAttributesMode = (activeMode, type = 'shape') => {\n      if (type === 'point') {\n        SettingsStore.activePointAttributesMode = activeMode;\n        this.shapes.forEach(shape => {\n          shape.userDataMode = activeMode;\n        });\n      } else {\n        SettingsStore.activeAttributesMode = activeMode;\n      }\n      this.updateLabels();\n    };\n    /**\n     * handle hotkey events\n     */\n    this.handleHotkey = ({\n      affected,\n      type,\n      attributes\n    }) => {\n      if (this.readonly) {\n        return;\n      }\n      if (affected === 'point') {\n        // set polygon point\n        const setPointsUserDataForShape = shape => {\n          if (shape instanceof Polygon || shape instanceof Line) {\n            const selectedPoints = shape.getSelectedPoints();\n            const pointsData = [];\n            selectedPoints.forEach(({\n              index,\n              point\n            }) => {\n              const userData = type === 'overwrite' ? {\n                ...attributes\n              } : {\n                ...point.userData,\n                ...attributes\n              };\n              pointsData.push({\n                index,\n                userData\n              });\n            });\n            shape.setPointsUserData(pointsData);\n          }\n        };\n        if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n          if (this.selectedShape) {\n            setPointsUserDataForShape(this.selectedShape);\n          }\n        } else {\n          const selectedInstance = this.instances[this.selectedInstanceId];\n          if (selectedInstance && selectedInstance.frames[this.currentFrame]) {\n            var _this$gridsRef$curren4;\n            const shapes = (_this$gridsRef$curren4 = this.gridsRef.current) === null || _this$gridsRef$curren4 === void 0 ? void 0 : _this$gridsRef$curren4.getShapesForGrid(this.currentFrame);\n            shapes === null || shapes === void 0 ? void 0 : shapes.forEach(shape => {\n              setPointsUserDataForShape(shape);\n            });\n          }\n        }\n      }\n    };\n    /**\n     * convert shape to polygon type\n     */\n    this.convertShapeToPolygon = () => {\n      if (!this.readonly && this.selectedShape) {\n        const instanceId = this.shapeInstanceMap[this.selectedShape.uid];\n        const instance = this.instances[instanceId];\n        if (this.selectedShape instanceof Rectangle) {\n          const storeId = UndoStore.preserve({\n            instances: [instance]\n          });\n          const points = this.selectedShape.getPoints();\n          const shape = this.createShape(this.selectedCategory.display_color, this.getInstanceLabel(instance), ShapeType.POLYGON, {\n            points\n          });\n          instance.frames[this.currentFrame] = {\n            ...instance.frames[this.currentFrame],\n            shapeType: ShapeType.POLYGON,\n            shape: shape.getData(),\n            isKeyFrame: true\n          };\n          if (instance.frames[this.currentFrame - 1]) {\n            instance.frames[this.currentFrame - 1].isKeyFrame = true;\n          }\n          if (instance.frames[this.currentFrame + 1]) {\n            instance.frames[this.currentFrame + 1].isKeyFrame = true;\n          }\n          UndoStore.save(storeId, {\n            instances: [instance]\n          });\n          this.addShapeListeners(shape);\n          this.shapes.splice(this.shapes.indexOf(this.selectedShape), 1, shape);\n          delete this.shapeInstanceMap[this.selectedShape.uid];\n          this.shapeInstanceMap[shape.uid] = instanceId;\n          this.selectedShape.destroy();\n          this.selectedShape = null;\n          this.selectShape(shape);\n          this.selectedInstanceFrames = mapValues(instance.frames, 'isKeyFrame');\n          message.success('Converted to polygon.');\n        }\n      }\n    };\n    /**\n     * trigger validation, return passed or not\n     */\n    this.triggerValidation = async () => {\n      if (this.validatorRef.current) {\n        const {\n          hasCustomError,\n          blockSubmitErrors\n        } = await this.validatorRef.current.handleSync();\n        return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n      }\n      return true;\n    };\n    /**\n     * update hidden shapes\n     */\n    this.updateHiddenShapes = () => {\n      this.shapes.forEach(shape => {\n        if (!SettingsStore.hideOthers || !this.selectedInstanceId || this.shapeInstanceMap[shape.uid] === this.selectedInstanceId) {\n          shape.visible = true;\n        } else {\n          shape.visible = false;\n        }\n      });\n    };\n    /**\n     * clear annotation\n     */\n    this.clear = () => {\n      const storeId = UndoStore.preserve({\n        instances: Object.values(this.instances),\n        relationships: RelationshipsStore.getRelationshipsForSave(),\n        frames: FramesStore.getFramesForSave(),\n        reviews: ReviewsStore.getReviewsForSave()\n      });\n\n      // unselect\n      this.selectedInstanceId = '';\n      this.selectedInstanceFrames = {};\n      this.currentAttributes = null;\n      this.currentSnapshot = '';\n      // remove all current shapes\n      this.clearShapes();\n      // reset instance\n      this.instances = {};\n      this.frameInstances = this.frames.map(() => []);\n      this.categoryInstancesMap = {};\n      this.updateLabels();\n\n      // remove relationships\n      RelationshipsStore.setInitialData([], {});\n      // remove frame validation\n      FramesStore.setInitialData([]);\n      UndoStore.save(storeId);\n      message.success('Clear completed.');\n    };\n    /**\n     * add instances in current selected category to current frame\n     */\n    this.addCategoryInstancesToCurrentFrame = () => {\n      if (SettingsStore.viewMode !== ViewMode.DEFAULT) {\n        return;\n      }\n      const instanceIds = Object.keys(this.categoryInstancesMap[this.selectedCategoryName] || {});\n      const prevInstances = [];\n      const currInstances = [];\n      for (let i = 0; i < instanceIds.length; i += 1) {\n        const instanceId = instanceIds[i];\n        const instance = this.instances[instanceId];\n        if (!instance.frames[this.currentFrame]) {\n          let shapeInfo = predictShapeData(this.currentFrame, instance.frames, this.imageBounds);\n          if (!shapeInfo) {\n            const lastFrame = Object.keys(instance.frames).pop();\n            if (lastFrame) {\n              const {\n                shapeType,\n                shape\n              } = instance.frames[parseInt(lastFrame, 10)];\n              shapeInfo = {\n                shapeType,\n                shape\n              };\n            }\n          }\n          if (shapeInfo) {\n            prevInstances.push(cloneDeep(instance));\n            const shape = this.createShape(this.selectedCategory.display_color, this.getInstanceLabel(instance), shapeInfo.shapeType, shapeInfo.shape);\n            this.addShapeToCurrentFrame(shape, instance, undefined, true, shapeInfo.shapeType, shapeInfo.shape);\n            this.addShapeListeners(shape);\n            currInstances.push(cloneDeep(instance));\n          }\n        }\n      }\n      if (prevInstances.length > 0 || currInstances.length > 0) {\n        const storeId = UndoStore.preserve({\n          instances: prevInstances\n        });\n        UndoStore.save(storeId, {\n          instances: currInstances\n        });\n      }\n    };\n    /**\n     * update label viewer\n     */\n    this.updateLabels = () => {\n      var _this$labelRef$curren;\n      (_this$labelRef$curren = this.labelRef.current) === null || _this$labelRef$curren === void 0 ? void 0 : _this$labelRef$curren.forceUpdate();\n    };\n    /**\n     * format point label\n     * @param data\n     * @returns\n     */\n    this.formatPointLabel = data => {\n      const labels = [];\n      const {\n        pointLabelItems\n      } = SettingsStore;\n      Object.keys(data).forEach(key => {\n        const label = [];\n        if (pointLabelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n          label.push(`${key}`);\n        }\n        if (pointLabelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n          label.push(`${data[key]}`);\n        }\n        if (label.length > 0) {\n          labels.push(label);\n        }\n      });\n      return labels.map(l => l.join(': ')).join('; ');\n    };\n    makeObservable(this);\n  }\n\n  /**\n   * selected category\n   */\n  get selectedCategory() {\n    const currentCategory = this.getCategory(this.selectedCategoryName);\n    return currentCategory || this.props.ontology[0];\n  }\n\n  /**\n   * current shapeType by currentTool\n   */\n  get currentShapeType() {\n    return getShapeTypeByTool(this.currentTool) || ShapeType.RECTANGLE;\n  }\n\n  /**\n   * image boundary\n   */\n  get imageBounds() {\n    var _this$image, _this$image2;\n    return {\n      left: 0,\n      top: 0,\n      right: ((_this$image = this.image) === null || _this$image === void 0 ? void 0 : _this$image.width) || 0,\n      bottom: ((_this$image2 = this.image) === null || _this$image2 === void 0 ? void 0 : _this$image2.height) || 0\n    };\n  }\n\n  /**\n   * read only (qa readonly, audit, preview)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.props.jobProxy.toolMode) || isPreview(this.props.jobProxy.toolMode);\n  }\n  async componentDidMount() {\n    this.removeKeyboardEvents = bindKeyboardEvents(this, this.props.hotkeys);\n\n    // setup i18n\n    i18n.setLocale(this.props.locale);\n\n    // init payload\n    SettingsStore.initPayload(this.props);\n    const frames = await parseFramesByPaylod(this.props);\n    this.frameInstances = frames.map(() => []);\n\n    // init relationship\n    RelationshipsStore.init(frames.length, this.props.relationships);\n    // init frame attributes\n    FramesStore.init(frames.length);\n    // init reviews\n    ReviewsStore.init(this.props.jobProxy.toolMode, this.props.issue_types);\n\n    // load saved result\n    try {\n      await this.loadResult(frames.length);\n    } catch (e) {\n      notification.error({\n        message: i18n.translate('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n    // load saved reviews\n    await this.loadReviews();\n\n    // set frame images\n    this.frames = frames;\n\n    // preload image\n    this.imagePreloader = loader(frames);\n    this.imagePreloader.preload(this.currentFrame);\n\n    // render completed\n    this.props.renderComplete();\n  }\n  componentWillUnmount() {\n    this.removeKeyboardEvents();\n  }\n  /**\n   * clear shapes\n   */\n  clearShapes() {\n    this.shapes.forEach(shape => {\n      shape.destroy();\n    });\n    this.shapes = [];\n    this.shapeInstanceMap = {};\n    this.drawingShape = null;\n    this.selectedShape = null;\n    if (this.predictedShape) {\n      this.predictedShape.destroy();\n      this.predictedShape = null;\n      this.predictedShapeType = null;\n    }\n  }\n  /**\n   * add onSelect & onChange listeners\n   * @param shape\n   */\n  addShapeListeners(shape) {\n    shape.on(EventAction.SELECTED, s => {\n      if (s !== this.predictedShape) {\n        this.selectShape(s, true);\n      }\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      const isPredicted = s === this.predictedShape && this.predictedShapeType;\n      const instanceId = isPredicted ? this.selectedInstanceId : this.shapeInstanceMap[s.uid];\n      this.updateShapeForInstance(instanceId, s, data);\n      this.updateLabels();\n    });\n    shape.on(EventAction.REMOVED, () => {\n      this.deleteShapeFromInstance(this.selectedInstanceId, [this.currentFrame]);\n    });\n    shape.on(EventAction.DRAGGING, this.updateLabels);\n    shape.on(EventAction.RESIZING, this.updateLabels);\n    shape.on(EventAction.POINTER_OVER, s => {\n      this.hoveredShapeId = s.uid;\n    });\n    shape.on(EventAction.POINTER_OUT, () => {\n      this.hoveredShapeId = '';\n    });\n  }\n  /**\n   * remove shape instance\n   * @param shape\n   */\n  removeShape(shape) {\n    if (shape === this.selectedShape) {\n      this.selectedShape = null;\n    }\n    const index = this.shapes.indexOf(shape);\n    this.shapes.splice(index, 1);\n    shape.destroy();\n  }\n  /**\n   * push to shapes array and add to mappings\n   * @param shape\n   * @param instanceId\n   * @param isKeyFrame\n   * @param shapeType\n   * @param shapeData\n   */\n  addShapeToCurrentFrame(shape, instance, isOCR, isKeyFrame = true, shapeType = this.currentShapeType, shapeData) {\n    var _this$attributesRef$c2;\n    instance.frames[this.currentFrame] = {\n      frameIndex: this.currentFrame,\n      isKeyFrame,\n      shapeType,\n      shape: shapeData || shape.getData(),\n      isOCR\n    };\n    const [lastKeyFrame] = getLastKeyFrames(1, this.currentFrame, instance.frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, this.currentFrame, instance.frames);\n    const keyFrame = lastKeyFrame !== undefined ? lastKeyFrame : nextKeyFrame;\n    if (keyFrame !== undefined) {\n      if (SettingsStore.labelConfig) {\n        instance.frames[this.currentFrame].attributes = cloneDeep(instance.frames[keyFrame].attributes);\n      }\n      if (isOCR === undefined) {\n        instance.frames[this.currentFrame].isOCR = instance.frames[keyFrame].isOCR;\n        instance.frames[this.currentFrame].OCRText = instance.frames[keyFrame].OCRText;\n      }\n    }\n    this.frameInstances[this.currentFrame].push(instance.id);\n    this.currentInstancesMap[instance.id] = true;\n    this.selectedInstanceFrames[this.currentFrame] = true;\n    if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n      // default view, should set shape status\n      this.shapes.push(shape);\n      this.shapeInstanceMap[shape.uid] = instance.id;\n      this.selectShape(shape);\n    } else {\n      // grid view, only set instance status\n      this.setSelectedInstance(instance.id);\n    }\n    this.interpolate(instance, true);\n    this.updateLabels();\n    (_this$attributesRef$c2 = this.attributesRef.current) === null || _this$attributesRef$c2 === void 0 ? void 0 : _this$attributesRef$c2.showModal();\n  }\n  /**\n   * get shape by instance id\n   * @param instanceId\n   * @returns\n   */\n  getShapeByInstance(instanceId) {\n    const shapeId = Object.keys(this.shapeInstanceMap).find(id => this.shapeInstanceMap[id] === instanceId);\n    return this.shapes.find(shape => shape.uid === shapeId);\n  }\n\n  /**\n   * get current editing instance\n   */\n  getCurrentInstance() {\n    if (this.selectedInstanceId) {\n      const instance = this.instances[this.selectedInstanceId];\n      const {\n        frames\n      } = instance;\n      if (!frames[this.currentFrame]) {\n        // instance exists, but not in current frame\n        return instance;\n      }\n    }\n    // return a new instance\n    return this.createInstance();\n  }\n\n  /**\n   * get instance by category & number\n   * @param categoryName\n   * @param number\n   * @returns {Instance | undefined}\n   */\n  getInstanceByNumber(categoryName, number) {\n    const categoryInstances = this.categoryInstancesMap[categoryName];\n    const instanceId = Object.keys(categoryInstances).find(id => categoryInstances[id] === number);\n    return instanceId ? this.instances[instanceId] : undefined;\n  }\n\n  /**\n   * create instance\n   */\n  createInstance(category = this.selectedCategory) {\n    const {\n      class_name\n    } = category;\n    const instance = {\n      id: uuidv4(),\n      category: class_name,\n      number: this.getNextInstanceNumber(category),\n      frames: {}\n    };\n    // add to instances\n    this.instances[instance.id] = instance;\n    // add to category mapping\n    if (!this.categoryInstancesMap[class_name]) {\n      this.categoryInstancesMap[class_name] = {};\n    }\n    this.categoryInstancesMap[class_name][instance.id] = instance.number;\n    return instance;\n  }\n\n  /**\n   * set selected instance\n   * @param instanceId\n   * @param isManual\n   */\n  setSelectedInstance(instanceId, isManual = false) {\n    var _this$instances$insta, _this$instances$insta2;\n    if (this.selectedInstanceId !== instanceId) {\n      this.selectedInstanceId = instanceId;\n      const selectedInstance = this.instances[instanceId];\n      this.selectedInstanceFrames = selectedInstance ? mapValues(selectedInstance.frames, 'isKeyFrame') : {};\n      // if category changes\n      if (selectedInstance && selectedInstance.category !== this.selectedCategoryName) {\n        this.selectedCategoryName = selectedInstance.category;\n      }\n      // predict changes\n      this.predict(selectedInstance);\n      // try to add relationship if needed\n      if (isManual && selectedInstance && selectedInstance.frames[this.currentFrame] !== undefined) {\n        // shape exists\n        try {\n          RelationshipsStore.addRelationship(instanceId, this.currentFrame);\n        } catch (e) {\n          message.error(e.message);\n        }\n      } else {\n        RelationshipsStore.resetTempRelationship();\n      }\n      this.updateHiddenShapes();\n    }\n    this.setCurrentAttributes();\n    if ((_this$instances$insta = this.instances[instanceId]) === null || _this$instances$insta === void 0 ? void 0 : (_this$instances$insta2 = _this$instances$insta.frames[this.currentFrame]) === null || _this$instances$insta2 === void 0 ? void 0 : _this$instances$insta2.isOCR) {\n      const shape = this.getShapeByInstance(instanceId);\n      if (shape) {\n        this.setCurrentSnapshot(shape.getData());\n      }\n    }\n  }\n  /**\n   * get next instance number\n   * @param category\n   */\n  getNextInstanceNumber(category) {\n    const categoryInstanceNumbers = Object.values(this.categoryInstancesMap[category.class_name] || {});\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * predict shape\n   * @param instance\n   */\n  predict(instance) {\n    if (this.predictedShape) {\n      this.predictedShape.destroy();\n      this.predictedShape = null;\n      this.predictedShapeType = null;\n    }\n    if (!this.readonly && instance && SettingsStore.viewMode === ViewMode.DEFAULT) {\n      const {\n        frames\n      } = instance;\n      const shapeInfo = predictShapeData(this.currentFrame, frames, this.imageBounds);\n      if (shapeInfo) {\n        // create predict shape\n        this.predictedShape = this.createShape(this.selectedCategory.display_color, this.getInstanceLabel(instance), shapeInfo.shapeType, shapeInfo.shape);\n        this.predictedShapeType = shapeInfo.shapeType;\n        this.predictedShape.borderStyle = BorderStyle.DASHED;\n        this.predictedShape.selected = true; // predicted shape is always selected\n        // add listeners\n        this.addShapeListeners(this.predictedShape);\n      }\n    }\n  }\n\n  /**\n   * interpolate shapes\n   * @param instance\n   * @param shouldInsert\n   */\n  interpolate(instance, shouldInsert = false) {\n    if (!SettingsStore.autoInterpolation) {\n      return;\n    }\n    const {\n      frames\n    } = instance;\n    const {\n      shapeType\n    } = frames[this.currentFrame];\n    const [lastKeyFrame] = getLastKeyFrames(1, this.currentFrame, frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, this.currentFrame, frames);\n    const instanceFrames = {};\n    const updateFrameData = (frameIndex, shape, insert, frameData) => {\n      if (frames[frameIndex]) {\n        frames[frameIndex].isKeyFrame = false;\n        frames[frameIndex].shape = shape;\n        frames[frameIndex].shapeType = shapeType;\n        instanceFrames[frameIndex] = false;\n      } else if (insert) {\n        frames[frameIndex] = {\n          frameIndex,\n          isKeyFrame: false,\n          shapeType,\n          shape,\n          ...(frameData && frameData.attributes && {\n            attributes: {\n              ...frameData.attributes\n            }\n          }),\n          ...(frameData && frameData.isOCR && {\n            isOCR: true,\n            OCRText: frameData.OCRText\n          })\n        };\n        this.frameInstances[frameIndex].push(instance.id);\n        instanceFrames[frameIndex] = false;\n      }\n    };\n    if (lastKeyFrame !== undefined && frames[lastKeyFrame].shapeType === shapeType) {\n      for (let i = lastKeyFrame + 1; i < this.currentFrame; i += 1) {\n        const {\n          shape\n        } = getShapeFromFrames(frames, lastKeyFrame, this.currentFrame, lastKeyFrame, i);\n        updateFrameData(i, shape, shouldInsert, frames[lastKeyFrame]);\n      }\n    }\n    if (nextKeyFrame !== undefined && frames[nextKeyFrame].shapeType === shapeType) {\n      for (let i = this.currentFrame + 1; i < nextKeyFrame; i += 1) {\n        const {\n          shape\n        } = getShapeFromFrames(frames, this.currentFrame, nextKeyFrame, this.currentFrame, i);\n        updateFrameData(i, shape, false);\n      }\n    }\n    if (Object.keys(instanceFrames).length > 0) {\n      this.selectedInstanceFrames = {\n        ...this.selectedInstanceFrames,\n        ...instanceFrames\n      };\n    }\n  }\n\n  /**\n   * set instance moving modal visible status\n   * @param moving\n   */\n  setInstanceMoving(moving) {\n    this.instanceMoving = moving;\n  }\n  renderValidator(hasValidation) {\n    return hasValidation && /*#__PURE__*/React.createElement(Validator, {\n      ref: this.validatorRef,\n      categoryInstancesMap: toJS(this.categoryInstancesMap),\n      instances: this.instances,\n      jobProxy: this.props.jobProxy,\n      getCategory: this.getCategory,\n      setFrame: this.setFrame,\n      selectInstance: this.selectInstance,\n      saveResult: () => this.saveResult('temp'),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1781,\n        columnNumber: 7\n      }\n    });\n  }\n  render() {\n    const loading = this.loading && SettingsStore.viewMode !== ViewMode.GRID;\n    const readonly = this.readonly || loading;\n    const hasRightPanel = (SettingsStore.labelConfig || this.props.tools.includes(Tool.OCR) || this.props.tools.includes(Tool.OCR_POLYGON)) && SettingsStore.viewMode !== ViewMode.GRID;\n    const hasFrameControl = this.frames.length > 1;\n    const hasValidation = Object.keys(SettingsStore.validationConfig).length > 0;\n    return /*#__PURE__*/React.createElement(LayoutWrapper, {\n      className: \"video-tracking-app\",\n      loading: loading,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1801,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(AutoSaver, {\n      ref: this.saverRef,\n      leaveCheck: true,\n      data: {\n        storePointer: UndoStore.pointer,\n        storeId: UndoStore.lastStoreId\n      },\n      save: () => this.save(true),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1802,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(Toolbar, {\n      readonly: readonly,\n      tools: this.props.tools,\n      currentTool: this.currentTool,\n      gridViewEnabled: hasFrameControl,\n      addMode: this.addMode,\n      labelMode: this.labelMode,\n      viewScale: SettingsStore.viewScale,\n      selectedInstanceId: this.selectedInstanceId,\n      selectedInstanceInCurrentFrame: this.currentInstancesMap[this.selectedInstanceId],\n      updateData: this.updateData,\n      onCurrentToolChanges: this.changeCurrentTool,\n      onAddModeChanges: this.changeAddMode,\n      onLabelModeChanges: this.changeLabelMode,\n      onViewModeChanges: this.setViewMode,\n      onAttributesModeChanges: this.setActiveAttributesMode,\n      onViewReset: () => {\n        var _this$canvasRef$curre;\n        return (_this$canvasRef$curre = this.canvasRef.current) === null || _this$canvasRef$curre === void 0 ? void 0 : _this$canvasRef$curre.fitImageToView();\n      },\n      setViewScale: scale => {\n        var _this$canvasRef$curre2;\n        return (_this$canvasRef$curre2 = this.canvasRef.current) === null || _this$canvasRef$curre2 === void 0 ? void 0 : _this$canvasRef$curre2.zoomTo(scale);\n      },\n      updateHiddenShapes: this.updateHiddenShapes,\n      onSave: () => this.save(),\n      onClear: this.clear,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1808,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"container\",\n      style: {\n        height: `calc(100% - ${hasFrameControl ? `${this.frameControlHeight + 36}px` : '36px'})`,\n        transition: 'height 0.15s'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1830,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Sidebar, {\n      readonly: readonly,\n      ontology: this.props.ontology,\n      currentFrame: this.currentFrame,\n      currentInstancesMap: toJS(this.currentInstancesMap),\n      categoryInstancesMap: toJS(this.categoryInstancesMap),\n      instances: this.instances,\n      selectedInstanceId: this.selectedInstanceId,\n      selectedCategoryName: this.selectedCategoryName,\n      hasValidation: hasValidation,\n      selectInstance: this.selectInstance,\n      selectCategory: this.selectCategory,\n      addShapeToInstance: instanceId => {\n        if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n          this.addShapeToInstance(instanceId);\n        } else {\n          var _this$gridsRef$curren5;\n          (_this$gridsRef$curren5 = this.gridsRef.current) === null || _this$gridsRef$curren5 === void 0 ? void 0 : _this$gridsRef$curren5.addShapeToGrid(this.currentFrame, instanceId);\n        }\n      },\n      deleteShapeFromInstance: this.deleteShapeFromInstanceByType,\n      openInstanceMove: () => this.setInstanceMoving(true),\n      renderValidator: () => this.renderValidator(hasValidation),\n      getInstanceLabel: this.getInstanceLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1837,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        width: `calc(100% - ${hasRightPanel ? '526px' : '286px'})`,\n        position: 'relative',\n        cursor: this.cursor\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1861,\n        columnNumber: 11\n      }\n    }, SettingsStore.viewMode === ViewMode.DEFAULT && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Canvas, {\n      ref: this.canvasRef,\n      app: this.props.app,\n      crossline: SettingsStore.crossLineVisible,\n      measurementBox: toJS(SettingsStore.activeMeasurementBox),\n      imageUrl: this.frames[this.currentFrame],\n      interactive: !this.loading,\n      onImageLoaded: this.setupFrame,\n      onScaleChange: scale => {\n        SettingsStore.setViewScale(scale);\n        this.updateLabels();\n      },\n      onPositionChange: () => {\n        this.updateLabels();\n        for (let i = 0; i < this.shapes.length; i += 1) {\n          this.shapes[i].drawShapeLabel();\n        }\n      },\n      onClick: this.addShape,\n      onBlankClick: this.unselectShape,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1870,\n        columnNumber: 17\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.labelsContainer,\n      className: \"instance-labels-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1891,\n        columnNumber: 17\n      }\n    }), /*#__PURE__*/React.createElement(LabelViewer, {\n      ref: this.labelRef,\n      shapes: this.shapes,\n      shapeInstanceMap: this.shapeInstanceMap,\n      instances: this.instances,\n      selectedInstanceId: this.selectedInstanceId,\n      currentFrame: this.currentFrame,\n      hoveredShapeId: this.hoveredShapeId,\n      hideOthers: SettingsStore.hideOthers,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1892,\n        columnNumber: 17\n      }\n    }), !this.readonly && /*#__PURE__*/React.createElement(GridTool, {\n      ref: this.gridToolRef,\n      undoPointer: UndoStore.pointer,\n      undoStackId: UndoStore.lastStoreId,\n      loading: this.loading,\n      addMode: this.addMode,\n      currentTool: this.currentTool,\n      selectedInstanceId: this.selectedInstanceId,\n      selectedShape: this.selectedShape,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1903,\n        columnNumber: 19\n      }\n    })), SettingsStore.viewMode === ViewMode.GRID && /*#__PURE__*/React.createElement(GridView, {\n      ref: this.gridsRef,\n      app: this.props.app,\n      readonly: this.readonly,\n      labelMode: this.labelMode,\n      attributesMode: SettingsStore.activePointAttributesMode,\n      frames: this.frames,\n      currentFrame: this.currentFrame,\n      instances: this.instances,\n      selectedInstanceId: this.selectedInstanceId,\n      selectedCategoryColor: this.selectedCategory.display_color,\n      setFrame: this.setFrame,\n      addShape: this.addShape,\n      createShape: this.createShape,\n      updateShape: this.updateShapeForInstance,\n      deleteShape: this.deleteShapeFromInstance,\n      addShapeToInstance: this.addShapeToInstance,\n      getInstanceLabel: this.getInstanceLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1917,\n        columnNumber: 15\n      }\n    })), hasRightPanel && /*#__PURE__*/React.createElement(Attributes, {\n      ref: this.attributesRef,\n      readonly: readonly,\n      isMultiFrame: this.frames.length > 1,\n      config: toJS(SettingsStore.labelConfig),\n      ocrTagGroup: toJS(SettingsStore.ocrTagGroup),\n      values: toJS(this.currentAttributes),\n      snapshot: this.currentSnapshot,\n      currentFrame: this.currentFrame,\n      currentImage: this.frames[this.currentFrame],\n      selectedInstance: this.instances[this.selectedInstanceId],\n      selectedCategoryColor: this.selectedCategory.display_color,\n      onValuesChange: this.setAttributes,\n      getInstanceLabel: this.getInstanceLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1939,\n        columnNumber: 13\n      }\n    })), hasFrameControl && /*#__PURE__*/React.createElement(FrameControl, {\n      readonly: readonly,\n      undoStackPointer: UndoStore.pointer,\n      frameCount: this.frames.length,\n      frameLoading: loading,\n      currentFrame: this.currentFrame,\n      invalidFrames: toJS(FramesStore.invalidFrames),\n      categoryInstancesMap: toJS(this.categoryInstancesMap),\n      instances: this.instances,\n      frameInstances: this.frameInstances,\n      frameReviews: toJS(ReviewsStore.frameReviewsMap),\n      selectedInstance: this.instances[this.selectedInstanceId],\n      selectedInstanceFrames: toJS(this.selectedInstanceFrames),\n      selectInstance: this.selectInstance,\n      setFrame: this.setFrame,\n      getCategory: this.getCategory,\n      getInstanceLabel: this.getInstanceLabel,\n      onHeightChange: height => {\n        this.frameControlHeight = height;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1957,\n        columnNumber: 11\n      }\n    }), this.selectedInstanceId && this.instanceMoving && /*#__PURE__*/React.createElement(InstanceMove, {\n      ontology: this.props.ontology,\n      currentFrame: this.currentFrame,\n      activeInstanceId: this.selectedInstanceId,\n      instances: this.instances,\n      categoryInstancesMap: toJS(this.categoryInstancesMap),\n      onMove: this.move,\n      onClose: () => this.setInstanceMoving(false),\n      getInstanceLabel: this.getInstanceLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1980,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(Review, {\n      currentFrame: this.currentFrame,\n      instances: this.instances,\n      saveFile: this.props.jobProxy.saveFile,\n      onReviewed: () => {\n        var _this$gridsRef$curren6;\n        return (_this$gridsRef$curren6 = this.gridsRef.current) === null || _this$gridsRef$curren6 === void 0 ? void 0 : _this$gridsRef$curren6.updateStyle(this.currentFrame);\n      },\n      getInstanceLabel: this.getInstanceLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1991,\n        columnNumber: 9\n      }\n    }));\n  }\n}, _VideoTracking.defaultProps = {\n  tools: Object.values(Tool)\n}, _VideoTracking), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"frames\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return [];\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"currentFrame\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"currentTool\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return this.props.tools[0];\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, \"loading\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return true;\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, \"addMode\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, \"labelMode\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return true;\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, \"cursor\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return Cursor.INHERIT;\n  }\n}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, \"selectedCategoryName\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    var _this$props$ontology$;\n    return (_this$props$ontology$ = this.props.ontology[0]) === null || _this$props$ontology$ === void 0 ? void 0 : _this$props$ontology$.class_name;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, \"selectedInstanceId\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor0 = _applyDecoratedDescriptor(_class2.prototype, \"selectedInstanceFrames\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {};\n  }\n}), _descriptor1 = _applyDecoratedDescriptor(_class2.prototype, \"currentInstancesMap\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {};\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, \"categoryInstancesMap\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {};\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, \"currentAttributes\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return null;\n  }\n}), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, \"currentSnapshot\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, \"hoveredShapeId\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, \"instanceMoving\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, \"frameControlHeight\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 104;\n  }\n}), _applyDecoratedDescriptor(_class2.prototype, \"selectedCategory\", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, \"selectedCategory\"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, \"currentShapeType\", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, \"currentShapeType\"), _class2.prototype), _class2)) || _class;\nexport default AppWrapper(VideoTracking, {\n  mappingMethods: Object.values(methods)\n});","map":{"version":3,"names":["React","message","notification","observable","computed","toJS","makeObservable","observer","v4","uuidv4","cloneDeep","mapValues","isEqual","AutoSaver","LayoutWrapper","AppWrapper","Canvas","ShapeFactory","ShapeType","BorderStyle","EventAction","Polygon","Line","Rectangle","RectType","Label","Cursor","GridView","Toolbar","Sidebar","Attributes","FrameControl","InstanceMove","Review","Validator","LabelViewer","GridTool","bindKeyboardEvents","UndoStore","SettingsStore","RelationshipsStore","ReviewsStore","FramesStore","Tool","ViewMode","LabelItem","parseFramesByPaylod","loadInstancesFromResult","predictShapeData","getLastKeyFrames","getNextKeyFrames","getShapeFromFrames","getSnapshot","getShapeTypeByTool","getToolTypeFromFrameData","methods","i18n","loader","isPreview","isAnnotationReadonly","isReviewEditable","VideoTracking","_class","_class2","_VideoTracking","Component","constructor","props","_initializerDefineProperty","_descriptor","_descriptor2","_descriptor3","_descriptor4","_descriptor5","_descriptor6","_descriptor7","_descriptor8","_descriptor9","_descriptor0","_descriptor1","_descriptor10","_descriptor11","_descriptor12","_descriptor13","_descriptor14","_descriptor15","instances","frameInstances","initialData","shapes","shapeInstanceMap","drawingShape","selectedShape","predictedShape","predictedShapeType","image","imagePreloader","labelsContainer","createRef","canvasRef","gridsRef","labelRef","attributesRef","saverRef","validatorRef","gridToolRef","removeKeyboardEvents","loadResult","frameCount","result","jobProxy","auditId","setAuditId","categoryInstancesMap","setInitialData","relationships","frames","reviewFrom","loadReviewFrom","getStatistics","reviews","getReviewsForSave","forEach","review","instanceId","frameIndex","Object","values","instance","frame","id","shape","rejected","approved","saveResult","type","_this$saverRef$curren","current","disableLeaveCheck","submitCheck","passed","triggerValidation","Error","translate","allInstances","map","getRelationshipsForSave","getFramesForSave","loadReviews","saveReviews","_this$saverRef$curren2","save","isAutoSave","toolMode","length","promises","push","_this$saverRef$curren3","Promise","all","success","setTempSaved","e","error","isModified","currInstances","currRelationships","currFrames","changeCurrentTool","tool","currentTool","addMode","changeAddMode","forceChange","_this$attributesRef$c","readonly","instanceMoving","modalVisible","currentInstanceId","cursor","CROSSHAIR","DEFAULT","interactive","destroy","selectedInstanceId","predict","undefined","changeLabelMode","labelMode","intance","uid","label","getInstanceLabel","style","display","setFrame","currentFrame","_this$imagePreloader","viewMode","loading","setupFrameData","preload","clearShapes","setInstanceMoving","resetTempRelationship","currentInstancesMap","reduce","acc","curr","setupFrame","_","category","getCategory","createShape","display_color","shapeType","editable","addShapeListeners","selectInstance","updateHiddenShapes","updateLabels","createShapeLabel","shapeLabel","className","addToContainer","hexColor","shapeData","shapeContainer","imageBounds","useCurrent","color","parseInt","substr","currentShapeType","getShape","app","container","selectedColor","alpha","boundaryCheck","bounds","CENTERLINE_RECTANGLE","centerLineEnabled","FOUR_DOTS_RECTANGLE","rectType","FOUR_DOTS_RECT","rotatable","labelDom","userDataFormatter","formatPointLabel","RECTANGLE","rotation","userDataMode","activePointAttributesMode","addShape","point","selectedCategory","on","FINISHED","off","REMOVED","getCurrentInstance","storeId","preserve","addShapeToCurrentFrame","OCR","OCR_POLYGON","_this$gridsRef$curren","update","options","GRID","colsCount","getColsCount","rowsCount","getRowsCount","cols","rows","create","selectShape","isManual","selected","setSelectedInstance","unselectShape","updateShapeForInstance","borderStyle","SOLID","isKeyFrame","selectedInstanceFrames","interpolate","isOCR","setCurrentSnapshot","addShapeToInstance","stackId","shapeInfo","lastFrame","keys","pop","delete","getShapeByInstance","pointsDeleted","deleteSelectedPoints","deleteShapeFromInstance","_this$gridsRef$curren2","i","deleteFrame","instanceIndex","indexOf","splice","removeShape","deleteRelationshipByInstance","deleteReviewByInstance","deleteShapeFromInstanceByType","nextKeyFrames","nextKeyFrame","Array","from","index","display_name","class_name","number","selectCategory","categoryName","selectedCategoryName","ontology","find","o","move","currentInstance","targetInstance","createInstance","getInstanceByNumber","switchRelationshipInstance","isRangeStart","isRangeEnd","targetShape","targetCategory","setAttributes","applyAll","allFrames","f","OCRText","attributes","slice","labelConfig","currentAttributes","setCurrentAttributes","currentFrameData","url","currentSnapshot","updateData","prev","_prev$instances","_curr$instances","currentSelectedInstance","isGridView","findIndex","currFrameData","newShape","_prev$frames","_curr$frames","currFrameAttributes","_this$gridsRef$curren3","setViewMode","setActiveAttributesMode","activeMode","activeAttributesMode","handleHotkey","affected","setPointsUserDataForShape","selectedPoints","getSelectedPoints","pointsData","userData","setPointsUserData","selectedInstance","_this$gridsRef$curren4","getShapesForGrid","convertShapeToPolygon","points","getPoints","POLYGON","getData","hasCustomError","blockSubmitErrors","handleSync","hideOthers","visible","clear","addCategoryInstancesToCurrentFrame","instanceIds","prevInstances","_this$labelRef$curren","forceUpdate","data","labels","pointLabelItems","key","includes","ATTRIBUTE_KEYS","ATTRIBUTE_VALUES","l","join","currentCategory","_this$image","_this$image2","left","top","right","width","bottom","height","componentDidMount","hotkeys","setLocale","locale","initPayload","init","issue_types","duration","renderComplete","componentWillUnmount","SELECTED","s","CHANGED","isPredicted","DRAGGING","RESIZING","POINTER_OVER","hoveredShapeId","POINTER_OUT","_this$attributesRef$c2","lastKeyFrame","keyFrame","showModal","shapeId","categoryInstances","getNextInstanceNumber","_this$instances$insta","_this$instances$insta2","addRelationship","categoryInstanceNumbers","Math","max","DASHED","shouldInsert","autoInterpolation","instanceFrames","updateFrameData","insert","frameData","moving","renderValidator","hasValidation","createElement","ref","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","render","hasRightPanel","tools","hasFrameControl","validationConfig","leaveCheck","storePointer","pointer","lastStoreId","gridViewEnabled","viewScale","selectedInstanceInCurrentFrame","onCurrentToolChanges","onAddModeChanges","onLabelModeChanges","onViewModeChanges","onAttributesModeChanges","onViewReset","_this$canvasRef$curre","fitImageToView","setViewScale","scale","_this$canvasRef$curre2","zoomTo","onSave","onClear","frameControlHeight","transition","_this$gridsRef$curren5","addShapeToGrid","openInstanceMove","position","Fragment","crossline","crossLineVisible","measurementBox","activeMeasurementBox","imageUrl","onImageLoaded","onScaleChange","onPositionChange","drawShapeLabel","onClick","onBlankClick","undoPointer","undoStackId","attributesMode","selectedCategoryColor","updateShape","deleteShape","isMultiFrame","config","ocrTagGroup","snapshot","currentImage","onValuesChange","undoStackPointer","frameLoading","invalidFrames","frameReviews","frameReviewsMap","onHeightChange","activeInstanceId","onMove","onClose","saveFile","onReviewed","_this$gridsRef$curren6","updateStyle","defaultProps","_applyDecoratedDescriptor","prototype","configurable","enumerable","writable","initializer","INHERIT","_this$props$ontology$","getOwnPropertyDescriptor","mappingMethods"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking/index.tsx"],"sourcesContent":["import React from 'react';\nimport { message, notification } from 'antd';\nimport { observable, computed, toJS, makeObservable } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { cloneDeep, mapValues, isEqual } from 'lodash';\nimport { Application, Sprite, Point, Container } from 'pixi.js';\nimport AutoSaver from '../common/AutoSaver';\nimport LayoutWrapper from '../common/layout/LayoutWrapper';\nimport AppWrapper from '../common/shapes/wrapper/AppWrapper';\nimport Canvas from '../common/shapes/canvas/Canvas';\nimport ShapeFactory from '../common/shapes/ShapeFactory';\nimport { ShapeType, ShapeData } from '../common/shapes/types';\nimport Shape, { BorderStyle, EventAction, UserDataMode } from '../common/shapes/Shape';\nimport Polygon from '../common/shapes/Polygon';\nimport Line from '../common/shapes/Line';\nimport Rectangle, { RectType, RectangleData } from '../common/shapes/Rectangle';\nimport Label from '../common/shapes/label/Label';\nimport Cursor from '../common/Cursor';\nimport GridView from './components/GridView';\nimport Toolbar from './components/Toolbar';\nimport Sidebar from './components/Sidebar';\nimport Attributes, { AttributesHandle } from './components/Attributes';\nimport FrameControl from './components/FrameControl';\nimport InstanceMove from './components/InstanceMove';\nimport Review from './components/Review';\nimport Validator from './components/Validator';\nimport LabelViewer from './components/LabelViewer';\nimport GridTool, { GridToolHandle } from './components/GridTool';\nimport bindKeyboardEvents from './keyboard-events';\nimport UndoStore, { StoreData } from './store/UndoStore';\nimport SettingsStore from './store/SettingsStore';\nimport RelationshipsStore from './store/RelationshipsStore';\nimport ReviewsStore from './store/ReviewsStore';\nimport FramesStore from './store/FramesStore';\nimport { Tool, Ontology, Instance, CategoryInstancesMap, FrameData, HotkeyItem, AttributesMode, ViewMode, LabelItem } from './types';\nimport {\n  parseFramesByPaylod,\n  loadInstancesFromResult,\n  predictShapeData,\n  getLastKeyFrames,\n  getNextKeyFrames,\n  getShapeFromFrames,\n  getSnapshot,\n  getShapeTypeByTool,\n  getToolTypeFromFrameData,\n} from './utils';\nimport { methods } from './payload';\nimport i18n from './locales';\nimport JobProxy from '../../libs/JobProxy';\nimport loader, { ImagePreloader } from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly, isReviewEditable } from '../../utils/tool-mode';\nimport 'antd/es/message/style/index.css';\nimport './index.scss';\n\ninterface VideoTrackingProps {\n  locale?: string;\n  issue_types?: string;\n  tools: Tool[];\n  ontology: Ontology[];\n  label_config?: string;\n  ocr_tag_group?: string;\n  hotkeys?: string;\n  relationships?: string;\n  measurement_box?: string;\n  auto_interpolation?: string | boolean;\n  boundary_check?: string | boolean;\n  base_url?: string;\n  frames?: string | string[];\n  custom_check?: string;\n  submit_check?: string | boolean;\n  app: Application;\n  jobProxy: JobProxy;\n  renderComplete: () => Promise<void>;\n}\n\n@observer\nexport class VideoTracking extends React.Component<VideoTrackingProps> {\n  static defaultProps = {\n    tools: Object.values(Tool),\n  };\n\n  /**\n   * frame image urls\n   */\n  @observable frames: string[] = [];\n\n  /**\n   * current frame index\n   */\n  @observable currentFrame = 0;\n\n  /**\n   * current tool\n   */\n  @observable currentTool = this.props.tools[0];\n\n  /**\n   * frame loading\n   */\n  @observable loading = true;\n\n  /**\n   * add mode, true means adding active\n   */\n  @observable addMode = false;\n\n  /**\n   * show shape labels or not\n   */\n  @observable labelMode = true;\n\n  /**\n   * current cursor\n   */\n  @observable cursor = Cursor.INHERIT;\n\n  /**\n   * selected category class_name (status cross frames)\n   */\n  @observable selectedCategoryName = this.props.ontology[0]?.class_name;\n\n  /**\n   * selected instance id (status cross frames)\n   */\n  @observable selectedInstanceId = '';\n\n  /**\n   * selected instance frame status (used for frame control render)\n   */\n  @observable selectedInstanceFrames: {[frameIndex: number]: boolean} = {};\n\n  /**\n   * instances in current frame (used for sidebar render)\n   */\n  @observable currentInstancesMap: {[instanceId: string]: boolean} = {};\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  @observable categoryInstancesMap: CategoryInstancesMap = {};\n\n  /**\n   * current selected instance shape attributes\n   */\n  @observable currentAttributes: any = null;\n\n  /**\n   * current selected instance shape snapshot\n   */\n  @observable currentSnapshot = '';\n\n  /**\n   * currently hovered shape\n   */\n  @observable hoveredShapeId = '';\n\n  /**\n   * whether instance move modal is open\n   */\n  @observable instanceMoving = false;\n\n  /**\n   * frame control height (default is 48 + 56 = 104)\n   */\n  @observable frameControlHeight = 104;\n\n  /**\n   * all instances\n   */\n  instances: {[instanceId: string]: Instance} = {};\n\n  /**\n   * frame instances\n   */\n  frameInstances: string[][] = [];\n\n  /**\n   * initial data copy\n   */\n  initialData: any = null;\n\n  /**\n   * shape instances in current frame\n   */\n  shapes: Shape<ShapeData>[] = [];\n\n  /**\n   * shape instance map (used for shape select & instance select)\n   */\n  shapeInstanceMap: {[shapeId: string]: string} = {};\n\n  /**\n   * currently drawing shape\n   */\n  drawingShape: Shape<ShapeData> | null = null;\n\n  /**\n   * currently selected shape\n   */\n  selectedShape: Shape<ShapeData> | null = null;\n\n  /**\n   * predicted selected instance shape in current frame\n   */\n  predictedShape: Shape<ShapeData> | null = null;\n\n  /**\n   * predicted selected instance shape type\n   */\n  predictedShapeType: ShapeType | null = null;\n\n  /**\n   * current image\n   */\n  image: Sprite | null = null;\n\n  /**\n   * image preloader\n   */\n  imagePreloader: ImagePreloader | null = null;\n\n  /**\n   * shape labels container\n   */\n  labelsContainer = React.createRef<HTMLDivElement>();\n\n  /**\n   * canvas reference\n   */\n  canvasRef = React.createRef<Canvas>();\n\n  /**\n   * grid view reference\n   */\n  gridsRef = React.createRef<GridView>();\n\n  /**\n   * label viewer\n   */\n  labelRef = React.createRef<LabelViewer>();\n\n  /**\n   * attributes reference\n   */\n  attributesRef = React.createRef<AttributesHandle>();\n\n  /**\n   * auto saver reference\n   */\n  saverRef = React.createRef<AutoSaver>();\n\n  /**\n   * validator reference\n   */\n  validatorRef = React.createRef<Validator>();\n\n  /**\n   * grid tool reference\n   */\n  gridToolRef = React.createRef<GridToolHandle>();\n\n  /**\n   * keyboard events\n   */\n  removeKeyboardEvents = () => {};\n\n  constructor(props: VideoTrackingProps) {\n    super(props);\n    makeObservable(this);\n  }\n\n  /**\n   * selected category\n   */\n  @computed get selectedCategory() {\n    const currentCategory = this.getCategory(this.selectedCategoryName);\n    return currentCategory || this.props.ontology[0];\n  }\n\n  /**\n   * current shapeType by currentTool\n   */\n  @computed get currentShapeType() {\n    return getShapeTypeByTool(this.currentTool) || ShapeType.RECTANGLE;\n  }\n\n  /**\n   * image boundary\n   */\n  get imageBounds() {\n    return { left: 0, top: 0, right: this.image?.width || 0, bottom: this.image?.height || 0 };\n  }\n\n  /**\n   * read only (qa readonly, audit, preview)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.props.jobProxy.toolMode) || isPreview(this.props.jobProxy.toolMode);\n  }\n\n  async componentDidMount() {\n    this.removeKeyboardEvents = bindKeyboardEvents(this, this.props.hotkeys);\n\n    // setup i18n\n    i18n.setLocale(this.props.locale);\n\n    // init payload\n    SettingsStore.initPayload(this.props);\n\n    const frames = await parseFramesByPaylod(this.props);\n    this.frameInstances = frames.map(() => []);\n\n    // init relationship\n    RelationshipsStore.init(frames.length, this.props.relationships);\n    // init frame attributes\n    FramesStore.init(frames.length);\n    // init reviews\n    ReviewsStore.init(this.props.jobProxy.toolMode, this.props.issue_types);\n\n    // load saved result\n    try {\n      await this.loadResult(frames.length);\n    } catch (e) {\n      notification.error({ message: i18n.translate('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n    // load saved reviews\n    await this.loadReviews();\n\n    // set frame images\n    this.frames = frames;\n\n    // preload image\n    this.imagePreloader = loader(frames);\n    this.imagePreloader.preload(this.currentFrame);\n\n    // render completed\n    this.props.renderComplete();\n  }\n\n  componentWillUnmount() {\n    this.removeKeyboardEvents();\n  }\n\n  loadResult = async (frameCount: number) => {\n    const result = await this.props.jobProxy.loadResult();\n    if (!result) {\n      return;\n    }\n    if (result.auditId) {\n      this.props.jobProxy.setAuditId(result.auditId);\n    }\n    const { instances, frameInstances, categoryInstancesMap } = loadInstancesFromResult(result, frameCount);\n    this.instances = instances;\n    this.frameInstances = frameInstances;\n    this.categoryInstancesMap = categoryInstancesMap;\n    RelationshipsStore.setInitialData(result.relationships, instances);\n    FramesStore.setInitialData(result.frames);\n    // copy initial data\n    const reviewFrom = await this.props.jobProxy.loadReviewFrom();\n    if (reviewFrom) {\n      this.initialData = cloneDeep({\n        instances: reviewFrom.instances,\n        relationships: reviewFrom.relationships,\n        frames: reviewFrom.frames,\n      });\n    }\n  };\n\n  getStatistics = () => {\n    const reviews: {\n      [instanceId: string]: {[frameIndex: number]: string};\n    } = {};\n    ReviewsStore.getReviewsForSave().forEach((review) => {\n      if (!reviews[review.instanceId]) {\n        reviews[review.instanceId] = {};\n      }\n      reviews[review.instanceId][review.frameIndex] = review.result;\n    });\n    const shapes: {\n      [shape: string]: {rejected: number; approved: number};\n    } = {};\n    Object.values(this.instances).forEach((instance: Instance) => {\n      Object.values(instance.frames).forEach((frame) => {\n        let review;\n        if (reviews[instance.id]) {\n          review = reviews[instance.id][frame.frameIndex];\n        }\n        const shape = `${getToolTypeFromFrameData(frame)}`;\n        if (!shapes[shape]) {\n          shapes[shape] = {\n            rejected: 0,\n            approved: 0,\n          };\n        }\n        if (review === 'reject') {\n          shapes[shape].rejected += 1;\n        } else {\n          shapes[shape].approved += 1;\n        }\n      });\n    });\n    return { shapes };\n  };\n\n  saveResult = async (type = 'submit') => {\n    if (type === 'submit') {\n      this.saverRef.current?.disableLeaveCheck();\n      if (SettingsStore.submitCheck) {\n        // validate before submit\n        const passed = await this.triggerValidation();\n        if (!passed) {\n          throw new Error(i18n.translate('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n\n    const allInstances = Object.values(this.instances).map((instance) => ({\n      ...instance,\n      frames: Object.values(instance.frames),\n    }));\n    return this.props.jobProxy.saveResult({\n      auditId: this.props.jobProxy.auditId,\n      instances: allInstances,\n      relationships: RelationshipsStore.getRelationshipsForSave(),\n      frames: FramesStore.getFramesForSave(),\n    }, type === 'submit');\n  };\n\n  loadReviews = async () => {\n    const reviews = await this.props.jobProxy.loadReviews();\n    ReviewsStore.setInitialData(reviews);\n  };\n\n  saveReviews = (type = 'submit') => {\n    if (type === 'submit') {\n      this.saverRef.current?.disableLeaveCheck();\n    }\n    const reviews = ReviewsStore.getReviewsForSave();\n    return this.props.jobProxy.saveReviews(reviews);\n  };\n\n  save = async (isAutoSave = false) => {\n    const { toolMode } = this.props.jobProxy;\n    if (this.frames.length <= 0 || isPreview(toolMode)) { // not rendered, or is preview mode\n      return;\n    }\n\n    const promises = [];\n    if (!isAnnotationReadonly(toolMode)) {\n      promises.push(this.saveResult('temp'));\n    }\n    if (isReviewEditable(toolMode)) {\n      promises.push(this.saveReviews('temp'));\n    }\n    if (promises.length > 0) {\n      try {\n        await Promise.all(promises);\n        message.success(i18n.translate(isAutoSave ? 'SAVE_AUTO_SUCCESS' : 'SAVE_SUCCESS'));\n        // update tempSaved flag\n        this.saverRef.current?.setTempSaved(true);\n      } catch (e) {\n        if (!isAutoSave) {\n          message.error(i18n.translate('SAVE_FAIL'));\n        } else {\n          throw e;\n        }\n      }\n    }\n  };\n\n  isModified = () => {\n    const currInstances = Object.values(this.instances).map((instance) => ({\n      ...instance,\n      frames: Object.values(instance.frames),\n    }));\n    const currRelationships = RelationshipsStore.getRelationshipsForSave();\n    const currFrames = FramesStore.getFramesForSave();\n    const { instances = [], relationships = [], frames = [] } = this.initialData || {};\n    return !isEqual(currInstances, instances) || !isEqual(currRelationships, relationships) || !isEqual(currFrames, frames);\n  };\n\n  /**\n   * chhange current tool\n   * @param tool\n   */\n  changeCurrentTool = (tool: Tool) => {\n    this.currentTool = tool;\n    if (!this.addMode) {\n      this.changeAddMode(true);\n    }\n  };\n\n  /**\n   * change add mode\n   * @param addMode\n   * @param forceChange\n   */\n  changeAddMode = (addMode: boolean, forceChange = false) => {\n    if (!forceChange && (\n      this.readonly ||\n      this.instanceMoving ||\n      this.attributesRef.current?.modalVisible ||\n      !!ReviewsStore.currentInstanceId\n    )) {\n      return;\n    }\n\n    this.addMode = addMode;\n    // change cursor\n    this.cursor = addMode ? Cursor.CROSSHAIR : Cursor.DEFAULT;\n    // change other shapes interactive\n    this.shapes.forEach((shape) => {\n      shape.interactive = !addMode;\n    });\n    // remove drawing shape if needed\n    if (!addMode && this.drawingShape) {\n      this.drawingShape.destroy();\n      this.drawingShape = null;\n    }\n    // hide or show predict shape\n    if (this.selectedInstanceId) {\n      this.predict(addMode ? undefined : this.instances[this.selectedInstanceId]);\n    }\n  };\n\n  /**\n   * change label mode\n   * @param labelMode\n   */\n  changeLabelMode = (labelMode: boolean) => {\n    if (this.labelMode !== labelMode) {\n      this.labelMode = labelMode;\n      this.shapes.forEach((shape) => {\n        const intance = this.instances[this.shapeInstanceMap[shape.uid]];\n        shape.label = this.labelMode ? this.getInstanceLabel(intance) : '';\n      });\n      if (this.predictedShape) {\n        this.predictedShape.label = this.labelMode ? this.getInstanceLabel(this.instances[this.selectedInstanceId]) : '';\n      }\n      if (this.labelsContainer.current) {\n        this.labelsContainer.current.style.display = labelMode ? 'block' : 'none';\n      }\n    }\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  setFrame = (frame: number) => {\n    if (this.currentFrame !== frame) {\n      this.currentFrame = frame;\n      if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n        this.loading = true;\n      } else {\n        this.setupFrameData();\n      }\n      this.imagePreloader?.preload(this.currentFrame);\n    }\n  };\n\n  /**\n   * setup frame data\n   */\n  setupFrameData = () => {\n    // remove all current shapes\n    this.clearShapes();\n\n    // close modals\n    this.setInstanceMoving(false);\n    // turn off add mode\n    this.changeAddMode(false, true);\n    // reset temp relationship\n    RelationshipsStore.resetTempRelationship();\n\n    // add shapes in current frame\n    this.currentInstancesMap = this.frameInstances[this.currentFrame]\n      .reduce((acc, curr) => ({ ...acc, [curr]: true }), {} as {[instanceId: string]: boolean});\n  };\n\n  /**\n   * setup frame shapes\n   */\n  setupFrame = (_: string, image: Sprite) => {\n    this.image = image;\n\n    // setup frame data\n    this.setupFrameData();\n    // create frame shapes\n    this.frameInstances[this.currentFrame].forEach((instanceId) => {\n      const instance = this.instances[instanceId];\n      const category = this.getCategory(instance.category);\n      if (category) {\n        const shape = this.createShape(\n          category.display_color,\n          this.getInstanceLabel(instance),\n          instance.frames[this.currentFrame].shapeType,\n          instance.frames[this.currentFrame].shape,\n        );\n        if (this.readonly) {\n          shape.editable = false;\n        }\n        this.addShapeListeners(shape);\n        this.shapes.push(shape);\n        this.shapeInstanceMap[shape.uid] = instance.id;\n      }\n    });\n\n    if (this.selectedInstanceId) {\n      this.selectInstance(this.selectedInstanceId);\n    }\n    this.updateHiddenShapes();\n    this.updateLabels();\n\n    this.loading = false;\n  };\n\n  /**\n   * clear shapes\n   */\n  clearShapes() {\n    this.shapes.forEach((shape) => {\n      shape.destroy();\n    });\n    this.shapes = [];\n    this.shapeInstanceMap = {};\n    this.drawingShape = null;\n    this.selectedShape = null;\n    if (this.predictedShape) {\n      this.predictedShape.destroy();\n      this.predictedShape = null;\n      this.predictedShapeType = null;\n    }\n  }\n\n  /**\n   * create shape label dom\n   */\n  createShapeLabel = () => {\n    const shapeLabel = new Label({ className: 'instance-label' });\n    shapeLabel.addToContainer(this.labelsContainer.current!);\n    return shapeLabel;\n  };\n\n  /**\n   * create shape instance\n   * @param hexColor\n   * @param label\n   * @param shapeType\n   * @param shapeData\n   * @param shapeContainer\n   * @param imageBounds\n   */\n  createShape = (hexColor: string, label?: string, shapeType?: ShapeType, shapeData?: ShapeData, shapeContainer?: Container, imageBounds = this.imageBounds) => {\n    const useCurrent = shapeType === undefined;\n    const color = parseInt(hexColor.substr(1), 16);\n    const currentShapeType = shapeType || this.currentShapeType;\n    const shape = ShapeFactory.getShape(currentShapeType, {\n      app: this.props.app,\n      container: shapeContainer,\n      color,\n      selectedColor: 0xFF0000,\n      alpha: 0.2,\n      ...SettingsStore.boundaryCheck && { bounds: imageBounds },\n      ...(this.labelMode && { label }),\n      ...shapeData,\n      ...(useCurrent && this.currentTool === Tool.CENTERLINE_RECTANGLE && {\n        centerLineEnabled: true,\n      }),\n      ...(useCurrent && this.currentTool === Tool.FOUR_DOTS_RECTANGLE && {\n        rectType: RectType.FOUR_DOTS_RECT,\n      }),\n      rotatable: SettingsStore.rotatable,\n      ...SettingsStore.viewMode === ViewMode.DEFAULT && {\n        labelDom: this.createShapeLabel(),\n      },\n      userDataFormatter: this.formatPointLabel,\n    });\n    if (shapeData && currentShapeType === ShapeType.RECTANGLE) {\n      shape!.rotation = (shapeData as RectangleData).rotation || 0;\n    }\n    shape!.userDataMode = SettingsStore.activePointAttributesMode as unknown as UserDataMode;\n    return shape!;\n  };\n\n  /**\n   * add onSelect & onChange listeners\n   * @param shape\n   */\n  addShapeListeners(shape: Shape<ShapeData>) {\n    shape.on(EventAction.SELECTED, (s) => {\n      if (s !== this.predictedShape) {\n        this.selectShape(s, true);\n      }\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      const isPredicted = s === this.predictedShape && this.predictedShapeType;\n      const instanceId = isPredicted ? this.selectedInstanceId : this.shapeInstanceMap[s.uid];\n      this.updateShapeForInstance(instanceId, s, data);\n      this.updateLabels();\n    });\n    shape.on(EventAction.REMOVED, () => {\n      this.deleteShapeFromInstance(this.selectedInstanceId, [this.currentFrame]);\n    });\n    shape.on(EventAction.DRAGGING, this.updateLabels);\n    shape.on(EventAction.RESIZING, this.updateLabels);\n    shape.on(EventAction.POINTER_OVER, (s) => {\n      this.hoveredShapeId = s.uid;\n    });\n    shape.on(EventAction.POINTER_OUT, () => {\n      this.hoveredShapeId = '';\n    });\n  }\n\n  /**\n   * click to draw a shape\n   * @param point\n   * @param shapeContainer\n   * @param imageBounds\n   */\n  addShape = (point: Point, shapeContainer?: Container, imageBounds?: { left: number; top: number; right: number; bottom: number; }) => {\n    if (this.addMode && !this.drawingShape) {\n      this.drawingShape = this.createShape(\n        this.selectedCategory.display_color,\n        undefined,\n        undefined,\n        undefined,\n        shapeContainer,\n        imageBounds,\n      );\n\n      // add listeners\n      this.drawingShape.on(EventAction.FINISHED, (shape) => {\n        // remove listeners after creating\n        shape.off(EventAction.FINISHED);\n        shape.off(EventAction.REMOVED);\n        // drawing finished\n        const instance = this.getCurrentInstance();\n        const storeId = UndoStore.preserve({ instances: [instance] });\n        if (this.labelMode) {\n          shape.label = this.getInstanceLabel(instance);\n        }\n        this.addShapeToCurrentFrame(shape, instance, this.currentTool === Tool.OCR || this.currentTool === Tool.OCR_POLYGON);\n        this.drawingShape = null;\n        this.changeAddMode(false, true);\n        UndoStore.save(storeId, {\n          instances: [instance],\n        });\n\n        if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n          this.addShapeListeners(shape);\n        } else {\n          this.gridsRef.current?.update();\n        }\n      });\n      this.drawingShape.on(EventAction.REMOVED, () => {\n        this.drawingShape = null;\n      });\n      // start create\n      let options;\n      if (this.currentTool === Tool.GRID && this.gridToolRef.current) {\n        const colsCount = this.gridToolRef.current.getColsCount();\n        const rowsCount = this.gridToolRef.current.getRowsCount();\n        options = { cols: colsCount, rows: rowsCount };\n      }\n      this.drawingShape.create(point, options);\n\n      return this.drawingShape;\n    }\n    return null;\n  };\n\n  /**\n   * select shape by click canvas\n   * @param shape\n   */\n  selectShape = (shape: Shape<ShapeData>, isManual?: boolean) => {\n    if (!this.selectedShape || this.selectedShape.uid !== shape.uid) {\n      // selected shape changes\n      if (this.selectedShape) {\n        this.selectedShape.selected = false;\n      }\n      this.selectedShape = shape;\n      this.selectedShape.selected = true;\n      this.setSelectedInstance(this.shapeInstanceMap[this.selectedShape.uid], isManual);\n    }\n  };\n\n  /**\n   * unselect shape by click canvas\n   */\n  unselectShape = () => {\n    if (this.addMode) {\n      return;\n    }\n    if (this.selectedShape) {\n      this.selectedShape.selected = false;\n    }\n    this.selectedShape = null;\n    this.setSelectedInstance('');\n  };\n\n  /**\n   * remove shape instance\n   * @param shape\n   */\n  removeShape(shape: Shape<ShapeData>) {\n    if (shape === this.selectedShape) {\n      this.selectedShape = null;\n    }\n    const index = this.shapes.indexOf(shape);\n    this.shapes.splice(index, 1);\n    shape.destroy();\n  }\n\n  /**\n   * on shape changed\n   * @param instanceId\n   * @param shape\n   * @param shapeType\n   * @param shapeData\n   */\n  updateShapeForInstance = (instanceId: string, shape: Shape<ShapeData>, shapeData: ShapeData, shapeType?: ShapeType) => {\n    const instance = this.instances[instanceId];\n    const { frames } = instance;\n    const storeId = UndoStore.preserve({\n      instances: [instance],\n    });\n    if (!frames[this.currentFrame]) {\n      this.addShapeToCurrentFrame(shape, instance, undefined, true, shapeType || this.predictedShapeType!, shapeData);\n      shape.borderStyle = BorderStyle.SOLID;\n      this.predictedShape = null;\n      this.predictedShapeType = null;\n    } else {\n      frames[this.currentFrame].isKeyFrame = true;\n      frames[this.currentFrame].shape = shapeData;\n      this.selectedInstanceFrames[this.currentFrame] = true;\n      this.interpolate(instance);\n    }\n    UndoStore.save(storeId, {\n      instances: [instance],\n    });\n    if (frames[this.currentFrame].isOCR) {\n      this.setCurrentSnapshot(shapeData);\n    }\n  };\n\n  /**\n   * push to shapes array and add to mappings\n   * @param shape\n   * @param instanceId\n   * @param isKeyFrame\n   * @param shapeType\n   * @param shapeData\n   */\n  addShapeToCurrentFrame(shape: Shape<ShapeData>, instance: Instance, isOCR?: boolean, isKeyFrame = true, shapeType: ShapeType = this.currentShapeType, shapeData?: ShapeData) {\n    instance.frames[this.currentFrame] = {\n      frameIndex: this.currentFrame,\n      isKeyFrame,\n      shapeType,\n      shape: shapeData || shape.getData() as ShapeData,\n      isOCR,\n    };\n    const [lastKeyFrame] = getLastKeyFrames(1, this.currentFrame, instance.frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, this.currentFrame, instance.frames);\n    const keyFrame = lastKeyFrame !== undefined ? lastKeyFrame : nextKeyFrame;\n    if (keyFrame !== undefined) {\n      if (SettingsStore.labelConfig) {\n        instance.frames[this.currentFrame].attributes = cloneDeep(instance.frames[keyFrame].attributes);\n      }\n      if (isOCR === undefined) {\n        instance.frames[this.currentFrame].isOCR = instance.frames[keyFrame].isOCR;\n        instance.frames[this.currentFrame].OCRText = instance.frames[keyFrame].OCRText;\n      }\n    }\n    this.frameInstances[this.currentFrame].push(instance.id);\n    this.currentInstancesMap[instance.id] = true;\n    this.selectedInstanceFrames[this.currentFrame] = true;\n    if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n      // default view, should set shape status\n      this.shapes.push(shape);\n      this.shapeInstanceMap[shape.uid] = instance.id;\n      this.selectShape(shape);\n    } else {\n      // grid view, only set instance status\n      this.setSelectedInstance(instance.id);\n    }\n    this.interpolate(instance, true);\n    this.updateLabels();\n    this.attributesRef.current?.showModal();\n  }\n\n  /**\n   * add shape to instance\n   * @param instanceId\n   * @param shapeContainer\n   * @param imageBounds\n   */\n  addShapeToInstance = (instanceId: string, shapeContainer?: Container, imageBounds = this.imageBounds) => {\n    const instance = this.instances[instanceId];\n    const stackId = UndoStore.preserve({ instances: [instance] });\n    if (this.selectedInstanceId === instanceId && this.predictedShape && this.predictedShapeType) {\n      this.addShapeToCurrentFrame(this.predictedShape, instance, undefined, true, this.predictedShapeType);\n      this.predictedShape.borderStyle = BorderStyle.SOLID;\n      this.predictedShape = null;\n      this.predictedShapeType = null;\n      UndoStore.save(stackId, { instances: [instance] });\n    } else {\n      let shapeInfo = predictShapeData(this.currentFrame, instance.frames, imageBounds);\n      if (!shapeInfo) {\n        const lastFrame = Object.keys(instance.frames).pop();\n        if (lastFrame) {\n          const { shapeType, shape } = instance.frames[parseInt(lastFrame, 10)];\n          shapeInfo = { shapeType, shape };\n        }\n      }\n      if (shapeInfo) {\n        const shape = this.createShape(\n          this.selectedCategory.display_color,\n          this.getInstanceLabel(instance),\n          shapeInfo.shapeType,\n          shapeInfo.shape,\n          shapeContainer,\n          imageBounds,\n        );\n        this.addShapeToCurrentFrame(shape, instance, undefined, true, shapeInfo.shapeType, shapeInfo.shape);\n        UndoStore.save(stackId, { instances: [instance] });\n        if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n          this.addShapeListeners(shape);\n        }\n        return shape;\n      }\n    }\n    return null;\n  };\n\n  /**\n   * delete selected shape points or shape instance from current frame\n   */\n  delete = () => {\n    if (!this.readonly && this.selectedInstanceId) {\n      if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n        const shape = this.getShapeByInstance(this.selectedInstanceId);\n        if (shape) {\n          const pointsDeleted = shape.deleteSelectedPoints();\n          if (!pointsDeleted) {\n            this.deleteShapeFromInstance(this.selectedInstanceId, [this.currentFrame]);\n            this.updateLabels();\n          }\n        }\n      } else {\n        this.gridsRef.current?.delete(this.currentFrame, this.selectedInstanceId);\n      }\n    }\n  };\n\n  /**\n   * delete shape in frames\n   * @param instanceId instance id\n   * @param frames affected frame indexes\n   */\n  deleteShapeFromInstance = (instanceId: string, frames: number[]) => {\n    const instance = this.instances[instanceId];\n    const storeId = UndoStore.preserve({\n      instances: [instance],\n      relationships: RelationshipsStore.getRelationshipsForSave(),\n      reviews: ReviewsStore.getReviewsForSave(),\n    });\n    for (let i = 0; i < frames.length; i += 1) {\n      const deleteFrame = frames[i];\n      // remove from instance\n      delete instance.frames[deleteFrame];\n      // remove from frames\n      const instanceIndex = this.frameInstances[deleteFrame].indexOf(instanceId);\n      if (instanceIndex >= 0) {\n        this.frameInstances[deleteFrame].splice(instanceIndex, 1);\n      }\n      // is current frame, need remove shape and update state\n      if (deleteFrame === this.currentFrame) {\n        const shape = this.getShapeByInstance(instanceId);\n        if (shape) {\n          this.removeShape(shape);\n          delete this.shapeInstanceMap[shape.uid];\n        }\n        delete this.currentInstancesMap[instance.id];\n      }\n      // set prev & next frame to key frame\n      if (instance.frames[deleteFrame - 1]) {\n        instance.frames[deleteFrame - 1].isKeyFrame = true;\n      }\n      if (instance.frames[deleteFrame + 1]) {\n        instance.frames[deleteFrame + 1].isKeyFrame = true;\n      }\n      // delete related relationships if needed\n      RelationshipsStore.deleteRelationshipByInstance(instanceId, deleteFrame);\n      // delete related reviews if needed\n      ReviewsStore.deleteReviewByInstance(instanceId, deleteFrame);\n    }\n    // update instance frames\n    this.selectedInstanceFrames = mapValues(instance.frames, 'isKeyFrame');\n    // no frame exists\n    if (Object.keys(instance.frames).length <= 0) {\n      // remove instance\n      delete this.instances[instanceId];\n      delete this.categoryInstancesMap[instance.category][instance.id];\n      if (this.selectedInstanceId === instanceId) {\n        this.setSelectedInstance(''); // unselect\n      }\n    }\n    this.predict(instance);\n    UndoStore.save(storeId, {\n      instances: [instance],\n      relationships: RelationshipsStore.getRelationshipsForSave(),\n      reviews: ReviewsStore.getReviewsForSave(),\n    });\n  };\n\n  /**\n   * delete shape from instance by type\n   * @param instanceId\n   * @param type\n   */\n  deleteShapeFromInstanceByType = (instanceId: string, type: 'current' | 'key' | 'following' | 'all' = 'current') => {\n    switch (type) {\n      case 'current':\n        this.deleteShapeFromInstance(instanceId, [this.currentFrame]);\n        break;\n      case 'key': {\n        const nextKeyFrames = getNextKeyFrames(1, this.currentFrame, this.instances[instanceId].frames);\n        const nextKeyFrame = nextKeyFrames.length === 1 ? nextKeyFrames[0] : this.frames.length - 1;\n        this.deleteShapeFromInstance(\n          instanceId,\n          Array.from({ length: nextKeyFrame - this.currentFrame }).map((_, index) => this.currentFrame + index),\n        );\n        break;\n      }\n      case 'following':\n        this.deleteShapeFromInstance(\n          instanceId,\n          Array.from({ length: this.frames.length - this.currentFrame }).map((_, index) => this.currentFrame + index),\n        );\n        break;\n      case 'all':\n        this.deleteShapeFromInstance(\n          instanceId,\n          Array.from({ length: this.frames.length }).map((_, index) => index),\n        );\n        break;\n      default:\n    }\n  };\n\n  /**\n   * get shape by instance id\n   * @param instanceId\n   * @returns\n   */\n  getShapeByInstance(instanceId: string) {\n    const shapeId = Object.keys(this.shapeInstanceMap).find((id) => this.shapeInstanceMap[id] === instanceId);\n    return this.shapes.find((shape) => shape.uid === shapeId);\n  }\n\n  /**\n   * get current editing instance\n   */\n  getCurrentInstance() {\n    if (this.selectedInstanceId) {\n      const instance = this.instances[this.selectedInstanceId];\n      const { frames } = instance;\n      if (!frames[this.currentFrame]) {\n        // instance exists, but not in current frame\n        return instance;\n      }\n    }\n    // return a new instance\n    return this.createInstance();\n  }\n\n  /**\n   * get instance by category & number\n   * @param categoryName\n   * @param number\n   * @returns {Instance | undefined}\n   */\n  getInstanceByNumber(categoryName: string, number: number) {\n    const categoryInstances = this.categoryInstancesMap[categoryName];\n    const instanceId = Object.keys(categoryInstances).find((id) => categoryInstances[id] === number);\n    return instanceId ? this.instances[instanceId] : undefined;\n  }\n\n  /**\n   * create instance\n   */\n  createInstance(category: Ontology = this.selectedCategory) {\n    const { class_name } = category;\n    const instance: Instance = {\n      id: uuidv4(),\n      category: class_name,\n      number: this.getNextInstanceNumber(category),\n      frames: {},\n    };\n    // add to instances\n    this.instances[instance.id] = instance;\n    // add to category mapping\n    if (!this.categoryInstancesMap[class_name]) {\n      this.categoryInstancesMap[class_name] = {};\n    }\n    this.categoryInstancesMap[class_name][instance.id] = instance.number;\n    return instance;\n  }\n\n  /**\n   * set selected instance\n   * @param instanceId\n   * @param isManual\n   */\n  setSelectedInstance(instanceId: string, isManual = false) {\n    if (this.selectedInstanceId !== instanceId) {\n      this.selectedInstanceId = instanceId;\n      const selectedInstance = this.instances[instanceId];\n      this.selectedInstanceFrames = selectedInstance ? mapValues(selectedInstance.frames, 'isKeyFrame') : {};\n      // if category changes\n      if (selectedInstance && selectedInstance.category !== this.selectedCategoryName) {\n        this.selectedCategoryName = selectedInstance.category;\n      }\n      // predict changes\n      this.predict(selectedInstance);\n      // try to add relationship if needed\n      if (isManual && selectedInstance && selectedInstance.frames[this.currentFrame] !== undefined) {\n        // shape exists\n        try {\n          RelationshipsStore.addRelationship(instanceId, this.currentFrame);\n        } catch (e) {\n          message.error(e.message);\n        }\n      } else {\n        RelationshipsStore.resetTempRelationship();\n      }\n      this.updateHiddenShapes();\n    }\n    this.setCurrentAttributes();\n    if (this.instances[instanceId]?.frames[this.currentFrame]?.isOCR) {\n      const shape = this.getShapeByInstance(instanceId);\n      if (shape) {\n        this.setCurrentSnapshot(shape.getData());\n      }\n    }\n  }\n\n  /**\n   * select instance\n   * @param instanceId\n   * @param isManual\n   */\n  selectInstance = (instanceId: string, isManual?: boolean) => {\n    this.setSelectedInstance(instanceId, isManual);\n    // select shape\n    const shape = this.getShapeByInstance(instanceId);\n    if (this.selectedShape) {\n      this.selectedShape.selected = false;\n    }\n    if (shape) {\n      this.selectedShape = shape;\n      this.selectedShape.selected = true;\n    } else {\n      this.selectedShape = null;\n    }\n  };\n\n  /**\n   * get instance label\n   * @param instance\n   */\n  getInstanceLabel = (instance: Instance) => {\n    const category = this.getCategory(instance.category);\n    return `${category?.display_name || category?.class_name || instance.category} ${instance.number}`;\n  };\n\n  /**\n   * select category\n   * @param categoryName\n   */\n  selectCategory = (categoryName: string) => {\n    if (this.selectedCategoryName !== categoryName) {\n      this.selectedCategoryName = categoryName;\n      if (this.selectedInstanceId) {\n        this.selectInstance('');\n      }\n    }\n  };\n\n  /**\n   * get category object\n   * @param categoryName\n   */\n  getCategory = (categoryName: string) => this.props.ontology.find((o) => o.class_name === categoryName);\n\n  /**\n   * get next instance number\n   * @param category\n   */\n  getNextInstanceNumber(category: Ontology) {\n    const categoryInstanceNumbers = Object.values(this.categoryInstancesMap[category.class_name] || {});\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * predict shape\n   * @param instance\n   */\n  predict(instance?: Instance) {\n    if (this.predictedShape) {\n      this.predictedShape.destroy();\n      this.predictedShape = null;\n      this.predictedShapeType = null;\n    }\n    if (!this.readonly && instance && SettingsStore.viewMode === ViewMode.DEFAULT) {\n      const { frames } = instance;\n      const shapeInfo = predictShapeData(this.currentFrame, frames, this.imageBounds);\n      if (shapeInfo) {\n        // create predict shape\n        this.predictedShape = this.createShape(this.selectedCategory.display_color, this.getInstanceLabel(instance), shapeInfo.shapeType, shapeInfo.shape);\n        this.predictedShapeType = shapeInfo.shapeType;\n        this.predictedShape.borderStyle = BorderStyle.DASHED;\n        this.predictedShape.selected = true; // predicted shape is always selected\n        // add listeners\n        this.addShapeListeners(this.predictedShape);\n      }\n    }\n  }\n\n  /**\n   * interpolate shapes\n   * @param instance\n   * @param shouldInsert\n   */\n  interpolate(instance: Instance, shouldInsert = false) {\n    if (!SettingsStore.autoInterpolation) {\n      return;\n    }\n    const { frames } = instance;\n    const { shapeType } = frames[this.currentFrame];\n    const [lastKeyFrame] = getLastKeyFrames(1, this.currentFrame, frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, this.currentFrame, frames);\n    const instanceFrames: {[frameIndex: number]: boolean} = {};\n    const updateFrameData = (frameIndex: number, shape: ShapeData, insert: boolean, frameData?: FrameData) => {\n      if (frames[frameIndex]) {\n        frames[frameIndex].isKeyFrame = false;\n        frames[frameIndex].shape = shape;\n        frames[frameIndex].shapeType = shapeType;\n        instanceFrames[frameIndex] = false;\n      } else if (insert) {\n        frames[frameIndex] = {\n          frameIndex,\n          isKeyFrame: false,\n          shapeType,\n          shape,\n          ...(frameData && frameData.attributes && { attributes: { ...frameData.attributes } }),\n          ...(frameData && frameData.isOCR && { isOCR: true, OCRText: frameData.OCRText }),\n        };\n        this.frameInstances[frameIndex].push(instance.id);\n        instanceFrames[frameIndex] = false;\n      }\n    };\n    if (lastKeyFrame !== undefined && frames[lastKeyFrame].shapeType === shapeType) {\n      for (let i = lastKeyFrame + 1; i < this.currentFrame; i += 1) {\n        const { shape } = getShapeFromFrames(frames, lastKeyFrame, this.currentFrame, lastKeyFrame, i);\n        updateFrameData(i, shape, shouldInsert, frames[lastKeyFrame]);\n      }\n    }\n    if (nextKeyFrame !== undefined && frames[nextKeyFrame].shapeType === shapeType) {\n      for (let i = this.currentFrame + 1; i < nextKeyFrame; i += 1) {\n        const { shape } = getShapeFromFrames(frames, this.currentFrame, nextKeyFrame, this.currentFrame, i);\n        updateFrameData(i, shape, false);\n      }\n    }\n    if (Object.keys(instanceFrames).length > 0) {\n      this.selectedInstanceFrames = { ...this.selectedInstanceFrames, ...instanceFrames };\n    }\n  }\n\n  /**\n   * set instance moving modal visible status\n   * @param moving\n   */\n  setInstanceMoving(moving: boolean) {\n    this.instanceMoving = moving;\n  }\n\n  /**\n   * move instance to target category & number in frames\n   * @param instanceId instance to be moved\n   * @param category target category\n   * @param number target number\n   * @param frames affected frames\n   */\n  move = (instanceId: string, category: string, number: number, frames: number[]) => {\n    const currentInstance = this.instances[instanceId];\n    const targetInstance = number < 0 ? this.createInstance(this.getCategory(category)) : this.getInstanceByNumber(category, number);\n    if (currentInstance && targetInstance) {\n      const storeId = UndoStore.preserve({\n        instances: [currentInstance, targetInstance],\n        relationships: RelationshipsStore.getRelationshipsForSave(),\n      });\n      const currentInstancesMap: {[instanceId: string]: boolean} = { ...this.currentInstancesMap };\n      frames.forEach((frameIndex, i) => {\n        targetInstance.frames[frameIndex] = { ...currentInstance.frames[frameIndex] };\n        delete currentInstance.frames[frameIndex];\n        RelationshipsStore.switchRelationshipInstance(instanceId, targetInstance.id, frameIndex);\n        const isRangeStart = i === 0 || (i > 0 && frames[i] - frames[i - 1] > 1);\n        const isRangeEnd = i === frames.length - 1 || (i < frames.length - 1 && frames[i + 1] - frames[i] > 1);\n        if (isRangeStart || isRangeEnd) {\n          if (isRangeStart && currentInstance.frames[frameIndex - 1]) {\n            currentInstance.frames[frameIndex - 1].isKeyFrame = true;\n          }\n          if (isRangeEnd && currentInstance.frames[frameIndex + 1]) {\n            currentInstance.frames[frameIndex + 1].isKeyFrame = true;\n          }\n          targetInstance.frames[frameIndex].isKeyFrame = true;\n          if (isRangeStart && targetInstance.frames[frameIndex - 1]) {\n            targetInstance.frames[frameIndex - 1].isKeyFrame = true;\n          }\n          if (isRangeEnd && targetInstance.frames[frameIndex + 1]) {\n            targetInstance.frames[frameIndex + 1].isKeyFrame = true;\n          }\n        }\n        // update frame instances mapping\n        const index = this.frameInstances[frameIndex].indexOf(instanceId);\n        if (index >= 0) {\n          this.frameInstances[frameIndex].splice(index, 1);\n        }\n        if (this.frameInstances[frameIndex].indexOf(targetInstance.id) < 0) {\n          this.frameInstances[frameIndex].push(targetInstance.id);\n        }\n        if (frameIndex === this.currentFrame) {\n          // update shapes mapping\n          const targetShape = this.getShapeByInstance(targetInstance.id);\n          if (targetShape) {\n            this.removeShape(targetShape);\n            delete this.shapeInstanceMap[targetShape.uid];\n          }\n          const shape = this.getShapeByInstance(instanceId);\n          if (shape) {\n            if (this.labelMode) {\n              shape.label = this.getInstanceLabel(targetInstance);\n            }\n            const targetCategory = this.getCategory(category);\n            if (targetCategory) {\n              shape.color = parseInt(targetCategory.display_color.substr(1), 16);\n            }\n            this.shapeInstanceMap[shape.uid] = targetInstance.id;\n          }\n          // update current instances mapping\n          currentInstancesMap[targetInstance.id] = true;\n          delete currentInstancesMap[instanceId];\n        }\n      });\n      this.currentInstancesMap = currentInstancesMap;\n      this.setSelectedInstance(targetInstance.id);\n      if (Object.keys(currentInstance.frames).length <= 0) {\n        // remove current instance if no frame exists\n        delete this.instances[instanceId];\n        delete this.categoryInstancesMap[currentInstance.category][instanceId];\n      }\n      UndoStore.save(storeId, {\n        instances: [currentInstance, targetInstance],\n        relationships: RelationshipsStore.getRelationshipsForSave(),\n      });\n    }\n    this.setInstanceMoving(false);\n    this.updateLabels();\n  };\n\n  /**\n   * set values to instance to specific frame\n   * @param values\n   * @param applyAll\n   * @param instanceId\n   * @param frame\n   */\n  setAttributes = (values: any, applyAll: boolean, instanceId = this.selectedInstanceId, frame = this.currentFrame) => {\n    const instance = this.instances[instanceId];\n    if (instance) {\n      const { frames } = instance;\n      const allFrames = Object.keys(frames).map((f) => parseInt(f, 10));\n      const index = allFrames.indexOf(frame);\n      if (index >= 0) {\n        const storeId = UndoStore.preserve({\n          instances: [instance],\n        });\n        const { isOCR, OCRText, ...attributes } = values;\n        allFrames.slice(index, applyAll ? allFrames.length : index + 1).forEach((f) => {\n          if (SettingsStore.labelConfig || frames[f].isOCR) {\n            frames[f].isOCR = isOCR;\n            frames[f].OCRText = OCRText;\n            if (SettingsStore.labelConfig) {\n              frames[f].attributes = { ...attributes };\n            }\n            if (f === this.currentFrame) {\n              this.currentAttributes = { ...values };\n            }\n          }\n        });\n        UndoStore.save(storeId, {\n          instances: [instance],\n        });\n        this.updateLabels();\n      }\n    }\n  };\n\n  /**\n   * set current attributes (with OCR)\n   */\n  setCurrentAttributes = () => {\n    this.currentAttributes = null;\n    const instance = this.instances[this.selectedInstanceId];\n    if (instance) {\n      const { frames } = instance;\n      const currentFrameData = frames[this.currentFrame];\n      if (currentFrameData && (SettingsStore.labelConfig || currentFrameData.isOCR)) {\n        this.currentAttributes = {\n          ...(SettingsStore.labelConfig && currentFrameData.attributes),\n          // append ocr attributes\n          isOCR: currentFrameData.isOCR,\n          OCRText: currentFrameData.OCRText,\n        };\n      }\n    }\n  };\n\n  /**\n   * set current snapshot (for OCR)\n   */\n  setCurrentSnapshot = async (shape: ShapeData) => {\n    try {\n      const url = await getSnapshot(this.frames[this.currentFrame], shape);\n      this.currentSnapshot = url;\n    } catch (e) {\n      this.currentSnapshot = '';\n    }\n  };\n\n  /**\n   * update data (used for undo / redo)\n   * @param curr\n   * @param prev\n   */\n  updateData = (curr: StoreData, prev: StoreData) => {\n    const currentSelectedInstance = this.selectedInstanceId;\n    const currentInstancesMap = { ...this.currentInstancesMap };\n    const categoryInstancesMap = { ...this.categoryInstancesMap };\n\n    const isGridView = SettingsStore.viewMode === ViewMode.GRID;\n    prev.instances?.forEach((instance) => {\n      if (instance) {\n        // update instances\n        delete this.instances[instance.id];\n        Object.values(instance.frames).forEach(({ frameIndex }) => {\n          const index = this.frameInstances[frameIndex].findIndex((i) => i === instance.id);\n          if (index >= 0) {\n            this.frameInstances[frameIndex].splice(index, 1);\n          }\n        });\n        delete currentInstancesMap[instance.id];\n        delete categoryInstancesMap[instance.category][instance.id];\n        if (!isGridView) {\n          // remove shape\n          const shape = this.getShapeByInstance(instance.id);\n          if (shape) {\n            this.removeShape(shape);\n            delete this.shapeInstanceMap[shape.uid];\n          }\n        }\n        // unselect\n        if (currentSelectedInstance === instance.id) {\n          this.setSelectedInstance('');\n        }\n      }\n    });\n    curr.instances?.forEach((instance) => {\n      if (instance && instance.frames && Object.keys(instance.frames).length > 0) {\n        this.instances[instance.id] = instance;\n        Object.values(instance.frames).forEach(({ frameIndex }) => {\n          if (this.frameInstances[frameIndex].findIndex((i) => i === instance.id) < 0) {\n            this.frameInstances[frameIndex].push(instance.id);\n          }\n        });\n        currentInstancesMap[instance.id] = instance.frames[this.currentFrame] !== undefined;\n        if (!categoryInstancesMap[instance.category]) {\n          categoryInstancesMap[instance.category] = {};\n        }\n        categoryInstancesMap[instance.category][instance.id] = instance.number;\n        const currFrameData = instance.frames[this.currentFrame];\n        if (currFrameData !== undefined) {\n          // readd shape\n          const category = this.getCategory(instance.category);\n          if (category && !isGridView) {\n            const newShape = this.createShape(category.display_color, this.getInstanceLabel(instance), currFrameData.shapeType, currFrameData.shape);\n            this.addShapeListeners(newShape);\n            this.shapes.push(newShape);\n            this.shapeInstanceMap[newShape.uid] = instance.id;\n            if (currentSelectedInstance === instance.id) {\n              this.selectShape(newShape);\n            }\n          }\n        }\n        if (currentSelectedInstance === instance.id) {\n          this.setSelectedInstance(instance.id);\n        }\n      }\n    });\n    this.currentInstancesMap = currentInstancesMap;\n    this.categoryInstancesMap = categoryInstancesMap;\n\n    if (curr.relationships) {\n      RelationshipsStore.setInitialData(curr.relationships, this.instances);\n    }\n    if (prev.frames || curr.frames) {\n      const currFrameAttributes = toJS(FramesStore.attributes);\n      prev.frames?.forEach((frame) => {\n        // remove\n        delete currFrameAttributes[frame.frameIndex];\n      });\n      curr.frames?.forEach((frame) => {\n        // readd\n        currFrameAttributes[frame.frameIndex] = frame;\n      });\n      FramesStore.attributes = currFrameAttributes;\n    }\n    if (curr.reviews) {\n      ReviewsStore.setInitialData(curr.reviews);\n    }\n\n    if (isGridView) {\n      this.gridsRef.current?.update();\n    }\n\n    this.updateLabels();\n  };\n\n  /**\n   * set view mode\n   * @param viewMode\n   */\n  setViewMode = (viewMode: ViewMode) => {\n    if (SettingsStore.viewMode !== viewMode) {\n      SettingsStore.viewMode = viewMode;\n      this.clearShapes();\n    }\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or shape\n   */\n  setActiveAttributesMode = (activeMode: AttributesMode, type = 'shape') => {\n    if (type === 'point') {\n      SettingsStore.activePointAttributesMode = activeMode;\n      this.shapes.forEach((shape) => {\n        shape.userDataMode = activeMode as unknown as UserDataMode;\n      });\n    } else {\n      SettingsStore.activeAttributesMode = activeMode;\n    }\n    this.updateLabels();\n  };\n\n  /**\n   * handle hotkey events\n   */\n  handleHotkey = ({ affected, type, attributes }: HotkeyItem) => {\n    if (this.readonly) {\n      return;\n    }\n    if (affected === 'point') {\n      // set polygon point\n      const setPointsUserDataForShape = (shape: Shape<ShapeData>) => {\n        if (shape instanceof Polygon || shape instanceof Line) {\n          const selectedPoints = shape.getSelectedPoints();\n          const pointsData: {index: number; userData: any}[] = [];\n          selectedPoints.forEach(({ index, point }) => {\n            const userData = type === 'overwrite' ? { ...attributes } : { ...point.userData, ...attributes };\n            pointsData.push({ index, userData });\n          });\n          shape.setPointsUserData(pointsData);\n        }\n      };\n      if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n        if (this.selectedShape) {\n          setPointsUserDataForShape(this.selectedShape);\n        }\n      } else {\n        const selectedInstance = this.instances[this.selectedInstanceId];\n        if (selectedInstance && selectedInstance.frames[this.currentFrame]) {\n          const shapes = this.gridsRef.current?.getShapesForGrid(this.currentFrame);\n          shapes?.forEach((shape) => {\n            setPointsUserDataForShape(shape);\n          });\n        }\n      }\n    }\n  };\n\n  /**\n   * convert shape to polygon type\n   */\n  convertShapeToPolygon = () => {\n    if (!this.readonly && this.selectedShape) {\n      const instanceId = this.shapeInstanceMap[this.selectedShape.uid];\n      const instance = this.instances[instanceId];\n      if (this.selectedShape instanceof Rectangle) {\n        const storeId = UndoStore.preserve({\n          instances: [instance],\n        });\n        const points = this.selectedShape.getPoints();\n        const shape = this.createShape(this.selectedCategory.display_color, this.getInstanceLabel(instance), ShapeType.POLYGON, { points });\n        instance.frames[this.currentFrame] = {\n          ...instance.frames[this.currentFrame],\n          shapeType: ShapeType.POLYGON,\n          shape: shape.getData(),\n          isKeyFrame: true,\n        };\n        if (instance.frames[this.currentFrame - 1]) {\n          instance.frames[this.currentFrame - 1].isKeyFrame = true;\n        }\n        if (instance.frames[this.currentFrame + 1]) {\n          instance.frames[this.currentFrame + 1].isKeyFrame = true;\n        }\n        UndoStore.save(storeId, {\n          instances: [instance],\n        });\n\n        this.addShapeListeners(shape);\n        this.shapes.splice(this.shapes.indexOf(this.selectedShape), 1, shape);\n        delete this.shapeInstanceMap[this.selectedShape.uid];\n        this.shapeInstanceMap[shape.uid] = instanceId;\n        this.selectedShape.destroy();\n        this.selectedShape = null;\n        this.selectShape(shape);\n        this.selectedInstanceFrames = mapValues(instance.frames, 'isKeyFrame');\n        message.success('Converted to polygon.');\n      }\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  triggerValidation = async () => {\n    if (this.validatorRef.current) {\n      const { hasCustomError, blockSubmitErrors } = await this.validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n\n  /**\n   * update hidden shapes\n   */\n  updateHiddenShapes = () => {\n    this.shapes.forEach((shape) => {\n      if (!SettingsStore.hideOthers || !this.selectedInstanceId || this.shapeInstanceMap[shape.uid] === this.selectedInstanceId) {\n        shape.visible = true;\n      } else {\n        shape.visible = false;\n      }\n    });\n  };\n\n  /**\n   * clear annotation\n   */\n  clear = () => {\n    const storeId = UndoStore.preserve({\n      instances: Object.values(this.instances),\n      relationships: RelationshipsStore.getRelationshipsForSave(),\n      frames: FramesStore.getFramesForSave(),\n      reviews: ReviewsStore.getReviewsForSave(),\n    });\n\n    // unselect\n    this.selectedInstanceId = '';\n    this.selectedInstanceFrames = {};\n    this.currentAttributes = null;\n    this.currentSnapshot = '';\n    // remove all current shapes\n    this.clearShapes();\n    // reset instance\n    this.instances = {};\n    this.frameInstances = this.frames.map(() => []);\n    this.categoryInstancesMap = {};\n    this.updateLabels();\n\n    // remove relationships\n    RelationshipsStore.setInitialData([], {});\n    // remove frame validation\n    FramesStore.setInitialData([]);\n\n    UndoStore.save(storeId);\n    message.success('Clear completed.');\n  };\n\n  /**\n   * add instances in current selected category to current frame\n   */\n  addCategoryInstancesToCurrentFrame = () => {\n    if (SettingsStore.viewMode !== ViewMode.DEFAULT) {\n      return;\n    }\n    const instanceIds = Object.keys(this.categoryInstancesMap[this.selectedCategoryName] || {});\n    const prevInstances = [];\n    const currInstances = [];\n    for (let i = 0; i < instanceIds.length; i += 1) {\n      const instanceId = instanceIds[i];\n      const instance = this.instances[instanceId];\n      if (!instance.frames[this.currentFrame]) {\n        let shapeInfo = predictShapeData(this.currentFrame, instance.frames, this.imageBounds);\n        if (!shapeInfo) {\n          const lastFrame = Object.keys(instance.frames).pop();\n          if (lastFrame) {\n            const { shapeType, shape } = instance.frames[parseInt(lastFrame, 10)];\n            shapeInfo = { shapeType, shape };\n          }\n        }\n        if (shapeInfo) {\n          prevInstances.push(cloneDeep(instance));\n          const shape = this.createShape(\n            this.selectedCategory.display_color,\n            this.getInstanceLabel(instance),\n            shapeInfo.shapeType,\n            shapeInfo.shape,\n          );\n          this.addShapeToCurrentFrame(shape, instance, undefined, true, shapeInfo.shapeType, shapeInfo.shape);\n          this.addShapeListeners(shape);\n          currInstances.push(cloneDeep(instance));\n        }\n      }\n    }\n    if (prevInstances.length > 0 || currInstances.length > 0) {\n      const storeId = UndoStore.preserve({ instances: prevInstances });\n      UndoStore.save(storeId, { instances: currInstances });\n    }\n  };\n\n  /**\n   * update label viewer\n   */\n  updateLabels = () => {\n    this.labelRef.current?.forceUpdate();\n  };\n\n  /**\n   * format point label\n   * @param data\n   * @returns\n   */\n  formatPointLabel = (data: any) => {\n    const labels: string[][] = [];\n    const { pointLabelItems } = SettingsStore;\n    Object.keys(data).forEach((key) => {\n      const label = [];\n      if (pointLabelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n        label.push(`${key}`);\n      }\n      if (pointLabelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n        label.push(`${data[key]}`);\n      }\n      if (label.length > 0) {\n        labels.push(label);\n      }\n    });\n    return labels.map((l) => l.join(': ')).join('; ');\n  };\n\n  renderValidator(hasValidation: boolean) {\n    return hasValidation && (\n      <Validator\n        ref={this.validatorRef}\n        categoryInstancesMap={toJS(this.categoryInstancesMap)}\n        instances={this.instances}\n        jobProxy={this.props.jobProxy}\n        getCategory={this.getCategory}\n        setFrame={this.setFrame}\n        selectInstance={this.selectInstance}\n        saveResult={() => this.saveResult('temp')}\n      />\n    );\n  }\n\n  render() {\n    const loading = this.loading && SettingsStore.viewMode !== ViewMode.GRID;\n    const readonly = this.readonly || loading;\n    const hasRightPanel = (SettingsStore.labelConfig || this.props.tools.includes(Tool.OCR) || this.props.tools.includes(Tool.OCR_POLYGON)) && SettingsStore.viewMode !== ViewMode.GRID;\n    const hasFrameControl = this.frames.length > 1;\n    const hasValidation = Object.keys(SettingsStore.validationConfig).length > 0;\n    return (\n      <LayoutWrapper className=\"video-tracking-app\" loading={loading}>\n        <AutoSaver\n          ref={this.saverRef}\n          leaveCheck\n          data={{ storePointer: UndoStore.pointer, storeId: UndoStore.lastStoreId }}\n          save={() => this.save(true)}\n        />\n        <Toolbar\n          readonly={readonly}\n          tools={this.props.tools}\n          currentTool={this.currentTool}\n          gridViewEnabled={hasFrameControl}\n          addMode={this.addMode}\n          labelMode={this.labelMode}\n          viewScale={SettingsStore.viewScale}\n          selectedInstanceId={this.selectedInstanceId}\n          selectedInstanceInCurrentFrame={this.currentInstancesMap[this.selectedInstanceId]}\n          updateData={this.updateData}\n          onCurrentToolChanges={this.changeCurrentTool}\n          onAddModeChanges={this.changeAddMode}\n          onLabelModeChanges={this.changeLabelMode}\n          onViewModeChanges={this.setViewMode}\n          onAttributesModeChanges={this.setActiveAttributesMode}\n          onViewReset={() => this.canvasRef.current?.fitImageToView()}\n          setViewScale={(scale) => this.canvasRef.current?.zoomTo(scale)}\n          updateHiddenShapes={this.updateHiddenShapes}\n          onSave={() => this.save()}\n          onClear={this.clear}\n        />\n        <div\n          className=\"container\"\n          style={{\n            height: `calc(100% - ${hasFrameControl ? `${this.frameControlHeight + 36}px` : '36px'})`,\n            transition: 'height 0.15s',\n          }}\n        >\n          <Sidebar\n            readonly={readonly}\n            ontology={this.props.ontology}\n            currentFrame={this.currentFrame}\n            currentInstancesMap={toJS(this.currentInstancesMap)}\n            categoryInstancesMap={toJS(this.categoryInstancesMap)}\n            instances={this.instances}\n            selectedInstanceId={this.selectedInstanceId}\n            selectedCategoryName={this.selectedCategoryName}\n            hasValidation={hasValidation}\n            selectInstance={this.selectInstance}\n            selectCategory={this.selectCategory}\n            addShapeToInstance={(instanceId) => {\n              if (SettingsStore.viewMode === ViewMode.DEFAULT) {\n                this.addShapeToInstance(instanceId);\n              } else {\n                this.gridsRef.current?.addShapeToGrid(this.currentFrame, instanceId);\n              }\n            }}\n            deleteShapeFromInstance={this.deleteShapeFromInstanceByType}\n            openInstanceMove={() => this.setInstanceMoving(true)}\n            renderValidator={() => this.renderValidator(hasValidation)}\n            getInstanceLabel={this.getInstanceLabel}\n          />\n          <div\n            style={{\n              width: `calc(100% - ${hasRightPanel ? '526px' : '286px'})`,\n              position: 'relative',\n              cursor: this.cursor,\n            }}\n          >\n            {SettingsStore.viewMode === ViewMode.DEFAULT && (\n              <>\n                <Canvas\n                  ref={this.canvasRef}\n                  app={this.props.app}\n                  crossline={SettingsStore.crossLineVisible}\n                  measurementBox={toJS(SettingsStore.activeMeasurementBox)}\n                  imageUrl={this.frames[this.currentFrame]}\n                  interactive={!this.loading}\n                  onImageLoaded={this.setupFrame}\n                  onScaleChange={(scale) => {\n                    SettingsStore.setViewScale(scale);\n                    this.updateLabels();\n                  }}\n                  onPositionChange={() => {\n                    this.updateLabels();\n                    for (let i = 0; i < this.shapes.length; i += 1) {\n                      this.shapes[i].drawShapeLabel();\n                    }\n                  }}\n                  onClick={this.addShape}\n                  onBlankClick={this.unselectShape}\n                />\n                <div ref={this.labelsContainer} className=\"instance-labels-container\" />\n                <LabelViewer\n                  ref={this.labelRef}\n                  shapes={this.shapes}\n                  shapeInstanceMap={this.shapeInstanceMap}\n                  instances={this.instances}\n                  selectedInstanceId={this.selectedInstanceId}\n                  currentFrame={this.currentFrame}\n                  hoveredShapeId={this.hoveredShapeId}\n                  hideOthers={SettingsStore.hideOthers}\n                />\n                {!this.readonly && (\n                  <GridTool\n                    ref={this.gridToolRef}\n                    undoPointer={UndoStore.pointer}\n                    undoStackId={UndoStore.lastStoreId}\n                    loading={this.loading}\n                    addMode={this.addMode}\n                    currentTool={this.currentTool}\n                    selectedInstanceId={this.selectedInstanceId}\n                    selectedShape={this.selectedShape}\n                  />\n                )}\n              </>\n            )}\n            {SettingsStore.viewMode === ViewMode.GRID && (\n              <GridView\n                ref={this.gridsRef}\n                app={this.props.app}\n                readonly={this.readonly}\n                labelMode={this.labelMode}\n                attributesMode={SettingsStore.activePointAttributesMode}\n                frames={this.frames}\n                currentFrame={this.currentFrame}\n                instances={this.instances}\n                selectedInstanceId={this.selectedInstanceId}\n                selectedCategoryColor={this.selectedCategory.display_color}\n                setFrame={this.setFrame}\n                addShape={this.addShape}\n                createShape={this.createShape}\n                updateShape={this.updateShapeForInstance}\n                deleteShape={this.deleteShapeFromInstance}\n                addShapeToInstance={this.addShapeToInstance}\n                getInstanceLabel={this.getInstanceLabel}\n              />\n            )}\n          </div>\n          {hasRightPanel && (\n            <Attributes\n              ref={this.attributesRef}\n              readonly={readonly}\n              isMultiFrame={this.frames.length > 1}\n              config={toJS(SettingsStore.labelConfig)}\n              ocrTagGroup={toJS(SettingsStore.ocrTagGroup)}\n              values={toJS(this.currentAttributes)}\n              snapshot={this.currentSnapshot}\n              currentFrame={this.currentFrame}\n              currentImage={this.frames[this.currentFrame]}\n              selectedInstance={this.instances[this.selectedInstanceId]}\n              selectedCategoryColor={this.selectedCategory.display_color}\n              onValuesChange={this.setAttributes}\n              getInstanceLabel={this.getInstanceLabel}\n            />\n          )}\n        </div>\n        {hasFrameControl && (\n          <FrameControl\n            readonly={readonly}\n            undoStackPointer={UndoStore.pointer}\n            frameCount={this.frames.length}\n            frameLoading={loading}\n            currentFrame={this.currentFrame}\n            invalidFrames={toJS(FramesStore.invalidFrames)}\n            categoryInstancesMap={toJS(this.categoryInstancesMap)}\n            instances={this.instances}\n            frameInstances={this.frameInstances}\n            frameReviews={toJS(ReviewsStore.frameReviewsMap)}\n            selectedInstance={this.instances[this.selectedInstanceId]}\n            selectedInstanceFrames={toJS(this.selectedInstanceFrames)}\n            selectInstance={this.selectInstance}\n            setFrame={this.setFrame}\n            getCategory={this.getCategory}\n            getInstanceLabel={this.getInstanceLabel}\n            onHeightChange={(height: number) => {\n              this.frameControlHeight = height;\n            }}\n          />\n        )}\n        {this.selectedInstanceId && this.instanceMoving && (\n          <InstanceMove\n            ontology={this.props.ontology}\n            currentFrame={this.currentFrame}\n            activeInstanceId={this.selectedInstanceId}\n            instances={this.instances}\n            categoryInstancesMap={toJS(this.categoryInstancesMap)}\n            onMove={this.move}\n            onClose={() => this.setInstanceMoving(false)}\n            getInstanceLabel={this.getInstanceLabel}\n          />\n        )}\n        <Review\n          currentFrame={this.currentFrame}\n          instances={this.instances}\n          saveFile={this.props.jobProxy.saveFile}\n          onReviewed={() => this.gridsRef.current?.updateStyle(this.currentFrame)}\n          getInstanceLabel={this.getInstanceLabel}\n        />\n      </LayoutWrapper>\n    );\n  }\n}\n\nexport default AppWrapper(VideoTracking, {\n  mappingMethods: Object.values(methods),\n});\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,OAAO,EAAEC,YAAY,QAAQ,MAAM;AAC5C,SAASC,UAAU,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,cAAc,QAAQ,MAAM;AACjE,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,EAAE,IAAIC,MAAM,QAAQ,MAAM;AACnC,SAASC,SAAS,EAAEC,SAAS,EAAEC,OAAO,QAAQ,QAAQ;AAEtD,OAAOC,SAAS,MAAM,qBAAqB;AAC3C,OAAOC,aAAa,MAAM,gCAAgC;AAC1D,OAAOC,UAAU,MAAM,qCAAqC;AAC5D,OAAOC,MAAM,MAAM,gCAAgC;AACnD,OAAOC,YAAY,MAAM,+BAA+B;AACxD,SAASC,SAAS,QAAmB,wBAAwB;AAC7D,SAAgBC,WAAW,EAAEC,WAAW,QAAsB,wBAAwB;AACtF,OAAOC,OAAO,MAAM,0BAA0B;AAC9C,OAAOC,IAAI,MAAM,uBAAuB;AACxC,OAAOC,SAAS,IAAIC,QAAQ,QAAuB,4BAA4B;AAC/E,OAAOC,KAAK,MAAM,8BAA8B;AAChD,OAAOC,MAAM,MAAM,kBAAkB;AACrC,OAAOC,QAAQ,MAAM,uBAAuB;AAC5C,OAAOC,OAAO,MAAM,sBAAsB;AAC1C,OAAOC,OAAO,MAAM,sBAAsB;AAC1C,OAAOC,UAAU,MAA4B,yBAAyB;AACtE,OAAOC,YAAY,MAAM,2BAA2B;AACpD,OAAOC,YAAY,MAAM,2BAA2B;AACpD,OAAOC,MAAM,MAAM,qBAAqB;AACxC,OAAOC,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,WAAW,MAAM,0BAA0B;AAClD,OAAOC,QAAQ,MAA0B,uBAAuB;AAChE,OAAOC,kBAAkB,MAAM,mBAAmB;AAClD,OAAOC,SAAS,MAAqB,mBAAmB;AACxD,OAAOC,aAAa,MAAM,uBAAuB;AACjD,OAAOC,kBAAkB,MAAM,4BAA4B;AAC3D,OAAOC,YAAY,MAAM,sBAAsB;AAC/C,OAAOC,WAAW,MAAM,qBAAqB;AAC7C,SAASC,IAAI,EAAmFC,QAAQ,EAAEC,SAAS,QAAQ,SAAS;AACpI,SACEC,mBAAmB,EACnBC,uBAAuB,EACvBC,gBAAgB,EAChBC,gBAAgB,EAChBC,gBAAgB,EAChBC,kBAAkB,EAClBC,WAAW,EACXC,kBAAkB,EAClBC,wBAAwB,QACnB,SAAS;AAChB,SAASC,OAAO,QAAQ,WAAW;AACnC,OAAOC,IAAI,MAAM,WAAW;AAE5B,OAAOC,MAAM,MAA0B,6BAA6B;AACpE,SAASC,SAAS,EAAEC,oBAAoB,EAAEC,gBAAgB,QAAQ,uBAAuB;AACzF,OAAO,iCAAiC;AACxC,OAAO,cAAc;AAuBrB,WACaC,aAAa,GADzBtD,QAAQ,CAAAuD,MAAA,IAAAC,OAAA,IAAAC,cAAA,GAAT,MACaH,aAAa,SAAS7D,KAAK,CAACiE,SAAS,CAAqB;EA8LrEC,WAAWA,CAACC,KAAyB,EAAE;IACrC,KAAK,CAACA,KAAK,CAAC;IA1Ld;AACF;AACA;IAFEC,0BAAA,iBAAAC,WAAA;IAKA;AACF;AACA;IAFED,0BAAA,uBAAAE,YAAA;IAKA;AACF;AACA;IAFEF,0BAAA,sBAAAG,YAAA;IAKA;AACF;AACA;IAFEH,0BAAA,kBAAAI,YAAA;IAKA;AACF;AACA;IAFEJ,0BAAA,kBAAAK,YAAA;IAKA;AACF;AACA;IAFEL,0BAAA,oBAAAM,YAAA;IAKA;AACF;AACA;IAFEN,0BAAA,iBAAAO,YAAA;IAKA;AACF;AACA;IAFEP,0BAAA,+BAAAQ,YAAA;IAKA;AACF;AACA;IAFER,0BAAA,6BAAAS,YAAA;IAKA;AACF;AACA;IAFET,0BAAA,iCAAAU,YAAA;IAKA;AACF;AACA;IAFEV,0BAAA,8BAAAW,YAAA;IAKA;AACF;AACA;IAFEX,0BAAA,+BAAAY,aAAA;IAKA;AACF;AACA;IAFEZ,0BAAA,4BAAAa,aAAA;IAKA;AACF;AACA;IAFEb,0BAAA,0BAAAc,aAAA;IAKA;AACF;AACA;IAFEd,0BAAA,yBAAAe,aAAA;IAKA;AACF;AACA;IAFEf,0BAAA,yBAAAgB,aAAA;IAKA;AACF;AACA;IAFEhB,0BAAA,6BAAAiB,aAAA;IAKA;AACF;AACA;IAFE,KAGAC,SAAS,GAAqC,CAAC,CAAC;IAEhD;AACF;AACA;IAFE,KAGAC,cAAc,GAAe,EAAE;IAE/B;AACF;AACA;IAFE,KAGAC,WAAW,GAAQ,IAAI;IAEvB;AACF;AACA;IAFE,KAGAC,MAAM,GAAuB,EAAE;IAE/B;AACF;AACA;IAFE,KAGAC,gBAAgB,GAAgC,CAAC,CAAC;IAElD;AACF;AACA;IAFE,KAGAC,YAAY,GAA4B,IAAI;IAE5C;AACF;AACA;IAFE,KAGAC,aAAa,GAA4B,IAAI;IAE7C;AACF;AACA;IAFE,KAGAC,cAAc,GAA4B,IAAI;IAE9C;AACF;AACA;IAFE,KAGAC,kBAAkB,GAAqB,IAAI;IAE3C;AACF;AACA;IAFE,KAGAC,KAAK,GAAkB,IAAI;IAE3B;AACF;AACA;IAFE,KAGAC,cAAc,GAA0B,IAAI;IAE5C;AACF;AACA;IAFE,KAGAC,eAAe,GAAGjG,KAAK,CAACkG,SAAS,CAAiB,CAAC;IAEnD;AACF;AACA;IAFE,KAGAC,SAAS,GAAGnG,KAAK,CAACkG,SAAS,CAAS,CAAC;IAErC;AACF;AACA;IAFE,KAGAE,QAAQ,GAAGpG,KAAK,CAACkG,SAAS,CAAW,CAAC;IAEtC;AACF;AACA;IAFE,KAGAG,QAAQ,GAAGrG,KAAK,CAACkG,SAAS,CAAc,CAAC;IAEzC;AACF;AACA;IAFE,KAGAI,aAAa,GAAGtG,KAAK,CAACkG,SAAS,CAAmB,CAAC;IAEnD;AACF;AACA;IAFE,KAGAK,QAAQ,GAAGvG,KAAK,CAACkG,SAAS,CAAY,CAAC;IAEvC;AACF;AACA;IAFE,KAGAM,YAAY,GAAGxG,KAAK,CAACkG,SAAS,CAAY,CAAC;IAE3C;AACF;AACA;IAFE,KAGAO,WAAW,GAAGzG,KAAK,CAACkG,SAAS,CAAiB,CAAC;IAE/C;AACF;AACA;IAFE,KAGAQ,oBAAoB,GAAG,MAAM,CAAC,CAAC;IAAA,KAgF/BC,UAAU,GAAG,MAAOC,UAAkB,IAAK;MACzC,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAC1C,KAAK,CAAC2C,QAAQ,CAACH,UAAU,CAAC,CAAC;MACrD,IAAI,CAACE,MAAM,EAAE;QACX;MACF;MACA,IAAIA,MAAM,CAACE,OAAO,EAAE;QAClB,IAAI,CAAC5C,KAAK,CAAC2C,QAAQ,CAACE,UAAU,CAACH,MAAM,CAACE,OAAO,CAAC;MAChD;MACA,MAAM;QAAEzB,SAAS;QAAEC,cAAc;QAAE0B;MAAqB,CAAC,GAAGlE,uBAAuB,CAAC8D,MAAM,EAAED,UAAU,CAAC;MACvG,IAAI,CAACtB,SAAS,GAAGA,SAAS;MAC1B,IAAI,CAACC,cAAc,GAAGA,cAAc;MACpC,IAAI,CAAC0B,oBAAoB,GAAGA,oBAAoB;MAChDzE,kBAAkB,CAAC0E,cAAc,CAACL,MAAM,CAACM,aAAa,EAAE7B,SAAS,CAAC;MAClE5C,WAAW,CAACwE,cAAc,CAACL,MAAM,CAACO,MAAM,CAAC;MACzC;MACA,MAAMC,UAAU,GAAG,MAAM,IAAI,CAAClD,KAAK,CAAC2C,QAAQ,CAACQ,cAAc,CAAC,CAAC;MAC7D,IAAID,UAAU,EAAE;QACd,IAAI,CAAC7B,WAAW,GAAG9E,SAAS,CAAC;UAC3B4E,SAAS,EAAE+B,UAAU,CAAC/B,SAAS;UAC/B6B,aAAa,EAAEE,UAAU,CAACF,aAAa;UACvCC,MAAM,EAAEC,UAAU,CAACD;QACrB,CAAC,CAAC;MACJ;IACF,CAAC;IAAA,KAEDG,aAAa,GAAG,MAAM;MACpB,MAAMC,OAEL,GAAG,CAAC,CAAC;MACN/E,YAAY,CAACgF,iBAAiB,CAAC,CAAC,CAACC,OAAO,CAAEC,MAAM,IAAK;QACnD,IAAI,CAACH,OAAO,CAACG,MAAM,CAACC,UAAU,CAAC,EAAE;UAC/BJ,OAAO,CAACG,MAAM,CAACC,UAAU,CAAC,GAAG,CAAC,CAAC;QACjC;QACAJ,OAAO,CAACG,MAAM,CAACC,UAAU,CAAC,CAACD,MAAM,CAACE,UAAU,CAAC,GAAGF,MAAM,CAACd,MAAM;MAC/D,CAAC,CAAC;MACF,MAAMpB,MAEL,GAAG,CAAC,CAAC;MACNqC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACzC,SAAS,CAAC,CAACoC,OAAO,CAAEM,QAAkB,IAAK;QAC5DF,MAAM,CAACC,MAAM,CAACC,QAAQ,CAACZ,MAAM,CAAC,CAACM,OAAO,CAAEO,KAAK,IAAK;UAChD,IAAIN,MAAM;UACV,IAAIH,OAAO,CAACQ,QAAQ,CAACE,EAAE,CAAC,EAAE;YACxBP,MAAM,GAAGH,OAAO,CAACQ,QAAQ,CAACE,EAAE,CAAC,CAACD,KAAK,CAACJ,UAAU,CAAC;UACjD;UACA,MAAMM,KAAK,GAAG,GAAG7E,wBAAwB,CAAC2E,KAAK,CAAC,EAAE;UAClD,IAAI,CAACxC,MAAM,CAAC0C,KAAK,CAAC,EAAE;YAClB1C,MAAM,CAAC0C,KAAK,CAAC,GAAG;cACdC,QAAQ,EAAE,CAAC;cACXC,QAAQ,EAAE;YACZ,CAAC;UACH;UACA,IAAIV,MAAM,KAAK,QAAQ,EAAE;YACvBlC,MAAM,CAAC0C,KAAK,CAAC,CAACC,QAAQ,IAAI,CAAC;UAC7B,CAAC,MAAM;YACL3C,MAAM,CAAC0C,KAAK,CAAC,CAACE,QAAQ,IAAI,CAAC;UAC7B;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,OAAO;QAAE5C;MAAO,CAAC;IACnB,CAAC;IAAA,KAED6C,UAAU,GAAG,OAAOC,IAAI,GAAG,QAAQ,KAAK;MACtC,IAAIA,IAAI,KAAK,QAAQ,EAAE;QAAA,IAAAC,qBAAA;QACrB,CAAAA,qBAAA,OAAI,CAACjC,QAAQ,CAACkC,OAAO,cAAAD,qBAAA,uBAArBA,qBAAA,CAAuBE,iBAAiB,CAAC,CAAC;QAC1C,IAAInG,aAAa,CAACoG,WAAW,EAAE;UAC7B;UACA,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAAC,CAAC;UAC7C,IAAI,CAACD,MAAM,EAAE;YACX,MAAM,IAAIE,KAAK,CAACtF,IAAI,CAACuF,SAAS,CAAC,mBAAmB,CAAC,CAAC;UACtD;QACF;MACF;MAEA,MAAMC,YAAY,GAAGlB,MAAM,CAACC,MAAM,CAAC,IAAI,CAACzC,SAAS,CAAC,CAAC2D,GAAG,CAAEjB,QAAQ,KAAM;QACpE,GAAGA,QAAQ;QACXZ,MAAM,EAAEU,MAAM,CAACC,MAAM,CAACC,QAAQ,CAACZ,MAAM;MACvC,CAAC,CAAC,CAAC;MACH,OAAO,IAAI,CAACjD,KAAK,CAAC2C,QAAQ,CAACwB,UAAU,CAAC;QACpCvB,OAAO,EAAE,IAAI,CAAC5C,KAAK,CAAC2C,QAAQ,CAACC,OAAO;QACpCzB,SAAS,EAAE0D,YAAY;QACvB7B,aAAa,EAAE3E,kBAAkB,CAAC0G,uBAAuB,CAAC,CAAC;QAC3D9B,MAAM,EAAE1E,WAAW,CAACyG,gBAAgB,CAAC;MACvC,CAAC,EAAEZ,IAAI,KAAK,QAAQ,CAAC;IACvB,CAAC;IAAA,KAEDa,WAAW,GAAG,YAAY;MACxB,MAAM5B,OAAO,GAAG,MAAM,IAAI,CAACrD,KAAK,CAAC2C,QAAQ,CAACsC,WAAW,CAAC,CAAC;MACvD3G,YAAY,CAACyE,cAAc,CAACM,OAAO,CAAC;IACtC,CAAC;IAAA,KAED6B,WAAW,GAAG,CAACd,IAAI,GAAG,QAAQ,KAAK;MACjC,IAAIA,IAAI,KAAK,QAAQ,EAAE;QAAA,IAAAe,sBAAA;QACrB,CAAAA,sBAAA,OAAI,CAAC/C,QAAQ,CAACkC,OAAO,cAAAa,sBAAA,uBAArBA,sBAAA,CAAuBZ,iBAAiB,CAAC,CAAC;MAC5C;MACA,MAAMlB,OAAO,GAAG/E,YAAY,CAACgF,iBAAiB,CAAC,CAAC;MAChD,OAAO,IAAI,CAACtD,KAAK,CAAC2C,QAAQ,CAACuC,WAAW,CAAC7B,OAAO,CAAC;IACjD,CAAC;IAAA,KAED+B,IAAI,GAAG,OAAOC,UAAU,GAAG,KAAK,KAAK;MACnC,MAAM;QAAEC;MAAS,CAAC,GAAG,IAAI,CAACtF,KAAK,CAAC2C,QAAQ;MACxC,IAAI,IAAI,CAACM,MAAM,CAACsC,MAAM,IAAI,CAAC,IAAIhG,SAAS,CAAC+F,QAAQ,CAAC,EAAE;QAAE;QACpD;MACF;MAEA,MAAME,QAAQ,GAAG,EAAE;MACnB,IAAI,CAAChG,oBAAoB,CAAC8F,QAAQ,CAAC,EAAE;QACnCE,QAAQ,CAACC,IAAI,CAAC,IAAI,CAACtB,UAAU,CAAC,MAAM,CAAC,CAAC;MACxC;MACA,IAAI1E,gBAAgB,CAAC6F,QAAQ,CAAC,EAAE;QAC9BE,QAAQ,CAACC,IAAI,CAAC,IAAI,CAACP,WAAW,CAAC,MAAM,CAAC,CAAC;MACzC;MACA,IAAIM,QAAQ,CAACD,MAAM,GAAG,CAAC,EAAE;QACvB,IAAI;UAAA,IAAAG,sBAAA;UACF,MAAMC,OAAO,CAACC,GAAG,CAACJ,QAAQ,CAAC;UAC3B1J,OAAO,CAAC+J,OAAO,CAACxG,IAAI,CAACuF,SAAS,CAACS,UAAU,GAAG,mBAAmB,GAAG,cAAc,CAAC,CAAC;UAClF;UACA,CAAAK,sBAAA,OAAI,CAACtD,QAAQ,CAACkC,OAAO,cAAAoB,sBAAA,uBAArBA,sBAAA,CAAuBI,YAAY,CAAC,IAAI,CAAC;QAC3C,CAAC,CAAC,OAAOC,CAAC,EAAE;UACV,IAAI,CAACV,UAAU,EAAE;YACfvJ,OAAO,CAACkK,KAAK,CAAC3G,IAAI,CAACuF,SAAS,CAAC,WAAW,CAAC,CAAC;UAC5C,CAAC,MAAM;YACL,MAAMmB,CAAC;UACT;QACF;MACF;IACF,CAAC;IAAA,KAEDE,UAAU,GAAG,MAAM;MACjB,MAAMC,aAAa,GAAGvC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACzC,SAAS,CAAC,CAAC2D,GAAG,CAAEjB,QAAQ,KAAM;QACrE,GAAGA,QAAQ;QACXZ,MAAM,EAAEU,MAAM,CAACC,MAAM,CAACC,QAAQ,CAACZ,MAAM;MACvC,CAAC,CAAC,CAAC;MACH,MAAMkD,iBAAiB,GAAG9H,kBAAkB,CAAC0G,uBAAuB,CAAC,CAAC;MACtE,MAAMqB,UAAU,GAAG7H,WAAW,CAACyG,gBAAgB,CAAC,CAAC;MACjD,MAAM;QAAE7D,SAAS,GAAG,EAAE;QAAE6B,aAAa,GAAG,EAAE;QAAEC,MAAM,GAAG;MAAG,CAAC,GAAG,IAAI,CAAC5B,WAAW,IAAI,CAAC,CAAC;MAClF,OAAO,CAAC5E,OAAO,CAACyJ,aAAa,EAAE/E,SAAS,CAAC,IAAI,CAAC1E,OAAO,CAAC0J,iBAAiB,EAAEnD,aAAa,CAAC,IAAI,CAACvG,OAAO,CAAC2J,UAAU,EAAEnD,MAAM,CAAC;IACzH,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAoD,iBAAiB,GAAIC,IAAU,IAAK;MAClC,IAAI,CAACC,WAAW,GAAGD,IAAI;MACvB,IAAI,CAAC,IAAI,CAACE,OAAO,EAAE;QACjB,IAAI,CAACC,aAAa,CAAC,IAAI,CAAC;MAC1B;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKAA,aAAa,GAAG,CAACD,OAAgB,EAAEE,WAAW,GAAG,KAAK,KAAK;MAAA,IAAAC,qBAAA;MACzD,IAAI,CAACD,WAAW,KACd,IAAI,CAACE,QAAQ,IACb,IAAI,CAACC,cAAc,MAAAF,qBAAA,GACnB,IAAI,CAACxE,aAAa,CAACmC,OAAO,cAAAqC,qBAAA,uBAA1BA,qBAAA,CAA4BG,YAAY,KACxC,CAAC,CAACxI,YAAY,CAACyI,iBAAiB,CACjC,EAAE;QACD;MACF;MAEA,IAAI,CAACP,OAAO,GAAGA,OAAO;MACtB;MACA,IAAI,CAACQ,MAAM,GAAGR,OAAO,GAAGjJ,MAAM,CAAC0J,SAAS,GAAG1J,MAAM,CAAC2J,OAAO;MACzD;MACA,IAAI,CAAC5F,MAAM,CAACiC,OAAO,CAAES,KAAK,IAAK;QAC7BA,KAAK,CAACmD,WAAW,GAAG,CAACX,OAAO;MAC9B,CAAC,CAAC;MACF;MACA,IAAI,CAACA,OAAO,IAAI,IAAI,CAAChF,YAAY,EAAE;QACjC,IAAI,CAACA,YAAY,CAAC4F,OAAO,CAAC,CAAC;QAC3B,IAAI,CAAC5F,YAAY,GAAG,IAAI;MAC1B;MACA;MACA,IAAI,IAAI,CAAC6F,kBAAkB,EAAE;QAC3B,IAAI,CAACC,OAAO,CAACd,OAAO,GAAGe,SAAS,GAAG,IAAI,CAACpG,SAAS,CAAC,IAAI,CAACkG,kBAAkB,CAAC,CAAC;MAC7E;IACF,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAG,eAAe,GAAIC,SAAkB,IAAK;MACxC,IAAI,IAAI,CAACA,SAAS,KAAKA,SAAS,EAAE;QAChC,IAAI,CAACA,SAAS,GAAGA,SAAS;QAC1B,IAAI,CAACnG,MAAM,CAACiC,OAAO,CAAES,KAAK,IAAK;UAC7B,MAAM0D,OAAO,GAAG,IAAI,CAACvG,SAAS,CAAC,IAAI,CAACI,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC,CAAC;UAChE3D,KAAK,CAAC4D,KAAK,GAAG,IAAI,CAACH,SAAS,GAAG,IAAI,CAACI,gBAAgB,CAACH,OAAO,CAAC,GAAG,EAAE;QACpE,CAAC,CAAC;QACF,IAAI,IAAI,CAAChG,cAAc,EAAE;UACvB,IAAI,CAACA,cAAc,CAACkG,KAAK,GAAG,IAAI,CAACH,SAAS,GAAG,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAC1G,SAAS,CAAC,IAAI,CAACkG,kBAAkB,CAAC,CAAC,GAAG,EAAE;QAClH;QACA,IAAI,IAAI,CAACvF,eAAe,CAACwC,OAAO,EAAE;UAChC,IAAI,CAACxC,eAAe,CAACwC,OAAO,CAACwD,KAAK,CAACC,OAAO,GAAGN,SAAS,GAAG,OAAO,GAAG,MAAM;QAC3E;MACF;IACF,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAO,QAAQ,GAAIlE,KAAa,IAAK;MAC5B,IAAI,IAAI,CAACmE,YAAY,KAAKnE,KAAK,EAAE;QAAA,IAAAoE,oBAAA;QAC/B,IAAI,CAACD,YAAY,GAAGnE,KAAK;QACzB,IAAI1F,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;UAC/C,IAAI,CAACkB,OAAO,GAAG,IAAI;QACrB,CAAC,MAAM;UACL,IAAI,CAACC,cAAc,CAAC,CAAC;QACvB;QACA,CAAAH,oBAAA,OAAI,CAACrG,cAAc,cAAAqG,oBAAA,uBAAnBA,oBAAA,CAAqBI,OAAO,CAAC,IAAI,CAACL,YAAY,CAAC;MACjD;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGAI,cAAc,GAAG,MAAM;MACrB;MACA,IAAI,CAACE,WAAW,CAAC,CAAC;;MAElB;MACA,IAAI,CAACC,iBAAiB,CAAC,KAAK,CAAC;MAC7B;MACA,IAAI,CAAC/B,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC;MAC/B;MACApI,kBAAkB,CAACoK,qBAAqB,CAAC,CAAC;;MAE1C;MACA,IAAI,CAACC,mBAAmB,GAAG,IAAI,CAACtH,cAAc,CAAC,IAAI,CAAC6G,YAAY,CAAC,CAC9DU,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,MAAM;QAAE,GAAGD,GAAG;QAAE,CAACC,IAAI,GAAG;MAAK,CAAC,CAAC,EAAE,CAAC,CAAoC,CAAC;IAC7F,CAAC;IAED;AACF;AACA;IAFE,KAGAC,UAAU,GAAG,CAACC,CAAS,EAAEnH,KAAa,KAAK;MACzC,IAAI,CAACA,KAAK,GAAGA,KAAK;;MAElB;MACA,IAAI,CAACyG,cAAc,CAAC,CAAC;MACrB;MACA,IAAI,CAACjH,cAAc,CAAC,IAAI,CAAC6G,YAAY,CAAC,CAAC1E,OAAO,CAAEE,UAAU,IAAK;QAC7D,MAAMI,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAACsC,UAAU,CAAC;QAC3C,MAAMuF,QAAQ,GAAG,IAAI,CAACC,WAAW,CAACpF,QAAQ,CAACmF,QAAQ,CAAC;QACpD,IAAIA,QAAQ,EAAE;UACZ,MAAMhF,KAAK,GAAG,IAAI,CAACkF,WAAW,CAC5BF,QAAQ,CAACG,aAAa,EACtB,IAAI,CAACtB,gBAAgB,CAAChE,QAAQ,CAAC,EAC/BA,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAACmB,SAAS,EAC5CvF,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAACjE,KACrC,CAAC;UACD,IAAI,IAAI,CAAC4C,QAAQ,EAAE;YACjB5C,KAAK,CAACqF,QAAQ,GAAG,KAAK;UACxB;UACA,IAAI,CAACC,iBAAiB,CAACtF,KAAK,CAAC;UAC7B,IAAI,CAAC1C,MAAM,CAACmE,IAAI,CAACzB,KAAK,CAAC;UACvB,IAAI,CAACzC,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC,GAAG9D,QAAQ,CAACE,EAAE;QAChD;MACF,CAAC,CAAC;MAEF,IAAI,IAAI,CAACsD,kBAAkB,EAAE;QAC3B,IAAI,CAACkC,cAAc,CAAC,IAAI,CAAClC,kBAAkB,CAAC;MAC9C;MACA,IAAI,CAACmC,kBAAkB,CAAC,CAAC;MACzB,IAAI,CAACC,YAAY,CAAC,CAAC;MAEnB,IAAI,CAACrB,OAAO,GAAG,KAAK;IACtB,CAAC;IAoBD;AACF;AACA;IAFE,KAGAsB,gBAAgB,GAAG,MAAM;MACvB,MAAMC,UAAU,GAAG,IAAIrM,KAAK,CAAC;QAAEsM,SAAS,EAAE;MAAiB,CAAC,CAAC;MAC7DD,UAAU,CAACE,cAAc,CAAC,IAAI,CAAC/H,eAAe,CAACwC,OAAQ,CAAC;MACxD,OAAOqF,UAAU;IACnB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IARE,KASAT,WAAW,GAAG,CAACY,QAAgB,EAAElC,KAAc,EAAEwB,SAAqB,EAAEW,SAAqB,EAAEC,cAA0B,EAAEC,WAAW,GAAG,IAAI,CAACA,WAAW,KAAK;MAC5J,MAAMC,UAAU,GAAGd,SAAS,KAAK7B,SAAS;MAC1C,MAAM4C,KAAK,GAAGC,QAAQ,CAACN,QAAQ,CAACO,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MAC9C,MAAMC,gBAAgB,GAAGlB,SAAS,IAAI,IAAI,CAACkB,gBAAgB;MAC3D,MAAMtG,KAAK,GAAGlH,YAAY,CAACyN,QAAQ,CAACD,gBAAgB,EAAE;QACpDE,GAAG,EAAE,IAAI,CAACxK,KAAK,CAACwK,GAAG;QACnBC,SAAS,EAAET,cAAc;QACzBG,KAAK;QACLO,aAAa,EAAE,QAAQ;QACvBC,KAAK,EAAE,GAAG;QACV,IAAGvM,aAAa,CAACwM,aAAa,IAAI;UAAEC,MAAM,EAAEZ;QAAY,CAAC;QACzD,IAAI,IAAI,CAACxC,SAAS,IAAI;UAAEG;QAAM,CAAC,CAAC;QAChC,GAAGmC,SAAS;QACZ,IAAIG,UAAU,IAAI,IAAI,CAAC3D,WAAW,KAAK/H,IAAI,CAACsM,oBAAoB,IAAI;UAClEC,iBAAiB,EAAE;QACrB,CAAC,CAAC;QACF,IAAIb,UAAU,IAAI,IAAI,CAAC3D,WAAW,KAAK/H,IAAI,CAACwM,mBAAmB,IAAI;UACjEC,QAAQ,EAAE5N,QAAQ,CAAC6N;QACrB,CAAC,CAAC;QACFC,SAAS,EAAE/M,aAAa,CAAC+M,SAAS;QAClC,IAAG/M,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,IAAI;UAChDkE,QAAQ,EAAE,IAAI,CAAC1B,gBAAgB,CAAC;QAClC,CAAC;QACD2B,iBAAiB,EAAE,IAAI,CAACC;MAC1B,CAAC,CAAC;MACF,IAAIvB,SAAS,IAAIO,gBAAgB,KAAKvN,SAAS,CAACwO,SAAS,EAAE;QACzDvH,KAAK,CAAEwH,QAAQ,GAAIzB,SAAS,CAAmByB,QAAQ,IAAI,CAAC;MAC9D;MACAxH,KAAK,CAAEyH,YAAY,GAAGrN,aAAa,CAACsN,yBAAoD;MACxF,OAAO1H,KAAK;IACd,CAAC;IA+BD;AACF;AACA;AACA;AACA;AACA;IALE,KAMA2H,QAAQ,GAAG,CAACC,KAAY,EAAE5B,cAA0B,EAAEC,WAA2E,KAAK;MACpI,IAAI,IAAI,CAACzD,OAAO,IAAI,CAAC,IAAI,CAAChF,YAAY,EAAE;QACtC,IAAI,CAACA,YAAY,GAAG,IAAI,CAAC0H,WAAW,CAClC,IAAI,CAAC2C,gBAAgB,CAAC1C,aAAa,EACnC5B,SAAS,EACTA,SAAS,EACTA,SAAS,EACTyC,cAAc,EACdC,WACF,CAAC;;QAED;QACA,IAAI,CAACzI,YAAY,CAACsK,EAAE,CAAC7O,WAAW,CAAC8O,QAAQ,EAAG/H,KAAK,IAAK;UACpD;UACAA,KAAK,CAACgI,GAAG,CAAC/O,WAAW,CAAC8O,QAAQ,CAAC;UAC/B/H,KAAK,CAACgI,GAAG,CAAC/O,WAAW,CAACgP,OAAO,CAAC;UAC9B;UACA,MAAMpI,QAAQ,GAAG,IAAI,CAACqI,kBAAkB,CAAC,CAAC;UAC1C,MAAMC,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;YAAEjL,SAAS,EAAE,CAAC0C,QAAQ;UAAE,CAAC,CAAC;UAC7D,IAAI,IAAI,CAAC4D,SAAS,EAAE;YAClBzD,KAAK,CAAC4D,KAAK,GAAG,IAAI,CAACC,gBAAgB,CAAChE,QAAQ,CAAC;UAC/C;UACA,IAAI,CAACwI,sBAAsB,CAACrI,KAAK,EAAEH,QAAQ,EAAE,IAAI,CAAC0C,WAAW,KAAK/H,IAAI,CAAC8N,GAAG,IAAI,IAAI,CAAC/F,WAAW,KAAK/H,IAAI,CAAC+N,WAAW,CAAC;UACpH,IAAI,CAAC/K,YAAY,GAAG,IAAI;UACxB,IAAI,CAACiF,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC;UAC/BtI,SAAS,CAACiH,IAAI,CAAC+G,OAAO,EAAE;YACtBhL,SAAS,EAAE,CAAC0C,QAAQ;UACtB,CAAC,CAAC;UAEF,IAAIzF,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;YAC/C,IAAI,CAACoC,iBAAiB,CAACtF,KAAK,CAAC;UAC/B,CAAC,MAAM;YAAA,IAAAwI,qBAAA;YACL,CAAAA,qBAAA,OAAI,CAACvK,QAAQ,CAACqC,OAAO,cAAAkI,qBAAA,uBAArBA,qBAAA,CAAuBC,MAAM,CAAC,CAAC;UACjC;QACF,CAAC,CAAC;QACF,IAAI,CAACjL,YAAY,CAACsK,EAAE,CAAC7O,WAAW,CAACgP,OAAO,EAAE,MAAM;UAC9C,IAAI,CAACzK,YAAY,GAAG,IAAI;QAC1B,CAAC,CAAC;QACF;QACA,IAAIkL,OAAO;QACX,IAAI,IAAI,CAACnG,WAAW,KAAK/H,IAAI,CAACmO,IAAI,IAAI,IAAI,CAACrK,WAAW,CAACgC,OAAO,EAAE;UAC9D,MAAMsI,SAAS,GAAG,IAAI,CAACtK,WAAW,CAACgC,OAAO,CAACuI,YAAY,CAAC,CAAC;UACzD,MAAMC,SAAS,GAAG,IAAI,CAACxK,WAAW,CAACgC,OAAO,CAACyI,YAAY,CAAC,CAAC;UACzDL,OAAO,GAAG;YAAEM,IAAI,EAAEJ,SAAS;YAAEK,IAAI,EAAEH;UAAU,CAAC;QAChD;QACA,IAAI,CAACtL,YAAY,CAAC0L,MAAM,CAACtB,KAAK,EAAEc,OAAO,CAAC;QAExC,OAAO,IAAI,CAAClL,YAAY;MAC1B;MACA,OAAO,IAAI;IACb,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIA2L,WAAW,GAAG,CAACnJ,KAAuB,EAAEoJ,QAAkB,KAAK;MAC7D,IAAI,CAAC,IAAI,CAAC3L,aAAa,IAAI,IAAI,CAACA,aAAa,CAACkG,GAAG,KAAK3D,KAAK,CAAC2D,GAAG,EAAE;QAC/D;QACA,IAAI,IAAI,CAAClG,aAAa,EAAE;UACtB,IAAI,CAACA,aAAa,CAAC4L,QAAQ,GAAG,KAAK;QACrC;QACA,IAAI,CAAC5L,aAAa,GAAGuC,KAAK;QAC1B,IAAI,CAACvC,aAAa,CAAC4L,QAAQ,GAAG,IAAI;QAClC,IAAI,CAACC,mBAAmB,CAAC,IAAI,CAAC/L,gBAAgB,CAAC,IAAI,CAACE,aAAa,CAACkG,GAAG,CAAC,EAAEyF,QAAQ,CAAC;MACnF;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGAG,aAAa,GAAG,MAAM;MACpB,IAAI,IAAI,CAAC/G,OAAO,EAAE;QAChB;MACF;MACA,IAAI,IAAI,CAAC/E,aAAa,EAAE;QACtB,IAAI,CAACA,aAAa,CAAC4L,QAAQ,GAAG,KAAK;MACrC;MACA,IAAI,CAAC5L,aAAa,GAAG,IAAI;MACzB,IAAI,CAAC6L,mBAAmB,CAAC,EAAE,CAAC;IAC9B,CAAC;IAeD;AACF;AACA;AACA;AACA;AACA;AACA;IANE,KAOAE,sBAAsB,GAAG,CAAC/J,UAAkB,EAAEO,KAAuB,EAAE+F,SAAoB,EAAEX,SAAqB,KAAK;MACrH,MAAMvF,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAACsC,UAAU,CAAC;MAC3C,MAAM;QAAER;MAAO,CAAC,GAAGY,QAAQ;MAC3B,MAAMsI,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;QACjCjL,SAAS,EAAE,CAAC0C,QAAQ;MACtB,CAAC,CAAC;MACF,IAAI,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,EAAE;QAC9B,IAAI,CAACoE,sBAAsB,CAACrI,KAAK,EAAEH,QAAQ,EAAE0D,SAAS,EAAE,IAAI,EAAE6B,SAAS,IAAI,IAAI,CAACzH,kBAAmB,EAAEoI,SAAS,CAAC;QAC/G/F,KAAK,CAACyJ,WAAW,GAAGzQ,WAAW,CAAC0Q,KAAK;QACrC,IAAI,CAAChM,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACC,kBAAkB,GAAG,IAAI;MAChC,CAAC,MAAM;QACLsB,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAAC0F,UAAU,GAAG,IAAI;QAC3C1K,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAACjE,KAAK,GAAG+F,SAAS;QAC3C,IAAI,CAAC6D,sBAAsB,CAAC,IAAI,CAAC3F,YAAY,CAAC,GAAG,IAAI;QACrD,IAAI,CAAC4F,WAAW,CAAChK,QAAQ,CAAC;MAC5B;MACA1F,SAAS,CAACiH,IAAI,CAAC+G,OAAO,EAAE;QACtBhL,SAAS,EAAE,CAAC0C,QAAQ;MACtB,CAAC,CAAC;MACF,IAAIZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAAC6F,KAAK,EAAE;QACnC,IAAI,CAACC,kBAAkB,CAAChE,SAAS,CAAC;MACpC;IACF,CAAC;IA+CD;AACF;AACA;AACA;AACA;AACA;IALE,KAMAiE,kBAAkB,GAAG,CAACvK,UAAkB,EAAEuG,cAA0B,EAAEC,WAAW,GAAG,IAAI,CAACA,WAAW,KAAK;MACvG,MAAMpG,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAACsC,UAAU,CAAC;MAC3C,MAAMwK,OAAO,GAAG9P,SAAS,CAACiO,QAAQ,CAAC;QAAEjL,SAAS,EAAE,CAAC0C,QAAQ;MAAE,CAAC,CAAC;MAC7D,IAAI,IAAI,CAACwD,kBAAkB,KAAK5D,UAAU,IAAI,IAAI,CAAC/B,cAAc,IAAI,IAAI,CAACC,kBAAkB,EAAE;QAC5F,IAAI,CAAC0K,sBAAsB,CAAC,IAAI,CAAC3K,cAAc,EAAEmC,QAAQ,EAAE0D,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC5F,kBAAkB,CAAC;QACpG,IAAI,CAACD,cAAc,CAAC+L,WAAW,GAAGzQ,WAAW,CAAC0Q,KAAK;QACnD,IAAI,CAAChM,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACC,kBAAkB,GAAG,IAAI;QAC9BxD,SAAS,CAACiH,IAAI,CAAC6I,OAAO,EAAE;UAAE9M,SAAS,EAAE,CAAC0C,QAAQ;QAAE,CAAC,CAAC;MACpD,CAAC,MAAM;QACL,IAAIqK,SAAS,GAAGrP,gBAAgB,CAAC,IAAI,CAACoJ,YAAY,EAAEpE,QAAQ,CAACZ,MAAM,EAAEgH,WAAW,CAAC;QACjF,IAAI,CAACiE,SAAS,EAAE;UACd,MAAMC,SAAS,GAAGxK,MAAM,CAACyK,IAAI,CAACvK,QAAQ,CAACZ,MAAM,CAAC,CAACoL,GAAG,CAAC,CAAC;UACpD,IAAIF,SAAS,EAAE;YACb,MAAM;cAAE/E,SAAS;cAAEpF;YAAM,CAAC,GAAGH,QAAQ,CAACZ,MAAM,CAACmH,QAAQ,CAAC+D,SAAS,EAAE,EAAE,CAAC,CAAC;YACrED,SAAS,GAAG;cAAE9E,SAAS;cAAEpF;YAAM,CAAC;UAClC;QACF;QACA,IAAIkK,SAAS,EAAE;UACb,MAAMlK,KAAK,GAAG,IAAI,CAACkF,WAAW,CAC5B,IAAI,CAAC2C,gBAAgB,CAAC1C,aAAa,EACnC,IAAI,CAACtB,gBAAgB,CAAChE,QAAQ,CAAC,EAC/BqK,SAAS,CAAC9E,SAAS,EACnB8E,SAAS,CAAClK,KAAK,EACfgG,cAAc,EACdC,WACF,CAAC;UACD,IAAI,CAACoC,sBAAsB,CAACrI,KAAK,EAAEH,QAAQ,EAAE0D,SAAS,EAAE,IAAI,EAAE2G,SAAS,CAAC9E,SAAS,EAAE8E,SAAS,CAAClK,KAAK,CAAC;UACnG7F,SAAS,CAACiH,IAAI,CAAC6I,OAAO,EAAE;YAAE9M,SAAS,EAAE,CAAC0C,QAAQ;UAAE,CAAC,CAAC;UAClD,IAAIzF,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;YAC/C,IAAI,CAACoC,iBAAiB,CAACtF,KAAK,CAAC;UAC/B;UACA,OAAOA,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb,CAAC;IAED;AACF;AACA;IAFE,KAGAsK,MAAM,GAAG,MAAM;MACb,IAAI,CAAC,IAAI,CAAC1H,QAAQ,IAAI,IAAI,CAACS,kBAAkB,EAAE;QAC7C,IAAIjJ,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;UAC/C,MAAMlD,KAAK,GAAG,IAAI,CAACuK,kBAAkB,CAAC,IAAI,CAAClH,kBAAkB,CAAC;UAC9D,IAAIrD,KAAK,EAAE;YACT,MAAMwK,aAAa,GAAGxK,KAAK,CAACyK,oBAAoB,CAAC,CAAC;YAClD,IAAI,CAACD,aAAa,EAAE;cAClB,IAAI,CAACE,uBAAuB,CAAC,IAAI,CAACrH,kBAAkB,EAAE,CAAC,IAAI,CAACY,YAAY,CAAC,CAAC;cAC1E,IAAI,CAACwB,YAAY,CAAC,CAAC;YACrB;UACF;QACF,CAAC,MAAM;UAAA,IAAAkF,sBAAA;UACL,CAAAA,sBAAA,OAAI,CAAC1M,QAAQ,CAACqC,OAAO,cAAAqK,sBAAA,uBAArBA,sBAAA,CAAuBL,MAAM,CAAC,IAAI,CAACrG,YAAY,EAAE,IAAI,CAACZ,kBAAkB,CAAC;QAC3E;MACF;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKAqH,uBAAuB,GAAG,CAACjL,UAAkB,EAAER,MAAgB,KAAK;MAClE,MAAMY,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAACsC,UAAU,CAAC;MAC3C,MAAM0I,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;QACjCjL,SAAS,EAAE,CAAC0C,QAAQ,CAAC;QACrBb,aAAa,EAAE3E,kBAAkB,CAAC0G,uBAAuB,CAAC,CAAC;QAC3D1B,OAAO,EAAE/E,YAAY,CAACgF,iBAAiB,CAAC;MAC1C,CAAC,CAAC;MACF,KAAK,IAAIsL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3L,MAAM,CAACsC,MAAM,EAAEqJ,CAAC,IAAI,CAAC,EAAE;QACzC,MAAMC,WAAW,GAAG5L,MAAM,CAAC2L,CAAC,CAAC;QAC7B;QACA,OAAO/K,QAAQ,CAACZ,MAAM,CAAC4L,WAAW,CAAC;QACnC;QACA,MAAMC,aAAa,GAAG,IAAI,CAAC1N,cAAc,CAACyN,WAAW,CAAC,CAACE,OAAO,CAACtL,UAAU,CAAC;QAC1E,IAAIqL,aAAa,IAAI,CAAC,EAAE;UACtB,IAAI,CAAC1N,cAAc,CAACyN,WAAW,CAAC,CAACG,MAAM,CAACF,aAAa,EAAE,CAAC,CAAC;QAC3D;QACA;QACA,IAAID,WAAW,KAAK,IAAI,CAAC5G,YAAY,EAAE;UACrC,MAAMjE,KAAK,GAAG,IAAI,CAACuK,kBAAkB,CAAC9K,UAAU,CAAC;UACjD,IAAIO,KAAK,EAAE;YACT,IAAI,CAACiL,WAAW,CAACjL,KAAK,CAAC;YACvB,OAAO,IAAI,CAACzC,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC;UACzC;UACA,OAAO,IAAI,CAACe,mBAAmB,CAAC7E,QAAQ,CAACE,EAAE,CAAC;QAC9C;QACA;QACA,IAAIF,QAAQ,CAACZ,MAAM,CAAC4L,WAAW,GAAG,CAAC,CAAC,EAAE;UACpChL,QAAQ,CAACZ,MAAM,CAAC4L,WAAW,GAAG,CAAC,CAAC,CAAClB,UAAU,GAAG,IAAI;QACpD;QACA,IAAI9J,QAAQ,CAACZ,MAAM,CAAC4L,WAAW,GAAG,CAAC,CAAC,EAAE;UACpChL,QAAQ,CAACZ,MAAM,CAAC4L,WAAW,GAAG,CAAC,CAAC,CAAClB,UAAU,GAAG,IAAI;QACpD;QACA;QACAtP,kBAAkB,CAAC6Q,4BAA4B,CAACzL,UAAU,EAAEoL,WAAW,CAAC;QACxE;QACAvQ,YAAY,CAAC6Q,sBAAsB,CAAC1L,UAAU,EAAEoL,WAAW,CAAC;MAC9D;MACA;MACA,IAAI,CAACjB,sBAAsB,GAAGpR,SAAS,CAACqH,QAAQ,CAACZ,MAAM,EAAE,YAAY,CAAC;MACtE;MACA,IAAIU,MAAM,CAACyK,IAAI,CAACvK,QAAQ,CAACZ,MAAM,CAAC,CAACsC,MAAM,IAAI,CAAC,EAAE;QAC5C;QACA,OAAO,IAAI,CAACpE,SAAS,CAACsC,UAAU,CAAC;QACjC,OAAO,IAAI,CAACX,oBAAoB,CAACe,QAAQ,CAACmF,QAAQ,CAAC,CAACnF,QAAQ,CAACE,EAAE,CAAC;QAChE,IAAI,IAAI,CAACsD,kBAAkB,KAAK5D,UAAU,EAAE;UAC1C,IAAI,CAAC6J,mBAAmB,CAAC,EAAE,CAAC,CAAC,CAAC;QAChC;MACF;MACA,IAAI,CAAChG,OAAO,CAACzD,QAAQ,CAAC;MACtB1F,SAAS,CAACiH,IAAI,CAAC+G,OAAO,EAAE;QACtBhL,SAAS,EAAE,CAAC0C,QAAQ,CAAC;QACrBb,aAAa,EAAE3E,kBAAkB,CAAC0G,uBAAuB,CAAC,CAAC;QAC3D1B,OAAO,EAAE/E,YAAY,CAACgF,iBAAiB,CAAC;MAC1C,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKA8L,6BAA6B,GAAG,CAAC3L,UAAkB,EAAEW,IAA6C,GAAG,SAAS,KAAK;MACjH,QAAQA,IAAI;QACV,KAAK,SAAS;UACZ,IAAI,CAACsK,uBAAuB,CAACjL,UAAU,EAAE,CAAC,IAAI,CAACwE,YAAY,CAAC,CAAC;UAC7D;QACF,KAAK,KAAK;UAAE;YACV,MAAMoH,aAAa,GAAGtQ,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACkJ,YAAY,EAAE,IAAI,CAAC9G,SAAS,CAACsC,UAAU,CAAC,CAACR,MAAM,CAAC;YAC/F,MAAMqM,YAAY,GAAGD,aAAa,CAAC9J,MAAM,KAAK,CAAC,GAAG8J,aAAa,CAAC,CAAC,CAAC,GAAG,IAAI,CAACpM,MAAM,CAACsC,MAAM,GAAG,CAAC;YAC3F,IAAI,CAACmJ,uBAAuB,CAC1BjL,UAAU,EACV8L,KAAK,CAACC,IAAI,CAAC;cAAEjK,MAAM,EAAE+J,YAAY,GAAG,IAAI,CAACrH;YAAa,CAAC,CAAC,CAACnD,GAAG,CAAC,CAACiE,CAAC,EAAE0G,KAAK,KAAK,IAAI,CAACxH,YAAY,GAAGwH,KAAK,CACtG,CAAC;YACD;UACF;QACA,KAAK,WAAW;UACd,IAAI,CAACf,uBAAuB,CAC1BjL,UAAU,EACV8L,KAAK,CAACC,IAAI,CAAC;YAAEjK,MAAM,EAAE,IAAI,CAACtC,MAAM,CAACsC,MAAM,GAAG,IAAI,CAAC0C;UAAa,CAAC,CAAC,CAACnD,GAAG,CAAC,CAACiE,CAAC,EAAE0G,KAAK,KAAK,IAAI,CAACxH,YAAY,GAAGwH,KAAK,CAC5G,CAAC;UACD;QACF,KAAK,KAAK;UACR,IAAI,CAACf,uBAAuB,CAC1BjL,UAAU,EACV8L,KAAK,CAACC,IAAI,CAAC;YAAEjK,MAAM,EAAE,IAAI,CAACtC,MAAM,CAACsC;UAAO,CAAC,CAAC,CAACT,GAAG,CAAC,CAACiE,CAAC,EAAE0G,KAAK,KAAKA,KAAK,CACpE,CAAC;UACD;QACF;MACF;IACF,CAAC;IAmGD;AACF;AACA;AACA;AACA;IAJE,KAKAlG,cAAc,GAAG,CAAC9F,UAAkB,EAAE2J,QAAkB,KAAK;MAC3D,IAAI,CAACE,mBAAmB,CAAC7J,UAAU,EAAE2J,QAAQ,CAAC;MAC9C;MACA,MAAMpJ,KAAK,GAAG,IAAI,CAACuK,kBAAkB,CAAC9K,UAAU,CAAC;MACjD,IAAI,IAAI,CAAChC,aAAa,EAAE;QACtB,IAAI,CAACA,aAAa,CAAC4L,QAAQ,GAAG,KAAK;MACrC;MACA,IAAIrJ,KAAK,EAAE;QACT,IAAI,CAACvC,aAAa,GAAGuC,KAAK;QAC1B,IAAI,CAACvC,aAAa,CAAC4L,QAAQ,GAAG,IAAI;MACpC,CAAC,MAAM;QACL,IAAI,CAAC5L,aAAa,GAAG,IAAI;MAC3B;IACF,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAoG,gBAAgB,GAAIhE,QAAkB,IAAK;MACzC,MAAMmF,QAAQ,GAAG,IAAI,CAACC,WAAW,CAACpF,QAAQ,CAACmF,QAAQ,CAAC;MACpD,OAAO,GAAG,CAAAA,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE0G,YAAY,MAAI1G,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE2G,UAAU,KAAI9L,QAAQ,CAACmF,QAAQ,IAAInF,QAAQ,CAAC+L,MAAM,EAAE;IACpG,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAC,cAAc,GAAIC,YAAoB,IAAK;MACzC,IAAI,IAAI,CAACC,oBAAoB,KAAKD,YAAY,EAAE;QAC9C,IAAI,CAACC,oBAAoB,GAAGD,YAAY;QACxC,IAAI,IAAI,CAACzI,kBAAkB,EAAE;UAC3B,IAAI,CAACkC,cAAc,CAAC,EAAE,CAAC;QACzB;MACF;IACF,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAN,WAAW,GAAI6G,YAAoB,IAAK,IAAI,CAAC9P,KAAK,CAACgQ,QAAQ,CAACC,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACP,UAAU,KAAKG,YAAY,CAAC;IA8FtG;AACF;AACA;AACA;AACA;AACA;AACA;IANE,KAOAK,IAAI,GAAG,CAAC1M,UAAkB,EAAEuF,QAAgB,EAAE4G,MAAc,EAAE3M,MAAgB,KAAK;MACjF,MAAMmN,eAAe,GAAG,IAAI,CAACjP,SAAS,CAACsC,UAAU,CAAC;MAClD,MAAM4M,cAAc,GAAGT,MAAM,GAAG,CAAC,GAAG,IAAI,CAACU,cAAc,CAAC,IAAI,CAACrH,WAAW,CAACD,QAAQ,CAAC,CAAC,GAAG,IAAI,CAACuH,mBAAmB,CAACvH,QAAQ,EAAE4G,MAAM,CAAC;MAChI,IAAIQ,eAAe,IAAIC,cAAc,EAAE;QACrC,MAAMlE,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;UACjCjL,SAAS,EAAE,CAACiP,eAAe,EAAEC,cAAc,CAAC;UAC5CrN,aAAa,EAAE3E,kBAAkB,CAAC0G,uBAAuB,CAAC;QAC5D,CAAC,CAAC;QACF,MAAM2D,mBAAoD,GAAG;UAAE,GAAG,IAAI,CAACA;QAAoB,CAAC;QAC5FzF,MAAM,CAACM,OAAO,CAAC,CAACG,UAAU,EAAEkL,CAAC,KAAK;UAChCyB,cAAc,CAACpN,MAAM,CAACS,UAAU,CAAC,GAAG;YAAE,GAAG0M,eAAe,CAACnN,MAAM,CAACS,UAAU;UAAE,CAAC;UAC7E,OAAO0M,eAAe,CAACnN,MAAM,CAACS,UAAU,CAAC;UACzCrF,kBAAkB,CAACmS,0BAA0B,CAAC/M,UAAU,EAAE4M,cAAc,CAACtM,EAAE,EAAEL,UAAU,CAAC;UACxF,MAAM+M,YAAY,GAAG7B,CAAC,KAAK,CAAC,IAAKA,CAAC,GAAG,CAAC,IAAI3L,MAAM,CAAC2L,CAAC,CAAC,GAAG3L,MAAM,CAAC2L,CAAC,GAAG,CAAC,CAAC,GAAG,CAAE;UACxE,MAAM8B,UAAU,GAAG9B,CAAC,KAAK3L,MAAM,CAACsC,MAAM,GAAG,CAAC,IAAKqJ,CAAC,GAAG3L,MAAM,CAACsC,MAAM,GAAG,CAAC,IAAItC,MAAM,CAAC2L,CAAC,GAAG,CAAC,CAAC,GAAG3L,MAAM,CAAC2L,CAAC,CAAC,GAAG,CAAE;UACtG,IAAI6B,YAAY,IAAIC,UAAU,EAAE;YAC9B,IAAID,YAAY,IAAIL,eAAe,CAACnN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,EAAE;cAC1D0M,eAAe,CAACnN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,CAACiK,UAAU,GAAG,IAAI;YAC1D;YACA,IAAI+C,UAAU,IAAIN,eAAe,CAACnN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,EAAE;cACxD0M,eAAe,CAACnN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,CAACiK,UAAU,GAAG,IAAI;YAC1D;YACA0C,cAAc,CAACpN,MAAM,CAACS,UAAU,CAAC,CAACiK,UAAU,GAAG,IAAI;YACnD,IAAI8C,YAAY,IAAIJ,cAAc,CAACpN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,EAAE;cACzD2M,cAAc,CAACpN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,CAACiK,UAAU,GAAG,IAAI;YACzD;YACA,IAAI+C,UAAU,IAAIL,cAAc,CAACpN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,EAAE;cACvD2M,cAAc,CAACpN,MAAM,CAACS,UAAU,GAAG,CAAC,CAAC,CAACiK,UAAU,GAAG,IAAI;YACzD;UACF;UACA;UACA,MAAM8B,KAAK,GAAG,IAAI,CAACrO,cAAc,CAACsC,UAAU,CAAC,CAACqL,OAAO,CAACtL,UAAU,CAAC;UACjE,IAAIgM,KAAK,IAAI,CAAC,EAAE;YACd,IAAI,CAACrO,cAAc,CAACsC,UAAU,CAAC,CAACsL,MAAM,CAACS,KAAK,EAAE,CAAC,CAAC;UAClD;UACA,IAAI,IAAI,CAACrO,cAAc,CAACsC,UAAU,CAAC,CAACqL,OAAO,CAACsB,cAAc,CAACtM,EAAE,CAAC,GAAG,CAAC,EAAE;YAClE,IAAI,CAAC3C,cAAc,CAACsC,UAAU,CAAC,CAAC+B,IAAI,CAAC4K,cAAc,CAACtM,EAAE,CAAC;UACzD;UACA,IAAIL,UAAU,KAAK,IAAI,CAACuE,YAAY,EAAE;YACpC;YACA,MAAM0I,WAAW,GAAG,IAAI,CAACpC,kBAAkB,CAAC8B,cAAc,CAACtM,EAAE,CAAC;YAC9D,IAAI4M,WAAW,EAAE;cACf,IAAI,CAAC1B,WAAW,CAAC0B,WAAW,CAAC;cAC7B,OAAO,IAAI,CAACpP,gBAAgB,CAACoP,WAAW,CAAChJ,GAAG,CAAC;YAC/C;YACA,MAAM3D,KAAK,GAAG,IAAI,CAACuK,kBAAkB,CAAC9K,UAAU,CAAC;YACjD,IAAIO,KAAK,EAAE;cACT,IAAI,IAAI,CAACyD,SAAS,EAAE;gBAClBzD,KAAK,CAAC4D,KAAK,GAAG,IAAI,CAACC,gBAAgB,CAACwI,cAAc,CAAC;cACrD;cACA,MAAMO,cAAc,GAAG,IAAI,CAAC3H,WAAW,CAACD,QAAQ,CAAC;cACjD,IAAI4H,cAAc,EAAE;gBAClB5M,KAAK,CAACmG,KAAK,GAAGC,QAAQ,CAACwG,cAAc,CAACzH,aAAa,CAACkB,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;cACpE;cACA,IAAI,CAAC9I,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC,GAAG0I,cAAc,CAACtM,EAAE;YACtD;YACA;YACA2E,mBAAmB,CAAC2H,cAAc,CAACtM,EAAE,CAAC,GAAG,IAAI;YAC7C,OAAO2E,mBAAmB,CAACjF,UAAU,CAAC;UACxC;QACF,CAAC,CAAC;QACF,IAAI,CAACiF,mBAAmB,GAAGA,mBAAmB;QAC9C,IAAI,CAAC4E,mBAAmB,CAAC+C,cAAc,CAACtM,EAAE,CAAC;QAC3C,IAAIJ,MAAM,CAACyK,IAAI,CAACgC,eAAe,CAACnN,MAAM,CAAC,CAACsC,MAAM,IAAI,CAAC,EAAE;UACnD;UACA,OAAO,IAAI,CAACpE,SAAS,CAACsC,UAAU,CAAC;UACjC,OAAO,IAAI,CAACX,oBAAoB,CAACsN,eAAe,CAACpH,QAAQ,CAAC,CAACvF,UAAU,CAAC;QACxE;QACAtF,SAAS,CAACiH,IAAI,CAAC+G,OAAO,EAAE;UACtBhL,SAAS,EAAE,CAACiP,eAAe,EAAEC,cAAc,CAAC;UAC5CrN,aAAa,EAAE3E,kBAAkB,CAAC0G,uBAAuB,CAAC;QAC5D,CAAC,CAAC;MACJ;MACA,IAAI,CAACyD,iBAAiB,CAAC,KAAK,CAAC;MAC7B,IAAI,CAACiB,YAAY,CAAC,CAAC;IACrB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;IANE,KAOAoH,aAAa,GAAG,CAACjN,MAAW,EAAEkN,QAAiB,EAAErN,UAAU,GAAG,IAAI,CAAC4D,kBAAkB,EAAEvD,KAAK,GAAG,IAAI,CAACmE,YAAY,KAAK;MACnH,MAAMpE,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAACsC,UAAU,CAAC;MAC3C,IAAII,QAAQ,EAAE;QACZ,MAAM;UAAEZ;QAAO,CAAC,GAAGY,QAAQ;QAC3B,MAAMkN,SAAS,GAAGpN,MAAM,CAACyK,IAAI,CAACnL,MAAM,CAAC,CAAC6B,GAAG,CAAEkM,CAAC,IAAK5G,QAAQ,CAAC4G,CAAC,EAAE,EAAE,CAAC,CAAC;QACjE,MAAMvB,KAAK,GAAGsB,SAAS,CAAChC,OAAO,CAACjL,KAAK,CAAC;QACtC,IAAI2L,KAAK,IAAI,CAAC,EAAE;UACd,MAAMtD,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;YACjCjL,SAAS,EAAE,CAAC0C,QAAQ;UACtB,CAAC,CAAC;UACF,MAAM;YAAEiK,KAAK;YAAEmD,OAAO;YAAE,GAAGC;UAAW,CAAC,GAAGtN,MAAM;UAChDmN,SAAS,CAACI,KAAK,CAAC1B,KAAK,EAAEqB,QAAQ,GAAGC,SAAS,CAACxL,MAAM,GAAGkK,KAAK,GAAG,CAAC,CAAC,CAAClM,OAAO,CAAEyN,CAAC,IAAK;YAC7E,IAAI5S,aAAa,CAACgT,WAAW,IAAInO,MAAM,CAAC+N,CAAC,CAAC,CAAClD,KAAK,EAAE;cAChD7K,MAAM,CAAC+N,CAAC,CAAC,CAAClD,KAAK,GAAGA,KAAK;cACvB7K,MAAM,CAAC+N,CAAC,CAAC,CAACC,OAAO,GAAGA,OAAO;cAC3B,IAAI7S,aAAa,CAACgT,WAAW,EAAE;gBAC7BnO,MAAM,CAAC+N,CAAC,CAAC,CAACE,UAAU,GAAG;kBAAE,GAAGA;gBAAW,CAAC;cAC1C;cACA,IAAIF,CAAC,KAAK,IAAI,CAAC/I,YAAY,EAAE;gBAC3B,IAAI,CAACoJ,iBAAiB,GAAG;kBAAE,GAAGzN;gBAAO,CAAC;cACxC;YACF;UACF,CAAC,CAAC;UACFzF,SAAS,CAACiH,IAAI,CAAC+G,OAAO,EAAE;YACtBhL,SAAS,EAAE,CAAC0C,QAAQ;UACtB,CAAC,CAAC;UACF,IAAI,CAAC4F,YAAY,CAAC,CAAC;QACrB;MACF;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGA6H,oBAAoB,GAAG,MAAM;MAC3B,IAAI,CAACD,iBAAiB,GAAG,IAAI;MAC7B,MAAMxN,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAAC,IAAI,CAACkG,kBAAkB,CAAC;MACxD,IAAIxD,QAAQ,EAAE;QACZ,MAAM;UAAEZ;QAAO,CAAC,GAAGY,QAAQ;QAC3B,MAAM0N,gBAAgB,GAAGtO,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC;QAClD,IAAIsJ,gBAAgB,KAAKnT,aAAa,CAACgT,WAAW,IAAIG,gBAAgB,CAACzD,KAAK,CAAC,EAAE;UAC7E,IAAI,CAACuD,iBAAiB,GAAG;YACvB,IAAIjT,aAAa,CAACgT,WAAW,IAAIG,gBAAgB,CAACL,UAAU,CAAC;YAC7D;YACApD,KAAK,EAAEyD,gBAAgB,CAACzD,KAAK;YAC7BmD,OAAO,EAAEM,gBAAgB,CAACN;UAC5B,CAAC;QACH;MACF;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGAlD,kBAAkB,GAAG,MAAO/J,KAAgB,IAAK;MAC/C,IAAI;QACF,MAAMwN,GAAG,GAAG,MAAMvS,WAAW,CAAC,IAAI,CAACgE,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,EAAEjE,KAAK,CAAC;QACpE,IAAI,CAACyN,eAAe,GAAGD,GAAG;MAC5B,CAAC,CAAC,OAAOzL,CAAC,EAAE;QACV,IAAI,CAAC0L,eAAe,GAAG,EAAE;MAC3B;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKAC,UAAU,GAAG,CAAC7I,IAAe,EAAE8I,IAAe,KAAK;MAAA,IAAAC,eAAA,EAAAC,eAAA;MACjD,MAAMC,uBAAuB,GAAG,IAAI,CAACzK,kBAAkB;MACvD,MAAMqB,mBAAmB,GAAG;QAAE,GAAG,IAAI,CAACA;MAAoB,CAAC;MAC3D,MAAM5F,oBAAoB,GAAG;QAAE,GAAG,IAAI,CAACA;MAAqB,CAAC;MAE7D,MAAMiP,UAAU,GAAG3T,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACkO,IAAI;MAC3D,CAAAiF,eAAA,GAAAD,IAAI,CAACxQ,SAAS,cAAAyQ,eAAA,uBAAdA,eAAA,CAAgBrO,OAAO,CAAEM,QAAQ,IAAK;QACpC,IAAIA,QAAQ,EAAE;UACZ;UACA,OAAO,IAAI,CAAC1C,SAAS,CAAC0C,QAAQ,CAACE,EAAE,CAAC;UAClCJ,MAAM,CAACC,MAAM,CAACC,QAAQ,CAACZ,MAAM,CAAC,CAACM,OAAO,CAAC,CAAC;YAAEG;UAAW,CAAC,KAAK;YACzD,MAAM+L,KAAK,GAAG,IAAI,CAACrO,cAAc,CAACsC,UAAU,CAAC,CAACsO,SAAS,CAAEpD,CAAC,IAAKA,CAAC,KAAK/K,QAAQ,CAACE,EAAE,CAAC;YACjF,IAAI0L,KAAK,IAAI,CAAC,EAAE;cACd,IAAI,CAACrO,cAAc,CAACsC,UAAU,CAAC,CAACsL,MAAM,CAACS,KAAK,EAAE,CAAC,CAAC;YAClD;UACF,CAAC,CAAC;UACF,OAAO/G,mBAAmB,CAAC7E,QAAQ,CAACE,EAAE,CAAC;UACvC,OAAOjB,oBAAoB,CAACe,QAAQ,CAACmF,QAAQ,CAAC,CAACnF,QAAQ,CAACE,EAAE,CAAC;UAC3D,IAAI,CAACgO,UAAU,EAAE;YACf;YACA,MAAM/N,KAAK,GAAG,IAAI,CAACuK,kBAAkB,CAAC1K,QAAQ,CAACE,EAAE,CAAC;YAClD,IAAIC,KAAK,EAAE;cACT,IAAI,CAACiL,WAAW,CAACjL,KAAK,CAAC;cACvB,OAAO,IAAI,CAACzC,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC;YACzC;UACF;UACA;UACA,IAAImK,uBAAuB,KAAKjO,QAAQ,CAACE,EAAE,EAAE;YAC3C,IAAI,CAACuJ,mBAAmB,CAAC,EAAE,CAAC;UAC9B;QACF;MACF,CAAC,CAAC;MACF,CAAAuE,eAAA,GAAAhJ,IAAI,CAAC1H,SAAS,cAAA0Q,eAAA,uBAAdA,eAAA,CAAgBtO,OAAO,CAAEM,QAAQ,IAAK;QACpC,IAAIA,QAAQ,IAAIA,QAAQ,CAACZ,MAAM,IAAIU,MAAM,CAACyK,IAAI,CAACvK,QAAQ,CAACZ,MAAM,CAAC,CAACsC,MAAM,GAAG,CAAC,EAAE;UAC1E,IAAI,CAACpE,SAAS,CAAC0C,QAAQ,CAACE,EAAE,CAAC,GAAGF,QAAQ;UACtCF,MAAM,CAACC,MAAM,CAACC,QAAQ,CAACZ,MAAM,CAAC,CAACM,OAAO,CAAC,CAAC;YAAEG;UAAW,CAAC,KAAK;YACzD,IAAI,IAAI,CAACtC,cAAc,CAACsC,UAAU,CAAC,CAACsO,SAAS,CAAEpD,CAAC,IAAKA,CAAC,KAAK/K,QAAQ,CAACE,EAAE,CAAC,GAAG,CAAC,EAAE;cAC3E,IAAI,CAAC3C,cAAc,CAACsC,UAAU,CAAC,CAAC+B,IAAI,CAAC5B,QAAQ,CAACE,EAAE,CAAC;YACnD;UACF,CAAC,CAAC;UACF2E,mBAAmB,CAAC7E,QAAQ,CAACE,EAAE,CAAC,GAAGF,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,KAAKV,SAAS;UACnF,IAAI,CAACzE,oBAAoB,CAACe,QAAQ,CAACmF,QAAQ,CAAC,EAAE;YAC5ClG,oBAAoB,CAACe,QAAQ,CAACmF,QAAQ,CAAC,GAAG,CAAC,CAAC;UAC9C;UACAlG,oBAAoB,CAACe,QAAQ,CAACmF,QAAQ,CAAC,CAACnF,QAAQ,CAACE,EAAE,CAAC,GAAGF,QAAQ,CAAC+L,MAAM;UACtE,MAAMqC,aAAa,GAAGpO,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC;UACxD,IAAIgK,aAAa,KAAK1K,SAAS,EAAE;YAC/B;YACA,MAAMyB,QAAQ,GAAG,IAAI,CAACC,WAAW,CAACpF,QAAQ,CAACmF,QAAQ,CAAC;YACpD,IAAIA,QAAQ,IAAI,CAAC+I,UAAU,EAAE;cAC3B,MAAMG,QAAQ,GAAG,IAAI,CAAChJ,WAAW,CAACF,QAAQ,CAACG,aAAa,EAAE,IAAI,CAACtB,gBAAgB,CAAChE,QAAQ,CAAC,EAAEoO,aAAa,CAAC7I,SAAS,EAAE6I,aAAa,CAACjO,KAAK,CAAC;cACxI,IAAI,CAACsF,iBAAiB,CAAC4I,QAAQ,CAAC;cAChC,IAAI,CAAC5Q,MAAM,CAACmE,IAAI,CAACyM,QAAQ,CAAC;cAC1B,IAAI,CAAC3Q,gBAAgB,CAAC2Q,QAAQ,CAACvK,GAAG,CAAC,GAAG9D,QAAQ,CAACE,EAAE;cACjD,IAAI+N,uBAAuB,KAAKjO,QAAQ,CAACE,EAAE,EAAE;gBAC3C,IAAI,CAACoJ,WAAW,CAAC+E,QAAQ,CAAC;cAC5B;YACF;UACF;UACA,IAAIJ,uBAAuB,KAAKjO,QAAQ,CAACE,EAAE,EAAE;YAC3C,IAAI,CAACuJ,mBAAmB,CAACzJ,QAAQ,CAACE,EAAE,CAAC;UACvC;QACF;MACF,CAAC,CAAC;MACF,IAAI,CAAC2E,mBAAmB,GAAGA,mBAAmB;MAC9C,IAAI,CAAC5F,oBAAoB,GAAGA,oBAAoB;MAEhD,IAAI+F,IAAI,CAAC7F,aAAa,EAAE;QACtB3E,kBAAkB,CAAC0E,cAAc,CAAC8F,IAAI,CAAC7F,aAAa,EAAE,IAAI,CAAC7B,SAAS,CAAC;MACvE;MACA,IAAIwQ,IAAI,CAAC1O,MAAM,IAAI4F,IAAI,CAAC5F,MAAM,EAAE;QAAA,IAAAkP,YAAA,EAAAC,YAAA;QAC9B,MAAMC,mBAAmB,GAAGnW,IAAI,CAACqC,WAAW,CAAC2S,UAAU,CAAC;QACxD,CAAAiB,YAAA,GAAAR,IAAI,CAAC1O,MAAM,cAAAkP,YAAA,uBAAXA,YAAA,CAAa5O,OAAO,CAAEO,KAAK,IAAK;UAC9B;UACA,OAAOuO,mBAAmB,CAACvO,KAAK,CAACJ,UAAU,CAAC;QAC9C,CAAC,CAAC;QACF,CAAA0O,YAAA,GAAAvJ,IAAI,CAAC5F,MAAM,cAAAmP,YAAA,uBAAXA,YAAA,CAAa7O,OAAO,CAAEO,KAAK,IAAK;UAC9B;UACAuO,mBAAmB,CAACvO,KAAK,CAACJ,UAAU,CAAC,GAAGI,KAAK;QAC/C,CAAC,CAAC;QACFvF,WAAW,CAAC2S,UAAU,GAAGmB,mBAAmB;MAC9C;MACA,IAAIxJ,IAAI,CAACxF,OAAO,EAAE;QAChB/E,YAAY,CAACyE,cAAc,CAAC8F,IAAI,CAACxF,OAAO,CAAC;MAC3C;MAEA,IAAI0O,UAAU,EAAE;QAAA,IAAAO,sBAAA;QACd,CAAAA,sBAAA,OAAI,CAACrQ,QAAQ,CAACqC,OAAO,cAAAgO,sBAAA,uBAArBA,sBAAA,CAAuB7F,MAAM,CAAC,CAAC;MACjC;MAEA,IAAI,CAAChD,YAAY,CAAC,CAAC;IACrB,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIA8I,WAAW,GAAIpK,QAAkB,IAAK;MACpC,IAAI/J,aAAa,CAAC+J,QAAQ,KAAKA,QAAQ,EAAE;QACvC/J,aAAa,CAAC+J,QAAQ,GAAGA,QAAQ;QACjC,IAAI,CAACI,WAAW,CAAC,CAAC;MACpB;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKAiK,uBAAuB,GAAG,CAACC,UAA0B,EAAErO,IAAI,GAAG,OAAO,KAAK;MACxE,IAAIA,IAAI,KAAK,OAAO,EAAE;QACpBhG,aAAa,CAACsN,yBAAyB,GAAG+G,UAAU;QACpD,IAAI,CAACnR,MAAM,CAACiC,OAAO,CAAES,KAAK,IAAK;UAC7BA,KAAK,CAACyH,YAAY,GAAGgH,UAAqC;QAC5D,CAAC,CAAC;MACJ,CAAC,MAAM;QACLrU,aAAa,CAACsU,oBAAoB,GAAGD,UAAU;MACjD;MACA,IAAI,CAAChJ,YAAY,CAAC,CAAC;IACrB,CAAC;IAED;AACF;AACA;IAFE,KAGAkJ,YAAY,GAAG,CAAC;MAAEC,QAAQ;MAAExO,IAAI;MAAE8M;IAAuB,CAAC,KAAK;MAC7D,IAAI,IAAI,CAACtK,QAAQ,EAAE;QACjB;MACF;MACA,IAAIgM,QAAQ,KAAK,OAAO,EAAE;QACxB;QACA,MAAMC,yBAAyB,GAAI7O,KAAuB,IAAK;UAC7D,IAAIA,KAAK,YAAY9G,OAAO,IAAI8G,KAAK,YAAY7G,IAAI,EAAE;YACrD,MAAM2V,cAAc,GAAG9O,KAAK,CAAC+O,iBAAiB,CAAC,CAAC;YAChD,MAAMC,UAA4C,GAAG,EAAE;YACvDF,cAAc,CAACvP,OAAO,CAAC,CAAC;cAAEkM,KAAK;cAAE7D;YAAM,CAAC,KAAK;cAC3C,MAAMqH,QAAQ,GAAG7O,IAAI,KAAK,WAAW,GAAG;gBAAE,GAAG8M;cAAW,CAAC,GAAG;gBAAE,GAAGtF,KAAK,CAACqH,QAAQ;gBAAE,GAAG/B;cAAW,CAAC;cAChG8B,UAAU,CAACvN,IAAI,CAAC;gBAAEgK,KAAK;gBAAEwD;cAAS,CAAC,CAAC;YACtC,CAAC,CAAC;YACFjP,KAAK,CAACkP,iBAAiB,CAACF,UAAU,CAAC;UACrC;QACF,CAAC;QACD,IAAI5U,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;UAC/C,IAAI,IAAI,CAACzF,aAAa,EAAE;YACtBoR,yBAAyB,CAAC,IAAI,CAACpR,aAAa,CAAC;UAC/C;QACF,CAAC,MAAM;UACL,MAAM0R,gBAAgB,GAAG,IAAI,CAAChS,SAAS,CAAC,IAAI,CAACkG,kBAAkB,CAAC;UAChE,IAAI8L,gBAAgB,IAAIA,gBAAgB,CAAClQ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,EAAE;YAAA,IAAAmL,sBAAA;YAClE,MAAM9R,MAAM,IAAA8R,sBAAA,GAAG,IAAI,CAACnR,QAAQ,CAACqC,OAAO,cAAA8O,sBAAA,uBAArBA,sBAAA,CAAuBC,gBAAgB,CAAC,IAAI,CAACpL,YAAY,CAAC;YACzE3G,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEiC,OAAO,CAAES,KAAK,IAAK;cACzB6O,yBAAyB,CAAC7O,KAAK,CAAC;YAClC,CAAC,CAAC;UACJ;QACF;MACF;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGAsP,qBAAqB,GAAG,MAAM;MAC5B,IAAI,CAAC,IAAI,CAAC1M,QAAQ,IAAI,IAAI,CAACnF,aAAa,EAAE;QACxC,MAAMgC,UAAU,GAAG,IAAI,CAAClC,gBAAgB,CAAC,IAAI,CAACE,aAAa,CAACkG,GAAG,CAAC;QAChE,MAAM9D,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAACsC,UAAU,CAAC;QAC3C,IAAI,IAAI,CAAChC,aAAa,YAAYrE,SAAS,EAAE;UAC3C,MAAM+O,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;YACjCjL,SAAS,EAAE,CAAC0C,QAAQ;UACtB,CAAC,CAAC;UACF,MAAM0P,MAAM,GAAG,IAAI,CAAC9R,aAAa,CAAC+R,SAAS,CAAC,CAAC;UAC7C,MAAMxP,KAAK,GAAG,IAAI,CAACkF,WAAW,CAAC,IAAI,CAAC2C,gBAAgB,CAAC1C,aAAa,EAAE,IAAI,CAACtB,gBAAgB,CAAChE,QAAQ,CAAC,EAAE9G,SAAS,CAAC0W,OAAO,EAAE;YAAEF;UAAO,CAAC,CAAC;UACnI1P,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,GAAG;YACnC,GAAGpE,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC;YACrCmB,SAAS,EAAErM,SAAS,CAAC0W,OAAO;YAC5BzP,KAAK,EAAEA,KAAK,CAAC0P,OAAO,CAAC,CAAC;YACtB/F,UAAU,EAAE;UACd,CAAC;UACD,IAAI9J,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,GAAG,CAAC,CAAC,EAAE;YAC1CpE,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,GAAG,CAAC,CAAC,CAAC0F,UAAU,GAAG,IAAI;UAC1D;UACA,IAAI9J,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,GAAG,CAAC,CAAC,EAAE;YAC1CpE,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,GAAG,CAAC,CAAC,CAAC0F,UAAU,GAAG,IAAI;UAC1D;UACAxP,SAAS,CAACiH,IAAI,CAAC+G,OAAO,EAAE;YACtBhL,SAAS,EAAE,CAAC0C,QAAQ;UACtB,CAAC,CAAC;UAEF,IAAI,CAACyF,iBAAiB,CAACtF,KAAK,CAAC;UAC7B,IAAI,CAAC1C,MAAM,CAAC0N,MAAM,CAAC,IAAI,CAAC1N,MAAM,CAACyN,OAAO,CAAC,IAAI,CAACtN,aAAa,CAAC,EAAE,CAAC,EAAEuC,KAAK,CAAC;UACrE,OAAO,IAAI,CAACzC,gBAAgB,CAAC,IAAI,CAACE,aAAa,CAACkG,GAAG,CAAC;UACpD,IAAI,CAACpG,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC,GAAGlE,UAAU;UAC7C,IAAI,CAAChC,aAAa,CAAC2F,OAAO,CAAC,CAAC;UAC5B,IAAI,CAAC3F,aAAa,GAAG,IAAI;UACzB,IAAI,CAAC0L,WAAW,CAACnJ,KAAK,CAAC;UACvB,IAAI,CAAC4J,sBAAsB,GAAGpR,SAAS,CAACqH,QAAQ,CAACZ,MAAM,EAAE,YAAY,CAAC;UACtEnH,OAAO,CAAC+J,OAAO,CAAC,uBAAuB,CAAC;QAC1C;MACF;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGAnB,iBAAiB,GAAG,YAAY;MAC9B,IAAI,IAAI,CAACrC,YAAY,CAACiC,OAAO,EAAE;QAC7B,MAAM;UAAEqP,cAAc;UAAEC;QAAkB,CAAC,GAAG,MAAM,IAAI,CAACvR,YAAY,CAACiC,OAAO,CAACuP,UAAU,CAAC,CAAC;QAC1F,OAAO,CAACF,cAAc,IAAIC,iBAAiB,CAACrO,MAAM,IAAI,CAAC,CAAC,CAAC;MAC3D;MACA,OAAO,IAAI;IACb,CAAC;IAED;AACF;AACA;IAFE,KAGAiE,kBAAkB,GAAG,MAAM;MACzB,IAAI,CAAClI,MAAM,CAACiC,OAAO,CAAES,KAAK,IAAK;QAC7B,IAAI,CAAC5F,aAAa,CAAC0V,UAAU,IAAI,CAAC,IAAI,CAACzM,kBAAkB,IAAI,IAAI,CAAC9F,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC,KAAK,IAAI,CAACN,kBAAkB,EAAE;UACzHrD,KAAK,CAAC+P,OAAO,GAAG,IAAI;QACtB,CAAC,MAAM;UACL/P,KAAK,CAAC+P,OAAO,GAAG,KAAK;QACvB;MACF,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;IAFE,KAGAC,KAAK,GAAG,MAAM;MACZ,MAAM7H,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;QACjCjL,SAAS,EAAEwC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACzC,SAAS,CAAC;QACxC6B,aAAa,EAAE3E,kBAAkB,CAAC0G,uBAAuB,CAAC,CAAC;QAC3D9B,MAAM,EAAE1E,WAAW,CAACyG,gBAAgB,CAAC,CAAC;QACtC3B,OAAO,EAAE/E,YAAY,CAACgF,iBAAiB,CAAC;MAC1C,CAAC,CAAC;;MAEF;MACA,IAAI,CAAC+D,kBAAkB,GAAG,EAAE;MAC5B,IAAI,CAACuG,sBAAsB,GAAG,CAAC,CAAC;MAChC,IAAI,CAACyD,iBAAiB,GAAG,IAAI;MAC7B,IAAI,CAACI,eAAe,GAAG,EAAE;MACzB;MACA,IAAI,CAAClJ,WAAW,CAAC,CAAC;MAClB;MACA,IAAI,CAACpH,SAAS,GAAG,CAAC,CAAC;MACnB,IAAI,CAACC,cAAc,GAAG,IAAI,CAAC6B,MAAM,CAAC6B,GAAG,CAAC,MAAM,EAAE,CAAC;MAC/C,IAAI,CAAChC,oBAAoB,GAAG,CAAC,CAAC;MAC9B,IAAI,CAAC2G,YAAY,CAAC,CAAC;;MAEnB;MACApL,kBAAkB,CAAC0E,cAAc,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;MACzC;MACAxE,WAAW,CAACwE,cAAc,CAAC,EAAE,CAAC;MAE9B5E,SAAS,CAACiH,IAAI,CAAC+G,OAAO,CAAC;MACvBrQ,OAAO,CAAC+J,OAAO,CAAC,kBAAkB,CAAC;IACrC,CAAC;IAED;AACF;AACA;IAFE,KAGAoO,kCAAkC,GAAG,MAAM;MACzC,IAAI7V,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;QAC/C;MACF;MACA,MAAMgN,WAAW,GAAGvQ,MAAM,CAACyK,IAAI,CAAC,IAAI,CAACtL,oBAAoB,CAAC,IAAI,CAACiN,oBAAoB,CAAC,IAAI,CAAC,CAAC,CAAC;MAC3F,MAAMoE,aAAa,GAAG,EAAE;MACxB,MAAMjO,aAAa,GAAG,EAAE;MACxB,KAAK,IAAI0I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsF,WAAW,CAAC3O,MAAM,EAAEqJ,CAAC,IAAI,CAAC,EAAE;QAC9C,MAAMnL,UAAU,GAAGyQ,WAAW,CAACtF,CAAC,CAAC;QACjC,MAAM/K,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAACsC,UAAU,CAAC;QAC3C,IAAI,CAACI,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,EAAE;UACvC,IAAIiG,SAAS,GAAGrP,gBAAgB,CAAC,IAAI,CAACoJ,YAAY,EAAEpE,QAAQ,CAACZ,MAAM,EAAE,IAAI,CAACgH,WAAW,CAAC;UACtF,IAAI,CAACiE,SAAS,EAAE;YACd,MAAMC,SAAS,GAAGxK,MAAM,CAACyK,IAAI,CAACvK,QAAQ,CAACZ,MAAM,CAAC,CAACoL,GAAG,CAAC,CAAC;YACpD,IAAIF,SAAS,EAAE;cACb,MAAM;gBAAE/E,SAAS;gBAAEpF;cAAM,CAAC,GAAGH,QAAQ,CAACZ,MAAM,CAACmH,QAAQ,CAAC+D,SAAS,EAAE,EAAE,CAAC,CAAC;cACrED,SAAS,GAAG;gBAAE9E,SAAS;gBAAEpF;cAAM,CAAC;YAClC;UACF;UACA,IAAIkK,SAAS,EAAE;YACbiG,aAAa,CAAC1O,IAAI,CAAClJ,SAAS,CAACsH,QAAQ,CAAC,CAAC;YACvC,MAAMG,KAAK,GAAG,IAAI,CAACkF,WAAW,CAC5B,IAAI,CAAC2C,gBAAgB,CAAC1C,aAAa,EACnC,IAAI,CAACtB,gBAAgB,CAAChE,QAAQ,CAAC,EAC/BqK,SAAS,CAAC9E,SAAS,EACnB8E,SAAS,CAAClK,KACZ,CAAC;YACD,IAAI,CAACqI,sBAAsB,CAACrI,KAAK,EAAEH,QAAQ,EAAE0D,SAAS,EAAE,IAAI,EAAE2G,SAAS,CAAC9E,SAAS,EAAE8E,SAAS,CAAClK,KAAK,CAAC;YACnG,IAAI,CAACsF,iBAAiB,CAACtF,KAAK,CAAC;YAC7BkC,aAAa,CAACT,IAAI,CAAClJ,SAAS,CAACsH,QAAQ,CAAC,CAAC;UACzC;QACF;MACF;MACA,IAAIsQ,aAAa,CAAC5O,MAAM,GAAG,CAAC,IAAIW,aAAa,CAACX,MAAM,GAAG,CAAC,EAAE;QACxD,MAAM4G,OAAO,GAAGhO,SAAS,CAACiO,QAAQ,CAAC;UAAEjL,SAAS,EAAEgT;QAAc,CAAC,CAAC;QAChEhW,SAAS,CAACiH,IAAI,CAAC+G,OAAO,EAAE;UAAEhL,SAAS,EAAE+E;QAAc,CAAC,CAAC;MACvD;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGAuD,YAAY,GAAG,MAAM;MAAA,IAAA2K,qBAAA;MACnB,CAAAA,qBAAA,OAAI,CAAClS,QAAQ,CAACoC,OAAO,cAAA8P,qBAAA,uBAArBA,qBAAA,CAAuBC,WAAW,CAAC,CAAC;IACtC,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKA/I,gBAAgB,GAAIgJ,IAAS,IAAK;MAChC,MAAMC,MAAkB,GAAG,EAAE;MAC7B,MAAM;QAAEC;MAAgB,CAAC,GAAGpW,aAAa;MACzCuF,MAAM,CAACyK,IAAI,CAACkG,IAAI,CAAC,CAAC/Q,OAAO,CAAEkR,GAAG,IAAK;QACjC,MAAM7M,KAAK,GAAG,EAAE;QAChB,IAAI4M,eAAe,CAACE,QAAQ,CAAChW,SAAS,CAACiW,cAAc,CAAC,EAAE;UACtD/M,KAAK,CAACnC,IAAI,CAAC,GAAGgP,GAAG,EAAE,CAAC;QACtB;QACA,IAAID,eAAe,CAACE,QAAQ,CAAChW,SAAS,CAACkW,gBAAgB,CAAC,EAAE;UACxDhN,KAAK,CAACnC,IAAI,CAAC,GAAG6O,IAAI,CAACG,GAAG,CAAC,EAAE,CAAC;QAC5B;QACA,IAAI7M,KAAK,CAACrC,MAAM,GAAG,CAAC,EAAE;UACpBgP,MAAM,CAAC9O,IAAI,CAACmC,KAAK,CAAC;QACpB;MACF,CAAC,CAAC;MACF,OAAO2M,MAAM,CAACzP,GAAG,CAAE+P,CAAC,IAAKA,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC,CAACA,IAAI,CAAC,IAAI,CAAC;IACnD,CAAC;IAn+CC3Y,cAAc,CAAC,IAAI,CAAC;EACtB;;EAEA;AACF;AACA;EACE,IAAc0P,gBAAgBA,CAAA,EAAG;IAC/B,MAAMkJ,eAAe,GAAG,IAAI,CAAC9L,WAAW,CAAC,IAAI,CAAC8G,oBAAoB,CAAC;IACnE,OAAOgF,eAAe,IAAI,IAAI,CAAC/U,KAAK,CAACgQ,QAAQ,CAAC,CAAC,CAAC;EAClD;;EAEA;AACF;AACA;EACE,IAAc1F,gBAAgBA,CAAA,EAAG;IAC/B,OAAOpL,kBAAkB,CAAC,IAAI,CAACqH,WAAW,CAAC,IAAIxJ,SAAS,CAACwO,SAAS;EACpE;;EAEA;AACF;AACA;EACE,IAAItB,WAAWA,CAAA,EAAG;IAAA,IAAA+K,WAAA,EAAAC,YAAA;IAChB,OAAO;MAAEC,IAAI,EAAE,CAAC;MAAEC,GAAG,EAAE,CAAC;MAAEC,KAAK,EAAE,EAAAJ,WAAA,OAAI,CAACpT,KAAK,cAAAoT,WAAA,uBAAVA,WAAA,CAAYK,KAAK,KAAI,CAAC;MAAEC,MAAM,EAAE,EAAAL,YAAA,OAAI,CAACrT,KAAK,cAAAqT,YAAA,uBAAVA,YAAA,CAAYM,MAAM,KAAI;IAAE,CAAC;EAC5F;;EAEA;AACF;AACA;EACE,IAAI3O,QAAQA,CAAA,EAAG;IACb,OAAOpH,oBAAoB,CAAC,IAAI,CAACQ,KAAK,CAAC2C,QAAQ,CAAC2C,QAAQ,CAAC,IAAI/F,SAAS,CAAC,IAAI,CAACS,KAAK,CAAC2C,QAAQ,CAAC2C,QAAQ,CAAC;EACtG;EAEA,MAAMkQ,iBAAiBA,CAAA,EAAG;IACxB,IAAI,CAACjT,oBAAoB,GAAGrE,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAAC8B,KAAK,CAACyV,OAAO,CAAC;;IAExE;IACApW,IAAI,CAACqW,SAAS,CAAC,IAAI,CAAC1V,KAAK,CAAC2V,MAAM,CAAC;;IAEjC;IACAvX,aAAa,CAACwX,WAAW,CAAC,IAAI,CAAC5V,KAAK,CAAC;IAErC,MAAMiD,MAAM,GAAG,MAAMtE,mBAAmB,CAAC,IAAI,CAACqB,KAAK,CAAC;IACpD,IAAI,CAACoB,cAAc,GAAG6B,MAAM,CAAC6B,GAAG,CAAC,MAAM,EAAE,CAAC;;IAE1C;IACAzG,kBAAkB,CAACwX,IAAI,CAAC5S,MAAM,CAACsC,MAAM,EAAE,IAAI,CAACvF,KAAK,CAACgD,aAAa,CAAC;IAChE;IACAzE,WAAW,CAACsX,IAAI,CAAC5S,MAAM,CAACsC,MAAM,CAAC;IAC/B;IACAjH,YAAY,CAACuX,IAAI,CAAC,IAAI,CAAC7V,KAAK,CAAC2C,QAAQ,CAAC2C,QAAQ,EAAE,IAAI,CAACtF,KAAK,CAAC8V,WAAW,CAAC;;IAEvE;IACA,IAAI;MACF,MAAM,IAAI,CAACtT,UAAU,CAACS,MAAM,CAACsC,MAAM,CAAC;IACtC,CAAC,CAAC,OAAOQ,CAAC,EAAE;MACVhK,YAAY,CAACiK,KAAK,CAAC;QAAElK,OAAO,EAAEuD,IAAI,CAACuF,SAAS,CAAC,4BAA4B,CAAC;QAAEmR,QAAQ,EAAE;MAAK,CAAC,CAAC;MAC7F;IACF;IACA;IACA,MAAM,IAAI,CAAC9Q,WAAW,CAAC,CAAC;;IAExB;IACA,IAAI,CAAChC,MAAM,GAAGA,MAAM;;IAEpB;IACA,IAAI,CAACpB,cAAc,GAAGvC,MAAM,CAAC2D,MAAM,CAAC;IACpC,IAAI,CAACpB,cAAc,CAACyG,OAAO,CAAC,IAAI,CAACL,YAAY,CAAC;;IAE9C;IACA,IAAI,CAACjI,KAAK,CAACgW,cAAc,CAAC,CAAC;EAC7B;EAEAC,oBAAoBA,CAAA,EAAG;IACrB,IAAI,CAAC1T,oBAAoB,CAAC,CAAC;EAC7B;EAoRA;AACF;AACA;EACEgG,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACjH,MAAM,CAACiC,OAAO,CAAES,KAAK,IAAK;MAC7BA,KAAK,CAACoD,OAAO,CAAC,CAAC;IACjB,CAAC,CAAC;IACF,IAAI,CAAC9F,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,gBAAgB,GAAG,CAAC,CAAC;IAC1B,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,IAAI,CAACC,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAAC0F,OAAO,CAAC,CAAC;MAC7B,IAAI,CAAC1F,cAAc,GAAG,IAAI;MAC1B,IAAI,CAACC,kBAAkB,GAAG,IAAI;IAChC;EACF;EAoDA;AACF;AACA;AACA;EACE2H,iBAAiBA,CAACtF,KAAuB,EAAE;IACzCA,KAAK,CAAC8H,EAAE,CAAC7O,WAAW,CAACiZ,QAAQ,EAAGC,CAAC,IAAK;MACpC,IAAIA,CAAC,KAAK,IAAI,CAACzU,cAAc,EAAE;QAC7B,IAAI,CAACyL,WAAW,CAACgJ,CAAC,EAAE,IAAI,CAAC;MAC3B;IACF,CAAC,CAAC;IACFnS,KAAK,CAAC8H,EAAE,CAAC7O,WAAW,CAACmZ,OAAO,EAAE,CAACD,CAAC,EAAE7B,IAAI,KAAK;MACzC,MAAM+B,WAAW,GAAGF,CAAC,KAAK,IAAI,CAACzU,cAAc,IAAI,IAAI,CAACC,kBAAkB;MACxE,MAAM8B,UAAU,GAAG4S,WAAW,GAAG,IAAI,CAAChP,kBAAkB,GAAG,IAAI,CAAC9F,gBAAgB,CAAC4U,CAAC,CAACxO,GAAG,CAAC;MACvF,IAAI,CAAC6F,sBAAsB,CAAC/J,UAAU,EAAE0S,CAAC,EAAE7B,IAAI,CAAC;MAChD,IAAI,CAAC7K,YAAY,CAAC,CAAC;IACrB,CAAC,CAAC;IACFzF,KAAK,CAAC8H,EAAE,CAAC7O,WAAW,CAACgP,OAAO,EAAE,MAAM;MAClC,IAAI,CAACyC,uBAAuB,CAAC,IAAI,CAACrH,kBAAkB,EAAE,CAAC,IAAI,CAACY,YAAY,CAAC,CAAC;IAC5E,CAAC,CAAC;IACFjE,KAAK,CAAC8H,EAAE,CAAC7O,WAAW,CAACqZ,QAAQ,EAAE,IAAI,CAAC7M,YAAY,CAAC;IACjDzF,KAAK,CAAC8H,EAAE,CAAC7O,WAAW,CAACsZ,QAAQ,EAAE,IAAI,CAAC9M,YAAY,CAAC;IACjDzF,KAAK,CAAC8H,EAAE,CAAC7O,WAAW,CAACuZ,YAAY,EAAGL,CAAC,IAAK;MACxC,IAAI,CAACM,cAAc,GAAGN,CAAC,CAACxO,GAAG;IAC7B,CAAC,CAAC;IACF3D,KAAK,CAAC8H,EAAE,CAAC7O,WAAW,CAACyZ,WAAW,EAAE,MAAM;MACtC,IAAI,CAACD,cAAc,GAAG,EAAE;IAC1B,CAAC,CAAC;EACJ;EA0FA;AACF;AACA;AACA;EACExH,WAAWA,CAACjL,KAAuB,EAAE;IACnC,IAAIA,KAAK,KAAK,IAAI,CAACvC,aAAa,EAAE;MAChC,IAAI,CAACA,aAAa,GAAG,IAAI;IAC3B;IACA,MAAMgO,KAAK,GAAG,IAAI,CAACnO,MAAM,CAACyN,OAAO,CAAC/K,KAAK,CAAC;IACxC,IAAI,CAAC1C,MAAM,CAAC0N,MAAM,CAACS,KAAK,EAAE,CAAC,CAAC;IAC5BzL,KAAK,CAACoD,OAAO,CAAC,CAAC;EACjB;EAkCA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEiF,sBAAsBA,CAACrI,KAAuB,EAAEH,QAAkB,EAAEiK,KAAe,EAAEH,UAAU,GAAG,IAAI,EAAEvE,SAAoB,GAAG,IAAI,CAACkB,gBAAgB,EAAEP,SAAqB,EAAE;IAAA,IAAA4M,sBAAA;IAC3K9S,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,GAAG;MACnCvE,UAAU,EAAE,IAAI,CAACuE,YAAY;MAC7B0F,UAAU;MACVvE,SAAS;MACTpF,KAAK,EAAE+F,SAAS,IAAI/F,KAAK,CAAC0P,OAAO,CAAC,CAAc;MAChD5F;IACF,CAAC;IACD,MAAM,CAAC8I,YAAY,CAAC,GAAG9X,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACmJ,YAAY,EAAEpE,QAAQ,CAACZ,MAAM,CAAC;IAC9E,MAAM,CAACqM,YAAY,CAAC,GAAGvQ,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACkJ,YAAY,EAAEpE,QAAQ,CAACZ,MAAM,CAAC;IAC9E,MAAM4T,QAAQ,GAAGD,YAAY,KAAKrP,SAAS,GAAGqP,YAAY,GAAGtH,YAAY;IACzE,IAAIuH,QAAQ,KAAKtP,SAAS,EAAE;MAC1B,IAAInJ,aAAa,CAACgT,WAAW,EAAE;QAC7BvN,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAACiJ,UAAU,GAAG3U,SAAS,CAACsH,QAAQ,CAACZ,MAAM,CAAC4T,QAAQ,CAAC,CAAC3F,UAAU,CAAC;MACjG;MACA,IAAIpD,KAAK,KAAKvG,SAAS,EAAE;QACvB1D,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAAC6F,KAAK,GAAGjK,QAAQ,CAACZ,MAAM,CAAC4T,QAAQ,CAAC,CAAC/I,KAAK;QAC1EjK,QAAQ,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,CAACgJ,OAAO,GAAGpN,QAAQ,CAACZ,MAAM,CAAC4T,QAAQ,CAAC,CAAC5F,OAAO;MAChF;IACF;IACA,IAAI,CAAC7P,cAAc,CAAC,IAAI,CAAC6G,YAAY,CAAC,CAACxC,IAAI,CAAC5B,QAAQ,CAACE,EAAE,CAAC;IACxD,IAAI,CAAC2E,mBAAmB,CAAC7E,QAAQ,CAACE,EAAE,CAAC,GAAG,IAAI;IAC5C,IAAI,CAAC6J,sBAAsB,CAAC,IAAI,CAAC3F,YAAY,CAAC,GAAG,IAAI;IACrD,IAAI7J,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;MAC/C;MACA,IAAI,CAAC5F,MAAM,CAACmE,IAAI,CAACzB,KAAK,CAAC;MACvB,IAAI,CAACzC,gBAAgB,CAACyC,KAAK,CAAC2D,GAAG,CAAC,GAAG9D,QAAQ,CAACE,EAAE;MAC9C,IAAI,CAACoJ,WAAW,CAACnJ,KAAK,CAAC;IACzB,CAAC,MAAM;MACL;MACA,IAAI,CAACsJ,mBAAmB,CAACzJ,QAAQ,CAACE,EAAE,CAAC;IACvC;IACA,IAAI,CAAC8J,WAAW,CAAChK,QAAQ,EAAE,IAAI,CAAC;IAChC,IAAI,CAAC4F,YAAY,CAAC,CAAC;IACnB,CAAAkN,sBAAA,OAAI,CAACxU,aAAa,CAACmC,OAAO,cAAAqS,sBAAA,uBAA1BA,sBAAA,CAA4BG,SAAS,CAAC,CAAC;EACzC;EAkKA;AACF;AACA;AACA;AACA;EACEvI,kBAAkBA,CAAC9K,UAAkB,EAAE;IACrC,MAAMsT,OAAO,GAAGpT,MAAM,CAACyK,IAAI,CAAC,IAAI,CAAC7M,gBAAgB,CAAC,CAAC0O,IAAI,CAAElM,EAAE,IAAK,IAAI,CAACxC,gBAAgB,CAACwC,EAAE,CAAC,KAAKN,UAAU,CAAC;IACzG,OAAO,IAAI,CAACnC,MAAM,CAAC2O,IAAI,CAAEjM,KAAK,IAAKA,KAAK,CAAC2D,GAAG,KAAKoP,OAAO,CAAC;EAC3D;;EAEA;AACF;AACA;EACE7K,kBAAkBA,CAAA,EAAG;IACnB,IAAI,IAAI,CAAC7E,kBAAkB,EAAE;MAC3B,MAAMxD,QAAQ,GAAG,IAAI,CAAC1C,SAAS,CAAC,IAAI,CAACkG,kBAAkB,CAAC;MACxD,MAAM;QAAEpE;MAAO,CAAC,GAAGY,QAAQ;MAC3B,IAAI,CAACZ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,EAAE;QAC9B;QACA,OAAOpE,QAAQ;MACjB;IACF;IACA;IACA,OAAO,IAAI,CAACyM,cAAc,CAAC,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,mBAAmBA,CAACT,YAAoB,EAAEF,MAAc,EAAE;IACxD,MAAMoH,iBAAiB,GAAG,IAAI,CAAClU,oBAAoB,CAACgN,YAAY,CAAC;IACjE,MAAMrM,UAAU,GAAGE,MAAM,CAACyK,IAAI,CAAC4I,iBAAiB,CAAC,CAAC/G,IAAI,CAAElM,EAAE,IAAKiT,iBAAiB,CAACjT,EAAE,CAAC,KAAK6L,MAAM,CAAC;IAChG,OAAOnM,UAAU,GAAG,IAAI,CAACtC,SAAS,CAACsC,UAAU,CAAC,GAAG8D,SAAS;EAC5D;;EAEA;AACF;AACA;EACE+I,cAAcA,CAACtH,QAAkB,GAAG,IAAI,CAAC6C,gBAAgB,EAAE;IACzD,MAAM;MAAE8D;IAAW,CAAC,GAAG3G,QAAQ;IAC/B,MAAMnF,QAAkB,GAAG;MACzBE,EAAE,EAAEzH,MAAM,CAAC,CAAC;MACZ0M,QAAQ,EAAE2G,UAAU;MACpBC,MAAM,EAAE,IAAI,CAACqH,qBAAqB,CAACjO,QAAQ,CAAC;MAC5C/F,MAAM,EAAE,CAAC;IACX,CAAC;IACD;IACA,IAAI,CAAC9B,SAAS,CAAC0C,QAAQ,CAACE,EAAE,CAAC,GAAGF,QAAQ;IACtC;IACA,IAAI,CAAC,IAAI,CAACf,oBAAoB,CAAC6M,UAAU,CAAC,EAAE;MAC1C,IAAI,CAAC7M,oBAAoB,CAAC6M,UAAU,CAAC,GAAG,CAAC,CAAC;IAC5C;IACA,IAAI,CAAC7M,oBAAoB,CAAC6M,UAAU,CAAC,CAAC9L,QAAQ,CAACE,EAAE,CAAC,GAAGF,QAAQ,CAAC+L,MAAM;IACpE,OAAO/L,QAAQ;EACjB;;EAEA;AACF;AACA;AACA;AACA;EACEyJ,mBAAmBA,CAAC7J,UAAkB,EAAE2J,QAAQ,GAAG,KAAK,EAAE;IAAA,IAAA8J,qBAAA,EAAAC,sBAAA;IACxD,IAAI,IAAI,CAAC9P,kBAAkB,KAAK5D,UAAU,EAAE;MAC1C,IAAI,CAAC4D,kBAAkB,GAAG5D,UAAU;MACpC,MAAM0P,gBAAgB,GAAG,IAAI,CAAChS,SAAS,CAACsC,UAAU,CAAC;MACnD,IAAI,CAACmK,sBAAsB,GAAGuF,gBAAgB,GAAG3W,SAAS,CAAC2W,gBAAgB,CAAClQ,MAAM,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;MACtG;MACA,IAAIkQ,gBAAgB,IAAIA,gBAAgB,CAACnK,QAAQ,KAAK,IAAI,CAAC+G,oBAAoB,EAAE;QAC/E,IAAI,CAACA,oBAAoB,GAAGoD,gBAAgB,CAACnK,QAAQ;MACvD;MACA;MACA,IAAI,CAAC1B,OAAO,CAAC6L,gBAAgB,CAAC;MAC9B;MACA,IAAI/F,QAAQ,IAAI+F,gBAAgB,IAAIA,gBAAgB,CAAClQ,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,KAAKV,SAAS,EAAE;QAC5F;QACA,IAAI;UACFlJ,kBAAkB,CAAC+Y,eAAe,CAAC3T,UAAU,EAAE,IAAI,CAACwE,YAAY,CAAC;QACnE,CAAC,CAAC,OAAOlC,CAAC,EAAE;UACVjK,OAAO,CAACkK,KAAK,CAACD,CAAC,CAACjK,OAAO,CAAC;QAC1B;MACF,CAAC,MAAM;QACLuC,kBAAkB,CAACoK,qBAAqB,CAAC,CAAC;MAC5C;MACA,IAAI,CAACe,kBAAkB,CAAC,CAAC;IAC3B;IACA,IAAI,CAAC8H,oBAAoB,CAAC,CAAC;IAC3B,KAAA4F,qBAAA,GAAI,IAAI,CAAC/V,SAAS,CAACsC,UAAU,CAAC,cAAAyT,qBAAA,wBAAAC,sBAAA,GAA1BD,qBAAA,CAA4BjU,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC,cAAAkP,sBAAA,uBAArDA,sBAAA,CAAuDrJ,KAAK,EAAE;MAChE,MAAM9J,KAAK,GAAG,IAAI,CAACuK,kBAAkB,CAAC9K,UAAU,CAAC;MACjD,IAAIO,KAAK,EAAE;QACT,IAAI,CAAC+J,kBAAkB,CAAC/J,KAAK,CAAC0P,OAAO,CAAC,CAAC,CAAC;MAC1C;IACF;EACF;EAkDA;AACF;AACA;AACA;EACEuD,qBAAqBA,CAACjO,QAAkB,EAAE;IACxC,MAAMqO,uBAAuB,GAAG1T,MAAM,CAACC,MAAM,CAAC,IAAI,CAACd,oBAAoB,CAACkG,QAAQ,CAAC2G,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;IACnG,OAAO2H,IAAI,CAACC,GAAG,CAAC,GAAGF,uBAAuB,EAAE,CAAC,CAAC,GAAG,CAAC;EACpD;;EAEA;AACF;AACA;AACA;EACE/P,OAAOA,CAACzD,QAAmB,EAAE;IAC3B,IAAI,IAAI,CAACnC,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAAC0F,OAAO,CAAC,CAAC;MAC7B,IAAI,CAAC1F,cAAc,GAAG,IAAI;MAC1B,IAAI,CAACC,kBAAkB,GAAG,IAAI;IAChC;IACA,IAAI,CAAC,IAAI,CAACiF,QAAQ,IAAI/C,QAAQ,IAAIzF,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;MAC7E,MAAM;QAAEjE;MAAO,CAAC,GAAGY,QAAQ;MAC3B,MAAMqK,SAAS,GAAGrP,gBAAgB,CAAC,IAAI,CAACoJ,YAAY,EAAEhF,MAAM,EAAE,IAAI,CAACgH,WAAW,CAAC;MAC/E,IAAIiE,SAAS,EAAE;QACb;QACA,IAAI,CAACxM,cAAc,GAAG,IAAI,CAACwH,WAAW,CAAC,IAAI,CAAC2C,gBAAgB,CAAC1C,aAAa,EAAE,IAAI,CAACtB,gBAAgB,CAAChE,QAAQ,CAAC,EAAEqK,SAAS,CAAC9E,SAAS,EAAE8E,SAAS,CAAClK,KAAK,CAAC;QAClJ,IAAI,CAACrC,kBAAkB,GAAGuM,SAAS,CAAC9E,SAAS;QAC7C,IAAI,CAAC1H,cAAc,CAAC+L,WAAW,GAAGzQ,WAAW,CAACwa,MAAM;QACpD,IAAI,CAAC9V,cAAc,CAAC2L,QAAQ,GAAG,IAAI,CAAC,CAAC;QACrC;QACA,IAAI,CAAC/D,iBAAiB,CAAC,IAAI,CAAC5H,cAAc,CAAC;MAC7C;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEmM,WAAWA,CAAChK,QAAkB,EAAE4T,YAAY,GAAG,KAAK,EAAE;IACpD,IAAI,CAACrZ,aAAa,CAACsZ,iBAAiB,EAAE;MACpC;IACF;IACA,MAAM;MAAEzU;IAAO,CAAC,GAAGY,QAAQ;IAC3B,MAAM;MAAEuF;IAAU,CAAC,GAAGnG,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAC;IAC/C,MAAM,CAAC2O,YAAY,CAAC,GAAG9X,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACmJ,YAAY,EAAEhF,MAAM,CAAC;IACrE,MAAM,CAACqM,YAAY,CAAC,GAAGvQ,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACkJ,YAAY,EAAEhF,MAAM,CAAC;IACrE,MAAM0U,cAA+C,GAAG,CAAC,CAAC;IAC1D,MAAMC,eAAe,GAAGA,CAAClU,UAAkB,EAAEM,KAAgB,EAAE6T,MAAe,EAAEC,SAAqB,KAAK;MACxG,IAAI7U,MAAM,CAACS,UAAU,CAAC,EAAE;QACtBT,MAAM,CAACS,UAAU,CAAC,CAACiK,UAAU,GAAG,KAAK;QACrC1K,MAAM,CAACS,UAAU,CAAC,CAACM,KAAK,GAAGA,KAAK;QAChCf,MAAM,CAACS,UAAU,CAAC,CAAC0F,SAAS,GAAGA,SAAS;QACxCuO,cAAc,CAACjU,UAAU,CAAC,GAAG,KAAK;MACpC,CAAC,MAAM,IAAImU,MAAM,EAAE;QACjB5U,MAAM,CAACS,UAAU,CAAC,GAAG;UACnBA,UAAU;UACViK,UAAU,EAAE,KAAK;UACjBvE,SAAS;UACTpF,KAAK;UACL,IAAI8T,SAAS,IAAIA,SAAS,CAAC5G,UAAU,IAAI;YAAEA,UAAU,EAAE;cAAE,GAAG4G,SAAS,CAAC5G;YAAW;UAAE,CAAC,CAAC;UACrF,IAAI4G,SAAS,IAAIA,SAAS,CAAChK,KAAK,IAAI;YAAEA,KAAK,EAAE,IAAI;YAAEmD,OAAO,EAAE6G,SAAS,CAAC7G;UAAQ,CAAC;QACjF,CAAC;QACD,IAAI,CAAC7P,cAAc,CAACsC,UAAU,CAAC,CAAC+B,IAAI,CAAC5B,QAAQ,CAACE,EAAE,CAAC;QACjD4T,cAAc,CAACjU,UAAU,CAAC,GAAG,KAAK;MACpC;IACF,CAAC;IACD,IAAIkT,YAAY,KAAKrP,SAAS,IAAItE,MAAM,CAAC2T,YAAY,CAAC,CAACxN,SAAS,KAAKA,SAAS,EAAE;MAC9E,KAAK,IAAIwF,CAAC,GAAGgI,YAAY,GAAG,CAAC,EAAEhI,CAAC,GAAG,IAAI,CAAC3G,YAAY,EAAE2G,CAAC,IAAI,CAAC,EAAE;QAC5D,MAAM;UAAE5K;QAAM,CAAC,GAAGhF,kBAAkB,CAACiE,MAAM,EAAE2T,YAAY,EAAE,IAAI,CAAC3O,YAAY,EAAE2O,YAAY,EAAEhI,CAAC,CAAC;QAC9FgJ,eAAe,CAAChJ,CAAC,EAAE5K,KAAK,EAAEyT,YAAY,EAAExU,MAAM,CAAC2T,YAAY,CAAC,CAAC;MAC/D;IACF;IACA,IAAItH,YAAY,KAAK/H,SAAS,IAAItE,MAAM,CAACqM,YAAY,CAAC,CAAClG,SAAS,KAAKA,SAAS,EAAE;MAC9E,KAAK,IAAIwF,CAAC,GAAG,IAAI,CAAC3G,YAAY,GAAG,CAAC,EAAE2G,CAAC,GAAGU,YAAY,EAAEV,CAAC,IAAI,CAAC,EAAE;QAC5D,MAAM;UAAE5K;QAAM,CAAC,GAAGhF,kBAAkB,CAACiE,MAAM,EAAE,IAAI,CAACgF,YAAY,EAAEqH,YAAY,EAAE,IAAI,CAACrH,YAAY,EAAE2G,CAAC,CAAC;QACnGgJ,eAAe,CAAChJ,CAAC,EAAE5K,KAAK,EAAE,KAAK,CAAC;MAClC;IACF;IACA,IAAIL,MAAM,CAACyK,IAAI,CAACuJ,cAAc,CAAC,CAACpS,MAAM,GAAG,CAAC,EAAE;MAC1C,IAAI,CAACqI,sBAAsB,GAAG;QAAE,GAAG,IAAI,CAACA,sBAAsB;QAAE,GAAG+J;MAAe,CAAC;IACrF;EACF;;EAEA;AACF;AACA;AACA;EACEnP,iBAAiBA,CAACuP,MAAe,EAAE;IACjC,IAAI,CAAClR,cAAc,GAAGkR,MAAM;EAC9B;EAyeAC,eAAeA,CAACC,aAAsB,EAAE;IACtC,OAAOA,aAAa,iBAClBpc,KAAA,CAAAqc,aAAA,CAACna,SAAS;MACRoa,GAAG,EAAE,IAAI,CAAC9V,YAAa;MACvBS,oBAAoB,EAAE5G,IAAI,CAAC,IAAI,CAAC4G,oBAAoB,CAAE;MACtD3B,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1BwB,QAAQ,EAAE,IAAI,CAAC3C,KAAK,CAAC2C,QAAS;MAC9BsG,WAAW,EAAE,IAAI,CAACA,WAAY;MAC9BjB,QAAQ,EAAE,IAAI,CAACA,QAAS;MACxBuB,cAAc,EAAE,IAAI,CAACA,cAAe;MACpCpF,UAAU,EAAEA,CAAA,KAAM,IAAI,CAACA,UAAU,CAAC,MAAM,CAAE;MAAAiU,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CAC3C,CACF;EACH;EAEAC,MAAMA,CAAA,EAAG;IACP,MAAMtQ,OAAO,GAAG,IAAI,CAACA,OAAO,IAAIhK,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACkO,IAAI;IACxE,MAAM/F,QAAQ,GAAG,IAAI,CAACA,QAAQ,IAAIwB,OAAO;IACzC,MAAMuQ,aAAa,GAAG,CAACva,aAAa,CAACgT,WAAW,IAAI,IAAI,CAACpR,KAAK,CAAC4Y,KAAK,CAAClE,QAAQ,CAAClW,IAAI,CAAC8N,GAAG,CAAC,IAAI,IAAI,CAACtM,KAAK,CAAC4Y,KAAK,CAAClE,QAAQ,CAAClW,IAAI,CAAC+N,WAAW,CAAC,KAAKnO,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACkO,IAAI;IACnL,MAAMkM,eAAe,GAAG,IAAI,CAAC5V,MAAM,CAACsC,MAAM,GAAG,CAAC;IAC9C,MAAM0S,aAAa,GAAGtU,MAAM,CAACyK,IAAI,CAAChQ,aAAa,CAAC0a,gBAAgB,CAAC,CAACvT,MAAM,GAAG,CAAC;IAC5E,oBACE1J,KAAA,CAAAqc,aAAA,CAACvb,aAAa;MAACiN,SAAS,EAAC,oBAAoB;MAACxB,OAAO,EAAEA,OAAQ;MAAAgQ,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,gBAC7D5c,KAAA,CAAAqc,aAAA,CAACxb,SAAS;MACRyb,GAAG,EAAE,IAAI,CAAC/V,QAAS;MACnB2W,UAAU;MACVzE,IAAI,EAAE;QAAE0E,YAAY,EAAE7a,SAAS,CAAC8a,OAAO;QAAE9M,OAAO,EAAEhO,SAAS,CAAC+a;MAAY,CAAE;MAC1E9T,IAAI,EAAEA,CAAA,KAAM,IAAI,CAACA,IAAI,CAAC,IAAI,CAAE;MAAAgT,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CAC7B,CAAC,eACF5c,KAAA,CAAAqc,aAAA,CAACza,OAAO;MACNmJ,QAAQ,EAAEA,QAAS;MACnBgS,KAAK,EAAE,IAAI,CAAC5Y,KAAK,CAAC4Y,KAAM;MACxBrS,WAAW,EAAE,IAAI,CAACA,WAAY;MAC9B4S,eAAe,EAAEN,eAAgB;MACjCrS,OAAO,EAAE,IAAI,CAACA,OAAQ;MACtBiB,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1B2R,SAAS,EAAEhb,aAAa,CAACgb,SAAU;MACnC/R,kBAAkB,EAAE,IAAI,CAACA,kBAAmB;MAC5CgS,8BAA8B,EAAE,IAAI,CAAC3Q,mBAAmB,CAAC,IAAI,CAACrB,kBAAkB,CAAE;MAClFqK,UAAU,EAAE,IAAI,CAACA,UAAW;MAC5B4H,oBAAoB,EAAE,IAAI,CAACjT,iBAAkB;MAC7CkT,gBAAgB,EAAE,IAAI,CAAC9S,aAAc;MACrC+S,kBAAkB,EAAE,IAAI,CAAChS,eAAgB;MACzCiS,iBAAiB,EAAE,IAAI,CAAClH,WAAY;MACpCmH,uBAAuB,EAAE,IAAI,CAAClH,uBAAwB;MACtDmH,WAAW,EAAEA,CAAA;QAAA,IAAAC,qBAAA;QAAA,QAAAA,qBAAA,GAAM,IAAI,CAAC5X,SAAS,CAACsC,OAAO,cAAAsV,qBAAA,uBAAtBA,qBAAA,CAAwBC,cAAc,CAAC,CAAC;MAAA,CAAC;MAC5DC,YAAY,EAAGC,KAAK;QAAA,IAAAC,sBAAA;QAAA,QAAAA,sBAAA,GAAK,IAAI,CAAChY,SAAS,CAACsC,OAAO,cAAA0V,sBAAA,uBAAtBA,sBAAA,CAAwBC,MAAM,CAACF,KAAK,CAAC;MAAA,CAAC;MAC/DvQ,kBAAkB,EAAE,IAAI,CAACA,kBAAmB;MAC5C0Q,MAAM,EAAEA,CAAA,KAAM,IAAI,CAAC9U,IAAI,CAAC,CAAE;MAC1B+U,OAAO,EAAE,IAAI,CAACnG,KAAM;MAAAoE,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACrB,CAAC,eACF5c,KAAA,CAAAqc,aAAA;MACEtO,SAAS,EAAC,WAAW;MACrB9B,KAAK,EAAE;QACLyN,MAAM,EAAE,eAAesD,eAAe,GAAG,GAAG,IAAI,CAACuB,kBAAkB,GAAG,EAAE,IAAI,GAAG,MAAM,GAAG;QACxFC,UAAU,EAAE;MACd,CAAE;MAAAjC,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,gBAEF5c,KAAA,CAAAqc,aAAA,CAACxa,OAAO;MACNkJ,QAAQ,EAAEA,QAAS;MACnBoJ,QAAQ,EAAE,IAAI,CAAChQ,KAAK,CAACgQ,QAAS;MAC9B/H,YAAY,EAAE,IAAI,CAACA,YAAa;MAChCS,mBAAmB,EAAExM,IAAI,CAAC,IAAI,CAACwM,mBAAmB,CAAE;MACpD5F,oBAAoB,EAAE5G,IAAI,CAAC,IAAI,CAAC4G,oBAAoB,CAAE;MACtD3B,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1BkG,kBAAkB,EAAE,IAAI,CAACA,kBAAmB;MAC5C0I,oBAAoB,EAAE,IAAI,CAACA,oBAAqB;MAChDkI,aAAa,EAAEA,aAAc;MAC7B1O,cAAc,EAAE,IAAI,CAACA,cAAe;MACpCsG,cAAc,EAAE,IAAI,CAACA,cAAe;MACpC7B,kBAAkB,EAAGvK,UAAU,IAAK;QAClC,IAAIrF,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,EAAE;UAC/C,IAAI,CAAC8G,kBAAkB,CAACvK,UAAU,CAAC;QACrC,CAAC,MAAM;UAAA,IAAA6W,sBAAA;UACL,CAAAA,sBAAA,OAAI,CAACrY,QAAQ,CAACqC,OAAO,cAAAgW,sBAAA,uBAArBA,sBAAA,CAAuBC,cAAc,CAAC,IAAI,CAACtS,YAAY,EAAExE,UAAU,CAAC;QACtE;MACF,CAAE;MACFiL,uBAAuB,EAAE,IAAI,CAACU,6BAA8B;MAC5DoL,gBAAgB,EAAEA,CAAA,KAAM,IAAI,CAAChS,iBAAiB,CAAC,IAAI,CAAE;MACrDwP,eAAe,EAAEA,CAAA,KAAM,IAAI,CAACA,eAAe,CAACC,aAAa,CAAE;MAC3DpQ,gBAAgB,EAAE,IAAI,CAACA,gBAAiB;MAAAuQ,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACzC,CAAC,eACF5c,KAAA,CAAAqc,aAAA;MACEpQ,KAAK,EAAE;QACLuN,KAAK,EAAE,eAAesD,aAAa,GAAG,OAAO,GAAG,OAAO,GAAG;QAC1D8B,QAAQ,EAAE,UAAU;QACpBzT,MAAM,EAAE,IAAI,CAACA;MACf,CAAE;MAAAoR,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,GAEDra,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACyI,OAAO,iBAC1CrL,KAAA,CAAAqc,aAAA,CAAArc,KAAA,CAAA6e,QAAA,qBACE7e,KAAA,CAAAqc,aAAA,CAACrb,MAAM;MACLsb,GAAG,EAAE,IAAI,CAACnW,SAAU;MACpBwI,GAAG,EAAE,IAAI,CAACxK,KAAK,CAACwK,GAAI;MACpBmQ,SAAS,EAAEvc,aAAa,CAACwc,gBAAiB;MAC1CC,cAAc,EAAE3e,IAAI,CAACkC,aAAa,CAAC0c,oBAAoB,CAAE;MACzDC,QAAQ,EAAE,IAAI,CAAC9X,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAE;MACzCd,WAAW,EAAE,CAAC,IAAI,CAACiB,OAAQ;MAC3B4S,aAAa,EAAE,IAAI,CAAClS,UAAW;MAC/BmS,aAAa,EAAGlB,KAAK,IAAK;QACxB3b,aAAa,CAAC0b,YAAY,CAACC,KAAK,CAAC;QACjC,IAAI,CAACtQ,YAAY,CAAC,CAAC;MACrB,CAAE;MACFyR,gBAAgB,EAAEA,CAAA,KAAM;QACtB,IAAI,CAACzR,YAAY,CAAC,CAAC;QACnB,KAAK,IAAImF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtN,MAAM,CAACiE,MAAM,EAAEqJ,CAAC,IAAI,CAAC,EAAE;UAC9C,IAAI,CAACtN,MAAM,CAACsN,CAAC,CAAC,CAACuM,cAAc,CAAC,CAAC;QACjC;MACF,CAAE;MACFC,OAAO,EAAE,IAAI,CAACzP,QAAS;MACvB0P,YAAY,EAAE,IAAI,CAAC9N,aAAc;MAAA6K,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CAClC,CAAC,eACF5c,KAAA,CAAAqc,aAAA;MAAKC,GAAG,EAAE,IAAI,CAACrW,eAAgB;MAAC8H,SAAS,EAAC,2BAA2B;MAAAwO,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CAAE,CAAC,eACxE5c,KAAA,CAAAqc,aAAA,CAACla,WAAW;MACVma,GAAG,EAAE,IAAI,CAACjW,QAAS;MACnBZ,MAAM,EAAE,IAAI,CAACA,MAAO;MACpBC,gBAAgB,EAAE,IAAI,CAACA,gBAAiB;MACxCJ,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1BkG,kBAAkB,EAAE,IAAI,CAACA,kBAAmB;MAC5CY,YAAY,EAAE,IAAI,CAACA,YAAa;MAChCwO,cAAc,EAAE,IAAI,CAACA,cAAe;MACpC3C,UAAU,EAAE1V,aAAa,CAAC0V,UAAW;MAAAsE,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACtC,CAAC,EACD,CAAC,IAAI,CAAC7R,QAAQ,iBACb/K,KAAA,CAAAqc,aAAA,CAACja,QAAQ;MACPka,GAAG,EAAE,IAAI,CAAC7V,WAAY;MACtBgZ,WAAW,EAAEnd,SAAS,CAAC8a,OAAQ;MAC/BsC,WAAW,EAAEpd,SAAS,CAAC+a,WAAY;MACnC9Q,OAAO,EAAE,IAAI,CAACA,OAAQ;MACtB5B,OAAO,EAAE,IAAI,CAACA,OAAQ;MACtBD,WAAW,EAAE,IAAI,CAACA,WAAY;MAC9Bc,kBAAkB,EAAE,IAAI,CAACA,kBAAmB;MAC5C5F,aAAa,EAAE,IAAI,CAACA,aAAc;MAAA2W,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACnC,CAEH,CACH,EACAra,aAAa,CAAC+J,QAAQ,KAAK1J,QAAQ,CAACkO,IAAI,iBACvC9Q,KAAA,CAAAqc,aAAA,CAAC1a,QAAQ;MACP2a,GAAG,EAAE,IAAI,CAAClW,QAAS;MACnBuI,GAAG,EAAE,IAAI,CAACxK,KAAK,CAACwK,GAAI;MACpB5D,QAAQ,EAAE,IAAI,CAACA,QAAS;MACxBa,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1B+T,cAAc,EAAEpd,aAAa,CAACsN,yBAA0B;MACxDzI,MAAM,EAAE,IAAI,CAACA,MAAO;MACpBgF,YAAY,EAAE,IAAI,CAACA,YAAa;MAChC9G,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1BkG,kBAAkB,EAAE,IAAI,CAACA,kBAAmB;MAC5CoU,qBAAqB,EAAE,IAAI,CAAC5P,gBAAgB,CAAC1C,aAAc;MAC3DnB,QAAQ,EAAE,IAAI,CAACA,QAAS;MACxB2D,QAAQ,EAAE,IAAI,CAACA,QAAS;MACxBzC,WAAW,EAAE,IAAI,CAACA,WAAY;MAC9BwS,WAAW,EAAE,IAAI,CAAClO,sBAAuB;MACzCmO,WAAW,EAAE,IAAI,CAACjN,uBAAwB;MAC1CV,kBAAkB,EAAE,IAAI,CAACA,kBAAmB;MAC5CnG,gBAAgB,EAAE,IAAI,CAACA,gBAAiB;MAAAuQ,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACzC,CAEA,CAAC,EACLE,aAAa,iBACZ9c,KAAA,CAAAqc,aAAA,CAACva,UAAU;MACTwa,GAAG,EAAE,IAAI,CAAChW,aAAc;MACxByE,QAAQ,EAAEA,QAAS;MACnBgV,YAAY,EAAE,IAAI,CAAC3Y,MAAM,CAACsC,MAAM,GAAG,CAAE;MACrCsW,MAAM,EAAE3f,IAAI,CAACkC,aAAa,CAACgT,WAAW,CAAE;MACxC0K,WAAW,EAAE5f,IAAI,CAACkC,aAAa,CAAC0d,WAAW,CAAE;MAC7ClY,MAAM,EAAE1H,IAAI,CAAC,IAAI,CAACmV,iBAAiB,CAAE;MACrC0K,QAAQ,EAAE,IAAI,CAACtK,eAAgB;MAC/BxJ,YAAY,EAAE,IAAI,CAACA,YAAa;MAChC+T,YAAY,EAAE,IAAI,CAAC/Y,MAAM,CAAC,IAAI,CAACgF,YAAY,CAAE;MAC7CkL,gBAAgB,EAAE,IAAI,CAAChS,SAAS,CAAC,IAAI,CAACkG,kBAAkB,CAAE;MAC1DoU,qBAAqB,EAAE,IAAI,CAAC5P,gBAAgB,CAAC1C,aAAc;MAC3D8S,cAAc,EAAE,IAAI,CAACpL,aAAc;MACnChJ,gBAAgB,EAAE,IAAI,CAACA,gBAAiB;MAAAuQ,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACzC,CAEA,CAAC,EACLI,eAAe,iBACdhd,KAAA,CAAAqc,aAAA,CAACta,YAAY;MACXgJ,QAAQ,EAAEA,QAAS;MACnBsV,gBAAgB,EAAE/d,SAAS,CAAC8a,OAAQ;MACpCxW,UAAU,EAAE,IAAI,CAACQ,MAAM,CAACsC,MAAO;MAC/B4W,YAAY,EAAE/T,OAAQ;MACtBH,YAAY,EAAE,IAAI,CAACA,YAAa;MAChCmU,aAAa,EAAElgB,IAAI,CAACqC,WAAW,CAAC6d,aAAa,CAAE;MAC/CtZ,oBAAoB,EAAE5G,IAAI,CAAC,IAAI,CAAC4G,oBAAoB,CAAE;MACtD3B,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1BC,cAAc,EAAE,IAAI,CAACA,cAAe;MACpCib,YAAY,EAAEngB,IAAI,CAACoC,YAAY,CAACge,eAAe,CAAE;MACjDnJ,gBAAgB,EAAE,IAAI,CAAChS,SAAS,CAAC,IAAI,CAACkG,kBAAkB,CAAE;MAC1DuG,sBAAsB,EAAE1R,IAAI,CAAC,IAAI,CAAC0R,sBAAsB,CAAE;MAC1DrE,cAAc,EAAE,IAAI,CAACA,cAAe;MACpCvB,QAAQ,EAAE,IAAI,CAACA,QAAS;MACxBiB,WAAW,EAAE,IAAI,CAACA,WAAY;MAC9BpB,gBAAgB,EAAE,IAAI,CAACA,gBAAiB;MACxC0U,cAAc,EAAGhH,MAAc,IAAK;QAClC,IAAI,CAAC6E,kBAAkB,GAAG7E,MAAM;MAClC,CAAE;MAAA6C,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACH,CACF,EACA,IAAI,CAACpR,kBAAkB,IAAI,IAAI,CAACR,cAAc,iBAC7ChL,KAAA,CAAAqc,aAAA,CAACra,YAAY;MACXmS,QAAQ,EAAE,IAAI,CAAChQ,KAAK,CAACgQ,QAAS;MAC9B/H,YAAY,EAAE,IAAI,CAACA,YAAa;MAChCuU,gBAAgB,EAAE,IAAI,CAACnV,kBAAmB;MAC1ClG,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1B2B,oBAAoB,EAAE5G,IAAI,CAAC,IAAI,CAAC4G,oBAAoB,CAAE;MACtD2Z,MAAM,EAAE,IAAI,CAACtM,IAAK;MAClBuM,OAAO,EAAEA,CAAA,KAAM,IAAI,CAAClU,iBAAiB,CAAC,KAAK,CAAE;MAC7CX,gBAAgB,EAAE,IAAI,CAACA,gBAAiB;MAAAuQ,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACzC,CACF,eACD5c,KAAA,CAAAqc,aAAA,CAACpa,MAAM;MACLmK,YAAY,EAAE,IAAI,CAACA,YAAa;MAChC9G,SAAS,EAAE,IAAI,CAACA,SAAU;MAC1Bwb,QAAQ,EAAE,IAAI,CAAC3c,KAAK,CAAC2C,QAAQ,CAACga,QAAS;MACvCC,UAAU,EAAEA,CAAA;QAAA,IAAAC,sBAAA;QAAA,QAAAA,sBAAA,GAAM,IAAI,CAAC5a,QAAQ,CAACqC,OAAO,cAAAuY,sBAAA,uBAArBA,sBAAA,CAAuBC,WAAW,CAAC,IAAI,CAAC7U,YAAY,CAAC;MAAA,CAAC;MACxEJ,gBAAgB,EAAE,IAAI,CAACA,gBAAiB;MAAAuQ,MAAA;MAAAC,QAAA;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IAAA,CACzC,CACY,CAAC;EAEpB;AACF,CAAC,EAAA5Y,cAAA,CAl4DQkd,YAAY,GAAG;EACpBnE,KAAK,EAAEjV,MAAM,CAACC,MAAM,CAACpF,IAAI;AAC3B,CAAC,EAAAqB,cAAA,GAAAK,WAAA,GAAA8c,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,aAKAjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAoB,EAAE;EAAA;AAAA,IAAAld,YAAA,GAAA6c,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,mBAKhCjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAgB,CAAC;EAAA;AAAA,IAAAjd,YAAA,GAAA4c,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,kBAK3BjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAe,IAAI,CAACrd,KAAK,CAAC4Y,KAAK,CAAC,CAAC,CAAC;EAAA;AAAA,IAAAvY,YAAA,GAAA2c,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,cAK5CjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAW,IAAI;EAAA;AAAA,IAAA/c,YAAA,GAAA0c,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,cAKzBjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAW,KAAK;EAAA;AAAA,IAAA9c,YAAA,GAAAyc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,gBAK1BjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAa,IAAI;EAAA;AAAA,IAAA7c,YAAA,GAAAwc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,aAK3BjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAU9f,MAAM,CAAC+f,OAAO;EAAA;AAAA,IAAA7c,YAAA,GAAAuc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,2BAKlCjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,IAAAE,qBAAA;IAAA,QAAAA,qBAAA,GAAwB,IAAI,CAACvd,KAAK,CAACgQ,QAAQ,CAAC,CAAC,CAAC,cAAAuN,qBAAA,uBAAtBA,qBAAA,CAAwB5N,UAAU;EAAA;AAAA,IAAAjP,YAAA,GAAAsc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,yBAKpEjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAsB,EAAE;EAAA;AAAA,IAAA1c,YAAA,GAAAqc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,6BAKlCjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAA2D,CAAC,CAAC;EAAA;AAAA,IAAAzc,YAAA,GAAAoc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,0BAKvEjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAwD,CAAC,CAAC;EAAA;AAAA,IAAAxc,aAAA,GAAAmc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,2BAKpEjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAA8C,CAAC,CAAC;EAAA;AAAA,IAAAvc,aAAA,GAAAkc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,wBAK1DjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAA0B,IAAI;EAAA;AAAA,IAAAtc,aAAA,GAAAic,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,sBAKxCjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAmB,EAAE;EAAA;AAAA,IAAArc,aAAA,GAAAgc,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,qBAK/BjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAkB,EAAE;EAAA;AAAA,IAAApc,aAAA,GAAA+b,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,qBAK9BjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAkB,KAAK;EAAA;AAAA,IAAAnc,aAAA,GAAA8b,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,yBAKjCjhB,UAAU;EAAAkhB,YAAA;EAAAC,UAAA;EAAAC,QAAA;EAAAC,WAAA,WAAAA,CAAA;IAAA,OAAsB,GAAG;EAAA;AAAA,IAAAL,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,uBA8GnChhB,QAAQ,GAAA0H,MAAA,CAAA6Z,wBAAA,CAAA5d,OAAA,CAAAqd,SAAA,uBAAArd,OAAA,CAAAqd,SAAA,GAAAD,yBAAA,CAAApd,OAAA,CAAAqd,SAAA,uBAQRhhB,QAAQ,GAAA0H,MAAA,CAAA6Z,wBAAA,CAAA5d,OAAA,CAAAqd,SAAA,uBAAArd,OAAA,CAAAqd,SAAA,GAAArd,OAAA,MAAAD,MAAA;AAurDX,eAAe/C,UAAU,CAAC8C,aAAa,EAAE;EACvC+d,cAAc,EAAE9Z,MAAM,CAACC,MAAM,CAACxE,OAAO;AACvC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module"}