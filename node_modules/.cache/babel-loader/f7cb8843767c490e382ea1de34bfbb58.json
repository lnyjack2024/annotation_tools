{"ast":null,"code":"import { action, makeAutoObservable, observable, toJS } from 'mobx';\nimport { notification } from 'antd';\nimport * as alawmulaw from 'alawmulaw';\nimport WavDecoder from '../utils/wav-decoder';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport WaveStore from './WaveStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport GlobalStore from './GlobalStore';\nimport Crunker from '../utils/crunker';\nimport { loadInstancesFromResult, triggerForm } from '../utils';\nimport { ReviewResult } from '../types';\nimport i18n from '../locales';\nimport { parseAlawPcmToAudioData } from '../../../utils/pcm';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, TOOL_MODE } from '../../../utils/tool-mode';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy.toolMode) || this.global.annotateDisabled;\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in labeling mode\n   */\n  get isLabeling() {\n    return this.jobProxy.toolMode === TOOL_MODE.LABELING;\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy.toolMode);\n  }\n  constructor() {\n    this.ontology = void 0;\n    this.undo = void 0;\n    this.waveform = void 0;\n    this.setting = void 0;\n    this.review = void 0;\n    this.instance = void 0;\n    this.global = void 0;\n    this.urls = [];\n    /**\n     * job proxy\n     */\n    this.jobProxy = void 0;\n    /**\n     * is tool initialized\n     */\n    this.initialized = false;\n    this.mergeAudios = async () => new Promise(async (resolve, reject) => {\n      try {\n        const buffers = [];\n        for (let i = 0; i < this.urls.length; i += 1) {\n          // eslint-disable-next-line no-await-in-loop\n          const audioBuffer = this.urls[i] ? await this.loadBuffer(this.urls[i]) : null;\n          if (audioBuffer) {\n            buffers.push(audioBuffer);\n          }\n        }\n        const crunker = new Crunker({\n          sampleRate: Math.min(...buffers.map(b => b.sampleRate))\n        });\n        const audioBuffer = crunker.mergeAudio(buffers, false);\n        resolve(audioBuffer);\n      } catch (error) {\n        reject({\n          message: i18n.translate('AUDIO_MULTI_LOAD_ERROR')\n        });\n      }\n    });\n    // Loads audio using Web Audio buffer backend.\n    this.loadBuffer = url => new Promise(async (resolve, reject) => {\n      try {\n        const tail = url.split('.').pop();\n        const arrayBuffer = await fetch(url).then(data => data.arrayBuffer());\n        let audioBuffer = null;\n        if (tail === 'wav') {\n          const decodeData = WavDecoder.decodeSync(arrayBuffer);\n          audioBuffer = new AudioBuffer({\n            numberOfChannels: decodeData.numberOfChannels,\n            sampleRate: decodeData.sampleRate,\n            length: decodeData.length\n          });\n          for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n            const audioChannelBuffer = audioBuffer.getChannelData(i);\n            for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n              audioChannelBuffer[j] = decodeData.channelData[i][j];\n            }\n          }\n        } else if (tail === 'alaw') {\n          const alawOriginData = new Uint8Array(arrayBuffer);\n          const decodeAlaw = alawmulaw.alaw.decode(alawOriginData);\n          audioBuffer = parseAlawPcmToAudioData(decodeAlaw.buffer);\n        } else {\n          const audioCtx = new AudioContext();\n          audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);\n        }\n        resolve(audioBuffer);\n      } catch (error) {\n        resolve(null);\n      }\n    });\n    /**\n     * get instance statistics\n     */\n    this.getInstanceStatistics = () => {\n      const objects = {\n        summary: [],\n        duration: 0,\n        // file duration\n        validDuration: 0,\n        annotationDuration: 0,\n        // annotation duration\n        approvedValidDuration: 0,\n        rejectedValidDuration: 0\n      };\n      const reviews = this.review.getReviewsForSave().filter(r => r.result !== ReviewResult.APPROVE);\n      const instancesList = Object.values(this.instance.instances).filter(v => !!v);\n      objects.duration = Math.round(this.waveform.duration * 1000);\n      for (let i = 0; i < instancesList.length; i += 1) {\n        const {\n          id,\n          start,\n          end\n        } = instancesList[i];\n        const duration = Math.round((end - start) * 1000);\n        objects.annotationDuration += duration;\n        const review = reviews.find(r => r.instanceId === id);\n        if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.REJECT) {\n          objects.rejectedValidDuration += duration;\n        } else {\n          objects.approvedValidDuration += duration;\n        }\n      }\n      return objects;\n    };\n    /**\n     * save file\n     * @param file\n     */\n    this.saveFile = file => this.jobProxy.saveFile(file);\n    makeAutoObservable(this, {\n      urls: observable,\n      initialized: observable,\n      initEnd: action\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.waveform = new WaveStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n    this.global = new GlobalStore(this);\n  }\n  async init(payload) {\n    return new Promise(async (resolve, reject) => {\n      // init urls\n      this.urls = payload.audio ? payload.audio.split(',') : [];\n      // init job proxy\n      this.jobProxy = payload.jobProxy;\n\n      // init common stores\n      try {\n        this.ontology.init(payload);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR')\n        });\n      }\n      this.setting.init(payload);\n      try {\n        this.global.init(payload);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_LOAD_GLOBAL_ERROR')\n        });\n      }\n      try {\n        if (this.urls.length === 0) {\n          throw new Error();\n        }\n        const audioBuffer = this.urls.length > 1 ? await this.mergeAudios() : undefined;\n        this.waveform.init(payload, audioBuffer);\n      } catch (error) {\n        var _ref;\n        notification.error({\n          message: ((_ref = error) === null || _ref === void 0 ? void 0 : _ref.message) || i18n.translate('AUDIO_LOAD_ERROR')\n        });\n        this.setting.setLoading(false);\n        return;\n      }\n      // load result & init instances\n      try {\n        await this.loadResult(payload.ontology);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR')\n        });\n      }\n      // load & init reviews\n      try {\n        await this.loadReviews(payload);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR')\n        });\n      }\n      this.initEnd();\n      resolve(true);\n    });\n  }\n  initEnd() {\n    this.initialized = true;\n  }\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology) {\n    const savedResult = await this.jobProxy.loadSavedResult();\n    const reviewFromResult = await this.jobProxy.loadReviewFrom();\n    const result = savedResult || reviewFromResult;\n    if (result) {\n      this.global.setAttributes(Object.prototype.toString.call(result.attributes) === '[object Object]' ? result.attributes : {});\n      // load instance\n      this.instance.init(result.instances ? loadInstancesFromResult(result === null || result === void 0 ? void 0 : result.instances, ontology) : []);\n      if (result.channelOffset) {\n        this.waveform.setChannelOffsets(result.channelOffset);\n      }\n      if (result.auditId) {\n        this.jobProxy.setAuditId(result.auditId);\n      }\n    }\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const {\n      channelOffset\n    } = this.waveform;\n    const {\n      updatedValues\n    } = triggerForm(this.global.globalConfig, this.global.attributes);\n    const newInstances = Object.values(toJS(this.instance.instances)).map(i => {\n      var _i$text;\n      return {\n        ...i,\n        text: (_i$text = i.text) === null || _i$text === void 0 ? void 0 : _i$text.trim()\n      };\n    });\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy.saveResultStat(statData);\n    return this.jobProxy.saveResult({\n      auditId: this.jobProxy.auditId,\n      attributes: updatedValues,\n      instances: newInstances,\n      channelOffset,\n      statistics\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload) {\n    this.review.init(payload.toolMode || payload.jobProxy.toolMode, payload.issue_types);\n    const reviews = await this.jobProxy.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews() {\n    return this.jobProxy.saveReviews(this.review.getReviewsForSave());\n  }\n}\nconst rootStore = new RootStore();\nexport default rootStore;","map":{"version":3,"names":["action","makeAutoObservable","observable","toJS","notification","alawmulaw","WavDecoder","OntologyStore","UndoStore","WaveStore","SettingsStore","ReviewsStore","InstanceStore","GlobalStore","Crunker","loadInstancesFromResult","triggerForm","ReviewResult","i18n","parseAlawPcmToAudioData","isAnnotationReadonly","isReviewEditable","isRework","isPreview","TOOL_MODE","RootStore","readonly","jobProxy","toolMode","global","annotateDisabled","reviewable","isLabeling","LABELING","constructor","ontology","undo","waveform","setting","review","instance","urls","initialized","mergeAudios","Promise","resolve","reject","buffers","i","length","audioBuffer","loadBuffer","push","crunker","sampleRate","Math","min","map","b","mergeAudio","error","message","translate","url","tail","split","pop","arrayBuffer","fetch","then","data","decodeData","decodeSync","AudioBuffer","numberOfChannels","audioChannelBuffer","getChannelData","j","channelData","alawOriginData","Uint8Array","decodeAlaw","alaw","decode","buffer","audioCtx","AudioContext","decodeAudioData","getInstanceStatistics","objects","summary","duration","validDuration","annotationDuration","approvedValidDuration","rejectedValidDuration","reviews","getReviewsForSave","filter","r","result","APPROVE","instancesList","Object","values","instances","v","round","id","start","end","find","instanceId","REJECT","saveFile","file","initEnd","init","payload","audio","Error","undefined","_ref","setLoading","loadResult","loadReviews","savedResult","loadSavedResult","reviewFromResult","loadReviewFrom","setAttributes","prototype","toString","call","attributes","channelOffset","setChannelOffsets","auditId","setAuditId","saveResult","submit","updatedValues","globalConfig","newInstances","_i$text","text","trim","statData","statistics","saveResultStat","issue_types","setInitialData","saveReviews","rootStore"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/store/RootStore.ts"],"sourcesContent":["import { action, makeAutoObservable, observable, toJS } from 'mobx';\nimport { notification } from 'antd';\nimport * as alawmulaw from 'alawmulaw';\nimport WavDecoder from '../utils/wav-decoder';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport WaveStore from './WaveStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport GlobalStore from './GlobalStore';\nimport Crunker from '../utils/crunker';\nimport { loadInstancesFromResult, triggerForm } from '../utils';\nimport { Payload, Instance, Ontology, ReviewResult } from '../types';\nimport i18n from '../locales';\nimport JobProxy from '../../../libs/JobProxy';\nimport { parseAlawPcmToAudioData } from '../../../utils/pcm';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, TOOL_MODE } from '../../../utils/tool-mode';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  ontology: OntologyStore;\n\n  undo: UndoStore;\n\n  waveform: WaveStore;\n\n  setting: SettingsStore;\n\n  review: ReviewsStore;\n\n  instance: InstanceStore;\n\n  global: GlobalStore;\n\n  urls: string[] = [];\n\n  /**\n   * job proxy\n   */\n  jobProxy?: JobProxy;\n\n  /**\n   * is tool initialized\n   */\n  initialized = false;\n\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy!.toolMode) || this.global.annotateDisabled;\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in labeling mode\n   */\n  get isLabeling() {\n    return this.jobProxy!.toolMode === TOOL_MODE.LABELING;\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy!.toolMode);\n  }\n\n  constructor() {\n    makeAutoObservable(this, {\n      urls: observable,\n      initialized: observable,\n      initEnd: action,\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.waveform = new WaveStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n    this.global = new GlobalStore(this);\n  }\n\n  async init(payload: Payload) {\n    return new Promise(async (resolve, reject) => {\n      // init urls\n      this.urls = payload.audio ? payload.audio.split(',') : [];\n      // init job proxy\n      this.jobProxy = payload.jobProxy;\n\n      // init common stores\n      try {\n        this.ontology.init(payload);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR') });\n      }\n      this.setting.init(payload);\n\n      try {\n        this.global.init(payload);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_LOAD_GLOBAL_ERROR') });\n      }\n\n      try {\n        if (this.urls.length === 0) {\n          throw new Error();\n        }\n        const audioBuffer = this.urls.length > 1 ? await this.mergeAudios() : undefined;\n        this.waveform.init(payload, audioBuffer);\n      } catch (error) {\n        notification.error({ message: (error as any)?.message || i18n.translate('AUDIO_LOAD_ERROR') });\n        this.setting.setLoading(false);\n        return;\n      }\n      // load result & init instances\n      try {\n        await this.loadResult(payload.ontology);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR') });\n      }\n      // load & init reviews\n      try {\n        await this.loadReviews(payload);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR') });\n      }\n      this.initEnd();\n      resolve(true);\n    });\n  }\n\n  mergeAudios = async () => new Promise<AudioBuffer | undefined>(async (resolve, reject) => {\n    try {\n      const buffers: AudioBuffer[] = [];\n      for (let i = 0; i < this.urls.length; i += 1) {\n        // eslint-disable-next-line no-await-in-loop\n        const audioBuffer = this.urls[i] ? await this.loadBuffer(this.urls[i]) : null;\n        if (audioBuffer) {\n          buffers.push(audioBuffer);\n        }\n      }\n      const crunker = new Crunker({ sampleRate: Math.min(...buffers.map((b) => b.sampleRate)) });\n      const audioBuffer = crunker.mergeAudio(buffers, false);\n      resolve(audioBuffer);\n    } catch (error) {\n      reject({ message: i18n.translate('AUDIO_MULTI_LOAD_ERROR') });\n    }\n  });\n\n  // Loads audio using Web Audio buffer backend.\n  loadBuffer = (url: string) => new Promise<AudioBuffer|null>(async (resolve, reject) => {\n    try {\n      const tail = url.split('.').pop();\n      const arrayBuffer = await fetch(url)\n        .then((data) => data.arrayBuffer());\n\n      let audioBuffer: AudioBuffer | null = null;\n      if (tail === 'wav') {\n        const decodeData = WavDecoder.decodeSync(arrayBuffer);\n        audioBuffer = new AudioBuffer({\n          numberOfChannels: decodeData.numberOfChannels,\n          sampleRate: decodeData.sampleRate,\n          length: decodeData.length,\n        });\n        for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n          const audioChannelBuffer = audioBuffer.getChannelData(i);\n          for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n            audioChannelBuffer[j] = decodeData.channelData[i][j];\n          }\n        }\n      } else if (tail === 'alaw') {\n        const alawOriginData = new Uint8Array(arrayBuffer);\n        const decodeAlaw = alawmulaw.alaw.decode(alawOriginData);\n        audioBuffer = parseAlawPcmToAudioData(decodeAlaw.buffer);\n      } else {\n        const audioCtx = new AudioContext();\n        audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);\n      }\n      resolve(audioBuffer);\n    } catch (error) {\n      resolve(null);\n    }\n  });\n\n  initEnd() {\n    this.initialized = true;\n  };\n\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology: Ontology[]) {\n    const savedResult = await this.jobProxy!.loadSavedResult();\n    const reviewFromResult = await this.jobProxy!.loadReviewFrom();\n\n    const result = savedResult || reviewFromResult;\n    if (result) {\n      this.global.setAttributes(Object.prototype.toString.call(result.attributes) === '[object Object]' ? result.attributes : {});\n      // load instance\n      this.instance.init(result.instances ? loadInstancesFromResult(result?.instances, ontology) : []);\n\n      if (result.channelOffset) {\n        this.waveform.setChannelOffsets(result.channelOffset);\n      }\n\n      if (result.auditId) {\n        this.jobProxy!.setAuditId(result.auditId);\n      }\n    }\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const { channelOffset } = this.waveform;\n    const { updatedValues } = triggerForm(this.global.globalConfig, this.global.attributes);\n    const newInstances: Instance[] = Object.values(toJS(this.instance.instances)).map((i) => ({ ...i, text: i.text?.trim() }));\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy!.saveResultStat(statData);\n    return this.jobProxy!.saveResult({\n      auditId: this.jobProxy!.auditId,\n      attributes: updatedValues,\n      instances: newInstances,\n      channelOffset,\n      statistics,\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload: Payload) {\n    this.review.init(payload.toolMode || payload.jobProxy.toolMode, payload.issue_types);\n    const reviews = await this.jobProxy!.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews() {\n    return this.jobProxy!.saveReviews(this.review.getReviewsForSave());\n  }\n\n  /**\n   * get instance statistics\n   */\n  getInstanceStatistics = () => {\n    const objects = {\n      summary: [],\n      duration: 0, // file duration\n      validDuration: 0,\n      annotationDuration: 0, // annotation duration\n      approvedValidDuration: 0,\n      rejectedValidDuration: 0,\n    };\n    const reviews = this.review.getReviewsForSave().filter((r) => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(this.instance.instances).filter((v) => !!v);\n\n    objects.duration = Math.round(this.waveform.duration * 1000);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, start, end } = instancesList[i];\n      const duration = Math.round((end - start) * 1000);\n      objects.annotationDuration += duration;\n      const review = reviews.find((r) => r.instanceId === id);\n      if (review?.result === ReviewResult.REJECT) {\n        objects.rejectedValidDuration += duration;\n      } else {\n        objects.approvedValidDuration += duration;\n      }\n    }\n    return objects;\n  };\n\n  /**\n   * save file\n   * @param file\n   */\n  saveFile = (file: File) => this.jobProxy!.saveFile(file);\n}\n\nconst rootStore = new RootStore();\nexport type RootStoreType = typeof rootStore;\nexport default rootStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}