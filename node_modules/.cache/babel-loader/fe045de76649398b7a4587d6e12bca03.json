{"ast":null,"code":"import { makeAutoObservable, runInAction, toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport { message } from 'antd';\nimport CamerasMapping from '../cameras-mapping/CamerasMapping';\nimport View, { EventAction } from '../shapes/View';\nimport { DEFAULT_CAMERA_NAME, SIDEBAR_WIDTH, TOOLBAR_HEIGHT } from '../constants';\nimport { parseFramesByPaylod, parseLabelConfig } from '../utils';\nimport { ViewMode, ValidationType, ReviewMode, ProjectMode } from '../types';\nimport i18n from '../locales';\nimport loader from '../../../utils/image-preloader';\nimport { triggerFormRules } from '../../../utils/form';\nimport { ProjectModel } from '../cameras-mapping/types';\n\n/**\n * store for frames\n * @class\n */\nexport default class FrameStore {\n  /**\n   * is single camera\n   * @getter\n   */\n  get isSingleCamera() {\n    const cameraNames = Object.keys(this.cameras);\n    return cameraNames.length === 1;\n  }\n\n  /**\n   * camera names\n   * @getter\n   */\n  get cameraNames() {\n    return Object.keys(this.cameras);\n  }\n\n  /**\n   * camera count\n   * @getter\n   */\n  get cameraCount() {\n    return Object.keys(this.cameras).length;\n  }\n\n  /**\n   * current cameras frames\n   * @getter\n   */\n  get frames() {\n    return this.cameras[this.currentCamera] || [];\n  }\n\n  /**\n   * current camera frame count\n   * @getter\n   */\n  get frameCount() {\n    return this.frames.length;\n  }\n\n  /**\n   * image boundary\n   * @getter\n   */\n  get imageBounds() {\n    return this.getImageBoundsForCamera(this.currentCamera);\n  }\n\n  /**\n   * current frame rotation, default is 0\n   * @getter\n   */\n  get currentFrameRotation() {\n    return this.getFrameRotation(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current frame valid, default is valid\n   * @getter\n   */\n  get currentFrameValid() {\n    return this.isFrameValid(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  get currentFrameAttributes() {\n    var _this$attributes$this;\n    const {\n      attributes = {}\n    } = ((_this$attributes$this = this.attributes[this.currentCamera]) === null || _this$attributes$this === void 0 ? void 0 : _this$attributes$this[this.currentFrame]) || {};\n    return attributes;\n  }\n\n  /**\n   * invalid frame indexes in summary\n   * @getter\n   */\n  get invalidFrames() {\n    const invalidFrames = new Set();\n    Object.values(this.attributes).forEach(frameAttrs => {\n      Object.keys(frameAttrs).forEach(frameIndexStr => {\n        const frameIndex = Number(frameIndexStr);\n        if (frameAttrs[frameIndex].valid === false) {\n          invalidFrames.add(frameIndex);\n        }\n      });\n    });\n    return Array.from(invalidFrames);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * camera frames\n     */\n    this.cameras = {};\n    /**\n     * project worker\n     */\n    this.camerasMapping = new CamerasMapping();\n    /**\n     * camera views\n     */\n    this.cameraViews = {};\n    /**\n     * current active camera\n     */\n    this.currentCameraView = null;\n    /**\n     * frame attributes\n     */\n    this.attributes = {};\n    /**\n     * next shape orders for different cameras & frames\n     */\n    this.nextShapeOrders = {};\n    /**\n     * current camera name\n     */\n    this.currentCamera = DEFAULT_CAMERA_NAME;\n    /**\n     * current frame index\n     */\n    this.currentFrame = 0;\n    /**\n     * frame loading\n     */\n    this.loading = true;\n    /**\n     * is playing\n     */\n    this.isPlaying = false;\n    /**\n     * play timer\n     */\n    this.playTimer = null;\n    /**\n     * image preloader\n     */\n    this.imagePreloader = null;\n    /**\n     * frame config\n     */\n    this.frameConfig = void 0;\n    makeAutoObservable(this, {\n      rootStore: false,\n      camerasMapping: false,\n      cameraViews: false,\n      nextShapeOrders: false,\n      playTimer: false,\n      imagePreloader: false,\n      imageBounds: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  async init(payload) {\n    const cameras = await parseFramesByPaylod(payload);\n    // parse frame config\n    this.frameConfig = parseLabelConfig(payload.frame_config);\n    // update attributes by camera & frames\n    const attributes = toJS(this.attributes);\n    cameras.forEach(({\n      camera,\n      frames,\n      calibrations\n    }) => {\n      if (!attributes[camera]) {\n        attributes[camera] = {};\n      }\n      frames.forEach((imageUrl, frameIndex) => {\n        if (!attributes[camera][frameIndex]) {\n          attributes[camera][frameIndex] = {\n            frameIndex,\n            valid: true,\n            rotation: 0\n          };\n        }\n        if (this.frameConfig) {\n          const {\n            updatedValues\n          } = triggerFormRules(this.frameConfig, attributes[camera][frameIndex].attributes || {});\n          if (!this.rootStore.readonly) {\n            // save to attributes directly\n            attributes[camera][frameIndex].attributes = {\n              ...updatedValues\n            };\n          } else {\n            // just show attribute keys if no value\n            Object.keys(updatedValues).forEach(key => {\n              if (!attributes[camera][frameIndex].attributes) {\n                attributes[camera][frameIndex].attributes = {};\n              }\n              if (attributes[camera][frameIndex].attributes[key] === undefined) {\n                attributes[camera][frameIndex].attributes[key] = '';\n              }\n            });\n          }\n        }\n      });\n      if (this.rootStore.config.projectMode !== ProjectMode.NONE) {\n        // set calibrations\n        this.camerasMapping.setCalibrations(camera, calibrations);\n      }\n    });\n    this.attributes = attributes;\n    if (this.rootStore.config.projectMode !== ProjectMode.NONE && !this.camerasMapping.projectEnabled) {\n      // set default calibrations\n      const defaultCalibs = {\n        model: ProjectModel.DEFAULT,\n        homography: [1, 0, 0, 0, 1, 0, 0, 0, 1]\n      };\n      cameras.forEach(({\n        camera\n      }) => {\n        this.camerasMapping.setCalibrations(camera, defaultCalibs);\n      });\n    }\n    runInAction(() => {\n      if (cameras.length > 0) {\n        // set cameras\n        this.cameras = cameras.reduce((acc, curr) => {\n          acc[curr.camera] = curr.frames;\n          return acc;\n        }, {});\n        // setup camera containers\n        cameras.forEach(({\n          camera\n        }) => this.createCameraView(camera));\n        // set current camera\n        this.setCamera(cameras[0].camera);\n        // preload image\n        const allImages = Array.from({\n          length: this.frameCount\n        }).flatMap((_, i) => cameras.map(c => c.frames[i]));\n        this.imagePreloader = loader(allImages);\n      }\n    });\n  }\n\n  /**\n   * init attributes\n   * @param attrs\n   */\n  initAttributes(attrs) {\n    if (Array.isArray(attrs)) {\n      const attributes = toJS(this.attributes);\n      attrs.forEach(cameraItem => {\n        const {\n          camera,\n          frames\n        } = cameraItem || {};\n        if (camera) {\n          if (!attributes[camera]) {\n            attributes[camera] = {};\n          }\n          if (Array.isArray(frames)) {\n            frames.forEach(frameItem => {\n              const {\n                frameIndex,\n                imageUrl,\n                imageWidth,\n                imageHeight,\n                valid,\n                rotation,\n                attributes: frameAttributes,\n                ...legacyAttributes\n              } = frameItem;\n              attributes[camera][frameIndex] = {\n                ...attributes[camera][frameIndex],\n                frameIndex,\n                imageUrl,\n                imageWidth,\n                imageHeight,\n                valid: valid !== false && valid !== 'false',\n                rotation: rotation % (Math.PI / 2) === 0 ? rotation : 0,\n                attributes: frameAttributes || Object.keys(legacyAttributes).length > 0 ? cloneDeep({\n                  ...legacyAttributes,\n                  ...frameAttributes\n                }) : undefined\n              };\n            });\n          }\n        }\n      });\n      this.attributes = attributes;\n    }\n  }\n\n  /**\n   * create camera view\n   * @param camera\n   */\n  createCameraView(camera) {\n    const {\n      validationConfig,\n      auxiliaryLines\n    } = this.rootStore.config;\n    const cameraView = new View({\n      id: camera,\n      enableReview: true,\n      enableCheck: !!validationConfig[ValidationType.EMPTY_AREA],\n      ...(auxiliaryLines && {\n        auxiliaryLines\n      })\n    });\n\n    // bind listeners\n    cameraView.on(EventAction.SELECTED, (event, view) => {\n      if (view !== this.currentCameraView) {\n        this.setCamera(view.id);\n      }\n      if (event.button === 2) {\n        return;\n      }\n      this.rootStore.shape.unselectShape();\n      this.rootStore.review.unselectReview();\n    });\n    cameraView.on(EventAction.POINTERDOWN, (p, event, view) => {\n      if (this.rootStore.shape.cuttingPolygon || this.rootStore.shape.splittingPolygn) {\n        return; // ignore click when cutting polygon or splitting polygon\n      }\n      if (event.button === 2) {\n        return;\n      }\n      if (this.rootStore.config.reviewMode === ReviewMode.LABELING) {\n        const shape = this.rootStore.shape.addShape(p);\n        if (shape) {\n          return;\n        }\n      } else {\n        const review = this.rootStore.review.addReview(p);\n        if (review) {\n          return;\n        }\n      }\n      if (this.rootStore.initialized && !this.rootStore.config.addMode && !this.rootStore.review.addMode) {\n        view.startSelect();\n      }\n    });\n    cameraView.on(EventAction.SCALE_CHANGED, scale => {\n      this.rootStore.config.setViewScale(scale, camera);\n    });\n    cameraView.on(EventAction.POSITION_CHANGED, () => {\n      this.rootStore.shape.redrawShapesLabel();\n    });\n    cameraView.on(EventAction.SHAPES_SELECTED, shapes => this.rootStore.shape.setSelectedShapes(shapes));\n    cameraView.on(EventAction.POINTS_SELECTED, points => this.rootStore.shape.setSelectedPoints(points));\n    this.cameraViews[camera] = cameraView;\n    return cameraView;\n  }\n\n  /**\n   * get image bounds for camera\n   * @param camera\n   */\n  getImageBoundsForCamera(camera) {\n    const cameraView = this.cameraViews[camera];\n    let w = cameraView === null || cameraView === void 0 ? void 0 : cameraView.image.width;\n    let h = cameraView === null || cameraView === void 0 ? void 0 : cameraView.image.height;\n    if ((cameraView === null || cameraView === void 0 ? void 0 : cameraView.imageRotation) % Math.PI !== 0) {\n      w = cameraView === null || cameraView === void 0 ? void 0 : cameraView.image.height;\n      h = cameraView === null || cameraView === void 0 ? void 0 : cameraView.image.width;\n    }\n    return {\n      left: 0,\n      top: 0,\n      right: w || 0,\n      bottom: h || 0\n    };\n  }\n\n  /**\n   * set current camera\n   * @param camera\n   */\n  setCamera(camera) {\n    if (this.rootStore.shape.drawingShape || this.rootStore.shape.cuttingPolygon) {\n      return;\n    }\n    // cancel working status\n    this.rootStore.cancelShapeWorking();\n    // reset camera selected status\n    if (this.currentCameraView) {\n      this.currentCameraView.selected = false;\n    }\n    // set selected camera\n    this.currentCamera = camera;\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.selected = true;\n      this.currentCameraView = cameraView;\n      this.updateCameraLayers(cameraView);\n    }\n    // update shapes selected status\n    const {\n      selectedInstances\n    } = this.rootStore.instance;\n    this.rootStore.instance.selectInstanceItem(null);\n    this.rootStore.instance.selectInstance(selectedInstances);\n  }\n\n  /**\n   * update working layers by camera view\n   * @param cameraView\n   */\n  updateCameraLayers(cameraView) {\n    // update view scale\n    this.rootStore.config.setViewScale(cameraView.viewScale);\n    // update shapes layer\n    this.rootStore.shape.currentLayer = cameraView.shapesLayer;\n    // update review layer\n    if (cameraView.reviewLayer) {\n      this.rootStore.review.setReviewLayer(cameraView.reviewLayer);\n      this.rootStore.review.setReviewLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n  }\n\n  /**\n   * set current frame\n   * @param frameIndex\n   */\n  setFrame(frameIndex) {\n    if (frameIndex !== this.currentFrame) {\n      // frame changes\n      this.currentFrame = frameIndex;\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        this.loading = true;\n        this.rootStore.review.clearAnchors();\n      }\n    }\n  }\n\n  /**\n   * when frame loaded\n   * @param image\n   */\n  onFrameLoaded() {\n    var _this$imagePreloader;\n    this.camerasMapping.setFrame(this.currentFrame);\n\n    // turn off add mode\n    this.rootStore.config.setAddMode(false);\n    // setup current shapes\n    this.rootStore.shape.setupShapes();\n    // select shape\n    const {\n      selectedInstanceItems,\n      selectedInstances\n    } = this.rootStore.instance;\n    if (selectedInstanceItems.length > 0) {\n      this.rootStore.shape.selectShapeByInstanceItem(selectedInstanceItems);\n    } else if (selectedInstances.length > 0) {\n      this.rootStore.shape.updateShapesInInstance(selectedInstances);\n    }\n    // predict\n    this.rootStore.shape.predict();\n\n    // setup relationships\n    this.rootStore.relationship.setupConnections();\n\n    // setup reivew anchors\n    this.rootStore.review.setupReviewAnchors();\n\n    // if sole mode\n    this.rootStore.shape.hideOrShowOthers();\n\n    // redraw empty area\n    this.rootStore.validation.redrawEmptyArea();\n    this.loading = false;\n\n    // preload image\n    (_this$imagePreloader = this.imagePreloader) === null || _this$imagePreloader === void 0 ? void 0 : _this$imagePreloader.preload((this.currentFrame + 1) * this.cameraCount);\n\n    // when loaded, if is auto playing, play next frame\n    if (this.isPlaying) {\n      this.playTimer = window.setTimeout(() => {\n        this.setFrameByAutoPlay();\n      }, 300);\n    }\n  }\n\n  /**\n   * go to previous frame by step\n   * @param step\n   */\n  prev(step) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.max(this.currentFrame - step, 0));\n    }\n  }\n\n  /**\n   * go to next frame by step\n   * @param step\n   */\n  next(step) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.min(this.currentFrame + step, this.frameCount - 1));\n    }\n  }\n\n  /**\n   * toggle playing\n   */\n  togglePlaying() {\n    this.isPlaying = !this.isPlaying;\n    if (this.isPlaying) {\n      this.setFrameByAutoPlay();\n    } else if (this.playTimer) {\n      window.clearTimeout(this.playTimer);\n      this.playTimer = null;\n    }\n  }\n\n  /**\n   * set frame by auto play\n   */\n  setFrameByAutoPlay() {\n    if (this.currentFrame < this.frameCount - 1) {\n      this.setFrame(this.currentFrame + 1);\n    } else {\n      this.setFrame(0);\n      this.isPlaying = false;\n    }\n  }\n\n  /**\n   * can update attributes by camera & frameIndex\n   * @param camera\n   * @param frameIndex\n   */\n  canUpdateFrame(camera, frameIndex) {\n    if (this.rootStore.readonly) {\n      return false;\n    }\n    if (!this.attributes[camera] || !this.attributes[camera][frameIndex]) {\n      // attributes not initialized as expected, may have wrong frames or base_url input\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * get frame rotation\n   * @param camera\n   * @param frameIndex\n   */\n  getFrameRotation(camera, frameIndex) {\n    if (!this.attributes[camera]) {\n      return 0;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return 0;\n    }\n    return this.attributes[camera][frameIndex].rotation || 0;\n  }\n\n  /**\n   * set frame rotation\n   * @param camera\n   * @param frameIndex\n   * @param rotation\n   */\n  setFrameRotation(camera, frameIndex, rotation) {\n    if (!this.canUpdateFrame(camera, frameIndex)) {\n      return;\n    }\n\n    // calc rotation diff\n    let diff = rotation - this.currentFrameRotation;\n    if (diff > Math.PI) {\n      diff -= Math.PI * 2;\n    } else if (diff <= -Math.PI) {\n      diff += Math.PI * 2;\n    }\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = this.imageBounds;\n    const imageWidth = right - left;\n    const imageHeight = bottom - top;\n    const LTPoint = {\n      x: left,\n      y: top\n    };\n    const rotatedLTPoint = {\n      ...LTPoint\n    };\n    if (diff === -Math.PI / 2) {\n      // anti-clockwise 90 degrees\n      rotatedLTPoint.y -= imageWidth;\n    } else if (diff === Math.PI) {\n      // anti-clockwise 180 degrees\n      rotatedLTPoint.x -= imageWidth;\n      rotatedLTPoint.y -= imageHeight;\n    } else if (diff === Math.PI / 2) {\n      // anti-clockwise 270 degrees\n      rotatedLTPoint.x -= imageHeight;\n    }\n\n    // rotate shapes\n    const {\n      prevState,\n      currState\n    } = this.rootStore.shape.rotateShapesByCanvas(diff, LTPoint, rotatedLTPoint.x, rotatedLTPoint.y);\n\n    // save rotation\n    const storeId = this.rootStore.undo.preserve({\n      ...prevState,\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n    this.attributes[camera][frameIndex].rotation = rotation;\n    this.rootStore.undo.save(storeId, {\n      ...currState,\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n\n    // set rotation for camera view\n    this.cameraViews[camera].imageRotation = rotation;\n    this.cameraViews[camera].rotate();\n    // update shapes bounds\n    this.rootStore.shape.updateShapesBounds();\n  }\n\n  /**\n   * is frame valid\n   * @param camera\n   * @param frameIndex\n   */\n  isFrameValid(camera, frameIndex) {\n    if (!this.attributes[camera]) {\n      return true;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return true;\n    }\n    return this.attributes[camera][frameIndex].valid !== false;\n  }\n\n  /**\n   * set frame valid\n   * @param camera\n   * @param frameIndex\n   * @param valid\n   */\n  setFrameValid(camera, frameIndex, valid) {\n    if (!this.canUpdateFrame(camera, frameIndex)) {\n      return;\n    }\n    const storeId = this.rootStore.undo.preserve({\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n    this.attributes[camera][frameIndex].valid = valid;\n    this.rootStore.undo.save(storeId, {\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n  }\n\n  /**\n   * set frame attributes\n   * @param camera\n   * @param frameIndex\n   * @param frameAttributes\n   */\n  setFrameAttributes(camera, frames, attributes, applyAllFields = [], isApplyAllAttributes) {\n    const currentFramesData = [];\n    const newFramesData = [];\n    const applyValues = {};\n    applyAllFields.forEach(field => {\n      applyValues[field] = attributes[field];\n    });\n    frames.sort((a, b) => a - b).forEach((frameIndex, i) => {\n      if (this.canUpdateFrame(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        if (isApplyAllAttributes || i === 0) {\n          this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n        } else {\n          this.attributes[camera][frameIndex].attributes = {\n            ...toJS(this.attributes[camera][frameIndex].attributes),\n            ...applyValues\n          };\n        }\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{\n          camera,\n          frames: currentFramesData\n        }]\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{\n          camera,\n          frames: newFramesData\n        }]\n      });\n    }\n  }\n\n  /**\n   * set frame attributes & frame valid\n   * @param camera\n   * @param frames\n   * @param attributes\n   * @param applyAllFields\n   * @param valid\n   * @param applyValid\n   * @param isApplyAllAttributes\n   */\n  setFrameAttributesWithValid(camera, frames, attributes, applyAllFields = [], valid, applyValid, isApplyAllAttributes) {\n    const currentFramesData = [];\n    const newFramesData = [];\n    const applyValues = {};\n    applyAllFields.forEach(field => {\n      applyValues[field] = attributes[field];\n    });\n    frames.sort((a, b) => a - b).forEach((frameIndex, i) => {\n      if (this.canUpdateFrame(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        if (isApplyAllAttributes || i === 0) {\n          this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n          this.attributes[camera][frameIndex].valid = valid;\n        } else {\n          this.attributes[camera][frameIndex].attributes = {\n            ...toJS(this.attributes[camera][frameIndex].attributes),\n            ...applyValues\n          };\n          if (applyValid) {\n            this.attributes[camera][frameIndex].valid = valid;\n          }\n        }\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{\n          camera,\n          frames: currentFramesData\n        }]\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{\n          camera,\n          frames: newFramesData\n        }]\n      });\n    }\n  }\n\n  /**\n   * get next shape order & do increment\n   * @param frameIndex\n   * @param camera\n   */\n  getNextShapeOrder(frameIndex = this.currentFrame, camera = this.currentCamera) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n      this.nextShapeOrders[camera][frameIndex] = 0;\n    }\n    const order = this.nextShapeOrders[camera][frameIndex];\n    this.nextShapeOrders[camera][frameIndex] += 1;\n    return order;\n  }\n\n  /**\n   * update next shape order\n   * @param currentOrder\n   * @param frameIndex\n   * @param camera\n   */\n  updateNextShapeOrder(currentOrder, frameIndex = this.currentFrame, camera = this.currentCamera) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined || this.nextShapeOrders[camera][frameIndex] <= currentOrder) {\n      this.nextShapeOrders[camera][frameIndex] = currentOrder + 1;\n    }\n  }\n\n  /**\n   * fix image size if no image width & height\n   */\n  async fixImageSize(showMsg = true) {\n    const noSizeFrames = [];\n    const cameras = Object.keys(this.cameras);\n    for (let i = 0; i < cameras.length; i += 1) {\n      const camera = cameras[i];\n      const cameraFrames = this.cameras[camera];\n      for (let j = 0; j < cameraFrames.length; j += 1) {\n        const {\n          imageWidth,\n          imageHeight\n        } = this.attributes[camera][j];\n        if (imageWidth === undefined || imageHeight === undefined) {\n          noSizeFrames.push({\n            camera,\n            frameIndex: j,\n            imageUrl: cameraFrames[j]\n          });\n        }\n      }\n    }\n    if (noSizeFrames.length <= 0) {\n      Promise.resolve();\n      return;\n    }\n    const count = noSizeFrames.length;\n    let hide;\n    if (showMsg) {\n      hide = message.loading({\n        key: 'loading',\n        duration: 0,\n        content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', {\n          values: {\n            count,\n            finished: 0\n          }\n        })\n      });\n    }\n    return new Promise(resolve => {\n      const queue = [];\n      let finished = 0;\n      let i = 0;\n      const loadImageSize = ({\n        camera,\n        frameIndex,\n        imageUrl\n      }) => {\n        const finish = () => {\n          finished += 1;\n          if (showMsg) {\n            message.loading({\n              key: 'loading',\n              duration: 0,\n              content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', {\n                values: {\n                  count,\n                  finished\n                }\n              })\n            });\n          }\n          if (finished === count) {\n            if (hide) {\n              hide();\n            }\n            resolve();\n          } else if (i < count - 1) {\n            i += 1;\n            queue.shift();\n            loadImageSize(noSizeFrames[i]);\n          }\n        };\n        const img = new Image();\n        img.onload = () => {\n          this.updateImageSize(camera, frameIndex, img.width, img.height);\n          finish();\n        };\n        img.onerror = () => {\n          this.updateImageSize(camera, frameIndex, -1, -1);\n          finish();\n        };\n        img.src = imageUrl;\n        queue.push(imageUrl);\n        if (queue.length < 10 && i < count - 1) {\n          i += 1;\n          loadImageSize(noSizeFrames[i]);\n        }\n      };\n      loadImageSize(noSizeFrames[i]);\n    });\n  }\n\n  /**\n   * update image size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  updateImageSize(camera, frameIndex, width, height) {\n    if (this.attributes[camera] && this.attributes[camera][frameIndex]) {\n      const {\n        imageWidth,\n        imageHeight\n      } = this.attributes[camera][frameIndex];\n      if (width > 0 && height > 0 || imageWidth === undefined || imageHeight === undefined) {\n        // only update when size valid, or size not initialized\n        this.attributes[camera][frameIndex].imageWidth = width;\n        this.attributes[camera][frameIndex].imageHeight = height;\n        this.camerasMapping.setCameraSize(camera, frameIndex, width, height);\n      }\n    }\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  framesJSON() {\n    return Object.keys(this.cameras).map(camera => ({\n      camera,\n      frames: this.cameras[camera].map((imageUrl, frameIndex) => ({\n        frameIndex,\n        imageUrl,\n        imageWidth: this.attributes[camera][frameIndex].imageWidth,\n        imageHeight: this.attributes[camera][frameIndex].imageHeight,\n        valid: this.isFrameValid(camera, frameIndex),\n        rotation: this.getFrameRotation(camera, frameIndex),\n        attributes: toJS(this.attributes[camera][frameIndex].attributes)\n      }))\n    }));\n  }\n}","map":{"version":3,"names":["makeAutoObservable","runInAction","toJS","cloneDeep","message","CamerasMapping","View","EventAction","DEFAULT_CAMERA_NAME","SIDEBAR_WIDTH","TOOLBAR_HEIGHT","parseFramesByPaylod","parseLabelConfig","ViewMode","ValidationType","ReviewMode","ProjectMode","i18n","loader","triggerFormRules","ProjectModel","FrameStore","isSingleCamera","cameraNames","Object","keys","cameras","length","cameraCount","frames","currentCamera","frameCount","imageBounds","getImageBoundsForCamera","currentFrameRotation","getFrameRotation","currentFrame","currentFrameValid","isFrameValid","currentFrameAttributes","_this$attributes$this","attributes","invalidFrames","Set","values","forEach","frameAttrs","frameIndexStr","frameIndex","Number","valid","add","Array","from","constructor","rootStore","camerasMapping","cameraViews","currentCameraView","nextShapeOrders","loading","isPlaying","playTimer","imagePreloader","frameConfig","autoBind","init","payload","frame_config","camera","calibrations","imageUrl","rotation","updatedValues","readonly","key","undefined","config","projectMode","NONE","setCalibrations","projectEnabled","defaultCalibs","model","DEFAULT","homography","reduce","acc","curr","createCameraView","setCamera","allImages","flatMap","_","i","map","c","initAttributes","attrs","isArray","cameraItem","frameItem","imageWidth","imageHeight","frameAttributes","legacyAttributes","Math","PI","validationConfig","auxiliaryLines","cameraView","id","enableReview","enableCheck","EMPTY_AREA","on","SELECTED","event","view","button","shape","unselectShape","review","unselectReview","POINTERDOWN","p","cuttingPolygon","splittingPolygn","reviewMode","LABELING","addShape","addReview","initialized","addMode","startSelect","SCALE_CHANGED","scale","setViewScale","POSITION_CHANGED","redrawShapesLabel","SHAPES_SELECTED","shapes","setSelectedShapes","POINTS_SELECTED","points","setSelectedPoints","w","image","width","h","height","imageRotation","left","top","right","bottom","drawingShape","cancelShapeWorking","selected","updateCameraLayers","selectedInstances","instance","selectInstanceItem","selectInstance","viewScale","currentLayer","shapesLayer","reviewLayer","setReviewLayer","setReviewLayerOffset","setFrame","viewMode","clearAnchors","onFrameLoaded","_this$imagePreloader","setAddMode","setupShapes","selectedInstanceItems","selectShapeByInstanceItem","updateShapesInInstance","predict","relationship","setupConnections","setupReviewAnchors","hideOrShowOthers","validation","redrawEmptyArea","preload","window","setTimeout","setFrameByAutoPlay","prev","step","max","next","min","togglePlaying","clearTimeout","canUpdateFrame","setFrameRotation","diff","LTPoint","x","y","rotatedLTPoint","prevState","currState","rotateShapesByCanvas","storeId","undo","preserve","save","rotate","updateShapesBounds","setFrameValid","setFrameAttributes","applyAllFields","isApplyAllAttributes","currentFramesData","newFramesData","applyValues","field","sort","a","b","push","setFrameAttributesWithValid","applyValid","getNextShapeOrder","order","updateNextShapeOrder","currentOrder","fixImageSize","showMsg","noSizeFrames","cameraFrames","j","Promise","resolve","count","hide","duration","content","translate","finished","queue","loadImageSize","finish","shift","img","Image","onload","updateImageSize","onerror","src","setCameraSize","framesJSON"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/FrameStore.ts"],"sourcesContent":["import { makeAutoObservable, runInAction, toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport { message } from 'antd';\nimport { MessageType } from 'antd/es/message';\nimport RootStore from './RootStore';\nimport CamerasMapping from '../cameras-mapping/CamerasMapping';\nimport View, { EventAction } from '../shapes/View';\nimport { DEFAULT_CAMERA_NAME, SIDEBAR_WIDTH, TOOLBAR_HEIGHT } from '../constants';\nimport { parseFramesByPaylod, parseLabelConfig } from '../utils';\nimport { Payload, FrameAttributes, CameraFrameAttributes, ViewMode, LabelConfig, ValidationType, ReviewMode, ProjectMode } from '../types';\nimport i18n from '../locales';\nimport loader, { ImagePreloader } from '../../../utils/image-preloader';\nimport { triggerFormRules } from '../../../utils/form';\nimport { ProjectModel } from '../cameras-mapping/types';\n\n/**\n * store for frames\n * @class\n */\nexport default class FrameStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * camera frames\n   */\n  cameras: { [camera: string]: string[] } = {};\n\n  /**\n   * project worker\n   */\n  camerasMapping = new CamerasMapping();\n\n  /**\n   * camera views\n   */\n  cameraViews: { [camera: string]: View } = {};\n\n  /**\n   * current active camera\n   */\n  currentCameraView: View | null = null;\n\n  /**\n   * frame attributes\n   */\n  attributes: {\n    [camera: string]: {\n      [frameIndex: number]: FrameAttributes;\n    }\n  } = {};\n\n  /**\n   * next shape orders for different cameras & frames\n   */\n  nextShapeOrders: {\n    [camera: string]: {\n      [frameIndex: number]: number;\n    }\n  } = {};\n\n  /**\n   * current camera name\n   */\n  currentCamera = DEFAULT_CAMERA_NAME;\n\n  /**\n   * current frame index\n   */\n  currentFrame = 0;\n\n  /**\n   * frame loading\n   */\n  loading = true;\n\n  /**\n   * is playing\n   */\n  isPlaying = false;\n\n  /**\n   * play timer\n   */\n  playTimer: number | null = null;\n\n  /**\n   * image preloader\n   */\n  imagePreloader: ImagePreloader | null = null;\n\n  /**\n   * frame config\n   */\n  frameConfig?: LabelConfig;\n\n  /**\n   * is single camera\n   * @getter\n   */\n  get isSingleCamera() {\n    const cameraNames = Object.keys(this.cameras);\n    return cameraNames.length === 1;\n  }\n\n  /**\n   * camera names\n   * @getter\n   */\n  get cameraNames() {\n    return Object.keys(this.cameras);\n  }\n\n  /**\n   * camera count\n   * @getter\n   */\n  get cameraCount() {\n    return Object.keys(this.cameras).length;\n  }\n\n  /**\n   * current cameras frames\n   * @getter\n   */\n  get frames() {\n    return this.cameras[this.currentCamera] || [];\n  }\n\n  /**\n   * current camera frame count\n   * @getter\n   */\n  get frameCount() {\n    return this.frames.length;\n  }\n\n  /**\n   * image boundary\n   * @getter\n   */\n  get imageBounds() {\n    return this.getImageBoundsForCamera(this.currentCamera);\n  }\n\n  /**\n   * current frame rotation, default is 0\n   * @getter\n   */\n  get currentFrameRotation() {\n    return this.getFrameRotation(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current frame valid, default is valid\n   * @getter\n   */\n  get currentFrameValid() {\n    return this.isFrameValid(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  get currentFrameAttributes() {\n    const { attributes = {} } = this.attributes[this.currentCamera]?.[this.currentFrame] || {};\n    return attributes;\n  }\n\n  /**\n   * invalid frame indexes in summary\n   * @getter\n   */\n  get invalidFrames() {\n    const invalidFrames = new Set<number>();\n    Object.values(this.attributes).forEach((frameAttrs) => {\n      Object.keys(frameAttrs).forEach((frameIndexStr) => {\n        const frameIndex = Number(frameIndexStr);\n        if (frameAttrs[frameIndex].valid === false) {\n          invalidFrames.add(frameIndex);\n        }\n      });\n    });\n    return Array.from(invalidFrames);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      camerasMapping: false,\n      cameraViews: false,\n      nextShapeOrders: false,\n      playTimer: false,\n      imagePreloader: false,\n      imageBounds: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  async init(payload: Payload) {\n    const cameras = await parseFramesByPaylod(payload);\n    // parse frame config\n    this.frameConfig = parseLabelConfig(payload.frame_config);\n    // update attributes by camera & frames\n    const attributes = toJS(this.attributes);\n    cameras.forEach(({ camera, frames, calibrations }) => {\n      if (!attributes[camera]) {\n        attributes[camera] = {};\n      }\n      frames.forEach((imageUrl, frameIndex) => {\n        if (!attributes[camera][frameIndex]) {\n          attributes[camera][frameIndex] = {\n            frameIndex,\n            valid: true,\n            rotation: 0,\n          };\n        }\n        if (this.frameConfig) {\n          const { updatedValues } = triggerFormRules(this.frameConfig, attributes[camera][frameIndex].attributes || {});\n          if (!this.rootStore.readonly) {\n            // save to attributes directly\n            attributes[camera][frameIndex].attributes = { ...updatedValues };\n          } else {\n            // just show attribute keys if no value\n            Object.keys(updatedValues).forEach((key) => {\n              if (!attributes[camera][frameIndex].attributes) {\n                attributes[camera][frameIndex].attributes = {};\n              }\n              if (attributes[camera][frameIndex].attributes[key] === undefined) {\n                attributes[camera][frameIndex].attributes[key] = '';\n              }\n            });\n          }\n        }\n      });\n\n      if (this.rootStore.config.projectMode !== ProjectMode.NONE) {\n        // set calibrations\n        this.camerasMapping.setCalibrations(camera, calibrations);\n      }\n    });\n    this.attributes = attributes;\n    if (this.rootStore.config.projectMode !== ProjectMode.NONE && !this.camerasMapping.projectEnabled) {\n      // set default calibrations\n      const defaultCalibs = {\n        model: ProjectModel.DEFAULT,\n        homography: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n      };\n      cameras.forEach(({ camera }) => {\n        this.camerasMapping.setCalibrations(camera, defaultCalibs);\n      });\n    }\n    runInAction(() => {\n      if (cameras.length > 0) {\n        // set cameras\n        this.cameras = cameras.reduce((acc, curr) => {\n          acc[curr.camera] = curr.frames;\n          return acc;\n        }, {} as { [camera: string]: string[] });\n        // setup camera containers\n        cameras.forEach(({ camera }) => this.createCameraView(camera));\n        // set current camera\n        this.setCamera(cameras[0].camera);\n        // preload image\n        const allImages = Array.from({ length: this.frameCount }).flatMap((_, i) => cameras.map((c) => c.frames[i]));\n        this.imagePreloader = loader(allImages);\n      }\n    });\n  }\n\n  /**\n   * init attributes\n   * @param attrs\n   */\n  initAttributes(attrs: any) {\n    if (Array.isArray(attrs)) {\n      const attributes = toJS(this.attributes);\n\n      attrs.forEach((cameraItem) => {\n        const { camera, frames } = cameraItem || {};\n        if (camera) {\n          if (!attributes[camera]) {\n            attributes[camera] = {};\n          }\n          if (Array.isArray(frames)) {\n            frames.forEach((frameItem) => {\n              const { frameIndex, imageUrl, imageWidth, imageHeight, valid, rotation, attributes: frameAttributes, ...legacyAttributes } = frameItem;\n              attributes[camera][frameIndex] = {\n                ...attributes[camera][frameIndex],\n                frameIndex,\n                imageUrl,\n                imageWidth,\n                imageHeight,\n                valid: valid !== false && valid !== 'false',\n                rotation: rotation % (Math.PI / 2) === 0 ? rotation : 0,\n                attributes: frameAttributes || Object.keys(legacyAttributes).length > 0 ? cloneDeep({ ...legacyAttributes, ...frameAttributes }) : undefined,\n              };\n            });\n          }\n        }\n      });\n\n      this.attributes = attributes;\n    }\n  }\n\n  /**\n   * create camera view\n   * @param camera\n   */\n  createCameraView(camera: string) {\n    const { validationConfig, auxiliaryLines } = this.rootStore.config;\n    const cameraView = new View({\n      id: camera,\n      enableReview: true,\n      enableCheck: !!validationConfig[ValidationType.EMPTY_AREA],\n      ...auxiliaryLines && { auxiliaryLines },\n    });\n\n    // bind listeners\n    cameraView.on(EventAction.SELECTED, (event, view) => {\n      if (view !== this.currentCameraView) {\n        this.setCamera(view.id);\n      }\n      if (event.button === 2) {\n        return;\n      }\n      this.rootStore.shape.unselectShape();\n      this.rootStore.review.unselectReview();\n    });\n    cameraView.on(EventAction.POINTERDOWN, (p, event, view) => {\n      if (this.rootStore.shape.cuttingPolygon || this.rootStore.shape.splittingPolygn) {\n        return; // ignore click when cutting polygon or splitting polygon\n      }\n      if (event.button === 2) {\n        return;\n      }\n      if (this.rootStore.config.reviewMode === ReviewMode.LABELING) {\n        const shape = this.rootStore.shape.addShape(p);\n        if (shape) {\n          return;\n        }\n      } else {\n        const review = this.rootStore.review.addReview(p);\n        if (review) {\n          return;\n        }\n      }\n      if (this.rootStore.initialized && !this.rootStore.config.addMode && !this.rootStore.review.addMode) {\n        view.startSelect();\n      }\n    });\n    cameraView.on(EventAction.SCALE_CHANGED, (scale) => {\n      this.rootStore.config.setViewScale(scale, camera);\n    });\n    cameraView.on(EventAction.POSITION_CHANGED, () => {\n      this.rootStore.shape.redrawShapesLabel();\n    });\n    cameraView.on(EventAction.SHAPES_SELECTED, (shapes) => this.rootStore.shape.setSelectedShapes(shapes));\n    cameraView.on(EventAction.POINTS_SELECTED, (points) => this.rootStore.shape.setSelectedPoints(points));\n\n    this.cameraViews[camera] = cameraView;\n    return cameraView;\n  }\n\n  /**\n   * get image bounds for camera\n   * @param camera\n   */\n  getImageBoundsForCamera(camera: string) {\n    const cameraView = this.cameraViews[camera];\n    let w = cameraView?.image.width;\n    let h = cameraView?.image.height;\n    if (cameraView?.imageRotation % Math.PI !== 0) {\n      w = cameraView?.image.height;\n      h = cameraView?.image.width;\n    }\n    return { left: 0, top: 0, right: w || 0, bottom: h || 0 };\n  }\n\n  /**\n   * set current camera\n   * @param camera\n   */\n  setCamera(camera: string) {\n    if (this.rootStore.shape.drawingShape || this.rootStore.shape.cuttingPolygon) {\n      return;\n    }\n    // cancel working status\n    this.rootStore.cancelShapeWorking();\n    // reset camera selected status\n    if (this.currentCameraView) {\n      this.currentCameraView.selected = false;\n    }\n    // set selected camera\n    this.currentCamera = camera;\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.selected = true;\n      this.currentCameraView = cameraView;\n      this.updateCameraLayers(cameraView);\n    }\n    // update shapes selected status\n    const { selectedInstances } = this.rootStore.instance;\n    this.rootStore.instance.selectInstanceItem(null);\n    this.rootStore.instance.selectInstance(selectedInstances);\n  }\n\n  /**\n   * update working layers by camera view\n   * @param cameraView\n   */\n  updateCameraLayers(cameraView: View) {\n    // update view scale\n    this.rootStore.config.setViewScale(cameraView.viewScale);\n    // update shapes layer\n    this.rootStore.shape.currentLayer = cameraView.shapesLayer;\n    // update review layer\n    if (cameraView.reviewLayer) {\n      this.rootStore.review.setReviewLayer(cameraView.reviewLayer);\n      this.rootStore.review.setReviewLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n  }\n\n  /**\n   * set current frame\n   * @param frameIndex\n   */\n  setFrame(frameIndex: number) {\n    if (frameIndex !== this.currentFrame) {\n      // frame changes\n      this.currentFrame = frameIndex;\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        this.loading = true;\n        this.rootStore.review.clearAnchors();\n      }\n    }\n  }\n\n  /**\n   * when frame loaded\n   * @param image\n   */\n  onFrameLoaded() {\n    this.camerasMapping.setFrame(this.currentFrame);\n\n    // turn off add mode\n    this.rootStore.config.setAddMode(false);\n    // setup current shapes\n    this.rootStore.shape.setupShapes();\n    // select shape\n    const { selectedInstanceItems, selectedInstances } = this.rootStore.instance;\n    if (selectedInstanceItems.length > 0) {\n      this.rootStore.shape.selectShapeByInstanceItem(selectedInstanceItems);\n    } else if (selectedInstances.length > 0) {\n      this.rootStore.shape.updateShapesInInstance(selectedInstances);\n    }\n    // predict\n    this.rootStore.shape.predict();\n\n    // setup relationships\n    this.rootStore.relationship.setupConnections();\n\n    // setup reivew anchors\n    this.rootStore.review.setupReviewAnchors();\n\n    // if sole mode\n    this.rootStore.shape.hideOrShowOthers();\n\n    // redraw empty area\n    this.rootStore.validation.redrawEmptyArea();\n\n    this.loading = false;\n\n    // preload image\n    this.imagePreloader?.preload((this.currentFrame + 1) * this.cameraCount);\n\n    // when loaded, if is auto playing, play next frame\n    if (this.isPlaying) {\n      this.playTimer = window.setTimeout(() => {\n        this.setFrameByAutoPlay();\n      }, 300);\n    }\n  }\n\n  /**\n   * go to previous frame by step\n   * @param step\n   */\n  prev(step: number) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.max(this.currentFrame - step, 0));\n    }\n  }\n\n  /**\n   * go to next frame by step\n   * @param step\n   */\n  next(step: number) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.min(this.currentFrame + step, this.frameCount - 1));\n    }\n  }\n\n  /**\n   * toggle playing\n   */\n  togglePlaying() {\n    this.isPlaying = !this.isPlaying;\n    if (this.isPlaying) {\n      this.setFrameByAutoPlay();\n    } else if (this.playTimer) {\n      window.clearTimeout(this.playTimer);\n      this.playTimer = null;\n    }\n  }\n\n  /**\n   * set frame by auto play\n   */\n  setFrameByAutoPlay() {\n    if (this.currentFrame < this.frameCount - 1) {\n      this.setFrame(this.currentFrame + 1);\n    } else {\n      this.setFrame(0);\n      this.isPlaying = false;\n    }\n  }\n\n  /**\n   * can update attributes by camera & frameIndex\n   * @param camera\n   * @param frameIndex\n   */\n  canUpdateFrame(camera: string, frameIndex: number) {\n    if (this.rootStore.readonly) {\n      return false;\n    }\n    if (!this.attributes[camera] || !this.attributes[camera][frameIndex]) {\n      // attributes not initialized as expected, may have wrong frames or base_url input\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * get frame rotation\n   * @param camera\n   * @param frameIndex\n   */\n  getFrameRotation(camera: string, frameIndex: number) {\n    if (!this.attributes[camera]) {\n      return 0;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return 0;\n    }\n    return this.attributes[camera][frameIndex].rotation || 0;\n  }\n\n  /**\n   * set frame rotation\n   * @param camera\n   * @param frameIndex\n   * @param rotation\n   */\n  setFrameRotation(camera: string, frameIndex: number, rotation: number) {\n    if (!this.canUpdateFrame(camera, frameIndex)) {\n      return;\n    }\n\n    // calc rotation diff\n    let diff = rotation - this.currentFrameRotation;\n    if (diff > Math.PI) {\n      diff -= Math.PI * 2;\n    } else if (diff <= -Math.PI) {\n      diff += Math.PI * 2;\n    }\n\n    const { left, top, right, bottom } = this.imageBounds;\n    const imageWidth = right - left;\n    const imageHeight = bottom - top;\n    const LTPoint = { x: left, y: top };\n    const rotatedLTPoint = { ...LTPoint };\n    if (diff === -Math.PI / 2) {\n      // anti-clockwise 90 degrees\n      rotatedLTPoint.y -= imageWidth;\n    } else if (diff === Math.PI) {\n      // anti-clockwise 180 degrees\n      rotatedLTPoint.x -= imageWidth;\n      rotatedLTPoint.y -= imageHeight;\n    } else if (diff === Math.PI / 2) {\n      // anti-clockwise 270 degrees\n      rotatedLTPoint.x -= imageHeight;\n    }\n\n    // rotate shapes\n    const { prevState, currState } = this.rootStore.shape.rotateShapesByCanvas(diff, LTPoint, rotatedLTPoint.x, rotatedLTPoint.y);\n\n    // save rotation\n    const storeId = this.rootStore.undo.preserve({\n      ...prevState,\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n    this.attributes[camera][frameIndex].rotation = rotation;\n    this.rootStore.undo.save(storeId, {\n      ...currState,\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n\n    // set rotation for camera view\n    this.cameraViews[camera].imageRotation = rotation;\n    this.cameraViews[camera].rotate();\n    // update shapes bounds\n    this.rootStore.shape.updateShapesBounds();\n  }\n\n  /**\n   * is frame valid\n   * @param camera\n   * @param frameIndex\n   */\n  isFrameValid(camera: string, frameIndex: number) {\n    if (!this.attributes[camera]) {\n      return true;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return true;\n    }\n    return this.attributes[camera][frameIndex].valid !== false;\n  }\n\n  /**\n   * set frame valid\n   * @param camera\n   * @param frameIndex\n   * @param valid\n   */\n  setFrameValid(camera: string, frameIndex: number, valid: boolean) {\n    if (!this.canUpdateFrame(camera, frameIndex)) {\n      return;\n    }\n\n    const storeId = this.rootStore.undo.preserve({\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n    this.attributes[camera][frameIndex].valid = valid;\n    this.rootStore.undo.save(storeId, {\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n  }\n\n  /**\n   * set frame attributes\n   * @param camera\n   * @param frameIndex\n   * @param frameAttributes\n   */\n  setFrameAttributes(camera: string, frames: number[], attributes: any, applyAllFields: string[] = [], isApplyAllAttributes?: boolean) {\n    const currentFramesData: FrameAttributes[] = [];\n    const newFramesData: FrameAttributes[] = [];\n    const applyValues:{[key: string]: any} = {};\n    applyAllFields.forEach((field) => {\n      applyValues[field] = attributes[field];\n    });\n    frames.sort((a, b) => a - b).forEach((frameIndex, i) => {\n      if (this.canUpdateFrame(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        if (isApplyAllAttributes || i === 0) {\n          this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n        } else {\n          this.attributes[camera][frameIndex].attributes = {\n            ...toJS(this.attributes[camera][frameIndex].attributes),\n            ...applyValues\n          };\n        }\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{ camera, frames: currentFramesData }],\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{ camera, frames: newFramesData }],\n      });\n    }\n  }\n\n  /**\n   * set frame attributes & frame valid\n   * @param camera\n   * @param frames\n   * @param attributes\n   * @param applyAllFields\n   * @param valid\n   * @param applyValid\n   * @param isApplyAllAttributes\n   */\n  setFrameAttributesWithValid(\n    camera: string,\n    frames: number[],\n    attributes: any,\n    applyAllFields: string[] = [],\n    valid: boolean,\n    applyValid: boolean,\n    isApplyAllAttributes?: boolean,\n  ) {\n    const currentFramesData: FrameAttributes[] = [];\n    const newFramesData: FrameAttributes[] = [];\n    const applyValues:{[key: string]: any} = {};\n    applyAllFields.forEach((field) => {\n      applyValues[field] = attributes[field];\n    });\n    frames.sort((a, b) => a - b).forEach((frameIndex, i) => {\n      if (this.canUpdateFrame(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        if (isApplyAllAttributes || i === 0) {\n          this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n          this.attributes[camera][frameIndex].valid = valid;\n        } else {\n          this.attributes[camera][frameIndex].attributes = {\n            ...toJS(this.attributes[camera][frameIndex].attributes),\n            ...applyValues\n          };\n          if (applyValid) {\n            this.attributes[camera][frameIndex].valid = valid;\n          }\n        }\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{ camera, frames: currentFramesData }],\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{ camera, frames: newFramesData }],\n      });\n    }\n  }\n\n  /**\n   * get next shape order & do increment\n   * @param frameIndex\n   * @param camera\n   */\n  getNextShapeOrder(frameIndex = this.currentFrame, camera = this.currentCamera) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n      this.nextShapeOrders[camera][frameIndex] = 0;\n    }\n\n    const order = this.nextShapeOrders[camera][frameIndex];\n    this.nextShapeOrders[camera][frameIndex] += 1;\n    return order;\n  }\n\n  /**\n   * update next shape order\n   * @param currentOrder\n   * @param frameIndex\n   * @param camera\n   */\n  updateNextShapeOrder(currentOrder: number, frameIndex = this.currentFrame, camera = this.currentCamera) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined || this.nextShapeOrders[camera][frameIndex] <= currentOrder) {\n      this.nextShapeOrders[camera][frameIndex] = currentOrder + 1;\n    }\n  }\n\n  /**\n   * fix image size if no image width & height\n   */\n  async fixImageSize(showMsg = true) {\n    const noSizeFrames: { camera: string; frameIndex: number; imageUrl: string }[] = [];\n    const cameras = Object.keys(this.cameras);\n    for (let i = 0; i < cameras.length; i += 1) {\n      const camera = cameras[i];\n      const cameraFrames = this.cameras[camera];\n      for (let j = 0; j < cameraFrames.length; j += 1) {\n        const { imageWidth, imageHeight } = this.attributes[camera][j];\n        if (imageWidth === undefined || imageHeight === undefined) {\n          noSizeFrames.push({ camera, frameIndex: j, imageUrl: cameraFrames[j] });\n        }\n      }\n    }\n\n    if (noSizeFrames.length <= 0) {\n      Promise.resolve();\n      return;\n    }\n\n    const count = noSizeFrames.length;\n    let hide: MessageType | undefined;\n    if (showMsg) {\n      hide = message.loading({\n        key: 'loading',\n        duration: 0,\n        content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', { values: { count, finished: 0 } }),\n      });\n    }\n    return new Promise<void>((resolve) => {\n      const queue: string[] = [];\n      let finished = 0;\n      let i = 0;\n      const loadImageSize = ({ camera, frameIndex, imageUrl }: { camera: string; frameIndex: number; imageUrl: string }) => {\n        const finish = () => {\n          finished += 1;\n          if (showMsg) {\n            message.loading({\n              key: 'loading',\n              duration: 0,\n              content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', { values: { count, finished } }),\n            });\n          }\n          if (finished === count) {\n            if (hide) {\n              hide();\n            }\n            resolve();\n          } else if (i < count - 1) {\n            i += 1;\n            queue.shift();\n            loadImageSize(noSizeFrames[i]);\n          }\n        };\n        const img = new Image();\n        img.onload = () => {\n          this.updateImageSize(camera, frameIndex, img.width, img.height);\n          finish();\n        };\n        img.onerror = () => {\n          this.updateImageSize(camera, frameIndex, -1, -1);\n          finish();\n        };\n        img.src = imageUrl;\n        queue.push(imageUrl);\n        if (queue.length < 10 && i < count - 1) {\n          i += 1;\n          loadImageSize(noSizeFrames[i]);\n        }\n      };\n      loadImageSize(noSizeFrames[i]);\n    });\n  }\n\n  /**\n   * update image size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  updateImageSize(camera: string, frameIndex: number, width: number, height: number) {\n    if (this.attributes[camera] && this.attributes[camera][frameIndex]) {\n      const { imageWidth, imageHeight } = this.attributes[camera][frameIndex];\n      if ((width > 0 && height > 0) || imageWidth === undefined || imageHeight === undefined) {\n        // only update when size valid, or size not initialized\n        this.attributes[camera][frameIndex].imageWidth = width;\n        this.attributes[camera][frameIndex].imageHeight = height;\n        this.camerasMapping.setCameraSize(camera, frameIndex, width, height);\n      }\n    }\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  framesJSON(): CameraFrameAttributes[] {\n    return Object.keys(this.cameras).map((camera) => ({\n      camera,\n      frames: this.cameras[camera].map((imageUrl, frameIndex) => ({\n        frameIndex,\n        imageUrl,\n        imageWidth: this.attributes[camera][frameIndex].imageWidth,\n        imageHeight: this.attributes[camera][frameIndex].imageHeight,\n        valid: this.isFrameValid(camera, frameIndex),\n        rotation: this.getFrameRotation(camera, frameIndex),\n        attributes: toJS(this.attributes[camera][frameIndex].attributes),\n      })),\n    }));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}