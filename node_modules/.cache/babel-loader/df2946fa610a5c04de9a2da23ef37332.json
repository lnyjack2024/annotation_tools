{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/TextAnnotationApp.jsx\";\n/* eslint-disable no-nested-ternary */\n/* eslint-disable react/no-access-state-in-setstate */\n/* eslint-disable no-undef */\n/* eslint-disable no-underscore-dangle */\nimport React, { createContext } from 'react';\nimport { Editor, EditorState, convertFromRaw, getDefaultKeyBinding } from 'draft-js';\nimport { notification, message } from 'antd';\nimport { uniq } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport localMessage, { setLocale } from './locale';\nimport { LabelTag, InsertionTag, ConnectionTag } from './components/tag';\nimport { isAnnotationReadonly, isRework, isReviewEditable, isPreview } from '../../utils/tool-mode';\nimport Sidebar from './components/sidebar';\nimport { genTagMap, renderTagMap, genDisplayLabels } from './utils/tagMapUtil';\nimport ReviewForm from './components/reviewForm';\nimport UndoRedo from './components/UndoRedo';\nimport ReviewMode from './components/ReviewMode';\nimport Save from './components/Save';\nimport { isAppenCloud } from '../../utils';\nimport AppenLogo from '../common/AppenLogo';\nimport store from './store/RootStore';\nimport './TextAnnotationApp.scss';\nimport 'draft-js/dist/Draft.css';\nimport { FIND_BLOCK, FIND_BLOCK_SELECTED, FOCUS_COLOR, DEFAULT_COLOR, FONT_COLOR, BASE_COLOR, HISTORY_SIZE, FONT_SIZE, TAG_HEIGHT, LINE_HEIGHT, EDITOR_PADDING, COMPOSITION, SELECTION, ACTION, KEY_COMMAND, RECALL_TYPE, HOVER_COLOR, FONT_SPACE, FOCUS_TYPE, HOVER_ALPHA, ACTIVE_ALPHA, DEFAULT_ALPHA } from './store/constant';\nimport { isArabic, convertArrayToColor, convertColorToArray, getSliceHead, setSelection, closeSelection, getTextByInsertion, getTargetWrapperDataSet, isElementInViewport, escapeCharacter, getConfigByKeys } from './utils/helper';\nimport { isLabel, isInsertion, isConnection, isQATag } from './store/tag_mode';\nimport { ReviewItemResult, TAG, ReviewMode as ReviewModeType } from './types';\nimport TagInfoMap from './utils/TagInfoMap';\nconst storageKey = 'text-annotation-label-content';\nlet defaultLabelsDrawerFlag = false;\ntry {\n  const s = localStorage.getItem(storageKey);\n  defaultLabelsDrawerFlag = s === 'true';\n} catch (e) {\n  // get error\n}\nexport const TextToolContext = createContext();\nexport default class TextAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.addHistory = (type, data) => {\n      let targetList;\n      if (this.undoLock) {\n        // Add history to redo list\n        targetList = this.redoList;\n      } else if (this.redoLock) {\n        // Add history back to undo list\n        targetList = this.undoList;\n        // Clear redo list\n      } else {\n        // Add history to redo list\n        targetList = this.undoList;\n        this.redoList = [];\n      }\n      let {\n        length\n      } = targetList;\n      if (length > HISTORY_SIZE) {\n        targetList.shift();\n        length -= 1;\n      }\n      if (type === ACTION.EDIT_SINGLE_ADD && length >= 1) {\n        const prev = targetList[length - 1];\n        if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_ADD) && prev.data.prevSlice === '' && prev.data.end === data.prevStart) {\n          targetList.pop();\n          targetList.push({\n            type: ACTION.EDIT_DEFAULT,\n            data: {\n              prevSlice: '',\n              slice: prev.data.slice + data.slice,\n              prevStart: prev.data.prevStart,\n              prevEnd: prev.data.prevEnd,\n              start: data.start,\n              end: data.end\n            }\n          });\n        } else targetList.push({\n          type,\n          data\n        });\n      } else if (type === ACTION.EDIT_SINGLE_DEL && length >= 1) {\n        const prev = targetList[length - 1];\n        if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_DEL) && prev.data.slice === '' && data.prevEnd === prev.data.start) {\n          targetList.pop();\n          targetList.push({\n            type: ACTION.EDIT_DEFAULT,\n            data: {\n              slice: '',\n              prevSlice: data.prevSlice + prev.data.prevSlice,\n              prevStart: data.end,\n              prevEnd: prev.data.prevEnd,\n              start: data.start,\n              end: data.end\n            }\n          });\n        } else targetList.push({\n          type,\n          data\n        });\n      } else targetList.push({\n        type,\n        data\n      });\n    };\n    this.executeHistory = recallType => {\n      // Execute history\n      let targetList;\n      if (recallType === RECALL_TYPE.UNDO) {\n        // Get from undo list\n        this.undoLock = true;\n        targetList = this.undoList;\n      } else if (recallType === RECALL_TYPE.REDO) {\n        // Get from redo list\n        this.redoLock = true;\n        targetList = this.redoList;\n      }\n      if (targetList.length === 0) {\n        this.undoLock = false;\n        this.redoLock = false;\n        return;\n      }\n      const item = targetList.pop();\n      const {\n        data\n      } = item;\n      let nextEditorState = this.state.editorState;\n      switch (item.type) {\n        case ACTION.EDIT_SINGLE_ADD:\n        case ACTION.EDIT_SINGLE_DEL:\n        case ACTION.EDIT_DEFAULT:\n        case ACTION.EDIT_REPLACE:\n          {\n            const newData = {\n              prevSlice: data.slice,\n              slice: data.prevSlice,\n              start: data.prevEnd,\n              end: data.prevEnd,\n              prevStart: data.prevStart,\n              prevEnd: data.end,\n              ...(item.type === ACTION.EDIT_REPLACE && {\n                tags: data.prevTags,\n                prevTags: data.tags\n              })\n            };\n            // nextEditorState = this.onContentChange(nextEditorState, newData);\n            nextEditorState = setSelection(this.onContentChange(nextEditorState, newData, item.type), newData.start, newData.end);\n            break;\n          }\n        case ACTION.ADD_INSERTION:\n          {\n            const {\n              type,\n              id\n            } = data.insertion;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.ADD_LABEL:\n          {\n            const {\n              type,\n              id\n            } = data.label;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.ADD_MISSING_REVIEW:\n          {\n            const {\n              preReview,\n              id\n            } = data;\n            if (preReview) {\n              const {\n                editorState\n              } = this.addReview(nextEditorState, id, {\n                ...preReview\n              });\n              nextEditorState = editorState;\n            } else {\n              const {\n                editorState\n              } = this.deleteQATag(id);\n              nextEditorState = editorState;\n            }\n            break;\n          }\n        case ACTION.ADD_CONNECTION:\n          {\n            const {\n              type,\n              id\n            } = data;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.DEL_LABEL:\n          {\n            const {\n              relatedConnections,\n              label\n            } = data;\n            nextEditorState = this.addLabel(nextEditorState, label, relatedConnections);\n            break;\n          }\n        case ACTION.DEL_MISSING_REVIEW:\n          {\n            const {\n              label,\n              review\n            } = data;\n            const {\n              editorState\n            } = this.addQALabel(nextEditorState, label, {\n              ...review\n            });\n            nextEditorState = editorState;\n            break;\n          }\n        case ACTION.DEL_INSERTION:\n          {\n            const {\n              relatedConnections,\n              insertion\n            } = data;\n            nextEditorState = this.addInsertion(nextEditorState, insertion, relatedConnections);\n            break;\n          }\n        case ACTION.DEL_CONNECTION:\n          {\n            const {\n              connection\n            } = data;\n            nextEditorState = this.addConnection(nextEditorState, connection);\n            break;\n          }\n        case ACTION.EDIT_REPLACE_ALL:\n          {\n            const {\n              text: currentText,\n              prevText,\n              prevResults,\n              results\n            } = data;\n            store.ontology.text = prevText;\n            store.ontology.setResults(prevResults);\n            this.raw = this.renderTextArea(prevText);\n            nextEditorState = EditorState.set(nextEditorState, {\n              currentContent: convertFromRaw(this.raw)\n            });\n            this.addHistory(ACTION.EDIT_REPLACE_ALL, {\n              text: prevText,\n              prevText: currentText,\n              prevResults: results,\n              results: prevResults\n            });\n            break;\n          }\n        case ACTION.ADD_REVIEW:\n          {\n            const {\n              preReview,\n              id\n            } = data;\n            if (preReview) {\n              const {\n                editorState\n              } = this.addReview(nextEditorState, id, {\n                ...preReview\n              });\n              nextEditorState = editorState;\n            } else {\n              const {\n                editorState\n              } = this.deleteReview(id);\n              nextEditorState = editorState;\n            }\n            break;\n          }\n        case ACTION.DELETE_REVIEW:\n          {\n            const {\n              review,\n              id\n            } = data;\n            const {\n              editorState\n            } = this.addReview(nextEditorState, id, {\n              ...review\n            });\n            nextEditorState = editorState;\n            break;\n          }\n        case ACTION.ADD_REVIEWS:\n          {\n            nextEditorState = this.deleteReviewItems(data);\n            break;\n          }\n        case ACTION.DELETE_REVIEWS:\n          {\n            nextEditorState = this.addReviewItems(nextEditorState, data);\n            break;\n          }\n        default:\n          break;\n      }\n      this.renderAndSave(nextEditorState);\n      this.undoLock = false;\n      this.redoLock = false;\n      const {\n        findStr,\n        findPanelVisible,\n        selectedIndex\n      } = this.state;\n      if (findStr && findPanelVisible && [ACTION.EDIT_REPLACE, ACTION.EDIT_REPLACE_ALL].includes(item.type)) {\n        this.onFind(findStr, selectedIndex || 1);\n      }\n    };\n    this.renderAndSave = (_editorState, shouldRenderTags = true, shouldResetCurrentState = false, shouldSaveURL = false) => {\n      const editorState = _editorState || this.state.editorState;\n      const {\n        hasFocus\n      } = editorState.getSelection();\n      const top = this.editorWrapper.scrollTop;\n      // window.ew = this.editorWrapper;\n      return new Promise(resolve => {\n        if (shouldResetCurrentState) {\n          this.resetCurrentFrom();\n        }\n        this.setState({\n          editorState\n        });\n        if (shouldSaveURL) {\n          this.exportResult();\n        }\n        resolve();\n      }).then(() => {\n        if (shouldRenderTags) {\n          const {\n            nextEditorState,\n            tagMap\n          } = this.measureTags(editorState);\n          return new Promise(resolve => {\n            this.setState({\n              editorState: nextEditorState\n            }, () => {\n              store.ontology.updateOntologiesStatusMap();\n            });\n            resolve(tagMap);\n          });\n        }\n      }).then(tagMap => {\n        if (shouldRenderTags) {\n          this.renderTags(tagMap);\n          return new Promise(resolve => {\n            this.setState({\n              editorWidth: this.editorWrapper.offsetWidth - EDITOR_PADDING * 2,\n              editorHeight: this.editorWrapper.scrollHeight - EDITOR_PADDING * 2,\n              tagMap\n            });\n            resolve();\n          });\n        }\n      }).then(() => {\n        if (hasFocus) {\n          // move back to current selection after composition end\n          if (this.compositionTop >= 0) {\n            this.editor.focus({\n              y: this.compositionTop\n            });\n            this.compositionTop = -1;\n          } else this.editor.focus({\n            y: top\n          });\n        }\n        return new Promise(resolve => resolve());\n      }).then(() => {\n        const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n        this.setState({\n          displayLabels\n        });\n      });\n    };\n    this.updateEditorAndRender = options => {\n      let {\n        editorState\n      } = this.state;\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      if (options && typeof options[Symbol.iterator] === 'function') {\n        return this.renderAndSave(editorState, ...options);\n      }\n      return this.renderAndSave(editorState);\n    };\n    this.onChange = editorState => {\n      // ignore composition operation\n      if (this.compositionFlag === COMPOSITION.ENABLED) return;\n      // get operation type ( handled operation not included )\n      const prevEditorState = this.state.editorState;\n      const prevText = store.ontology.text;\n      const text = editorState.getCurrentContent().getPlainText();\n      let prevStart = prevEditorState.getSelection().getStartOffset();\n      const prevEnd = prevEditorState.getSelection().getEndOffset();\n      const start = editorState.getSelection().getStartOffset();\n      const end = editorState.getSelection().getEndOffset();\n      const {\n        hasFocus\n      } = editorState.getSelection();\n      const {\n        hasFocus: prevFocus\n      } = prevEditorState.getSelection();\n      if (hasFocus !== prevFocus) {\n        // when focus change update new editor state and return without doing anything\n        const nextEditorState = EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        });\n        this.renderAndSave(nextEditorState, null, false);\n        return;\n      }\n      if (this.inputFlag || this.pasteFlag || this.compositionFlag === COMPOSITION.PENDING || prevText !== text) {\n        /* text changed:\n         * 1. deleted by delete key\n         * 2. deleted by drag + delete key\n         * 3. deleted by drag + cut operation\n         * 4. insert/replace by (drag) + simply typing\n         * 5. insert/replace by (drag) + composition typing\n         * 6. insert/replace by (drag) + paste operation\n         * 7. redo && undo\n         */\n        if (prevStart === prevEnd && start === prevStart - 1) prevStart -= 1;\n        const prevSlice = prevText.slice(prevStart, prevEnd);\n        const slice = text.slice(prevStart, end);\n        const data = {\n          prevSlice,\n          slice,\n          prevStart,\n          prevEnd,\n          start,\n          end\n        };\n        const nextEditorState = this.onContentChange(editorState, data);\n        // reset flag\n        this.inputFlag = false;\n        this.pasteFlag = false;\n        this.compositionFlag = COMPOSITION.DISABLED;\n        this.renderAndSave(nextEditorState);\n      } else {\n        /* selection changed\n         * 1. simply select\n         * 2. click select: add insertion\n         * 3. drag select: add label\n         */\n        const data = {\n          start,\n          end\n        };\n        const {\n          nextEditorState,\n          type\n        } = this.onSelectionChange(editorState, data);\n        const shouldRender = type !== SELECTION.MOVE;\n        this.renderAndSave(nextEditorState, shouldRender, shouldRender);\n      }\n    };\n    this.renderTags = tagMap => {\n      const spanMap = this.getAnchorElementsByHeads();\n      const newTagMap = renderTagMap(tagMap, spanMap);\n      return newTagMap;\n    };\n    this.onSave = async () => {\n      if (isPreview(this.toolMode)) return;\n      try {\n        if (!isAnnotationReadonly(this.toolMode)) {\n          await this.exportResult();\n        }\n        if (isReviewEditable(this.toolMode)) {\n          await this.submitReviews(false);\n        }\n        message.success(localMessage('saveSuccess'));\n      } catch (e) {\n        message.warning(localMessage('saveFail'));\n      }\n    };\n    this.onSubmit = async params => {\n      const invalid = params && params.validityFlag === 'false';\n      if (store.config.submitCheck && (!invalid || !store.config.skipCheckForInvalidData)) {\n        // validate before submit\n        await store.validation.defaultSync();\n        if (store.validation.blocked) {\n          throw new Error(localMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n      return this.exportResult(true);\n    };\n    this.exportResult = (isSubmit = false) => {\n      if (isAnnotationReadonly(this.toolMode)) return;\n      return store.saveResult(isSubmit);\n    };\n    this.measureTags = editorState => {\n      const {\n        raw\n      } = this;\n      const {\n        text\n      } = store.ontology;\n      const {\n        labels,\n        insertions\n      } = store.ontology.getResults();\n      const spanMap = this.getAnchorElementsByHeads();\n      const offsetTops = uniq(labels.map(label => {\n        var _spanMap$get;\n        return (_spanMap$get = spanMap.get(label.start)) === null || _spanMap$get === void 0 ? void 0 : _spanMap$get.offsetTop;\n      }).concat(insertions.map(insertion => {\n        var _spanMap$get2;\n        return (_spanMap$get2 = spanMap.get(insertion.at)) === null || _spanMap$get2 === void 0 ? void 0 : _spanMap$get2.offsetTop;\n      })));\n      const occupyMap = new Map();\n      offsetTops.forEach(offsetTop => {\n        occupyMap.set(offsetTop, []);\n      });\n\n      // get label offsets\n      const tagMap = genTagMap(store.ontology.getResults(), store.ontology.ontologyConfigMap, spanMap, occupyMap, text);\n      const ranges = raw.blocks[0].inlineStyleRanges;\n      const style = {\n        ...this.state.style\n      };\n      ranges.filter(item => item.style.slice(0, 6) === 'ANCHOR').forEach(item => {\n        const span = this.getAnchorElementByHead(item.offset);\n        if (span) {\n          const occupyList = occupyMap.get(span.offsetTop);\n          const lineHeight = occupyList.map(it => it.top > 0 ? it.top - FONT_SIZE + TAG_HEIGHT : -it.top).sort((a, b) => a - b).pop() * 2 + LINE_HEIGHT;\n          style[`LINEHEIGHT_${lineHeight}`] = {\n            lineHeight: `${lineHeight}px`\n          };\n          ranges.push({\n            offset: item.offset,\n            length: item.length,\n            style: `LINEHEIGHT_${lineHeight}`\n          });\n        }\n      });\n      const nextEditorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      this.setState({\n        style\n      });\n      return {\n        nextEditorState,\n        tagMap\n      };\n    };\n    this.onSelectionChange = (editorState, data) => {\n      const {\n        start,\n        end\n      } = data;\n      const {\n        currentBrush\n      } = this.state;\n      if (!this.mouseFlag) {\n        return {\n          nextEditorState: editorState,\n          type: SELECTION.MOVE\n        };\n      }\n      if (start === end && isInsertion(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n        const fbAt = strlen(store.ontology.text.slice(0, start));\n        const nextEditorState = this.addInsertion(editorState, {\n          at: fbAt,\n          value: currentBrush.text,\n          keys: currentBrush.keys,\n          type: TAG.INSERTION\n        });\n        return {\n          nextEditorState,\n          type: SELECTION.CLICK\n        };\n      }\n      if (start !== end && isLabel(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n        const fbStart = strlen(store.ontology.text.slice(0, start));\n        const fbEnd = strlen(store.ontology.text.slice(0, end));\n        if (isQATag(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n          const {\n            editorState: nextEditorState\n          } = this.addQALabel(editorState, {\n            start: fbStart,\n            end: fbEnd,\n            value: currentBrush.text,\n            keys: currentBrush.keys,\n            type: currentBrush.type\n          }, {\n            result: ReviewItemResult.MISSING\n          }, true, true);\n          return {\n            nextEditorState,\n            type: SELECTION.DRAG\n          };\n        }\n        const nextEditorState = this.addLabel(editorState, {\n          start: fbStart,\n          end: fbEnd,\n          value: currentBrush.text,\n          keys: currentBrush.keys,\n          type: currentBrush.type\n        });\n        return {\n          nextEditorState,\n          type: SELECTION.DRAG\n        };\n      }\n      return {\n        nextEditorState: editorState,\n        type: SELECTION.MOVE\n      };\n    };\n    this.deleteTag = (type, id) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (isQATag(type) && store.config.reviewMode !== ReviewModeType.REVIEW) {\n        return editorState;\n      }\n      if (!isQATag(type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n        return;\n      }\n      if (isAnnotationReadonly(this.toolMode)) {\n        return editorState;\n      }\n      const operation = store.ontology.deleteTag(type, id);\n      switch (true) {\n        case isLabel(type):\n          this.addHistory(ACTION.DEL_LABEL, operation);\n          break;\n        case isConnection(type):\n          this.addHistory(ACTION.DEL_CONNECTION, operation);\n          break;\n        case isInsertion(type):\n          this.addHistory(ACTION.DEL_INSERTION, operation);\n          break;\n        default:\n          break;\n      }\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.addInsertion = (editorState, {\n      at,\n      value,\n      id,\n      keys,\n      type\n    }, relatedConnections = []) => {\n      const {\n        state: {\n          currentBrush\n        },\n        toolMode\n      } = this;\n      const {\n        text\n      } = store.ontology;\n      if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n      if (at === strlen(text)) return editorState; // prevent insert to the end of content\n      // eslint-disable-next-line no-restricted-syntax\n      for (const item of store.ontology.results.insertions) {\n        if (item.at === at && item.value === currentBrush.text) return editorState;\n      }\n      if (!id) id = uuidv4();\n      const arabic = isArabic(substr(text, at));\n      if (arabic && at) at -= 1;\n      const newItem = {\n        type,\n        at,\n        value,\n        id,\n        text: getTextByInsertion(store.ontology.text, {\n          at,\n          value\n        }),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_INSERTION, {\n        insertion: newItem,\n        relatedConnections\n      });\n      store.ontology.addResultItem(newItem, relatedConnections);\n      this.raw = this.renderTextArea();\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return editorState;\n    };\n    this.addConnection = (editorState, {\n      fromId,\n      fromType,\n      toId,\n      toType,\n      value,\n      id,\n      keys,\n      type\n    }) => {\n      const {\n        state: {\n          currentBrush\n        },\n        toolMode\n      } = this;\n      if (isAnnotationReadonly(toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n      if (fromId === toId) return editorState;\n      if (isQATag(fromType) || isQATag(toType)) return editorState; // can't add connection for qa tool\n\n      if (store.ontology.results.connections.some(item => item.fromId === fromId && item.toId === toId && item.value === currentBrush.text)) return editorState;\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        fromId,\n        fromType,\n        toId,\n        toType,\n        value,\n        id,\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_CONNECTION, newItem);\n      store.ontology.addResultItem(newItem);\n      this.raw = this.renderTextArea();\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      return editorState;\n    };\n    this.addLabel = (editorState, {\n      start,\n      end,\n      value,\n      id,\n      keys,\n      type\n    }, relatedConnections = []) => {\n      const {\n        toolMode\n      } = this;\n      const {\n        ontology,\n        config\n      } = store;\n      const {\n        text\n      } = store.ontology;\n      if (config.reviewMode === ReviewModeType.REVIEW && !isQATag(type)) return editorState;\n      if (isAnnotationReadonly(this.toolMode) && !isQATag(type)) return editorState;\n      if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return editorState; // qa mode can only use qa tool, work mode can only use normal tool\n\n      // slice should not begin with \\n\n      if (substr(text, start, 1) === '\\n') return editorState;\n      if (ontology.results.labels.some(item => item.start === start && item.end === end && item.value === value)) return editorState;\n\n      // generate new label\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        start,\n        end,\n        value,\n        id,\n        text: substr(text, start, end - start),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_LABEL, {\n        label: newItem,\n        relatedConnections\n      });\n      ontology.addResultItem(newItem, relatedConnections);\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return editorState;\n    };\n    this.addQALabel = (editorState, {\n      start,\n      end,\n      value,\n      id,\n      keys,\n      type\n    }, reviewInfo, needUnRedo = true, needOpenReview = false) => {\n      const {\n        toolMode\n      } = this;\n      const {\n        ontology,\n        config,\n        review\n      } = store;\n      const {\n        text\n      } = ontology;\n      if (config.reviewMode === ReviewModeType.REVIEW && !isQATag(type)) return {\n        editorState,\n        operation: null\n      };\n      if (isAnnotationReadonly(this.toolMode) && !isQATag(type)) return {\n        editorState,\n        operation: null\n      };\n      if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return {\n        editorState,\n        operation: null\n      }; // qa mode can only use qa tool, work mode can only use normal tool\n\n      // slice should not begin with \\n\n      if (substr(text, start, 1) === '\\n') return {\n        editorState,\n        operation: null\n      };\n      if (review.reviews.missing.some(item => item.start === start && item.end === end && item.value === value)) return {\n        editorState,\n        operation: null\n      };\n\n      // generate new label\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        start,\n        end,\n        value,\n        id,\n        text: substr(text, start, end - start),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      if (needOpenReview) {\n        this.setState({\n          tagOpenReview: {\n            ...newItem\n          }\n        });\n      }\n      const operation = review.addMissingReview(newItem, id, {\n        ...reviewInfo\n      });\n      if (needUnRedo) {\n        this.addHistory(ACTION.ADD_MISSING_REVIEW, operation);\n      }\n\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return {\n        editorState,\n        operation\n      };\n    };\n    this.deleteQATag = (id, needUnRedo = true) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (store.config.reviewMode !== ReviewModeType.REVIEW) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      if (isAnnotationReadonly(this.toolMode)) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      const operation = store.review.deleteMissingReview(id);\n      if (needUnRedo) {\n        this.addHistory(ACTION.DEL_MISSING_REVIEW, operation);\n      }\n      this.raw = this.renderTextArea();\n      return {\n        editorState: EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        }),\n        operation\n      };\n    };\n    this.deleteReview = (reviewId, needUnRedo = true) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      const operation = store.review.deleteReview(reviewId);\n      if (needUnRedo) {\n        this.addHistory(ACTION.DELETE_REVIEW, operation);\n      }\n      this.raw = this.renderTextArea();\n      return {\n        editorState: EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        }),\n        operation\n      };\n    };\n    this.addReview = (editorState, reviewId, review, needUnRedo = true) => {\n      const {\n        state: {\n          editorState: currEditorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState: currEditorState,\n          operation: null\n        };\n      }\n      const operation = store.review.setReview(reviewId, {\n        ...review\n      });\n      if (needUnRedo) {\n        this.addHistory(ACTION.ADD_REVIEW, operation);\n      }\n      this.raw = this.renderTextArea();\n      return {\n        editorState: EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        }),\n        operation\n      };\n    };\n    this.deleteReviewItemById = reviewId => {\n      if (reviewId) {\n        let nextEditorState = this.state.editorState;\n        const reviewItem = store.ontology.getItemById(reviewId);\n        if (reviewItem && isQATag(reviewItem.type)) {\n          const {\n            editorState\n          } = this.deleteQATag(reviewItem.id);\n          nextEditorState = editorState;\n        } else {\n          const {\n            editorState\n          } = this.deleteReview(reviewId);\n          nextEditorState = editorState;\n        }\n        this.renderAndSave(nextEditorState);\n      }\n    };\n    this.deleteReviewItemsById = reviewIds => {\n      const operations = [];\n      reviewIds === null || reviewIds === void 0 ? void 0 : reviewIds.forEach(reviewId => {\n        if (reviewId) {\n          const reviewItem = store.ontology.getItemById(reviewId);\n          if (reviewItem && isQATag(reviewItem.type)) {\n            const {\n              operation\n            } = this.deleteQATag(reviewItem.id, false);\n            if (operation) {\n              operations.push(operation);\n            }\n          } else {\n            const {\n              operation\n            } = this.deleteReview(reviewId, false);\n            if (operation) {\n              operations.push(operation);\n            }\n          }\n        }\n      });\n      this.addHistory(ACTION.DELETE_REVIEWS, operations);\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.deleteReviewItems = reviewItems => {\n      const operations = [];\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return editorState;\n      }\n      reviewItems === null || reviewItems === void 0 ? void 0 : reviewItems.forEach(reviewItem => {\n        const {\n          review,\n          id\n        } = reviewItem;\n        if (review.result === ReviewItemResult.MISSING) {\n          const {\n            operation\n          } = this.deleteQATag(id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const {\n            operation\n          } = this.deleteReview(id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      });\n      this.addHistory(ACTION.DELETE_REVIEWS, operations);\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.addReviewItems = (editorState, reviewItems) => {\n      const operations = [];\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return editorState;\n      }\n      reviewItems === null || reviewItems === void 0 ? void 0 : reviewItems.forEach(reviewItem => {\n        const {\n          review,\n          id\n        } = reviewItem;\n        if (review.result === ReviewItemResult.MISSING) {\n          const {\n            operation\n          } = this.addQALabel(editorState, reviewItem.label, {\n            ...review\n          }, false, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const {\n            operation\n          } = this.addReview(editorState, id, {\n            ...review\n          }, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      });\n      this.addHistory(ACTION.ADD_REVIEWS, operations);\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.deleteReviewHandle = reviewItem => {\n      if (reviewItem) {\n        let nextEditorState = this.state.editorState;\n        if (isQATag(reviewItem.type)) {\n          const {\n            editorState\n          } = this.deleteQATag(reviewItem.id);\n          nextEditorState = editorState;\n        } else {\n          const {\n            editorState\n          } = this.deleteReview(reviewItem.id);\n          nextEditorState = editorState;\n        }\n        this.renderAndSave(nextEditorState);\n      }\n    };\n    this.onDeleteReview = () => {\n      const {\n        tagOpenReview\n      } = this.state;\n      this.deleteReviewHandle(tagOpenReview);\n    };\n    // create new RawDraftContentState and update customeStyleMap\n    // update: raw, style, sliceMap\n    this.renderTextArea = _text => {\n      const {\n        ontology\n      } = store;\n      const {\n        ontologyConfigMap\n      } = ontology;\n      const {\n        currentClick,\n        currentHover,\n        foundTags,\n        foundTagSelectedIndex,\n        needJumpFound\n      } = this.state;\n      const style = {\n        ...this.state.style\n      };\n      const text = _text || store.ontology.text;\n      const {\n        labels,\n        insertions\n      } = ontology.getResults();\n      // render missing labels as normal labels\n\n      // slice text to segments\n      const slices = uniq(labels.map(label => label.start).concat(labels.map(label => label.end)).concat(insertions.map(insertion => insertion.at)).concat(foundTags.map(t => t.start)).concat(foundTags.map(t => t.end)).concat([0, text.length]).sort((a, b) => a - b));\n      const labelHeads = uniq(labels.map(label => label.start));\n      const insertionHeads = uniq(insertions.map(insertion => insertion.at));\n      const foundTagHeads = uniq(foundTags.map(tag => tag.start));\n\n      // .concat(insertions.map((insertion) => insertion.at)));\n      const raw = {\n        blocks: [{\n          text,\n          key: 'span-wrapper',\n          type: 'unstyled',\n          depth: 0,\n          inlineStyleRanges: [{\n            offset: 0,\n            length: text.length,\n            style: 'DEFAULT_STYLE'\n          }],\n          children: [],\n          entityRanges: [],\n          data: {}\n        }],\n        entityMap: {}\n      };\n      let sliceCount = 0;\n      // 对重叠的tag进行背景色叠加\n      const ranges = raw.blocks[0].inlineStyleRanges;\n      this.sliceMap = new Map();\n      slices.forEach((anchor, index, array) => {\n        // set slice\n        if (!index) return;\n        const {\n          prev,\n          next\n        } = {\n          prev: array[index - 1],\n          next: anchor\n        };\n        const match = labels.filter(label => label.start <= prev && label.end > prev);\n        let currentRGB = [0, 0, 0];\n        let currentAlpha = 0;\n        let nextAlpha = DEFAULT_ALPHA;\n        let isCoverbyQa = false;\n        let keepRGB = null;\n        match.some(label => {\n          const labelItem = getConfigByKeys(ontologyConfigMap, label.keys);\n          const tempRGB = convertColorToArray(labelItem.color);\n          if (!keepRGB) isCoverbyQa = isQATag(label.type);\n          // render clicked tag in priority\n          if (currentClick.id === label.id || currentClick.fromId === label.id || currentClick.toId === label.id) {\n            keepRGB = tempRGB.map((value, i) => value * ACTIVE_ALPHA);\n            isCoverbyQa = isQATag(label.type);\n            return true;\n          }\n          if (!keepRGB && currentHover.id === label.id || currentHover.fromId === label.id || currentHover.toId === label.id) {\n            keepRGB = tempRGB.map(v => v * HOVER_ALPHA);\n          }\n          if (!keepRGB) {\n            currentRGB = currentRGB.map((value, i) => value + tempRGB[i] * nextAlpha);\n            currentAlpha += nextAlpha;\n            nextAlpha = DEFAULT_ALPHA * (1 - currentAlpha) * (1 - currentAlpha);\n          }\n          return false;\n        });\n        // background of found tag\n        foundTags.filter(tag => tag.start <= prev && tag.end > prev).some(tag => {\n          const tagIndex = foundTags.findIndex(f => f.start === tag.start);\n          if (tagIndex !== undefined) {\n            keepRGB = foundTagSelectedIndex === tagIndex && !needJumpFound ? [255, 230, 0] : [255, 169, 64, 0.20];\n            return true;\n          }\n          return false;\n        });\n        const baseRGB = convertColorToArray(BASE_COLOR);\n        currentRGB = keepRGB || currentRGB.map((value, i) => Math.min(255, value + baseRGB[i] * (1 - currentAlpha)));\n        const currentColor = convertArrayToColor(currentRGB);\n        if (!style[`BACKGROUND_${currentColor}`]) style[`BACKGROUND_${currentColor}`] = {\n          backgroundColor: currentColor\n        };\n        if (isCoverbyQa) ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: 'MISSING_STYLE'\n        });\n        ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: `BACKGROUND_${currentColor}`\n        });\n        ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: `SLICE_${prev}_${next}`\n        });\n        // set slice head if for label/insertion slice\n        if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0) {\n          const slice = substr(text, prev, next - prev);\n          const head = getSliceHead(slice);\n          ranges.push({\n            offset: prev,\n            length: strlen(head),\n            style: `ANCHOR_${prev}`\n          });\n        }\n        if (foundTagHeads.indexOf(prev) >= 0) {\n          const tagIndex = foundTags.findIndex(f => f.start === prev);\n          if (tagIndex !== undefined) {\n            const tag = foundTags[tagIndex];\n            ranges.push({\n              offset: prev,\n              length: tag.end - tag.start,\n              style: foundTagSelectedIndex === tagIndex && !needJumpFound ? 'FIND_BLOCK_SELECTED' : 'FIND_BLOCK'\n            });\n          }\n        }\n        if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0 || foundTagHeads.indexOf(prev) >= 0) {\n          const slice = substr(text, prev, next - prev);\n          const head = getSliceHead(slice);\n          // set sliceMap\n          this.sliceMap.set(prev, sliceCount);\n          if (head !== slice) sliceCount += 1;\n        }\n        sliceCount += 1;\n      });\n      // update new style\n      this.setState({\n        style\n      });\n      return raw;\n    };\n    this.onMouseMove = e => {\n      const box = this.svg.getBoundingClientRect();\n      this.setState({\n        currentMouse: {\n          left: e.clientX - box.x,\n          top: e.clientY - box.y\n        }\n      });\n    };\n    this.moveFocusToTag = tag => {\n      let currentClick = {\n        ...this.state.currentClick\n      };\n      const {\n        tagMap\n      } = this.state;\n      if (tag == null) return;\n      currentClick = {\n        id: tag.id,\n        fromId: tag.fromId,\n        toId: tag.toId,\n        fromType: tag.fromType,\n        toType: tag.toType\n      };\n      const {\n        top\n      } = tagMap.getItem(tag.id, tag.type);\n      const {\n        clientHeight,\n        scrollTop\n      } = this.editorWrapper;\n      if (top < scrollTop || top > clientHeight + scrollTop) {\n        this.editor.focus({\n          y: top\n        });\n      }\n      this.setState({\n        currentClick\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    };\n    this.onKeyDown = e => {\n      if (window.disableTextHotKeys) {\n        return;\n      }\n      const {\n        currentClick,\n        editorState\n      } = this.state;\n      const {\n        keyCode,\n        ctrlKey,\n        altKey\n      } = e;\n      const config = [];\n      store.ontology.ontologyConfigMap.forEach(value => {\n        config.push(value);\n      });\n      if (ctrlKey) {\n        switch (true) {\n          case keyCode >= 48 && keyCode <= 57:\n            {\n              // 0 - 9\n              e.preventDefault();\n              const index = e.keyCode - 49;\n              if (index === -1) {\n                this.setCurrentBrush(null);\n              }\n              if (config[index]) {\n                this.setCurrentBrush(config[index]);\n              }\n              break;\n            }\n          case keyCode === 90:\n            e.preventDefault();\n            this.executeHistory(RECALL_TYPE.UNDO);\n            break;\n          // Z\n          case keyCode === 89:\n            e.preventDefault();\n            this.executeHistory(RECALL_TYPE.REDO);\n            break;\n          // Y\n          case keyCode === 83:\n            e.preventDefault();\n            this.onSave();\n            break;\n          // S\n          case keyCode === 82:\n            {\n              // R\n              e.preventDefault();\n              const nTag = store.ontology.moveToTagByStep(currentClick.id, 1, true);\n              this.moveFocusToTag(nTag);\n              break;\n            }\n          case keyCode === 81:\n            {\n              // Q\n              e.preventDefault();\n              if (currentClick.id == null) break;\n              let nxtTag;\n              if (altKey) {\n                nxtTag = store.ontology.stepToTag(currentClick.id, -1);\n              } else {\n                nxtTag = store.ontology.moveToTagByStep(currentClick.id, -1);\n              }\n              this.moveFocusToTag(nxtTag);\n              break;\n            }\n          case keyCode === 69:\n            {\n              // E\n              e.preventDefault();\n              if (currentClick.id == null) break;\n              let nextTag;\n              if (altKey) {\n                nextTag = store.ontology.stepToTag(currentClick.id, 1);\n              } else {\n                nextTag = store.ontology.moveToTagByStep(currentClick.id, 1);\n              }\n              this.moveFocusToTag(nextTag);\n              break;\n            }\n          default:\n            break;\n        }\n      } else if ((currentClick === null || currentClick === void 0 ? void 0 : currentClick.id) !== null && isReviewEditable(this.toolMode) && !isQATag(currentClick.type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n        switch (keyCode) {\n          case 49:\n            // 1\n            e.preventDefault();\n            e.stopPropagation();\n            this.addReview(editorState, currentClick.id, {\n              result: 'pass'\n            });\n            break;\n          // 2\n          case 50:\n            {\n              e.preventDefault();\n              e.stopPropagation();\n              let tagReviewInfo = store.review.getReview(currentClick.id);\n              if (!tagReviewInfo || tagReviewInfo.result !== ReviewItemResult.REJECT) {\n                tagReviewInfo = {\n                  result: 'reject',\n                  id: currentClick.id,\n                  type: []\n                };\n              }\n              const item = store.ontology.getItem(currentClick.type, currentClick.id);\n              this.setState({\n                tagOpenReview: item,\n                tagReviewInfo\n              });\n              this.editor.blur();\n              break;\n            }\n          default:\n            break;\n        }\n      }\n    };\n    // update text\n    this.onContentChange = (editorState, data, type) => {\n      const {\n        currentBrush,\n        editorState: preState,\n        findPanelVisible,\n        inputEnable\n      } = this.state;\n      if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW || (currentBrush || findPanelVisible || !inputEnable) && type === undefined || this.props.read_only) {\n        return preState;\n      }\n      const {\n        slice,\n        prevSlice,\n        tags,\n        prevTags\n      } = data;\n      let {\n        prevStart,\n        prevEnd\n      } = data;\n      if (prevSlice.length === 1 && slice.length === 0) this.addHistory(ACTION.EDIT_SINGLE_DEL, data);else if (prevSlice.length === 0 && slice.length === 1) this.addHistory(ACTION.EDIT_SINGLE_ADD, data);else if (type === ACTION.EDIT_REPLACE) this.addHistory(ACTION.EDIT_REPLACE, data);else this.addHistory(ACTION.EDIT_DEFAULT, data);\n      prevStart = strlen(store.ontology.text.slice(0, data.prevStart));\n      prevEnd = strlen(store.ontology.text.slice(0, data.prevEnd));\n      store.ontology.text = store.ontology.text.slice(0, data.prevStart) + data.slice + store.ontology.text.slice(data.prevEnd);\n      // update labels and insertions\n      const offset = slice.length - prevSlice.length;\n      if (type === ACTION.EDIT_REPLACE && prevTags) {\n        const {\n          insertions = [],\n          labels = [],\n          connections = []\n        } = prevTags;\n        [...insertions, ...labels, ...connections].forEach(t => {\n          store.ontology.deleteTag(t.type, t.id);\n        });\n      }\n      store.ontology.tagMove(prevStart, prevEnd, offset);\n      if (type === ACTION.EDIT_REPLACE && tags) {\n        const {\n          insertions = [],\n          labels = [],\n          connections = []\n        } = tags;\n        [...insertions, ...labels, ...connections].forEach(t => {\n          store.ontology.addResultItem(t);\n        });\n      }\n\n      // update rawDraftContentState, using new text and results\n      // this.updateFindTags();\n      this.raw = this.renderTextArea();\n\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      return editorState;\n    };\n    this.resetCurrentFocus = (attribute = 'currentClick', shouldUpdate) => new Promise(resolve => {\n      this.setState({\n        [`${attribute}`]: {\n          id: null,\n          from: null,\n          to: null\n        }\n      }, () => resolve('state updated'));\n    }).then(() => {\n      if (shouldUpdate) {\n        return this.updateEditorAndRender();\n      }\n    });\n    this.resetCurrentFrom = () => {\n      this.setState({\n        currentFrom: {\n          type: null,\n          id: null,\n          offset: null\n        }\n      });\n    };\n    // to status for tag: connection mode and other mode\n    this.onTagClick = (e, type, id) => {\n      const {\n        currentFrom,\n        currentBrush,\n        editorState,\n        tagMap\n      } = this.state;\n      const offset = tagMap.getItem(id, type);\n      this.editor.blur();\n      if (!isConnection(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) return;\n\n      // connecting mode only applys to label and insertion\n      if (isLabel(type) || isInsertion(type)) {\n        // if there is no starting point, setup the starting point\n        if (!currentFrom.type) {\n          this.setState({\n            currentFrom: {\n              type,\n              id,\n              offset\n            }\n          });\n        } else {\n          const nextEditorState = this.addConnection(editorState, {\n            fromId: currentFrom.id,\n            fromType: currentFrom.type,\n            toId: id,\n            toType: type,\n            type: TAG.CONNECTION,\n            value: currentBrush.text,\n            keys: currentBrush.keys\n          });\n          this.renderAndSave(nextEditorState, true, true);\n        }\n      }\n    };\n    this.onTagDoubleClick = e => {\n      // only work in qa mode\n      if (!store.reviewable && !store.isRework) {\n        return;\n      }\n      const {\n        id,\n        type\n      } = getTargetWrapperDataSet(e);\n      const item = store.ontology.getItem(type, id);\n      const tagReviewInfo = store.review.getReview(id);\n      this.setState({\n        tagOpenReview: item,\n        tagReviewInfo\n      });\n      this.editor.blur();\n    };\n    // mouseEvent includes: mouse enter, mouse leave, mouse click, mouse context menu\n    this.TagMouseEvent = (e, type, id, focusType, active) => {\n      const {\n        currentClick: {\n          id: currId\n        }\n      } = this.state;\n      const tag = store.ontology.getItem(type, id);\n      if (!tag) {\n        return;\n      }\n      let attribute = '';\n      if (focusType === FOCUS_TYPE.HOVER) {\n        if (currId === tag.id && active) return;\n        attribute = 'currentHover';\n      } else if (focusType === FOCUS_TYPE.CLICK) {\n        attribute = 'currentClick';\n        this.editor.blur();\n      }\n\n      // active status: mouse enter | mouse click\n      if (active) {\n        if (focusType === FOCUS_TYPE.CLICK) {\n          this.onTagClick(e, type, id);\n        }\n        // ranges.push({ offset: label.start, length: label.end - label.start, style: `${focusType}_STYLE_${color}` });\n        this.setState({\n          [`${attribute}`]: {\n            id: tag.id,\n            fromId: tag === null || tag === void 0 ? void 0 : tag.fromId,\n            toId: tag === null || tag === void 0 ? void 0 : tag.toId,\n            fromType: tag === null || tag === void 0 ? void 0 : tag.fromType,\n            toType: tag === null || tag === void 0 ? void 0 : tag.toType,\n            type: tag === null || tag === void 0 ? void 0 : tag.type\n          }\n        }, () => {\n          this.updateEditorAndRender();\n        });\n      } else {\n        // unactive status: mouse leave | mouse context menu\n        const tagType = type;\n        this.resetCurrentFocus(attribute, true).then(() => {\n          if (focusType === FOCUS_TYPE.CLICK) {\n            this.onContextMenu(e, tag.id, tagType);\n          }\n        });\n      }\n    };\n    this.onContextMenu = (e, id, type) => {\n      let nextEditorState;\n      switch (type) {\n        case TAG.LABEL:\n        case TAG.CONNECTION:\n        case TAG.INSERTION:\n          nextEditorState = this.deleteTag(type, id);\n          break;\n        case TAG.LABEL_QA:\n          {\n            const {\n              editorState\n            } = this.deleteQATag(id);\n            nextEditorState = editorState;\n            break;\n          }\n        default:\n          return;\n      }\n      this.renderAndSave(nextEditorState);\n    };\n    // toggleLabelsDrawer = () => {\n    //   if (!this.state.labelsDrawerOpen) {\n    //     const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n    //     this.setState({ displayLabels });\n    //   }\n    //   this.setState({ labelsDrawerOpen: !this.state.labelsDrawerOpen }, () => {\n    //     this.updateEditorAndRender();\n    //     localStorage.setItem(storageKey, this.state.labelsDrawerOpen);\n    //   });\n    // };\n    this.toggleFindPanelVisible = visible => {\n      this.setState({\n        findPanelVisible: visible,\n        inputEnable: false,\n        currentBrush: null\n      });\n      if (visible) {\n        this.onFind(this.state.findStr);\n      } else {\n        this.setState({\n          foundTags: [],\n          needJumpFound: false,\n          foundTagSelectedIndex: 0\n        }, () => {\n          this.updateEditorAndRender();\n        });\n      }\n    };\n    this.jumpToFindTag = async (offset, findString) => {\n      const {\n        findStr\n      } = this.state;\n      if (!findStr) {\n        this.onFind(findString);\n        return;\n      }\n      const {\n        foundTagSelectedIndex,\n        foundTags\n      } = this.state;\n      if (foundTags.length === 0) {\n        this.updateEditorAndRender();\n        return;\n      }\n      let newFindTagSelectedIndex = foundTagSelectedIndex + offset;\n      if (newFindTagSelectedIndex < 0) {\n        newFindTagSelectedIndex = foundTags.length - 1;\n      }\n      if (newFindTagSelectedIndex > foundTags.length - 1) {\n        newFindTagSelectedIndex = 0;\n      }\n      this.setState({\n        needJumpFound: false,\n        foundTagSelectedIndex: newFindTagSelectedIndex\n      }, () => {\n        this.focusSelectedFoundTag();\n      });\n    };\n    this.focusSelectedFoundTag = () => {\n      this.updateEditorAndRender();\n      const {\n        foundTags,\n        foundTagSelectedIndex\n      } = this.state;\n      const selectedTag = foundTags[foundTagSelectedIndex];\n      if (selectedTag) {\n        const span = this.getAnchorElementByHead(selectedTag.start);\n        if (span && this.editorWrapper && !isElementInViewport(span, this.editorWrapper)) {\n          const {\n            top\n          } = span.getBoundingClientRect();\n          const offsetHeight = this.editorWrapper.clientHeight / 2;\n          const scrollTop = this.editorWrapper.scrollTop + top - offsetHeight;\n          this.editorWrapper.scroll(0, scrollTop);\n        }\n      }\n    };\n    this.updateFindTags = () => new Promise(resolve => {\n      const {\n        findStr\n      } = this.state;\n      const str = store.ontology.text;\n      const reg = new RegExp(escapeCharacter(findStr), 'g');\n      const ans = [];\n      if (findStr) {\n        let matched = null;\n        let i = 0;\n        // eslint-disable-next-line no-cond-assign\n        while ((matched = reg.exec(str)) !== null) {\n          const temp = {\n            start: matched.index,\n            end: matched.index + findStr.length,\n            id: i\n          };\n          ans.push(temp);\n          i += 1;\n        }\n      }\n      this.setState({\n        foundTags: ans,\n        foundTagSelectedIndex: -1\n      }, () => {\n        resolve();\n      });\n    });\n    this.onFind = (_findStr, selectedIndex) => {\n      const {\n        findStr,\n        foundTags\n      } = this.state;\n      if (findStr && _findStr === findStr && foundTags.length > 0 && selectedIndex === undefined) {\n        this.jumpToFindTag(1, findStr);\n      } else if (_findStr) {\n        this.setState({\n          findStr: _findStr\n        }, async () => {\n          await this.updateFindTags();\n          this.jumpToFindTag(selectedIndex || 1, findStr);\n        });\n      } else {\n        this.setState({\n          findStr: '',\n          foundTags: [],\n          foundTagSelectedIndex: -1\n        }, () => {\n          this.updateEditorAndRender();\n        });\n      }\n    };\n    this.setCurrentBrush = (item, input = false) => {\n      this.setState({\n        currentBrush: item,\n        inputEnable: input\n      });\n    };\n    this.setFormVisible = () => {\n      this.setState({\n        tagOpenReview: null,\n        tagReviewInfo: null\n      });\n    };\n    this.genKeyCommand = e => {\n      if (e.metaKey || e.altKey) return KEY_COMMAND.INVALID_KEY;\n      switch (e.keyCode) {\n        case 90:\n          // prevent default undo\n          e.preventDefault();\n          if (e.ctrlKey) return KEY_COMMAND.HANDLE_UNDO;\n          return getDefaultKeyBinding(e);\n        case 89:\n          // prevent default redo\n          e.preventDefault();\n          if (e.ctrlKey) return KEY_COMMAND.HANDLE_REDO;\n          return getDefaultKeyBinding(e);\n        case 13:\n          e.preventDefault();\n          return KEY_COMMAND.HANDLE_RETURN;\n        default:\n          return getDefaultKeyBinding(e);\n      }\n    };\n    this.handleKeyCommand = command => {\n      const {\n        editorState\n      } = this.state;\n      switch (command) {\n        case KEY_COMMAND.INVALID_KEY:\n          return 'handled';\n        case KEY_COMMAND.HANDLE_RETURN:\n          {\n            const start = editorState.getSelection().getStartOffset();\n            const end = editorState.getSelection().getEndOffset();\n            const nextEditorState = setSelection(this.onContentChange(editorState, {\n              slice: '\\n',\n              prevSlice: store.ontology.text.slice(start, end),\n              prevStart: start,\n              prevEnd: end,\n              start: start + 1,\n              end: start + 1\n            }), start + 1, start + 1);\n            this.renderAndSave(nextEditorState);\n            return 'handled';\n          }\n        case KEY_COMMAND.HANDLE_UNDO:\n          return 'handled';\n        case KEY_COMMAND.HANDLE_REDO:\n          return 'handled';\n        default:\n          return 'not-handled';\n      }\n    };\n    // Get one anchor by slice head\n    this.getAnchorElementByHead = at => {\n      const {\n        sliceMap\n      } = this;\n      const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n      const id = `span-wrapper-0-${sliceMap.get(at)}`;\n      const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n      return span;\n    };\n    // Get all anchors at one time\n    this.getAnchorElementsByHeads = () => {\n      const {\n        sliceMap\n      } = this;\n      const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n      const spanMap = new Map();\n      sliceMap.forEach((value, key) => {\n        const id = `span-wrapper-0-${sliceMap.get(key)}`;\n        const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n        spanMap.set(key, span);\n      });\n      return spanMap;\n    };\n    this.onMouseDown = e => {\n      if (e.which === 1) {\n        this.mouseFlag = true;\n      }\n      const onMouseUp = () => {\n        this.mouseFlag = false;\n        window.removeEventListener('mouseup', onMouseUp);\n      };\n      window.addEventListener('mouseup', onMouseUp);\n    };\n    this.onCompositionEnd = () => {\n      this.compositionFlag = COMPOSITION.PENDING;\n    };\n    this.onCompositionStart = () => {\n      this.compositionFlag = COMPOSITION.ENABLED;\n      this.compositionTop = this.editorWrapper.scrollTop;\n    };\n    this.handleBeforeInput = () => {\n      this.inputFlag = true;\n      return 'not-handled';\n    };\n    this.handlePastedText = () => {\n      this.pasteFlag = true;\n      return 'not-handled';\n    };\n    setLocale(props.locale);\n    this.raw = {\n      blocks: [],\n      entityMap: {}\n    };\n    this.sliceMap = new Map();\n    this.state = {\n      findStr: '',\n      foundTags: [],\n      needJumpFound: false,\n      foundTagSelectedIndex: 0,\n      findPanelVisible: false,\n      displayLabels: [],\n      labelsDrawerOpen: defaultLabelsDrawerFlag,\n      style: {\n        FIND_BLOCK,\n        FIND_BLOCK_SELECTED\n      },\n      tagOpenReview: null,\n      tagReviewInfo: null,\n      editorState: EditorState.createEmpty(),\n      currentBrush: null,\n      editorHeight: null,\n      editorWidth: null,\n      tagMap: new TagInfoMap(),\n      currentClick: {\n        id: null,\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null\n      },\n      currentHover: {\n        id: '',\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null\n      },\n      currentFrom: {\n        type: null,\n        id: null,\n        offset: null\n      },\n      currentMouse: {\n        left: 0,\n        top: 0\n      },\n      inputEnable: false\n    };\n    this.compositionTop = -1;\n    this.compositionFlag = COMPOSITION.DISABLED;\n    this.inputFlag = false;\n    this.mouseFlag = false;\n    this.pasteFlag = false;\n    this.undoLock = false;\n    this.redoLock = false;\n    this.redoList = [];\n    this.undoList = [];\n\n    // user setting\n    this.fontColor = FONT_COLOR;\n    this.toolMode = this.props.jobProxy.toolMode || this.props.mode;\n    store.jobProxy = this.props.jobProxy;\n  }\n  submitReviews(isSubmit = true) {\n    return store.saveReviews(isSubmit);\n  }\n  getReviews() {\n    return this.submitReviews();\n  }\n  getStatistics() {\n    return store.getAuditStatistics();\n  }\n  async componentDidMount() {\n    this.toolMode = this.props.jobProxy.toolMode;\n    let {\n      content\n    } = this.props;\n    let results;\n\n    // insert qa tool's label\n    try {\n      const resultRes = await this.props.jobProxy.loadResult();\n      if ((resultRes === null || resultRes === void 0 ? void 0 : resultRes.results) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.content)) {\n        content = resultRes.content;\n        results = resultRes.results;\n      } else if ((resultRes === null || resultRes === void 0 ? void 0 : resultRes.labels) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.connections) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.insertions)) {\n        results = resultRes;\n      }\n    } catch (e) {\n      notification.error({\n        message: localMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // init store\n    try {\n      await store.init({\n        ...this.props,\n        content: content || ''\n      });\n    } catch (e) {\n      notification.error({\n        message: e.message,\n        duration: null\n      });\n      return;\n    }\n\n    // initialize results\n    store.ontology.parseResults(results);\n    const reviewRes = await this.props.jobProxy.loadReviews();\n    if (reviewRes) {\n      store.review.parseReview(reviewRes);\n    }\n\n    // initialize raw\n    this.raw = this.renderTextArea();\n    // apply composition lock\n    // if (this.state.labelsDrawerOpen) {\n    //   const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n    //   this.setState({ displayLabels });\n    // }\n    this.editorWrapper.addEventListener('compositionstart', this.onCompositionStart);\n    this.editorWrapper.addEventListener('compositionend', this.onCompositionEnd);\n    this.editorWrapper.addEventListener('mousedown', this.onMouseDown);\n    this.editorWrapper.addEventListener('dragstart', e => e.preventDefault());\n    this.editorWrapper.addEventListener('contextmenu', e => {\n      e.preventDefault();\n      this.resetCurrentFrom();\n      this.resetCurrentFocus('currentClick', true);\n    });\n    this.editorWrapper.addEventListener('mousemove', this.onMouseMove);\n    window.addEventListener('keydown', this.onKeyDown);\n    window.addEventListener('resize', () => this.renderAndSave(null, true, false, false));\n\n    // initialize customStyleMap\n    this.setState({\n      style: {\n        ...this.state.style,\n        DEFAULT_STYLE: {\n          color: this.fontColor,\n          fontSize: `${FONT_SIZE}px`,\n          lineHeight: `${LINE_HEIGHT}px`,\n          letterSpacing: `${FONT_SPACE}px`\n        },\n        MISSING_STYLE: {\n          color: '#000000'\n        }\n      }\n    });\n    this.renderAndSave(EditorState.createWithContent(convertFromRaw(this.raw)), true, true, false);\n    // use url file backup to replace content, results, and reviews information\n    // use local storage backup to replace text, results, and reviews information\n    // save every 5 minutes\n    setInterval(() => {\n      this.onSave();\n    }, 1000 * 60 * 5);\n    if (this.props.renderComplete) {\n      this.props.renderComplete();\n    }\n  }\n  render() {\n    var _currentFrom$offset, _currentFrom$offset2;\n    const {\n      editorState,\n      style,\n      currentBrush,\n      editorWidth,\n      editorHeight,\n      currentClick,\n      currentHover,\n      currentMouse,\n      currentFrom,\n      tagMap,\n      tagOpenReview,\n      tagReviewInfo,\n      inputEnable\n    } = this.state;\n    const {\n      config\n    } = store;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"app-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1520,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-wrapper\",\n      onClick: () => {\n        this.editorOnFocus = false;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1521,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-left-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1522,\n        columnNumber: 11\n      }\n    }, isAppenCloud() && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"logo\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1524,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(AppenLogo, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1525,\n        columnNumber: 15\n      }\n    })), /*#__PURE__*/React.createElement(ReviewMode, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1528,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"divider\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1529,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(UndoRedo, {\n      undoHandle: () => this.executeHistory(RECALL_TYPE.UNDO),\n      redoHandle: () => this.executeHistory(RECALL_TYPE.REDO),\n      undoList: this.undoList,\n      redoList: this.redoList,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1530,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"divider\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1536,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Save, {\n      onSave: this.onSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1537,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-right-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1539,\n        columnNumber: 11\n      }\n    })), /*#__PURE__*/React.createElement(TextToolContext.Provider, {\n      value: {\n        moveFocusToTag: this.moveFocusToTag,\n        deleteReviewItemById: this.deleteReviewItemById,\n        deleteReviewItemsById: this.deleteReviewItemsById\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1543,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Sidebar, {\n      showReview: isRework(this.toolMode) || isReviewEditable(this.toolMode),\n      onClick: () => {\n        this.editorOnFocus = false;\n      },\n      currentBrush: currentBrush,\n      inputEnable: inputEnable,\n      setCurrentBrush: this.setCurrentBrush,\n      items: tagMap,\n      contentReadyOnly: this.props.read_only,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1544,\n        columnNumber: 11\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"right-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1554,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"editor-wrapper\",\n      ref: r => {\n        this.editorWrapper = r;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1555,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"svg-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1559,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"svg\", {\n      ref: r => {\n        this.svg = r;\n      },\n      style: {\n        height: `${editorHeight}px`,\n        width: `${editorWidth}px`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1560,\n        columnNumber: 15\n      }\n    }, Object.entries(tagMap.connections).map(([id, connect]) => /*#__PURE__*/React.createElement(\"g\", {\n      key: id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1562,\n        columnNumber: 19\n      }\n    }, /*#__PURE__*/React.createElement(\"path\", {\n      d: connect.path,\n      stroke: currentHover.id === id ? HOVER_COLOR : currentClick.id === id ? FOCUS_COLOR : DEFAULT_COLOR,\n      fill: \"#00000000\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1563,\n        columnNumber: 21\n      }\n    }))), currentFrom.type ? /*#__PURE__*/React.createElement(\"path\", {\n      d: `M ${(_currentFrom$offset = currentFrom.offset) === null || _currentFrom$offset === void 0 ? void 0 : _currentFrom$offset.left} ${(_currentFrom$offset2 = currentFrom.offset) === null || _currentFrom$offset2 === void 0 ? void 0 : _currentFrom$offset2.top} L ${currentMouse.left} ${currentMouse.top}`,\n      stroke: FOCUS_COLOR,\n      fill: \"#00000000\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1571,\n        columnNumber: 19\n      }\n    }) : null)), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tags-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1575,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tags-panel\",\n      style: {\n        height: `${editorHeight}px`,\n        width: `${editorWidth}px`\n      },\n      onDoubleClick: this.onTagDoubleClick,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1576,\n        columnNumber: 15\n      }\n    }, Object.entries(tagMap.labels).map(([id, label]) => {\n      var _store$review$getRevi;\n      return /*#__PURE__*/React.createElement(LabelTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi = store.review.getReview(id)) === null || _store$review$getRevi === void 0 ? void 0 : _store$review$getRevi.result,\n        label: label,\n        isHover: currentHover.id === id || currentHover.fromId === id || currentHover.toId === id,\n        isClick: currentClick.id === id || currentClick.fromId === id || currentClick.toId === id,\n        labelMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1582,\n          columnNumber: 19\n        }\n      });\n    }), Object.entries(tagMap.insertions).map(([id, insertion]) => {\n      var _store$review$getRevi2;\n      return /*#__PURE__*/React.createElement(InsertionTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi2 = store.review.getReview(id)) === null || _store$review$getRevi2 === void 0 ? void 0 : _store$review$getRevi2.result,\n        insertion: insertion,\n        isHover: currentHover.id === id || currentHover.fromId === id || currentHover.toId === id,\n        isClick: currentClick.id === id || currentClick.fromId === id || currentClick.toId === id,\n        insertionMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1600,\n          columnNumber: 19\n        }\n      });\n    }), Object.entries(tagMap.connections).map(([id, connection]) => {\n      var _store$review$getRevi3;\n      return /*#__PURE__*/React.createElement(ConnectionTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi3 = store.review.getReview(id)) === null || _store$review$getRevi3 === void 0 ? void 0 : _store$review$getRevi3.result,\n        connection: connection,\n        isHover: currentHover.id === id,\n        isClick: currentClick.id === id,\n        connectionMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1618,\n          columnNumber: 19\n        }\n      });\n    }))), /*#__PURE__*/React.createElement(\"div\", {\n      onClick: () => {\n        this.editor.focus();\n        this.resetCurrentFocus('currentClick', true);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1629,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(Editor, {\n      ref: r => {\n        this.editor = r;\n      },\n      editorState: editorState,\n      customStyleMap: style,\n      onChange: this.onChange,\n      handlePastedText: this.handlePastedText,\n      handleBeforeInput: this.handleBeforeInput,\n      handleKeyCommand: this.handleKeyCommand,\n      keyBindingFn: this.genKeyCommand,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1635,\n        columnNumber: 15\n      }\n    })))), /*#__PURE__*/React.createElement(ReviewForm, {\n      toolMode: this.toolMode,\n      tagReviewInfo: tagReviewInfo,\n      tagOpenReview: tagOpenReview,\n      issueTypes: this.props.issue_types,\n      setFormVisible: this.setFormVisible,\n      onConfirm: review => {\n        this.addReview(editorState, tagOpenReview === null || tagOpenReview === void 0 ? void 0 : tagOpenReview.id, review);\n        store.ontology.updateOntologiesStatusMap();\n      },\n      onDelete: this.onDeleteReview,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1655,\n        columnNumber: 9\n      }\n    }));\n  }\n}","map":{"version":3,"names":["React","createContext","Editor","EditorState","convertFromRaw","getDefaultKeyBinding","notification","message","uniq","substr","strlen","v4","uuidv4","localMessage","setLocale","LabelTag","InsertionTag","ConnectionTag","isAnnotationReadonly","isRework","isReviewEditable","isPreview","Sidebar","genTagMap","renderTagMap","genDisplayLabels","ReviewForm","UndoRedo","ReviewMode","Save","isAppenCloud","AppenLogo","store","FIND_BLOCK","FIND_BLOCK_SELECTED","FOCUS_COLOR","DEFAULT_COLOR","FONT_COLOR","BASE_COLOR","HISTORY_SIZE","FONT_SIZE","TAG_HEIGHT","LINE_HEIGHT","EDITOR_PADDING","COMPOSITION","SELECTION","ACTION","KEY_COMMAND","RECALL_TYPE","HOVER_COLOR","FONT_SPACE","FOCUS_TYPE","HOVER_ALPHA","ACTIVE_ALPHA","DEFAULT_ALPHA","isArabic","convertArrayToColor","convertColorToArray","getSliceHead","setSelection","closeSelection","getTextByInsertion","getTargetWrapperDataSet","isElementInViewport","escapeCharacter","getConfigByKeys","isLabel","isInsertion","isConnection","isQATag","ReviewItemResult","TAG","ReviewModeType","TagInfoMap","storageKey","defaultLabelsDrawerFlag","s","localStorage","getItem","e","TextToolContext","TextAnnotationApp","Component","constructor","props","addHistory","type","data","targetList","undoLock","redoList","redoLock","undoList","length","shift","EDIT_SINGLE_ADD","prev","EDIT_DEFAULT","prevSlice","end","prevStart","pop","push","slice","prevEnd","start","EDIT_SINGLE_DEL","executeHistory","recallType","UNDO","REDO","item","nextEditorState","state","editorState","EDIT_REPLACE","newData","tags","prevTags","onContentChange","ADD_INSERTION","id","insertion","deleteTag","ADD_LABEL","label","ADD_MISSING_REVIEW","preReview","addReview","deleteQATag","ADD_CONNECTION","DEL_LABEL","relatedConnections","addLabel","DEL_MISSING_REVIEW","review","addQALabel","DEL_INSERTION","addInsertion","DEL_CONNECTION","connection","addConnection","EDIT_REPLACE_ALL","text","currentText","prevText","prevResults","results","ontology","setResults","raw","renderTextArea","set","currentContent","ADD_REVIEW","deleteReview","DELETE_REVIEW","ADD_REVIEWS","deleteReviewItems","DELETE_REVIEWS","addReviewItems","renderAndSave","findStr","findPanelVisible","selectedIndex","includes","onFind","_editorState","shouldRenderTags","shouldResetCurrentState","shouldSaveURL","hasFocus","getSelection","top","editorWrapper","scrollTop","Promise","resolve","resetCurrentFrom","setState","exportResult","then","tagMap","measureTags","updateOntologiesStatusMap","renderTags","editorWidth","offsetWidth","editorHeight","scrollHeight","compositionTop","editor","focus","y","displayLabels","labels","ontologyConfigMap","updateEditorAndRender","options","Symbol","iterator","onChange","compositionFlag","ENABLED","prevEditorState","getCurrentContent","getPlainText","getStartOffset","getEndOffset","prevFocus","inputFlag","pasteFlag","PENDING","DISABLED","onSelectionChange","shouldRender","MOVE","spanMap","getAnchorElementsByHeads","newTagMap","onSave","toolMode","submitReviews","success","warning","onSubmit","params","invalid","validityFlag","config","submitCheck","skipCheckForInvalidData","validation","defaultSync","blocked","Error","isSubmit","saveResult","insertions","getResults","offsetTops","map","_spanMap$get","get","offsetTop","concat","_spanMap$get2","at","occupyMap","Map","forEach","ranges","blocks","inlineStyleRanges","style","filter","span","getAnchorElementByHead","offset","occupyList","lineHeight","it","sort","a","b","currentBrush","mouseFlag","fbAt","value","keys","INSERTION","CLICK","fbStart","fbEnd","result","MISSING","DRAG","reviewMode","REVIEW","operation","arabic","newItem","isReview","addResultItem","fromId","fromType","toId","toType","connections","some","LABELING","reviewInfo","needUnRedo","needOpenReview","reviews","missing","tagOpenReview","addMissingReview","deleteMissingReview","reviewId","currEditorState","setReview","deleteReviewItemById","reviewItem","getItemById","deleteReviewItemsById","reviewIds","operations","reviewItems","deleteReviewHandle","onDeleteReview","_text","currentClick","currentHover","foundTags","foundTagSelectedIndex","needJumpFound","slices","t","labelHeads","insertionHeads","foundTagHeads","tag","key","depth","children","entityRanges","entityMap","sliceCount","sliceMap","anchor","index","array","next","match","currentRGB","currentAlpha","nextAlpha","isCoverbyQa","keepRGB","labelItem","tempRGB","color","i","v","tagIndex","findIndex","f","undefined","baseRGB","Math","min","currentColor","backgroundColor","indexOf","head","onMouseMove","box","svg","getBoundingClientRect","currentMouse","left","clientX","x","clientY","moveFocusToTag","clientHeight","onKeyDown","window","disableTextHotKeys","keyCode","ctrlKey","altKey","preventDefault","setCurrentBrush","nTag","moveToTagByStep","nxtTag","stepToTag","nextTag","stopPropagation","tagReviewInfo","getReview","REJECT","blur","preState","inputEnable","read_only","tagMove","resetCurrentFocus","attribute","shouldUpdate","from","to","currentFrom","onTagClick","CONNECTION","onTagDoubleClick","reviewable","TagMouseEvent","focusType","active","currId","HOVER","tagType","onContextMenu","LABEL","LABEL_QA","toggleFindPanelVisible","visible","jumpToFindTag","findString","newFindTagSelectedIndex","focusSelectedFoundTag","selectedTag","offsetHeight","scroll","updateFindTags","str","reg","RegExp","ans","matched","exec","temp","_findStr","input","setFormVisible","genKeyCommand","metaKey","INVALID_KEY","HANDLE_UNDO","HANDLE_REDO","HANDLE_RETURN","handleKeyCommand","command","wrapper","querySelector","onMouseDown","which","onMouseUp","removeEventListener","addEventListener","onCompositionEnd","onCompositionStart","handleBeforeInput","handlePastedText","locale","labelsDrawerOpen","createEmpty","fontColor","jobProxy","mode","saveReviews","getReviews","getStatistics","getAuditStatistics","componentDidMount","content","resultRes","loadResult","error","duration","init","parseResults","reviewRes","loadReviews","parseReview","DEFAULT_STYLE","fontSize","letterSpacing","MISSING_STYLE","createWithContent","setInterval","renderComplete","render","_currentFrom$offset","_currentFrom$offset2","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","onClick","editorOnFocus","undoHandle","redoHandle","Provider","showReview","items","contentReadyOnly","ref","r","height","width","Object","entries","connect","d","path","stroke","fill","onDoubleClick","_store$review$getRevi","reviewResult","isHover","isClick","labelMouseEvent","_store$review$getRevi2","insertionMouseEvent","_store$review$getRevi3","connectionMouseEvent","customStyleMap","keyBindingFn","issueTypes","issue_types","onConfirm","onDelete"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/TextAnnotationApp.jsx"],"sourcesContent":["/* eslint-disable no-nested-ternary */\n/* eslint-disable react/no-access-state-in-setstate */\n/* eslint-disable no-undef */\n/* eslint-disable no-underscore-dangle */\nimport React, { createContext } from 'react';\nimport { Editor, EditorState, convertFromRaw, getDefaultKeyBinding } from 'draft-js';\nimport { notification, message } from 'antd';\nimport { uniq } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport localMessage, { setLocale } from './locale';\nimport { LabelTag, InsertionTag, ConnectionTag } from './components/tag';\nimport { isAnnotationReadonly, isRework, isReviewEditable, isPreview } from '../../utils/tool-mode';\nimport Sidebar from './components/sidebar';\nimport { genTagMap, renderTagMap, genDisplayLabels } from './utils/tagMapUtil';\n\nimport ReviewForm from './components/reviewForm';\nimport UndoRedo from './components/UndoRedo';\nimport ReviewMode from './components/ReviewMode';\nimport Save from './components/Save';\nimport { isAppenCloud } from '../../utils';\nimport AppenLogo from '../common/AppenLogo';\nimport store from './store/RootStore';\nimport './TextAnnotationApp.scss';\nimport 'draft-js/dist/Draft.css';\nimport {\n  FIND_BLOCK,\n  FIND_BLOCK_SELECTED,\n  FOCUS_COLOR, DEFAULT_COLOR,\n  FONT_COLOR, BASE_COLOR, HISTORY_SIZE,\n  FONT_SIZE, TAG_HEIGHT,\n  LINE_HEIGHT, EDITOR_PADDING,\n  COMPOSITION, SELECTION, ACTION, KEY_COMMAND,\n  RECALL_TYPE,\n  HOVER_COLOR,\n  FONT_SPACE, FOCUS_TYPE,\n  HOVER_ALPHA,\n  ACTIVE_ALPHA,\n  DEFAULT_ALPHA,\n} from './store/constant';\nimport {\n  isArabic,\n  convertArrayToColor,\n  convertColorToArray,\n  getSliceHead,\n  setSelection,\n  closeSelection,\n  getTextByInsertion,\n  getTargetWrapperDataSet,\n  isElementInViewport,\n  escapeCharacter,\n  getConfigByKeys,\n} from './utils/helper';\nimport {\n  isLabel,\n  isInsertion,\n  isConnection,\n  isQATag,\n} from './store/tag_mode';\nimport { ReviewItemResult, TAG, ReviewMode as ReviewModeType } from './types';\nimport TagInfoMap from './utils/TagInfoMap';\n\nconst storageKey = 'text-annotation-label-content';\nlet defaultLabelsDrawerFlag = false;\ntry {\n  const s = localStorage.getItem(storageKey);\n  defaultLabelsDrawerFlag = s === 'true';\n} catch (e) {\n  // get error\n}\n\nexport const TextToolContext = createContext();\nexport default class TextAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    setLocale(props.locale);\n    this.raw = { blocks: [], entityMap: {} };\n    this.sliceMap = new Map();\n    this.state = {\n      findStr: '',\n      foundTags: [],\n      needJumpFound: false,\n      foundTagSelectedIndex: 0,\n      findPanelVisible: false,\n      displayLabels: [],\n      labelsDrawerOpen: defaultLabelsDrawerFlag,\n      style: {\n        FIND_BLOCK,\n        FIND_BLOCK_SELECTED,\n      },\n      tagOpenReview: null,\n      tagReviewInfo: null,\n      editorState: EditorState.createEmpty(),\n      currentBrush: null,\n      editorHeight: null,\n      editorWidth: null,\n      tagMap: new TagInfoMap(),\n      currentClick: {\n        id: null,\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null,\n      },\n      currentHover: {\n        id: '',\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null,\n      },\n      currentFrom: {\n        type: null,\n        id: null,\n        offset: null,\n      },\n      currentMouse: {\n        left: 0,\n        top: 0,\n      },\n      inputEnable: false,\n    };\n\n    this.compositionTop = -1;\n    this.compositionFlag = COMPOSITION.DISABLED;\n    this.inputFlag = false;\n    this.mouseFlag = false;\n    this.pasteFlag = false;\n    this.undoLock = false;\n    this.redoLock = false;\n    this.redoList = [];\n    this.undoList = [];\n\n    // user setting\n    this.fontColor = FONT_COLOR;\n    this.toolMode = this.props.jobProxy.toolMode || this.props.mode;\n    store.jobProxy = this.props.jobProxy;\n  };\n\n  addHistory = (type, data) => {\n    let targetList;\n    if (this.undoLock) {\n      // Add history to redo list\n      targetList = this.redoList;\n    } else if (this.redoLock) {\n      // Add history back to undo list\n      targetList = this.undoList;\n      // Clear redo list\n    } else {\n      // Add history to redo list\n      targetList = this.undoList;\n      this.redoList = [];\n    }\n    let { length } = targetList;\n    if (length > HISTORY_SIZE) {\n      targetList.shift();\n      length -= 1;\n    }\n    if (type === ACTION.EDIT_SINGLE_ADD && length >= 1) {\n      const prev = targetList[length - 1];\n      if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_ADD) && (prev.data.prevSlice === '' && prev.data.end === data.prevStart)) {\n        targetList.pop();\n        targetList.push({\n          type: ACTION.EDIT_DEFAULT,\n          data: {\n            prevSlice: '',\n            slice: prev.data.slice + data.slice,\n            prevStart: prev.data.prevStart,\n            prevEnd: prev.data.prevEnd,\n            start: data.start,\n            end: data.end,\n          }\n        });\n      } else targetList.push({ type, data });\n    } else if (type === ACTION.EDIT_SINGLE_DEL && length >= 1) {\n      const prev = targetList[length - 1];\n      if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_DEL) && (prev.data.slice === '' && data.prevEnd === prev.data.start)) {\n        targetList.pop();\n        targetList.push({\n          type: ACTION.EDIT_DEFAULT,\n          data: {\n            slice: '',\n            prevSlice: data.prevSlice + prev.data.prevSlice,\n            prevStart: data.end,\n            prevEnd: prev.data.prevEnd,\n            start: data.start,\n            end: data.end,\n          }\n        });\n      } else targetList.push({ type, data });\n    } else targetList.push({ type, data });\n  };\n\n  executeHistory = (recallType) => {\n    // Execute history\n    let targetList;\n    if (recallType === RECALL_TYPE.UNDO) {\n      // Get from undo list\n      this.undoLock = true;\n      targetList = this.undoList;\n    } else if (recallType === RECALL_TYPE.REDO) {\n      // Get from redo list\n      this.redoLock = true;\n      targetList = this.redoList;\n    }\n    if (targetList.length === 0) {\n      this.undoLock = false;\n      this.redoLock = false;\n      return;\n    }\n    const item = targetList.pop();\n    const { data } = item;\n    let nextEditorState = this.state.editorState;\n    switch (item.type) {\n      case ACTION.EDIT_SINGLE_ADD:\n      case ACTION.EDIT_SINGLE_DEL:\n      case ACTION.EDIT_DEFAULT:\n      case ACTION.EDIT_REPLACE:\n      {\n        const newData = {\n          prevSlice: data.slice,\n          slice: data.prevSlice,\n          start: data.prevEnd,\n          end: data.prevEnd,\n          prevStart: data.prevStart,\n          prevEnd: data.end,\n          ...item.type === ACTION.EDIT_REPLACE && {\n            tags: data.prevTags,\n            prevTags: data.tags,\n          }\n        };\n        // nextEditorState = this.onContentChange(nextEditorState, newData);\n        nextEditorState = setSelection(this.onContentChange(nextEditorState, newData, item.type), newData.start, newData.end);\n        break;\n      }\n      case ACTION.ADD_INSERTION:\n      {\n        const { type, id } = data.insertion;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.ADD_LABEL:\n      {\n        const { type, id } = data.label;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.ADD_MISSING_REVIEW:\n      {\n        const { preReview, id } = data;\n        if (preReview) {\n          const { editorState } = this.addReview(nextEditorState, id, { ...preReview });\n          nextEditorState = editorState;\n        } else {\n          const { editorState } = this.deleteQATag(id);\n          nextEditorState = editorState;\n        }\n        break;\n      }\n      case ACTION.ADD_CONNECTION:\n      {\n        const { type, id } = data;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.DEL_LABEL:\n      {\n        const { relatedConnections, label } = data;\n        nextEditorState = this.addLabel(nextEditorState, label, relatedConnections);\n        break;\n      }\n      case ACTION.DEL_MISSING_REVIEW:\n      {\n        const { label, review } = data;\n        const { editorState } = this.addQALabel(nextEditorState, label, { ...review });\n        nextEditorState = editorState;\n\n        break;\n      }\n      case ACTION.DEL_INSERTION:\n      {\n        const { relatedConnections, insertion } = data;\n\n        nextEditorState = this.addInsertion(nextEditorState, insertion, relatedConnections);\n        break;\n      }\n      case ACTION.DEL_CONNECTION:\n      {\n        const { connection } = data;\n        nextEditorState = this.addConnection(nextEditorState, connection);\n        break;\n      }\n      case ACTION.EDIT_REPLACE_ALL:\n      {\n        const { text: currentText, prevText, prevResults, results } = data;\n        store.ontology.text = prevText;\n        store.ontology.setResults(prevResults);\n        this.raw = this.renderTextArea(prevText);\n        nextEditorState = EditorState.set(nextEditorState, { currentContent: convertFromRaw(this.raw) });\n        this.addHistory(ACTION.EDIT_REPLACE_ALL, {\n          text: prevText,\n          prevText: currentText,\n          prevResults: results,\n          results: prevResults,\n        });\n        break;\n      }\n      case ACTION.ADD_REVIEW: {\n        const { preReview, id } = data;\n        if (preReview) {\n          const { editorState } = this.addReview(nextEditorState, id, { ...preReview });\n          nextEditorState = editorState;\n        } else {\n          const { editorState } = this.deleteReview(id);\n          nextEditorState = editorState;\n        }\n        break;\n      }\n      case ACTION.DELETE_REVIEW: {\n        const { review, id } = data;\n        const { editorState } = this.addReview(nextEditorState, id, { ...review });\n        nextEditorState = editorState;\n        break;\n      }\n      case ACTION.ADD_REVIEWS: {\n        nextEditorState = this.deleteReviewItems(data);\n        break;\n      }\n      case ACTION.DELETE_REVIEWS: {\n        nextEditorState = this.addReviewItems(nextEditorState, data);\n        break;\n      }\n      default:\n        break;\n    }\n\n    this.renderAndSave(nextEditorState);\n    this.undoLock = false;\n    this.redoLock = false;\n    const { findStr, findPanelVisible, selectedIndex } = this.state;\n    if (findStr && findPanelVisible && [ACTION.EDIT_REPLACE, ACTION.EDIT_REPLACE_ALL].includes(item.type)) {\n      this.onFind(findStr, selectedIndex || 1);\n    }\n  };\n\n  renderAndSave = (\n    _editorState,\n    shouldRenderTags = true,\n    shouldResetCurrentState = false,\n    shouldSaveURL = false,\n  ) => {\n    const editorState = _editorState || this.state.editorState;\n    const { hasFocus } = editorState.getSelection();\n    const top = this.editorWrapper.scrollTop;\n    // window.ew = this.editorWrapper;\n    return new Promise((resolve) => {\n      if (shouldResetCurrentState) {\n        this.resetCurrentFrom();\n      }\n      this.setState({ editorState });\n      if (shouldSaveURL) {\n        this.exportResult();\n      }\n      resolve();\n    }).then(() => {\n      if (shouldRenderTags) {\n        const { nextEditorState, tagMap } = this.measureTags(editorState);\n        return new Promise((resolve) => {\n          this.setState({ editorState: nextEditorState }, () => {\n            store.ontology.updateOntologiesStatusMap();\n          });\n          resolve(tagMap);\n        });\n      }\n    }).then((tagMap) => {\n      if (shouldRenderTags) {\n        this.renderTags(tagMap);\n        return new Promise((resolve) => {\n          this.setState({\n            editorWidth: this.editorWrapper.offsetWidth - EDITOR_PADDING * 2,\n            editorHeight: this.editorWrapper.scrollHeight - EDITOR_PADDING * 2,\n            tagMap,\n          });\n          resolve();\n        });\n      }\n    }).then(() => {\n      if (hasFocus) {\n        // move back to current selection after composition end\n        if (this.compositionTop >= 0) {\n          this.editor.focus({ y: this.compositionTop });\n          this.compositionTop = -1;\n        } else this.editor.focus({ y: top });\n      }\n      return new Promise((resolve) => resolve());\n    })\n      .then(() => {\n        const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n        this.setState({ displayLabels });\n      });\n  };\n\n  updateEditorAndRender = (options) => {\n    let { editorState } = this.state;\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    if (options && typeof options[Symbol.iterator] === 'function') {\n      return this.renderAndSave(editorState, ...options);\n    }\n\n    return this.renderAndSave(editorState);\n  };\n\n  onChange = (editorState) => {\n    // ignore composition operation\n    if (this.compositionFlag === COMPOSITION.ENABLED) return;\n    // get operation type ( handled operation not included )\n    const prevEditorState = this.state.editorState;\n    const prevText = store.ontology.text;\n    const text = editorState.getCurrentContent().getPlainText();\n    let prevStart = prevEditorState.getSelection().getStartOffset();\n    const prevEnd = prevEditorState.getSelection().getEndOffset();\n    const start = editorState.getSelection().getStartOffset();\n    const end = editorState.getSelection().getEndOffset();\n    const { hasFocus } = editorState.getSelection();\n    const { hasFocus: prevFocus } = prevEditorState.getSelection();\n\n    if (hasFocus !== prevFocus) { // when focus change update new editor state and return without doing anything\n      const nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n      this.renderAndSave(nextEditorState, null, false);\n      return;\n    }\n\n    if (this.inputFlag || this.pasteFlag || this.compositionFlag === COMPOSITION.PENDING || prevText !== text) {\n      /* text changed:\n       * 1. deleted by delete key\n       * 2. deleted by drag + delete key\n       * 3. deleted by drag + cut operation\n       * 4. insert/replace by (drag) + simply typing\n       * 5. insert/replace by (drag) + composition typing\n       * 6. insert/replace by (drag) + paste operation\n       * 7. redo && undo\n       */\n      if (prevStart === prevEnd && start === prevStart - 1) prevStart -= 1;\n      const prevSlice = prevText.slice(prevStart, prevEnd);\n      const slice = text.slice(prevStart, end);\n      const data = { prevSlice, slice, prevStart, prevEnd, start, end };\n      const nextEditorState = this.onContentChange(editorState, data);\n      // reset flag\n      this.inputFlag = false;\n      this.pasteFlag = false;\n      this.compositionFlag = COMPOSITION.DISABLED;\n      this.renderAndSave(nextEditorState);\n    } else {\n      /* selection changed\n       * 1. simply select\n       * 2. click select: add insertion\n       * 3. drag select: add label\n       */\n      const data = { start, end };\n      const { nextEditorState, type } = this.onSelectionChange(editorState, data);\n      const shouldRender = type !== SELECTION.MOVE;\n      this.renderAndSave(nextEditorState, shouldRender, shouldRender);\n    }\n  };\n\n  renderTags = (tagMap) => {\n    const spanMap = this.getAnchorElementsByHeads();\n    const newTagMap = renderTagMap(tagMap, spanMap);\n    return newTagMap;\n  };\n\n  onSave = async () => {\n    if (isPreview(this.toolMode)) return;\n    try {\n      if (!isAnnotationReadonly(this.toolMode)) {\n        await this.exportResult();\n      }\n      if (isReviewEditable(this.toolMode)) {\n        await this.submitReviews(false);\n      }\n      message.success(localMessage('saveSuccess'));\n    } catch (e) {\n      message.warning(localMessage('saveFail'));\n    }\n  };\n\n  onSubmit = async (params) => {\n    const invalid = params && params.validityFlag === 'false';\n    if (store.config.submitCheck && (\n      !invalid || !store.config.skipCheckForInvalidData\n    )) {\n      // validate before submit\n      await store.validation.defaultSync();\n      if (store.validation.blocked) {\n        throw new Error(localMessage('SUBMIT_CHECK_FAIL'));\n      }\n    }\n    return this.exportResult(true);\n  };\n\n  exportResult = (isSubmit = false) => {\n    if (isAnnotationReadonly(this.toolMode)) return;\n    return store.saveResult(isSubmit);\n  };\n\n  submitReviews(isSubmit = true) {\n    return store.saveReviews(isSubmit);\n  }\n\n  getReviews() {\n    return this.submitReviews();\n  }\n\n  getStatistics() {\n    return store.getAuditStatistics();\n  }\n\n  measureTags = (editorState) => {\n    const { raw } = this;\n    const { text } = store.ontology;\n    const { labels, insertions } = store.ontology.getResults();\n\n    const spanMap = this.getAnchorElementsByHeads();\n    const offsetTops = uniq((labels.map((label) => spanMap.get(label.start)?.offsetTop))\n      .concat(insertions.map((insertion) => spanMap.get(insertion.at)?.offsetTop)));\n    const occupyMap = new Map();\n    offsetTops.forEach((offsetTop) => { occupyMap.set(offsetTop, []); });\n\n    // get label offsets\n    const tagMap = genTagMap(store.ontology.getResults(), store.ontology.ontologyConfigMap, spanMap, occupyMap, text);\n    const ranges = raw.blocks[0].inlineStyleRanges;\n    const style = { ...this.state.style };\n    ranges.filter((item) => item.style.slice(0, 6) === 'ANCHOR').forEach((item) => {\n      const span = this.getAnchorElementByHead(item.offset);\n      if (span) {\n        const occupyList = occupyMap.get(span.offsetTop);\n        const lineHeight = occupyList.map((it) => (it.top > 0 ? it.top - FONT_SIZE + TAG_HEIGHT : -it.top))\n          .sort((a, b) => (a - b)).pop() * 2 + LINE_HEIGHT;\n        style[`LINEHEIGHT_${lineHeight}`] = { lineHeight: `${lineHeight}px` };\n        ranges.push({ offset: item.offset, length: item.length, style: `LINEHEIGHT_${lineHeight}` });\n      }\n    });\n    const nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    this.setState({ style });\n    return { nextEditorState, tagMap };\n  };\n\n  onSelectionChange = (editorState, data) => {\n    const { start, end } = data;\n    const { currentBrush } = this.state;\n    if (!this.mouseFlag) {\n      return { nextEditorState: editorState, type: SELECTION.MOVE };\n    } if (start === end && isInsertion(currentBrush?.type)) {\n      const fbAt = strlen(store.ontology.text.slice(0, start));\n      const nextEditorState = this.addInsertion(editorState, { at: fbAt, value: currentBrush.text, keys: currentBrush.keys, type: TAG.INSERTION });\n      return { nextEditorState, type: SELECTION.CLICK };\n    } if (start !== end && isLabel(currentBrush?.type)) {\n      const fbStart = strlen(store.ontology.text.slice(0, start));\n      const fbEnd = strlen(store.ontology.text.slice(0, end));\n      if (isQATag(currentBrush?.type)) {\n        const { editorState: nextEditorState } = this.addQALabel(editorState, { start: fbStart, end: fbEnd, value: currentBrush.text, keys: currentBrush.keys, type: currentBrush.type }, { result: ReviewItemResult.MISSING }, true, true);\n        return { nextEditorState, type: SELECTION.DRAG };\n      }\n      const nextEditorState = this.addLabel(editorState, { start: fbStart, end: fbEnd, value: currentBrush.text, keys: currentBrush.keys, type: currentBrush.type });\n      return { nextEditorState, type: SELECTION.DRAG };\n    }\n    return { nextEditorState: editorState, type: SELECTION.MOVE };\n  };\n\n  deleteTag = (type, id) => {\n    const { state: { editorState } } = this;\n    if (isQATag(type) && store.config.reviewMode !== ReviewModeType.REVIEW) {\n      return editorState;\n    }\n    if (!isQATag(type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n      return;\n    }\n    if (isAnnotationReadonly(this.toolMode)) {\n      return editorState;\n    }\n\n    const operation = store.ontology.deleteTag(type, id);\n    switch (true) {\n      case (isLabel(type)): this.addHistory(ACTION.DEL_LABEL, operation); break;\n      case (isConnection(type)): this.addHistory(ACTION.DEL_CONNECTION, operation); break;\n      case (isInsertion(type)): this.addHistory(ACTION.DEL_INSERTION, operation); break;\n      default: break;\n    }\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  addInsertion = (editorState, { at, value, id, keys, type }, relatedConnections = []) => {\n    const { state: { currentBrush }, toolMode } = this;\n    const { text } = store.ontology;\n    if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n    if (at === strlen(text)) return editorState; // prevent insert to the end of content\n    // eslint-disable-next-line no-restricted-syntax\n    for (const item of store.ontology.results.insertions) {\n      if (item.at === at && item.value === currentBrush.text) return editorState;\n    }\n    if (!id) id = uuidv4();\n    const arabic = isArabic(substr(text, at));\n    if (arabic && at) at -= 1;\n    const newItem = {\n      type,\n      at,\n      value,\n      id,\n      text: getTextByInsertion(store.ontology.text, { at, value }),\n      isReview: isReviewEditable(toolMode),\n      keys,\n    };\n\n    this.addHistory(ACTION.ADD_INSERTION, {\n      insertion: newItem,\n      relatedConnections,\n    });\n\n    store.ontology.addResultItem(newItem, relatedConnections);\n\n    this.raw = this.renderTextArea();\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return editorState;\n  };\n\n  addConnection = (editorState, { fromId, fromType, toId, toType, value, id, keys, type }) => {\n    const { state: { currentBrush }, toolMode } = this;\n    if (isAnnotationReadonly(toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n    if (fromId === toId) return editorState;\n    if (isQATag(fromType) || isQATag(toType)) return editorState; // can't add connection for qa tool\n\n    if (store.ontology.results.connections.some((item) => item.fromId === fromId && item.toId === toId && item.value === currentBrush.text)) return editorState;\n\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      fromId,\n      fromType,\n      toId,\n      toType,\n      value,\n      id,\n      isReview: isReviewEditable(toolMode),\n      keys,\n    };\n    this.addHistory(ACTION.ADD_CONNECTION, newItem);\n    store.ontology.addResultItem(newItem);\n\n    this.raw = this.renderTextArea();\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    return editorState;\n  };\n\n  addLabel = (editorState, { start, end, value, id, keys, type }, relatedConnections = []) => {\n    const { toolMode } = this;\n    const { ontology, config } = store;\n    const { text } = store.ontology;\n\n    if (config.reviewMode === ReviewModeType.REVIEW && (!isQATag(type))) return editorState;\n    if (isAnnotationReadonly(this.toolMode) && (!isQATag(type))) return editorState;\n    if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return editorState; // qa mode can only use qa tool, work mode can only use normal tool\n\n    // slice should not begin with \\n\n    if (substr(text, start, 1) === '\\n') return editorState;\n\n    if (ontology.results.labels.some((item) => item.start === start && item.end === end && item.value === value)) return editorState;\n\n    // generate new label\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      start,\n      end,\n      value,\n      id,\n      text: substr(text, start, end - start),\n      isReview: isReviewEditable(toolMode),\n      keys\n    };\n\n    this.addHistory(ACTION.ADD_LABEL, {\n      label: newItem,\n      relatedConnections,\n    });\n\n    ontology.addResultItem(newItem, relatedConnections);\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return editorState;\n  };\n\n  addQALabel = (editorState, { start, end, value, id, keys, type }, reviewInfo, needUnRedo = true, needOpenReview = false) => {\n    const { toolMode } = this;\n    const { ontology, config, review } = store;\n    const { text } = ontology;\n    if (config.reviewMode === ReviewModeType.REVIEW && (!isQATag(type))) return { editorState, operation: null };\n    if (isAnnotationReadonly(this.toolMode) && (!isQATag(type))) return { editorState, operation: null };\n    if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return { editorState, operation: null }; // qa mode can only use qa tool, work mode can only use normal tool\n\n    // slice should not begin with \\n\n    if (substr(text, start, 1) === '\\n') return { editorState, operation: null };\n\n    if (review.reviews.missing.some((item) => item.start === start && item.end === end && item.value === value)) return { editorState, operation: null };\n\n    // generate new label\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      start,\n      end,\n      value,\n      id,\n      text: substr(text, start, end - start),\n      isReview: isReviewEditable(toolMode),\n      keys\n    };\n    if (needOpenReview) {\n      this.setState({ tagOpenReview: { ...newItem } });\n    }\n\n    const operation = review.addMissingReview(newItem, id, { ...reviewInfo });\n    if (needUnRedo) {\n      this.addHistory(ACTION.ADD_MISSING_REVIEW, operation);\n    }\n\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return { editorState, operation };\n  };\n\n  deleteQATag = (id, needUnRedo = true) => {\n    const { state: { editorState } } = this;\n\n    if (store.config.reviewMode !== ReviewModeType.REVIEW) {\n      return { editorState, operation: null };\n    }\n    if (isAnnotationReadonly(this.toolMode)) {\n      return { editorState, operation: null };\n    }\n    const operation = store.review.deleteMissingReview(id);\n    if (needUnRedo) {\n      this.addHistory(ACTION.DEL_MISSING_REVIEW, operation);\n    }\n    this.raw = this.renderTextArea();\n    return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n  };\n\n  deleteReview = (reviewId, needUnRedo = true) => {\n    const { state: { editorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState, operation: null };\n    }\n    const operation = store.review.deleteReview(reviewId);\n    if (needUnRedo) {\n      this.addHistory(ACTION.DELETE_REVIEW, operation);\n    }\n    this.raw = this.renderTextArea();\n    return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n  };\n\n  addReview = (editorState, reviewId, review, needUnRedo = true) => {\n    const { state: { editorState: currEditorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState: currEditorState, operation: null };\n    }\n    const operation = store.review.setReview(reviewId, {\n      ...review\n    });\n    if (needUnRedo) {\n      this.addHistory(ACTION.ADD_REVIEW, operation);\n    }\n    this.raw = this.renderTextArea();\n    return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n  };\n\n  deleteReviewItemById = (reviewId) => {\n    if (reviewId) {\n      let nextEditorState = this.state.editorState;\n      const reviewItem = store.ontology.getItemById(reviewId);\n      if (reviewItem && isQATag(reviewItem.type)) {\n        const { editorState } = this.deleteQATag(reviewItem.id);\n        nextEditorState = editorState;\n      } else {\n        const { editorState } = this.deleteReview(reviewId);\n        nextEditorState = editorState;\n      }\n      this.renderAndSave(nextEditorState);\n    }\n  };\n\n  deleteReviewItemsById = (reviewIds) => {\n    const operations = [];\n    reviewIds?.forEach((reviewId) => {\n      if (reviewId) {\n        const reviewItem = store.ontology.getItemById(reviewId);\n        if (reviewItem && isQATag(reviewItem.type)) {\n          const { operation } = this.deleteQATag(reviewItem.id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const { operation } = this.deleteReview(reviewId, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      }\n    });\n    this.addHistory(ACTION.DELETE_REVIEWS, operations);\n    const { state: { editorState } } = this;\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  deleteReviewItems = (reviewItems) => {\n    const operations = [];\n    const { state: { editorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return editorState;\n    }\n    reviewItems?.forEach((reviewItem) => {\n      const { review, id } = reviewItem;\n      if (review.result === ReviewItemResult.MISSING) {\n        const { operation } = this.deleteQATag(id, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      } else {\n        const { operation } = this.deleteReview(id, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      }\n    });\n    this.addHistory(ACTION.DELETE_REVIEWS, operations);\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  addReviewItems = (editorState, reviewItems) => {\n    const operations = [];\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return editorState;\n    }\n    reviewItems?.forEach((reviewItem) => {\n      const { review, id } = reviewItem;\n      if (review.result === ReviewItemResult.MISSING) {\n        const { operation } = this.addQALabel(editorState, reviewItem.label, { ...review }, false, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      } else {\n        const { operation } = this.addReview(editorState, id, { ...review }, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      }\n    });\n    this.addHistory(ACTION.ADD_REVIEWS, operations);\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  deleteReviewHandle = (reviewItem) => {\n    if (reviewItem) {\n      let nextEditorState = this.state.editorState;\n      if (isQATag(reviewItem.type)) {\n        const { editorState } = this.deleteQATag(reviewItem.id);\n        nextEditorState = editorState;\n      } else {\n        const { editorState } = this.deleteReview(reviewItem.id);\n        nextEditorState = editorState;\n      }\n      this.renderAndSave(nextEditorState);\n    }\n  };\n\n  onDeleteReview = () => {\n    const { tagOpenReview } = this.state;\n    this.deleteReviewHandle(tagOpenReview);\n  };\n\n  // create new RawDraftContentState and update customeStyleMap\n  // update: raw, style, sliceMap\n  renderTextArea = (_text) => {\n    const { ontology } = store;\n    const { ontologyConfigMap } = ontology;\n    const {\n      currentClick, currentHover,\n      foundTags, foundTagSelectedIndex, needJumpFound,\n    } = this.state;\n    const style = { ...this.state.style };\n    const text = _text || store.ontology.text;\n    const { labels, insertions } = ontology.getResults();\n    // render missing labels as normal labels\n\n    // slice text to segments\n    const slices = uniq(\n      (labels.map((label) => label.start))\n        .concat(labels.map((label) => label.end))\n        .concat(insertions.map((insertion) => insertion.at))\n        .concat(foundTags.map((t) => t.start))\n        .concat(foundTags.map((t) => t.end))\n        .concat([0, text.length])\n        .sort((a, b) => a - b)\n    );\n    const labelHeads = uniq((labels.map((label) => label.start)));\n    const insertionHeads = uniq((insertions.map((insertion) => insertion.at)));\n    const foundTagHeads = uniq((foundTags.map((tag) => tag.start)));\n\n    // .concat(insertions.map((insertion) => insertion.at)));\n    const raw = {\n      blocks: [{\n        text,\n        key: 'span-wrapper',\n        type: 'unstyled',\n        depth: 0,\n        inlineStyleRanges: [\n          { offset: 0, length: text.length, style: 'DEFAULT_STYLE' }],\n        children: [],\n        entityRanges: [],\n        data: {},\n      }],\n      entityMap: {}\n    };\n    let sliceCount = 0;\n    // 对重叠的tag进行背景色叠加\n    const ranges = raw.blocks[0].inlineStyleRanges;\n    this.sliceMap = new Map();\n    slices.forEach((anchor, index, array) => {\n      // set slice\n      if (!index) return;\n      const { prev, next } = { prev: array[index - 1], next: anchor };\n      const match = labels.filter((label) => (label.start <= prev && label.end > prev));\n      let currentRGB = [0, 0, 0];\n      let currentAlpha = 0;\n      let nextAlpha = DEFAULT_ALPHA;\n      let isCoverbyQa = false;\n      let keepRGB = null;\n      match.some((label) => {\n        const labelItem = getConfigByKeys(ontologyConfigMap, label.keys);\n        const tempRGB = convertColorToArray(labelItem.color);\n        if (!keepRGB) isCoverbyQa = isQATag(label.type);\n        // render clicked tag in priority\n        if (currentClick.id === label.id || currentClick.fromId === label.id || currentClick.toId === label.id) {\n          keepRGB = tempRGB.map((value, i) => value * ACTIVE_ALPHA);\n          isCoverbyQa = isQATag(label.type);\n          return true;\n        }\n\n        if ((!keepRGB && currentHover.id === label.id) || currentHover.fromId === label.id || currentHover.toId === label.id) {\n          keepRGB = tempRGB.map((v) => v * HOVER_ALPHA);\n        }\n\n        if (!keepRGB) {\n          currentRGB = currentRGB.map((value, i) => value + tempRGB[i] * nextAlpha);\n          currentAlpha += nextAlpha;\n          nextAlpha = DEFAULT_ALPHA * (1 - currentAlpha) * (1 - currentAlpha);\n        }\n        return false;\n      });\n      // background of found tag\n      foundTags\n        .filter((tag) => (tag.start <= prev && tag.end > prev))\n        .some((tag) => {\n          const tagIndex = foundTags.findIndex((f) => f.start === tag.start);\n          if (tagIndex !== undefined) {\n            keepRGB = foundTagSelectedIndex === tagIndex && !needJumpFound ? [255, 230, 0] : [255, 169, 64, 0.20];\n            return true;\n          }\n          return false;\n        });\n      const baseRGB = convertColorToArray(BASE_COLOR);\n      currentRGB = keepRGB || currentRGB.map((value, i) => Math.min(255, value + baseRGB[i] * (1 - currentAlpha)));\n      const currentColor = convertArrayToColor(currentRGB);\n\n      if (!style[`BACKGROUND_${currentColor}`]) style[`BACKGROUND_${currentColor}`] = { backgroundColor: currentColor };\n\n      if (isCoverbyQa) ranges.push({ offset: prev, length: next - prev, style: 'MISSING_STYLE' });\n      ranges.push({ offset: prev, length: next - prev, style: `BACKGROUND_${currentColor}` });\n      ranges.push({ offset: prev, length: next - prev, style: `SLICE_${prev}_${next}` });\n      // set slice head if for label/insertion slice\n      if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0) {\n        const slice = substr(text, prev, next - prev);\n        const head = getSliceHead(slice);\n        ranges.push({ offset: prev, length: strlen(head), style: `ANCHOR_${prev}` });\n      }\n      if (foundTagHeads.indexOf(prev) >= 0) {\n        const tagIndex = foundTags.findIndex((f) => f.start === prev);\n        if (tagIndex !== undefined) {\n          const tag = foundTags[tagIndex];\n          ranges.push({\n            offset: prev,\n            length: tag.end - tag.start,\n            style: foundTagSelectedIndex === tagIndex && !needJumpFound ? 'FIND_BLOCK_SELECTED' : 'FIND_BLOCK',\n          });\n        }\n      }\n\n      if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0 || foundTagHeads.indexOf(prev) >= 0) {\n        const slice = substr(text, prev, next - prev);\n        const head = getSliceHead(slice);\n        // set sliceMap\n        this.sliceMap.set(prev, sliceCount);\n        if (head !== slice) sliceCount += 1;\n      }\n      sliceCount += 1;\n    });\n    // update new style\n    this.setState({ style });\n    return raw;\n  };\n\n  async componentDidMount() {\n    this.toolMode = this.props.jobProxy.toolMode;\n    let { content } = this.props;\n    let results;\n\n    // insert qa tool's label\n    try {\n      const resultRes = await this.props.jobProxy.loadResult();\n      if (resultRes?.results && resultRes?.content) {\n        content = resultRes.content;\n        results = resultRes.results;\n      } else if (resultRes?.labels && resultRes?.connections && resultRes?.insertions) {\n        results = resultRes;\n      }\n    } catch (e) {\n      notification.error({ message: localMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // init store\n    try {\n      await store.init({ ...this.props, content: content || '' });\n    } catch (e) {\n      notification.error({ message: e.message, duration: null });\n      return;\n    }\n\n    // initialize results\n    store.ontology.parseResults(results);\n\n    const reviewRes = await this.props.jobProxy.loadReviews();\n    if (reviewRes) {\n      store.review.parseReview(reviewRes);\n    }\n\n    // initialize raw\n    this.raw = this.renderTextArea();\n    // apply composition lock\n    // if (this.state.labelsDrawerOpen) {\n    //   const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n    //   this.setState({ displayLabels });\n    // }\n    this.editorWrapper.addEventListener('compositionstart', this.onCompositionStart);\n    this.editorWrapper.addEventListener('compositionend', this.onCompositionEnd);\n\n    this.editorWrapper.addEventListener('mousedown', this.onMouseDown);\n    this.editorWrapper.addEventListener('dragstart', (e) => e.preventDefault());\n    this.editorWrapper.addEventListener('contextmenu', (e) => {\n      e.preventDefault();\n      this.resetCurrentFrom();\n      this.resetCurrentFocus('currentClick', true);\n    });\n    this.editorWrapper.addEventListener('mousemove', this.onMouseMove);\n\n    window.addEventListener('keydown', this.onKeyDown);\n    window.addEventListener('resize', () => this.renderAndSave(null, true, false, false));\n\n    // initialize customStyleMap\n    this.setState({\n      style: {\n        ...this.state.style,\n        DEFAULT_STYLE: {\n          color: this.fontColor,\n          fontSize: `${FONT_SIZE}px`,\n          lineHeight: `${LINE_HEIGHT}px`,\n          letterSpacing: `${FONT_SPACE}px`,\n        },\n        MISSING_STYLE: {\n          color: '#000000',\n        }\n      },\n    });\n    this.renderAndSave(EditorState.createWithContent(convertFromRaw(this.raw)), true, true, false);\n    // use url file backup to replace content, results, and reviews information\n    // use local storage backup to replace text, results, and reviews information\n    // save every 5 minutes\n    setInterval(() => {\n      this.onSave();\n    }, 1000 * 60 * 5);\n    if (this.props.renderComplete) {\n      this.props.renderComplete();\n    }\n  }\n\n  onMouseMove = (e) => {\n    const box = this.svg.getBoundingClientRect();\n    this.setState({\n      currentMouse: {\n        left: e.clientX - box.x,\n        top: e.clientY - box.y,\n      }\n    });\n  };\n\n  moveFocusToTag = (tag) => {\n    let currentClick = { ...this.state.currentClick };\n    const { tagMap } = this.state;\n    if (tag == null) return;\n    currentClick = {\n      id: tag.id,\n      fromId: tag.fromId,\n      toId: tag.toId,\n      fromType: tag.fromType,\n      toType: tag.toType,\n    };\n    const { top } = tagMap.getItem(tag.id, tag.type);\n    const { clientHeight, scrollTop } = this.editorWrapper;\n    if (top < scrollTop || top > clientHeight + scrollTop) {\n      this.editor.focus({ y: top });\n    }\n\n    this.setState({ currentClick }, () => {\n      this.updateEditorAndRender();\n    });\n  };\n\n  onKeyDown = (e) => {\n    if (window.disableTextHotKeys) {\n      return;\n    }\n    const { currentClick, editorState } = this.state;\n    const { keyCode, ctrlKey, altKey } = e;\n    const config = [];\n    store.ontology.ontologyConfigMap.forEach((value) => { config.push(value); });\n    if (ctrlKey) {\n      switch (true) {\n        case (keyCode >= 48 && keyCode <= 57): {\n          // 0 - 9\n          e.preventDefault();\n          const index = e.keyCode - 49;\n          if (index === -1) {\n            this.setCurrentBrush(null);\n          }\n          if (config[index]) {\n            this.setCurrentBrush(config[index]);\n          }\n          break; }\n        case (keyCode === 90): e.preventDefault(); this.executeHistory(RECALL_TYPE.UNDO); break; // Z\n        case (keyCode === 89): e.preventDefault(); this.executeHistory(RECALL_TYPE.REDO); break; // Y\n        case (keyCode === 83): e.preventDefault(); this.onSave(); break; // S\n        case (keyCode === 82): { // R\n          e.preventDefault();\n          const nTag = store.ontology.moveToTagByStep(currentClick.id, 1, true);\n          this.moveFocusToTag(nTag);\n          break;\n        }\n        case (keyCode === 81): { // Q\n          e.preventDefault();\n          if (currentClick.id == null) break;\n          let nxtTag;\n          if (altKey) {\n            nxtTag = store.ontology.stepToTag(currentClick.id, -1);\n          } else {\n            nxtTag = store.ontology.moveToTagByStep(currentClick.id, -1);\n          }\n          this.moveFocusToTag(nxtTag);\n          break;\n        }\n        case (keyCode === 69): { // E\n          e.preventDefault();\n          if (currentClick.id == null) break;\n          let nextTag;\n          if (altKey) {\n            nextTag = store.ontology.stepToTag(currentClick.id, 1);\n          } else {\n            nextTag = store.ontology.moveToTagByStep(currentClick.id, 1);\n          }\n          this.moveFocusToTag(nextTag);\n          break;\n        }\n        default: break;\n      }\n    } else if (currentClick?.id !== null && isReviewEditable(this.toolMode) && !isQATag(currentClick.type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n      switch (keyCode) {\n        case 49: // 1\n          e.preventDefault();\n          e.stopPropagation();\n          this.addReview(editorState, currentClick.id, {\n            result: 'pass',\n          });\n          break;\n        // 2\n        case 50: {\n          e.preventDefault();\n          e.stopPropagation();\n          let tagReviewInfo = store.review.getReview(currentClick.id);\n          if (!tagReviewInfo || tagReviewInfo.result !== ReviewItemResult.REJECT) {\n            tagReviewInfo = { result: 'reject', id: currentClick.id, type: [] };\n          }\n          const item = store.ontology.getItem(currentClick.type, currentClick.id);\n\n          this.setState({ tagOpenReview: item, tagReviewInfo });\n          this.editor.blur();\n          break;\n        }\n        default: break;\n      }\n    }\n  };\n\n  // update text\n  onContentChange = (editorState, data, type) => {\n    const { currentBrush, editorState: preState, findPanelVisible, inputEnable } = this.state;\n\n    if (\n      (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW)\n      || ((currentBrush || findPanelVisible || !inputEnable) && type === undefined)\n      || this.props.read_only\n    ) {\n      return preState;\n    }\n    const { slice, prevSlice, tags, prevTags } = data;\n    let { prevStart, prevEnd } = data;\n\n    if (prevSlice.length === 1 && slice.length === 0) this.addHistory(ACTION.EDIT_SINGLE_DEL, data);\n    else if (prevSlice.length === 0 && slice.length === 1) this.addHistory(ACTION.EDIT_SINGLE_ADD, data);\n    else if (type === ACTION.EDIT_REPLACE) this.addHistory(ACTION.EDIT_REPLACE, data);\n    else this.addHistory(ACTION.EDIT_DEFAULT, data);\n\n    prevStart = strlen(store.ontology.text.slice(0, data.prevStart));\n    prevEnd = strlen(store.ontology.text.slice(0, data.prevEnd));\n    store.ontology.text = store.ontology.text.slice(0, data.prevStart) + data.slice + store.ontology.text.slice(data.prevEnd);\n    // update labels and insertions\n    const offset = slice.length - prevSlice.length;\n\n    if (type === ACTION.EDIT_REPLACE && prevTags) {\n      const { insertions = [], labels = [], connections = [] } = prevTags;\n      [...insertions, ...labels, ...connections].forEach((t) => {\n        store.ontology.deleteTag(t.type, t.id);\n      });\n    }\n    store.ontology.tagMove(prevStart, prevEnd, offset);\n    if (type === ACTION.EDIT_REPLACE && tags) {\n      const { insertions = [], labels = [], connections = [] } = tags;\n      [...insertions, ...labels, ...connections].forEach((t) => {\n        store.ontology.addResultItem(t);\n      });\n    }\n\n    // update rawDraftContentState, using new text and results\n    // this.updateFindTags();\n    this.raw = this.renderTextArea();\n\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    return editorState;\n  };\n\n  resetCurrentFocus = (attribute = 'currentClick', shouldUpdate) => new Promise((resolve) => {\n    this.setState({\n      [`${attribute}`]: { id: null, from: null, to: null },\n    }, () => resolve('state updated'));\n  }).then(() => {\n    if (shouldUpdate) {\n      return this.updateEditorAndRender();\n    }\n  });\n\n  resetCurrentFrom = () => {\n    this.setState({\n      currentFrom: { type: null, id: null, offset: null },\n    });\n  };\n\n  // to status for tag: connection mode and other mode\n  onTagClick = (e, type, id) => {\n    const { currentFrom, currentBrush, editorState, tagMap } = this.state;\n    const offset = tagMap.getItem(id, type);\n    this.editor.blur();\n    if (!isConnection(currentBrush?.type)) return;\n\n    // connecting mode only applys to label and insertion\n    if (isLabel(type) || isInsertion(type)) {\n      // if there is no starting point, setup the starting point\n      if (!currentFrom.type) {\n        this.setState({\n          currentFrom: {\n            type,\n            id,\n            offset,\n          }\n        });\n      } else {\n        const nextEditorState = this.addConnection(editorState, { fromId: currentFrom.id, fromType: currentFrom.type, toId: id, toType: type, type: TAG.CONNECTION, value: currentBrush.text, keys: currentBrush.keys });\n        this.renderAndSave(nextEditorState, true, true);\n      }\n    }\n  };\n\n  onTagDoubleClick = (e) => {\n    // only work in qa mode\n    if (!store.reviewable && !store.isRework) {\n      return;\n    }\n    const { id, type } = getTargetWrapperDataSet(e);\n    const item = store.ontology.getItem(type, id);\n    const tagReviewInfo = store.review.getReview(id);\n    this.setState({ tagOpenReview: item, tagReviewInfo });\n    this.editor.blur();\n  };\n\n  // mouseEvent includes: mouse enter, mouse leave, mouse click, mouse context menu\n  TagMouseEvent = (e, type, id, focusType, active) => {\n    const { currentClick: { id: currId } } = this.state;\n    const tag = store.ontology.getItem(type, id);\n    if (!tag) {\n      return;\n    }\n\n    let attribute = '';\n    if (focusType === FOCUS_TYPE.HOVER) {\n      if (currId === tag.id && active) return;\n      attribute = 'currentHover';\n    } else if (focusType === FOCUS_TYPE.CLICK) {\n      attribute = 'currentClick';\n      this.editor.blur();\n    }\n\n    // active status: mouse enter | mouse click\n    if (active) {\n      if (focusType === FOCUS_TYPE.CLICK) {\n        this.onTagClick(e, type, id);\n      }\n      // ranges.push({ offset: label.start, length: label.end - label.start, style: `${focusType}_STYLE_${color}` });\n      this.setState({\n        [`${attribute}`]: {\n          id: tag.id,\n          fromId: tag?.fromId,\n          toId: tag?.toId,\n          fromType: tag?.fromType,\n          toType: tag?.toType,\n          type: tag?.type,\n        }\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    } else { // unactive status: mouse leave | mouse context menu\n      const tagType = type;\n      this.resetCurrentFocus(attribute, true).then(() => {\n        if (focusType === FOCUS_TYPE.CLICK) {\n          this.onContextMenu(e, tag.id, tagType);\n        }\n      });\n    }\n  };\n\n  onContextMenu = (e, id, type) => {\n    let nextEditorState;\n    switch (type) {\n      case TAG.LABEL:\n      case TAG.CONNECTION:\n      case TAG.INSERTION:\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      case TAG.LABEL_QA:\n      {\n        const { editorState } = this.deleteQATag(id);\n        nextEditorState = editorState;\n        break;\n      }\n      default: return;\n    }\n    this.renderAndSave(nextEditorState);\n  };\n\n  // toggleLabelsDrawer = () => {\n  //   if (!this.state.labelsDrawerOpen) {\n  //     const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n  //     this.setState({ displayLabels });\n  //   }\n  //   this.setState({ labelsDrawerOpen: !this.state.labelsDrawerOpen }, () => {\n  //     this.updateEditorAndRender();\n  //     localStorage.setItem(storageKey, this.state.labelsDrawerOpen);\n  //   });\n  // };\n\n  toggleFindPanelVisible = (visible) => {\n    this.setState({\n      findPanelVisible: visible,\n      inputEnable: false,\n      currentBrush: null,\n    });\n    if (visible) {\n      this.onFind(this.state.findStr);\n    } else {\n      this.setState({\n        foundTags: [],\n        needJumpFound: false,\n        foundTagSelectedIndex: 0,\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    }\n  };\n\n  jumpToFindTag = async (offset, findString) => {\n    const { findStr } = this.state;\n    if (!findStr) {\n      this.onFind(findString);\n      return;\n    }\n    const { foundTagSelectedIndex, foundTags } = this.state;\n    if (foundTags.length === 0) {\n      this.updateEditorAndRender();\n      return;\n    }\n    let newFindTagSelectedIndex = foundTagSelectedIndex + offset;\n    if (newFindTagSelectedIndex < 0) {\n      newFindTagSelectedIndex = foundTags.length - 1;\n    }\n    if (newFindTagSelectedIndex > foundTags.length - 1) {\n      newFindTagSelectedIndex = 0;\n    }\n    this.setState({\n      needJumpFound: false,\n      foundTagSelectedIndex: newFindTagSelectedIndex,\n    }, () => {\n      this.focusSelectedFoundTag();\n    });\n  };\n\n  focusSelectedFoundTag = () => {\n    this.updateEditorAndRender();\n    const { foundTags, foundTagSelectedIndex } = this.state;\n    const selectedTag = foundTags[foundTagSelectedIndex];\n    if (selectedTag) {\n      const span = this.getAnchorElementByHead(selectedTag.start);\n      if (span && this.editorWrapper && !isElementInViewport(span, this.editorWrapper)) {\n        const { top } = span.getBoundingClientRect();\n        const offsetHeight = this.editorWrapper.clientHeight / 2;\n        const scrollTop = this.editorWrapper.scrollTop + top - offsetHeight;\n        this.editorWrapper.scroll(0, scrollTop);\n      }\n    }\n  };\n\n  updateFindTags = () => new Promise((resolve) => {\n    const { findStr } = this.state;\n    const str = store.ontology.text;\n    const reg = new RegExp(escapeCharacter(findStr), 'g');\n    const ans = [];\n    if (findStr) {\n      let matched = null;\n      let i = 0;\n      // eslint-disable-next-line no-cond-assign\n      while ((matched = reg.exec(str)) !== null) {\n        const temp = {\n          start: matched.index,\n          end: matched.index + findStr.length,\n          id: i,\n        };\n        ans.push(temp);\n        i += 1;\n      }\n    }\n    this.setState({ foundTags: ans, foundTagSelectedIndex: -1 }, () => {\n      resolve();\n    });\n  });\n\n  onFind = (_findStr, selectedIndex) => {\n    const { findStr, foundTags } = this.state;\n    if (findStr && _findStr === findStr && foundTags.length > 0 && selectedIndex === undefined) {\n      this.jumpToFindTag(1, findStr);\n    } else if (_findStr) {\n      this.setState({ findStr: _findStr }, async () => {\n        await this.updateFindTags();\n        this.jumpToFindTag(selectedIndex || 1, findStr);\n      });\n    } else {\n      this.setState({ findStr: '', foundTags: [], foundTagSelectedIndex: -1 }, () => {\n        this.updateEditorAndRender();\n      });\n    }\n  };\n\n  render() {\n    const {\n      editorState,\n      style,\n      currentBrush,\n      editorWidth,\n      editorHeight,\n      currentClick,\n      currentHover,\n      currentMouse,\n      currentFrom,\n      tagMap,\n      tagOpenReview,\n      tagReviewInfo,\n\n      inputEnable,\n    } = this.state;\n    const { config } = store;\n    return (\n      <div className=\"app-wrapper\">\n        <div className=\"topbar-wrapper\" onClick={() => { this.editorOnFocus = false; }}>\n          <div className=\"topbar-left-wrapper\">\n            {isAppenCloud() && (\n            <div className=\"logo\">\n              <AppenLogo />\n            </div>\n            )}\n            <ReviewMode />\n            <div className=\"divider\" />\n            <UndoRedo\n              undoHandle={() => this.executeHistory(RECALL_TYPE.UNDO)}\n              redoHandle={() => this.executeHistory(RECALL_TYPE.REDO)}\n              undoList={this.undoList}\n              redoList={this.redoList}\n            />\n            <div className=\"divider\" />\n            <Save onSave={this.onSave} />\n          </div>\n          <div className=\"topbar-right-wrapper\">\n            {/* <LabelScan onToggle={this.toggleLabelsDrawer} /> */}\n          </div>\n        </div>\n        <TextToolContext.Provider value={{ moveFocusToTag: this.moveFocusToTag, deleteReviewItemById: this.deleteReviewItemById, deleteReviewItemsById: this.deleteReviewItemsById }}>\n          <Sidebar\n            showReview={isRework(this.toolMode) || isReviewEditable(this.toolMode)}\n            onClick={() => { this.editorOnFocus = false; }}\n            currentBrush={currentBrush}\n            inputEnable={inputEnable}\n            setCurrentBrush={this.setCurrentBrush}\n            items={tagMap}\n            contentReadyOnly={this.props.read_only}\n          />\n        </TextToolContext.Provider>\n        <div className=\"right-wrapper\">\n          <div\n            className=\"editor-wrapper\"\n            ref={(r) => { this.editorWrapper = r; }}\n          >\n            <div className=\"svg-wrapper\">\n              <svg ref={(r) => { this.svg = r; }} style={{ height: `${editorHeight}px`, width: `${editorWidth}px` }}>\n                {Object.entries(tagMap.connections).map(([id, connect]) => (\n                  <g key={id}>\n                    <path\n                      d={connect.path}\n                      stroke={currentHover.id === id ? HOVER_COLOR : currentClick.id === id ? FOCUS_COLOR : DEFAULT_COLOR}\n                      fill=\"#00000000\"\n                    />\n                  </g>\n                ))}\n                {currentFrom.type ?\n                  <path d={`M ${currentFrom.offset?.left} ${currentFrom.offset?.top} L ${currentMouse.left} ${currentMouse.top}`} stroke={FOCUS_COLOR} fill=\"#00000000\" /> :\n                  null}\n              </svg>\n            </div>\n            <div className=\"tags-wrapper\">\n              <div\n                className=\"tags-panel\"\n                style={{ height: `${editorHeight}px`, width: `${editorWidth}px` }}\n                onDoubleClick={this.onTagDoubleClick}\n              >\n                {Object.entries(tagMap.labels).map(([id, label]) => (\n                  <LabelTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    label={label}\n                    isHover={\n                      (currentHover.id === id) ||\n                      currentHover.fromId === id ||\n                      currentHover.toId === id\n                    }\n                    isClick={\n                      (currentClick.id === id) ||\n                      currentClick.fromId === id ||\n                      currentClick.toId === id\n                    }\n                    labelMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n                {Object.entries(tagMap.insertions).map(([id, insertion]) => (\n                  <InsertionTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    insertion={insertion}\n                    isHover={\n                      (currentHover.id === id) ||\n                      currentHover.fromId === id ||\n                      currentHover.toId === id\n                    }\n                    isClick={\n                      (currentClick.id === id) ||\n                      currentClick.fromId === id ||\n                      currentClick.toId === id\n                    }\n                    insertionMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n                {Object.entries(tagMap.connections).map(([id, connection]) => (\n                  <ConnectionTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    connection={connection}\n                    isHover={currentHover.id === id}\n                    isClick={currentClick.id === id}\n                    connectionMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n              </div>\n            </div>\n            <div\n              onClick={() => {\n                this.editor.focus();\n                this.resetCurrentFocus('currentClick', true);\n              }}\n            >\n              <Editor\n                ref={(r) => { this.editor = r; }}\n                editorState={editorState}\n                customStyleMap={style}\n                onChange={this.onChange}\n                handlePastedText={this.handlePastedText}\n                handleBeforeInput={this.handleBeforeInput}\n                handleKeyCommand={this.handleKeyCommand}\n                keyBindingFn={this.genKeyCommand}\n              />\n            </div>\n          </div>\n          {/* {labelsDrawerOpen && (\n            <LabelsDisplay\n              title={localMessage('LABEL_CONTENT')}\n              labelsDrawerOpen={labelsDrawerOpen}\n              displayLabels={displayLabels}\n            />\n          )} */}\n        </div>\n        <ReviewForm\n          toolMode={this.toolMode}\n          tagReviewInfo={tagReviewInfo}\n          tagOpenReview={tagOpenReview}\n          issueTypes={this.props.issue_types}\n          setFormVisible={this.setFormVisible}\n          onConfirm={(review) => {\n            this.addReview(editorState, tagOpenReview?.id, review);\n            store.ontology.updateOntologiesStatusMap();\n          }}\n          onDelete={this.onDeleteReview}\n        />\n      </div>\n    );\n  };\n\n  setCurrentBrush = (item, input = false) => {\n    this.setState({ currentBrush: item, inputEnable: input });\n  };\n\n  setFormVisible = () => {\n    this.setState({ tagOpenReview: null, tagReviewInfo: null });\n  };\n\n  genKeyCommand = (e) => {\n    if (e.metaKey || e.altKey) return KEY_COMMAND.INVALID_KEY;\n    switch (e.keyCode) {\n      case 90:\n        // prevent default undo\n        e.preventDefault();\n        if (e.ctrlKey) return KEY_COMMAND.HANDLE_UNDO;\n        return getDefaultKeyBinding(e);\n      case 89:\n        // prevent default redo\n        e.preventDefault();\n        if (e.ctrlKey) return KEY_COMMAND.HANDLE_REDO;\n        return getDefaultKeyBinding(e);\n      case 13:\n        e.preventDefault();\n        return KEY_COMMAND.HANDLE_RETURN;\n      default:\n        return getDefaultKeyBinding(e);\n    }\n  };\n\n  handleKeyCommand = (command) => {\n    const { editorState } = this.state;\n    switch (command) {\n      case KEY_COMMAND.INVALID_KEY: return 'handled';\n      case KEY_COMMAND.HANDLE_RETURN:\n      {\n        const start = editorState.getSelection().getStartOffset();\n        const end = editorState.getSelection().getEndOffset();\n        const nextEditorState = setSelection(this.onContentChange(editorState, {\n          slice: '\\n',\n          prevSlice: store.ontology.text.slice(start, end),\n          prevStart: start,\n          prevEnd: end,\n          start: start + 1,\n          end: start + 1,\n        }), start + 1, start + 1);\n        this.renderAndSave(nextEditorState);\n        return 'handled';\n      }\n      case KEY_COMMAND.HANDLE_UNDO: return 'handled';\n      case KEY_COMMAND.HANDLE_REDO: return 'handled';\n      default: return 'not-handled';\n    }\n  };\n\n  // Get one anchor by slice head\n  getAnchorElementByHead = (at) => {\n    const { sliceMap } = this;\n    const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n    const id = `span-wrapper-0-${sliceMap.get(at)}`;\n    const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n    return span;\n  };\n\n  // Get all anchors at one time\n  getAnchorElementsByHeads = () => {\n    const { sliceMap } = this;\n    const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n    const spanMap = new Map();\n    sliceMap.forEach((value, key) => {\n      const id = `span-wrapper-0-${sliceMap.get(key)}`;\n      const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n      spanMap.set(key, span);\n    });\n    return spanMap;\n  };\n\n  onMouseDown = (e) => {\n    if (e.which === 1) {\n      this.mouseFlag = true;\n    }\n    const onMouseUp = () => {\n      this.mouseFlag = false;\n      window.removeEventListener('mouseup', onMouseUp);\n    };\n    window.addEventListener('mouseup', onMouseUp);\n  };\n\n  onCompositionEnd = () => {\n    this.compositionFlag = COMPOSITION.PENDING;\n  };\n\n  onCompositionStart = () => {\n    this.compositionFlag = COMPOSITION.ENABLED;\n    this.compositionTop = this.editorWrapper.scrollTop;\n  };\n\n  handleBeforeInput = () => { this.inputFlag = true; return 'not-handled'; };\n\n  handlePastedText = () => { this.pasteFlag = true; return 'not-handled'; };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}