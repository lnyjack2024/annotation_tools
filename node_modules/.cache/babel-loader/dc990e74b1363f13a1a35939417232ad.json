{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport CameraData from './CameraData';\n/**\n * instance item\n * @class\n */\nexport default class InstanceItem {\n  /**\n   * instance item name\n   * @getter\n   */\n  get name() {\n    return this.categoryItemRef.name;\n  }\n\n  /**\n   * instance item label\n   * @getter\n   */\n  get label() {\n    if (this.instance.isSingle) {\n      return this.instance.label;\n    }\n    return `${this.instance.label}-${this.itemLabel}`;\n  }\n\n  /**\n   * instance item label only\n   * @getter\n   */\n  get itemLabel() {\n    let label = this.categoryItemRef.displayName;\n    if (this.instance.isSingle) {\n      label = this.instance.categoryRef.displayName;\n    }\n    if (this.isSingle) {\n      return label;\n    }\n    return `${label}${this.number}`;\n  }\n\n  /**\n   * instance item frame status (merged status)\n   * @getter\n   */\n  get frameStatus() {\n    // simple merge\n    return Object.values(this.cameras).map(c => c.frameStatus).reduce((acc, curr) => ({\n      ...acc,\n      ...curr\n    }), {});\n  }\n\n  /**\n   * instance item existed camera names\n   * @getter\n   */\n  get existedCameras() {\n    return Object.keys(this.cameras).filter(cameraName => !this.cameras[cameraName].isEmpty);\n  }\n\n  /**\n   * is instance item empty\n   * @getter\n   */\n  get isEmpty() {\n    return Object.values(this.cameras).every(camera => camera.isEmpty);\n  }\n\n  /**\n   * is instance item only contains one shape\n   * @getter\n   */\n  get isSingle() {\n    return this.categoryItemRef.count === 1;\n  }\n  constructor({\n    id,\n    instance,\n    categoryItemRef,\n    number,\n    cameras = []\n  }) {\n    /**\n     * instance item id\n     * @member\n     */\n    this.id = void 0;\n    /**\n     * instance which belongs to\n     * @member\n     */\n    this.instance = void 0;\n    /**\n     * category item reference\n     * @member\n     */\n    this.categoryItemRef = void 0;\n    /**\n     * instance item number\n     * @member\n     */\n    this.number = void 0;\n    /**\n     * instance item camera data\n     * @member\n     */\n    this.cameras = {};\n    /**\n     * is instance item selected\n     * @member\n     */\n    this.selected = false;\n    makeAutoObservable(this, {\n      id: false,\n      instance: false,\n      categoryItemRef: false,\n      number: false,\n      label: false,\n      itemLabel: false,\n      isEmpty: false,\n      isSingle: false\n    }, {\n      autoBind: true\n    });\n    this.id = id || uuidv4();\n    this.instance = instance;\n    this.categoryItemRef = categoryItemRef;\n    this.number = number;\n    cameras.forEach(camera => this.createCameraFromData(camera));\n  }\n\n  /**\n   * create camera from structured camera data\n   * @param cameraData\n   */\n  createCameraFromData(cameraData) {\n    const camera = new CameraData({\n      camera: cameraData.camera,\n      frames: cameraData.frames\n    });\n    this.cameras[camera.camera] = camera;\n  }\n\n  /**\n   * set selected\n   * @param selected\n   */\n  setSelected(selected) {\n    this.selected = selected;\n  }\n\n  /**\n   * get camera\n   * @param camera\n   */\n  getCamera(camera) {\n    if (!this.cameras[camera]) {\n      // create camera if not exist\n      this.createCameraFromData({\n        camera,\n        frames: []\n      });\n    }\n    return this.cameras[camera];\n  }\n\n  /**\n   * set attributes in frame\n   * @param camera\n   * @param frames\n   * @param attributes\n   */\n  setAttributes(camera, frames, attributes) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.setAttributes(frames, attributes);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * add shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param isOCR\n   * @param isFormula\n   */\n  addShape(camera, frameIndex, interpolation, shapeType, shapeData, order, isOCR, isFormula) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.addShape(frameIndex, interpolation, shapeType, shapeData, order, isOCR, isFormula);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * update shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(camera, frameIndex, interpolation, shapeType, shapeData, order, attributes) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.updateShape(frameIndex, interpolation, shapeType, shapeData, order, attributes);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * predict shape\n   * @param camera\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(camera, frameIndex, imageBounds, useNearest) {\n    const cameraData = this.getCamera(camera);\n    return cameraData.predictShape(frameIndex, imageBounds, useNearest);\n  }\n\n  /**\n   * remove from frames\n   * @param camera\n   * @param frames\n   */\n  remove(camera, frames) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.remove(frames);\n    if (cameraData.isEmpty) {\n      // delete camera\n      delete this.cameras[camera];\n    }\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * update frames by frame data\n   * @param camera\n   * @param frames\n   */\n  updateFramesFromData(camera, frames) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.updateFramesFromData(frames);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * add relationship\n   * @param relationship\n   */\n  addRelationship(camera, relationship) {\n    const cameraData = this.getCamera(camera);\n    cameraData.addRelationship(relationship);\n  }\n\n  /**\n   * remove relationship\n   * @param camera\n   * @param relationship\n   */\n  removeRelationship(camera, relationship) {\n    const cameraData = this.getCamera(camera);\n    cameraData.removeRelationship(relationship);\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON() {\n    return {\n      ...this.getBasicInfo(),\n      cameras: Object.values(this.cameras).filter(camera => !camera.isEmpty).map(camera => camera.toJSON())\n    };\n  }\n\n  /**\n   * return basic info data\n   */\n  getBasicInfo() {\n    return {\n      id: this.id,\n      name: this.name,\n      displayName: this.categoryItemRef.displayName,\n      displayColor: this.categoryItemRef.displayColor,\n      number: this.number\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState, currState) {\n    const basicInfo = this.getBasicInfo();\n    return {\n      ...(prevState.length > 0 && {\n        prevState: {\n          ...basicInfo,\n          cameras: [...prevState]\n        }\n      }),\n      ...(currState.length > 0 && {\n        currState: {\n          ...basicInfo,\n          cameras: [...currState]\n        }\n      })\n    };\n  }\n}","map":{"version":3,"names":["makeAutoObservable","v4","uuidv4","CameraData","InstanceItem","name","categoryItemRef","label","instance","isSingle","itemLabel","displayName","categoryRef","number","frameStatus","Object","values","cameras","map","c","reduce","acc","curr","existedCameras","keys","filter","cameraName","isEmpty","every","camera","count","constructor","id","selected","autoBind","forEach","createCameraFromData","cameraData","frames","setSelected","getCamera","setAttributes","attributes","prevState","currState","formatChangedState","addShape","frameIndex","interpolation","shapeType","shapeData","order","isOCR","isFormula","updateShape","predictShape","imageBounds","useNearest","remove","updateFramesFromData","addRelationship","relationship","removeRelationship","toJSON","getBasicInfo","displayColor","basicInfo","length"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/model/InstanceItem.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport CameraData from './CameraData';\nimport Instance from './Instance';\nimport Relationship from './Relationship';\nimport { CameraData as ICameraData, InstanceItem as IInstanceItem, FrameData as IFrameData, CategoryItem } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\n\ninterface InstanceItemOptions {\n  id?: string;\n  instance: Instance;\n  categoryItemRef: CategoryItem;\n  number: number;\n  cameras?: ICameraData[],\n}\n\ninterface ChangedState {\n  prevState?: IInstanceItem;\n  currState?: IInstanceItem;\n}\n\n/**\n * instance item\n * @class\n */\nexport default class InstanceItem {\n  /**\n   * instance item id\n   * @member\n   */\n  id: string;\n\n  /**\n   * instance which belongs to\n   * @member\n   */\n  instance: Instance;\n\n  /**\n   * category item reference\n   * @member\n   */\n  categoryItemRef: CategoryItem;\n\n  /**\n   * instance item number\n   * @member\n   */\n  number: number;\n\n  /**\n   * instance item camera data\n   * @member\n   */\n  cameras: { [camera: string]: CameraData } = {};\n\n  /**\n   * is instance item selected\n   * @member\n   */\n  selected = false;\n\n  /**\n   * instance item name\n   * @getter\n   */\n  get name() {\n    return this.categoryItemRef.name;\n  }\n\n  /**\n   * instance item label\n   * @getter\n   */\n  get label() {\n    if (this.instance.isSingle) {\n      return this.instance.label;\n    }\n    return `${this.instance.label}-${this.itemLabel}`;\n  }\n\n  /**\n   * instance item label only\n   * @getter\n   */\n  get itemLabel() {\n    let label = this.categoryItemRef.displayName;\n    if (this.instance.isSingle) {\n      label = this.instance.categoryRef.displayName;\n    }\n    if (this.isSingle) {\n      return label;\n    }\n    return `${label}${this.number}`;\n  }\n\n  /**\n   * instance item frame status (merged status)\n   * @getter\n   */\n  get frameStatus() {\n    // simple merge\n    return Object.values(this.cameras)\n      .map((c) => c.frameStatus)\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n  }\n\n  /**\n   * instance item existed camera names\n   * @getter\n   */\n  get existedCameras() {\n    return Object.keys(this.cameras).filter((cameraName) => !this.cameras[cameraName].isEmpty);\n  }\n\n  /**\n   * is instance item empty\n   * @getter\n   */\n  get isEmpty() {\n    return Object.values(this.cameras).every((camera) => camera.isEmpty);\n  }\n\n  /**\n   * is instance item only contains one shape\n   * @getter\n   */\n  get isSingle() {\n    return this.categoryItemRef.count === 1;\n  }\n\n  constructor({ id, instance, categoryItemRef, number, cameras = [] }: InstanceItemOptions) {\n    makeAutoObservable(this, {\n      id: false,\n      instance: false,\n      categoryItemRef: false,\n      number: false,\n      label: false,\n      itemLabel: false,\n      isEmpty: false,\n      isSingle: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.id = id || uuidv4();\n    this.instance = instance;\n    this.categoryItemRef = categoryItemRef;\n    this.number = number;\n    cameras.forEach((camera) => this.createCameraFromData(camera));\n  }\n\n  /**\n   * create camera from structured camera data\n   * @param cameraData\n   */\n  createCameraFromData(cameraData: ICameraData) {\n    const camera = new CameraData({\n      camera: cameraData.camera,\n      frames: cameraData.frames,\n    });\n    this.cameras[camera.camera] = camera;\n  }\n\n  /**\n   * set selected\n   * @param selected\n   */\n  setSelected(selected: boolean) {\n    this.selected = selected;\n  }\n\n  /**\n   * get camera\n   * @param camera\n   */\n  getCamera(camera: string) {\n    if (!this.cameras[camera]) {\n      // create camera if not exist\n      this.createCameraFromData({ camera, frames: [] });\n    }\n    return this.cameras[camera];\n  }\n\n  /**\n   * set attributes in frame\n   * @param camera\n   * @param frames\n   * @param attributes\n   */\n  setAttributes(camera: string, frames: number[], attributes: { attributes?: any; OCRText?: string; formulaText?: string }) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.setAttributes(frames, attributes);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * add shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param isOCR\n   * @param isFormula\n   */\n  addShape(camera: string, frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, isOCR?: boolean, isFormula?: boolean): ChangedState {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.addShape(frameIndex, interpolation, shapeType, shapeData, order, isOCR, isFormula);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * update shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(camera: string, frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, attributes?: any) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.updateShape(frameIndex, interpolation, shapeType, shapeData, order, attributes);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * predict shape\n   * @param camera\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(camera: string, frameIndex: number, imageBounds?: { top: number; right: number; bottom: number; left: number }, useNearest?: boolean) {\n    const cameraData = this.getCamera(camera);\n    return cameraData.predictShape(frameIndex, imageBounds, useNearest);\n  }\n\n  /**\n   * remove from frames\n   * @param camera\n   * @param frames\n   */\n  remove(camera: string, frames: number[]) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.remove(frames);\n    if (cameraData.isEmpty) {\n      // delete camera\n      delete this.cameras[camera];\n    }\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * update frames by frame data\n   * @param camera\n   * @param frames\n   */\n  updateFramesFromData(camera: string, frames: IFrameData[]) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.updateFramesFromData(frames);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * add relationship\n   * @param relationship\n   */\n  addRelationship(camera: string, relationship: Relationship) {\n    const cameraData = this.getCamera(camera);\n    cameraData.addRelationship(relationship);\n  }\n\n  /**\n   * remove relationship\n   * @param camera\n   * @param relationship\n   */\n  removeRelationship(camera: string, relationship: Relationship) {\n    const cameraData = this.getCamera(camera);\n    cameraData.removeRelationship(relationship);\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON(): IInstanceItem {\n    return {\n      ...this.getBasicInfo(),\n      cameras: Object.values(this.cameras)\n        .filter((camera) => !camera.isEmpty)\n        .map((camera) => camera.toJSON()),\n    };\n  }\n\n  /**\n   * return basic info data\n   */\n  getBasicInfo() {\n    return {\n      id: this.id,\n      name: this.name,\n      displayName: this.categoryItemRef.displayName,\n      displayColor: this.categoryItemRef.displayColor,\n      number: this.number,\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState: ICameraData[], currState: ICameraData[]): ChangedState {\n    const basicInfo = this.getBasicInfo();\n    return {\n      ...prevState.length > 0 && {\n        prevState: { ...basicInfo, cameras: [...prevState] },\n      },\n      ...currState.length > 0 && {\n        currState: { ...basicInfo, cameras: [...currState] },\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}