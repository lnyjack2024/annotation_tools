{"ast":null,"code":"import i18n from './locales';\nimport { ValidationType, Tool } from './types';\nimport { ShapeType } from '../common/shapes/types';\nimport { fetchResultByUrl, runCustomValidation } from '../../utils';\nimport { computeRotatedPosition } from '../../utils/math';\nexport function parseFrames(frames) {\n  if (typeof frames === 'string') {\n    return frames.split(',').map(f => f.trim());\n  }\n  return [...frames];\n}\nexport async function parseFramesByPaylod({\n  frames,\n  base_url\n}) {\n  let parsedFrames = [];\n  if (frames) {\n    parsedFrames = parseFrames(frames);\n  } else if (base_url) {\n    try {\n      const res = await fetchResultByUrl(base_url);\n      if (res && res.frames && Array.isArray(res.frames)) {\n        parsedFrames = [...res.frames];\n      }\n    } catch (e) {\n      // fetch error\n    }\n  }\n  return parsedFrames;\n}\nexport function loadInstancesFromResult(result, frameCount) {\n  const instances = {};\n  const frameInstances = Array.from({\n    length: frameCount\n  }).map(() => []);\n  const categoryInstancesMap = {};\n  if (result && result.instances && Array.isArray(result.instances)) {\n    result.instances.forEach(({\n      id,\n      category,\n      number,\n      frames\n    }) => {\n      const instance = {\n        id,\n        category,\n        number,\n        frames: {}\n      };\n      (frames || []).forEach(frame => {\n        const {\n          frameIndex,\n          shape\n        } = frame;\n        if (frame.shapeType === ShapeType.RECTANGLE && typeof shape.points === 'string') {\n          const points = [{\n            x: shape.x,\n            y: shape.y\n          }, {\n            x: shape.x + shape.width,\n            y: shape.y\n          }, {\n            x: shape.x + shape.width,\n            y: shape.y + shape.height\n          }, {\n            x: shape.x,\n            y: shape.y + shape.height\n          }];\n          if (shape.rotation) {\n            points.forEach(p => {\n              const point = computeRotatedPosition({\n                x: shape.x + shape.width / 2,\n                y: shape.y + shape.height / 2\n              }, p, shape.rotation);\n              p.x = point.x;\n              p.y = point.y;\n            });\n          }\n          frame.shape.points = points;\n        }\n        instance.frames[frameIndex] = frame;\n        // add to frameInstances\n        frameInstances[frameIndex].push(id);\n      });\n      // add to instances\n      instances[id] = instance;\n      // add to categoryInstancesMap\n      if (!categoryInstancesMap[category]) {\n        categoryInstancesMap[category] = {};\n      }\n      categoryInstancesMap[category][id] = instance.number;\n    });\n\n    // check duplicated numbers & fix\n    Object.keys(categoryInstancesMap).forEach(category => {\n      const allNumbers = Object.values(categoryInstancesMap[category]);\n      let newNumber = Math.max(...allNumbers) + 1;\n      Object.keys(categoryInstancesMap[category]).forEach((instanceId, index) => {\n        const instanceNum = categoryInstancesMap[category][instanceId];\n        if (allNumbers.findIndex((num, i) => num === instanceNum && i < index) >= 0) {\n          // fix\n          instances[instanceId].number = newNumber;\n          categoryInstancesMap[category][instanceId] = newNumber;\n          newNumber += 1;\n        }\n      });\n    });\n  }\n  return {\n    instances,\n    frameInstances,\n    categoryInstancesMap\n  };\n}\nexport function formatFrames(frames) {\n  if (frames.length === 1) {\n    return frames[0] + 1;\n  }\n  const ranges = [];\n  if (frames.length > 1) {\n    let currMin = frames[0];\n    let currMax = frames[0];\n    let i = 1;\n    while (i < frames.length) {\n      if (frames[i] - frames[i - 1] > 1) {\n        currMax = frames[i - 1];\n        ranges.push([currMin, currMax]);\n        currMin = frames[i];\n        currMax = frames[i];\n      }\n      i += 1;\n    }\n    currMax = frames[frames.length - 1];\n    ranges.push([currMin, currMax]);\n  }\n  return ranges.reduce((acc, curr) => `${acc ? `${acc}, ` : ''}${curr[0] === curr[1] ? curr[0] + 1 : `${curr[0] + 1}-${curr[1] + 1}`}`, '');\n}\nexport function predictShapeData(currentFrame, frames, bounds) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame);\n    }\n  }\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const {\n        shapeType,\n        shape\n      } = frames[prevKeyFrameIndexes[0]];\n      return {\n        shapeType,\n        shape\n      };\n    }\n  }\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const {\n      shapeType,\n      shape\n    } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return {\n        shapeType,\n        shape\n      };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const {\n      shapeType,\n      shape\n    } = frames[prevKeyFrameIndexes[0]];\n    return {\n      shapeType,\n      shape\n    };\n  }\n  return null;\n}\nexport function getLastKeyFrames(count, currentFrame, frames) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map(f => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\nexport function getNextKeyFrames(count, currentFrame, frames) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map(f => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\nexport function getShapeFromFrames(frames, startFrame, endFrame, baseFrame, currentFrame) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape\n  };\n  if (Object.values(frames).filter(f => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some(f => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE:\n      {\n        const shape = calculate(startShape, endShape, baseShape, frameScale);\n        const {\n          x: startX,\n          width: startW,\n          center: startCenter\n        } = startShape;\n        const {\n          x: endX,\n          width: endW,\n          center: endCenter\n        } = endShape;\n        const {\n          x: baseX,\n          width: baseW,\n          center: baseCenter\n        } = baseShape;\n        let center;\n        if (startCenter !== undefined && endCenter !== undefined && baseCenter !== undefined) {\n          const startCenterScale = (startCenter - startX) / startW;\n          const endCenterScale = (endCenter - endX) / endW;\n          const baseCenterScale = (baseCenter - baseX) / baseW;\n          const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n          center = Math.min(Math.max(centerScale * shape.width + shape.x, shape.x), shape.x + shape.width);\n        }\n        const points = [{\n          x: shape.x,\n          y: shape.y\n        }, {\n          x: shape.x + shape.width,\n          y: shape.y\n        }, {\n          x: shape.x + shape.width,\n          y: shape.y + shape.height\n        }, {\n          x: shape.x,\n          y: shape.y + shape.height\n        }];\n        if (shape.rotation) {\n          points.forEach(p => {\n            const point = computeRotatedPosition({\n              x: shape.x + shape.width / 2,\n              y: shape.y + shape.height / 2\n            }, p, shape.rotation);\n            p.x = point.x;\n            p.y = point.y;\n          });\n        }\n        shape.points = points;\n        shapeInfo.shape = {\n          ...shape,\n          center\n        };\n        break;\n      }\n    case ShapeType.ELLIPSE:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale);\n        break;\n      }\n    case ShapeType.CUBOID:\n      {\n        const {\n          front: startFront,\n          back: startBack\n        } = startShape;\n        const {\n          front: endFront,\n          back: endBack\n        } = endShape;\n        const {\n          front: baseFront,\n          back: baseBack\n        } = baseShape;\n        const front = calculate(startFront, endFront, baseFront, frameScale);\n        const back = calculate(startBack, endBack, baseBack, frameScale);\n        shapeInfo.shape = {\n          front,\n          back\n        };\n        break;\n      }\n    case ShapeType.LSHAPE:\n      {\n        const {\n          front: startFront,\n          sidePoints: startSidePoints,\n          center: startCenter\n        } = startShape;\n        const {\n          front: endFront,\n          sidePoints: endSidePoints,\n          center: endCenter\n        } = endShape;\n        const {\n          front: baseFront,\n          sidePoints: baseSidePoints,\n          center: baseCenter\n        } = baseShape;\n        const front = calculate(startFront, endFront, baseFront, frameScale);\n        const sidePoints = startSidePoints.map((_, index) => calculate(startSidePoints[index], endSidePoints[index], baseSidePoints[index], frameScale));\n        const startCenterScale = (startCenter - startFront.x) / startFront.width;\n        const endCenterScale = (endCenter - endFront.x) / endFront.width;\n        const baseCenterScale = (baseCenter - baseFront.x) / baseFront.width;\n        const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n        const center = Math.min(Math.max(centerScale * front.width + front.x, front.x), front.x + front.width);\n        shapeInfo.shape = {\n          front,\n          sidePoints,\n          center\n        };\n        break;\n      }\n    case ShapeType.DOT:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale);\n        break;\n      }\n    default:\n  }\n  return shapeInfo;\n}\nfunction calculate(start, end, base, scale) {\n  const calculatedObject = {};\n  Object.keys(base).forEach(key => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = base[key] + (end[key] - start[key]) * scale;\n    }\n  });\n  return calculatedObject;\n}\nfunction checkShapeInBounds(shape, shapeType, bounds) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n      {\n        const {\n          x,\n          y,\n          width,\n          height\n        } = shape;\n        return x <= bounds.right && y <= bounds.bottom && x + width >= bounds.left && y + height >= bounds.top;\n      }\n    case ShapeType.ELLIPSE:\n      {\n        const {\n          x,\n          y,\n          halfWidth,\n          halfHeight\n        } = shape;\n        return x - halfWidth <= bounds.right && y - halfHeight <= bounds.bottom && x + halfWidth >= bounds.left && y + halfHeight >= bounds.top;\n      }\n    case ShapeType.CUBOID:\n      {\n        const {\n          front,\n          back\n        } = shape;\n        return front.x <= bounds.right && front.y <= bounds.bottom && front.x + front.width >= bounds.left && front.y + front.height >= bounds.top || back.x <= bounds.right && back.y <= bounds.bottom && back.x + back.width >= bounds.left && back.y + back.height >= bounds.top;\n      }\n    case ShapeType.LSHAPE:\n      {\n        const {\n          front,\n          sidePoints\n        } = shape;\n        return front.x <= bounds.right && front.y <= bounds.bottom && front.x + front.width >= bounds.left && front.y + front.height >= bounds.top || sidePoints.some(p => p.x >= bounds.left && p.x <= bounds.right && p.y >= bounds.top && p.y <= bounds.bottom);\n      }\n    case ShapeType.DOT:\n      {\n        const {\n          x,\n          y\n        } = shape;\n        return x <= bounds.right && y <= bounds.bottom && x >= bounds.left && y >= bounds.top;\n      }\n    default:\n  }\n  return true;\n}\nexport function getSnapshot(imageUrl, shape) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n    image.onload = reject;\n    image.onerror = reject;\n    const shapeData = shape;\n    if (Array.isArray(shapeData.points)) {\n      // polygon, or rotatable rectangle\n      const points = shapeData.points;\n      const allX = points.map(({\n        x\n      }) => x);\n      const allY = points.map(({\n        y\n      }) => y);\n      const minX = Math.min(...allX);\n      const maxX = Math.max(...allX);\n      const minY = Math.min(...allY);\n      const maxY = Math.max(...allY);\n      canvas.width = maxX - minX;\n      canvas.height = maxY - minY;\n      image.onload = () => {\n        if (ctx) {\n          points.forEach((p, i) => {\n            if (i === 0) {\n              ctx.moveTo(p.x - minX, p.y - minY);\n            } else {\n              ctx.lineTo(p.x - minX, p.y - minY);\n            }\n          });\n          ctx.lineTo(points[0].x - minX, points[0].y - minY);\n          ctx.clip();\n          ctx.drawImage(image, minX, minY, maxX - minX, maxY - minY, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    } else if (shapeData.x !== undefined && shapeData.y !== undefined && shapeData.width !== undefined && shapeData.height !== undefined) {\n      // legacy rectangle data (no points)\n      canvas.width = shapeData.width;\n      canvas.height = shapeData.height;\n      image.onload = () => {\n        if (ctx) {\n          ctx.drawImage(image, shapeData.x, shapeData.y, shapeData.width, shapeData.height, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    }\n    image.src = imageUrl;\n  });\n}\nexport function validate(config, params) {\n  return new Promise(async resolve => {\n    const {\n      instances,\n      resultLink\n    } = params;\n    const results = [];\n    let hasCustomError = false;\n    if (config[ValidationType.ATTR_EMPTY]) {\n      // check empty attr\n      const invalidInstanceMap = {};\n      Object.values(instances).forEach(instance => {\n        const {\n          id,\n          frames\n        } = instance;\n        Object.values(frames).forEach(frameData => {\n          const {\n            frameIndex,\n            attributes\n          } = frameData;\n          if (!attributes || Object.keys(attributes).length <= 0) {\n            // empty\n            if (!invalidInstanceMap[id]) {\n              invalidInstanceMap[id] = [];\n            }\n            invalidInstanceMap[id].push(frameIndex);\n          }\n        });\n      });\n      Object.keys(invalidInstanceMap).forEach(instanceId => {\n        const frames = invalidInstanceMap[instanceId];\n        results.push({\n          type: ValidationType.ATTR_EMPTY,\n          id: instanceId,\n          frames: [...frames],\n          message: i18n.translate('VALIDATION_ATTR_EMPTY_MSG', {\n            values: {\n              frames: formatFrames(frames)\n            }\n          })\n        });\n      });\n    }\n    if (config[ValidationType.CUSTOM]) {\n      // custom check\n      const customResult = await runCustomValidation(config[ValidationType.CUSTOM], resultLink);\n      customResult.results.forEach(result => {\n        results.push({\n          ...result,\n          type: ValidationType.CUSTOM\n        });\n      });\n      hasCustomError = customResult.hasCustomError;\n    }\n    resolve({\n      results,\n      hasCustomError\n    });\n  });\n}\nexport function parseHotkeysConfig(hotkeysConfig) {\n  const supportedAffectedTypes = ['point'];\n  const supportedTypes = ['overwrite', 'upsert'];\n  const supportedKeys = ['0', '4', '5', '6', '7', '8', '9'];\n  const hotkeyMap = {};\n  if (hotkeysConfig && typeof hotkeysConfig === 'object') {\n    Object.keys(hotkeysConfig).forEach(affected => {\n      if (supportedAffectedTypes.includes(affected)) {\n        const items = hotkeysConfig[affected];\n        if (Array.isArray(items)) {\n          items.forEach(item => {\n            if (item && item.key && supportedKeys.includes(item.key)) {\n              const {\n                key,\n                type,\n                attributes\n              } = item;\n              const hotkeyItem = {\n                key,\n                affected,\n                type,\n                attributes\n              };\n              if (!supportedTypes.includes(type)) {\n                // eslint-disable-next-line prefer-destructuring\n                hotkeyItem.type = supportedTypes[0];\n              }\n              if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n                hotkeyItem.attributes = {};\n              }\n              if (!hotkeyMap[key]) {\n                hotkeyMap[key] = [];\n              }\n              hotkeyMap[key].push(hotkeyItem);\n            }\n          });\n        }\n      }\n    });\n  }\n  return hotkeyMap;\n}\nexport function containsRTLLanguage(text = '') {\n  // https://en.wikipedia.org/wiki/Arabic_script_in_Unicode\n  return Array.from(text).some(c => {\n    const code = c.codePointAt(0);\n    return code !== undefined && (code >= 0x0600 && code <= 0x06ff || code >= 0x0750 && code <= 0x077f || code >= 0x08a0 && code <= 0x08ff || code >= 0xfb50 && code <= 0xfdff || code >= 0xfe70 && code <= 0xfeff || code >= 0x10e60 && code <= 0x10e7f || code >= 0x1ec70 && code <= 0x1ecbf || code >= 0x1ed00 && code <= 0x1ed4f || code >= 0x1ee00 && code <= 0x1eeff);\n  });\n}\nexport function getShapeTypeByTool(tool) {\n  switch (tool) {\n    case Tool.RECTANGLE:\n    case Tool.CENTERLINE_RECTANGLE:\n    case Tool.FOUR_DOTS_RECTANGLE:\n    case Tool.OCR:\n      return ShapeType.RECTANGLE;\n    case Tool.ELLIPSE:\n      return ShapeType.ELLIPSE;\n    case Tool.POLYGON:\n    case Tool.OCR_POLYGON:\n      return ShapeType.POLYGON;\n    case Tool.CUBOID:\n      return ShapeType.CUBOID;\n    case Tool.LSHAPE:\n      return ShapeType.LSHAPE;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    case Tool.GRID:\n      return ShapeType.GRID;\n    default:\n  }\n  return undefined;\n}\nexport function getToolTypeFromFrameData(shape) {\n  switch (shape.shapeType) {\n    case ShapeType.CUBOID:\n      return Tool.CUBOID;\n    case ShapeType.ELLIPSE:\n      return Tool.ELLIPSE;\n    case ShapeType.LSHAPE:\n      return Tool.LSHAPE;\n    case ShapeType.POLYGON:\n      return shape.isOCR ? Tool.OCR_POLYGON : Tool.POLYGON;\n    case ShapeType.RECTANGLE:\n      if (shape.isOCR) {\n        return Tool.OCR;\n      }\n      if (shape.shape.center) {\n        return Tool.CENTERLINE_RECTANGLE;\n      }\n      return Tool.RECTANGLE;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    case ShapeType.GRID:\n      return Tool.GRID;\n    default:\n  }\n  return undefined;\n}","map":{"version":3,"names":["i18n","ValidationType","Tool","ShapeType","fetchResultByUrl","runCustomValidation","computeRotatedPosition","parseFrames","frames","split","map","f","trim","parseFramesByPaylod","base_url","parsedFrames","res","Array","isArray","e","loadInstancesFromResult","result","frameCount","instances","frameInstances","from","length","categoryInstancesMap","forEach","id","category","number","instance","frame","frameIndex","shape","shapeType","RECTANGLE","points","x","y","width","height","rotation","p","point","push","Object","keys","allNumbers","values","newNumber","Math","max","instanceId","index","instanceNum","findIndex","num","i","formatFrames","ranges","currMin","currMax","reduce","acc","curr","predictShapeData","currentFrame","bounds","prevKeyFrameIndexes","getLastKeyFrames","nextKeyFrameIndexes","getNextKeyFrames","startFrame","endFrame","getShapeFromFrames","checkShapeInBounds","count","keyFrameIndexes","minFrame","min","isKeyFrame","maxFrame","baseFrame","frameShapeType","shapeInfo","filter","some","startShape","endShape","baseShape","frameScale","calculate","startX","startW","center","startCenter","endX","endW","endCenter","baseX","baseW","baseCenter","undefined","startCenterScale","endCenterScale","baseCenterScale","centerScale","ELLIPSE","CUBOID","front","startFront","back","startBack","endFront","endBack","baseFront","baseBack","LSHAPE","sidePoints","startSidePoints","endSidePoints","baseSidePoints","_","DOT","start","end","base","scale","calculatedObject","key","right","bottom","left","top","halfWidth","halfHeight","getSnapshot","imageUrl","Promise","resolve","reject","canvas","document","createElement","ctx","getContext","image","Image","crossOrigin","onload","onerror","shapeData","allX","allY","minX","maxX","minY","maxY","moveTo","lineTo","clip","drawImage","toDataURL","src","validate","config","params","resultLink","results","hasCustomError","ATTR_EMPTY","invalidInstanceMap","frameData","attributes","type","message","translate","CUSTOM","customResult","parseHotkeysConfig","hotkeysConfig","supportedAffectedTypes","supportedTypes","supportedKeys","hotkeyMap","affected","includes","items","item","hotkeyItem","containsRTLLanguage","text","c","code","codePointAt","getShapeTypeByTool","tool","CENTERLINE_RECTANGLE","FOUR_DOTS_RECTANGLE","OCR","POLYGON","OCR_POLYGON","LINE","GRID","getToolTypeFromFrameData","isOCR"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking/utils.ts"],"sourcesContent":["import i18n from './locales';\nimport { Instance, FrameData, CategoryInstancesMap, ValidationType, ValidationResult, HotkeyItem, Tool, Ontology } from './types';\nimport { ShapeData, ShapeType } from '../common/shapes/types';\nimport { RectangleData } from '../common/shapes/Rectangle';\nimport { EllipseData } from '../common/shapes/Ellipse';\nimport { CuboidData } from '../common/shapes/Cuboid';\nimport { LShapeData } from '../common/shapes/LShape';\nimport { DotData } from '../common/shapes/Dot';\nimport { fetchResultByUrl, runCustomValidation } from '../../utils';\nimport { computeRotatedPosition } from '../../utils/math';\n\nexport function parseFrames(frames: string | string[]) {\n  if (typeof frames === 'string') {\n    return frames.split(',').map((f) => f.trim());\n  }\n  return [...frames];\n}\n\nexport async function parseFramesByPaylod({ frames, base_url }: { frames?: string | string[]; base_url?: string }) {\n  let parsedFrames: string[] = [];\n  if (frames) {\n    parsedFrames = parseFrames(frames);\n  } else if (base_url) {\n    try {\n      const res: any = await fetchResultByUrl(base_url);\n      if (res && res.frames && Array.isArray(res.frames)) {\n        parsedFrames = [...res.frames];\n      }\n    } catch (e) {\n      // fetch error\n    }\n  }\n  return parsedFrames;\n}\n\nexport function loadInstancesFromResult(result: any, frameCount: number) {\n  const instances: {[instanceId: string]: Instance} = {};\n  const frameInstances: string[][] = Array.from({ length: frameCount }).map(() => []);\n  const categoryInstancesMap: CategoryInstancesMap = {};\n\n  if (result && result.instances && Array.isArray(result.instances)) {\n    result.instances.forEach(({ id, category, number, frames }: any) => {\n      const instance: Instance = { id, category, number, frames: {} };\n      (frames || []).forEach((frame: any) => {\n        const { frameIndex, shape } = frame;\n        if (frame.shapeType === ShapeType.RECTANGLE && typeof shape.points === 'string') {\n          const points = [\n            { x: shape.x, y: shape.y },\n            { x: shape.x + shape.width, y: shape.y },\n            { x: shape.x + shape.width, y: shape.y + shape.height },\n            { x: shape.x, y: shape.y + shape.height },\n          ];\n          if (shape.rotation) {\n            points.forEach((p) => {\n              const point = computeRotatedPosition({ x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }, p, shape.rotation as number);\n              p.x = point.x;\n              p.y = point.y;\n            });\n          }\n          frame.shape.points = points;\n        }\n        instance.frames[frameIndex] = frame;\n        // add to frameInstances\n        frameInstances[frameIndex].push(id);\n      });\n      // add to instances\n      instances[id] = instance;\n      // add to categoryInstancesMap\n      if (!categoryInstancesMap[category]) {\n        categoryInstancesMap[category] = {};\n      }\n      categoryInstancesMap[category][id] = instance.number;\n    });\n\n    // check duplicated numbers & fix\n    Object.keys(categoryInstancesMap).forEach((category) => {\n      const allNumbers = Object.values(categoryInstancesMap[category]);\n      let newNumber = Math.max(...allNumbers) + 1;\n      Object.keys(categoryInstancesMap[category]).forEach((instanceId, index) => {\n        const instanceNum = categoryInstancesMap[category][instanceId];\n        if (allNumbers.findIndex((num, i) => num === instanceNum && i < index) >= 0) {\n          // fix\n          instances[instanceId].number = newNumber;\n          categoryInstancesMap[category][instanceId] = newNumber;\n          newNumber += 1;\n        }\n      });\n    });\n  }\n\n  return {\n    instances,\n    frameInstances,\n    categoryInstancesMap,\n  };\n}\n\nexport function formatFrames(frames: number[]) {\n  if (frames.length === 1) {\n    return frames[0] + 1;\n  }\n\n  const ranges = [];\n  if (frames.length > 1) {\n    let currMin = frames[0];\n    let currMax = frames[0];\n    let i = 1;\n    while (i < frames.length) {\n      if (frames[i] - frames[i - 1] > 1) {\n        currMax = frames[i - 1];\n        ranges.push([currMin, currMax]);\n        currMin = frames[i];\n        currMax = frames[i];\n      }\n      i += 1;\n    }\n    currMax = frames[frames.length - 1];\n    ranges.push([currMin, currMax]);\n  }\n\n  return ranges.reduce((acc, curr) => `${acc ? `${acc}, ` : ''}${curr[0] === curr[1] ? (curr[0] + 1) : `${curr[0] + 1}-${curr[1] + 1}`}`, '');\n}\n\nexport function predictShapeData(\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n  bounds?: { top: number; right: number; bottom: number; left: number },\n) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame);\n    }\n  }\n\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n      return { shapeType, shape };\n    }\n  }\n\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const { shapeType, shape } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return { shapeType, shape };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n    return { shapeType, shape };\n  }\n\n  return null;\n}\n\nexport function getLastKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map((f) => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\nexport function getNextKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map((f) => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\nexport function getShapeFromFrames(\n  frames: {[frameIndex: number]: FrameData},\n  startFrame: number,\n  endFrame: number,\n  baseFrame: number,\n  currentFrame: number,\n) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape,\n  };\n\n  if (Object.values(frames).filter((f) => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some((f) => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE: {\n      const shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as RectangleData;\n      const { x: startX, width: startW, center: startCenter } = startShape as RectangleData;\n      const { x: endX, width: endW, center: endCenter } = endShape as RectangleData;\n      const { x: baseX, width: baseW, center: baseCenter } = baseShape as RectangleData;\n      let center;\n      if (startCenter !== undefined && endCenter !== undefined && baseCenter !== undefined) {\n        const startCenterScale = (startCenter - startX) / startW;\n        const endCenterScale = (endCenter - endX) / endW;\n        const baseCenterScale = (baseCenter - baseX) / baseW;\n        const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n        center = Math.min(Math.max(centerScale * shape.width + shape.x, shape.x), shape.x + shape.width);\n      }\n      const points = [\n        { x: shape.x, y: shape.y },\n        { x: shape.x + shape.width, y: shape.y },\n        { x: shape.x + shape.width, y: shape.y + shape.height },\n        { x: shape.x, y: shape.y + shape.height },\n      ];\n      if (shape.rotation) {\n        points.forEach((p) => {\n          const point = computeRotatedPosition({ x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }, p, shape.rotation as number);\n          p.x = point.x;\n          p.y = point.y;\n        });\n      }\n\n      shape.points = points;\n      shapeInfo.shape = { ...shape, center };\n      break;\n    }\n    case ShapeType.ELLIPSE: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as EllipseData;\n      break;\n    }\n    case ShapeType.CUBOID: {\n      const { front: startFront, back: startBack } = startShape as CuboidData;\n      const { front: endFront, back: endBack } = endShape as CuboidData;\n      const { front: baseFront, back: baseBack } = baseShape as CuboidData;\n      const front = calculate(\n        startFront as unknown as { [key: string]: number; },\n        endFront as unknown as { [key: string]: number; },\n        baseFront as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as CuboidData['front'];\n      const back = calculate(\n        startBack as unknown as { [key: string]: number; },\n        endBack as unknown as { [key: string]: number; },\n        baseBack as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as CuboidData['back'];\n      shapeInfo.shape = { front, back };\n      break;\n    }\n    case ShapeType.LSHAPE: {\n      const { front: startFront, sidePoints: startSidePoints, center: startCenter } = startShape as LShapeData;\n      const { front: endFront, sidePoints: endSidePoints, center: endCenter } = endShape as LShapeData;\n      const { front: baseFront, sidePoints: baseSidePoints, center: baseCenter } = baseShape as LShapeData;\n      const front = calculate(\n        startFront as unknown as { [key: string]: number; },\n        endFront as unknown as { [key: string]: number; },\n        baseFront as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as LShapeData['front'];\n      const sidePoints = startSidePoints.map((_, index) => calculate(\n        startSidePoints[index] as unknown as { [key: string]: number; },\n        endSidePoints[index] as unknown as { [key: string]: number; },\n        baseSidePoints[index] as unknown as { [key: string]: number; },\n        frameScale,\n      )) as unknown as LShapeData['sidePoints'];\n      const startCenterScale = (startCenter - startFront.x) / startFront.width;\n      const endCenterScale = (endCenter - endFront.x) / endFront.width;\n      const baseCenterScale = (baseCenter - baseFront.x) / baseFront.width;\n      const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n      const center = Math.min(Math.max(centerScale * front.width + front.x, front.x), front.x + front.width);\n      shapeInfo.shape = { front, sidePoints, center };\n      break;\n    }\n    case ShapeType.DOT: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as EllipseData;\n      break;\n    }\n    default:\n  }\n\n  return shapeInfo;\n}\n\nfunction calculate(\n  start: {[key: string]: number},\n  end: {[key: string]: number},\n  base: {[key: string]: number},\n  scale: number,\n) {\n  const calculatedObject: {[key: string]: number} = {};\n  Object.keys(base).forEach((key) => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = base[key] + (end[key] - start[key]) * scale;\n    }\n  });\n  return calculatedObject;\n}\n\nfunction checkShapeInBounds(\n  shape: ShapeData,\n  shapeType: ShapeType,\n  bounds: { top: number; right: number; bottom: number; left: number },\n) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE: {\n      const { x, y, width, height } = shape as RectangleData;\n      return x <= bounds.right && y <= bounds.bottom && x + width >= bounds.left && y + height >= bounds.top;\n    }\n    case ShapeType.ELLIPSE: {\n      const { x, y, halfWidth, halfHeight } = shape as EllipseData;\n      return x - halfWidth <= bounds.right && y - halfHeight <= bounds.bottom && x + halfWidth >= bounds.left && y + halfHeight >= bounds.top;\n    }\n    case ShapeType.CUBOID: {\n      const { front, back } = shape as CuboidData;\n      return (\n        front.x <= bounds.right && front.y <= bounds.bottom && front.x + front.width >= bounds.left && front.y + front.height >= bounds.top\n      ) || (\n        back.x <= bounds.right && back.y <= bounds.bottom && back.x + back.width >= bounds.left && back.y + back.height >= bounds.top\n      );\n    }\n    case ShapeType.LSHAPE: {\n      const { front, sidePoints } = shape as LShapeData;\n      return (\n        front.x <= bounds.right && front.y <= bounds.bottom && front.x + front.width >= bounds.left && front.y + front.height >= bounds.top\n      ) || (\n        sidePoints.some((p) => (p.x >= bounds.left && p.x <= bounds.right && p.y >= bounds.top && p.y <= bounds.bottom))\n      );\n    }\n    case ShapeType.DOT: {\n      const { x, y } = shape as DotData;\n      return x <= bounds.right && y <= bounds.bottom && x >= bounds.left && y >= bounds.top;\n    }\n    default:\n  }\n  return true;\n}\n\nexport function getSnapshot(imageUrl: string, shape: ShapeData) {\n  return new Promise<string>((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n    image.onload = reject;\n    image.onerror = reject;\n\n    const shapeData = shape as any;\n    if (Array.isArray(shapeData.points)) {\n      // polygon, or rotatable rectangle\n      const points = shapeData.points as { x: number; y: number }[];\n      const allX = points.map(({ x }) => x);\n      const allY = points.map(({ y }) => y);\n      const minX = Math.min(...allX);\n      const maxX = Math.max(...allX);\n      const minY = Math.min(...allY);\n      const maxY = Math.max(...allY);\n      canvas.width = maxX - minX;\n      canvas.height = maxY - minY;\n      image.onload = () => {\n        if (ctx) {\n          points.forEach((p, i) => {\n            if (i === 0) {\n              ctx.moveTo(p.x - minX, p.y - minY);\n            } else {\n              ctx.lineTo(p.x - minX, p.y - minY);\n            }\n          });\n          ctx.lineTo(points[0].x - minX, points[0].y - minY);\n          ctx.clip();\n          ctx.drawImage(image, minX, minY, maxX - minX, maxY - minY, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    } else if (shapeData.x !== undefined && shapeData.y !== undefined && shapeData.width !== undefined && shapeData.height !== undefined) {\n      // legacy rectangle data (no points)\n      canvas.width = shapeData.width;\n      canvas.height = shapeData.height;\n      image.onload = () => {\n        if (ctx) {\n          ctx.drawImage(image, shapeData.x, shapeData.y, shapeData.width, shapeData.height, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    }\n\n    image.src = imageUrl;\n  });\n}\n\nexport function validate(\n  config: {\n    [type in ValidationType]?: boolean | string[];\n  },\n  params: {\n    instances: {[instanceId: string]: Instance};\n    resultLink?: string;\n  },\n) {\n  return new Promise<{\n    results: ValidationResult[];\n    hasCustomError: boolean;\n  }>(async (resolve) => {\n    const { instances, resultLink } = params;\n    const results: ValidationResult[] = [];\n    let hasCustomError = false;\n\n    if (config[ValidationType.ATTR_EMPTY]) {\n      // check empty attr\n      const invalidInstanceMap: {[instanceId: string]: number[]} = {};\n      Object.values(instances).forEach((instance) => {\n        const { id, frames } = instance;\n        Object.values(frames).forEach((frameData) => {\n          const { frameIndex, attributes } = frameData;\n          if (!attributes || Object.keys(attributes).length <= 0) {\n            // empty\n            if (!invalidInstanceMap[id]) {\n              invalidInstanceMap[id] = [];\n            }\n            invalidInstanceMap[id].push(frameIndex);\n          }\n        });\n      });\n      Object.keys(invalidInstanceMap).forEach((instanceId) => {\n        const frames = invalidInstanceMap[instanceId];\n        results.push({\n          type: ValidationType.ATTR_EMPTY,\n          id: instanceId,\n          frames: [...frames],\n          message: i18n.translate('VALIDATION_ATTR_EMPTY_MSG', { values: { frames: formatFrames(frames) } }),\n        });\n      });\n    }\n\n    if (config[ValidationType.CUSTOM]) {\n      // custom check\n      const customResult = await runCustomValidation(config[ValidationType.CUSTOM] as string[], resultLink!);\n      customResult.results.forEach((result) => {\n        results.push({ ...result, type: ValidationType.CUSTOM });\n      });\n      hasCustomError = customResult.hasCustomError;\n    }\n\n    resolve({ results, hasCustomError });\n  });\n}\n\nexport function parseHotkeysConfig(hotkeysConfig: any) {\n  const supportedAffectedTypes = ['point'];\n  const supportedTypes = ['overwrite', 'upsert'];\n  const supportedKeys = ['0', '4', '5', '6', '7', '8', '9'];\n\n  const hotkeyMap: {[key: string]: HotkeyItem[]} = {};\n  if (hotkeysConfig && typeof hotkeysConfig === 'object') {\n    Object.keys(hotkeysConfig).forEach((affected) => {\n      if (supportedAffectedTypes.includes(affected)) {\n        const items = hotkeysConfig[affected];\n        if (Array.isArray(items)) {\n          items.forEach((item) => {\n            if (item && item.key && supportedKeys.includes(item.key)) {\n              const { key, type, attributes } = item;\n              const hotkeyItem: HotkeyItem = {\n                key,\n                affected,\n                type,\n                attributes,\n              };\n\n              if (!supportedTypes.includes(type)) {\n                // eslint-disable-next-line prefer-destructuring\n                hotkeyItem.type = supportedTypes[0];\n              }\n\n              if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n                hotkeyItem.attributes = {};\n              }\n\n              if (!hotkeyMap[key]) {\n                hotkeyMap[key] = [];\n              }\n              hotkeyMap[key].push(hotkeyItem);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  return hotkeyMap;\n}\n\nexport function containsRTLLanguage(text = '') {\n  // https://en.wikipedia.org/wiki/Arabic_script_in_Unicode\n  return Array.from(text).some((c) => {\n    const code = c.codePointAt(0);\n    return code !== undefined && (\n      (code >= 0x0600 && code <= 0x06ff) ||\n      (code >= 0x0750 && code <= 0x077f) ||\n      (code >= 0x08a0 && code <= 0x08ff) ||\n      (code >= 0xfb50 && code <= 0xfdff) ||\n      (code >= 0xfe70 && code <= 0xfeff) ||\n      (code >= 0x10e60 && code <= 0x10e7f) ||\n      (code >= 0x1ec70 && code <= 0x1ecbf) ||\n      (code >= 0x1ed00 && code <= 0x1ed4f) ||\n      (code >= 0x1ee00 && code <= 0x1eeff)\n    );\n  });\n}\n\nexport function getShapeTypeByTool(tool: Tool): ShapeType | undefined {\n  switch (tool) {\n    case Tool.RECTANGLE:\n    case Tool.CENTERLINE_RECTANGLE:\n    case Tool.FOUR_DOTS_RECTANGLE:\n    case Tool.OCR:\n      return ShapeType.RECTANGLE;\n    case Tool.ELLIPSE:\n      return ShapeType.ELLIPSE;\n    case Tool.POLYGON:\n    case Tool.OCR_POLYGON:\n      return ShapeType.POLYGON;\n    case Tool.CUBOID:\n      return ShapeType.CUBOID;\n    case Tool.LSHAPE:\n      return ShapeType.LSHAPE;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    case Tool.GRID:\n      return ShapeType.GRID;\n    default:\n  }\n  return undefined;\n}\n\nexport function getToolTypeFromFrameData(shape: FrameData) {\n  switch (shape.shapeType) {\n    case ShapeType.CUBOID:\n      return Tool.CUBOID;\n    case ShapeType.ELLIPSE:\n      return Tool.ELLIPSE;\n    case ShapeType.LSHAPE:\n      return Tool.LSHAPE;\n    case ShapeType.POLYGON:\n      return shape.isOCR ? Tool.OCR_POLYGON : Tool.POLYGON;\n    case ShapeType.RECTANGLE:\n      if (shape.isOCR) {\n        return Tool.OCR;\n      }\n      if ((shape.shape as RectangleData).center) {\n        return Tool.CENTERLINE_RECTANGLE;\n      }\n      return Tool.RECTANGLE;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    case ShapeType.GRID:\n      return Tool.GRID;\n    default:\n  }\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}