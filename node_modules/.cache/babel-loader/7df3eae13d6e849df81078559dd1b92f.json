{"ast":null,"code":"/**\n * This module contains the datastructures used for working with\n * Textgrids, IntervalTiers, and PointTiers, and the primary\n * functions used to operate over them.<br /><br />\n *\n * A Textgrid() is a container for annotation tiers. Annotation tiers\n * come in two varieties: IntervalTier and PointTier. With this library,\n * a textgrid can be queried, be used to filter data points, cleaned,\n * or algorithmically altered, etc.\n *\n * @author Tim Mahrt\n * @since March 25, 2015\n * @module textgrid\n */\n\nimport { isClose, sortCompareEntriesByTime, entryListToTree, findIntervalAtTime, findPointAtTime, doIntervalsOverlap } from './utils.js';\nconst INTERVAL_TIER = 'IntervalTier';\nconst POINT_TIER = 'TextTier';\nconst MIN_INTERVAL_LENGTH = 0.00000001; // Arbitrary threshold\n\nclass TierExistsException extends Error {\n  constructor(tierName, ...args) {\n    super(...args);\n    this.tierName = tierName;\n    this.message = `Tier name ${tierName} already exists in textgrid`;\n  }\n}\n;\nclass TierCreationException extends Error {\n  constructor(errStr, ...args) {\n    super(...args);\n    this.errStr = errStr;\n    this.message = \"Couldn't create tier: \" + errStr;\n  }\n}\n;\nclass TextgridCollisionException extends Error {\n  constructor(tierName, entry, matchList, ...args) {\n    super(...args);\n    this.tierName = tierName;\n    this.entry = entry;\n    this.matchList = matchList;\n    this.message = `Attempted to insert interval [${entry}] into tier '${tierName}' of textgrid but overlapping entries [${matchList}] already exist.`;\n  }\n}\n;\nclass IndexException extends Error {\n  constructor(indexVal, listLength, ...args) {\n    super(...args);\n    this.indexVal = indexVal;\n    this.listLength = listLength;\n    this.message = `Attempted to index a list of length ${listLength} with index ${indexVal}.`;\n  }\n}\n;\n\n/**\n * Abstract class for tiers.\n * @abstract\n * @hideconstructor\n */\nclass TextgridTier {\n  constructor(name, entryList, minT, maxT) {\n    // Don't allow a timeless tier to exist\n    if (minT === null || maxT === null) {\n      throw new TierCreationException('All textgrid tiers must have a min and max timestamp');\n    }\n    this.name = name;\n    this.entryList = entryList;\n    this.minTimestamp = minT;\n    this.maxTimestamp = maxT;\n    this.tierType = null;\n    this.sort();\n  }\n\n  /**\n   * Remove an entry from the tier's entryList\n   * @param {Array} entry - the entry to remove\n   */\n  deleteEntry(entry) {\n    let deleteI = -1;\n    for (let i = 0; i < this.entryList.length; i++) {\n      if (compareEntries(this.entryList[i], entry)) {\n        deleteI = i;\n        break;\n      }\n    }\n    if (deleteI === -1) {\n      throw new IndexException(deleteI, this.entryList.length);\n    }\n    this.entryList.splice(deleteI, 1);\n  }\n  sort() {\n    this.entryList.sort(sortCompareEntriesByTime);\n  }\n}\n\n/**\n * Class representing an PointTier.\n * @augments TextgridTier\n * @inheritdoc\n */\nclass PointTier extends TextgridTier {\n  /**\n   * @constructor\n   * @param {string} name\n   * @param {Array} entryList - each entry is of the form [time, label]\n   * @param {number} [minT=null] - the smallest time; if null use 0\n   * @param {number} [maxT=null] - the maximum length of the tier; if null use the last timestamp found in the entryList\n   */\n  constructor(name, entryList, minT = null, maxT = null) {\n    entryList = entryList.map(([timeV, label]) => [parseFloat(timeV), label]);\n\n    // Determine the min and max timestamps\n    const timeList = entryList.map(entry => entry[0]);\n    if (minT !== null) timeList.push(parseFloat(minT));\n    if (timeList.length > 0) minT = Math.min(...timeList);\n    if (maxT !== null) timeList.push(parseFloat(maxT));\n    if (timeList.length > 0) maxT = Math.max(...timeList);\n\n    // Finish intialization\n    super(name, entryList, minT, maxT);\n    this.tierType = POINT_TIER;\n    this.labelIndex = 1;\n  }\n\n  /**\n   * Insert an entry into the tier\n   * @param {Array} entry - of the form [time, label]\n   * @param {boolean} [warnFlag=true] - if the entry collides with an existing entry, warn the user?\n   * @param {string} [collisionCode=null] - the action to take if there is a collision\n   */\n  insertEntry(entry, warnFlag = true, collisionCode = null) {\n    const startTime = entry[0];\n    let match = null;\n    for (let i = 0; i < this.entryList.length; i++) {\n      if (isClose(startTime, this.entryList[i][0])) {\n        match = this.entryList[i];\n        break;\n      }\n    }\n    if (!match) {\n      this.entryList.push(entry);\n    } else if (collisionCode && collisionCode.toLowerCase() === 'replace') {\n      this.deleteEntry(match);\n      this.entryList.push(entry);\n    } else if (collisionCode && collisionCode.toLowerCase() === 'merge') {\n      const newEntry = [match[0], [match[1], entry[1]].join('-')];\n      this.deleteEntry(match);\n      this.entryList.push(newEntry);\n    } else {\n      throw new TextgridCollisionException(this.name, entry, match);\n    }\n    this.sort();\n    if (match && warnFlag === true) {\n      const msg = `Collision warning for [${entry}] with items [${match}] of tier '${this.name}'`;\n      console.log(msg);\n    }\n  }\n}\n\n/**\n * Class representing an IntervalTier.\n * @augments TextgridTier\n */\nclass IntervalTier extends TextgridTier {\n  /**\n   * @constructor\n   * @param {string} name\n   * @param {Array} entryList - each entry is of the form [start time, end time, label]\n   * @param {number} [minT=null] - the smallest time; if null use 0\n   * @param {number} [maxT=null] - the maximum length of the tier; if null use the last timestamp found in the entryList\n   */\n  constructor(name, entryList, minT = null, maxT = null) {\n    entryList = entryList.map(([startTime, endTime, label]) => [parseFloat(startTime), parseFloat(endTime), label]);\n\n    // Determine the min and max timestamps\n    const startTimeList = entryList.map(entry => entry[0]);\n    if (minT !== null) startTimeList.push(parseFloat(minT));\n    if (startTimeList.length > 0) minT = Math.min(...startTimeList);\n    const endTimeList = entryList.map(entry => entry[1]);\n    if (maxT !== null) endTimeList.push(parseFloat(maxT));\n    if (endTimeList.length > 0) maxT = Math.max(...endTimeList);\n\n    // Finish initialization\n    super(name, entryList, minT, maxT);\n    this.tierType = INTERVAL_TIER;\n    this.labelIndex = 2;\n  }\n\n  /**\n   * Insert an entry into the tier\n   * @param {Array} entry - of the form [start time, end time, label]\n   * @param {boolean} [warnFlag=true] - if the entry collides with an existing entry, warn the user?\n   * @param {string} [collisionCode=null] - the action to take if there is a collision\n   */\n  insertEntry(entry, warnFlag = false, collisionCode = null) {\n    const startTime = entry[0];\n    const endTime = entry[1];\n    const matchList = getEntriesInInterval(this, startTime, endTime);\n    if (matchList.length === 0) {\n      this.entryList.push(entry);\n    } else if (collisionCode && collisionCode.toLowerCase() === 'replace') {\n      for (let i = 0; i < matchList.length; i++) {\n        this.deleteEntry(matchList[i]);\n      }\n      this.entryList.push(entry);\n    } else if (collisionCode && collisionCode.toLowerCase() === 'merge') {\n      for (let i = 0; i < matchList.length; i++) {\n        this.deleteEntry(matchList[i]);\n      }\n      matchList.push(entry);\n      matchList.sort(sortCompareEntriesByTime);\n      const startTimes = matchList.map(entry => entry[0]);\n      const endTimes = matchList.map(entry => entry[1]);\n      const labels = matchList.map(entry => entry[2]);\n      const newEntry = [Math.min(...startTimes), Math.max(...endTimes), labels.join('-')];\n      this.entryList.push(newEntry);\n    } else {\n      throw new TextgridCollisionException(this.name, entry, matchList);\n    }\n    this.sort();\n    if (matchList && warnFlag === true) {\n      const msg = `Collision warning for [${entry}] with items [${matchList}] of tier '${this.name}'`;\n      console.log(msg);\n    }\n  }\n}\n\n/**\n * Class representing a Textgrid.<br /><br />\n * A Textgrid is a container for annotations of an audio\n * file.  Annotations can be split into multiple tiers that\n * might represent different things (different speakers or\n * categories of events, etc). <br /><br />\n *\n * A Textgrid allows one to compute operations that affect\n * all of the contained tiers.\n */\nclass Textgrid {\n  constructor() {\n    this.tierNameList = [];\n    this.tierDict = {};\n    this.minTimestamp = null;\n    this.maxTimestamp = null;\n  }\n\n  /**\n   * Adds a tier to the textgrid.  Added to the end, unless an index is specified.\n   * @param {TextgridTier} tier\n   * @param {number} [tierIndex=null] - The index to insert at.  If null, add it to the end.\n   */\n  addTier(tier, tierIndex = null) {\n    if (Object.keys(this.tierDict).includes(tier.name)) {\n      throw new TierExistsException(tier.name);\n    }\n    if (tierIndex === null) this.tierNameList.push(tier.name);else this.tierNameList.splice(tierIndex, 0, tier.name);\n    this.tierDict[tier.name] = tier;\n    if (this.minTimestamp === null) {\n      this.minTimestamp = tier.minTimestamp;\n    }\n    if (this.maxTimestamp === null) {\n      this.maxTimestamp = tier.maxTimestamp;\n    }\n    this._homogonizeMinMaxTimestamps();\n  }\n\n  /**\n   * Makes all min and max timestamps within a textgrid the same\n   * @ignore\n   */\n  _homogonizeMinMaxTimestamps() {\n    const minTimes = this.tierNameList.map(tierName => this.tierDict[tierName].minTimestamp);\n    const maxTimes = this.tierNameList.map(tierName => this.tierDict[tierName].maxTimestamp);\n    const minTimestamp = Math.min(...minTimes);\n    const maxTimestamp = Math.max(...maxTimes);\n    this.minTimestamp = minTimestamp;\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      const tierName = this.tierNameList[i];\n      this.tierDict[tierName].minTimestamp = minTimestamp;\n    }\n    this.maxTimestamp = maxTimestamp;\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      const tierName = this.tierNameList[i];\n      this.tierDict[tierName].maxTimestamp = maxTimestamp;\n    }\n  }\n\n  /**\n   * Renames one tier.  The new name must not exist in the textgrid already.\n   * @param {string} oldName\n   * @param {string} newName\n   */\n  renameTier(oldName, newName) {\n    if (Object.keys(this.tierDict).includes(newName)) {\n      throw new TierExistsException(newName);\n    }\n    const oldTier = this.tierDict[oldName];\n    const tierIndex = this.tierNameList.indexOf(oldName);\n    const newTier = copyTier(oldTier, {\n      name: newName\n    });\n    this.removeTier(oldName);\n    this.addTier(newTier, tierIndex);\n  }\n\n  /**\n   * Removes the given tier from this textgrid.\n   * @param {string} name\n   */\n  removeTier(name) {\n    this.tierNameList.splice(this.tierNameList.indexOf(name), 1);\n    delete this.tierDict[name];\n  }\n\n  /**\n   * Replace the tier with the given name with a new tier\n   * @param {string} name\n   * @param {TextgridTier} newTier\n   */\n  replaceTier(name, newTier) {\n    const tierIndex = this.tierNameList.indexOf(name);\n    this.removeTier(name);\n    this.addTier(newTier, tierIndex);\n  }\n}\n\n/**\n * Returns true if the two textgrids are the same, false otherwise\n * @param {Textgrid} tg1\n * @param {Textgrid} tg2\n * @return {boolean}\n */\nfunction compareTextgrids(tg1, tg2) {\n  let isEqual = true;\n  isEqual &= isClose(tg1.minTimestamp, tg2.minTimestamp);\n  isEqual &= isClose(tg1.maxTimestamp, tg2.maxTimestamp);\n  isEqual &= tg1.tierNameList.length === tg2.tierNameList.length;\n  for (let i = 0; i < tg1.tierNameList.length; i++) {\n    isEqual &= tg1.tierNameList[i] === tg2.tierNameList[i];\n  }\n  for (let i = 0; i < tg1.tierNameList.length; i++) {\n    const tierName = tg1.tierNameList[i];\n    isEqual &= compareTiers(tg1.tierDict[tierName], tg2.tierDict[tierName]);\n  }\n  return !!isEqual;\n}\n\n/**\n * Returns true if the two tiers are the same, false otherwise\n * @param {TextgridTier} tier1\n * @param {TextgridTier} tier2\n * @return {boolean}\n */\nfunction compareTiers(tier1, tier2) {\n  let isEqual = true;\n  isEqual &= tier1.name === tier2.name;\n  isEqual &= isClose(tier1.minTimestamp, tier2.minTimestamp);\n  isEqual &= isClose(tier1.maxTimestamp, tier2.maxTimestamp);\n  isEqual &= tier1.entryList.length === tier2.entryList.length;\n  if (isEqual) {\n    for (let i = 0; i < tier1.entryList.length; i++) {\n      isEqual &= compareEntries(tier1.entryList[i], tier2.entryList[i]);\n    }\n  }\n  return !!isEqual;\n}\n\n/**\n * Returns true if the two entries are the same, false otherwise\n * @param {Array} entryA\n * @param {Array} entryB\n * @return {boolean}\n */\nfunction compareEntries(entryA, entryB) {\n  let areEqual;\n  if (entryA.length === 2) {\n    areEqual = comparePoints(entryA, entryB);\n  } else if (entryA.length === 3) {\n    areEqual = compareIntervals(entryA, entryB);\n  }\n  return areEqual;\n}\nfunction comparePoints(pointA, pointB) {\n  let areEqual = true;\n  areEqual &= isClose(pointA[0], pointB[0]);\n  areEqual &= pointA[1] === pointB[1];\n  return !!areEqual;\n}\nfunction compareIntervals(intervalA, intervalB) {\n  let areEqual = true;\n  areEqual &= isClose(intervalA[0], intervalB[0]);\n  areEqual &= isClose(intervalA[1], intervalB[1]);\n  areEqual &= intervalA[2] === intervalB[2];\n  return !!areEqual;\n}\n\n/**\n * Returns a deep copy of a textgrid.\n * @param {Textgrid} tg\n * @return {Textgrid}\n */\nfunction copyTextgrid(tg) {\n  const textgrid = new Textgrid();\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    textgrid.addTier(copyTier(tg.tierDict[tierName]));\n  }\n  textgrid.minTimestamp = tg.minTimestamp;\n  textgrid.maxTimestamp = tg.maxTimestamp;\n  return textgrid;\n}\n\n/**\n * Returns a deep copy of a tier\n * @param {TextgridTier} tier\n * @param {Object} - an object containing optional values to replace those in the copy.  If the four paramaters name, entryList, minTimestamp, and maxTimestamp are null or not specified, those in the tier will be used (default behaviour).\n * @return {TextgridTier}\n */\nfunction copyTier(tier, {\n  name = null,\n  entryList = null,\n  minTimestamp = null,\n  maxTimestamp = null\n} = {}) {\n  if (name === null) name = tier.name;\n  if (entryList === null) entryList = tier.entryList.map(entry => entry.slice());\n  if (minTimestamp === null) minTimestamp = tier.minTimestamp;\n  if (maxTimestamp === null) maxTimestamp = tier.maxTimestamp;\n  return new tier.constructor(name, entryList, minTimestamp, maxTimestamp);\n}\n\n/**\n * Get the values that occur at points in the point tier.\n * @param {PointTier} pointTier\n * @param {Array} dataTupleList - should be ordered in time;\n *  must be of the form [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]\n * @return {Array}\n */\nfunction getValuesAtPoints(pointTier, dataTupleList) {\n  const searchTree = entryListToTree(pointTier.entryList);\n  const returnList = [];\n  for (let i = 0; i < dataTupleList.length; i++) {\n    const currentEntry = dataTupleList[i];\n    if (findPointAtTime(currentEntry[0], searchTree, false) !== null) {\n      returnList.push(currentEntry);\n    }\n  }\n  return returnList;\n}\n\n/**\n * Returns data from dataTupleList contained in labeled intervals\n * @params {IntervalTier} intervalTier\n * @params {Array} dataTupleList  - should be of the form: [(time1, value1a, value1b,..), (time2, value2a, value2b..), ..]\n * @return {Array}\n */\nfunction getValuesInIntervals(intervalTier, dataTupleList) {\n  const searchTree = entryListToTree(intervalTier.entryList);\n  const returnList = [];\n  for (let i = 0; i < dataTupleList.length; i++) {\n    const currentEntry = dataTupleList[i];\n    if (findIntervalAtTime(currentEntry[0], searchTree) !== null) {\n      returnList.push(currentEntry);\n    }\n  }\n  return returnList;\n}\n\n/**\n * Given an interval, returns entries in an interval tier that are in or (for intervals) that partially overlap with it\n * @params {TextgridTier} tier\n * @params {number} startTime\n * @params {number} endTime\n * @return {Array} entryList\n */\nfunction getEntriesInInterval(tier, startTime, endTime) {\n  let entryList;\n  if (tier instanceof PointTier) {\n    entryList = getPointTierEntriesInInterval(tier, startTime, endTime);\n  } else if (tier instanceof IntervalTier) {\n    entryList = getIntervalTierEntriesInInterval(tier, startTime, endTime);\n  }\n  return entryList;\n}\nfunction getIntervalTierEntriesInInterval(intervalTier, startTime, endTime) {\n  const entryList = [];\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const entry = intervalTier.entryList[i];\n    if (doIntervalsOverlap([startTime, endTime], entry)) {\n      entryList.push(entry);\n    }\n  }\n  return entryList;\n}\nfunction getPointTierEntriesInInterval(pointTier, startTime, endTime) {\n  const entryList = [];\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const entry = pointTier.entryList[i];\n    if (entry[0] >= startTime && entry[0] <= endTime) {\n      entryList.push(entry);\n    }\n  }\n  return entryList;\n}\n\n/**\n * Returns the regions of the textgrid without labels\n * @params {IntervalTier} intervalTier\n * @return {Array} invertedEntryList - where each entry looks like [start time, end time, '']\n */\nfunction getNonEntriesFromIntervalTier(intervalTier) {\n  const invertedEntryList = [];\n\n  // Special case--the entry list is empty\n  if (intervalTier.entryList.length === 0) return [[intervalTier.minTimestamp, intervalTier.maxTimestamp, '']];\n  if (intervalTier.entryList[0][0] > 0) {\n    invertedEntryList.push([0, intervalTier.entryList[0][0], '']);\n  }\n  for (let i = 0; i < intervalTier.entryList.length - 1; i++) {\n    const currEnd = intervalTier.entryList[i][1];\n    const nextStart = intervalTier.entryList[i + 1][0];\n    if (currEnd !== nextStart) {\n      invertedEntryList.push([currEnd, nextStart, '']);\n    }\n  }\n  const lastI = intervalTier.entryList.length - 1;\n  if (intervalTier.entryList[lastI][1] < intervalTier.maxTimestamp) {\n    invertedEntryList.push([intervalTier.entryList[lastI][1], intervalTier.maxTimestamp, '']);\n  }\n  return invertedEntryList;\n}\n\n/**\n * Returns the indexes of the entries that match the search label\n * @params {TextgridTier} tier\n * @params {string} searchLabel\n * @params {string} [mode=null] If null, look for exact matches; if 're', match using regular expressions; if 'substr' look for substring matches\n * @return {Array}\n */\nfunction findLabelInTier(tier, searchLabel, mode = null) {\n  let cmprFunc;\n  if (mode === 're') {\n    cmprFunc = (text, reStr) => {\n      return RegExp(reStr).test(text);\n    };\n  } else if (mode === 'substr') {\n    cmprFunc = (text, subStr) => {\n      return text.includes(subStr);\n    };\n  } else {\n    cmprFunc = (text, searchText) => {\n      return text === searchText;\n    };\n  }\n\n  // Run the search\n  const returnList = [];\n  for (let i = 0; i < tier.entryList.length; i++) {\n    if (cmprFunc(tier.entryList[i][tier.labelIndex], searchLabel)) returnList.push(i);\n  }\n  return returnList;\n}\nexport { Textgrid, IntervalTier, PointTier,\n// functions that compare\ncompareTextgrids, compareTiers, compareEntries, comparePoints, compareIntervals,\n// deep copy functions\ncopyTextgrid, copyTier,\n// query functions\ngetValuesAtPoints, getValuesInIntervals, getEntriesInInterval, getNonEntriesFromIntervalTier, findLabelInTier,\n// exceptions\nTierExistsException, TierCreationException, TextgridCollisionException, IndexException,\n// constants\nINTERVAL_TIER, POINT_TIER, MIN_INTERVAL_LENGTH };","map":{"version":3,"names":["isClose","sortCompareEntriesByTime","entryListToTree","findIntervalAtTime","findPointAtTime","doIntervalsOverlap","INTERVAL_TIER","POINT_TIER","MIN_INTERVAL_LENGTH","TierExistsException","Error","constructor","tierName","args","message","TierCreationException","errStr","TextgridCollisionException","entry","matchList","IndexException","indexVal","listLength","TextgridTier","name","entryList","minT","maxT","minTimestamp","maxTimestamp","tierType","sort","deleteEntry","deleteI","i","length","compareEntries","splice","PointTier","map","timeV","label","parseFloat","timeList","push","Math","min","max","labelIndex","insertEntry","warnFlag","collisionCode","startTime","match","toLowerCase","newEntry","join","msg","console","log","IntervalTier","endTime","startTimeList","endTimeList","getEntriesInInterval","startTimes","endTimes","labels","Textgrid","tierNameList","tierDict","addTier","tier","tierIndex","Object","keys","includes","_homogonizeMinMaxTimestamps","minTimes","maxTimes","renameTier","oldName","newName","oldTier","indexOf","newTier","copyTier","removeTier","replaceTier","compareTextgrids","tg1","tg2","isEqual","compareTiers","tier1","tier2","entryA","entryB","areEqual","comparePoints","compareIntervals","pointA","pointB","intervalA","intervalB","copyTextgrid","tg","textgrid","slice","getValuesAtPoints","pointTier","dataTupleList","searchTree","returnList","currentEntry","getValuesInIntervals","intervalTier","getPointTierEntriesInInterval","getIntervalTierEntriesInInterval","getNonEntriesFromIntervalTier","invertedEntryList","currEnd","nextStart","lastI","findLabelInTier","searchLabel","mode","cmprFunc","text","reStr","RegExp","test","subStr","searchText"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/praatio/lib/textgrid.js"],"sourcesContent":["/**\n * This module contains the datastructures used for working with\n * Textgrids, IntervalTiers, and PointTiers, and the primary\n * functions used to operate over them.<br /><br />\n *\n * A Textgrid() is a container for annotation tiers. Annotation tiers\n * come in two varieties: IntervalTier and PointTier. With this library,\n * a textgrid can be queried, be used to filter data points, cleaned,\n * or algorithmically altered, etc.\n *\n * @author Tim Mahrt\n * @since March 25, 2015\n * @module textgrid\n */\n\nimport {\n  isClose, sortCompareEntriesByTime, entryListToTree,\n  findIntervalAtTime, findPointAtTime, doIntervalsOverlap\n} from './utils.js';\n\nconst INTERVAL_TIER = 'IntervalTier';\nconst POINT_TIER = 'TextTier';\nconst MIN_INTERVAL_LENGTH = 0.00000001; // Arbitrary threshold\n\nclass TierExistsException extends Error {\n  constructor (tierName, ...args) {\n    super(...args);\n    this.tierName = tierName;\n    this.message = `Tier name ${tierName} already exists in textgrid`;\n  }\n};\n\nclass TierCreationException extends Error {\n  constructor (errStr, ...args) {\n    super(...args);\n    this.errStr = errStr;\n    this.message = \"Couldn't create tier: \" + errStr;\n  }\n};\n\nclass TextgridCollisionException extends Error {\n  constructor (tierName, entry, matchList, ...args) {\n    super(...args);\n    this.tierName = tierName;\n    this.entry = entry;\n    this.matchList = matchList;\n    this.message = `Attempted to insert interval [${entry}] into tier '${tierName}' of textgrid but overlapping entries [${matchList}] already exist.`;\n  }\n};\n\nclass IndexException extends Error {\n  constructor (indexVal, listLength, ...args) {\n    super(...args);\n    this.indexVal = indexVal;\n    this.listLength = listLength;\n    this.message = `Attempted to index a list of length ${listLength} with index ${indexVal}.`;\n  }\n};\n\n/**\n * Abstract class for tiers.\n * @abstract\n * @hideconstructor\n */\nclass TextgridTier {\n  constructor (name, entryList, minT, maxT) {\n    // Don't allow a timeless tier to exist\n    if (minT === null || maxT === null) {\n      throw new TierCreationException('All textgrid tiers must have a min and max timestamp');\n    }\n\n    this.name = name;\n    this.entryList = entryList;\n    this.minTimestamp = minT;\n    this.maxTimestamp = maxT;\n    this.tierType = null;\n    this.sort()\n  }\n\n  /**\n   * Remove an entry from the tier's entryList\n   * @param {Array} entry - the entry to remove\n   */\n  deleteEntry (entry) {\n    let deleteI = -1;\n    for (let i = 0; i < this.entryList.length; i++) {\n      if (compareEntries(this.entryList[i], entry)) {\n        deleteI = i;\n        break;\n      }\n    }\n\n    if (deleteI === -1) {\n      throw new IndexException(deleteI, this.entryList.length);\n    }\n\n    this.entryList.splice(deleteI, 1);\n  }\n\n  sort () {\n    this.entryList.sort(sortCompareEntriesByTime);\n  }\n}\n\n/**\n * Class representing an PointTier.\n * @augments TextgridTier\n * @inheritdoc\n */\nclass PointTier extends TextgridTier {\n  /**\n   * @constructor\n   * @param {string} name\n   * @param {Array} entryList - each entry is of the form [time, label]\n   * @param {number} [minT=null] - the smallest time; if null use 0\n   * @param {number} [maxT=null] - the maximum length of the tier; if null use the last timestamp found in the entryList\n   */\n  constructor (name, entryList, minT = null, maxT = null) {\n    entryList = entryList.map(([timeV, label]) => [parseFloat(timeV), label]);\n\n    // Determine the min and max timestamps\n    const timeList = entryList.map(entry => entry[0]);\n    if (minT !== null) timeList.push(parseFloat(minT));\n    if (timeList.length > 0) minT = Math.min(...timeList);\n\n    if (maxT !== null) timeList.push(parseFloat(maxT));\n    if (timeList.length > 0) maxT = Math.max(...timeList);\n\n    // Finish intialization\n    super(name, entryList, minT, maxT);\n    this.tierType = POINT_TIER;\n    this.labelIndex = 1;\n  }\n\n  /**\n   * Insert an entry into the tier\n   * @param {Array} entry - of the form [time, label]\n   * @param {boolean} [warnFlag=true] - if the entry collides with an existing entry, warn the user?\n   * @param {string} [collisionCode=null] - the action to take if there is a collision\n   */\n  insertEntry (entry, warnFlag = true, collisionCode = null) {\n    const startTime = entry[0];\n\n    let match = null;\n    for (let i = 0; i < this.entryList.length; i++) {\n      if (isClose(startTime, this.entryList[i][0])) {\n        match = this.entryList[i];\n        break;\n      }\n    }\n\n    if (!match) {\n      this.entryList.push(entry);\n    }\n    else if (collisionCode && collisionCode.toLowerCase() === 'replace') {\n      this.deleteEntry(match);\n      this.entryList.push(entry);\n    }\n    else if (collisionCode && collisionCode.toLowerCase() === 'merge') {\n      const newEntry = [match[0], [match[1], entry[1]].join('-')];\n      this.deleteEntry(match);\n      this.entryList.push(newEntry);\n    }\n    else {\n      throw new TextgridCollisionException(this.name, entry, match);\n    }\n\n    this.sort();\n\n    if (match && warnFlag === true) {\n      const msg = `Collision warning for [${entry}] with items [${match}] of tier '${this.name}'`;\n      console.log(msg);\n    }\n  }\n}\n\n/**\n * Class representing an IntervalTier.\n * @augments TextgridTier\n */\nclass IntervalTier extends TextgridTier {\n  /**\n   * @constructor\n   * @param {string} name\n   * @param {Array} entryList - each entry is of the form [start time, end time, label]\n   * @param {number} [minT=null] - the smallest time; if null use 0\n   * @param {number} [maxT=null] - the maximum length of the tier; if null use the last timestamp found in the entryList\n   */\n  constructor (name, entryList, minT = null, maxT = null) {\n    entryList = entryList.map(([startTime, endTime, label]) => [parseFloat(startTime), parseFloat(endTime), label]);\n\n    // Determine the min and max timestamps\n    const startTimeList = entryList.map(entry => entry[0]);\n    if (minT !== null) startTimeList.push(parseFloat(minT));\n    if (startTimeList.length > 0) minT = Math.min(...startTimeList);\n\n    const endTimeList = entryList.map(entry => entry[1]);\n    if (maxT !== null) endTimeList.push(parseFloat(maxT));\n    if (endTimeList.length > 0) maxT = Math.max(...endTimeList);\n\n    // Finish initialization\n    super(name, entryList, minT, maxT);\n    this.tierType = INTERVAL_TIER;\n    this.labelIndex = 2;\n  }\n\n  /**\n   * Insert an entry into the tier\n   * @param {Array} entry - of the form [start time, end time, label]\n   * @param {boolean} [warnFlag=true] - if the entry collides with an existing entry, warn the user?\n   * @param {string} [collisionCode=null] - the action to take if there is a collision\n   */\n  insertEntry (entry, warnFlag = false, collisionCode = null) {\n    const startTime = entry[0];\n    const endTime = entry[1];\n\n    const matchList = getEntriesInInterval(this, startTime, endTime);\n\n    if (matchList.length === 0) {\n      this.entryList.push(entry);\n    }\n    else if (collisionCode && collisionCode.toLowerCase() === 'replace') {\n      for (let i = 0; i < matchList.length; i++) {\n        this.deleteEntry(matchList[i]);\n      }\n      this.entryList.push(entry);\n    }\n    else if (collisionCode && collisionCode.toLowerCase() === 'merge') {\n      for (let i = 0; i < matchList.length; i++) {\n        this.deleteEntry(matchList[i]);\n      }\n      matchList.push(entry);\n      matchList.sort(sortCompareEntriesByTime);\n\n      const startTimes = matchList.map(entry => entry[0]);\n      const endTimes = matchList.map(entry => entry[1]);\n      const labels = matchList.map(entry => entry[2]);\n\n      const newEntry = [\n        Math.min(...startTimes),\n        Math.max(...endTimes),\n        labels.join('-')\n      ]\n\n      this.entryList.push(newEntry);\n    }\n    else {\n      throw new TextgridCollisionException(this.name, entry, matchList);\n    }\n\n    this.sort();\n\n    if (matchList && warnFlag === true) {\n      const msg = `Collision warning for [${entry}] with items [${matchList}] of tier '${this.name}'`;\n      console.log(msg);\n    }\n  }\n}\n\n/**\n * Class representing a Textgrid.<br /><br />\n * A Textgrid is a container for annotations of an audio\n * file.  Annotations can be split into multiple tiers that\n * might represent different things (different speakers or\n * categories of events, etc). <br /><br />\n *\n * A Textgrid allows one to compute operations that affect\n * all of the contained tiers.\n */\nclass Textgrid {\n  constructor () {\n    this.tierNameList = [];\n    this.tierDict = {};\n\n    this.minTimestamp = null;\n    this.maxTimestamp = null;\n  }\n\n  /**\n   * Adds a tier to the textgrid.  Added to the end, unless an index is specified.\n   * @param {TextgridTier} tier\n   * @param {number} [tierIndex=null] - The index to insert at.  If null, add it to the end.\n   */\n  addTier (tier, tierIndex = null) {\n    if (Object.keys(this.tierDict).includes(tier.name)) {\n      throw new TierExistsException(tier.name);\n    }\n\n    if (tierIndex === null) this.tierNameList.push(tier.name);\n    else this.tierNameList.splice(tierIndex, 0, tier.name);\n\n    this.tierDict[tier.name] = tier;\n\n    if (this.minTimestamp === null) {\n      this.minTimestamp = tier.minTimestamp;\n    }\n    if (this.maxTimestamp === null) {\n      this.maxTimestamp = tier.maxTimestamp;\n    }\n    this._homogonizeMinMaxTimestamps();\n  }\n\n  /**\n   * Makes all min and max timestamps within a textgrid the same\n   * @ignore\n   */\n  _homogonizeMinMaxTimestamps () {\n    const minTimes = this.tierNameList.map(tierName => this.tierDict[tierName].minTimestamp);\n    const maxTimes = this.tierNameList.map(tierName => this.tierDict[tierName].maxTimestamp);\n\n    const minTimestamp = Math.min(...minTimes);\n    const maxTimestamp = Math.max(...maxTimes);\n\n    this.minTimestamp = minTimestamp;\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      const tierName = this.tierNameList[i];\n      this.tierDict[tierName].minTimestamp = minTimestamp;\n    }\n\n    this.maxTimestamp = maxTimestamp;\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      const tierName = this.tierNameList[i];\n      this.tierDict[tierName].maxTimestamp = maxTimestamp;\n    }\n  }\n\n  /**\n   * Renames one tier.  The new name must not exist in the textgrid already.\n   * @param {string} oldName\n   * @param {string} newName\n   */\n  renameTier (oldName, newName) {\n    if (Object.keys(this.tierDict).includes(newName)) {\n      throw new TierExistsException(newName);\n    }\n\n    const oldTier = this.tierDict[oldName];\n    const tierIndex = this.tierNameList.indexOf(oldName);\n    const newTier = copyTier(oldTier, { name: newName });\n\n    this.removeTier(oldName);\n    this.addTier(newTier, tierIndex);\n  }\n\n  /**\n   * Removes the given tier from this textgrid.\n   * @param {string} name\n   */\n  removeTier (name) {\n    this.tierNameList.splice(this.tierNameList.indexOf(name), 1);\n    delete this.tierDict[name];\n  }\n\n  /**\n   * Replace the tier with the given name with a new tier\n   * @param {string} name\n   * @param {TextgridTier} newTier\n   */\n  replaceTier (name, newTier) {\n    const tierIndex = this.tierNameList.indexOf(name);\n    this.removeTier(name);\n    this.addTier(newTier, tierIndex);\n  }\n}\n\n/**\n * Returns true if the two textgrids are the same, false otherwise\n * @param {Textgrid} tg1\n * @param {Textgrid} tg2\n * @return {boolean}\n */\nfunction compareTextgrids (tg1, tg2) {\n  let isEqual = true;\n  isEqual &= isClose(tg1.minTimestamp, tg2.minTimestamp);\n  isEqual &= isClose(tg1.maxTimestamp, tg2.maxTimestamp);\n  isEqual &= tg1.tierNameList.length === tg2.tierNameList.length;\n  for (let i = 0; i < tg1.tierNameList.length; i++) {\n    isEqual &= tg1.tierNameList[i] === tg2.tierNameList[i];\n  }\n\n  for (let i = 0; i < tg1.tierNameList.length; i++) {\n    const tierName = tg1.tierNameList[i];\n    isEqual &= compareTiers(tg1.tierDict[tierName], tg2.tierDict[tierName]);\n  }\n\n  return !!isEqual;\n}\n\n/**\n * Returns true if the two tiers are the same, false otherwise\n * @param {TextgridTier} tier1\n * @param {TextgridTier} tier2\n * @return {boolean}\n */\nfunction compareTiers (tier1, tier2) {\n  let isEqual = true;\n  isEqual &= tier1.name === tier2.name;\n  isEqual &= isClose(tier1.minTimestamp, tier2.minTimestamp);\n  isEqual &= isClose(tier1.maxTimestamp, tier2.maxTimestamp);\n  isEqual &= tier1.entryList.length === tier2.entryList.length;\n\n  if (isEqual) {\n    for (let i = 0; i < tier1.entryList.length; i++) {\n      isEqual &= compareEntries(tier1.entryList[i], tier2.entryList[i]);\n    }\n  }\n\n  return !!isEqual;\n}\n\n/**\n * Returns true if the two entries are the same, false otherwise\n * @param {Array} entryA\n * @param {Array} entryB\n * @return {boolean}\n */\nfunction compareEntries (entryA, entryB) {\n  let areEqual;\n  if (entryA.length === 2) {\n    areEqual = comparePoints(entryA, entryB);\n  } else if (entryA.length === 3) {\n    areEqual = compareIntervals(entryA, entryB);\n  }\n  return areEqual\n}\n\nfunction comparePoints (pointA, pointB) {\n  let areEqual = true;\n  areEqual &= isClose(pointA[0], pointB[0]);\n  areEqual &= pointA[1] === pointB[1];\n  return !!areEqual;\n}\n\nfunction compareIntervals (intervalA, intervalB) {\n  let areEqual = true;\n  areEqual &= isClose(intervalA[0], intervalB[0]);\n  areEqual &= isClose(intervalA[1], intervalB[1]);\n  areEqual &= intervalA[2] === intervalB[2];\n  return !!areEqual\n}\n\n/**\n * Returns a deep copy of a textgrid.\n * @param {Textgrid} tg\n * @return {Textgrid}\n */\nfunction copyTextgrid (tg) {\n  const textgrid = new Textgrid();\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    textgrid.addTier(copyTier(tg.tierDict[tierName]));\n  }\n\n  textgrid.minTimestamp = tg.minTimestamp;\n  textgrid.maxTimestamp = tg.maxTimestamp;\n\n  return textgrid;\n}\n\n/**\n * Returns a deep copy of a tier\n * @param {TextgridTier} tier\n * @param {Object} - an object containing optional values to replace those in the copy.  If the four paramaters name, entryList, minTimestamp, and maxTimestamp are null or not specified, those in the tier will be used (default behaviour).\n * @return {TextgridTier}\n */\nfunction copyTier (tier, {\n  name = null,\n  entryList = null,\n  minTimestamp = null,\n  maxTimestamp = null\n} = {}) {\n  if (name === null) name = tier.name;\n  if (entryList === null) entryList = tier.entryList.map(entry => entry.slice());\n  if (minTimestamp === null) minTimestamp = tier.minTimestamp;\n  if (maxTimestamp === null) maxTimestamp = tier.maxTimestamp;\n\n  return new tier.constructor(name, entryList, minTimestamp, maxTimestamp);\n}\n\n/**\n * Get the values that occur at points in the point tier.\n * @param {PointTier} pointTier\n * @param {Array} dataTupleList - should be ordered in time;\n *  must be of the form [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]\n * @return {Array}\n */\nfunction getValuesAtPoints (pointTier, dataTupleList) {\n  const searchTree = entryListToTree(pointTier.entryList);\n\n  const returnList = [];\n  for (let i = 0; i < dataTupleList.length; i++) {\n    const currentEntry = dataTupleList[i];\n    if (findPointAtTime(currentEntry[0], searchTree, false) !== null) {\n      returnList.push(currentEntry);\n    }\n  }\n\n  return returnList;\n}\n\n/**\n * Returns data from dataTupleList contained in labeled intervals\n * @params {IntervalTier} intervalTier\n * @params {Array} dataTupleList  - should be of the form: [(time1, value1a, value1b,..), (time2, value2a, value2b..), ..]\n * @return {Array}\n */\nfunction getValuesInIntervals (intervalTier, dataTupleList) {\n  const searchTree = entryListToTree(intervalTier.entryList);\n\n  const returnList = [];\n  for (let i = 0; i < dataTupleList.length; i++) {\n    const currentEntry = dataTupleList[i];\n    if (findIntervalAtTime(currentEntry[0], searchTree) !== null) {\n      returnList.push(currentEntry);\n    }\n  }\n\n  return returnList;\n}\n\n/**\n * Given an interval, returns entries in an interval tier that are in or (for intervals) that partially overlap with it\n * @params {TextgridTier} tier\n * @params {number} startTime\n * @params {number} endTime\n * @return {Array} entryList\n */\nfunction getEntriesInInterval (tier, startTime, endTime) {\n  let entryList\n  if (tier instanceof PointTier) {\n    entryList = getPointTierEntriesInInterval(tier, startTime, endTime);\n  }\n  else if (tier instanceof IntervalTier) {\n    entryList = getIntervalTierEntriesInInterval(tier, startTime, endTime);\n  }\n  return entryList;\n}\n\nfunction getIntervalTierEntriesInInterval (intervalTier, startTime, endTime) {\n  const entryList = [];\n  for (let i = 0; i < intervalTier.entryList.length; i++) {\n    const entry = intervalTier.entryList[i];\n    if (doIntervalsOverlap([startTime, endTime], entry)) {\n      entryList.push(entry);\n    }\n  }\n  return entryList;\n}\n\nfunction getPointTierEntriesInInterval (pointTier, startTime, endTime) {\n  const entryList = [];\n  for (let i = 0; i < pointTier.entryList.length; i++) {\n    const entry = pointTier.entryList[i];\n    if (entry[0] >= startTime && entry[0] <= endTime) {\n      entryList.push(entry);\n    }\n  }\n  return entryList;\n}\n\n/**\n * Returns the regions of the textgrid without labels\n * @params {IntervalTier} intervalTier\n * @return {Array} invertedEntryList - where each entry looks like [start time, end time, '']\n */\nfunction getNonEntriesFromIntervalTier (intervalTier) {\n  const invertedEntryList = [];\n\n  // Special case--the entry list is empty\n  if (intervalTier.entryList.length === 0) return [[intervalTier.minTimestamp, intervalTier.maxTimestamp, '']];\n\n  if (intervalTier.entryList[0][0] > 0) {\n    invertedEntryList.push([0, intervalTier.entryList[0][0], '']);\n  }\n\n  for (let i = 0; i < intervalTier.entryList.length - 1; i++) {\n    const currEnd = intervalTier.entryList[i][1];\n    const nextStart = intervalTier.entryList[i + 1][0];\n    if (currEnd !== nextStart) {\n      invertedEntryList.push([currEnd, nextStart, '']);\n    }\n  }\n\n  const lastI = intervalTier.entryList.length - 1;\n  if (intervalTier.entryList[lastI][1] < intervalTier.maxTimestamp) {\n    invertedEntryList.push([intervalTier.entryList[lastI][1], intervalTier.maxTimestamp, '']);\n  }\n\n  return invertedEntryList;\n}\n\n/**\n * Returns the indexes of the entries that match the search label\n * @params {TextgridTier} tier\n * @params {string} searchLabel\n * @params {string} [mode=null] If null, look for exact matches; if 're', match using regular expressions; if 'substr' look for substring matches\n * @return {Array}\n */\nfunction findLabelInTier (tier, searchLabel, mode = null) {\n  let cmprFunc;\n  if (mode === 're') {\n    cmprFunc = (text, reStr) => { return RegExp(reStr).test(text) };\n  }\n  else if (mode === 'substr') {\n    cmprFunc = (text, subStr) => { return text.includes(subStr) };\n  }\n  else {\n    cmprFunc = (text, searchText) => { return text === searchText };\n  }\n\n  // Run the search\n  const returnList = [];\n  for (let i = 0; i < tier.entryList.length; i++) {\n    if (cmprFunc(tier.entryList[i][tier.labelIndex], searchLabel)) returnList.push(i);\n  }\n  return returnList;\n}\n\nexport {\n  Textgrid, IntervalTier, PointTier,\n  // functions that compare\n  compareTextgrids, compareTiers, compareEntries,\n  comparePoints, compareIntervals,\n  // deep copy functions\n  copyTextgrid, copyTier,\n  // query functions\n  getValuesAtPoints, getValuesInIntervals, getEntriesInInterval,\n  getNonEntriesFromIntervalTier, findLabelInTier,\n  // exceptions\n  TierExistsException, TierCreationException, TextgridCollisionException,\n  IndexException,\n  // constants\n  INTERVAL_TIER, POINT_TIER, MIN_INTERVAL_LENGTH\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}