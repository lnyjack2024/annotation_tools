{"ast":null,"code":"import { union, difference } from 'polygon-clipping';\nimport { ValidationType } from '../types';\nimport { computeRotatedPosition, bezierSplit } from '../../../utils/math';\n// eslint-disable-next-line no-restricted-globals\nconst ctx = self;\nlet checkCount = 0;\nlet stopped = false;\nfunction checkFinished() {\n  checkCount -= 1;\n  if (checkCount === 0 && !stopped) {\n    // finish\n    ctx.postMessage({\n      finished: true\n    });\n  }\n}\nfunction getImageSize(imageUrl) {\n  return fetch(imageUrl).then(res => res.blob()).then(blob => createImageBitmap(blob, {\n    premultiplyAlpha: 'none',\n    colorSpaceConversion: 'none'\n  })).then(bitmap => ({\n    width: bitmap.width,\n    height: bitmap.height\n  }));\n}\nfunction isShapeClosed(shapeType) {\n  return ['line', 'arrow', 'dot'].indexOf(shapeType) < 0;\n}\nfunction generateGeomForShape(shapeType, shape) {\n  switch (shapeType) {\n    case 'polygon':\n      {\n        const {\n          points\n        } = shape;\n        return [[points.map(p => [p.x, p.y])]];\n      }\n    case 'rectangle':\n      {\n        const {\n          x,\n          y,\n          width,\n          height,\n          rotation = 0\n        } = shape;\n        const center = {\n          x: x + width / 2,\n          y: y + height / 2\n        };\n        return [[[{\n          x,\n          y\n        }, {\n          x: x + width,\n          y\n        }, {\n          x: x + width,\n          y: y + height\n        }, {\n          x,\n          y: y + height\n        }].map(p => {\n          const rp = computeRotatedPosition(center, p, rotation);\n          return [rp.x, rp.y];\n        })]];\n      }\n    case 'cuboid':\n    case 'two-sides-cuboid':\n      {\n        const {\n          front,\n          back\n        } = shape;\n        const {\n          x: x1,\n          y: y1,\n          width: w1,\n          height: h1\n        } = front;\n        const {\n          x: x2,\n          y: y2,\n          width: w2,\n          height: h2\n        } = back;\n        const frontSide = [[x1, y1], [x1 + w1, y1], [x1 + w1, y1 + h1], [x1, y1 + h1]];\n        const backSide = [[x2, y2], [x2 + w2, y2], [x2 + w2, y2 + h2], [x2, y2 + h2]];\n        return union([frontSide], [backSide], [[frontSide[0], frontSide[1], backSide[1], backSide[0]]], [[frontSide[1], frontSide[2], backSide[2], backSide[1]]], [[frontSide[2], frontSide[3], backSide[3], backSide[2]]], [[frontSide[3], frontSide[1], backSide[1], backSide[3]]]);\n      }\n    case 'l-shape':\n      {\n        const {\n          front,\n          sidePoints\n        } = shape;\n        const {\n          x,\n          y,\n          width,\n          height\n        } = front;\n        const [s1, s2] = sidePoints;\n        let baseX;\n        if (Math.abs(s1.x - x) < Math.abs(s1.x - x - width)) {\n          baseX = x;\n        } else {\n          baseX = x + width;\n        }\n        return union([[[x, y], [x + width, y], [x + width, y + height], [x, y + height]]], [[[baseX, y], [s1.x, s1.y], [s2.x, s2.y], [baseX, y + height]]]);\n      }\n    case 'ellipse':\n      {\n        const {\n          x: sx,\n          y: sy,\n          halfWidth,\n          halfHeight\n        } = shape;\n        const kappa = 0.5522848;\n        const x = sx - halfWidth;\n        const y = sy - halfHeight;\n        const ox = halfWidth * kappa;\n        const oy = halfHeight * kappa;\n        const xe = x + halfWidth * 2;\n        const ye = y + halfHeight * 2;\n        const xm = sx;\n        const ym = sy;\n        return [[[...bezierSplit(x, ym, xm, y, x, ym - oy, xm - ox, y), ...bezierSplit(xm, y, xe, ym, xm + ox, y, xe, ym - oy), ...bezierSplit(xe, ym, xm, ye, xe, ym + oy, xm + ox, ye), ...bezierSplit(xm, ye, x, ym, xm - ox, ye, x, ym + oy)]]];\n      }\n    case 'circle':\n      {\n        const {\n          x: sx,\n          y: sy,\n          radius\n        } = shape;\n        const kappa = 0.5522848;\n        const x = sx - radius;\n        const y = sy - radius;\n        const or = radius * kappa;\n        const xe = x + radius * 2;\n        const ye = y + radius * 2;\n        const xm = sx;\n        const ym = sy;\n        return [[[...bezierSplit(x, ym, xm, y, x, ym - or, xm - or, y), ...bezierSplit(xm, y, xe, ym, xm + or, y, xe, ym - or), ...bezierSplit(xe, ym, xm, ye, xe, ym + or, xm + or, ye), ...bezierSplit(xm, ye, x, ym, xm - or, ye, x, ym + or)]]];\n      }\n    case 'grid':\n      {\n        const {\n          cols,\n          rows\n        } = shape;\n        const x1 = cols[0].x;\n        const y1 = rows[0].y;\n        const x2 = cols[cols.length - 1].x;\n        const y2 = rows[rows.length - 1].y;\n        return [[[x1, y1], [x2, y1], [x2, y2], [x1, y2]]];\n      }\n    default:\n      return null;\n  }\n}\nasync function checkFrameShapes(cameraName, frameIndex, imageUrl, shapes, rotation, config) {\n  if (stopped) {\n    return;\n  }\n  checkCount += 1;\n  const size = await getImageSize(imageUrl);\n  const width = rotation % Math.PI === 0 ? size.width : size.height;\n  const height = rotation % Math.PI === 0 ? size.height : size.width;\n  const shapesWithGeom = shapes.map(s => {\n    const shapeGeom = generateGeomForShape(s.shapeType, s.shape);\n    return {\n      ...s,\n      shapeGeom\n    };\n  });\n  if (!stopped && config[ValidationType.EMPTY_AREA]) {\n    let emptyPolygons = [[[0, 0], [width, 0], [width, height], [0, height]]];\n    let diffed = false;\n    shapesWithGeom.forEach(({\n      shapeType,\n      instanceId,\n      instanceItemId,\n      shapeGeom\n    }) => {\n      if (isShapeClosed(shapeType) && shapeGeom) {\n        diffed = true;\n        try {\n          emptyPolygons = difference(emptyPolygons, shapeGeom);\n        } catch (e) {\n          console.log('Empty area check failed. Info:', {\n            instanceId,\n            instanceItemId,\n            cameraName,\n            frameIndex\n          });\n        }\n      }\n    });\n    if (!diffed) {\n      emptyPolygons = [emptyPolygons];\n    }\n    ctx.postMessage({\n      type: ValidationType.EMPTY_AREA,\n      cameraName,\n      frameIndex,\n      emptyPolygons\n    });\n  }\n  if (!stopped && config[ValidationType.FULLY_COVERED]) {\n    const coveredShapes = [];\n    shapesWithGeom.forEach(({\n      shapeType,\n      order,\n      instanceId,\n      instanceItemId,\n      shapeGeom\n    }) => {\n      if (isShapeClosed(shapeType) && shapeGeom) {\n        const upperShapes = shapesWithGeom.filter(s => isShapeClosed(s.shapeType) && s.order > order && s.shapeGeom);\n        if (upperShapes.length > 0) {\n          try {\n            let upperArea = upperShapes[0].shapeGeom;\n            if (upperShapes.length > 1) {\n              upperArea = union(upperArea, ...upperShapes.slice(1).map(i => i.shapeGeom));\n            }\n            const subtracted = difference(shapeGeom, upperArea);\n            if (subtracted.length === 0) {\n              coveredShapes.push({\n                instanceId,\n                instanceItemId\n              });\n            }\n          } catch (e) {\n            console.log('Fully covered check failed. Info:', {\n              instanceId,\n              instanceItemId,\n              cameraName,\n              frameIndex\n            });\n          }\n        }\n      }\n    });\n    ctx.postMessage({\n      type: ValidationType.FULLY_COVERED,\n      cameraName,\n      frameIndex,\n      coveredShapes\n    });\n  }\n  checkFinished();\n}\nctx.addEventListener('message', e => {\n  const {\n    type,\n    config,\n    cameras,\n    cameraAttributes,\n    instances\n  } = e.data;\n  if (type === 'stop') {\n    // stop\n    stopped = true;\n    ctx.postMessage({\n      finished: true\n    });\n    return;\n  }\n\n  // reset count & stopped\n  checkCount = 0;\n  stopped = false;\n\n  // parse camera instances map\n  const cameraInstancesMap = {};\n  for (let i = 0; i < instances.length; i += 1) {\n    const instance = instances[i];\n    const {\n      id: instanceId,\n      children: instanceItems\n    } = instance;\n    instanceItems.forEach(instanceItem => {\n      const {\n        id: instanceItemId,\n        cameras: instanceItemCameras\n      } = instanceItem;\n      instanceItemCameras.forEach(cameraData => {\n        const {\n          camera: cameraName,\n          frames\n        } = cameraData;\n        if (!cameraInstancesMap[cameraName]) {\n          cameraInstancesMap[cameraName] = {};\n        }\n        for (let j = 0; j < frames.length; j += 1) {\n          const frameData = frames[j];\n          const {\n            frameIndex,\n            shapeType,\n            shape,\n            order = 0\n          } = frameData;\n          if (!cameraInstancesMap[cameraName][frameIndex]) {\n            cameraInstancesMap[cameraName][frameIndex] = [];\n          }\n          cameraInstancesMap[cameraName][frameIndex].push({\n            shapeType,\n            shape,\n            order,\n            instanceItemId,\n            instanceId\n          });\n        }\n      });\n    });\n  }\n\n  // do validation\n  const allFramesData = [];\n  const allCameras = Object.keys(cameras);\n  for (let i = 0; i < allCameras.length; i += 1) {\n    const cameraName = allCameras[i];\n    const cameraFrames = cameras[cameraName];\n    for (let j = 0; j < cameraFrames.length; j += 1) {\n      const frame = cameraFrames[j];\n      const shapes = (cameraInstancesMap[cameraName] || {})[j] || [];\n      const {\n        rotation = 0\n      } = (cameraAttributes[cameraName] || {})[j] || {};\n      allFramesData.push({\n        cameraName,\n        frameIndex: j,\n        imageUrl: frame,\n        shapes,\n        rotation\n      });\n    }\n  }\n  const queueSize = 5;\n  const queue = [];\n  let currIndex = 0;\n  const doCheck = data => {\n    const req = checkFrameShapes(data.cameraName, data.frameIndex, data.imageUrl, data.shapes, data.rotation, config).then(() => {\n      if (currIndex < allFramesData.length - 1) {\n        currIndex += 1;\n        queue.shift();\n        doCheck(allFramesData[currIndex]);\n      }\n    });\n    queue.push(req);\n    if (queue.length < queueSize && currIndex < allFramesData.length - 1) {\n      currIndex += 1;\n      doCheck(allFramesData[currIndex]);\n    }\n  };\n  doCheck(allFramesData[currIndex]);\n});\nexport default null;","map":{"version":3,"names":["union","difference","ValidationType","computeRotatedPosition","bezierSplit","ctx","self","checkCount","stopped","checkFinished","postMessage","finished","getImageSize","imageUrl","fetch","then","res","blob","createImageBitmap","premultiplyAlpha","colorSpaceConversion","bitmap","width","height","isShapeClosed","shapeType","indexOf","generateGeomForShape","shape","points","map","p","x","y","rotation","center","rp","front","back","x1","y1","w1","h1","x2","y2","w2","h2","frontSide","backSide","sidePoints","s1","s2","baseX","Math","abs","sx","sy","halfWidth","halfHeight","kappa","ox","oy","xe","ye","xm","ym","radius","or","cols","rows","length","checkFrameShapes","cameraName","frameIndex","shapes","config","size","PI","shapesWithGeom","s","shapeGeom","EMPTY_AREA","emptyPolygons","diffed","forEach","instanceId","instanceItemId","e","console","log","type","FULLY_COVERED","coveredShapes","order","upperShapes","filter","upperArea","slice","i","subtracted","push","addEventListener","cameras","cameraAttributes","instances","data","cameraInstancesMap","instance","id","children","instanceItems","instanceItem","instanceItemCameras","cameraData","camera","frames","j","frameData","allFramesData","allCameras","Object","keys","cameraFrames","frame","queueSize","queue","currIndex","doCheck","req","shift"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/worker/validate.worker.ts"],"sourcesContent":["import { Geom, Ring, union, difference, Pair } from 'polygon-clipping';\nimport { CuboidData } from '../../common/shapes/Cuboid';\nimport { EllipseData } from '../../common/shapes/Ellipse';\nimport { CircleData } from '../../common/shapes/Circle';\nimport { GridData } from '../../common/shapes/Grid';\nimport { LShapeData } from '../../common/shapes/LShape';\nimport { PolygonData } from '../../common/shapes/Polygon';\nimport { RectangleData } from '../../common/shapes/Rectangle';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\nimport { Instance, ValidationType } from '../types';\nimport { computeRotatedPosition, bezierSplit } from '../../../utils/math';\n\ninterface ShapeInfoItem {\n  shapeType: ShapeType;\n  shape: ShapeData;\n  order: number;\n  instanceItemId: string;\n  instanceId: string;\n}\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = self as any;\n\nlet checkCount = 0;\nlet stopped = false;\n\nfunction checkFinished() {\n  checkCount -= 1;\n  if (checkCount === 0 && !stopped) {\n    // finish\n    ctx.postMessage({\n      finished: true,\n    });\n  }\n}\n\nfunction getImageSize(imageUrl: string) {\n  return fetch(imageUrl)\n    .then((res) => res.blob())\n    .then((blob) => createImageBitmap(blob, {\n      premultiplyAlpha: 'none',\n      colorSpaceConversion: 'none',\n    }))\n    .then((bitmap) => ({\n      width: bitmap.width,\n      height: bitmap.height,\n    }));\n}\n\nfunction isShapeClosed(shapeType: ShapeType) {\n  return ['line', 'arrow', 'dot'].indexOf(shapeType) < 0;\n}\n\nfunction generateGeomForShape(shapeType: ShapeType, shape: ShapeData): Geom | null {\n  switch (shapeType) {\n    case 'polygon': {\n      const { points } = shape as PolygonData;\n      return [[points.map((p) => [p.x, p.y] as Pair)]];\n    }\n    case 'rectangle': {\n      const { x, y, width, height, rotation = 0 } = shape as RectangleData;\n      const center = { x: x + width / 2, y: y + height / 2 };\n      return [[\n        [\n          { x, y },\n          { x: x + width, y },\n          { x: x + width, y: y + height },\n          { x, y: y + height },\n        ].map((p) => {\n          const rp = computeRotatedPosition(center, p, rotation);\n          return [rp.x, rp.y];\n        }),\n      ]];\n    }\n    case 'cuboid':\n    case 'two-sides-cuboid': {\n      const { front, back } = shape as CuboidData;\n      const { x: x1, y: y1, width: w1, height: h1 } = front;\n      const { x: x2, y: y2, width: w2, height: h2 } = back;\n      const frontSide: Ring = [[x1, y1], [x1 + w1, y1], [x1 + w1, y1 + h1], [x1, y1 + h1]];\n      const backSide: Ring = [[x2, y2], [x2 + w2, y2], [x2 + w2, y2 + h2], [x2, y2 + h2]];\n      return union(\n        [frontSide],\n        [backSide],\n        [[frontSide[0], frontSide[1], backSide[1], backSide[0]]],\n        [[frontSide[1], frontSide[2], backSide[2], backSide[1]]],\n        [[frontSide[2], frontSide[3], backSide[3], backSide[2]]],\n        [[frontSide[3], frontSide[1], backSide[1], backSide[3]]],\n      );\n    }\n    case 'l-shape': {\n      const { front, sidePoints } = shape as LShapeData;\n      const { x, y, width, height } = front;\n      const [s1, s2] = sidePoints;\n      let baseX;\n      if (Math.abs(s1.x - x) < Math.abs(s1.x - x - width)) {\n        baseX = x;\n      } else {\n        baseX = x + width;\n      }\n      return union(\n        [[[x, y], [x + width, y], [x + width, y + height], [x, y + height]]],\n        [[[baseX, y], [s1.x, s1.y], [s2.x, s2.y], [baseX, y + height]]],\n      );\n    }\n    case 'ellipse': {\n      const { x: sx, y: sy, halfWidth, halfHeight } = shape as EllipseData;\n      const kappa = 0.5522848;\n      const x = sx - halfWidth;\n      const y = sy - halfHeight;\n      const ox = halfWidth * kappa;\n      const oy = halfHeight * kappa;\n      const xe = x + halfWidth * 2;\n      const ye = y + halfHeight * 2;\n      const xm = sx;\n      const ym = sy;\n      return [[\n        [\n          ...bezierSplit(x, ym, xm, y, x, ym - oy, xm - ox, y),\n          ...bezierSplit(xm, y, xe, ym, xm + ox, y, xe, ym - oy),\n          ...bezierSplit(xe, ym, xm, ye, xe, ym + oy, xm + ox, ye),\n          ...bezierSplit(xm, ye, x, ym, xm - ox, ye, x, ym + oy),\n        ] as Ring,\n      ]];\n    }\n    case 'circle': {\n      const { x: sx, y: sy, radius } = shape as CircleData;\n      const kappa = 0.5522848;\n      const x = sx - radius;\n      const y = sy - radius;\n      const or = radius * kappa;\n      const xe = x + radius * 2;\n      const ye = y + radius * 2;\n      const xm = sx;\n      const ym = sy;\n      return [[\n        [\n          ...bezierSplit(x, ym, xm, y, x, ym - or, xm - or, y),\n          ...bezierSplit(xm, y, xe, ym, xm + or, y, xe, ym - or),\n          ...bezierSplit(xe, ym, xm, ye, xe, ym + or, xm + or, ye),\n          ...bezierSplit(xm, ye, x, ym, xm - or, ye, x, ym + or),\n        ] as Ring,\n      ]];\n    }\n    case 'grid': {\n      const { cols, rows } = shape as GridData;\n      const x1 = cols[0].x;\n      const y1 = rows[0].y;\n      const x2 = cols[cols.length - 1].x;\n      const y2 = rows[rows.length - 1].y;\n      return [[[x1, y1], [x2, y1], [x2, y2], [x1, y2]]];\n    }\n    default:\n      return null;\n  }\n}\n\nasync function checkFrameShapes(\n  cameraName: string,\n  frameIndex: number,\n  imageUrl: string,\n  shapes: ShapeInfoItem[],\n  rotation: number,\n  config: {\n    [type in ValidationType]?: boolean | string[]\n  },\n) {\n  if (stopped) {\n    return;\n  }\n\n  checkCount += 1;\n  const size = await getImageSize(imageUrl);\n  const width = rotation % Math.PI === 0 ? size.width : size.height;\n  const height = rotation % Math.PI === 0 ? size.height : size.width;\n\n  const shapesWithGeom = shapes.map((s) => {\n    const shapeGeom = generateGeomForShape(s.shapeType, s.shape);\n    return { ...s, shapeGeom };\n  });\n\n  if (!stopped && config[ValidationType.EMPTY_AREA]) {\n    let emptyPolygons: Geom = [[[0, 0], [width, 0], [width, height], [0, height]]];\n    let diffed = false;\n    shapesWithGeom.forEach(({ shapeType, instanceId, instanceItemId, shapeGeom }) => {\n      if (isShapeClosed(shapeType) && shapeGeom) {\n        diffed = true;\n        try {\n          emptyPolygons = difference(emptyPolygons, shapeGeom);\n        } catch (e) {\n          console.log('Empty area check failed. Info:', { instanceId, instanceItemId, cameraName, frameIndex });\n        }\n      }\n    });\n    if (!diffed) {\n      emptyPolygons = [emptyPolygons];\n    }\n    ctx.postMessage({\n      type: ValidationType.EMPTY_AREA,\n      cameraName,\n      frameIndex,\n      emptyPolygons,\n    });\n  }\n\n  if (!stopped && config[ValidationType.FULLY_COVERED]) {\n    const coveredShapes: { instanceId: string; instanceItemId: string }[] = [];\n    shapesWithGeom.forEach(({ shapeType, order, instanceId, instanceItemId, shapeGeom }) => {\n      if (isShapeClosed(shapeType) && shapeGeom) {\n        const upperShapes = shapesWithGeom.filter((s) => isShapeClosed(s.shapeType) && s.order > order && s.shapeGeom);\n        if (upperShapes.length > 0) {\n          try {\n            let upperArea = upperShapes[0].shapeGeom as Geom;\n            if (upperShapes.length > 1) {\n              upperArea = union(upperArea, ...upperShapes.slice(1).map((i) => i.shapeGeom as Geom));\n            }\n            const subtracted = difference(shapeGeom, upperArea);\n            if (subtracted.length === 0) {\n              coveredShapes.push({ instanceId, instanceItemId });\n            }\n          } catch (e) {\n            console.log('Fully covered check failed. Info:', { instanceId, instanceItemId, cameraName, frameIndex });\n          }\n        }\n      }\n    });\n    ctx.postMessage({\n      type: ValidationType.FULLY_COVERED,\n      cameraName,\n      frameIndex,\n      coveredShapes,\n    });\n  }\n\n  checkFinished();\n}\n\nctx.addEventListener('message', (e) => {\n  const { type, config, cameras, cameraAttributes, instances } = e.data;\n\n  if (type === 'stop') {\n    // stop\n    stopped = true;\n    ctx.postMessage({\n      finished: true,\n    });\n    return;\n  }\n\n  // reset count & stopped\n  checkCount = 0;\n  stopped = false;\n\n  // parse camera instances map\n  const cameraInstancesMap: {\n    [camera: string]: {\n      [frameIndex: number]: ShapeInfoItem[]\n    }\n  } = {};\n  for (let i = 0; i < instances.length; i += 1) {\n    const instance = instances[i] as Instance;\n    const { id: instanceId, children: instanceItems } = instance;\n    instanceItems.forEach((instanceItem) => {\n      const { id: instanceItemId, cameras: instanceItemCameras } = instanceItem;\n      instanceItemCameras.forEach((cameraData) => {\n        const { camera: cameraName, frames } = cameraData;\n        if (!cameraInstancesMap[cameraName]) {\n          cameraInstancesMap[cameraName] = {};\n        }\n        for (let j = 0; j < frames.length; j += 1) {\n          const frameData = frames[j];\n          const { frameIndex, shapeType, shape, order = 0 } = frameData;\n          if (!cameraInstancesMap[cameraName][frameIndex]) {\n            cameraInstancesMap[cameraName][frameIndex] = [];\n          }\n          cameraInstancesMap[cameraName][frameIndex].push({\n            shapeType, shape, order, instanceItemId, instanceId,\n          });\n        }\n      });\n    });\n  }\n\n  // do validation\n  const allFramesData: {\n    cameraName: string;\n    frameIndex: number;\n    imageUrl: string;\n    shapes: ShapeInfoItem[];\n    rotation: number;\n  }[] = [];\n  const allCameras = Object.keys(cameras);\n  for (let i = 0; i < allCameras.length; i += 1) {\n    const cameraName = allCameras[i];\n    const cameraFrames = cameras[cameraName];\n    for (let j = 0; j < cameraFrames.length; j += 1) {\n      const frame = cameraFrames[j];\n      const shapes = (cameraInstancesMap[cameraName] || {})[j] || [];\n      const { rotation = 0 } = (cameraAttributes[cameraName] || {})[j] || {};\n      allFramesData.push({ cameraName, frameIndex: j, imageUrl: frame, shapes, rotation });\n    }\n  }\n\n  const queueSize = 5;\n  const queue: Promise<any>[] = [];\n  let currIndex = 0;\n  const doCheck = (\n    data: {\n      cameraName: string;\n      frameIndex: number;\n      imageUrl: string;\n      shapes: ShapeInfoItem[];\n      rotation: number;\n    }\n  ) => {\n    const req = checkFrameShapes(data.cameraName, data.frameIndex, data.imageUrl, data.shapes, data.rotation, config)\n      .then(() => {\n        if (currIndex < allFramesData.length - 1) {\n          currIndex += 1;\n          queue.shift();\n          doCheck(allFramesData[currIndex]);\n        }\n      });\n    queue.push(req);\n    if (queue.length < queueSize && currIndex < allFramesData.length - 1) {\n      currIndex += 1;\n      doCheck(allFramesData[currIndex]);\n    }\n  };\n  doCheck(allFramesData[currIndex]);\n});\n\nexport default null as any;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}