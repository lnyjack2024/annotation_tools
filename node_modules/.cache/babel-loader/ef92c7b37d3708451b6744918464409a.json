{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBoundPosition = getBoundPosition;\nexports.snapToGrid = snapToGrid;\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.getControlPosition = getControlPosition;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nvar _shims = require(\"./shims\");\nvar _domFns = require(\"./domFns\");\nfunction getBoundPosition(draggable\n/*: Draggable*/, x\n/*: number*/, y\n/*: number*/) /*: [number, number]*/\n{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y]; // Clone new bounds\n\n  var bounds = draggable.props.bounds;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  var node = findDOMNode(draggable);\n  if (typeof bounds === 'string') {\n    var ownerDocument = node.ownerDocument;\n    var ownerWindow = ownerDocument.defaultView;\n    var boundNode;\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n    var nodeStyle = ownerWindow.getComputedStyle(node);\n    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  } // Keep x and y below right and bottom limits...\n\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.\n\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\nfunction snapToGrid(grid\n/*: [number, number]*/, pendingX\n/*: number*/, pendingY\n/*: number*/) /*: [number, number]*/\n{\n  var x = Math.round(pendingX / grid[0]) * grid[0];\n  var y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(draggable\n/*: Draggable*/) /*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\nfunction canDragY(draggable\n/*: Draggable*/) /*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n} // Get {x, y} positions from event.\n\nfunction getControlPosition(e\n/*: MouseTouchEvent*/, touchIdentifier\n/*: ?number*/, draggableCore\n/*: DraggableCore*/) /*: ?ControlPosition*/\n{\n  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n\n  var node = findDOMNode(draggableCore); // User can provide an offsetParent if desired.\n\n  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n} // Create an data object exposed by <DraggableCore>'s events\n\nfunction createCoreData(draggable\n/*: DraggableCore*/, x\n/*: number*/, y\n/*: number*/) /*: DraggableData*/\n{\n  var state = draggable.state;\n  var isStart = !(0, _shims.isNum)(state.lastX);\n  var node = findDOMNode(draggable);\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node: node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x: x,\n      y: y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node: node,\n      deltaX: x - state.lastX,\n      deltaY: y - state.lastY,\n      lastX: state.lastX,\n      lastY: state.lastY,\n      x: x,\n      y: y\n    };\n  }\n} // Create an data exposed by <Draggable>'s events\n\nfunction createDraggableData(draggable\n/*: Draggable*/, coreData\n/*: DraggableData*/) /*: DraggableData*/\n{\n  var scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n} // A lot faster than stringify/parse\n\nfunction cloneBounds(bounds\n/*: Bounds*/) /*: Bounds*/\n{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\nfunction findDOMNode(draggable\n/*: Draggable | DraggableCore*/) /*: HTMLElement*/\n{\n  var node = draggable.findDOMNode();\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n\n  return node;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getBoundPosition","snapToGrid","canDragX","canDragY","getControlPosition","createCoreData","createDraggableData","_shims","require","_domFns","draggable","x","y","props","bounds","cloneBounds","node","findDOMNode","ownerDocument","ownerWindow","defaultView","boundNode","parentNode","querySelector","HTMLElement","Error","nodeStyle","getComputedStyle","boundNodeStyle","left","offsetLeft","int","paddingLeft","marginLeft","top","offsetTop","paddingTop","marginTop","right","innerWidth","outerWidth","paddingRight","marginRight","bottom","innerHeight","outerHeight","paddingBottom","marginBottom","isNum","Math","min","max","grid","pendingX","pendingY","round","axis","e","touchIdentifier","draggableCore","touchObj","getTouch","offsetParent","body","offsetXYFromParent","scale","state","isStart","lastX","deltaX","deltaY","lastY","coreData"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/react-draggable/build/cjs/utils/positionFns.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBoundPosition = getBoundPosition;\nexports.snapToGrid = snapToGrid;\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.getControlPosition = getControlPosition;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\n\nvar _shims = require(\"./shims\");\n\nvar _domFns = require(\"./domFns\");\n\nfunction getBoundPosition(draggable\n/*: Draggable*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: [number, number]*/\n{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y]; // Clone new bounds\n\n  var bounds = draggable.props.bounds;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  var node = findDOMNode(draggable);\n\n  if (typeof bounds === 'string') {\n    var ownerDocument = node.ownerDocument;\n    var ownerWindow = ownerDocument.defaultView;\n    var boundNode;\n\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n\n    var nodeStyle = ownerWindow.getComputedStyle(node);\n    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  } // Keep x and y below right and bottom limits...\n\n\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.\n\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\n\nfunction snapToGrid(grid\n/*: [number, number]*/\n, pendingX\n/*: number*/\n, pendingY\n/*: number*/\n)\n/*: [number, number]*/\n{\n  var x = Math.round(pendingX / grid[0]) * grid[0];\n  var y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\n\nfunction canDragX(draggable\n/*: Draggable*/\n)\n/*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\n\nfunction canDragY(draggable\n/*: Draggable*/\n)\n/*: boolean*/\n{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n} // Get {x, y} positions from event.\n\n\nfunction getControlPosition(e\n/*: MouseTouchEvent*/\n, touchIdentifier\n/*: ?number*/\n, draggableCore\n/*: DraggableCore*/\n)\n/*: ?ControlPosition*/\n{\n  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n\n  var node = findDOMNode(draggableCore); // User can provide an offsetParent if desired.\n\n  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n} // Create an data object exposed by <DraggableCore>'s events\n\n\nfunction createCoreData(draggable\n/*: DraggableCore*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: DraggableData*/\n{\n  var state = draggable.state;\n  var isStart = !(0, _shims.isNum)(state.lastX);\n  var node = findDOMNode(draggable);\n\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node: node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x: x,\n      y: y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node: node,\n      deltaX: x - state.lastX,\n      deltaY: y - state.lastY,\n      lastX: state.lastX,\n      lastY: state.lastY,\n      x: x,\n      y: y\n    };\n  }\n} // Create an data exposed by <Draggable>'s events\n\n\nfunction createDraggableData(draggable\n/*: Draggable*/\n, coreData\n/*: DraggableData*/\n)\n/*: DraggableData*/\n{\n  var scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n} // A lot faster than stringify/parse\n\n\nfunction cloneBounds(bounds\n/*: Bounds*/\n)\n/*: Bounds*/\n{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\n\nfunction findDOMNode(draggable\n/*: Draggable | DraggableCore*/\n)\n/*: HTMLElement*/\n{\n  var node = draggable.findDOMNode();\n\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n\n\n  return node;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}