{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { Container, Graphics, Point, Text, utils as PIXIUtils } from 'pixi.js';\nimport Layer from './Layer';\nimport ExtendedGraphics from './ExtendedGraphics';\nimport ShapeGraphics from './ShapeGraphics';\nimport { ShapeType } from './types';\nimport { findIntersections } from './utils';\nimport Cursor from '../Cursor';\nimport { computeRotatedPosition } from '../../../utils/math';\nexport let EventAction = /*#__PURE__*/function (EventAction) {\n  EventAction[\"SELECTED\"] = \"selected\";\n  EventAction[\"VERTEX_SELECTED\"] = \"vertex-selected\";\n  EventAction[\"FINISHED\"] = \"finished\";\n  EventAction[\"REMOVED\"] = \"removed\";\n  EventAction[\"CHANGED\"] = \"changed\";\n  EventAction[\"POINTER_OVER\"] = \"pointer-over\";\n  EventAction[\"POINTER_OUT\"] = \"pointer-out\";\n  return EventAction;\n}({});\nexport let BorderStyle = /*#__PURE__*/function (BorderStyle) {\n  BorderStyle[\"SOLID\"] = \"solid\";\n  BorderStyle[\"DASHED\"] = \"dashed\";\n  return BorderStyle;\n}({});\n/**\n * Shape base\n * @class\n */\nexport default class Shape {\n  /**\n   * global snapping point (not on self shape)\n   * @getter\n   */\n  get globalSnappingPoint() {\n    return this.container instanceof Layer ? this.container.snappingPoint : this.app.stage.snappingPoint;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get area() {\n    return NaN;\n  }\n\n  // TODO: make pivot as abstract getter & setter\n  // eslint-disable-next-line class-methods-use-this\n  get pivot() {\n    return new Point(0, 0);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  set pivot(p) {}\n\n  /**\n   * get position\n   * @getter\n   */\n\n  /**\n   * set position\n   * @setter\n   */\n\n  /**\n   * shape bounds\n   * @getter\n   */\n\n  /**\n   * get color\n   * @getter\n   */\n  get color() {\n    return this._color;\n  }\n\n  /**\n   * set color\n   * @setter\n   */\n  set color(color) {\n    const shouldUpdate = this._color !== color;\n    this._color = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border color\n   * @getter\n   */\n  get borderColor() {\n    return this._borderColor;\n  }\n\n  /**\n   * set border color\n   * @setter\n   */\n  set borderColor(color) {\n    const shouldUpdate = this._borderColor !== color;\n    this._borderColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get display border color\n   * @getter\n   */\n  get displayBorderColor() {\n    if (this.selected) {\n      return this.selectedColor;\n    }\n    if (this.hovered) {\n      return this.hoveredColor;\n    }\n    return this.borderColor;\n  }\n\n  /**\n   * get alpha\n   * @getter\n   */\n  get alpha() {\n    return this._alpha;\n  }\n\n  /**\n   * set alpha\n   * @setter\n   */\n  set alpha(alpha) {\n    const newAlpha = alpha > 0 ? alpha : 0.005; // for transparent shape, interactions can't be fired\n    const shouldUpdate = this._alpha !== newAlpha;\n    this._alpha = newAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get label\n   * @getter\n   */\n  get label() {\n    return this._label;\n  }\n\n  /**\n   * set label\n   * @setter\n   */\n  set label(label) {\n    this._label = label;\n    this.drawShapeLabel();\n  }\n\n  /**\n   * get border style\n   * @getter\n   */\n  get borderStyle() {\n    return this._borderStyle;\n  }\n\n  /**\n   * set border style\n   * @setter\n   */\n  set borderStyle(borderStyle) {\n    const shouldUpdate = this._borderStyle !== borderStyle;\n    this._borderStyle = borderStyle;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex\n   * @getter\n   */\n  get showVertex() {\n    return this._showVertex;\n  }\n\n  /**\n   * set show vertex\n   * @setter\n   */\n  set showVertex(showVertex) {\n    const shouldUpdate = this._showVertex !== showVertex;\n    this._showVertex = showVertex;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex order\n   * @getter\n   */\n  get showVertexOrder() {\n    return this._showVertexOrder;\n  }\n\n  /**\n   * set show vertex order\n   * @setter\n   */\n  set showVertexOrder(showVertexOrder) {\n    const shouldUpdate = this._showVertexOrder !== showVertexOrder;\n    this._showVertexOrder = showVertexOrder;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get order\n   * @getter\n   */\n  get order() {\n    return this._order;\n  }\n\n  /**\n   * set order\n   * @setter\n   */\n  set order(order) {\n    this._order = order;\n    this._updateShapeContainerOrder();\n    if (this.labelDom) {\n      this.labelDom.zIndex = order;\n    }\n  }\n\n  /**\n   * get visible\n   * @getter\n   */\n  get visible() {\n    return this._visible;\n  }\n\n  /**\n   * set visible\n   * @setter\n   */\n  set visible(visible) {\n    const shouldUpdate = this._visible !== visible;\n    this._visible = visible;\n    if (shouldUpdate) {\n      this.instance.interactive = visible ? this.interactive : false;\n      this.shapeContainer.visible = visible;\n      this.controlsContainer.visible = visible;\n      if (this._rotateControl) {\n        this._rotateControl.control.visible = visible;\n      }\n      if (this.labelDom) {\n        this.labelDom.visible = visible;\n      }\n    }\n  }\n\n  /**\n   * get interactive\n   * @getter\n   */\n  get interactive() {\n    return this._interactive;\n  }\n\n  /**\n   * set interactive\n   * @setter\n   */\n  set interactive(interactive) {\n    this._interactive = interactive;\n    if (this.instance) {\n      this.instance.interactive = interactive;\n    }\n    this._controls.forEach(c => {\n      c.control.interactive = interactive;\n    });\n    if (!interactive) {\n      this.selected = false;\n      this.hovered = false;\n    }\n  }\n\n  /**\n   * get editable\n   * @getter\n   */\n  get editable() {\n    return this._editable;\n  }\n\n  /**\n   * set editable\n   * @setter\n   */\n  set editable(editable) {\n    this._editable = editable;\n    this.drawShape();\n  }\n\n  /**\n   * get rotatable\n   * @getter\n   */\n  get rotatable() {\n    return this._rotatable;\n  }\n\n  /**\n   * set rotatable\n   * @setter\n   */\n  set rotatable(rotatable) {\n    this._rotatable = rotatable;\n  }\n\n  /**\n   * get shape finished\n   * @getter\n   */\n  get finished() {\n    return this._finished;\n  }\n\n  /**\n   * get selected\n   * @getter\n   */\n  get selected() {\n    return this._selected;\n  }\n\n  /**\n   * set selected\n   * @setter\n   */\n  set selected(selected) {\n    const shouldUpdate = this._selected !== selected;\n    this._selected = selected;\n    this._updateShapeContainerOrder();\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get hovered\n   * @getter\n   */\n  get hovered() {\n    return this._hovered;\n  }\n\n  /**\n   * set hovered\n   * @setter\n   */\n  set hovered(hovered) {\n    const shouldUpdate = this._hovered !== hovered;\n    this._hovered = hovered;\n    if (shouldUpdate) {\n      this.drawShape();\n      this._emit(hovered ? EventAction.POINTER_OVER : EventAction.POINTER_OUT);\n    }\n    // should update stage cursor because instance cursor not show when covered by others\n    if (hovered) {\n      this.instance.cursor = this.editable ? Cursor.MOVE : Cursor.POINTER;\n    } else {\n      this.instance.cursor = Cursor.DEFAULT;\n    }\n  }\n\n  /**\n   * get scale\n   * @getter\n   */\n  get scale() {\n    return this._scale;\n  }\n\n  /**\n   * set scale\n   * @setter\n   */\n  set scale(scale) {\n    const shouldUpdate = this._scale !== scale;\n    this._scale = scale;\n    this._controls.forEach(c => {\n      // eslint-disable-next-line no-param-reassign\n      c.scale = scale;\n    });\n    if (this._rotateControl) {\n      this._rotateControl.scale = scale;\n    }\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get rotation\n   * @getter\n   */\n  get rotation() {\n    return this._rotation;\n  }\n\n  /**\n   * set rotation\n   * @setter\n   */\n  set rotation(rotation) {\n    this._rotation = rotation;\n    this._updatePosition();\n    this.drawShape();\n  }\n  constructor({\n    app,\n    container,\n    scale,\n    color,\n    alpha,\n    label,\n    showVertex,\n    showVertexOrder,\n    rotatable = false,\n    labelDom\n  }) {\n    /**\n     * shape type\n     */\n    this.shapeType = void 0;\n    /**\n     * unique id\n     * @member {string}\n     */\n    this.uid = uuidv4();\n    /**\n     * PIXI instance\n     * @member {ShapeGraphics}\n     */\n    this.instance = new ShapeGraphics(this);\n    /**\n     * PIXI application\n     * @member {PIXI.Application}\n     */\n    this.app = void 0;\n    /**\n     * PIXI container\n     * @member {PIXI.Container | Layer}\n     */\n    this.container = void 0;\n    /**\n     * origin colors from shape options\n     */\n    this.originColors = {\n      color: 0,\n      borderColor: 0\n    };\n    /**\n     * selected border color\n     * @member {number}\n     */\n    this.selectedColor = 0xFFFF00;\n    /**\n     * hovered border color\n     * @member {number}\n     */\n    this.hoveredColor = 0xCCCCCC;\n    /**\n     * shape container\n     * @member {PIXI.Container}\n     */\n    this.shapeContainer = new Container();\n    /**\n     * controls container\n     * @member {PIXI.Container}\n     */\n    this.controlsContainer = new Container();\n    /**\n     * label container\n     * @member {PIXI.Container}\n     */\n    this.labelContainer = void 0;\n    /**\n     * label dom\n     * @member {Label}\n     */\n    this.labelDom = void 0;\n    /**\n     * container to show shape vertexes\n     * @member {PIXI.Container}\n     */\n    this.vertexesContainer = void 0;\n    /**\n     * is shape destroyed\n     * @member {boolean}\n     */\n    this.destroyed = false;\n    /**\n     * is shape resizing\n     * @member {boolean}\n     */\n    this.resizing = false;\n    /**\n     * is shape dragging\n     * @member {boolean}\n     */\n    this.dragging = false;\n    /**\n     * events emitter\n     * @private {PIXI.utils.EventEmitter}\n     */\n    this._eventEmitter = new PIXIUtils.EventEmitter();\n    /**\n     * controls\n     * @protected {Control[]}\n     */\n    this._controls = [];\n    /**\n     * control for shape rotation\n     * @protected {ControlRotation}\n     */\n    this._rotateControl = void 0;\n    /**\n     * instance to draw shape boundary control\n     * @protected {ExtendedGraphics}\n     */\n    this._controlLine = new ExtendedGraphics();\n    /**\n     * color\n     * @protected {number}\n     */\n    this._color = 0;\n    /**\n     * border color\n     * @protected {number}\n     */\n    this._borderColor = 0;\n    /**\n     * shape alpha\n     * @protected {number}\n     */\n    this._alpha = 0.5;\n    /**\n     * shape label\n     * @protected {string}\n     */\n    this._label = '';\n    /**\n     * shape border style\n     * @protected {BorderStyle}\n     */\n    this._borderStyle = BorderStyle.SOLID;\n    /**\n     * show shape vertex\n     * @protected {boolean}\n     */\n    this._showVertex = false;\n    /**\n     * show shape vertex order\n     * @protected {boolean}\n     */\n    this._showVertexOrder = false;\n    /**\n     * shape z-index\n     * @protected {number}\n     */\n    this._order = 0;\n    /**\n     * is shape visible\n     * @protected {boolean}\n     */\n    this._visible = true;\n    /**\n     * is shape interactive\n     * @protected {boolean}\n     */\n    this._interactive = true;\n    /**\n     * is shape editable\n     * @protected {boolean}\n     */\n    this._editable = true;\n    /**\n     * is shape rotatable\n     * @protected {boolean}\n     */\n    this._rotatable = false;\n    /**\n     * is shape drawing finished\n     * @protected {boolean}\n     */\n    this._finished = true;\n    /**\n     * is shape selected\n     * @protected {boolean}\n     */\n    this._selected = false;\n    /**\n     * is shape hovered\n     * @protected {boolean}\n     */\n    this._hovered = false;\n    /**\n     * shape scale factor\n     * @protected {boolean}\n     */\n    this._scale = 1;\n    /**\n     * shape rotation\n     * @protected {number}\n     */\n    this._rotation = 0;\n    /**\n     * point when snapping\n     * @protected {Point}\n     */\n    this._snappingPoint = null;\n    /**\n     * is ctrl key down\n     * @protected {boolean}\n     */\n    this._ctrlKey = false;\n    /**\n     * mouse position when click to drag\n     * @private {Point}\n     */\n    this._dragPoint = null;\n    /**\n     * instance position when click to drag\n     * @private {Point}\n     */\n    this._dragPosistion = null;\n    /**\n     * is instance been dragged\n     * @private {boolean}\n     */\n    this._dragged = false;\n    /**\n     * is right click down\n     * @private {boolean}\n     */\n    this._rightClicked = false;\n    /**\n     * is right dragged\n     * @private {boolean}\n     */\n    this._rightDragged = false;\n    /**\n     * last pivot\n     * @private {Point|undefined}\n     */\n    this._lastPivot = void 0;\n    /**\n     * process pointerdown\n     * @param event\n     * @param frontTargets\n     */\n    this.processPointerDown = (event, frontTargets = []) => {\n      if (event.data.button === 2) {\n        this._rightClicked = true;\n        this._continuePropogating(event, frontTargets, 'processPointerDown');\n        return;\n      }\n      if (this.hovered) {\n        event.stopPropagation();\n        const p = event.data.getLocalPosition(this.container);\n        this._dragPoint = new Point(p.x, p.y);\n        this._dragPosistion = this.position;\n        this._dragged = false;\n        this.selected = true;\n        this._emit(EventAction.SELECTED, p);\n        // disable controls interactivity when first pointer down to selected (avoid bugs when start dragging on controls)\n        this._controls.forEach(c => {\n          c.control.interactive = false;\n        });\n      }\n      if (!this._snappingPoint) {\n        // if upper shapes has snapping point, do not propogating\n        this._continuePropogating(event, frontTargets, 'processPointerDown');\n      }\n    };\n    /**\n     * process pointerup\n     * @param event\n     * @param frontTargets\n     */\n    this.processPointerUp = (event, frontTargets = []) => {\n      if (event.data.button === 2 && this._rightClicked && !this._rightDragged) {\n        if (this.hovered && !this.selected) {\n          const p = event.data.getLocalPosition(this.container);\n          this.selected = true;\n          this._emit(EventAction.SELECTED, p);\n        }\n      }\n\n      // re-active controls when pointer up\n      this._controls.forEach(c => {\n        c.control.interactive = true;\n      });\n      this.dragging = false;\n      this._dragPoint = null;\n      this._dragPosistion = null;\n      if (this._dragged) {\n        this._changed();\n        this._dragged = false;\n      }\n      this._rightClicked = false;\n      this._rightDragged = false;\n      this._continuePropogating(event, frontTargets, 'processPointerUp');\n    };\n    /**\n     * process pointermove\n     * @param event\n     */\n    this.processPointerMove = event => {\n      if (event.data.buttons === 2 && this._rightClicked) {\n        this._rightDragged = true;\n        return;\n      }\n      if (this.editable && this.selected && this.snap(event)) {\n        // snapping\n        this.instance.cursor = Cursor.DEFAULT;\n      } else if (this.editable && this.selected && this._dragPoint && this._dragPosistion) {\n        // dragging\n        this._dragged = true;\n        this._ctrlKey = event.data.originalEvent.ctrlKey;\n        const point = event.data.getLocalPosition(this.container);\n        const originX = this.position.x;\n        const originY = this.position.y;\n        const position = new Point(this._dragPosistion.x + (point.x - this._dragPoint.x), this._dragPosistion.y + (point.y - this._dragPoint.y));\n        // prefer to use global snapping point if moving a dot\n        this.position = this.shapeType === ShapeType.DOT && this.globalSnappingPoint ? this.globalSnappingPoint : position;\n        this._updatePosition();\n        this._dragging({\n          deltaX: this.position.x - originX,\n          deltaY: this.position.y - originY\n        });\n      }\n    };\n    /**\n     * process app mouse down\n     */\n    this.processGlobalMouseDown = () => {\n      if (this._snappingPoint) {\n        const success = this.addSnappingPointToShape();\n        if (success) {\n          // set selected\n          this.selected = true;\n          this._emit(EventAction.SELECTED);\n          // ignore drag start\n          this._dragPoint = null;\n          this._dragPosistion = null;\n        }\n      }\n    };\n    /**\n     * key down handler\n     * @protected\n     * @param e\n     */\n    this._shapeKeyDown = e => {\n      if (this.finished && this.selected && this.editable && e.shiftKey) {\n        var _e$key;\n        let deltaX = 0;\n        let deltaY = 0;\n        let rotation = 0;\n        switch ((_e$key = e.key) === null || _e$key === void 0 ? void 0 : _e$key.toLowerCase()) {\n          case 'w':\n            deltaY = -1;\n            break;\n          case 'a':\n            deltaX = -1;\n            break;\n          case 's':\n            deltaY = 1;\n            break;\n          case 'd':\n            deltaX = 1;\n            break;\n          case 'q':\n            rotation = -1;\n            break;\n          case 'e':\n            rotation = 1;\n            break;\n          default:\n            break;\n        }\n        if (deltaX !== 0 || deltaY !== 0) {\n          e.preventDefault();\n          this.position = new Point(this.position.x + deltaX, this.position.y + deltaY);\n          this._updatePosition();\n          this._changed();\n        }\n        if (rotation !== 0 && this.rotatable) {\n          e.preventDefault();\n          this.rotation += rotation * (Math.PI / 180);\n          this._changed();\n        }\n      }\n    };\n    this.instance.on('pointerdown', this.processPointerDown);\n    this.instance.on('pointerup', this.processPointerUp);\n    this.instance.on('pointerupoutside', this.processPointerUp);\n    this.instance.on('pointermove', this.processPointerMove);\n    this.app = app;\n    this.app.view.addEventListener('mousedown', this.processGlobalMouseDown, false);\n    document.addEventListener('keydown', this._shapeKeyDown, false);\n    this.container = container || app.stage;\n    this.instance.interactive = this.interactive;\n    this.controlsContainer.zIndex = 9999;\n    this.shapeContainer.addChild(this.instance);\n    this.container.addChild(this.shapeContainer);\n    this.container.addChild(this.controlsContainer);\n    this._controlLine.interactive = false;\n    this.controlsContainer.addChild(this._controlLine);\n    this._scale = scale || app.stage.scale.x;\n    if (color !== undefined) {\n      this._color = color;\n      this._borderColor = color;\n    }\n    this.originColors = {\n      color: this._color,\n      borderColor: this._borderColor\n    };\n    if (alpha !== undefined) {\n      this._alpha = alpha > 0 ? alpha : 0.005;\n    }\n    if (label !== undefined) {\n      this._label = label;\n    }\n    if (showVertex !== undefined) {\n      this._showVertex = showVertex;\n    }\n    if (showVertexOrder !== undefined) {\n      this._showVertexOrder = showVertexOrder;\n    }\n    this._rotatable = rotatable;\n    this.labelDom = labelDom;\n  }\n\n  /**\n   * update container position\n   * @protected\n   */\n  _updatePosition(resize = false) {\n    const pivot = this.pivot.clone();\n    if (resize && this._lastPivot) {\n      // resize change pivot\n      const rotatedPivot = computeRotatedPosition(this._lastPivot, pivot, this.rotation);\n      pivot.x = rotatedPivot.x;\n      pivot.y = rotatedPivot.y;\n      this.pivot = pivot;\n    }\n    this.shapeContainer.pivot.set(pivot.x, pivot.y);\n    this.shapeContainer.position.set(pivot.x, pivot.y);\n    this.shapeContainer.rotation = this.rotation;\n    this._lastPivot = pivot.clone();\n    this.controlsContainer.pivot.set(pivot.x, pivot.y);\n    this.controlsContainer.position.set(pivot.x, pivot.y);\n    this.controlsContainer.rotation = this.rotation;\n  }\n  /**\n   * propogating event to back shapes\n   * @param event\n   * @param frontTargets\n   * @param funcName\n   */\n  _continuePropogating(event, frontTargets, funcName) {\n    this.instance.interactive = false;\n    const {\n      interaction\n    } = this.app.renderer.plugins;\n    const hit = interaction.hitTest(event.data.global);\n    if (hit && hit instanceof ShapeGraphics && !frontTargets.includes(this.instance)) {\n      hit.shape[funcName](event, [...frontTargets, this.instance]);\n    }\n    this.instance.interactive = true;\n  }\n  /**\n   * actual draw the shape on canvas\n   */\n  /**\n   * start shape create\n   * @param point create start point\n   * @param options options used for creation\n   */\n  /**\n   * get label position of the shape\n   */\n  /**\n   * get shape data\n   */\n  /**\n   * get shape Geo JSON (multi polygon)\n   */\n  /**\n   * delete selected points in shape, default reture false and can be overwritten in sub class\n   */\n  deleteSelectedPoints() {\n    return false; // false means no point deleted\n  }\n\n  /**\n   * snap to shape vertexes or edges\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point, tolerance) {\n    return null;\n  }\n\n  /**\n   * snap to shape edges\n   * @param point\n   */\n  snap(event) {\n    this._snappingPoint = null;\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    return false;\n  }\n\n  /**\n   * draw shape label\n   */\n  drawShapeLabel() {\n    const borderOffset = this.shapeType !== ShapeType.DOT ? 1 / 2 : 0;\n    const vertexOffset = (this.shapeType === ShapeType.POLYGON || this.shapeType === ShapeType.LINE || this.shapeType === ShapeType.RECTANGLE) && this.showVertex ? 4 : 0;\n    if (this.labelDom) {\n      // use dom to render\n      if (this.label) {\n        this.labelDom.text = this.label;\n        this.labelDom.zIndex = this.order;\n        const position = this.getLabelPosition();\n        const globalPosition = this.container.toGlobal({\n          x: position.x,\n          y: position.y - (borderOffset + vertexOffset) / this.scale\n        });\n        const globalPivot = this.container.toGlobal(this.pivot);\n        this.labelDom.setPosition(globalPosition, globalPivot, this.rotation);\n      }\n    } else if (this.label) {\n      if (!this.labelContainer) {\n        this._createLabelContainer();\n      } else {\n        this.labelContainer.removeChildren();\n      }\n      const {\n        x,\n        y\n      } = this.getLabelPosition();\n      this.labelContainer.position.x = x;\n      this.labelContainer.position.y = y - (18 + borderOffset + vertexOffset) / this.scale;\n      this.labelContainer.scale.set(1 / this.scale);\n      const text = new Text(` ${this.label} `, {\n        fontSize: 14,\n        lineHeight: 18,\n        fill: '#FFFFFF'\n      });\n      const {\n        width,\n        height\n      } = text.getBounds();\n      const bounds = new Graphics();\n      bounds.beginFill(0, 0.6);\n      bounds.drawRect(0, 0, width, height);\n      bounds.endFill();\n      this.labelContainer.addChild(bounds);\n      this.labelContainer.addChild(text);\n    }\n  }\n\n  /**\n   * finish shape create\n   * @param otherShapeData\n   * @protected\n   */\n  _finish(otherShapeData) {\n    if (!this.destroyed) {\n      this._finished = true;\n      this.drawShape();\n      this._emit(EventAction.FINISHED, otherShapeData);\n    }\n  }\n\n  /**\n   * remove shape from canvas\n   * @protected\n   */\n  _remove() {\n    this._emit(EventAction.REMOVED);\n    this.destroy();\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  _changed() {\n    this._emit(EventAction.CHANGED, this.getData());\n  }\n\n  /**\n   * when shape is been dragging\n   * @param data\n   * @protected\n   */\n  _dragging(data) {\n    this.dragging = true;\n  }\n\n  /**\n   * when shape is reszing\n   * @param data\n   * @protected\n   */\n  _resizing(data) {\n    this.resizing = true;\n  }\n\n  /**\n   * get global position\n   * @returns\n   */\n  getGlobalPosition() {\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.shapeBounds;\n    const center = new Point(left + (right - left) / 2, top + (bottom - top) / 2);\n    const {\n      x,\n      y\n    } = this.container.toGlobal(center);\n    return {\n      x,\n      y\n    };\n  }\n\n  /**\n   * find intersections\n   * @param shapes\n   */\n  findIntersections(shapes) {\n    const currentShapeData = this.getAreaAsGeoJSON();\n    const filteredShapes = shapes.filter(s => s.uid !== this.uid);\n    return findIntersections(currentShapeData, this.shapeBounds, this.shapeType, filteredShapes);\n  }\n\n  /**\n   * update shape position\n   * @param x\n   * @param y\n   */\n  updatePosition(x, y) {\n    this.position = new Point(x, y);\n    this._updatePosition();\n  }\n\n  /**\n   * destroy shape\n   */\n  destroy() {\n    if (this.destroyed) {\n      return;\n    }\n    this.app.view.removeEventListener('mousedown', this.processGlobalMouseDown, false);\n    document.removeEventListener('keydown', this._shapeKeyDown, false);\n    // remove all listeners\n    Object.values(EventAction).forEach(action => {\n      this.off(action);\n    });\n    // remove controls\n    this._controls = [];\n    if (this._rotateControl) {\n      this._rotateControl.destroy();\n    }\n    // destroy containers\n    [this.controlsContainer, this.shapeContainer].forEach(container => {\n      this.container.removeChild(container);\n      container.destroy({\n        children: true,\n        texture: true,\n        baseTexture: true\n      });\n    });\n    // remove dom if possible\n    if (this.labelDom) {\n      this.labelDom.remove();\n      this.labelDom = undefined;\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * remove controls\n   */\n  removeControls() {\n    // remove control points\n    this._controls.forEach(c => {\n      c.remove();\n    });\n    this._controls = [];\n    // remove rotate control\n    if (this._rotateControl) {\n      this._rotateControl.remove();\n    }\n  }\n\n  /**\n   * emit event\n   * @protected\n   * @param eventName\n   */\n  _emit(eventName, ...args) {\n    this._eventEmitter.emit(eventName, this, ...args);\n  }\n\n  /**\n   * add listener\n   * @param eventName\n   * @param callback\n   */\n  on(eventName, callback) {\n    this._eventEmitter.on(eventName, callback);\n    return this;\n  }\n\n  /**\n   * remove listener\n   * @param eventName\n   * @param callback\n   */\n  off(eventName, callback) {\n    if (callback) {\n      this._eventEmitter.removeListener(eventName, callback);\n    } else {\n      this._eventEmitter.removeAllListeners(eventName);\n    }\n    return this;\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @protected\n   * @param x screen position x\n   * @param y screen position y\n   */\n  _mapScreenToStagePosition(x, y) {\n    const point = new Point();\n    this.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @protected\n   * @param point\n   */\n  _mapStageToLocalPosition(point) {\n    return this.container.toLocal(point);\n  }\n\n  /**\n   * update shape container order\n   */\n  _updateShapeContainerOrder() {\n    if (this.shapeType === ShapeType.DOT || this.shapeType === ShapeType.LINE) {\n      this.shapeContainer.zIndex = this.selected ? 9999 : this.order;\n    } else {\n      this.shapeContainer.zIndex = this.order;\n    }\n  }\n\n  /**\n   * create label container\n   * @protected\n   */\n  _createLabelContainer() {\n    this.labelContainer = new Container();\n    this.labelContainer.interactive = false;\n    this.shapeContainer.addChild(this.labelContainer);\n  }\n\n  /**\n   * create vertexes container\n   * @protected\n   */\n  _createVertexesContainer() {\n    this.vertexesContainer = new Container();\n    this.vertexesContainer.interactive = false;\n    this.shapeContainer.addChild(this.vertexesContainer);\n  }\n}","map":{"version":3,"names":["v4","uuidv4","Container","Graphics","Point","Text","utils","PIXIUtils","Layer","ExtendedGraphics","ShapeGraphics","ShapeType","findIntersections","Cursor","computeRotatedPosition","EventAction","BorderStyle","Shape","globalSnappingPoint","container","snappingPoint","app","stage","area","NaN","pivot","p","color","_color","shouldUpdate","drawShape","borderColor","_borderColor","displayBorderColor","selected","selectedColor","hovered","hoveredColor","alpha","_alpha","newAlpha","label","_label","drawShapeLabel","borderStyle","_borderStyle","showVertex","_showVertex","showVertexOrder","_showVertexOrder","order","_order","_updateShapeContainerOrder","labelDom","zIndex","visible","_visible","instance","interactive","shapeContainer","controlsContainer","_rotateControl","control","_interactive","_controls","forEach","c","editable","_editable","rotatable","_rotatable","finished","_finished","_selected","_hovered","_emit","POINTER_OVER","POINTER_OUT","cursor","MOVE","POINTER","DEFAULT","scale","_scale","rotation","_rotation","_updatePosition","constructor","shapeType","uid","originColors","labelContainer","vertexesContainer","destroyed","resizing","dragging","_eventEmitter","EventEmitter","_controlLine","SOLID","_snappingPoint","_ctrlKey","_dragPoint","_dragPosistion","_dragged","_rightClicked","_rightDragged","_lastPivot","processPointerDown","event","frontTargets","data","button","_continuePropogating","stopPropagation","getLocalPosition","x","y","position","SELECTED","processPointerUp","_changed","processPointerMove","buttons","snap","originalEvent","ctrlKey","point","originX","originY","DOT","_dragging","deltaX","deltaY","processGlobalMouseDown","success","addSnappingPointToShape","_shapeKeyDown","e","shiftKey","_e$key","key","toLowerCase","preventDefault","Math","PI","on","view","addEventListener","document","addChild","undefined","resize","clone","rotatedPivot","set","funcName","interaction","renderer","plugins","hit","hitTest","global","includes","shape","deleteSelectedPoints","snapToPoint","tolerance","borderOffset","vertexOffset","POLYGON","LINE","RECTANGLE","text","getLabelPosition","globalPosition","toGlobal","globalPivot","setPosition","_createLabelContainer","removeChildren","fontSize","lineHeight","fill","width","height","getBounds","bounds","beginFill","drawRect","endFill","_finish","otherShapeData","FINISHED","_remove","REMOVED","destroy","CHANGED","getData","_resizing","getGlobalPosition","left","right","top","bottom","shapeBounds","center","shapes","currentShapeData","getAreaAsGeoJSON","filteredShapes","filter","s","updatePosition","removeEventListener","Object","values","action","off","removeChild","children","texture","baseTexture","remove","removeControls","eventName","args","emit","callback","removeListener","removeAllListeners","_mapScreenToStagePosition","mapPositionToPoint","_mapStageToLocalPosition","toLocal","_createVertexesContainer"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/Shape.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { Application, Container, Graphics, InteractionEvent, Point, Text, utils as PIXIUtils } from 'pixi.js';\nimport { Geom } from 'polygon-clipping';\nimport Layer from './Layer';\nimport ExtendedGraphics from './ExtendedGraphics';\nimport ShapeGraphics from './ShapeGraphics';\nimport { ShapeType, ShapeData } from './types';\nimport Control from './controls/Control';\nimport ControlRotation from './controls/ControlRotation';\nimport Label from './label/Label';\nimport { findIntersections } from './utils';\nimport Cursor from '../Cursor';\nimport { computeRotatedPosition } from '../../../utils/math';\n\nexport enum EventAction {\n  SELECTED = 'selected',\n  VERTEX_SELECTED = 'vertex-selected',\n  FINISHED = 'finished',\n  REMOVED = 'removed',\n  CHANGED = 'changed',\n  POINTER_OVER = 'pointer-over',\n  POINTER_OUT = 'pointer-out',\n}\n\nexport enum BorderStyle {\n  SOLID = 'solid',\n  DASHED = 'dashed',\n}\n\nexport interface ShapeOptions {\n  app: Application;\n  container?: Container;\n  scale?: number;\n  color?: number; // default for vertexes, edges & fill\n  alpha?: number;\n  label?: string;\n  showVertex?: boolean;\n  showVertexOrder?: boolean;\n  rotatable?: boolean;\n  labelDom?: Label;\n}\n\n/**\n * Shape base\n * @class\n */\nexport default abstract class Shape<T> {\n  /**\n   * shape type\n   */\n  abstract shapeType: ShapeType;\n\n  /**\n   * unique id\n   * @member {string}\n   */\n  uid = uuidv4();\n\n  /**\n   * PIXI instance\n   * @member {ShapeGraphics}\n   */\n  instance = new ShapeGraphics<T>(this);\n\n  /**\n   * PIXI application\n   * @member {PIXI.Application}\n   */\n  app: Application;\n\n  /**\n   * PIXI container\n   * @member {PIXI.Container | Layer}\n   */\n  container: Container | Layer;\n\n  /**\n   * origin colors from shape options\n   */\n  originColors: {\n    color: number;\n    borderColor: number;\n  } = {\n    color: 0,\n    borderColor: 0,\n  };\n\n  /**\n   * selected border color\n   * @member {number}\n   */\n  selectedColor = 0xFFFF00;\n\n  /**\n   * hovered border color\n   * @member {number}\n   */\n  hoveredColor = 0xCCCCCC;\n\n  /**\n   * shape container\n   * @member {PIXI.Container}\n   */\n  shapeContainer = new Container();\n\n  /**\n   * controls container\n   * @member {PIXI.Container}\n   */\n  controlsContainer = new Container();\n\n  /**\n   * label container\n   * @member {PIXI.Container}\n   */\n  labelContainer?: Container;\n\n  /**\n   * label dom\n   * @member {Label}\n   */\n  labelDom?: Label;\n\n  /**\n   * container to show shape vertexes\n   * @member {PIXI.Container}\n   */\n  vertexesContainer?: Container;\n\n  /**\n   * is shape destroyed\n   * @member {boolean}\n   */\n  destroyed = false;\n\n  /**\n   * is shape resizing\n   * @member {boolean}\n   */\n  resizing = false;\n\n  /**\n   * is shape dragging\n   * @member {boolean}\n   */\n  dragging = false;\n\n  /**\n   * events emitter\n   * @private {PIXI.utils.EventEmitter}\n   */\n  private _eventEmitter = new PIXIUtils.EventEmitter();\n\n  /**\n   * controls\n   * @protected {Control[]}\n   */\n  protected _controls: Control[] = [];\n\n  /**\n   * control for shape rotation\n   * @protected {ControlRotation}\n   */\n  protected _rotateControl?: ControlRotation;\n\n  /**\n   * instance to draw shape boundary control\n   * @protected {ExtendedGraphics}\n   */\n  protected _controlLine = new ExtendedGraphics();\n\n  /**\n   * color\n   * @protected {number}\n   */\n  protected _color = 0;\n\n  /**\n   * border color\n   * @protected {number}\n   */\n  protected _borderColor = 0;\n\n  /**\n   * shape alpha\n   * @protected {number}\n   */\n  protected _alpha = 0.5;\n\n  /**\n   * shape label\n   * @protected {string}\n   */\n  protected _label = '';\n\n  /**\n   * shape border style\n   * @protected {BorderStyle}\n   */\n  protected _borderStyle = BorderStyle.SOLID;\n\n  /**\n   * show shape vertex\n   * @protected {boolean}\n   */\n  protected _showVertex = false;\n\n  /**\n   * show shape vertex order\n   * @protected {boolean}\n   */\n  protected _showVertexOrder = false;\n\n  /**\n   * shape z-index\n   * @protected {number}\n   */\n  protected _order = 0;\n\n  /**\n   * is shape visible\n   * @protected {boolean}\n   */\n  protected _visible = true;\n\n  /**\n   * is shape interactive\n   * @protected {boolean}\n   */\n  protected _interactive = true;\n\n  /**\n   * is shape editable\n   * @protected {boolean}\n   */\n  protected _editable = true;\n\n  /**\n   * is shape rotatable\n   * @protected {boolean}\n   */\n  protected _rotatable = false;\n\n  /**\n   * is shape drawing finished\n   * @protected {boolean}\n   */\n  protected _finished = true;\n\n  /**\n   * is shape selected\n   * @protected {boolean}\n   */\n  protected _selected = false;\n\n  /**\n   * is shape hovered\n   * @protected {boolean}\n   */\n  protected _hovered = false;\n\n  /**\n   * shape scale factor\n   * @protected {boolean}\n   */\n  protected _scale = 1;\n\n  /**\n   * shape rotation\n   * @protected {number}\n   */\n  protected _rotation = 0;\n\n  /**\n   * point when snapping\n   * @protected {Point}\n   */\n  protected _snappingPoint: Point | null = null;\n\n  /**\n   * is ctrl key down\n   * @protected {boolean}\n   */\n  protected _ctrlKey = false;\n\n  /**\n   * mouse position when click to drag\n   * @private {Point}\n   */\n  private _dragPoint: Point | null = null;\n\n  /**\n   * instance position when click to drag\n   * @private {Point}\n   */\n  private _dragPosistion: Point | null = null;\n\n  /**\n   * is instance been dragged\n   * @private {boolean}\n   */\n  private _dragged = false;\n\n  /**\n   * is right click down\n   * @private {boolean}\n   */\n  private _rightClicked = false;\n\n  /**\n   * is right dragged\n   * @private {boolean}\n   */\n  private _rightDragged = false;\n\n  /**\n   * last pivot\n   * @private {Point|undefined}\n   */\n  private _lastPivot: Point | undefined;\n\n  /**\n   * global snapping point (not on self shape)\n   * @getter\n   */\n  get globalSnappingPoint() {\n    return this.container instanceof Layer ? this.container.snappingPoint : (this.app.stage as Layer).snappingPoint;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get area() {\n    return NaN;\n  }\n\n  // TODO: make pivot as abstract getter & setter\n  // eslint-disable-next-line class-methods-use-this\n  get pivot() {\n    return new Point(0, 0);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  set pivot(p: Point) {}\n\n  /**\n   * get position\n   * @getter\n   */\n  abstract get position(): Point;\n\n  /**\n   * set position\n   * @setter\n   */\n  abstract set position(point: Point);\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  abstract get shapeBounds(): { left: number, top: number, right: number, bottom: number };\n\n  /**\n   * get color\n   * @getter\n   */\n  get color() {\n    return this._color;\n  }\n\n  /**\n   * set color\n   * @setter\n   */\n  set color(color: number) {\n    const shouldUpdate = this._color !== color;\n    this._color = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get border color\n   * @getter\n   */\n  get borderColor() {\n    return this._borderColor;\n  }\n\n  /**\n   * set border color\n   * @setter\n   */\n  set borderColor(color: number) {\n    const shouldUpdate = this._borderColor !== color;\n    this._borderColor = color;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get display border color\n   * @getter\n   */\n  get displayBorderColor() {\n    if (this.selected) {\n      return this.selectedColor;\n    }\n    if (this.hovered) {\n      return this.hoveredColor;\n    }\n    return this.borderColor;\n  }\n\n  /**\n   * get alpha\n   * @getter\n   */\n  get alpha() {\n    return this._alpha;\n  }\n\n  /**\n   * set alpha\n   * @setter\n   */\n  set alpha(alpha: number) {\n    const newAlpha = alpha > 0 ? alpha : 0.005; // for transparent shape, interactions can't be fired\n    const shouldUpdate = this._alpha !== newAlpha;\n    this._alpha = newAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get label\n   * @getter\n   */\n  get label() {\n    return this._label;\n  }\n\n  /**\n   * set label\n   * @setter\n   */\n  set label(label: string) {\n    this._label = label;\n    this.drawShapeLabel();\n  }\n\n  /**\n   * get border style\n   * @getter\n   */\n  get borderStyle() {\n    return this._borderStyle;\n  }\n\n  /**\n   * set border style\n   * @setter\n   */\n  set borderStyle(borderStyle: BorderStyle) {\n    const shouldUpdate = this._borderStyle !== borderStyle;\n    this._borderStyle = borderStyle;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex\n   * @getter\n   */\n  get showVertex() {\n    return this._showVertex;\n  }\n\n  /**\n   * set show vertex\n   * @setter\n   */\n  set showVertex(showVertex: boolean) {\n    const shouldUpdate = this._showVertex !== showVertex;\n    this._showVertex = showVertex;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get show vertex order\n   * @getter\n   */\n  get showVertexOrder() {\n    return this._showVertexOrder;\n  }\n\n  /**\n   * set show vertex order\n   * @setter\n   */\n  set showVertexOrder(showVertexOrder: boolean) {\n    const shouldUpdate = this._showVertexOrder !== showVertexOrder;\n    this._showVertexOrder = showVertexOrder;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get order\n   * @getter\n   */\n  get order() {\n    return this._order;\n  }\n\n  /**\n   * set order\n   * @setter\n   */\n  set order(order: number) {\n    this._order = order;\n    this._updateShapeContainerOrder();\n    if (this.labelDom) {\n      this.labelDom.zIndex = order;\n    }\n  }\n\n  /**\n   * get visible\n   * @getter\n   */\n  get visible() {\n    return this._visible;\n  }\n\n  /**\n   * set visible\n   * @setter\n   */\n  set visible(visible: boolean) {\n    const shouldUpdate = this._visible !== visible;\n    this._visible = visible;\n    if (shouldUpdate) {\n      this.instance.interactive = visible ? this.interactive : false;\n      this.shapeContainer.visible = visible;\n      this.controlsContainer.visible = visible;\n      if (this._rotateControl) {\n        this._rotateControl.control.visible = visible;\n      }\n      if (this.labelDom) {\n        this.labelDom.visible = visible;\n      }\n    }\n  }\n\n  /**\n   * get interactive\n   * @getter\n   */\n  get interactive() {\n    return this._interactive;\n  }\n\n  /**\n   * set interactive\n   * @setter\n   */\n  set interactive(interactive: boolean) {\n    this._interactive = interactive;\n    if (this.instance) {\n      this.instance.interactive = interactive;\n    }\n    this._controls.forEach((c) => {\n      c.control.interactive = interactive;\n    });\n    if (!interactive) {\n      this.selected = false;\n      this.hovered = false;\n    }\n  }\n\n  /**\n   * get editable\n   * @getter\n   */\n  get editable() {\n    return this._editable;\n  }\n\n  /**\n   * set editable\n   * @setter\n   */\n  set editable(editable: boolean) {\n    this._editable = editable;\n    this.drawShape();\n  }\n\n  /**\n   * get rotatable\n   * @getter\n   */\n  get rotatable() {\n    return this._rotatable;\n  }\n\n  /**\n   * set rotatable\n   * @setter\n   */\n  set rotatable(rotatable: boolean) {\n    this._rotatable = rotatable;\n  }\n\n  /**\n   * get shape finished\n   * @getter\n   */\n  get finished() {\n    return this._finished;\n  }\n\n  /**\n   * get selected\n   * @getter\n   */\n  get selected() {\n    return this._selected;\n  }\n\n  /**\n   * set selected\n   * @setter\n   */\n  set selected(selected: boolean) {\n    const shouldUpdate = this._selected !== selected;\n    this._selected = selected;\n    this._updateShapeContainerOrder();\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get hovered\n   * @getter\n   */\n  get hovered() {\n    return this._hovered;\n  }\n\n  /**\n   * set hovered\n   * @setter\n   */\n  set hovered(hovered: boolean) {\n    const shouldUpdate = this._hovered !== hovered;\n    this._hovered = hovered;\n    if (shouldUpdate) {\n      this.drawShape();\n      this._emit(hovered ? EventAction.POINTER_OVER : EventAction.POINTER_OUT);\n    }\n    // should update stage cursor because instance cursor not show when covered by others\n    if (hovered) {\n      this.instance.cursor = this.editable ? Cursor.MOVE : Cursor.POINTER;\n    } else {\n      this.instance.cursor = Cursor.DEFAULT;\n    }\n  }\n\n  /**\n   * get scale\n   * @getter\n   */\n  get scale() {\n    return this._scale;\n  }\n\n  /**\n   * set scale\n   * @setter\n   */\n  set scale(scale: number) {\n    const shouldUpdate = this._scale !== scale;\n    this._scale = scale;\n    this._controls.forEach((c) => {\n      // eslint-disable-next-line no-param-reassign\n      c.scale = scale;\n    });\n    if (this._rotateControl) {\n      this._rotateControl.scale = scale;\n    }\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get rotation\n   * @getter\n   */\n  get rotation() {\n    return this._rotation;\n  }\n\n  /**\n   * set rotation\n   * @setter\n   */\n  set rotation(rotation: number) {\n    this._rotation = rotation;\n    this._updatePosition();\n    this.drawShape();\n  }\n\n  constructor({\n    app,\n    container,\n    scale,\n    color,\n    alpha,\n    label,\n    showVertex,\n    showVertexOrder,\n    rotatable = false,\n    labelDom,\n  }: ShapeOptions) {\n    this.instance.on('pointerdown', this.processPointerDown);\n    this.instance.on('pointerup', this.processPointerUp);\n    this.instance.on('pointerupoutside', this.processPointerUp);\n    this.instance.on('pointermove', this.processPointerMove);\n\n    this.app = app;\n    this.app.view.addEventListener('mousedown', this.processGlobalMouseDown, false);\n    document.addEventListener('keydown', this._shapeKeyDown, false);\n\n    this.container = container || app.stage;\n    this.instance.interactive = this.interactive;\n    this.controlsContainer.zIndex = 9999;\n    this.shapeContainer.addChild(this.instance);\n    this.container.addChild(this.shapeContainer);\n    this.container.addChild(this.controlsContainer);\n    this._controlLine.interactive = false;\n    this.controlsContainer.addChild(this._controlLine);\n\n    this._scale = scale || app.stage.scale.x;\n    if (color !== undefined) {\n      this._color = color;\n      this._borderColor = color;\n    }\n    this.originColors = {\n      color: this._color,\n      borderColor: this._borderColor,\n    };\n    if (alpha !== undefined) {\n      this._alpha = alpha > 0 ? alpha : 0.005;\n    }\n    if (label !== undefined) {\n      this._label = label;\n    }\n    if (showVertex !== undefined) {\n      this._showVertex = showVertex;\n    }\n    if (showVertexOrder !== undefined) {\n      this._showVertexOrder = showVertexOrder;\n    }\n    this._rotatable = rotatable;\n    this.labelDom = labelDom;\n  }\n\n  /**\n   * update container position\n   * @protected\n   */\n  protected _updatePosition(resize = false) {\n    const pivot = this.pivot.clone();\n    if (resize && this._lastPivot) {\n      // resize change pivot\n      const rotatedPivot = computeRotatedPosition(this._lastPivot, pivot, this.rotation);\n      pivot.x = rotatedPivot.x;\n      pivot.y = rotatedPivot.y;\n      this.pivot = pivot;\n    }\n    this.shapeContainer.pivot.set(pivot.x, pivot.y);\n    this.shapeContainer.position.set(pivot.x, pivot.y);\n    this.shapeContainer.rotation = this.rotation;\n    this._lastPivot = pivot.clone();\n\n    this.controlsContainer.pivot.set(pivot.x, pivot.y);\n    this.controlsContainer.position.set(pivot.x, pivot.y);\n    this.controlsContainer.rotation = this.rotation;\n  };\n\n  /**\n   * propogating event to back shapes\n   * @param event\n   * @param frontTargets\n   * @param funcName\n   */\n  private _continuePropogating(\n    event: InteractionEvent,\n    frontTargets: Graphics[],\n    funcName: 'processPointerDown' | 'processPointerUp',\n  ) {\n    this.instance.interactive = false;\n    const { interaction } = this.app.renderer.plugins;\n    const hit = interaction.hitTest(event.data.global);\n    if (hit && hit instanceof ShapeGraphics && !frontTargets.includes(this.instance)) {\n      hit.shape[funcName](event, [...frontTargets, this.instance]);\n    }\n    this.instance.interactive = true;\n  }\n\n  /**\n   * process pointerdown\n   * @param event\n   * @param frontTargets\n   */\n  processPointerDown = (event: InteractionEvent, frontTargets: Graphics[] = []) => {\n    if (event.data.button === 2) {\n      this._rightClicked = true;\n      this._continuePropogating(event, frontTargets, 'processPointerDown');\n      return;\n    }\n\n    if (this.hovered) {\n      event.stopPropagation();\n      const p = event.data.getLocalPosition(this.container);\n      this._dragPoint = new Point(p.x, p.y);\n      this._dragPosistion = this.position;\n      this._dragged = false;\n      this.selected = true;\n      this._emit(EventAction.SELECTED, p);\n      // disable controls interactivity when first pointer down to selected (avoid bugs when start dragging on controls)\n      this._controls.forEach((c) => {\n        c.control.interactive = false;\n      });\n    }\n\n    if (!this._snappingPoint) { // if upper shapes has snapping point, do not propogating\n      this._continuePropogating(event, frontTargets, 'processPointerDown');\n    }\n  };\n\n  /**\n   * process pointerup\n   * @param event\n   * @param frontTargets\n   */\n  processPointerUp = (event: InteractionEvent, frontTargets: Graphics[] = []) => {\n    if (event.data.button === 2 && this._rightClicked && !this._rightDragged) {\n      if (this.hovered && !this.selected) {\n        const p = event.data.getLocalPosition(this.container);\n        this.selected = true;\n        this._emit(EventAction.SELECTED, p);\n      }\n    }\n\n    // re-active controls when pointer up\n    this._controls.forEach((c) => {\n      c.control.interactive = true;\n    });\n    this.dragging = false;\n    this._dragPoint = null;\n    this._dragPosistion = null;\n    if (this._dragged) {\n      this._changed();\n      this._dragged = false;\n    }\n    this._rightClicked = false;\n    this._rightDragged = false;\n    this._continuePropogating(event, frontTargets, 'processPointerUp');\n  };\n\n  /**\n   * process pointermove\n   * @param event\n   */\n  processPointerMove = (event: InteractionEvent) => {\n    if (event.data.buttons === 2 && this._rightClicked) {\n      this._rightDragged = true;\n      return;\n    }\n    if (this.editable && this.selected && this.snap(event)) {\n      // snapping\n      this.instance.cursor = Cursor.DEFAULT;\n    } else if (this.editable && this.selected && this._dragPoint && this._dragPosistion) {\n      // dragging\n      this._dragged = true;\n      this._ctrlKey = event.data.originalEvent.ctrlKey;\n      const point = event.data.getLocalPosition(this.container);\n      const originX = this.position.x;\n      const originY = this.position.y;\n      const position = new Point(\n        this._dragPosistion.x + (point.x - this._dragPoint.x),\n        this._dragPosistion.y + (point.y - this._dragPoint.y),\n      );\n      // prefer to use global snapping point if moving a dot\n      this.position = (this.shapeType === ShapeType.DOT && this.globalSnappingPoint) ? this.globalSnappingPoint : position;\n      this._updatePosition();\n      this._dragging({ deltaX: this.position.x - originX, deltaY: this.position.y - originY });\n    }\n  };\n\n  /**\n   * process app mouse down\n   */\n  processGlobalMouseDown = () => {\n    if (this._snappingPoint) {\n      const success = this.addSnappingPointToShape();\n      if (success) {\n        // set selected\n        this.selected = true;\n        this._emit(EventAction.SELECTED);\n        // ignore drag start\n        this._dragPoint = null;\n        this._dragPosistion = null;\n      }\n    }\n  };\n\n  /**\n   * actual draw the shape on canvas\n   */\n  abstract drawShape(): void;\n\n  /**\n   * start shape create\n   * @param point create start point\n   * @param options options used for creation\n   */\n  abstract create(point?: Point, options?: any): void;\n\n  /**\n   * get label position of the shape\n   */\n  abstract getLabelPosition(): Point;\n\n  /**\n   * get shape data\n   */\n  abstract getData(): T;\n\n  /**\n   * get shape Geo JSON (multi polygon)\n   */\n  abstract getAreaAsGeoJSON(): Geom;\n\n  /**\n   * delete selected points in shape, default reture false and can be overwritten in sub class\n   */\n  deleteSelectedPoints() {\n    return false; // false means no point deleted\n  }\n\n  /**\n   * snap to shape vertexes or edges\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point: Point, tolerance?: number): Point | null {\n    return null;\n  }\n\n  /**\n   * snap to shape edges\n   * @param point\n   */\n  snap(event: InteractionEvent) {\n    this._snappingPoint = null;\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    return false;\n  }\n\n  /**\n   * draw shape label\n   */\n  drawShapeLabel() {\n    const borderOffset = this.shapeType !== ShapeType.DOT ? 1 / 2 : 0;\n    const vertexOffset = (\n      this.shapeType === ShapeType.POLYGON ||\n      this.shapeType === ShapeType.LINE ||\n      this.shapeType === ShapeType.RECTANGLE\n    ) && this.showVertex ? 4 : 0;\n\n    if (this.labelDom) {\n      // use dom to render\n      if (this.label) {\n        this.labelDom.text = this.label;\n        this.labelDom.zIndex = this.order;\n\n        const position = this.getLabelPosition();\n        const globalPosition = this.container.toGlobal({ x: position.x, y: position.y - (borderOffset + vertexOffset) / this.scale });\n        const globalPivot = this.container.toGlobal(this.pivot);\n        this.labelDom.setPosition(globalPosition, globalPivot, this.rotation);\n      }\n    } else if (this.label) {\n      if (!this.labelContainer) {\n        this._createLabelContainer();\n      } else {\n        this.labelContainer.removeChildren();\n      }\n\n      const { x, y } = this.getLabelPosition();\n      this.labelContainer!.position.x = x;\n      this.labelContainer!.position.y = y - (18 + borderOffset + vertexOffset) / this.scale;\n      this.labelContainer!.scale.set(1 / this.scale);\n\n      const text = new Text(` ${this.label} `, {\n        fontSize: 14,\n        lineHeight: 18,\n        fill: '#FFFFFF',\n      });\n\n      const { width, height } = text.getBounds();\n      const bounds = new Graphics();\n      bounds.beginFill(0, 0.6);\n      bounds.drawRect(0, 0, width, height);\n      bounds.endFill();\n      this.labelContainer!.addChild(bounds);\n      this.labelContainer!.addChild(text);\n    }\n  }\n\n  /**\n   * finish shape create\n   * @param otherShapeData\n   * @protected\n   */\n  protected _finish(otherShapeData?: ShapeData[]) {\n    if (!this.destroyed) {\n      this._finished = true;\n      this.drawShape();\n      this._emit(EventAction.FINISHED, otherShapeData);\n    }\n  }\n\n  /**\n   * remove shape from canvas\n   * @protected\n   */\n  protected _remove() {\n    this._emit(EventAction.REMOVED);\n    this.destroy();\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  protected _changed() {\n    this._emit(EventAction.CHANGED, this.getData());\n  }\n\n  /**\n   * when shape is been dragging\n   * @param data\n   * @protected\n   */\n  protected _dragging(data?: { deltaX: number; deltaY: number }) {\n    this.dragging = true;\n  }\n\n  /**\n   * when shape is reszing\n   * @param data\n   * @protected\n   */\n  protected _resizing(data?: { deltaX: number; deltaY: number }) {\n    this.resizing = true;\n  }\n\n  /**\n   * get global position\n   * @returns\n   */\n  getGlobalPosition() {\n    const { left, right, top, bottom } = this.shapeBounds;\n    const center = new Point(left + (right - left) / 2, top + (bottom - top) / 2);\n    const { x, y } = this.container.toGlobal(center);\n    return { x, y };\n  }\n\n  /**\n   * find intersections\n   * @param shapes\n   */\n  findIntersections(shapes: Shape<ShapeData>[]) {\n    const currentShapeData = this.getAreaAsGeoJSON();\n    const filteredShapes = shapes.filter((s) => s.uid !== this.uid);\n    return findIntersections(currentShapeData, this.shapeBounds, this.shapeType, filteredShapes);\n  }\n\n  /**\n   * update shape position\n   * @param x\n   * @param y\n   */\n  updatePosition(x: number, y: number) {\n    this.position = new Point(x, y);\n    this._updatePosition();\n  }\n\n  /**\n   * destroy shape\n   */\n  destroy() {\n    if (this.destroyed) {\n      return;\n    }\n    this.app.view.removeEventListener('mousedown', this.processGlobalMouseDown, false);\n    document.removeEventListener('keydown', this._shapeKeyDown, false);\n    // remove all listeners\n    Object.values(EventAction).forEach((action) => {\n      this.off(action);\n    });\n    // remove controls\n    this._controls = [];\n    if (this._rotateControl) {\n      this._rotateControl.destroy();\n    }\n    // destroy containers\n    [\n      this.controlsContainer,\n      this.shapeContainer,\n    ]\n      .forEach((container) => {\n        this.container.removeChild(container);\n        container.destroy({\n          children: true,\n          texture: true,\n          baseTexture: true,\n        });\n      });\n    // remove dom if possible\n    if (this.labelDom) {\n      this.labelDom.remove();\n      this.labelDom = undefined;\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * remove controls\n   */\n  removeControls() {\n    // remove control points\n    this._controls.forEach((c) => {\n      c.remove();\n    });\n    this._controls = [];\n    // remove rotate control\n    if (this._rotateControl) {\n      this._rotateControl.remove();\n    }\n  }\n\n  /**\n   * emit event\n   * @protected\n   * @param eventName\n   */\n  protected _emit(eventName: string, ...args: any[]) {\n    this._eventEmitter.emit(eventName, this, ...args);\n  }\n\n  /**\n   * add listener\n   * @param eventName\n   * @param callback\n   */\n  on(eventName: string, callback: (shape: Shape<T>, ...args: any[]) => void) {\n    this._eventEmitter.on(eventName, callback);\n    return this;\n  }\n\n  /**\n   * remove listener\n   * @param eventName\n   * @param callback\n   */\n  off(eventName: string, callback?: (shape: Shape<T>, ...args: any[]) => void) {\n    if (callback) {\n      this._eventEmitter.removeListener(eventName, callback);\n    } else {\n      this._eventEmitter.removeAllListeners(eventName);\n    }\n    return this;\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @protected\n   * @param x screen position x\n   * @param y screen position y\n   */\n  protected _mapScreenToStagePosition(x: number, y: number) {\n    const point = new Point();\n    this.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @protected\n   * @param point\n   */\n  protected _mapStageToLocalPosition(point: Point) {\n    return this.container.toLocal(point);\n  }\n\n  /**\n   * update shape container order\n   */\n  private _updateShapeContainerOrder() {\n    if (this.shapeType === ShapeType.DOT\n      || this.shapeType === ShapeType.LINE) {\n      this.shapeContainer.zIndex = this.selected ? 9999 : this.order;\n    } else {\n      this.shapeContainer.zIndex = this.order;\n    }\n  }\n\n  /**\n   * create label container\n   * @protected\n   */\n  protected _createLabelContainer() {\n    this.labelContainer = new Container();\n    this.labelContainer.interactive = false;\n    this.shapeContainer.addChild(this.labelContainer);\n  }\n\n  /**\n   * create vertexes container\n   * @protected\n   */\n  protected _createVertexesContainer() {\n    this.vertexesContainer = new Container();\n    this.vertexesContainer.interactive = false;\n    this.shapeContainer.addChild(this.vertexesContainer);\n  }\n\n  /**\n   * key down handler\n   * @protected\n   * @param e\n   */\n  protected _shapeKeyDown = (e: KeyboardEvent) => {\n    if (this.finished && this.selected && this.editable && e.shiftKey) {\n      let deltaX = 0;\n      let deltaY = 0;\n      let rotation = 0;\n      switch (e.key?.toLowerCase()) {\n        case 'w':\n          deltaY = -1;\n          break;\n        case 'a':\n          deltaX = -1;\n          break;\n        case 's':\n          deltaY = 1;\n          break;\n        case 'd':\n          deltaX = 1;\n          break;\n        case 'q':\n          rotation = -1;\n          break;\n        case 'e':\n          rotation = 1;\n          break;\n        default:\n          break;\n      }\n      if (deltaX !== 0 || deltaY !== 0) {\n        e.preventDefault();\n        this.position = new Point(\n          this.position.x + deltaX,\n          this.position.y + deltaY,\n        );\n        this._updatePosition();\n        this._changed();\n      }\n\n      if (rotation !== 0 && this.rotatable) {\n        e.preventDefault();\n        this.rotation += rotation * (Math.PI / 180);\n        this._changed();\n      }\n    }\n  };\n}\n"],"mappings":"AAAA,SAASA,EAAE,IAAIC,MAAM,QAAQ,MAAM;AACnC,SAAsBC,SAAS,EAAEC,QAAQ,EAAoBC,KAAK,EAAEC,IAAI,EAAEC,KAAK,IAAIC,SAAS,QAAQ,SAAS;AAE7G,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,SAASC,SAAS,QAAmB,SAAS;AAI9C,SAASC,iBAAiB,QAAQ,SAAS;AAC3C,OAAOC,MAAM,MAAM,WAAW;AAC9B,SAASC,sBAAsB,QAAQ,qBAAqB;AAE5D,WAAYC,WAAW,0BAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAA,OAAXA,WAAW;AAAA;AAUvB,WAAYC,WAAW,0BAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAA,OAAXA,WAAW;AAAA;AAkBvB;AACA;AACA;AACA;AACA,eAAe,MAAeC,KAAK,CAAI;EAmRrC;AACF;AACA;AACA;EACE,IAAIC,mBAAmBA,CAAA,EAAG;IACxB,OAAO,IAAI,CAACC,SAAS,YAAYX,KAAK,GAAG,IAAI,CAACW,SAAS,CAACC,aAAa,GAAI,IAAI,CAACC,GAAG,CAACC,KAAK,CAAWF,aAAa;EACjH;;EAEA;EACA,IAAIG,IAAIA,CAAA,EAAG;IACT,OAAOC,GAAG;EACZ;;EAEA;EACA;EACA,IAAIC,KAAKA,CAAA,EAAG;IACV,OAAO,IAAIrB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EACxB;;EAEA;EACA,IAAIqB,KAAKA,CAACC,CAAQ,EAAE,CAAC;;EAErB;AACF;AACA;AACA;;EAGE;AACF;AACA;AACA;;EAGE;AACF;AACA;AACA;;EAGE;AACF;AACA;AACA;EACE,IAAIC,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACC,MAAM;EACpB;;EAEA;AACF;AACA;AACA;EACE,IAAID,KAAKA,CAACA,KAAa,EAAE;IACvB,MAAME,YAAY,GAAG,IAAI,CAACD,MAAM,KAAKD,KAAK;IAC1C,IAAI,CAACC,MAAM,GAAGD,KAAK;IACnB,IAAIE,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIC,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACC,YAAY;EAC1B;;EAEA;AACF;AACA;AACA;EACE,IAAID,WAAWA,CAACJ,KAAa,EAAE;IAC7B,MAAME,YAAY,GAAG,IAAI,CAACG,YAAY,KAAKL,KAAK;IAChD,IAAI,CAACK,YAAY,GAAGL,KAAK;IACzB,IAAIE,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIG,kBAAkBA,CAAA,EAAG;IACvB,IAAI,IAAI,CAACC,QAAQ,EAAE;MACjB,OAAO,IAAI,CAACC,aAAa;IAC3B;IACA,IAAI,IAAI,CAACC,OAAO,EAAE;MAChB,OAAO,IAAI,CAACC,YAAY;IAC1B;IACA,OAAO,IAAI,CAACN,WAAW;EACzB;;EAEA;AACF;AACA;AACA;EACE,IAAIO,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACC,MAAM;EACpB;;EAEA;AACF;AACA;AACA;EACE,IAAID,KAAKA,CAACA,KAAa,EAAE;IACvB,MAAME,QAAQ,GAAGF,KAAK,GAAG,CAAC,GAAGA,KAAK,GAAG,KAAK,CAAC,CAAC;IAC5C,MAAMT,YAAY,GAAG,IAAI,CAACU,MAAM,KAAKC,QAAQ;IAC7C,IAAI,CAACD,MAAM,GAAGC,QAAQ;IACtB,IAAIX,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIW,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACC,MAAM;EACpB;;EAEA;AACF;AACA;AACA;EACE,IAAID,KAAKA,CAACA,KAAa,EAAE;IACvB,IAAI,CAACC,MAAM,GAAGD,KAAK;IACnB,IAAI,CAACE,cAAc,CAAC,CAAC;EACvB;;EAEA;AACF;AACA;AACA;EACE,IAAIC,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACC,YAAY;EAC1B;;EAEA;AACF;AACA;AACA;EACE,IAAID,WAAWA,CAACA,WAAwB,EAAE;IACxC,MAAMf,YAAY,GAAG,IAAI,CAACgB,YAAY,KAAKD,WAAW;IACtD,IAAI,CAACC,YAAY,GAAGD,WAAW;IAC/B,IAAIf,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIgB,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACC,WAAW;EACzB;;EAEA;AACF;AACA;AACA;EACE,IAAID,UAAUA,CAACA,UAAmB,EAAE;IAClC,MAAMjB,YAAY,GAAG,IAAI,CAACkB,WAAW,KAAKD,UAAU;IACpD,IAAI,CAACC,WAAW,GAAGD,UAAU;IAC7B,IAAIjB,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIkB,eAAeA,CAAA,EAAG;IACpB,OAAO,IAAI,CAACC,gBAAgB;EAC9B;;EAEA;AACF;AACA;AACA;EACE,IAAID,eAAeA,CAACA,eAAwB,EAAE;IAC5C,MAAMnB,YAAY,GAAG,IAAI,CAACoB,gBAAgB,KAAKD,eAAe;IAC9D,IAAI,CAACC,gBAAgB,GAAGD,eAAe;IACvC,IAAInB,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIoB,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACC,MAAM;EACpB;;EAEA;AACF;AACA;AACA;EACE,IAAID,KAAKA,CAACA,KAAa,EAAE;IACvB,IAAI,CAACC,MAAM,GAAGD,KAAK;IACnB,IAAI,CAACE,0BAA0B,CAAC,CAAC;IACjC,IAAI,IAAI,CAACC,QAAQ,EAAE;MACjB,IAAI,CAACA,QAAQ,CAACC,MAAM,GAAGJ,KAAK;IAC9B;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIK,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,QAAQ;EACtB;;EAEA;AACF;AACA;AACA;EACE,IAAID,OAAOA,CAACA,OAAgB,EAAE;IAC5B,MAAM1B,YAAY,GAAG,IAAI,CAAC2B,QAAQ,KAAKD,OAAO;IAC9C,IAAI,CAACC,QAAQ,GAAGD,OAAO;IACvB,IAAI1B,YAAY,EAAE;MAChB,IAAI,CAAC4B,QAAQ,CAACC,WAAW,GAAGH,OAAO,GAAG,IAAI,CAACG,WAAW,GAAG,KAAK;MAC9D,IAAI,CAACC,cAAc,CAACJ,OAAO,GAAGA,OAAO;MACrC,IAAI,CAACK,iBAAiB,CAACL,OAAO,GAAGA,OAAO;MACxC,IAAI,IAAI,CAACM,cAAc,EAAE;QACvB,IAAI,CAACA,cAAc,CAACC,OAAO,CAACP,OAAO,GAAGA,OAAO;MAC/C;MACA,IAAI,IAAI,CAACF,QAAQ,EAAE;QACjB,IAAI,CAACA,QAAQ,CAACE,OAAO,GAAGA,OAAO;MACjC;IACF;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIG,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACK,YAAY;EAC1B;;EAEA;AACF;AACA;AACA;EACE,IAAIL,WAAWA,CAACA,WAAoB,EAAE;IACpC,IAAI,CAACK,YAAY,GAAGL,WAAW;IAC/B,IAAI,IAAI,CAACD,QAAQ,EAAE;MACjB,IAAI,CAACA,QAAQ,CAACC,WAAW,GAAGA,WAAW;IACzC;IACA,IAAI,CAACM,SAAS,CAACC,OAAO,CAAEC,CAAC,IAAK;MAC5BA,CAAC,CAACJ,OAAO,CAACJ,WAAW,GAAGA,WAAW;IACrC,CAAC,CAAC;IACF,IAAI,CAACA,WAAW,EAAE;MAChB,IAAI,CAACxB,QAAQ,GAAG,KAAK;MACrB,IAAI,CAACE,OAAO,GAAG,KAAK;IACtB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAI+B,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACC,SAAS;EACvB;;EAEA;AACF;AACA;AACA;EACE,IAAID,QAAQA,CAACA,QAAiB,EAAE;IAC9B,IAAI,CAACC,SAAS,GAAGD,QAAQ;IACzB,IAAI,CAACrC,SAAS,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;EACE,IAAIuC,SAASA,CAAA,EAAG;IACd,OAAO,IAAI,CAACC,UAAU;EACxB;;EAEA;AACF;AACA;AACA;EACE,IAAID,SAASA,CAACA,SAAkB,EAAE;IAChC,IAAI,CAACC,UAAU,GAAGD,SAAS;EAC7B;;EAEA;AACF;AACA;AACA;EACE,IAAIE,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACC,SAAS;EACvB;;EAEA;AACF;AACA;AACA;EACE,IAAItC,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACuC,SAAS;EACvB;;EAEA;AACF;AACA;AACA;EACE,IAAIvC,QAAQA,CAACA,QAAiB,EAAE;IAC9B,MAAML,YAAY,GAAG,IAAI,CAAC4C,SAAS,KAAKvC,QAAQ;IAChD,IAAI,CAACuC,SAAS,GAAGvC,QAAQ;IACzB,IAAI,CAACkB,0BAA0B,CAAC,CAAC;IACjC,IAAIvB,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIM,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACsC,QAAQ;EACtB;;EAEA;AACF;AACA;AACA;EACE,IAAItC,OAAOA,CAACA,OAAgB,EAAE;IAC5B,MAAMP,YAAY,GAAG,IAAI,CAAC6C,QAAQ,KAAKtC,OAAO;IAC9C,IAAI,CAACsC,QAAQ,GAAGtC,OAAO;IACvB,IAAIP,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;MAChB,IAAI,CAAC6C,KAAK,CAACvC,OAAO,GAAGrB,WAAW,CAAC6D,YAAY,GAAG7D,WAAW,CAAC8D,WAAW,CAAC;IAC1E;IACA;IACA,IAAIzC,OAAO,EAAE;MACX,IAAI,CAACqB,QAAQ,CAACqB,MAAM,GAAG,IAAI,CAACX,QAAQ,GAAGtD,MAAM,CAACkE,IAAI,GAAGlE,MAAM,CAACmE,OAAO;IACrE,CAAC,MAAM;MACL,IAAI,CAACvB,QAAQ,CAACqB,MAAM,GAAGjE,MAAM,CAACoE,OAAO;IACvC;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIC,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACC,MAAM;EACpB;;EAEA;AACF;AACA;AACA;EACE,IAAID,KAAKA,CAACA,KAAa,EAAE;IACvB,MAAMrD,YAAY,GAAG,IAAI,CAACsD,MAAM,KAAKD,KAAK;IAC1C,IAAI,CAACC,MAAM,GAAGD,KAAK;IACnB,IAAI,CAAClB,SAAS,CAACC,OAAO,CAAEC,CAAC,IAAK;MAC5B;MACAA,CAAC,CAACgB,KAAK,GAAGA,KAAK;IACjB,CAAC,CAAC;IACF,IAAI,IAAI,CAACrB,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAACqB,KAAK,GAAGA,KAAK;IACnC;IACA,IAAIrD,YAAY,EAAE;MAChB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIsD,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACC,SAAS;EACvB;;EAEA;AACF;AACA;AACA;EACE,IAAID,QAAQA,CAACA,QAAgB,EAAE;IAC7B,IAAI,CAACC,SAAS,GAAGD,QAAQ;IACzB,IAAI,CAACE,eAAe,CAAC,CAAC;IACtB,IAAI,CAACxD,SAAS,CAAC,CAAC;EAClB;EAEAyD,WAAWA,CAAC;IACVlE,GAAG;IACHF,SAAS;IACT+D,KAAK;IACLvD,KAAK;IACLW,KAAK;IACLG,KAAK;IACLK,UAAU;IACVE,eAAe;IACfqB,SAAS,GAAG,KAAK;IACjBhB;EACY,CAAC,EAAE;IA7qBjB;AACF;AACA;IAFE,KAGSmC,SAAS;IAElB;AACF;AACA;AACA;IAHE,KAIAC,GAAG,GAAGxF,MAAM,CAAC,CAAC;IAEd;AACF;AACA;AACA;IAHE,KAIAwD,QAAQ,GAAG,IAAI/C,aAAa,CAAI,IAAI,CAAC;IAErC;AACF;AACA;AACA;IAHE,KAIAW,GAAG;IAEH;AACF;AACA;AACA;IAHE,KAIAF,SAAS;IAET;AACF;AACA;IAFE,KAGAuE,YAAY,GAGR;MACF/D,KAAK,EAAE,CAAC;MACRI,WAAW,EAAE;IACf,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAI,aAAa,GAAG,QAAQ;IAExB;AACF;AACA;AACA;IAHE,KAIAE,YAAY,GAAG,QAAQ;IAEvB;AACF;AACA;AACA;IAHE,KAIAsB,cAAc,GAAG,IAAIzD,SAAS,CAAC,CAAC;IAEhC;AACF;AACA;AACA;IAHE,KAIA0D,iBAAiB,GAAG,IAAI1D,SAAS,CAAC,CAAC;IAEnC;AACF;AACA;AACA;IAHE,KAIAyF,cAAc;IAEd;AACF;AACA;AACA;IAHE,KAIAtC,QAAQ;IAER;AACF;AACA;AACA;IAHE,KAIAuC,iBAAiB;IAEjB;AACF;AACA;AACA;IAHE,KAIAC,SAAS,GAAG,KAAK;IAEjB;AACF;AACA;AACA;IAHE,KAIAC,QAAQ,GAAG,KAAK;IAEhB;AACF;AACA;AACA;IAHE,KAIAC,QAAQ,GAAG,KAAK;IAEhB;AACF;AACA;AACA;IAHE,KAIQC,aAAa,GAAG,IAAIzF,SAAS,CAAC0F,YAAY,CAAC,CAAC;IAEpD;AACF;AACA;AACA;IAHE,KAIUjC,SAAS,GAAc,EAAE;IAEnC;AACF;AACA;AACA;IAHE,KAIUH,cAAc;IAExB;AACF;AACA;AACA;IAHE,KAIUqC,YAAY,GAAG,IAAIzF,gBAAgB,CAAC,CAAC;IAE/C;AACF;AACA;AACA;IAHE,KAIUmB,MAAM,GAAG,CAAC;IAEpB;AACF;AACA;AACA;IAHE,KAIUI,YAAY,GAAG,CAAC;IAE1B;AACF;AACA;AACA;IAHE,KAIUO,MAAM,GAAG,GAAG;IAEtB;AACF;AACA;AACA;IAHE,KAIUG,MAAM,GAAG,EAAE;IAErB;AACF;AACA;AACA;IAHE,KAIUG,YAAY,GAAG7B,WAAW,CAACmF,KAAK;IAE1C;AACF;AACA;AACA;IAHE,KAIUpD,WAAW,GAAG,KAAK;IAE7B;AACF;AACA;AACA;IAHE,KAIUE,gBAAgB,GAAG,KAAK;IAElC;AACF;AACA;AACA;IAHE,KAIUE,MAAM,GAAG,CAAC;IAEpB;AACF;AACA;AACA;IAHE,KAIUK,QAAQ,GAAG,IAAI;IAEzB;AACF;AACA;AACA;IAHE,KAIUO,YAAY,GAAG,IAAI;IAE7B;AACF;AACA;AACA;IAHE,KAIUK,SAAS,GAAG,IAAI;IAE1B;AACF;AACA;AACA;IAHE,KAIUE,UAAU,GAAG,KAAK;IAE5B;AACF;AACA;AACA;IAHE,KAIUE,SAAS,GAAG,IAAI;IAE1B;AACF;AACA;AACA;IAHE,KAIUC,SAAS,GAAG,KAAK;IAE3B;AACF;AACA;AACA;IAHE,KAIUC,QAAQ,GAAG,KAAK;IAE1B;AACF;AACA;AACA;IAHE,KAIUS,MAAM,GAAG,CAAC;IAEpB;AACF;AACA;AACA;IAHE,KAIUE,SAAS,GAAG,CAAC;IAEvB;AACF;AACA;AACA;IAHE,KAIUe,cAAc,GAAiB,IAAI;IAE7C;AACF;AACA;AACA;IAHE,KAIUC,QAAQ,GAAG,KAAK;IAE1B;AACF;AACA;AACA;IAHE,KAIQC,UAAU,GAAiB,IAAI;IAEvC;AACF;AACA;AACA;IAHE,KAIQC,cAAc,GAAiB,IAAI;IAE3C;AACF;AACA;AACA;IAHE,KAIQC,QAAQ,GAAG,KAAK;IAExB;AACF;AACA;AACA;IAHE,KAIQC,aAAa,GAAG,KAAK;IAE7B;AACF;AACA;AACA;IAHE,KAIQC,aAAa,GAAG,KAAK;IAE7B;AACF;AACA;AACA;IAHE,KAIQC,UAAU;IAoflB;AACF;AACA;AACA;AACA;IAJE,KAKAC,kBAAkB,GAAG,CAACC,KAAuB,EAAEC,YAAwB,GAAG,EAAE,KAAK;MAC/E,IAAID,KAAK,CAACE,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE;QAC3B,IAAI,CAACP,aAAa,GAAG,IAAI;QACzB,IAAI,CAACQ,oBAAoB,CAACJ,KAAK,EAAEC,YAAY,EAAE,oBAAoB,CAAC;QACpE;MACF;MAEA,IAAI,IAAI,CAAC1E,OAAO,EAAE;QAChByE,KAAK,CAACK,eAAe,CAAC,CAAC;QACvB,MAAMxF,CAAC,GAAGmF,KAAK,CAACE,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAChG,SAAS,CAAC;QACrD,IAAI,CAACmF,UAAU,GAAG,IAAIlG,KAAK,CAACsB,CAAC,CAAC0F,CAAC,EAAE1F,CAAC,CAAC2F,CAAC,CAAC;QACrC,IAAI,CAACd,cAAc,GAAG,IAAI,CAACe,QAAQ;QACnC,IAAI,CAACd,QAAQ,GAAG,KAAK;QACrB,IAAI,CAACtE,QAAQ,GAAG,IAAI;QACpB,IAAI,CAACyC,KAAK,CAAC5D,WAAW,CAACwG,QAAQ,EAAE7F,CAAC,CAAC;QACnC;QACA,IAAI,CAACsC,SAAS,CAACC,OAAO,CAAEC,CAAC,IAAK;UAC5BA,CAAC,CAACJ,OAAO,CAACJ,WAAW,GAAG,KAAK;QAC/B,CAAC,CAAC;MACJ;MAEA,IAAI,CAAC,IAAI,CAAC0C,cAAc,EAAE;QAAE;QAC1B,IAAI,CAACa,oBAAoB,CAACJ,KAAK,EAAEC,YAAY,EAAE,oBAAoB,CAAC;MACtE;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKAU,gBAAgB,GAAG,CAACX,KAAuB,EAAEC,YAAwB,GAAG,EAAE,KAAK;MAC7E,IAAID,KAAK,CAACE,IAAI,CAACC,MAAM,KAAK,CAAC,IAAI,IAAI,CAACP,aAAa,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;QACxE,IAAI,IAAI,CAACtE,OAAO,IAAI,CAAC,IAAI,CAACF,QAAQ,EAAE;UAClC,MAAMR,CAAC,GAAGmF,KAAK,CAACE,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAChG,SAAS,CAAC;UACrD,IAAI,CAACe,QAAQ,GAAG,IAAI;UACpB,IAAI,CAACyC,KAAK,CAAC5D,WAAW,CAACwG,QAAQ,EAAE7F,CAAC,CAAC;QACrC;MACF;;MAEA;MACA,IAAI,CAACsC,SAAS,CAACC,OAAO,CAAEC,CAAC,IAAK;QAC5BA,CAAC,CAACJ,OAAO,CAACJ,WAAW,GAAG,IAAI;MAC9B,CAAC,CAAC;MACF,IAAI,CAACqC,QAAQ,GAAG,KAAK;MACrB,IAAI,CAACO,UAAU,GAAG,IAAI;MACtB,IAAI,CAACC,cAAc,GAAG,IAAI;MAC1B,IAAI,IAAI,CAACC,QAAQ,EAAE;QACjB,IAAI,CAACiB,QAAQ,CAAC,CAAC;QACf,IAAI,CAACjB,QAAQ,GAAG,KAAK;MACvB;MACA,IAAI,CAACC,aAAa,GAAG,KAAK;MAC1B,IAAI,CAACC,aAAa,GAAG,KAAK;MAC1B,IAAI,CAACO,oBAAoB,CAACJ,KAAK,EAAEC,YAAY,EAAE,kBAAkB,CAAC;IACpE,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAY,kBAAkB,GAAIb,KAAuB,IAAK;MAChD,IAAIA,KAAK,CAACE,IAAI,CAACY,OAAO,KAAK,CAAC,IAAI,IAAI,CAAClB,aAAa,EAAE;QAClD,IAAI,CAACC,aAAa,GAAG,IAAI;QACzB;MACF;MACA,IAAI,IAAI,CAACvC,QAAQ,IAAI,IAAI,CAACjC,QAAQ,IAAI,IAAI,CAAC0F,IAAI,CAACf,KAAK,CAAC,EAAE;QACtD;QACA,IAAI,CAACpD,QAAQ,CAACqB,MAAM,GAAGjE,MAAM,CAACoE,OAAO;MACvC,CAAC,MAAM,IAAI,IAAI,CAACd,QAAQ,IAAI,IAAI,CAACjC,QAAQ,IAAI,IAAI,CAACoE,UAAU,IAAI,IAAI,CAACC,cAAc,EAAE;QACnF;QACA,IAAI,CAACC,QAAQ,GAAG,IAAI;QACpB,IAAI,CAACH,QAAQ,GAAGQ,KAAK,CAACE,IAAI,CAACc,aAAa,CAACC,OAAO;QAChD,MAAMC,KAAK,GAAGlB,KAAK,CAACE,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAChG,SAAS,CAAC;QACzD,MAAM6G,OAAO,GAAG,IAAI,CAACV,QAAQ,CAACF,CAAC;QAC/B,MAAMa,OAAO,GAAG,IAAI,CAACX,QAAQ,CAACD,CAAC;QAC/B,MAAMC,QAAQ,GAAG,IAAIlH,KAAK,CACxB,IAAI,CAACmG,cAAc,CAACa,CAAC,IAAIW,KAAK,CAACX,CAAC,GAAG,IAAI,CAACd,UAAU,CAACc,CAAC,CAAC,EACrD,IAAI,CAACb,cAAc,CAACc,CAAC,IAAIU,KAAK,CAACV,CAAC,GAAG,IAAI,CAACf,UAAU,CAACe,CAAC,CACtD,CAAC;QACD;QACA,IAAI,CAACC,QAAQ,GAAI,IAAI,CAAC9B,SAAS,KAAK7E,SAAS,CAACuH,GAAG,IAAI,IAAI,CAAChH,mBAAmB,GAAI,IAAI,CAACA,mBAAmB,GAAGoG,QAAQ;QACpH,IAAI,CAAChC,eAAe,CAAC,CAAC;QACtB,IAAI,CAAC6C,SAAS,CAAC;UAAEC,MAAM,EAAE,IAAI,CAACd,QAAQ,CAACF,CAAC,GAAGY,OAAO;UAAEK,MAAM,EAAE,IAAI,CAACf,QAAQ,CAACD,CAAC,GAAGY;QAAQ,CAAC,CAAC;MAC1F;IACF,CAAC;IAED;AACF;AACA;IAFE,KAGAK,sBAAsB,GAAG,MAAM;MAC7B,IAAI,IAAI,CAAClC,cAAc,EAAE;QACvB,MAAMmC,OAAO,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;QAC9C,IAAID,OAAO,EAAE;UACX;UACA,IAAI,CAACrG,QAAQ,GAAG,IAAI;UACpB,IAAI,CAACyC,KAAK,CAAC5D,WAAW,CAACwG,QAAQ,CAAC;UAChC;UACA,IAAI,CAACjB,UAAU,GAAG,IAAI;UACtB,IAAI,CAACC,cAAc,GAAG,IAAI;QAC5B;MACF;IACF,CAAC;IA0UD;AACF;AACA;AACA;AACA;IAJE,KAKUkC,aAAa,GAAIC,CAAgB,IAAK;MAC9C,IAAI,IAAI,CAACnE,QAAQ,IAAI,IAAI,CAACrC,QAAQ,IAAI,IAAI,CAACiC,QAAQ,IAAIuE,CAAC,CAACC,QAAQ,EAAE;QAAA,IAAAC,MAAA;QACjE,IAAIR,MAAM,GAAG,CAAC;QACd,IAAIC,MAAM,GAAG,CAAC;QACd,IAAIjD,QAAQ,GAAG,CAAC;QAChB,SAAAwD,MAAA,GAAQF,CAAC,CAACG,GAAG,cAAAD,MAAA,uBAALA,MAAA,CAAOE,WAAW,CAAC,CAAC;UAC1B,KAAK,GAAG;YACNT,MAAM,GAAG,CAAC,CAAC;YACX;UACF,KAAK,GAAG;YACND,MAAM,GAAG,CAAC,CAAC;YACX;UACF,KAAK,GAAG;YACNC,MAAM,GAAG,CAAC;YACV;UACF,KAAK,GAAG;YACND,MAAM,GAAG,CAAC;YACV;UACF,KAAK,GAAG;YACNhD,QAAQ,GAAG,CAAC,CAAC;YACb;UACF,KAAK,GAAG;YACNA,QAAQ,GAAG,CAAC;YACZ;UACF;YACE;QACJ;QACA,IAAIgD,MAAM,KAAK,CAAC,IAAIC,MAAM,KAAK,CAAC,EAAE;UAChCK,CAAC,CAACK,cAAc,CAAC,CAAC;UAClB,IAAI,CAACzB,QAAQ,GAAG,IAAIlH,KAAK,CACvB,IAAI,CAACkH,QAAQ,CAACF,CAAC,GAAGgB,MAAM,EACxB,IAAI,CAACd,QAAQ,CAACD,CAAC,GAAGgB,MACpB,CAAC;UACD,IAAI,CAAC/C,eAAe,CAAC,CAAC;UACtB,IAAI,CAACmC,QAAQ,CAAC,CAAC;QACjB;QAEA,IAAIrC,QAAQ,KAAK,CAAC,IAAI,IAAI,CAACf,SAAS,EAAE;UACpCqE,CAAC,CAACK,cAAc,CAAC,CAAC;UAClB,IAAI,CAAC3D,QAAQ,IAAIA,QAAQ,IAAI4D,IAAI,CAACC,EAAE,GAAG,GAAG,CAAC;UAC3C,IAAI,CAACxB,QAAQ,CAAC,CAAC;QACjB;MACF;IACF,CAAC;IA1jBC,IAAI,CAAChE,QAAQ,CAACyF,EAAE,CAAC,aAAa,EAAE,IAAI,CAACtC,kBAAkB,CAAC;IACxD,IAAI,CAACnD,QAAQ,CAACyF,EAAE,CAAC,WAAW,EAAE,IAAI,CAAC1B,gBAAgB,CAAC;IACpD,IAAI,CAAC/D,QAAQ,CAACyF,EAAE,CAAC,kBAAkB,EAAE,IAAI,CAAC1B,gBAAgB,CAAC;IAC3D,IAAI,CAAC/D,QAAQ,CAACyF,EAAE,CAAC,aAAa,EAAE,IAAI,CAACxB,kBAAkB,CAAC;IAExD,IAAI,CAACrG,GAAG,GAAGA,GAAG;IACd,IAAI,CAACA,GAAG,CAAC8H,IAAI,CAACC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAACd,sBAAsB,EAAE,KAAK,CAAC;IAC/Ee,QAAQ,CAACD,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACX,aAAa,EAAE,KAAK,CAAC;IAE/D,IAAI,CAACtH,SAAS,GAAGA,SAAS,IAAIE,GAAG,CAACC,KAAK;IACvC,IAAI,CAACmC,QAAQ,CAACC,WAAW,GAAG,IAAI,CAACA,WAAW;IAC5C,IAAI,CAACE,iBAAiB,CAACN,MAAM,GAAG,IAAI;IACpC,IAAI,CAACK,cAAc,CAAC2F,QAAQ,CAAC,IAAI,CAAC7F,QAAQ,CAAC;IAC3C,IAAI,CAACtC,SAAS,CAACmI,QAAQ,CAAC,IAAI,CAAC3F,cAAc,CAAC;IAC5C,IAAI,CAACxC,SAAS,CAACmI,QAAQ,CAAC,IAAI,CAAC1F,iBAAiB,CAAC;IAC/C,IAAI,CAACsC,YAAY,CAACxC,WAAW,GAAG,KAAK;IACrC,IAAI,CAACE,iBAAiB,CAAC0F,QAAQ,CAAC,IAAI,CAACpD,YAAY,CAAC;IAElD,IAAI,CAACf,MAAM,GAAGD,KAAK,IAAI7D,GAAG,CAACC,KAAK,CAAC4D,KAAK,CAACkC,CAAC;IACxC,IAAIzF,KAAK,KAAK4H,SAAS,EAAE;MACvB,IAAI,CAAC3H,MAAM,GAAGD,KAAK;MACnB,IAAI,CAACK,YAAY,GAAGL,KAAK;IAC3B;IACA,IAAI,CAAC+D,YAAY,GAAG;MAClB/D,KAAK,EAAE,IAAI,CAACC,MAAM;MAClBG,WAAW,EAAE,IAAI,CAACC;IACpB,CAAC;IACD,IAAIM,KAAK,KAAKiH,SAAS,EAAE;MACvB,IAAI,CAAChH,MAAM,GAAGD,KAAK,GAAG,CAAC,GAAGA,KAAK,GAAG,KAAK;IACzC;IACA,IAAIG,KAAK,KAAK8G,SAAS,EAAE;MACvB,IAAI,CAAC7G,MAAM,GAAGD,KAAK;IACrB;IACA,IAAIK,UAAU,KAAKyG,SAAS,EAAE;MAC5B,IAAI,CAACxG,WAAW,GAAGD,UAAU;IAC/B;IACA,IAAIE,eAAe,KAAKuG,SAAS,EAAE;MACjC,IAAI,CAACtG,gBAAgB,GAAGD,eAAe;IACzC;IACA,IAAI,CAACsB,UAAU,GAAGD,SAAS;IAC3B,IAAI,CAAChB,QAAQ,GAAGA,QAAQ;EAC1B;;EAEA;AACF;AACA;AACA;EACYiC,eAAeA,CAACkE,MAAM,GAAG,KAAK,EAAE;IACxC,MAAM/H,KAAK,GAAG,IAAI,CAACA,KAAK,CAACgI,KAAK,CAAC,CAAC;IAChC,IAAID,MAAM,IAAI,IAAI,CAAC7C,UAAU,EAAE;MAC7B;MACA,MAAM+C,YAAY,GAAG5I,sBAAsB,CAAC,IAAI,CAAC6F,UAAU,EAAElF,KAAK,EAAE,IAAI,CAAC2D,QAAQ,CAAC;MAClF3D,KAAK,CAAC2F,CAAC,GAAGsC,YAAY,CAACtC,CAAC;MACxB3F,KAAK,CAAC4F,CAAC,GAAGqC,YAAY,CAACrC,CAAC;MACxB,IAAI,CAAC5F,KAAK,GAAGA,KAAK;IACpB;IACA,IAAI,CAACkC,cAAc,CAAClC,KAAK,CAACkI,GAAG,CAAClI,KAAK,CAAC2F,CAAC,EAAE3F,KAAK,CAAC4F,CAAC,CAAC;IAC/C,IAAI,CAAC1D,cAAc,CAAC2D,QAAQ,CAACqC,GAAG,CAAClI,KAAK,CAAC2F,CAAC,EAAE3F,KAAK,CAAC4F,CAAC,CAAC;IAClD,IAAI,CAAC1D,cAAc,CAACyB,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5C,IAAI,CAACuB,UAAU,GAAGlF,KAAK,CAACgI,KAAK,CAAC,CAAC;IAE/B,IAAI,CAAC7F,iBAAiB,CAACnC,KAAK,CAACkI,GAAG,CAAClI,KAAK,CAAC2F,CAAC,EAAE3F,KAAK,CAAC4F,CAAC,CAAC;IAClD,IAAI,CAACzD,iBAAiB,CAAC0D,QAAQ,CAACqC,GAAG,CAAClI,KAAK,CAAC2F,CAAC,EAAE3F,KAAK,CAAC4F,CAAC,CAAC;IACrD,IAAI,CAACzD,iBAAiB,CAACwB,QAAQ,GAAG,IAAI,CAACA,QAAQ;EACjD;EAEA;AACF;AACA;AACA;AACA;AACA;EACU6B,oBAAoBA,CAC1BJ,KAAuB,EACvBC,YAAwB,EACxB8C,QAAmD,EACnD;IACA,IAAI,CAACnG,QAAQ,CAACC,WAAW,GAAG,KAAK;IACjC,MAAM;MAAEmG;IAAY,CAAC,GAAG,IAAI,CAACxI,GAAG,CAACyI,QAAQ,CAACC,OAAO;IACjD,MAAMC,GAAG,GAAGH,WAAW,CAACI,OAAO,CAACpD,KAAK,CAACE,IAAI,CAACmD,MAAM,CAAC;IAClD,IAAIF,GAAG,IAAIA,GAAG,YAAYtJ,aAAa,IAAI,CAACoG,YAAY,CAACqD,QAAQ,CAAC,IAAI,CAAC1G,QAAQ,CAAC,EAAE;MAChFuG,GAAG,CAACI,KAAK,CAACR,QAAQ,CAAC,CAAC/C,KAAK,EAAE,CAAC,GAAGC,YAAY,EAAE,IAAI,CAACrD,QAAQ,CAAC,CAAC;IAC9D;IACA,IAAI,CAACA,QAAQ,CAACC,WAAW,GAAG,IAAI;EAClC;EA8GA;AACF;AACA;EAGE;AACF;AACA;AACA;AACA;EAGE;AACF;AACA;EAGE;AACF;AACA;EAGE;AACF;AACA;EAGE;AACF;AACA;EACE2G,oBAAoBA,CAAA,EAAG;IACrB,OAAO,KAAK,CAAC,CAAC;EAChB;;EAEA;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAACvC,KAAY,EAAEwC,SAAkB,EAAgB;IAC1D,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACE3C,IAAIA,CAACf,KAAuB,EAAE;IAC5B,IAAI,CAACT,cAAc,GAAG,IAAI;IAC1B,OAAO,KAAK;EACd;;EAEA;AACF;AACA;EACEoC,uBAAuBA,CAAA,EAAG;IACxB,OAAO,KAAK;EACd;;EAEA;AACF;AACA;EACE7F,cAAcA,CAAA,EAAG;IACf,MAAM6H,YAAY,GAAG,IAAI,CAAChF,SAAS,KAAK7E,SAAS,CAACuH,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;IACjE,MAAMuC,YAAY,GAAG,CACnB,IAAI,CAACjF,SAAS,KAAK7E,SAAS,CAAC+J,OAAO,IACpC,IAAI,CAAClF,SAAS,KAAK7E,SAAS,CAACgK,IAAI,IACjC,IAAI,CAACnF,SAAS,KAAK7E,SAAS,CAACiK,SAAS,KACnC,IAAI,CAAC9H,UAAU,GAAG,CAAC,GAAG,CAAC;IAE5B,IAAI,IAAI,CAACO,QAAQ,EAAE;MACjB;MACA,IAAI,IAAI,CAACZ,KAAK,EAAE;QACd,IAAI,CAACY,QAAQ,CAACwH,IAAI,GAAG,IAAI,CAACpI,KAAK;QAC/B,IAAI,CAACY,QAAQ,CAACC,MAAM,GAAG,IAAI,CAACJ,KAAK;QAEjC,MAAMoE,QAAQ,GAAG,IAAI,CAACwD,gBAAgB,CAAC,CAAC;QACxC,MAAMC,cAAc,GAAG,IAAI,CAAC5J,SAAS,CAAC6J,QAAQ,CAAC;UAAE5D,CAAC,EAAEE,QAAQ,CAACF,CAAC;UAAEC,CAAC,EAAEC,QAAQ,CAACD,CAAC,GAAG,CAACmD,YAAY,GAAGC,YAAY,IAAI,IAAI,CAACvF;QAAM,CAAC,CAAC;QAC7H,MAAM+F,WAAW,GAAG,IAAI,CAAC9J,SAAS,CAAC6J,QAAQ,CAAC,IAAI,CAACvJ,KAAK,CAAC;QACvD,IAAI,CAAC4B,QAAQ,CAAC6H,WAAW,CAACH,cAAc,EAAEE,WAAW,EAAE,IAAI,CAAC7F,QAAQ,CAAC;MACvE;IACF,CAAC,MAAM,IAAI,IAAI,CAAC3C,KAAK,EAAE;MACrB,IAAI,CAAC,IAAI,CAACkD,cAAc,EAAE;QACxB,IAAI,CAACwF,qBAAqB,CAAC,CAAC;MAC9B,CAAC,MAAM;QACL,IAAI,CAACxF,cAAc,CAACyF,cAAc,CAAC,CAAC;MACtC;MAEA,MAAM;QAAEhE,CAAC;QAAEC;MAAE,CAAC,GAAG,IAAI,CAACyD,gBAAgB,CAAC,CAAC;MACxC,IAAI,CAACnF,cAAc,CAAE2B,QAAQ,CAACF,CAAC,GAAGA,CAAC;MACnC,IAAI,CAACzB,cAAc,CAAE2B,QAAQ,CAACD,CAAC,GAAGA,CAAC,GAAG,CAAC,EAAE,GAAGmD,YAAY,GAAGC,YAAY,IAAI,IAAI,CAACvF,KAAK;MACrF,IAAI,CAACS,cAAc,CAAET,KAAK,CAACyE,GAAG,CAAC,CAAC,GAAG,IAAI,CAACzE,KAAK,CAAC;MAE9C,MAAM2F,IAAI,GAAG,IAAIxK,IAAI,CAAE,IAAG,IAAI,CAACoC,KAAM,GAAE,EAAE;QACvC4I,QAAQ,EAAE,EAAE;QACZC,UAAU,EAAE,EAAE;QACdC,IAAI,EAAE;MACR,CAAC,CAAC;MAEF,MAAM;QAAEC,KAAK;QAAEC;MAAO,CAAC,GAAGZ,IAAI,CAACa,SAAS,CAAC,CAAC;MAC1C,MAAMC,MAAM,GAAG,IAAIxL,QAAQ,CAAC,CAAC;MAC7BwL,MAAM,CAACC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC;MACxBD,MAAM,CAACE,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEL,KAAK,EAAEC,MAAM,CAAC;MACpCE,MAAM,CAACG,OAAO,CAAC,CAAC;MAChB,IAAI,CAACnG,cAAc,CAAE2D,QAAQ,CAACqC,MAAM,CAAC;MACrC,IAAI,CAAChG,cAAc,CAAE2D,QAAQ,CAACuB,IAAI,CAAC;IACrC;EACF;;EAEA;AACF;AACA;AACA;AACA;EACYkB,OAAOA,CAACC,cAA4B,EAAE;IAC9C,IAAI,CAAC,IAAI,CAACnG,SAAS,EAAE;MACnB,IAAI,CAACrB,SAAS,GAAG,IAAI;MACrB,IAAI,CAAC1C,SAAS,CAAC,CAAC;MAChB,IAAI,CAAC6C,KAAK,CAAC5D,WAAW,CAACkL,QAAQ,EAAED,cAAc,CAAC;IAClD;EACF;;EAEA;AACF;AACA;AACA;EACYE,OAAOA,CAAA,EAAG;IAClB,IAAI,CAACvH,KAAK,CAAC5D,WAAW,CAACoL,OAAO,CAAC;IAC/B,IAAI,CAACC,OAAO,CAAC,CAAC;EAChB;;EAEA;AACF;AACA;AACA;EACY3E,QAAQA,CAAA,EAAG;IACnB,IAAI,CAAC9C,KAAK,CAAC5D,WAAW,CAACsL,OAAO,EAAE,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EACjD;;EAEA;AACF;AACA;AACA;AACA;EACYnE,SAASA,CAACpB,IAAyC,EAAE;IAC7D,IAAI,CAAChB,QAAQ,GAAG,IAAI;EACtB;;EAEA;AACF;AACA;AACA;AACA;EACYwG,SAASA,CAACxF,IAAyC,EAAE;IAC7D,IAAI,CAACjB,QAAQ,GAAG,IAAI;EACtB;;EAEA;AACF;AACA;AACA;EACE0G,iBAAiBA,CAAA,EAAG;IAClB,MAAM;MAAEC,IAAI;MAAEC,KAAK;MAAEC,GAAG;MAAEC;IAAO,CAAC,GAAG,IAAI,CAACC,WAAW;IACrD,MAAMC,MAAM,GAAG,IAAI1M,KAAK,CAACqM,IAAI,GAAG,CAACC,KAAK,GAAGD,IAAI,IAAI,CAAC,EAAEE,GAAG,GAAG,CAACC,MAAM,GAAGD,GAAG,IAAI,CAAC,CAAC;IAC7E,MAAM;MAAEvF,CAAC;MAAEC;IAAE,CAAC,GAAG,IAAI,CAAClG,SAAS,CAAC6J,QAAQ,CAAC8B,MAAM,CAAC;IAChD,OAAO;MAAE1F,CAAC;MAAEC;IAAE,CAAC;EACjB;;EAEA;AACF;AACA;AACA;EACEzG,iBAAiBA,CAACmM,MAA0B,EAAE;IAC5C,MAAMC,gBAAgB,GAAG,IAAI,CAACC,gBAAgB,CAAC,CAAC;IAChD,MAAMC,cAAc,GAAGH,MAAM,CAACI,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAAC3H,GAAG,KAAK,IAAI,CAACA,GAAG,CAAC;IAC/D,OAAO7E,iBAAiB,CAACoM,gBAAgB,EAAE,IAAI,CAACH,WAAW,EAAE,IAAI,CAACrH,SAAS,EAAE0H,cAAc,CAAC;EAC9F;;EAEA;AACF;AACA;AACA;AACA;EACEG,cAAcA,CAACjG,CAAS,EAAEC,CAAS,EAAE;IACnC,IAAI,CAACC,QAAQ,GAAG,IAAIlH,KAAK,CAACgH,CAAC,EAAEC,CAAC,CAAC;IAC/B,IAAI,CAAC/B,eAAe,CAAC,CAAC;EACxB;;EAEA;AACF;AACA;EACE8G,OAAOA,CAAA,EAAG;IACR,IAAI,IAAI,CAACvG,SAAS,EAAE;MAClB;IACF;IACA,IAAI,CAACxE,GAAG,CAAC8H,IAAI,CAACmE,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAChF,sBAAsB,EAAE,KAAK,CAAC;IAClFe,QAAQ,CAACiE,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC7E,aAAa,EAAE,KAAK,CAAC;IAClE;IACA8E,MAAM,CAACC,MAAM,CAACzM,WAAW,CAAC,CAACkD,OAAO,CAAEwJ,MAAM,IAAK;MAC7C,IAAI,CAACC,GAAG,CAACD,MAAM,CAAC;IAClB,CAAC,CAAC;IACF;IACA,IAAI,CAACzJ,SAAS,GAAG,EAAE;IACnB,IAAI,IAAI,CAACH,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAACuI,OAAO,CAAC,CAAC;IAC/B;IACA;IACA,CACE,IAAI,CAACxI,iBAAiB,EACtB,IAAI,CAACD,cAAc,CACpB,CACEM,OAAO,CAAE9C,SAAS,IAAK;MACtB,IAAI,CAACA,SAAS,CAACwM,WAAW,CAACxM,SAAS,CAAC;MACrCA,SAAS,CAACiL,OAAO,CAAC;QAChBwB,QAAQ,EAAE,IAAI;QACdC,OAAO,EAAE,IAAI;QACbC,WAAW,EAAE;MACf,CAAC,CAAC;IACJ,CAAC,CAAC;IACJ;IACA,IAAI,IAAI,CAACzK,QAAQ,EAAE;MACjB,IAAI,CAACA,QAAQ,CAAC0K,MAAM,CAAC,CAAC;MACtB,IAAI,CAAC1K,QAAQ,GAAGkG,SAAS;IAC3B;IACA,IAAI,CAAC1D,SAAS,GAAG,IAAI;EACvB;;EAEA;AACF;AACA;EACEmI,cAAcA,CAAA,EAAG;IACf;IACA,IAAI,CAAChK,SAAS,CAACC,OAAO,CAAEC,CAAC,IAAK;MAC5BA,CAAC,CAAC6J,MAAM,CAAC,CAAC;IACZ,CAAC,CAAC;IACF,IAAI,CAAC/J,SAAS,GAAG,EAAE;IACnB;IACA,IAAI,IAAI,CAACH,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAACkK,MAAM,CAAC,CAAC;IAC9B;EACF;;EAEA;AACF;AACA;AACA;AACA;EACYpJ,KAAKA,CAACsJ,SAAiB,EAAE,GAAGC,IAAW,EAAE;IACjD,IAAI,CAAClI,aAAa,CAACmI,IAAI,CAACF,SAAS,EAAE,IAAI,EAAE,GAAGC,IAAI,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;EACEhF,EAAEA,CAAC+E,SAAiB,EAAEG,QAAmD,EAAE;IACzE,IAAI,CAACpI,aAAa,CAACkD,EAAE,CAAC+E,SAAS,EAAEG,QAAQ,CAAC;IAC1C,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEV,GAAGA,CAACO,SAAiB,EAAEG,QAAoD,EAAE;IAC3E,IAAIA,QAAQ,EAAE;MACZ,IAAI,CAACpI,aAAa,CAACqI,cAAc,CAACJ,SAAS,EAAEG,QAAQ,CAAC;IACxD,CAAC,MAAM;MACL,IAAI,CAACpI,aAAa,CAACsI,kBAAkB,CAACL,SAAS,CAAC;IAClD;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACYM,yBAAyBA,CAACnH,CAAS,EAAEC,CAAS,EAAE;IACxD,MAAMU,KAAK,GAAG,IAAI3H,KAAK,CAAC,CAAC;IACzB,IAAI,CAACiB,GAAG,CAACyI,QAAQ,CAACC,OAAO,CAACF,WAAW,CAAC2E,kBAAkB,CAACzG,KAAK,EAAEX,CAAC,EAAEC,CAAC,CAAC;IACrE,OAAOU,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACY0G,wBAAwBA,CAAC1G,KAAY,EAAE;IAC/C,OAAO,IAAI,CAAC5G,SAAS,CAACuN,OAAO,CAAC3G,KAAK,CAAC;EACtC;;EAEA;AACF;AACA;EACU3E,0BAA0BA,CAAA,EAAG;IACnC,IAAI,IAAI,CAACoC,SAAS,KAAK7E,SAAS,CAACuH,GAAG,IAC/B,IAAI,CAAC1C,SAAS,KAAK7E,SAAS,CAACgK,IAAI,EAAE;MACtC,IAAI,CAAChH,cAAc,CAACL,MAAM,GAAG,IAAI,CAACpB,QAAQ,GAAG,IAAI,GAAG,IAAI,CAACgB,KAAK;IAChE,CAAC,MAAM;MACL,IAAI,CAACS,cAAc,CAACL,MAAM,GAAG,IAAI,CAACJ,KAAK;IACzC;EACF;;EAEA;AACF;AACA;AACA;EACYiI,qBAAqBA,CAAA,EAAG;IAChC,IAAI,CAACxF,cAAc,GAAG,IAAIzF,SAAS,CAAC,CAAC;IACrC,IAAI,CAACyF,cAAc,CAACjC,WAAW,GAAG,KAAK;IACvC,IAAI,CAACC,cAAc,CAAC2F,QAAQ,CAAC,IAAI,CAAC3D,cAAc,CAAC;EACnD;;EAEA;AACF;AACA;AACA;EACYgJ,wBAAwBA,CAAA,EAAG;IACnC,IAAI,CAAC/I,iBAAiB,GAAG,IAAI1F,SAAS,CAAC,CAAC;IACxC,IAAI,CAAC0F,iBAAiB,CAAClC,WAAW,GAAG,KAAK;IAC1C,IAAI,CAACC,cAAc,CAAC2F,QAAQ,CAAC,IAAI,CAAC1D,iBAAiB,CAAC;EACtD;AAmDF","ignoreList":[]},"metadata":{},"sourceType":"module"}