{"ast":null,"code":"import { Container, Sprite, Texture, Graphics, Polygon, Rectangle } from 'pixi.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport ShapeGraphics from '../../common/shapes/ShapeGraphics';\nimport Layer from '../../common/shapes/Layer';\nimport { ShapeType } from '../../common/shapes/types';\nimport { hitTesting, findIntersections } from '../../common/shapes/utils';\nconst ZOOM_MIN = 0.25;\nconst ZOOM_MAX = 100;\nexport let EventAction = /*#__PURE__*/function (EventAction) {\n  EventAction[\"SELECTED\"] = \"selected\";\n  EventAction[\"POINTERDOWN\"] = \"pointer-down\";\n  EventAction[\"BLANK_POINTERDOWN\"] = \"blank-pointer-down\";\n  EventAction[\"SCALE_CHANGED\"] = \"scale-changed\";\n  EventAction[\"POSITION_CHANGED\"] = \"position-changed\";\n  EventAction[\"SHAPES_SELECTED\"] = \"shapes-selected\";\n  EventAction[\"POINTS_SELECTED\"] = \"points-selected\";\n  return EventAction;\n}({});\nclass View extends Container {\n  /**\n   * get scale of view\n   * @getter\n   */\n  get viewScale() {\n    return this.stage.scale.x;\n  }\n\n  /**\n   * set scale of view\n   * @setter\n   */\n  set viewScale(scale) {\n    this.stage.scale.set(scale);\n    // update shapes scale\n    const setChildrenScale = children => {\n      children.forEach(child => {\n        if (child instanceof ShapeGraphics) {\n          // eslint-disable-next-line no-param-reassign\n          child.shape.scale = scale;\n        } else if (child instanceof Container) {\n          setChildrenScale(child.children);\n        }\n      });\n    };\n    setChildrenScale(this.shapesLayer.children);\n    // update assist layer\n    this.drawAuxiliaryLines();\n    this.emit(EventAction.SCALE_CHANGED, scale, this);\n  }\n\n  /**\n   * is right button clicked\n   * @private\n   */\n\n  constructor({\n    id,\n    enableReview,\n    enableCheck,\n    auxiliaryLines\n  }) {\n    super();\n    /**\n     * view id\n     */\n    this.id = void 0;\n    /**\n     * hit area\n     */\n    // area = new Graphics();\n    /**\n     * view stage (similar with PIXI stage)\n     */\n    this.stage = new Container();\n    /**\n     * shapes layer\n     */\n    this.shapesLayer = new Layer();\n    /**\n     * review layer (for review anchors)\n     */\n    this.reviewLayer = void 0;\n    /**\n     * check layer (for empty area)\n     */\n    this.checkLayer = void 0;\n    /**\n     * assist layer (for auxiliary lines)\n     */\n    this.assistLayer = void 0;\n    /**\n     * auxiliary lines\n     */\n    this.auxiliaryLines = void 0;\n    /**\n     * image sprite instance\n     */\n    this.image = new Sprite(Texture.EMPTY);\n    /**\n     * image rotation\n     */\n    this.imageRotation = 0;\n    /**\n     * image load error\n     */\n    this.imageLoadError = false;\n    /**\n     * first imge loaded\n     */\n    this.firstLoaded = false;\n    /**\n     * view width (default 400)\n     */\n    this.viewWidth = 400;\n    /**\n     * view height (default 300)\n     */\n    this.viewHeight = 300;\n    /**\n     * zoom level, default is 1 when image fits the view\n     */\n    this.viewZoom = 1;\n    this._rightClicked = false;\n    /**\n     * click position when right button clicked\n     * @private\n     */\n    this._rightClickPoint = null;\n    /**\n     * stage position when right button clicked\n     * @private\n     */\n    this._rightClickPosition = null;\n    /**\n     * is view selected\n     */\n    this.selected = false;\n    /**\n     * view selected changed\n     */\n    this._selectedChanged = false;\n    /**\n     * is view hovered\n     */\n    this.hovered = false;\n    /**\n     * hovered shape\n     */\n    this.hoveredShape = void 0;\n    /**\n     * selector path\n     */\n    this.selectorPath = new Graphics();\n    /**\n     * points in selector path\n     */\n    this.selectorPathPoints = [];\n    /**\n     * is selecting\n     * @private\n     */\n    this._selecting = false;\n    /**\n     * process pointer down\n     * @param e\n     */\n    this.processPointerDown = e => {\n      const selected = this.selected;\n      this.emit(EventAction.SELECTED, e.data.originalEvent, this);\n      this._selectedChanged = this.selected !== selected;\n      if (this.imageLoadError) {\n        return;\n      }\n      if (e.data.button === 2) {\n        const point = e.data.getLocalPosition(this);\n        this._rightClicked = true;\n        this._rightClickPoint = point;\n        this._rightClickPosition = this.stage.position.clone();\n        return;\n      }\n      const localPoint = e.data.getLocalPosition(this.stage);\n      if (this._selectedChanged && this.hovered) {\n        // if selected changed, should get cursor hovered shape\n        this.hitTest(e.data.global, localPoint, e.data.originalEvent.ctrlKey);\n        if (this.hoveredShape) {\n          // if hovered, mock pointer down event for the shape\n          this.hoveredShape.processPointerDown(e);\n        }\n      }\n      this.emit(EventAction.POINTERDOWN, localPoint, e.data.originalEvent, this);\n    };\n    /**\n     * process pointer move\n     * @param e\n     */\n    this.processPointerMove = e => {\n      if (this.imageLoadError || !this.selected) {\n        return;\n      }\n      if (this._rightClicked && this._rightClickPoint && this._rightClickPosition) {\n        const point = e.data.getLocalPosition(this);\n        const offsetX = point.x - this._rightClickPoint.x;\n        const offsetY = point.y - this._rightClickPoint.y;\n        const x = this._rightClickPosition.x + offsetX;\n        const y = this._rightClickPosition.y + offsetY;\n        this.setStagePosition(x, y);\n        return;\n      }\n      if (this._selectedChanged && this.hoveredShape) {\n        // not continue, current is moving shape\n        return;\n      }\n      const localPoint = e.data.getLocalPosition(this.stage);\n      if (this._selecting) {\n        this.selectorPathPoints.push(localPoint);\n        this.drawSelectorPath();\n        return;\n      }\n      if (this.hovered) {\n        this.hitTest(e.data.global, localPoint, e.data.originalEvent.ctrlKey);\n      }\n    };\n    /**\n     * process pointer up\n     */\n    this.processPointerUp = () => {\n      this.finishSelect();\n      this._rightClicked = false;\n      this._rightClickPoint = null;\n      this._rightClickPosition = null;\n      this._selectedChanged = false;\n    };\n    /**\n     * process pointer out\n     */\n    this.processPointerOut = () => {\n      this.processPointerUp();\n      this.setHoveredShape();\n    };\n    /**\n     * process blank pointer down\n     */\n    this.processBlankPointerDown = e => {\n      const localPoint = e.data.getLocalPosition(this.stage);\n      this.emit(EventAction.BLANK_POINTERDOWN, localPoint, e.data.originalEvent, this);\n    };\n    /**\n     * start select\n     */\n    this.startSelect = () => {\n      this._selecting = true;\n      this.stage.addChild(this.selectorPath);\n    };\n    /**\n     * rotate\n     */\n    this.rotate = () => {\n      if (this.image && !this.imageLoadError) {\n        // set pivot\n        const {\n          width,\n          height\n        } = this.image;\n        this.image.pivot.set(width / 2, height / 2);\n\n        // set position\n        let px = width / 2;\n        let py = height / 2;\n        if (this.imageRotation % Math.PI !== 0) {\n          px = height / 2;\n          py = width / 2;\n        }\n        const {\n          x: ox,\n          y: oy\n        } = this.image.position;\n        this.image.position.set(px, py);\n        const offsetX = px - ox;\n        const offsetY = py - oy;\n\n        // set rotation\n        this.image.rotation = this.imageRotation;\n\n        // update stage position\n        const {\n          x,\n          y\n        } = this.getStagePosition();\n        this.setStagePosition(x - offsetX * this.viewScale, y - offsetY * this.viewScale);\n      }\n    };\n    /**\n     * zoom\n     * @param event\n     * @param zoomPoint\n     */\n    this.zoom = (event, zoomPoint) => {\n      if (this.imageLoadError || !this.selected || !this.hovered) {\n        return false;\n      }\n      event.stopPropagation();\n      const zoomPointX = zoomPoint.x - this.position.x;\n      const zoomPointY = zoomPoint.y - this.position.y;\n      let newZoom = event.deltaY > 0 ? this.viewZoom / 1.1 : this.viewZoom * 1.1;\n      newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n      const zoomScale = newZoom / this.viewZoom;\n      const {\n        x,\n        y\n      } = this.getStagePosition();\n      this.setStagePosition(zoomPointX - (zoomPointX - x) * zoomScale, zoomPointY - (zoomPointY - y) * zoomScale);\n      this.viewZoom = newZoom;\n      this.viewScale *= zoomScale;\n      return true;\n    };\n    /**\n     * zoom to provided scale\n     * @param scale\n     */\n    this.zoomTo = scale => {\n      if (this.imageLoadError) {\n        return;\n      }\n      const centerX = this.viewWidth / 2;\n      const centerY = this.viewHeight / 2;\n      let newZoom = this.viewZoom * (scale / this.viewScale);\n      newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n      const zoomScale = newZoom / this.viewZoom;\n      const {\n        x,\n        y\n      } = this.getStagePosition();\n      this.setStagePosition(centerX - (centerX - x) * zoomScale, centerY - (centerY - y) * zoomScale);\n      this.viewZoom = newZoom;\n      this.viewScale *= zoomScale;\n    };\n    /**\n     * fit image to canvas\n     */\n    this.fitImageToView = () => {\n      if (this.imageLoadError) {\n        return;\n      }\n      const {\n        width,\n        height\n      } = this.image;\n      let imageWidth = width;\n      let imageHeight = height;\n      if (this.imageRotation % Math.PI !== 0) {\n        imageWidth = height;\n        imageHeight = width;\n      }\n      const viewRatio = this.viewWidth / this.viewHeight;\n      const imgRatio = imageWidth / imageHeight;\n      const scale = (viewRatio < imgRatio ? this.viewWidth / imageWidth : this.viewHeight / imageHeight) * 0.98;\n      this.setStagePosition((this.viewWidth - scale * imageWidth) / 2, (this.viewHeight - scale * imageHeight) / 2);\n      this.viewScale = scale;\n      this.viewZoom = 1;\n    };\n    /**\n     * fit shape to canvas\n     * @param bbox\n     * @param percentage\n     */\n    this.fitShapeToView = (bbox, percentage = 0.98) => {\n      if (this.imageLoadError) {\n        return;\n      }\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = bbox;\n      const width = right - left;\n      const height = bottom - top;\n      if (width !== 0 && height !== 0) {\n        const oldViewScale = this.viewScale;\n        const viewRatio = this.viewWidth / this.viewHeight;\n        const ratio = width / height;\n        let scale = (viewRatio < ratio ? this.viewWidth / width : this.viewHeight / height) * percentage;\n        let zoomScale = scale / oldViewScale;\n        let zoomLevel = Math.max(Math.min(this.viewZoom * zoomScale, ZOOM_MAX), ZOOM_MIN);\n        if (zoomLevel < 1) {\n          zoomLevel = 1;\n          zoomScale = zoomLevel / this.viewZoom;\n          scale = zoomScale * oldViewScale;\n        }\n        this.setStagePosition(this.viewWidth / 2 - scale * (left + width / 2), this.viewHeight / 2 - scale * (top + height / 2));\n        this.viewScale = scale;\n        this.viewZoom *= zoomScale;\n      }\n    };\n    this.id = id || uuidv4();\n    this.interactive = true;\n    this.on('pointerover', () => {\n      this.hovered = true;\n    });\n    this.on('pointerout', () => {\n      this.hovered = false;\n    });\n    this.on('pointerdown', this.processPointerDown);\n    this.on('pointermove', this.processPointerMove);\n    this.on('pointerup', this.processPointerUp);\n    this.on('pointerupoutside', this.processPointerUp);\n    this.on('pointerout', this.processPointerOut);\n\n    // this.area.interactive = true;\n    // this.area.on('pointerdown', this.processBlankPointerDown);\n\n    this.shapesLayer.sortableChildren = true;\n    this.stage.addChild(this.shapesLayer);\n    if (auxiliaryLines) {\n      this.auxiliaryLines = auxiliaryLines;\n      this.assistLayer = new Container();\n      this.assistLayer.interactive = false;\n      this.stage.addChild(this.assistLayer);\n    }\n    if (enableReview) {\n      this.reviewLayer = new Container();\n      this.stage.addChild(this.reviewLayer);\n    }\n    if (enableCheck) {\n      this.checkLayer = new Container();\n      this.checkLayer.interactive = false;\n      this.stage.addChild(this.checkLayer);\n    }\n    this.stage.addChildAt(this.image, 0);\n    this.addChild(this.stage);\n    // this.addChildAt(this.area, 0);\n  }\n\n  /**\n   * update position and size\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   */\n  updatePositionAndSize(x, y, width, height) {\n    const positionUpdated = this.x !== x || this.y !== y;\n    const sizeUpdated = this.viewWidth !== width || this.viewHeight !== height;\n    this.x = x;\n    this.y = y;\n    this.viewWidth = width;\n    this.viewHeight = height;\n    this.hitArea = new Rectangle(0, 0, width, height);\n    // if (sizeUpdated) {\n    //   this.area\n    //     .beginFill(0x000000)\n    //     .drawRect(0, 0, width, height)\n    //     .endFill();\n    // }\n    if (positionUpdated || sizeUpdated) {\n      this.mask = new Graphics().beginFill(0x000000).drawRect(x, y, width, height).endFill();\n    }\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.stage.x,\n      y: this.stage.y\n    };\n  }\n\n  /**\n   * set stage posistion\n   * @param x\n   * @param y\n   */\n  setStagePosition(x, y) {\n    this.stage.x = x;\n    this.stage.y = y;\n    this.emit(EventAction.POSITION_CHANGED, {\n      x,\n      y\n    }, this);\n  }\n\n  /**\n   * set image\n   * @param texture\n   */\n  setImage(texture) {\n    this.image.cacheAsBitmap = false;\n    if (this.image.texture) {\n      this.image.texture.destroy(true);\n    }\n    this.image.texture = texture;\n    this.image.cacheAsBitmap = true;\n    this.rotate();\n    if (!this.firstLoaded) {\n      this.firstLoaded = true;\n      this.fitImageToView();\n    }\n  }\n\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape && !this.hoveredShape.destroyed) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n\n  /**\n   * hit test\n   * @param point\n   * @param localPoint\n   * @param ctrlKey\n   */\n  hitTest(point, localPoint, ctrlKey = false) {\n    const {\n      intersection,\n      snappingPoint\n    } = hitTesting(point, localPoint, this.shapesLayer.children);\n    if (!ctrlKey) {\n      this.setHoveredShape(intersection);\n      this.shapesLayer.setSnappingPoint(snappingPoint);\n    } else {\n      this.setHoveredShape();\n      this.shapesLayer.setSnappingPoint(null);\n    }\n  }\n\n  /**\n   * get all shapes in stage\n   */\n  getAllShapes() {\n    const getShapes = children => {\n      let shapes = [];\n      for (let i = 0; i < children.length; i += 1) {\n        const child = children[i];\n        if (child.visible) {\n          if (child instanceof ShapeGraphics) {\n            if (child.shape.finished) {\n              shapes.push(child.shape);\n            }\n          } else if (child instanceof Container) {\n            shapes = [...shapes, ...getShapes(child.children)];\n          }\n        }\n      }\n      return shapes;\n    };\n    return getShapes(this.shapesLayer.children);\n  }\n  /**\n   * finish select\n   */\n  finishSelect() {\n    if (this._selecting && this.selectorPathPoints.length > 0) {\n      // check selected\n      const selectorPathData = [[[...this.selectorPathPoints].map(p => [p.x, p.y])]];\n      const selectorPathBounds = this.selectorPath.getLocalBounds();\n      const allShapes = this.getAllShapes();\n      const intersections = findIntersections(selectorPathData, selectorPathBounds, ShapeType.POLYGON, allShapes);\n      this.emit(EventAction.SHAPES_SELECTED, intersections.map(i => i.uid), this);\n      const shapePointsMap = {};\n      for (let i = 0; i < intersections.length; i += 1) {\n        const intersection = intersections[i];\n        if (intersection.shapeType === ShapeType.POLYGON || intersection.shapeType === ShapeType.LINE || intersection.shapeType === ShapeType.ARROW) {\n          // check points selected\n          const selectorPathArea = new Polygon(this.selectorPathPoints);\n          const {\n            points\n          } = intersection;\n          const selectedPointsIndex = [];\n          for (let j = 0; j < points.length; j += 1) {\n            if (selectorPathArea.contains(points[j].x, points[j].y)) {\n              selectedPointsIndex.push(j);\n            }\n          }\n          if (selectedPointsIndex.length > 0) {\n            shapePointsMap[intersection.uid] = selectedPointsIndex;\n          }\n        }\n      }\n      if (Object.keys(shapePointsMap).length > 0) {\n        this.emit(EventAction.POINTS_SELECTED, shapePointsMap, this);\n      }\n    }\n    this._selecting = false;\n    this.stage.removeChild(this.selectorPath);\n    this.selectorPathPoints = [];\n    this.drawSelectorPath();\n  }\n\n  /**\n   * draw path\n   */\n  drawSelectorPath() {\n    this.selectorPath.clear();\n    if (this.selectorPathPoints.length > 0) {\n      this.selectorPath.lineStyle(2 / this.viewScale, 0xFF0000);\n      this.selectorPath.moveTo(this.selectorPathPoints[0].x, this.selectorPathPoints[0].y);\n      for (let i = 1; i < this.selectorPathPoints.length; i += 1) {\n        this.selectorPath.lineTo(this.selectorPathPoints[i].x, this.selectorPathPoints[i].y);\n      }\n    }\n  }\n  /**\n   * draw auxiliary lines\n   */\n  drawAuxiliaryLines() {\n    if (!this.assistLayer || !this.auxiliaryLines) {\n      return;\n    }\n    this.assistLayer.removeChildren();\n    if (!this.imageLoadError) {\n      const graphics = new Graphics();\n      const {\n        width,\n        height\n      } = this.image;\n      let imageWidth = width;\n      let imageHeight = height;\n      if (this.imageRotation % Math.PI !== 0) {\n        imageWidth = height;\n        imageHeight = width;\n      }\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = this.auxiliaryLines;\n      for (let i = 0; i < left.length; i += 1) {\n        const {\n          positionType,\n          positionValue,\n          color\n        } = left[i];\n        const x = positionType === 'percentage' ? imageWidth * (positionValue / 100) : positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(x, 0);\n        graphics.lineTo(x, imageHeight);\n      }\n      for (let i = 0; i < top.length; i += 1) {\n        const {\n          positionType,\n          positionValue,\n          color\n        } = top[i];\n        const y = positionType === 'percentage' ? imageHeight * (positionValue / 100) : positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(0, y);\n        graphics.lineTo(imageWidth, y);\n      }\n      for (let i = 0; i < right.length; i += 1) {\n        const {\n          positionType,\n          positionValue,\n          color\n        } = right[i];\n        const x = positionType === 'percentage' ? imageWidth * (1 - positionValue / 100) : imageWidth - positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(x, 0);\n        graphics.lineTo(x, imageHeight);\n      }\n      for (let i = 0; i < bottom.length; i += 1) {\n        const {\n          positionType,\n          positionValue,\n          color\n        } = bottom[i];\n        const y = positionType === 'percentage' ? imageHeight * (1 - positionValue / 100) : imageHeight - positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(0, y);\n        graphics.lineTo(imageWidth, y);\n      }\n      this.assistLayer.addChild(graphics);\n    }\n  }\n}\nexport default View;","map":{"version":3,"names":["Container","Sprite","Texture","Graphics","Polygon","Rectangle","v4","uuidv4","ShapeGraphics","Layer","ShapeType","hitTesting","findIntersections","ZOOM_MIN","ZOOM_MAX","EventAction","View","viewScale","stage","scale","x","set","setChildrenScale","children","forEach","child","shape","shapesLayer","drawAuxiliaryLines","emit","SCALE_CHANGED","constructor","id","enableReview","enableCheck","auxiliaryLines","reviewLayer","checkLayer","assistLayer","image","EMPTY","imageRotation","imageLoadError","firstLoaded","viewWidth","viewHeight","viewZoom","_rightClicked","_rightClickPoint","_rightClickPosition","selected","_selectedChanged","hovered","hoveredShape","selectorPath","selectorPathPoints","_selecting","processPointerDown","e","SELECTED","data","originalEvent","button","point","getLocalPosition","position","clone","localPoint","hitTest","global","ctrlKey","POINTERDOWN","processPointerMove","offsetX","offsetY","y","setStagePosition","push","drawSelectorPath","processPointerUp","finishSelect","processPointerOut","setHoveredShape","processBlankPointerDown","BLANK_POINTERDOWN","startSelect","addChild","rotate","width","height","pivot","px","py","Math","PI","ox","oy","rotation","getStagePosition","zoom","event","zoomPoint","stopPropagation","zoomPointX","zoomPointY","newZoom","deltaY","max","min","zoomScale","zoomTo","centerX","centerY","fitImageToView","imageWidth","imageHeight","viewRatio","imgRatio","fitShapeToView","bbox","percentage","left","top","right","bottom","oldViewScale","ratio","zoomLevel","interactive","on","sortableChildren","addChildAt","updatePositionAndSize","positionUpdated","sizeUpdated","hitArea","mask","beginFill","drawRect","endFill","POSITION_CHANGED","setImage","texture","cacheAsBitmap","destroy","destroyed","intersection","snappingPoint","setSnappingPoint","getAllShapes","getShapes","shapes","i","length","visible","finished","selectorPathData","map","p","selectorPathBounds","getLocalBounds","allShapes","intersections","POLYGON","SHAPES_SELECTED","uid","shapePointsMap","shapeType","LINE","ARROW","selectorPathArea","points","selectedPointsIndex","j","contains","Object","keys","POINTS_SELECTED","removeChild","clear","lineStyle","moveTo","lineTo","removeChildren","graphics","positionType","positionValue","color"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/shapes/View.ts"],"sourcesContent":["import { Container, Sprite, Texture, Graphics, Point, Polygon, Rectangle, DisplayObject, InteractionEvent } from 'pixi.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport ShapeGraphics from '../../common/shapes/ShapeGraphics';\nimport Shape from '../../common/shapes/Shape';\nimport Layer from '../../common/shapes/Layer';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\nimport { hitTesting, findIntersections } from '../../common/shapes/utils';\nimport type TPolygon from '../../common/shapes/Polygon';\nimport type TLine from '../../common/shapes/Line';\nimport { AuxiliaryLines } from '../types';\n\nconst ZOOM_MIN = 0.25;\nconst ZOOM_MAX = 100;\n\nexport enum EventAction {\n  SELECTED = 'selected',\n  POINTERDOWN = 'pointer-down',\n  BLANK_POINTERDOWN = 'blank-pointer-down',\n  SCALE_CHANGED = 'scale-changed',\n  POSITION_CHANGED = 'position-changed',\n  SHAPES_SELECTED = 'shapes-selected',\n  POINTS_SELECTED = 'points-selected',\n}\n\ninterface ViewOptions {\n  id?: string;\n  enableReview?: boolean;\n  enableCheck?: boolean;\n  auxiliaryLines?: AuxiliaryLines;\n}\n\nclass View extends Container {\n  /**\n   * view id\n   */\n  id: string;\n\n  /**\n   * hit area\n   */\n  // area = new Graphics();\n\n  /**\n   * view stage (similar with PIXI stage)\n   */\n  stage = new Container();\n\n  /**\n   * shapes layer\n   */\n  shapesLayer = new Layer();\n\n  /**\n   * review layer (for review anchors)\n   */\n  reviewLayer?: Container;\n\n  /**\n   * check layer (for empty area)\n   */\n  checkLayer?: Container;\n\n  /**\n   * assist layer (for auxiliary lines)\n   */\n  assistLayer?: Container;\n\n  /**\n   * auxiliary lines\n   */\n  auxiliaryLines?: AuxiliaryLines;\n\n  /**\n   * image sprite instance\n   */\n  image = new Sprite(Texture.EMPTY);\n\n  /**\n   * image rotation\n   */\n  imageRotation = 0;\n\n  /**\n   * image load error\n   */\n  imageLoadError = false;\n\n  /**\n   * first imge loaded\n   */\n  firstLoaded = false;\n\n  /**\n   * view width (default 400)\n   */\n  viewWidth = 400;\n\n  /**\n   * view height (default 300)\n   */\n  viewHeight = 300;\n\n  /**\n   * zoom level, default is 1 when image fits the view\n   */\n  viewZoom = 1;\n\n  /**\n   * get scale of view\n   * @getter\n   */\n  get viewScale() {\n    return this.stage.scale.x;\n  }\n\n  /**\n   * set scale of view\n   * @setter\n   */\n  set viewScale(scale: number) {\n    this.stage.scale.set(scale);\n    // update shapes scale\n    const setChildrenScale = (children: DisplayObject[]) => {\n      children.forEach((child) => {\n        if (child instanceof ShapeGraphics) {\n          // eslint-disable-next-line no-param-reassign\n          child.shape.scale = scale;\n        } else if (child instanceof Container) {\n          setChildrenScale(child.children);\n        }\n      });\n    };\n    setChildrenScale(this.shapesLayer.children);\n    // update assist layer\n    this.drawAuxiliaryLines();\n\n    this.emit(EventAction.SCALE_CHANGED, scale, this);\n  }\n\n  /**\n   * is right button clicked\n   * @private\n   */\n  private _rightClicked = false;\n\n  /**\n   * click position when right button clicked\n   * @private\n   */\n  private _rightClickPoint: Point | null = null;\n\n  /**\n   * stage position when right button clicked\n   * @private\n   */\n  private _rightClickPosition: Point | null = null;\n\n  /**\n   * is view selected\n   */\n  selected = false;\n\n  /**\n   * view selected changed\n   */\n  private _selectedChanged = false;\n\n  /**\n   * is view hovered\n   */\n  hovered = false;\n\n  /**\n   * hovered shape\n   */\n  hoveredShape?: Shape<unknown>;\n\n  /**\n   * selector path\n   */\n  selectorPath = new Graphics();\n\n  /**\n   * points in selector path\n   */\n  selectorPathPoints: Point[] = [];\n\n  /**\n   * is selecting\n   * @private\n   */\n  private _selecting = false;\n\n  constructor({ id, enableReview, enableCheck, auxiliaryLines }: ViewOptions) {\n    super();\n    this.id = id || uuidv4();\n\n    this.interactive = true;\n    this.on('pointerover', () => {\n      this.hovered = true;\n    });\n    this.on('pointerout', () => {\n      this.hovered = false;\n    });\n    this.on('pointerdown', this.processPointerDown);\n    this.on('pointermove', this.processPointerMove);\n    this.on('pointerup', this.processPointerUp);\n    this.on('pointerupoutside', this.processPointerUp);\n    this.on('pointerout', this.processPointerOut);\n\n    // this.area.interactive = true;\n    // this.area.on('pointerdown', this.processBlankPointerDown);\n\n    this.shapesLayer.sortableChildren = true;\n    this.stage.addChild(this.shapesLayer);\n    if (auxiliaryLines) {\n      this.auxiliaryLines = auxiliaryLines;\n      this.assistLayer = new Container();\n      this.assistLayer.interactive = false;\n      this.stage.addChild(this.assistLayer);\n    }\n    if (enableReview) {\n      this.reviewLayer = new Container();\n      this.stage.addChild(this.reviewLayer);\n    }\n    if (enableCheck) {\n      this.checkLayer = new Container();\n      this.checkLayer.interactive = false;\n      this.stage.addChild(this.checkLayer);\n    }\n\n    this.stage.addChildAt(this.image, 0);\n    this.addChild(this.stage);\n    // this.addChildAt(this.area, 0);\n  }\n\n  /**\n   * process pointer down\n   * @param e\n   */\n  processPointerDown = (e: InteractionEvent) => {\n    const selected = this.selected;\n    this.emit(EventAction.SELECTED, e.data.originalEvent, this);\n    this._selectedChanged = this.selected !== selected;\n\n    if (this.imageLoadError) {\n      return;\n    }\n\n    if (e.data.button === 2) {\n      const point = e.data.getLocalPosition(this);\n      this._rightClicked = true;\n      this._rightClickPoint = point;\n      this._rightClickPosition = this.stage.position.clone();\n      return;\n    }\n\n    const localPoint = e.data.getLocalPosition(this.stage);\n    if (this._selectedChanged && this.hovered) {\n      // if selected changed, should get cursor hovered shape\n      this.hitTest(e.data.global, localPoint, e.data.originalEvent.ctrlKey);\n      if (this.hoveredShape) {\n        // if hovered, mock pointer down event for the shape\n        this.hoveredShape.processPointerDown(e);\n      }\n    }\n    this.emit(EventAction.POINTERDOWN, localPoint, e.data.originalEvent, this);\n  };\n\n  /**\n   * process pointer move\n   * @param e\n   */\n  processPointerMove = (e: InteractionEvent) => {\n    if (this.imageLoadError || !this.selected) {\n      return;\n    }\n\n    if (this._rightClicked && this._rightClickPoint && this._rightClickPosition) {\n      const point = e.data.getLocalPosition(this);\n      const offsetX = point.x - this._rightClickPoint.x;\n      const offsetY = point.y - this._rightClickPoint.y;\n      const x = this._rightClickPosition.x + offsetX;\n      const y = this._rightClickPosition.y + offsetY;\n      this.setStagePosition(x, y);\n      return;\n    }\n\n    if (this._selectedChanged && this.hoveredShape) {\n      // not continue, current is moving shape\n      return;\n    }\n\n    const localPoint = e.data.getLocalPosition(this.stage);\n    if (this._selecting) {\n      this.selectorPathPoints.push(localPoint);\n      this.drawSelectorPath();\n      return;\n    }\n\n    if (this.hovered) {\n      this.hitTest(e.data.global, localPoint, e.data.originalEvent.ctrlKey);\n    }\n  };\n\n  /**\n   * process pointer up\n   */\n  processPointerUp = () => {\n    this.finishSelect();\n    this._rightClicked = false;\n    this._rightClickPoint = null;\n    this._rightClickPosition = null;\n    this._selectedChanged = false;\n  };\n\n  /**\n   * process pointer out\n   */\n  processPointerOut = () => {\n    this.processPointerUp();\n    this.setHoveredShape();\n  };\n\n  /**\n   * process blank pointer down\n   */\n  processBlankPointerDown = (e: InteractionEvent) => {\n    const localPoint = e.data.getLocalPosition(this.stage);\n    this.emit(EventAction.BLANK_POINTERDOWN, localPoint, e.data.originalEvent, this);\n  };\n\n  /**\n   * update position and size\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   */\n  updatePositionAndSize(x: number, y: number, width: number, height: number) {\n    const positionUpdated = this.x !== x || this.y !== y;\n    const sizeUpdated = this.viewWidth !== width || this.viewHeight !== height;\n    this.x = x;\n    this.y = y;\n    this.viewWidth = width;\n    this.viewHeight = height;\n    this.hitArea = new Rectangle(0, 0, width, height);\n    // if (sizeUpdated) {\n    //   this.area\n    //     .beginFill(0x000000)\n    //     .drawRect(0, 0, width, height)\n    //     .endFill();\n    // }\n    if (positionUpdated || sizeUpdated) {\n      this.mask = new Graphics()\n        .beginFill(0x000000)\n        .drawRect(x, y, width, height)\n        .endFill();\n    }\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.stage.x,\n      y: this.stage.y,\n    };\n  }\n\n  /**\n   * set stage posistion\n   * @param x\n   * @param y\n   */\n  setStagePosition(x: number, y: number) {\n    this.stage.x = x;\n    this.stage.y = y;\n    this.emit(EventAction.POSITION_CHANGED, { x, y }, this);\n  }\n\n  /**\n   * set image\n   * @param texture\n   */\n  setImage(texture: Texture) {\n    this.image.cacheAsBitmap = false;\n    if (this.image.texture) {\n      this.image.texture.destroy(true);\n    }\n    this.image.texture = texture;\n    this.image.cacheAsBitmap = true;\n    this.rotate();\n    if (!this.firstLoaded) {\n      this.firstLoaded = true;\n      this.fitImageToView();\n    }\n  }\n\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape?: Shape<unknown>) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape && !this.hoveredShape.destroyed) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n\n  /**\n   * hit test\n   * @param point\n   * @param localPoint\n   * @param ctrlKey\n   */\n  hitTest(point: Point, localPoint: Point, ctrlKey = false) {\n    const { intersection, snappingPoint } = hitTesting(point, localPoint, this.shapesLayer.children);\n    if (!ctrlKey) {\n      this.setHoveredShape(intersection);\n      this.shapesLayer.setSnappingPoint(snappingPoint);\n    } else {\n      this.setHoveredShape();\n      this.shapesLayer.setSnappingPoint(null);\n    }\n  }\n\n  /**\n   * get all shapes in stage\n   */\n  getAllShapes() {\n    const getShapes = (children: DisplayObject[]) => {\n      let shapes: Shape<ShapeData>[] = [];\n      for (let i = 0; i < children.length; i += 1) {\n        const child = children[i];\n        if (child.visible) {\n          if (child instanceof ShapeGraphics) {\n            if (child.shape.finished) {\n              shapes.push(child.shape);\n            }\n          } else if (child instanceof Container) {\n            shapes = [...shapes, ...getShapes(child.children)];\n          }\n        }\n      }\n      return shapes;\n    };\n    return getShapes(this.shapesLayer.children);\n  }\n\n  /**\n   * start select\n   */\n  startSelect = () => {\n    this._selecting = true;\n    this.stage.addChild(this.selectorPath);\n  };\n\n  /**\n   * finish select\n   */\n  finishSelect() {\n    if (this._selecting && this.selectorPathPoints.length > 0) {\n      // check selected\n      const selectorPathData = [[[...this.selectorPathPoints].map((p) => [p.x, p.y] as [number, number])]];\n      const selectorPathBounds = this.selectorPath.getLocalBounds();\n      const allShapes = this.getAllShapes();\n      const intersections = findIntersections(selectorPathData, selectorPathBounds, ShapeType.POLYGON, allShapes);\n      this.emit(EventAction.SHAPES_SELECTED, intersections.map((i) => i.uid), this);\n\n      const shapePointsMap: { [shapeId: string]: number[] } = {};\n      for (let i = 0; i < intersections.length; i += 1) {\n        const intersection = intersections[i];\n        if (intersection.shapeType === ShapeType.POLYGON || intersection.shapeType === ShapeType.LINE || intersection.shapeType === ShapeType.ARROW) {\n          // check points selected\n          const selectorPathArea = new Polygon(this.selectorPathPoints);\n          const { points } = (intersection as TPolygon | TLine);\n          const selectedPointsIndex = [];\n          for (let j = 0; j < points.length; j += 1) {\n            if (selectorPathArea.contains(points[j].x, points[j].y)) {\n              selectedPointsIndex.push(j);\n            }\n          }\n          if (selectedPointsIndex.length > 0) {\n            shapePointsMap[intersection.uid] = selectedPointsIndex;\n          }\n        }\n      }\n      if (Object.keys(shapePointsMap).length > 0) {\n        this.emit(EventAction.POINTS_SELECTED, shapePointsMap, this);\n      }\n    }\n    this._selecting = false;\n    this.stage.removeChild(this.selectorPath);\n    this.selectorPathPoints = [];\n    this.drawSelectorPath();\n  }\n\n  /**\n   * draw path\n   */\n  drawSelectorPath() {\n    this.selectorPath.clear();\n    if (this.selectorPathPoints.length > 0) {\n      this.selectorPath.lineStyle(2 / this.viewScale, 0xFF0000);\n      this.selectorPath.moveTo(this.selectorPathPoints[0].x, this.selectorPathPoints[0].y);\n      for (let i = 1; i < this.selectorPathPoints.length; i += 1) {\n        this.selectorPath.lineTo(this.selectorPathPoints[i].x, this.selectorPathPoints[i].y);\n      }\n    }\n  }\n\n  /**\n   * rotate\n   */\n  rotate = () => {\n    if (this.image && !this.imageLoadError) {\n      // set pivot\n      const { width, height } = this.image;\n      this.image.pivot.set(width / 2, height / 2);\n\n      // set position\n      let px = width / 2;\n      let py = height / 2;\n      if (this.imageRotation % Math.PI !== 0) {\n        px = height / 2;\n        py = width / 2;\n      }\n      const { x: ox, y: oy } = this.image.position;\n      this.image.position.set(px, py);\n      const offsetX = px - ox;\n      const offsetY = py - oy;\n\n      // set rotation\n      this.image.rotation = this.imageRotation;\n\n      // update stage position\n      const { x, y } = this.getStagePosition();\n      this.setStagePosition(x - offsetX * this.viewScale, y - offsetY * this.viewScale);\n    }\n  };\n\n  /**\n   * zoom\n   * @param event\n   * @param zoomPoint\n   */\n  zoom = (event: WheelEvent, zoomPoint: Point) => {\n    if (this.imageLoadError || !this.selected || !this.hovered) {\n      return false;\n    }\n    event.stopPropagation();\n    const zoomPointX = zoomPoint.x - this.position.x;\n    const zoomPointY = zoomPoint.y - this.position.y;\n    let newZoom = event.deltaY > 0 ? this.viewZoom / 1.1 : this.viewZoom * 1.1;\n    newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n    const zoomScale = newZoom / this.viewZoom;\n    const { x, y } = this.getStagePosition();\n    this.setStagePosition(zoomPointX - (zoomPointX - x) * zoomScale, zoomPointY - (zoomPointY - y) * zoomScale);\n    this.viewZoom = newZoom;\n    this.viewScale *= zoomScale;\n    return true;\n  };\n\n  /**\n   * zoom to provided scale\n   * @param scale\n   */\n  zoomTo = (scale: number) => {\n    if (this.imageLoadError) {\n      return;\n    }\n    const centerX = this.viewWidth / 2;\n    const centerY = this.viewHeight / 2;\n    let newZoom = this.viewZoom * (scale / this.viewScale);\n    newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n    const zoomScale = newZoom / this.viewZoom;\n    const { x, y } = this.getStagePosition();\n    this.setStagePosition(centerX - (centerX - x) * zoomScale, centerY - (centerY - y) * zoomScale);\n    this.viewZoom = newZoom;\n    this.viewScale *= zoomScale;\n  };\n\n  /**\n   * fit image to canvas\n   */\n  fitImageToView = () => {\n    if (this.imageLoadError) {\n      return;\n    }\n    const { width, height } = this.image;\n    let imageWidth = width;\n    let imageHeight = height;\n    if (this.imageRotation % Math.PI !== 0) {\n      imageWidth = height;\n      imageHeight = width;\n    }\n    const viewRatio = this.viewWidth / this.viewHeight;\n    const imgRatio = imageWidth / imageHeight;\n    const scale = (viewRatio < imgRatio ? this.viewWidth / imageWidth : this.viewHeight / imageHeight) * 0.98;\n    this.setStagePosition((this.viewWidth - scale * imageWidth) / 2, (this.viewHeight - scale * imageHeight) / 2);\n    this.viewScale = scale;\n    this.viewZoom = 1;\n  };\n\n  /**\n   * fit shape to canvas\n   * @param bbox\n   * @param percentage\n   */\n  fitShapeToView = (bbox: { left: number; top: number; right: number; bottom: number }, percentage = 0.98) => {\n    if (this.imageLoadError) {\n      return;\n    }\n    const { left, top, right, bottom } = bbox;\n    const width = right - left;\n    const height = bottom - top;\n    if (width !== 0 && height !== 0) {\n      const oldViewScale = this.viewScale;\n      const viewRatio = this.viewWidth / this.viewHeight;\n      const ratio = width / height;\n      let scale = (viewRatio < ratio ? this.viewWidth / width : this.viewHeight / height) * percentage;\n      let zoomScale = scale / oldViewScale;\n      let zoomLevel = Math.max(Math.min(this.viewZoom * zoomScale, ZOOM_MAX), ZOOM_MIN);\n      if (zoomLevel < 1) {\n        zoomLevel = 1;\n        zoomScale = zoomLevel / this.viewZoom;\n        scale = zoomScale * oldViewScale;\n      }\n      this.setStagePosition(this.viewWidth / 2 - scale * (left + width / 2), this.viewHeight / 2 - scale * (top + height / 2));\n      this.viewScale = scale;\n      this.viewZoom *= zoomScale;\n    }\n  };\n\n  /**\n   * draw auxiliary lines\n   */\n  drawAuxiliaryLines() {\n    if (!this.assistLayer || !this.auxiliaryLines) {\n      return;\n    }\n\n    this.assistLayer.removeChildren();\n    if (!this.imageLoadError) {\n      const graphics = new Graphics();\n\n      const { width, height } = this.image;\n      let imageWidth = width;\n      let imageHeight = height;\n      if (this.imageRotation % Math.PI !== 0) {\n        imageWidth = height;\n        imageHeight = width;\n      }\n\n      const { left, top, right, bottom } = this.auxiliaryLines;\n      for (let i = 0; i < left.length; i += 1) {\n        const { positionType, positionValue, color } = left[i];\n        const x = positionType === 'percentage' ? imageWidth * (positionValue / 100) : positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(x, 0);\n        graphics.lineTo(x, imageHeight);\n      }\n      for (let i = 0; i < top.length; i += 1) {\n        const { positionType, positionValue, color } = top[i];\n        const y = positionType === 'percentage' ? imageHeight * (positionValue / 100) : positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(0, y);\n        graphics.lineTo(imageWidth, y);\n      }\n      for (let i = 0; i < right.length; i += 1) {\n        const { positionType, positionValue, color } = right[i];\n        const x = positionType === 'percentage' ? imageWidth * (1 - positionValue / 100) : imageWidth - positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(x, 0);\n        graphics.lineTo(x, imageHeight);\n      }\n      for (let i = 0; i < bottom.length; i += 1) {\n        const { positionType, positionValue, color } = bottom[i];\n        const y = positionType === 'percentage' ? imageHeight * (1 - positionValue / 100) : imageHeight - positionValue;\n        graphics.lineStyle(1 / this.viewScale, color);\n        graphics.moveTo(0, y);\n        graphics.lineTo(imageWidth, y);\n      }\n\n      this.assistLayer.addChild(graphics);\n    }\n  }\n}\n\nexport default View;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}