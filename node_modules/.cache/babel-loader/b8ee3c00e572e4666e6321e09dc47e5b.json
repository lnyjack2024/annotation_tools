{"ast":null,"code":"/*!\n * @pixi/canvas-sprite-tiling - v6.2.2\n * Compiled Wed, 26 Jan 2022 16:23:27 UTC\n *\n * @pixi/canvas-sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { TilingSprite } from '@pixi/sprite-tiling';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasRenderTarget } from '@pixi/utils';\nimport { Matrix, Point } from '@pixi/math';\nvar worldMatrix = new Matrix();\nvar patternMatrix = new Matrix();\nvar patternRect = [new Point(), new Point(), new Point(), new Point()];\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n  var texture = this._texture;\n  if (!texture.baseTexture.valid) {\n    return;\n  }\n  var context = renderer.context;\n  var transform = this.worldTransform;\n  var baseTexture = texture.baseTexture;\n  var source = baseTexture.getDrawableSource();\n  var baseTextureResolution = baseTexture.resolution;\n  // create a nice shiny pattern!\n  if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {\n    this._textureID = this._texture._updateID;\n    // cut an object from a spritesheet..\n    var tempCanvas = new CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution);\n    // Tint the tiling sprite\n    if (this.tint !== 0xFFFFFF) {\n      this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);\n      tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n    } else {\n      tempCanvas.context.drawImage(source, -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n    }\n    this._cachedTint = this.tint;\n    this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n  }\n  // set context state..\n  context.globalAlpha = this.worldAlpha;\n  renderer.setBlendMode(this.blendMode);\n  this.tileTransform.updateLocalTransform();\n  var lt = this.tileTransform.localTransform;\n  var W = this._width;\n  var H = this._height;\n  /*\n   * # Implementation Notes\n   *\n   * The tiling transform is not simply a transform on the tiling sprite's local space. If that\n   * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform\n   * on the \"pattern\" coordinates each vertex is assigned.\n   *\n   * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which\n   * is defined as:\n   *\n   * Pattern_Space = Local_Space x inverse(tileTransform)\n   *\n   * In other words,\n   * Local_Space = Pattern_Space x tileTransform\n   *\n   * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.\n   * In other words, the pattern will always \"originate\" from (0, 0) in the space we draw in.\n   *\n   * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes\n   * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.\n   *\n   * ## uvRespectAnchor\n   *\n   * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags\n   * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without\n   * loss of generality: If uvRespectAnchor = true, then\n   *\n   * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means \"maps to\")\n   *\n   * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That\n   * means the invariant under all other transforms are the origins)\n   *\n   * Otherwise,\n   *\n   * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)\n   *\n   * Here the mapping is provided by the tileTransfrom PLUS some \"shift\". This shift is done POST-tileTransform. The shift\n   * is equal to the position of the top-left corner of the tiling sprite in its local space.\n   *\n   * Hence,\n   *\n   * Local_Space = Pattern_Space x tileTransform x shiftTransform\n   */\n  // worldMatrix is used to convert from pattern space to world space.\n  //\n  // worldMatrix = tileTransform x shiftTransform x worldTransfrom\n  //             = patternMatrix x worldTransform\n  worldMatrix.identity();\n  // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space\n  // and this matrix is used to inverse-map the local space vertices into it.\n  //\n  // patternMatrix = tileTransfrom x shiftTransform\n  patternMatrix.copyFrom(lt);\n  // Apply shiftTransform into patternMatrix. See $1.1\n  if (!this.uvRespectAnchor) {\n    patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);\n  }\n  patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n  worldMatrix.prepend(patternMatrix);\n  worldMatrix.prepend(transform);\n  renderer.setContextTransform(worldMatrix);\n  // Fill the pattern!\n  context.fillStyle = this._canvasPattern;\n  // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)\n  var lx = this.anchor.x * -W;\n  var ly = this.anchor.y * -H;\n  // Set pattern rect in local space first.\n  patternRect[0].set(lx, ly);\n  patternRect[1].set(lx + W, ly);\n  patternRect[2].set(lx + W, ly + H);\n  patternRect[3].set(lx, ly + H);\n  // Map patternRect into pattern space.\n  for (var i = 0; i < 4; i++) {\n    patternMatrix.applyInverse(patternRect[i], patternRect[i]);\n  }\n  /*\n   * # Note about verification of theory\n   *\n   * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of\n   * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map\n   * to the top-left corner of the tiling sprite in its local space.\n   */\n  context.beginPath();\n  context.moveTo(patternRect[0].x, patternRect[0].y);\n  for (var i = 1; i < 4; i++) {\n    context.lineTo(patternRect[i].x, patternRect[i].y);\n  }\n  context.closePath();\n  context.fill();\n};","map":{"version":3,"sources":["../../src/TilingSprite.ts"],"names":[],"mappings":"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","sourcesContent":["import { TilingSprite } from '@pixi/sprite-tiling';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasRenderTarget } from '@pixi/utils';\nimport { Matrix, Point } from '@pixi/math';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\nconst worldMatrix = new Matrix();\nconst patternMatrix = new Matrix();\nconst patternRect = [new Point(), new Point(), new Point(), new Point()];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    const texture = this._texture;\n\n    if (!texture.baseTexture.valid)\n    {\n        return;\n    }\n\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    const baseTexture = texture.baseTexture;\n    const source = baseTexture.getDrawableSource();\n    const baseTextureResolution = baseTexture.resolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint)\n    {\n        this._textureID = this._texture._updateID;\n        // cut an object from a spritesheet..\n        const tempCanvas = new CanvasRenderTarget(texture._frame.width,\n            texture._frame.height,\n            baseTextureResolution);\n\n        // Tint the tiling sprite\n        if (this.tint !== 0xFFFFFF)\n        {\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint) as HTMLCanvasElement;\n            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(source,\n                -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n        }\n        this._cachedTint = this.tint;\n        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    renderer.setBlendMode(this.blendMode);\n\n    this.tileTransform.updateLocalTransform();\n    const lt = this.tileTransform.localTransform;\n    const W = this._width;\n    const H = this._height;\n\n    /*\n     * # Implementation Notes\n     *\n     * The tiling transform is not simply a transform on the tiling sprite's local space. If that\n     * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform\n     * on the \"pattern\" coordinates each vertex is assigned.\n     *\n     * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which\n     * is defined as:\n     *\n     * Pattern_Space = Local_Space x inverse(tileTransform)\n     *\n     * In other words,\n     * Local_Space = Pattern_Space x tileTransform\n     *\n     * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.\n     * In other words, the pattern will always \"originate\" from (0, 0) in the space we draw in.\n     *\n     * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes\n     * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.\n     *\n     * ## uvRespectAnchor\n     *\n     * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags\n     * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without\n     * loss of generality: If uvRespectAnchor = true, then\n     *\n     * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means \"maps to\")\n     *\n     * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That\n     * means the invariant under all other transforms are the origins)\n     *\n     * Otherwise,\n     *\n     * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)\n     *\n     * Here the mapping is provided by the tileTransfrom PLUS some \"shift\". This shift is done POST-tileTransform. The shift\n     * is equal to the position of the top-left corner of the tiling sprite in its local space.\n     *\n     * Hence,\n     *\n     * Local_Space = Pattern_Space x tileTransform x shiftTransform\n     */\n\n    // worldMatrix is used to convert from pattern space to world space.\n    //\n    // worldMatrix = tileTransform x shiftTransform x worldTransfrom\n    //             = patternMatrix x worldTransform\n    worldMatrix.identity();\n\n    // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space\n    // and this matrix is used to inverse-map the local space vertices into it.\n    //\n    // patternMatrix = tileTransfrom x shiftTransform\n    patternMatrix.copyFrom(lt);\n\n    // Apply shiftTransform into patternMatrix. See $1.1\n    if (!this.uvRespectAnchor)\n    {\n        patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);\n    }\n\n    patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n    worldMatrix.prepend(patternMatrix);\n    worldMatrix.prepend(transform);\n\n    renderer.setContextTransform(worldMatrix);\n\n    // Fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)\n    const lx = this.anchor.x * -W;\n    const ly = this.anchor.y * -H;\n\n    // Set pattern rect in local space first.\n    patternRect[0].set(lx, ly);\n    patternRect[1].set(lx + W, ly);\n    patternRect[2].set(lx + W, ly + H);\n    patternRect[3].set(lx, ly + H);\n\n    // Map patternRect into pattern space.\n    for (let i = 0; i < 4; i++)\n    {\n        patternMatrix.applyInverse(patternRect[i], patternRect[i]);\n    }\n\n    /*\n     * # Note about verification of theory\n     *\n     * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of\n     * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map\n     * to the top-left corner of the tiling sprite in its local space.\n     */\n\n    context.beginPath();\n    context.moveTo(patternRect[0].x, patternRect[0].y);\n\n    for (let i = 1; i < 4; i++)\n    {\n        context.lineTo(patternRect[i].x, patternRect[i].y);\n    }\n\n    context.closePath();\n    context.fill();\n};\n"]},"metadata":{},"sourceType":"module"}