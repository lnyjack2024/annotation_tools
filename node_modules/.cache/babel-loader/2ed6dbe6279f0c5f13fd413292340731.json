{"ast":null,"code":"import { v4 as uuid } from 'uuid';\nimport { setStyle } from './utils';\n\n/**\n * The `CanvasEntry` class represents an element consisting of a wave `canvas`\n * and an (optional) progress wave `canvas`.\n *\n * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to\n * render a waveform, depending on the zoom level.\n */\nexport default class CanvasEntry {\n  constructor() {\n    /**\n     * The wave node\n     *\n     * @type {HTMLCanvasElement}\n     */\n    this.wave = null;\n    /**\n     * The wave canvas rendering context\n     *\n     * @type {CanvasRenderingContext2D}\n     */\n    this.waveCtx = null;\n    /**\n     * The (optional) progress wave node\n     *\n     * @type {HTMLCanvasElement}\n     */\n    this.progress = null;\n    /**\n     * The (optional) progress wave canvas rendering context\n     *\n     * @type {CanvasRenderingContext2D}\n     */\n    this.progressCtx = null;\n    /**\n     * Start of the area the canvas should render, between 0 and 1\n     *\n     * @type {number}\n     */\n    this.start = 0;\n    /**\n     * End of the area the canvas should render, between 0 and 1\n     *\n     * @type {number}\n     */\n    this.end = 1;\n    /**\n     * Unique identifier for this entry\n     *\n     * @type {string}\n     */\n    this.id = uuid();\n    /**\n     * Canvas 2d context attributes\n     *\n     * @type {object}\n     */\n    this.canvasContextAttributes = {};\n\n    /**\n     * has progress\n     *\n     * @type {boolean|undefined}\n     */\n    this.hasProgressCanvas = false;\n    this.halfPixel = 1;\n  }\n\n  /**\n     * Store the wave canvas element and create the 2D rendering context\n     *\n     * @param {HTMLCanvasElement} element The wave `canvas` element.\n     */\n  initWave(element) {\n    this.wave = element;\n    this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);\n  }\n\n  /**\n     * Store the progress wave canvas element and create the 2D rendering\n     * context\n     *\n     * @param {HTMLCanvasElement} element The progress wave `canvas` element.\n     */\n  initProgress(element) {\n    this.progress = element;\n    this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);\n  }\n\n  /**\n     * Update the dimensions\n     *\n     * @param {number} elementWidth Width of the entry\n     * @param {number} elementHeight Height of the entry\n     * @param {number} width The new width of the element\n     * @param {number} height The new height of the element\n     */\n  updateDimensions(elementWidth, elementHeight, width, height) {\n    // where the canvas starts and ends in the waveform, represented as a\n    // decimal between 0 and 1\n    this.start = this.wave.offsetLeft / elementWidth || 0;\n    this.end = this.start + elementWidth / elementWidth;\n\n    // set wave canvas dimensions\n    this.wave.width = width;\n    this.wave.height = height;\n    setStyle(this.wave, {\n      width: `${elementWidth}px`,\n      height: `${elementHeight}px`\n    });\n    if (this.hasProgressCanvas) {\n      // set progress canvas dimensions\n      this.progress.width = width;\n      this.progress.height = height;\n    }\n  }\n\n  /**\n   * Clear the wave and progress rendering contexts\n   */\n  clearWave() {\n    // wave\n    this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height);\n\n    // progress\n    if (this.hasProgressCanvas) {\n      this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);\n    }\n  }\n\n  /**\n     * Set the fill styles for wave and progress\n     *\n     * @param {string} waveColor Fill color for the wave canvas\n     * @param {?string} progressColor Fill color for the progress canvas\n     */\n  setFillStyles(waveColor, progressColor) {\n    this.waveCtx.fillStyle = waveColor;\n    if (this.hasProgressCanvas) {\n      this.progressCtx.fillStyle = progressColor;\n    }\n  }\n\n  /**\n   * Set the canvas transforms for wave and progress\n   *\n   * @param {boolean} vertical Whether to render vertically\n   */\n  applyCanvasTransforms(vertical) {\n    if (vertical) {\n      // Reflect the waveform across the line y = -x\n      this.waveCtx.setTransform(0, 1, 1, 0, 0, 0);\n      if (this.hasProgressCanvas) {\n        this.progressCtx.setTransform(0, 1, 1, 0, 0, 0);\n      }\n    }\n  }\n\n  /**\n   * Draw a rectangle for wave and progress\n   *\n   * @param {number} x X start position\n   * @param {number} y Y start position\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   */\n  fillRects(x, y, width, height, radius) {\n    this.fillRectToContext(this.waveCtx, x, y, width, height, radius);\n    if (this.hasProgressCanvas) {\n      this.fillRectToContext(this.progressCtx, x, y, width, height, radius);\n    }\n  }\n\n  /**\n   * Draw the actual rectangle on a `canvas` element\n   *\n   * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas\n   * @param {number} x X start position\n   * @param {number} y Y start position\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   */\n  fillRectToContext(ctx, x, y, width, height, radius) {\n    if (!ctx) {\n      return;\n    }\n    if (radius) {\n      this.drawRoundedRect(ctx, x, y, width, height, radius);\n    } else {\n      ctx.fillRect(x, y, width, height);\n    }\n  }\n\n  /**\n   * Draw a rounded rectangle on Canvas\n   *\n   * @param {CanvasRenderingContext2D} ctx Canvas context\n   * @param {number} x X-position of the rectangle\n   * @param {number} y Y-position of the rectangle\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   *\n   * @return {void}\n   * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)\n   */\n  // eslint-disable-next-line class-methods-use-this\n  drawRoundedRect(ctx, x, y, width, _height, radius) {\n    if (_height === 0) {\n      return;\n    }\n    let height = _height;\n    // peaks are float values from -1 to 1. Use absolute height values in\n    // order to correctly calculate rounded rectangle coordinates\n    if (height < 0) {\n      height *= -1;\n      y -= height;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  /**\n   * Render the actual wave and progress lines\n   *\n   * @param {number[]} peaks Array with peaks data\n   * @param {number} absmax Maximum peak value (absolute)\n   * @param {number} halfH Half the height of the waveform\n   * @param {number} offsetY Offset to the top\n   */\n  drawLines(peaks, absmax, halfH, offsetY) {\n    this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY);\n    if (this.hasProgressCanvas) {\n      this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY);\n    }\n  }\n\n  /**\n   *\n   * @param {string} text\n   * @param {number} x\n   * @param {number} y\n   * @param {number} fontSize\n   */\n  drawText(text, x, y, fontSize) {\n    this.waveCtx.beginPath();\n    this.waveCtx.font = `${fontSize}px sans-serif`;\n    this.waveCtx.fillText(text, x, y);\n    this.waveCtx.stroke();\n    this.waveCtx.closePath();\n  }\n\n  /**\n   * Render the actual waveform line on a `canvas` element\n   *\n   * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas\n   * @param {number[]} peaks Array with peaks data\n   * @param {number} absmax Maximum peak value (absolute)\n   * @param {number} halfH Half the height of the waveform\n   * @param {number} offsetY Offset to the top\n   * @param {number} start The x-offset of the beginning of the area that\n   * should be rendered\n   * @param {number} end The x-offset of the end of the area that\n   * should be rendered\n   */\n  drawLineToContext(ctx, peaks, absmax, halfH, offsetY) {\n    if (!ctx) {\n      return;\n    }\n    const length = peaks.length / 2;\n    const first = Math.round(length * this.start);\n\n    // use one more peak value to make sure we join peaks at ends -- unless,\n    // of course, this is the last canvas\n    const last = Math.round(length * this.end) + 1;\n    const canvasStart = first;\n    const canvasEnd = last;\n    const scale = this.wave.width / (canvasEnd - canvasStart - 1);\n\n    // optimization\n    const halfOffset = halfH + offsetY;\n    const absmaxHalf = absmax / halfH;\n    ctx.beginPath();\n    ctx.moveTo((canvasStart - first) * scale, halfOffset);\n    ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));\n    let i;\n    let peak;\n    let h;\n    for (i = canvasStart; i < canvasEnd; i += 1) {\n      peak = peaks[2 * i] || 0;\n      h = Math.round(peak / absmaxHalf);\n      ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);\n    }\n\n    // draw the bottom edge going backwards, to make a single\n    // closed hull to fill\n    let j = canvasEnd - 1;\n    for (j; j >= canvasStart; j -= 1) {\n      peak = peaks[2 * j + 1] || 0;\n      h = Math.round(peak / absmaxHalf);\n      ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);\n    }\n    ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  /**\n     * Destroys this entry\n     */\n  destroy() {\n    this.waveCtx = null;\n    this.wave = null;\n    this.progressCtx = null;\n    this.progress = null;\n  }\n\n  /**\n   * Return image data of the wave `canvas` element\n   *\n   * When using a `type` of `'blob'`, this will return a `Promise` that\n   * resolves with a `Blob` instance.\n   *\n   * @param {string} format='image/png' An optional value of a format type.\n   * @param {number} quality=0.92 An optional value between 0 and 1.\n   * @param {string} type='dataURL' Either 'dataURL' or 'blob'.\n   * @return {string|Promise} When using the default `'dataURL'` `type` this\n   * returns a data URL. When using the `'blob'` `type` this returns a\n   * `Promise` that resolves with a `Blob` instance.\n   */\n  getImage(format, quality, type) {\n    if (type === 'blob') {\n      return new Promise(resolve => {\n        this.wave.toBlob(resolve, format, quality);\n      });\n    }\n    if (type === 'dataURL') {\n      return this.wave.toDataURL(format, quality);\n    }\n  }\n}","map":{"version":3,"names":["v4","uuid","setStyle","CanvasEntry","constructor","wave","waveCtx","progress","progressCtx","start","end","id","canvasContextAttributes","hasProgressCanvas","halfPixel","initWave","element","getContext","initProgress","updateDimensions","elementWidth","elementHeight","width","height","offsetLeft","clearWave","clearRect","canvas","setFillStyles","waveColor","progressColor","fillStyle","applyCanvasTransforms","vertical","setTransform","fillRects","x","y","radius","fillRectToContext","ctx","drawRoundedRect","fillRect","_height","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","drawLines","peaks","absmax","halfH","offsetY","drawLineToContext","drawText","text","fontSize","font","fillText","stroke","length","first","Math","round","last","canvasStart","canvasEnd","scale","halfOffset","absmaxHalf","i","peak","h","j","destroy","getImage","format","quality","type","Promise","resolve","toBlob","toDataURL"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/common/Wave/canvasentry.js"],"sourcesContent":["import { v4 as uuid } from 'uuid';\nimport { setStyle } from './utils';\n\n/**\n * The `CanvasEntry` class represents an element consisting of a wave `canvas`\n * and an (optional) progress wave `canvas`.\n *\n * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to\n * render a waveform, depending on the zoom level.\n */\nexport default class CanvasEntry {\n  constructor() {\n    /**\n     * The wave node\n     *\n     * @type {HTMLCanvasElement}\n     */\n    this.wave = null;\n    /**\n     * The wave canvas rendering context\n     *\n     * @type {CanvasRenderingContext2D}\n     */\n    this.waveCtx = null;\n    /**\n     * The (optional) progress wave node\n     *\n     * @type {HTMLCanvasElement}\n     */\n    this.progress = null;\n    /**\n     * The (optional) progress wave canvas rendering context\n     *\n     * @type {CanvasRenderingContext2D}\n     */\n    this.progressCtx = null;\n    /**\n     * Start of the area the canvas should render, between 0 and 1\n     *\n     * @type {number}\n     */\n    this.start = 0;\n    /**\n     * End of the area the canvas should render, between 0 and 1\n     *\n     * @type {number}\n     */\n    this.end = 1;\n    /**\n     * Unique identifier for this entry\n     *\n     * @type {string}\n     */\n    this.id = uuid();\n    /**\n     * Canvas 2d context attributes\n     *\n     * @type {object}\n     */\n    this.canvasContextAttributes = {};\n\n    /**\n     * has progress\n     *\n     * @type {boolean|undefined}\n     */\n    this.hasProgressCanvas = false;\n\n    this.halfPixel = 1;\n  }\n\n  /**\n     * Store the wave canvas element and create the 2D rendering context\n     *\n     * @param {HTMLCanvasElement} element The wave `canvas` element.\n     */\n  initWave(element) {\n    this.wave = element;\n    this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);\n  }\n\n  /**\n     * Store the progress wave canvas element and create the 2D rendering\n     * context\n     *\n     * @param {HTMLCanvasElement} element The progress wave `canvas` element.\n     */\n  initProgress(element) {\n    this.progress = element;\n    this.progressCtx = this.progress.getContext(\n      '2d',\n      this.canvasContextAttributes\n    );\n  }\n\n  /**\n     * Update the dimensions\n     *\n     * @param {number} elementWidth Width of the entry\n     * @param {number} elementHeight Height of the entry\n     * @param {number} width The new width of the element\n     * @param {number} height The new height of the element\n     */\n  updateDimensions(elementWidth, elementHeight, width, height) {\n    // where the canvas starts and ends in the waveform, represented as a\n    // decimal between 0 and 1\n    this.start = this.wave.offsetLeft / elementWidth || 0;\n    this.end = this.start + elementWidth / elementWidth;\n\n    // set wave canvas dimensions\n    this.wave.width = width;\n    this.wave.height = height;\n    setStyle(this.wave, {\n      width: `${elementWidth}px`,\n      height: `${elementHeight}px`,\n    });\n\n    if (this.hasProgressCanvas) {\n      // set progress canvas dimensions\n      this.progress.width = width;\n      this.progress.height = height;\n    }\n  }\n\n  /**\n   * Clear the wave and progress rendering contexts\n   */\n  clearWave() {\n    // wave\n    this.waveCtx.clearRect(\n      0,\n      0,\n      this.waveCtx.canvas.width,\n      this.waveCtx.canvas.height\n    );\n\n    // progress\n    if (this.hasProgressCanvas) {\n      this.progressCtx.clearRect(\n        0,\n        0,\n        this.progressCtx.canvas.width,\n        this.progressCtx.canvas.height\n      );\n    }\n  }\n\n  /**\n     * Set the fill styles for wave and progress\n     *\n     * @param {string} waveColor Fill color for the wave canvas\n     * @param {?string} progressColor Fill color for the progress canvas\n     */\n  setFillStyles(waveColor, progressColor) {\n    this.waveCtx.fillStyle = waveColor;\n\n    if (this.hasProgressCanvas) {\n      this.progressCtx.fillStyle = progressColor;\n    }\n  }\n\n  /**\n   * Set the canvas transforms for wave and progress\n   *\n   * @param {boolean} vertical Whether to render vertically\n   */\n  applyCanvasTransforms(vertical) {\n    if (vertical) {\n      // Reflect the waveform across the line y = -x\n      this.waveCtx.setTransform(0, 1, 1, 0, 0, 0);\n\n      if (this.hasProgressCanvas) {\n        this.progressCtx.setTransform(0, 1, 1, 0, 0, 0);\n      }\n    }\n  }\n\n  /**\n   * Draw a rectangle for wave and progress\n   *\n   * @param {number} x X start position\n   * @param {number} y Y start position\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   */\n  fillRects(x, y, width, height, radius) {\n    this.fillRectToContext(this.waveCtx, x, y, width, height, radius);\n\n    if (this.hasProgressCanvas) {\n      this.fillRectToContext(\n        this.progressCtx,\n        x,\n        y,\n        width,\n        height,\n        radius\n      );\n    }\n  }\n\n  /**\n   * Draw the actual rectangle on a `canvas` element\n   *\n   * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas\n   * @param {number} x X start position\n   * @param {number} y Y start position\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   */\n  fillRectToContext(ctx, x, y, width, height, radius) {\n    if (!ctx) {\n      return;\n    }\n\n    if (radius) {\n      this.drawRoundedRect(ctx, x, y, width, height, radius);\n    } else {\n      ctx.fillRect(x, y, width, height);\n    }\n  }\n\n  /**\n   * Draw a rounded rectangle on Canvas\n   *\n   * @param {CanvasRenderingContext2D} ctx Canvas context\n   * @param {number} x X-position of the rectangle\n   * @param {number} y Y-position of the rectangle\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   *\n   * @return {void}\n   * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)\n   */\n  // eslint-disable-next-line class-methods-use-this\n  drawRoundedRect(ctx, x, y, width, _height, radius) {\n    if (_height === 0) {\n      return;\n    }\n    let height = _height;\n    // peaks are float values from -1 to 1. Use absolute height values in\n    // order to correctly calculate rounded rectangle coordinates\n    if (height < 0) {\n      height *= -1;\n      y -= height;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(\n      x + width,\n      y + height,\n      x + width - radius,\n      y + height\n    );\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  /**\n   * Render the actual wave and progress lines\n   *\n   * @param {number[]} peaks Array with peaks data\n   * @param {number} absmax Maximum peak value (absolute)\n   * @param {number} halfH Half the height of the waveform\n   * @param {number} offsetY Offset to the top\n   */\n  drawLines(peaks, absmax, halfH, offsetY) {\n    this.drawLineToContext(\n      this.waveCtx,\n      peaks,\n      absmax,\n      halfH,\n      offsetY,\n    );\n\n    if (this.hasProgressCanvas) {\n      this.drawLineToContext(\n        this.progressCtx,\n        peaks,\n        absmax,\n        halfH,\n        offsetY,\n      );\n    }\n  }\n\n  /**\n   *\n   * @param {string} text\n   * @param {number} x\n   * @param {number} y\n   * @param {number} fontSize\n   */\n  drawText(text, x, y, fontSize) {\n    this.waveCtx.beginPath();\n    this.waveCtx.font = `${fontSize}px sans-serif`;\n    this.waveCtx.fillText(text, x, y);\n    this.waveCtx.stroke();\n    this.waveCtx.closePath();\n  }\n\n  /**\n   * Render the actual waveform line on a `canvas` element\n   *\n   * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas\n   * @param {number[]} peaks Array with peaks data\n   * @param {number} absmax Maximum peak value (absolute)\n   * @param {number} halfH Half the height of the waveform\n   * @param {number} offsetY Offset to the top\n   * @param {number} start The x-offset of the beginning of the area that\n   * should be rendered\n   * @param {number} end The x-offset of the end of the area that\n   * should be rendered\n   */\n  drawLineToContext(ctx, peaks, absmax, halfH, offsetY) {\n    if (!ctx) {\n      return;\n    }\n\n    const length = peaks.length / 2;\n    const first = Math.round(length * this.start);\n\n    // use one more peak value to make sure we join peaks at ends -- unless,\n    // of course, this is the last canvas\n    const last = Math.round(length * this.end) + 1;\n\n    const canvasStart = first;\n    const canvasEnd = last;\n    const scale = this.wave.width / (canvasEnd - canvasStart - 1);\n\n    // optimization\n    const halfOffset = halfH + offsetY;\n    const absmaxHalf = absmax / halfH;\n\n    ctx.beginPath();\n    ctx.moveTo((canvasStart - first) * scale, halfOffset);\n\n    ctx.lineTo(\n      (canvasStart - first) * scale,\n      halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf)\n    );\n\n    let i; let peak; let h;\n    for (i = canvasStart; i < canvasEnd; i += 1) {\n      peak = peaks[2 * i] || 0;\n      h = Math.round(peak / absmaxHalf);\n      ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);\n    }\n\n    // draw the bottom edge going backwards, to make a single\n    // closed hull to fill\n    let j = canvasEnd - 1;\n    for (j; j >= canvasStart; j -= 1) {\n      peak = peaks[2 * j + 1] || 0;\n      h = Math.round(peak / absmaxHalf);\n      ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);\n    }\n\n    ctx.lineTo(\n      (canvasStart - first) * scale,\n      halfOffset -\n                Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf)\n    );\n\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  /**\n     * Destroys this entry\n     */\n  destroy() {\n    this.waveCtx = null;\n    this.wave = null;\n\n    this.progressCtx = null;\n    this.progress = null;\n  }\n\n  /**\n   * Return image data of the wave `canvas` element\n   *\n   * When using a `type` of `'blob'`, this will return a `Promise` that\n   * resolves with a `Blob` instance.\n   *\n   * @param {string} format='image/png' An optional value of a format type.\n   * @param {number} quality=0.92 An optional value between 0 and 1.\n   * @param {string} type='dataURL' Either 'dataURL' or 'blob'.\n   * @return {string|Promise} When using the default `'dataURL'` `type` this\n   * returns a data URL. When using the `'blob'` `type` this returns a\n   * `Promise` that resolves with a `Blob` instance.\n   */\n  getImage(format, quality, type) {\n    if (type === 'blob') {\n      return new Promise((resolve) => {\n        this.wave.toBlob(resolve, format, quality);\n      });\n    } if (type === 'dataURL') {\n      return this.wave.toDataURL(format, quality);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}