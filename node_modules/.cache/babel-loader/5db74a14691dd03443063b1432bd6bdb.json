{"ast":null,"code":"import { Point, BitmapText } from 'pixi.js';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport Line from './Line';\nimport { ShapeType } from './types';\n\n/**\n * Arrow shape\n * @class\n */\nexport default class Arrow extends Line {\n  constructor(...args) {\n    super(...args);\n    this.shapeType = ShapeType.ARROW;\n  }\n  get arrowSize() {\n    return this.showVertex ? this.vertexSize * 2 + 8 : 16;\n  }\n  drawShape() {\n    super.drawShape();\n    this._drawArrow();\n  }\n\n  /**\n   * draw arrow at end of line\n   */\n  _drawArrow() {\n    if (this._finished) {\n      const p = this._getEdgePoint(this.arrowSize);\n      if (p) {\n        const lp = this.points[this.points.length - 1];\n        const p1 = computeRotatedPosition(lp, p, Math.PI / 6);\n        const p2 = computeRotatedPosition(lp, p, -Math.PI / 6);\n        this.instance.lineStyle(0);\n        this.instance.beginFill(this.displayBorderColor, this.borderAlpha);\n        this.instance.drawPolygon([lp, p1, p2].map(i => new Point(i.x, i.y)));\n        this.instance.endFill();\n      }\n    }\n  }\n\n  /**\n   * draw shape line\n   */\n  _drawShapeLine() {\n    if (this._points.length <= 0) {\n      return;\n    }\n    const baseWidth = this.borderWidth / this.scale;\n    const boldWidth = baseWidth * 4;\n    this.instance.moveTo(this._points[0].x, this._points[0].y);\n    for (let i = 1; i < this._points.length; i += 1) {\n      const {\n        color,\n        type,\n        bold\n      } = this.getEdgeStyle(i - 1);\n      this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n      const point = this._points[i];\n      if (i !== this._points.length - 1 || !this._finished) {\n        // not last, or not finished\n        this.instance.drawLine(point.x, point.y, this.borderStyle, type);\n      } else {\n        const d = this.arrowSize / 2 * Math.sqrt(3);\n        const p = this._getEdgePoint(d);\n        if (p) {\n          this.instance.drawLine(p.x, p.y, this.borderStyle, type);\n        }\n      }\n    }\n    if (!this._finished && this._nextPoint) {\n      const {\n        color,\n        type,\n        bold\n      } = this.getEdgeStyle(this._points.length - 1);\n      this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n      this.instance.drawLine(this._nextPoint.x, this._nextPoint.y, this.borderStyle, type);\n    }\n  }\n\n  /**\n   * draw shape vertex\n   */\n  _drawShapeVertex() {\n    this.vertexesContainer.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n    const r = this.vertexSize / this.scale;\n    const offset = this.showVertex ? r : 4 / this.scale;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this._points.forEach((point, index) => {\n      if (this.showVertex && !this.selected && (!this.finished || index !== this._points.length - 1)) {\n        const {\n          color,\n          type\n        } = this.getPointStyle(index);\n        this.instance.beginFill(color, this.borderAlpha);\n        this.instance.drawVertex(point.x, point.y, r, type);\n        this.instance.endFill();\n      }\n      if (this.showVertexOrder) {\n        // draw vertext order\n        const text = new BitmapText(`${this.vertexStart + index} `, {\n          fontName: 'ALPHA_NUMERIC'\n        });\n        text.scale.set(1 / this.scale);\n        if (!this.finished || index !== this._points.length - 1) {\n          text.position.set(point.x + offset, point.y + offset);\n        } else {\n          text.position.set(point.x + 4 / this.scale, point.y + 4 / this.scale);\n        }\n        this.vertexesContainer.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * get point on last edge by the distance from last point\n   * @param distance\n   */\n  _getEdgePoint(distance) {\n    if (this.points.length >= 2) {\n      const lp1 = this.points[this.points.length - 1];\n      const lp2 = this.points[this.points.length - 2];\n      const d = Math.sqrt((lp1.x - lp2.x) ** 2 + (lp1.y - lp2.y) ** 2);\n      const x = lp1.x - (lp1.x - lp2.x) / d * (distance / this.scale);\n      const y = lp1.y + (lp2.y - lp1.y) / d * (distance / this.scale);\n      return {\n        x,\n        y\n      };\n    }\n    return null;\n  }\n}","map":{"version":3,"names":["Point","BitmapText","computeRotatedPosition","Line","ShapeType","Arrow","constructor","args","shapeType","ARROW","arrowSize","showVertex","vertexSize","drawShape","_drawArrow","_finished","p","_getEdgePoint","lp","points","length","p1","Math","PI","p2","instance","lineStyle","beginFill","displayBorderColor","borderAlpha","drawPolygon","map","i","x","y","endFill","_drawShapeLine","_points","baseWidth","borderWidth","scale","boldWidth","moveTo","color","type","bold","getEdgeStyle","point","drawLine","borderStyle","d","sqrt","_nextPoint","_drawShapeVertex","vertexesContainer","removeChildren","showVertexOrder","r","offset","forEach","index","selected","finished","getPointStyle","drawVertex","text","vertexStart","fontName","set","position","addChild","distance","lp1","lp2"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/Arrow.ts"],"sourcesContent":["import { Point, BitmapText } from 'pixi.js';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport Line from './Line';\nimport { ShapeType, ShapeVertexType } from './types';\n\n/**\n * Arrow shape\n * @class\n */\nexport default class Arrow extends Line {\n  shapeType = ShapeType.ARROW;\n\n  get arrowSize() {\n    return this.showVertex ? this.vertexSize * 2 + 8 : 16;\n  }\n\n  drawShape() {\n    super.drawShape();\n    this._drawArrow();\n  }\n\n  /**\n   * draw arrow at end of line\n   */\n  private _drawArrow() {\n    if (this._finished) {\n      const p = this._getEdgePoint(this.arrowSize);\n      if (p) {\n        const lp = this.points[this.points.length - 1];\n        const p1 = computeRotatedPosition(lp, p, Math.PI / 6);\n        const p2 = computeRotatedPosition(lp, p, -Math.PI / 6);\n        this.instance.lineStyle(0);\n        this.instance.beginFill(this.displayBorderColor, this.borderAlpha);\n        this.instance.drawPolygon([lp, p1, p2].map((i) => new Point(i.x, i.y)));\n        this.instance.endFill();\n      }\n    }\n  }\n\n  /**\n   * draw shape line\n   */\n  protected _drawShapeLine() {\n    if (this._points.length <= 0) {\n      return;\n    }\n    const baseWidth = this.borderWidth / this.scale;\n    const boldWidth = baseWidth * 4;\n    this.instance.moveTo(this._points[0].x, this._points[0].y);\n    for (let i = 1; i < this._points.length; i += 1) {\n      const { color, type, bold } = this.getEdgeStyle(i - 1);\n      this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n      const point = this._points[i];\n      if (i !== this._points.length - 1 || !this._finished) {\n        // not last, or not finished\n        this.instance.drawLine(point.x, point.y, this.borderStyle, type);\n      } else {\n        const d = (this.arrowSize / 2) * Math.sqrt(3);\n        const p = this._getEdgePoint(d);\n        if (p) {\n          this.instance.drawLine(p.x, p.y, this.borderStyle, type);\n        }\n      }\n    }\n    if (!this._finished && this._nextPoint) {\n      const { color, type, bold } = this.getEdgeStyle(this._points.length - 1);\n      this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n      this.instance.drawLine(this._nextPoint.x, this._nextPoint.y, this.borderStyle, type);\n    }\n  }\n\n  /**\n   * draw shape vertex\n   */\n  protected _drawShapeVertex() {\n    this.vertexesContainer.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n\n    const r = this.vertexSize / this.scale;\n    const offset = this.showVertex ? r : 4 / this.scale;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this._points.forEach((point, index) => {\n      if (this.showVertex && !this.selected && (!this.finished || index !== this._points.length - 1)) {\n        const { color, type } = this.getPointStyle(index);\n        this.instance.beginFill(color, this.borderAlpha);\n        this.instance.drawVertex(point.x, point.y, r, type);\n        this.instance.endFill();\n      }\n      if (this.showVertexOrder) {\n        // draw vertext order\n        const text = new BitmapText(`${this.vertexStart + index} `, { fontName: 'ALPHA_NUMERIC' });\n        text.scale.set(1 / this.scale);\n        if (!this.finished || index !== this._points.length - 1) {\n          text.position.set(point.x + offset, point.y + offset);\n        } else {\n          text.position.set(point.x + 4 / this.scale, point.y + 4 / this.scale);\n        }\n        this.vertexesContainer.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * get point on last edge by the distance from last point\n   * @param distance\n   */\n  private _getEdgePoint(distance: number) {\n    if (this.points.length >= 2) {\n      const lp1 = this.points[this.points.length - 1];\n      const lp2 = this.points[this.points.length - 2];\n      const d = Math.sqrt((lp1.x - lp2.x) ** 2 + (lp1.y - lp2.y) ** 2);\n      const x = lp1.x - ((lp1.x - lp2.x) / d) * (distance / this.scale);\n      const y = lp1.y + ((lp2.y - lp1.y) / d) * (distance / this.scale);\n      return { x, y };\n    }\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}