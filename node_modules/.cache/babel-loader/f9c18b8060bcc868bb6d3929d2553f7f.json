{"ast":null,"code":"// copied from prism-react-renderer\n// https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/prism-react-renderer/src/utils/normalizeTokens.ts\n\nconst newlineRe = /\\r\\n|\\r|\\n/;\n\n// Empty lines need to contain a single empty token, denoted with { empty: true }\nconst normalizeEmptyLines = line => {\n  if (line.length === 0) {\n    line.push({\n      types: ['plain'],\n      content: '\\n',\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === '') {\n    line[0].content = '\\n';\n    line[0].empty = true;\n  }\n};\nconst appendTypes = (types, add) => {\n  const typesSize = types.length;\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n  return types.concat(add);\n};\n\n// Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\nconst normalizeTokens = tokens => {\n  const typeArrStack = [[]];\n  const tokenArrStack = [tokens];\n  const tokenArrIndexStack = [0];\n  const tokenArrSizeStack = [tokens.length];\n  let i = 0;\n  let stackIndex = 0;\n  let currentLine = [];\n  const acc = [currentLine];\n  while (stackIndex > -1) {\n    while (\n    // eslint-disable-next-line no-cond-assign, no-plusplus\n    (i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      let content;\n      let types = typeArrStack[stackIndex];\n      const tokenArr = tokenArrStack[stackIndex];\n      const token = tokenArr[i];\n\n      // Determine content and append type to types if necessary\n      if (typeof token === 'string') {\n        types = stackIndex > 0 ? types : ['plain'];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n        content = token.content;\n      }\n\n      // If token.content is an array, increase the stack depth and repeat this while-loop\n      if (typeof content !== 'string') {\n        stackIndex += 1;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // Split by newlines\n      const splitByNewlines = content.split(newlineRe);\n      const newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types,\n        content: splitByNewlines[0]\n      });\n\n      // Create a new line for each string on a new line\n      for (let j = 1; j < newlineCount; j += 1) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types,\n          content: splitByNewlines[j]\n        });\n      }\n    }\n\n    // Decreate the stack depth\n    stackIndex -= 1;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\nexport default normalizeTokens;","map":{"version":3,"names":["newlineRe","normalizeEmptyLines","line","length","push","types","content","empty","appendTypes","add","typesSize","concat","normalizeTokens","tokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","i","stackIndex","currentLine","acc","tokenArr","token","type","alias","splitByNewlines","split","newlineCount","j","pop"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/code/normalizeTokens.ts"],"sourcesContent":["// copied from prism-react-renderer\n// https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/prism-react-renderer/src/utils/normalizeTokens.ts\n\nimport type { Token as PrismToken, TokenStream } from 'prismjs';\n\nexport type Token = {\n  types: string[];\n  content: string;\n  empty?: boolean;\n};\n\nconst newlineRe = /\\r\\n|\\r|\\n/;\n\n// Empty lines need to contain a single empty token, denoted with { empty: true }\nconst normalizeEmptyLines = (line: Token[]) => {\n  if (line.length === 0) {\n    line.push({\n      types: ['plain'],\n      content: '\\n',\n      empty: true,\n    });\n  } else if (line.length === 1 && line[0].content === '') {\n    line[0].content = '\\n';\n    line[0].empty = true;\n  }\n};\n\nconst appendTypes = (types: string[], add: string[] | string): string[] => {\n  const typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n};\n\n// Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\nconst normalizeTokens = (tokens: (PrismToken | string)[]): Token[][] => {\n  const typeArrStack: string[][] = [[]];\n  const tokenArrStack = [tokens];\n  const tokenArrIndexStack = [0];\n  const tokenArrSizeStack = [tokens.length];\n  let i = 0;\n  let stackIndex = 0;\n  let currentLine: Token[] = [];\n  const acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while (\n      // eslint-disable-next-line no-cond-assign, no-plusplus\n      (i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]\n    ) {\n      let content: TokenStream;\n      let types = typeArrStack[stackIndex];\n      const tokenArr = tokenArrStack[stackIndex];\n      const token = tokenArr[i];\n\n      // Determine content and append type to types if necessary\n      if (typeof token === 'string') {\n        types = stackIndex > 0 ? types : ['plain'];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      }\n\n      // If token.content is an array, increase the stack depth and repeat this while-loop\n      if (typeof content !== 'string') {\n        stackIndex += 1;\n        typeArrStack.push(types);\n        tokenArrStack.push(content as PrismToken[]);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // Split by newlines\n      const splitByNewlines = content.split(newlineRe);\n      const newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types,\n        content: splitByNewlines[0],\n      });\n\n      // Create a new line for each string on a new line\n      for (let j = 1; j < newlineCount; j += 1) {\n        normalizeEmptyLines(currentLine);\n        acc.push((currentLine = []));\n        currentLine.push({\n          types,\n          content: splitByNewlines[j],\n        });\n      }\n    }\n\n    // Decreate the stack depth\n    stackIndex -= 1;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nexport default normalizeTokens;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}