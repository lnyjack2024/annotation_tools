{"ast":null,"code":"import React from 'react';\nimport { action, makeObservable, observable } from 'mobx';\nimport { message } from 'antd';\nimport { debounce } from 'lodash';\nimport GridView, { GridViewStatus } from '../view/GridView';\nimport Message from '../components/message/Message';\nimport { FilterDisplayRange, ReviewResult, ViewMode } from '../types';\nimport { calcShapeArea } from '../utils';\nimport i18n from '../locales';\nimport { BorderStyle, EventAction } from '../../common/shapes/Shape';\nimport { ShapeType } from '../../common/shapes/types';\nimport Pixel from '../../common/shapes/Pixel';\nimport Rectangle from '../../common/shapes/Rectangle';\nimport Dot from '../../common/shapes/Dot';\nimport { DEFAULT_CAMERA_NAME } from '../constants';\n\n/**\n * store for grid view\n * @class\n */\nexport default class GridStore {\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * cached grid views\n     */\n    this.cachedGridViews = {};\n    /**\n     * grids\n     */\n    this.grids = [];\n    /**\n     * grid col index\n     */\n    this.gridColIndex = -1;\n    /**\n     * grid context menu visibility\n     */\n    this.gridContextMenuVisible = false;\n    /**\n     * grid context menu position\n     */\n    this.gridContextMenuPosition = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * grid active context menu instance\n     */\n    this.gridContextMenuInstance = void 0;\n    /**\n     * multi select mode\n     */\n    this.multiSelectMode = false;\n    /**\n     * multi select message\n     */\n    this.multiSelectMsg = void 0;\n    /**\n     * multi selected grid keys\n     */\n    this.multiSelectedGridKeys = new Set();\n    this.setGridColIndex = colIndex => {\n      this.gridColIndex = colIndex;\n    };\n    this.openContextMenu = debounce((position, activeInstance) => {\n      if (this.rootStore.readonly || this.rootStore.frame.isPlaying) {\n        return;\n      }\n      this.gridContextMenuPosition = position;\n      this.gridContextMenuInstance = activeInstance;\n      this.gridContextMenuVisible = true;\n    }, 0);\n    this.closeContextMenu = () => {\n      this.gridContextMenuVisible = false;\n      this.gridContextMenuInstance = undefined;\n    };\n    this.setMultiSelectMode = mode => {\n      this.multiSelectMode = mode;\n      this.multiSelectedGridKeys.forEach(key => {\n        if (this.cachedGridViews[key]) {\n          this.cachedGridViews[key].multiSelected = false;\n        }\n      });\n      this.multiSelectedGridKeys.clear();\n      this.updateMultiSelectMsg();\n    };\n    this.setGridsMultiSelected = toGrid => {\n      const {\n        selectedInstances\n      } = this.rootStore.instance;\n      if (selectedInstances.length === 1) {\n        const {\n          currentFrame,\n          currentCamera\n        } = this.rootStore.frame;\n        const selectedKey = this.generateGridKey(currentFrame, currentCamera, selectedInstances[0].id);\n        const selectedGridIndex = this.grids.findIndex(grid => grid.key === selectedKey);\n        const gridIndex = this.grids.findIndex(grid => grid.key === toGrid.key);\n        if (selectedGridIndex >= 0 && gridIndex >= 0) {\n          const fromGridIndex = Math.min(selectedGridIndex, gridIndex);\n          const toGridIndex = Math.max(selectedGridIndex, gridIndex);\n          for (let i = fromGridIndex; i <= toGridIndex; i += 1) {\n            const grid = this.grids[i];\n            this.multiSelectedGridKeys.add(grid.key);\n            if (this.cachedGridViews[grid.key]) {\n              this.cachedGridViews[grid.key].multiSelected = true;\n            }\n          }\n          this.updateMultiSelectMsg();\n        }\n      }\n    };\n    this.toggleGridMultiSelected = grid => {\n      const {\n        key\n      } = grid;\n      if (this.multiSelectedGridKeys.has(key)) {\n        this.multiSelectedGridKeys.delete(key);\n        if (this.cachedGridViews[key]) {\n          this.cachedGridViews[key].multiSelected = false;\n        }\n      } else {\n        this.multiSelectedGridKeys.add(key);\n        if (this.cachedGridViews[key]) {\n          this.cachedGridViews[key].multiSelected = true;\n        }\n      }\n      this.updateMultiSelectMsg();\n    };\n    this.updateInstanceItemsForGrid = grid => {\n      if (this.rootStore.filter.filterMode) {\n        const {\n          instanceId,\n          frameIndex,\n          camera\n        } = this.parseGridKey(grid.key);\n        if (instanceId) {\n          const instance = this.rootStore.instance.instances[instanceId];\n          if (instance) {\n            const {\n              filteredInstances\n            } = this.rootStore.filter;\n            const {\n              cameras: filteredCameras\n            } = filteredInstances[instanceId];\n            const frames = filteredCameras[camera];\n            grid.instanceItems = frames[frameIndex];\n          }\n        }\n      } else {\n        const {\n          isMultiSelected,\n          selectedInstances\n        } = this.rootStore.instance;\n        const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n        grid.instanceItems = Object.values((selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.items) || {});\n      }\n    };\n    this.setupShapesForGrid = grid => {\n      if (!grid.imageLoaded || !grid.view || grid.view.imageLoadError || grid.shapesLoaded) {\n        grid.autoFitShapes();\n        return;\n      }\n      const {\n        instanceItems,\n        shapes,\n        camera,\n        frameIndex\n      } = grid;\n\n      // delete all shapes\n      Object.values(shapes).forEach(({\n        shape\n      }) => {\n        shape.destroy();\n      });\n      grid.shapes = {};\n\n      // add shapes\n      const {\n        filterMode\n      } = this.rootStore.filter;\n      const {\n        autoTracking,\n        activeLayerIndex,\n        labelMode\n      } = this.rootStore.config;\n      const {\n        createShape,\n        setShapeStyles\n      } = this.rootStore.shape;\n      const imageBounds = this.rootStore.frame.getImageBoundsForCamera(camera, frameIndex);\n      for (let i = 0; i < instanceItems.length; i += 1) {\n        var _instanceItem$cameras;\n        const instanceItem = instanceItems[i];\n        const frameData = (_instanceItem$cameras = instanceItem.cameras[camera]) === null || _instanceItem$cameras === void 0 ? void 0 : _instanceItem$cameras.frames[frameIndex];\n        if (frameData) {\n          const {\n            layer = activeLayerIndex\n          } = frameData;\n          let order;\n          if (frameData.order !== undefined) {\n            order = frameData.order;\n          } else {\n            order = frameData.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer, frameIndex, camera);\n          }\n          const shape = createShape(grid.view.getShapesLayerByIndex(layer), imageBounds, instanceItem.colorConfig.color, instanceItem.instance.category, instanceItem.name, instanceItem, frameData.shapeType, frameData.shape, order, labelMode ? instanceItem.label : '', camera);\n          instanceItem.setShapeColorConifg({\n            fillColor: shape.fillColor,\n            edgeColor: shape.borderColor,\n            pointColor: shape.vertexColor,\n            color: instanceItem.colorConfig.color\n          });\n          const selected = !filterMode || grid.camera === this.rootStore.frame.currentCamera && grid.frameIndex === this.rootStore.frame.currentFrame;\n          shape.scale = grid.view.viewScale;\n          shape.editable = !this.rootStore.readonly && !frameData.locked;\n          shape.selected = instanceItem.selected && selected;\n          this.addShapeListeners(grid, shape);\n          setShapeStyles(shape, instanceItem, camera, frameIndex);\n          if (instanceItem.instance.selected && selected) {\n            shape.borderColor = 0xFFFF00;\n            if (shape.shapeType === ShapeType.DOT) {\n              shape.color = 0xFFFF00;\n            }\n          }\n          grid.shapes[shape.uid] = {\n            shape,\n            instanceItem\n          };\n        } else if (!this.rootStore.readonly && autoTracking && !filterMode) {\n          // predict\n          const shapeInfo = instanceItem.predictShape(camera, frameIndex, imageBounds);\n          if (shapeInfo && shapeInfo.shapeType !== ShapeType.PIXEL) {\n            const predictedShape = createShape(grid.view.activeShapesLayer, imageBounds, instanceItem.colorConfig.color, instanceItem.instance.category, instanceItem.name, instanceItem, shapeInfo.shapeType, shapeInfo.shape, 9999,\n            // predicted shape always on the top\n            labelMode ? instanceItem.label : '');\n            predictedShape.borderStyle = BorderStyle.DASHED;\n            predictedShape.borderColor = 0xFFFF00;\n            if (predictedShape.shapeType === ShapeType.DOT) {\n              predictedShape.color = 0xFFFF00;\n            }\n            predictedShape.scale = grid.view.viewScale;\n            predictedShape.selected = instanceItem.selected;\n            this.addShapeListeners(grid, predictedShape);\n            grid.shapes[predictedShape.uid] = {\n              shape: predictedShape,\n              instanceItem\n            };\n          }\n        }\n      }\n      grid.status = Object.values(grid.shapes).filter(({\n        shape\n      }) => shape.borderStyle !== BorderStyle.DASHED).length === 0 ? GridViewStatus.EMPTY : GridViewStatus.DEFAULT;\n      grid.autoFitShapes();\n      grid.shapesLoaded = true;\n    };\n    this.updateReviewStatusForGrid = grid => {\n      const instanceItems = this.rootStore.filter.filterMode ? grid.instanceItems : this.rootStore.instance.selectedInstanceItems;\n      const {\n        getReviewForInstanceItem\n      } = this.rootStore.review;\n      grid.rejected = instanceItems.some(i => getReviewForInstanceItem(i, grid.camera, grid.frameIndex) === ReviewResult.REJECT);\n      grid.reviewAnchorsLoaded = false;\n    };\n    this.setupReviewsForGrid = grid => {\n      if (!grid.view || !grid.view.reviewLayer || grid.view.imageLoadError || grid.reviewAnchorsLoaded) {\n        return;\n      }\n      grid.reviewAnchors.forEach(anchor => {\n        anchor.destroy();\n      });\n      grid.reviewAnchors = [];\n      const {\n        reviews,\n        visible,\n        createReviewAnchorByReview,\n        addAnchorListeners\n      } = this.rootStore.review;\n      const {\n        selectedInstanceItems,\n        instances\n      } = this.rootStore.instance;\n      const instanceItems = this.rootStore.filter.filterMode ? grid.instanceItems : selectedInstanceItems;\n      for (let i = 0; i < instanceItems.length; i += 1) {\n        const instanceItem = instanceItems[i];\n        const instanceItemReviews = (reviews[grid.frameIndex] || []).filter(r => r.instanceItemId === instanceItem.id && r.camera === grid.camera);\n        for (let j = 0; j < instanceItemReviews.length; j += 1) {\n          const review = instanceItemReviews[j];\n          const anchor = createReviewAnchorByReview(review, grid.view.reviewLayer, grid.view.viewScale);\n          if (anchor) {\n            anchor.data = review;\n            anchor.visible = visible;\n            addAnchorListeners(anchor);\n            grid.reviewAnchors.push(anchor);\n          }\n        }\n      }\n      if (instanceItems.length === 0) {\n        // missing reviews\n        const frameReviews = reviews[grid.frameIndex] || [];\n        for (let i = 0; i < frameReviews.length; i += 1) {\n          const review = frameReviews[i];\n          if (review.result === ReviewResult.REJECT && review.camera === grid.camera) {\n            var _instances$instanceId, _instances$instanceId2, _instances$instanceId3;\n            const {\n              instanceId,\n              instanceItemId\n            } = review;\n            if (!instanceId || !instanceItemId || !((_instances$instanceId = instances[instanceId]) === null || _instances$instanceId === void 0 ? void 0 : (_instances$instanceId2 = _instances$instanceId.items[instanceItemId]) === null || _instances$instanceId2 === void 0 ? void 0 : (_instances$instanceId3 = _instances$instanceId2.cameras[grid.camera]) === null || _instances$instanceId3 === void 0 ? void 0 : _instances$instanceId3.frames[grid.frameIndex])) {\n              const anchor = createReviewAnchorByReview(review, grid.view.reviewLayer, grid.view.viewScale);\n              if (anchor) {\n                anchor.data = review;\n                anchor.visible = visible;\n                addAnchorListeners(anchor);\n                grid.reviewAnchors.push(anchor);\n              }\n            }\n          }\n        }\n      }\n      grid.reviewAnchorsLoaded = true;\n    };\n    /**\n     * add all predicted shapes to instances\n     * @param instances\n     */\n    this.addShapesToInstances = instances => {\n      message.warning(i18n.translate('GRID_ERR_ADD_SHAPES_TO_INSTANCES'));\n    };\n    /**\n     * add predicted shapes to instance\n     * @param instance\n     * @param camera\n     */\n    this.addShapesToInstance = (instance, camera = this.rootStore.frame.currentCamera) => {\n      if (this.rootStore.filter.filterMode) {\n        message.warning(i18n.translate('GRID_ERR_ADD_SHAPE_IN_FILTER_MODE'));\n        return;\n      }\n      const {\n        activeLayerIndex\n      } = this.rootStore.config;\n      const {\n        resolvePixelShapeData\n      } = this.rootStore.segmentation;\n      const {\n        currentFrame,\n        getImageBoundsForCamera,\n        getNextShapeOrder\n      } = this.rootStore.frame;\n      const imageBounds = getImageBoundsForCamera(camera, currentFrame);\n      const instanceItems = [];\n      Object.values(instance.items).forEach(instanceItem => {\n        var _instanceItem$cameras2;\n        if (!((_instanceItem$cameras2 = instanceItem.cameras[camera]) === null || _instanceItem$cameras2 === void 0 ? void 0 : _instanceItem$cameras2.frames[currentFrame])) {\n          // not exist\n          const shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n          if (shapeInfo) {\n            if (shapeInfo.shapeType === ShapeType.PIXEL) {\n              // resolve pixel\n              const newData = resolvePixelShapeData(shapeInfo.shape);\n              if (!newData) {\n                return;\n              }\n              shapeInfo.shape = newData;\n            } else {\n              const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n              if (area < this.rootStore.config.minArea) {\n                return;\n              }\n            }\n            instanceItems.push({\n              instanceItem,\n              camera,\n              frameIndex: currentFrame,\n              shapeType: shapeInfo.shapeType,\n              shape: shapeInfo.shape,\n              layer: activeLayerIndex,\n              order: shapeInfo.shapeType === ShapeType.PIXEL ? 0 : getNextShapeOrder(activeLayerIndex, currentFrame, camera)\n            });\n          }\n        }\n      });\n      if (instanceItems.length > 0) {\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n        // select\n        this.rootStore.instance.selectInstanceItem(null);\n        this.rootStore.instance.selectInstance(instance);\n        this.rootStore.instance.autoOpenAttributesModal();\n      }\n    };\n    /**\n     * update shapes interactive\n     * @param interactive\n     * @param ignoreIds\n     */\n    this.updateShapesInteractive = (interactive, ignoreIds) => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape,\n          instanceItem\n        }) => {\n          if (ignoreIds && ignoreIds.includes(shape.uid)) {\n            return;\n          }\n          shape.interactive = interactive;\n          if (interactive && instanceItem.selected) {\n            shape.selected = true;\n          }\n        });\n      });\n    };\n    /**\n     * update shapes user data mode\n     * @param userDataMode\n     */\n    this.updateShapesUserDataMode = userDataMode => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.userDataMode = userDataMode;\n        });\n      });\n    };\n    /**\n     * update rotate handle mode when shape rotate mode is handle\n     * @param shapeRotateHandleMode\n     */\n    this.updateShapesRotateHandleMode = shapeRotateHandleMode => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.rotateHandleMode = shapeRotateHandleMode;\n        });\n      });\n    };\n    /**\n     * update shapes rotate mode\n     * @param shapeRotateMode\n     */\n    this.updateShapesRotateMode = shapeRotateMode => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.rotateMode = shapeRotateMode;\n        });\n      });\n    };\n    /**\n     * update shapes show auxiliary lie\n     * @param showAuxiliaryLines\n     */\n    this.updateShapesShowAuxiliaryLines = showAuxiliaryLines => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Rectangle) {\n            shape.showAuxiliaryLines = showAuxiliaryLines;\n          }\n        });\n      });\n    };\n    /**\n     * update pixel shapes show bounds\n     * @param showPixelShapeBounds\n     */\n    this.updatePixelShapesShowBounds = showPixelShapeBounds => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Pixel) {\n            shape.showShapeBounds = showPixelShapeBounds;\n          }\n        });\n      });\n    };\n    /**\n     * update shapes double click finish (only for pixel shape)\n     * @param dblclickFinish\n     */\n    this.updateShapesDoubleClickFinish = dblclickFinish => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape.shapeType === ShapeType.PIXEL) {\n            shape.dblclickFinish = dblclickFinish;\n          }\n        });\n      });\n    };\n    /**\n     * update rectangle shapes auto snap tolerance\n     * @param tolerance\n     */\n    this.updateRectangleShapesAutoSnapTolerance = tolerance => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Rectangle) {\n            shape.autoSnapTolerance = tolerance;\n          }\n        });\n      });\n    };\n    this.updateShapesFill = fill => {\n      const fillAlpha = fill ? this.rootStore.shape.config.alpha / 100 : 0;\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.alpha = fillAlpha;\n        });\n      });\n    };\n    this.updateShapesAlpha = alpha => {\n      if (this.rootStore.shape.config.fill) {\n        this.grids.forEach(grid => {\n          Object.values(grid.shapes).forEach(({\n            shape\n          }) => {\n            shape.alpha = alpha;\n          });\n        });\n      }\n    };\n    this.updateShapesBorderAlpha = borderAlpha => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.borderAlpha = borderAlpha;\n        });\n      });\n    };\n    this.updateShapesBorderWidth = borderWidth => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.borderWidth = borderWidth;\n        });\n      });\n    };\n    this.updateDotsRadius = dotRadius => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Dot) {\n            shape.dotRadius = dotRadius;\n          } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n            shape.vertexSize = dotRadius;\n          }\n        });\n      });\n    };\n    this.updateShowSideLength = showSideLength => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.showSideLength = showSideLength;\n        });\n      });\n    };\n    this.updateShowDirection = showDirection => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.showDirection = showDirection;\n        });\n      });\n    };\n    this.updateShowVertex = showVertex => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.showVertex = showVertex;\n        });\n      });\n    };\n    this.updateShowVertexOrder = showVertexOrder => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          shape.showVertexOrder = showVertexOrder;\n        });\n      });\n    };\n    this.updateVertexSize = vertexSize => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape.shapeType !== ShapeType.KEYPOINTS) {\n            shape.vertexSize = vertexSize;\n          }\n        });\n      });\n    };\n    this.updateLabelMode = labelMode => {\n      this.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape,\n          instanceItem\n        }) => {\n          shape.label = labelMode ? instanceItem.label : '';\n        });\n      });\n    };\n    makeObservable(this, {\n      gridColIndex: observable,\n      gridContextMenuVisible: observable,\n      gridContextMenuPosition: observable,\n      gridContextMenuInstance: observable,\n      multiSelectMode: observable,\n      multiSelectedGridKeys: observable,\n      setGridColIndex: action,\n      openContextMenu: action,\n      closeContextMenu: action,\n      setMultiSelectMode: action,\n      setGridsMultiSelected: action,\n      toggleGridMultiSelected: action,\n      multiSelectByInstance: action\n    });\n    this.rootStore = rootStore;\n  }\n  updateMultiSelectMsg() {\n    if (this.multiSelectMode) {\n      this.multiSelectMsg = message.open({\n        key: 'multi-select-msg',\n        content: React.createElement(Message, {\n          message: i18n.translate('GRID_MULTI_SELECT_MSG', {\n            values: {\n              count: this.multiSelectedGridKeys.size\n            }\n          })\n        }),\n        duration: 0,\n        icon: null,\n        className: 'mode-message'\n      });\n    } else {\n      var _this$multiSelectMsg;\n      (_this$multiSelectMsg = this.multiSelectMsg) === null || _this$multiSelectMsg === void 0 ? void 0 : _this$multiSelectMsg.call(this);\n    }\n  }\n  multiSelectByInstance(instanceId) {\n    if (!this.multiSelectMode) {\n      this.multiSelectMode = true;\n    }\n    const {\n      filteredInstances\n    } = this.rootStore.filter;\n    const {\n      cameras: filteredCameras\n    } = filteredInstances[instanceId];\n    const filteredCameraNames = Object.keys(filteredCameras);\n    for (let i = 0; i < filteredCameraNames.length; i += 1) {\n      const camera = filteredCameraNames[i];\n      const frames = filteredCameras[camera];\n      const frameIndexList = Object.keys(frames);\n      for (let j = 0; j < frameIndexList.length; j += 1) {\n        const frameIndex = Number(frameIndexList[j]);\n        const key = this.generateGridKey(frameIndex, camera, instanceId);\n        this.multiSelectedGridKeys.add(key);\n        if (this.cachedGridViews[key]) {\n          this.cachedGridViews[key].multiSelected = true;\n        }\n      }\n    }\n    this.updateMultiSelectMsg();\n  }\n  moveMultiSelected(targetCategory, targetInstanceId) {\n    const checkedCategories = new Set();\n    checkedCategories.add(targetCategory);\n    const pendingInstanceItems = {};\n    const pendingCameraFramesCount = {};\n    let multiCameraFramesAffected = false;\n    this.multiSelectedGridKeys.forEach(key => {\n      if (checkedCategories.size > 1) {\n        return;\n      }\n      const grid = this.cachedGridViews[key];\n      if (grid) {\n        var _instanceItems$;\n        const {\n          camera,\n          frameIndex,\n          instanceItems\n        } = grid;\n        const instance = (_instanceItems$ = instanceItems[0]) === null || _instanceItems$ === void 0 ? void 0 : _instanceItems$.instance;\n        if (instance === null || instance === void 0 ? void 0 : instance.category) {\n          checkedCategories.add(instance.category);\n          if (checkedCategories.size > 1) {\n            // 跨分类了\n            return;\n          }\n          if (instance.id === targetInstanceId) {\n            // source = target，跳过\n            return;\n          }\n          instanceItems.forEach(instanceItem => {\n            if (!pendingInstanceItems[instanceItem.id]) {\n              pendingInstanceItems[instanceItem.id] = {\n                sourceInstanceItem: instanceItem,\n                affectedCameraFrames: {}\n              };\n            }\n            if (!pendingInstanceItems[instanceItem.id].affectedCameraFrames[camera]) {\n              pendingInstanceItems[instanceItem.id].affectedCameraFrames[camera] = [];\n            }\n            pendingInstanceItems[instanceItem.id].affectedCameraFrames[camera].push(frameIndex);\n            if (!pendingCameraFramesCount[camera]) {\n              pendingCameraFramesCount[camera] = {};\n            }\n            if (pendingCameraFramesCount[camera][frameIndex] === undefined) {\n              pendingCameraFramesCount[camera][frameIndex] = 0;\n            }\n            pendingCameraFramesCount[camera][frameIndex] += 1;\n            if (pendingCameraFramesCount[camera][frameIndex] > 1) {\n              multiCameraFramesAffected = true;\n            }\n          });\n        }\n      }\n    });\n    if (checkedCategories.size > 1) {\n      message.error(i18n.translate('FILTER_MOVE_TO_DIFF'));\n      return;\n    }\n    const allItems = Object.values(pendingInstanceItems);\n    if (allItems.length <= 0) {\n      message.error(i18n.translate('FILTER_MOVE_TO_EMPTY'));\n      return;\n    }\n    if (multiCameraFramesAffected) {\n      const category = this.rootStore.ontology.getCategory(targetCategory);\n      if ((category === null || category === void 0 ? void 0 : category.children.length) === 1 && (category === null || category === void 0 ? void 0 : category.children[0].count) === 1) {\n        message.error(i18n.translate('FILTER_MOVE_TO_OVERLAP'));\n        return;\n      }\n    }\n    const prevInstanceMap = {};\n    const currInstanceMap = {};\n    const prevRelationshipMap = {};\n    const currRelationshipMap = {};\n    try {\n      const {\n        instances,\n        changeCategoryForInstanceItemPure\n      } = this.rootStore.instance;\n      let targetInstance;\n      if (targetInstanceId) {\n        targetInstance = instances[targetInstanceId];\n      }\n      for (let i = 0; i < allItems.length; i += 1) {\n        var _targetInstance;\n        const {\n          sourceInstanceItem,\n          affectedCameraFrames\n        } = allItems[i];\n        const {\n          targetInstanceItem,\n          prevState,\n          currState\n        } = changeCategoryForInstanceItemPure(sourceInstanceItem, targetCategory, sourceInstanceItem.name, affectedCameraFrames, (_targetInstance = targetInstance) === null || _targetInstance === void 0 ? void 0 : _targetInstance.number);\n        targetInstance = targetInstanceItem.instance;\n\n        // FIXME: 这里组装状态时，默认此操作下不会有组件重复\n        // eslint-disable-next-line no-loop-func\n        prevState.instances.forEach(instance => {\n          var _targetInstance2;\n          // target instance 是上一次受影响的 instance\n          // 在下一次循环中，prev state 中无需保存上一次受影响的 instance\n          if (instance.id === ((_targetInstance2 = targetInstance) === null || _targetInstance2 === void 0 ? void 0 : _targetInstance2.id)) {\n            return;\n          }\n          if (!prevInstanceMap[instance.id]) {\n            prevInstanceMap[instance.id] = instance;\n          } else {\n            prevInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        currState.instances.forEach(instance => {\n          if (!currInstanceMap[instance.id]) {\n            currInstanceMap[instance.id] = instance;\n          } else {\n            currInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        prevState.relationships.forEach(r => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currState.relationships.forEach(r => {\n          currRelationshipMap[r.id] = r;\n        });\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap),\n        relationships: Object.values(prevRelationshipMap)\n      }, {\n        instances: Object.values(currInstanceMap),\n        relationships: Object.values(currRelationshipMap)\n      });\n      this.setMultiSelectMode(false);\n      this.rootStore.filter.filterInstances();\n    } catch (e) {\n      message.error(e.message);\n    }\n  }\n  generateGridKey(frameIndex, camera, instanceId) {\n    if (this.rootStore.filter.filterMode) {\n      return `${instanceId}-F${frameIndex}-C${camera}`;\n    }\n    return `F${frameIndex}`;\n  }\n  parseGridKey(key) {\n    if (this.rootStore.filter.filterMode) {\n      const [instanceId, restKey = ''] = key.split('-F');\n      const [frameStr = '0', camera = DEFAULT_CAMERA_NAME] = restKey.split('-C');\n      return {\n        frameIndex: Number(frameStr),\n        camera,\n        instanceId\n      };\n    }\n    const frameStr = key.replace('F', '');\n    return {\n      frameIndex: Number(frameStr)\n    };\n  }\n  getGridView(key, camera, frameIndex, viewContainer, labelContainer) {\n    const {\n      getImageUrl,\n      getFrameRotationForCamera\n    } = this.rootStore.frame;\n    const imageUrl = this.rootStore.proxyResource(getImageUrl(camera, frameIndex));\n    const imageRotation = getFrameRotationForCamera(camera, frameIndex);\n    if (!this.cachedGridViews[key]) {\n      var _this$rootStore$jobPr;\n      const {\n        layers,\n        autoSnapPoint\n      } = this.rootStore.config;\n      this.cachedGridViews[key] = new GridView({\n        key,\n        camera,\n        frameIndex,\n        viewContainer,\n        labelContainer,\n        imageUrl,\n        imageRotation,\n        config: {\n          layers,\n          enableReview: (_this$rootStore$jobPr = this.rootStore.jobProxy) === null || _this$rootStore$jobPr === void 0 ? void 0 : _this$rootStore$jobPr.loadReviewEnabled,\n          enableSnap: autoSnapPoint\n        }\n      });\n    } else {\n      this.cachedGridViews[key].imageUrl = imageUrl;\n      this.cachedGridViews[key].imageRotation = imageRotation;\n      this.cachedGridViews[key].viewContainer = viewContainer;\n      this.cachedGridViews[key].labelContainer = labelContainer;\n    }\n    return this.cachedGridViews[key];\n  }\n  setupGrids(viewContainer, labelContainer) {\n    if (this.rootStore.config.viewMode === ViewMode.GRID) {\n      const {\n        currentCamera,\n        currentFrame,\n        frameCount\n      } = this.rootStore.frame;\n      const grids = [];\n      if (this.rootStore.filter.filterMode) {\n        // filter mode\n        const {\n          filteredInstances,\n          filterDisplayRange\n        } = this.rootStore.filter;\n        const {\n          instances,\n          isMultiSelected,\n          selectedInstances\n        } = this.rootStore.instance;\n        Object.keys(filteredInstances).forEach(id => {\n          const instance = instances[id];\n          if (filterDisplayRange === FilterDisplayRange.SELECTED) {\n            const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n            if (id !== (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.id)) {\n              return;\n            }\n          }\n          const {\n            cameras: filteredCameras\n          } = filteredInstances[id];\n          const filteredCameraNames = Object.keys(filteredCameras);\n          for (let i = 0; i < filteredCameraNames.length; i += 1) {\n            const camera = filteredCameraNames[i];\n            const frames = filteredCameras[camera];\n            const frameIndexList = Object.keys(frames);\n            for (let j = 0; j < frameIndexList.length; j += 1) {\n              const frameIndex = Number(frameIndexList[j]);\n              const key = this.generateGridKey(frameIndex, camera, id);\n              const grid = this.getGridView(key, camera, frameIndex, viewContainer, labelContainer);\n              grid.selected = instance.selected && currentFrame === frameIndex && currentCamera === camera;\n              grid.multiSelected = this.multiSelectedGridKeys.has(key);\n              grid.instanceItems = frames[frameIndex];\n              grid.resetView();\n              grids.push(grid);\n              this.updateReviewStatusForGrid(grid);\n            }\n          }\n        });\n      } else {\n        // default grids\n        const {\n          isMultiSelected,\n          selectedInstances\n        } = this.rootStore.instance;\n        const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n        const instanceItems = Object.values((selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.items) || {});\n        Array.from({\n          length: frameCount\n        }).forEach((_, frameIndex) => {\n          const key = this.generateGridKey(frameIndex, currentCamera, selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.id);\n          const grid = this.getGridView(key, currentCamera, frameIndex, viewContainer, labelContainer);\n          grid.camera = currentCamera;\n          grid.selected = currentFrame === frameIndex;\n          grid.multiSelected = this.multiSelectedGridKeys.has(key);\n          grid.instanceItems = instanceItems;\n          grid.resetView();\n          grids.push(grid);\n          this.updateReviewStatusForGrid(grid);\n        });\n      }\n      Object.keys(this.cachedGridViews).forEach(key => {\n        const grid = this.cachedGridViews[key];\n        if (!grids.includes(grid)) {\n          if (this.multiSelectedGridKeys.has(key)) {\n            // temp keep selected grid\n            grid.remove();\n          } else {\n            grid.destroy();\n            delete this.cachedGridViews[key];\n          }\n        }\n      });\n      this.grids = grids;\n    }\n  }\n  addShapeListeners(grid, shape) {\n    shape.on(EventAction.SELECTED, s => {\n      // set camera & frame index\n      if (this.rootStore.frame.currentCamera !== grid.camera) {\n        this.rootStore.frame.setCamera(grid.camera);\n      }\n      if (this.rootStore.frame.currentFrame !== grid.frameIndex) {\n        this.rootStore.frame.setFrame(grid.frameIndex);\n      }\n      // select instance item\n      const {\n        instanceItem\n      } = grid.shapes[s.uid] || {};\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      // update shape selected status\n      Object.values(grid.shapes).forEach(shapeItem => {\n        shapeItem.shape.selected = shapeItem.shape.uid === shape.uid;\n      });\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      grid.setViewScaled();\n      const {\n        instanceItem\n      } = grid.shapes[s.uid] || {};\n      if (instanceItem) {\n        this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, grid.frameIndex, s.shapeType, data);\n        this.rootStore.cancelShapeWorking();\n      }\n    });\n    shape.on(EventAction.REMOVED, s => {\n      grid.setViewScaled();\n      const {\n        instanceItem\n      } = grid.shapes[s.uid] || {};\n      if (instanceItem) {\n        this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [grid.frameIndex], grid.camera);\n      }\n    });\n    shape.on(EventAction.CONTEXT_MENU, (s, p) => this.rootStore.openContextMenu(p));\n  }\n  getCurrentSelectedGrid() {\n    if (this.rootStore.filter.filterMode) {\n      const {\n        selectedInstances\n      } = this.rootStore.instance;\n      if (selectedInstances.length === 1) {\n        const {\n          currentFrame,\n          currentCamera\n        } = this.rootStore.frame;\n        const key = this.generateGridKey(currentFrame, currentCamera, selectedInstances[0].id);\n        return this.grids.find(grid => grid.key === key);\n      }\n    }\n    return this.grids[this.rootStore.frame.currentFrame];\n  }\n  getCurrentSelectedShape() {\n    const selectedGrid = this.getCurrentSelectedGrid();\n    if (selectedGrid) {\n      const shapeItem = Object.values((selectedGrid === null || selectedGrid === void 0 ? void 0 : selectedGrid.shapes) || {}).find(({\n        shape\n      }) => shape.selected && shape.borderStyle !== BorderStyle.DASHED);\n      return shapeItem === null || shapeItem === void 0 ? void 0 : shapeItem.shape;\n    }\n    return undefined;\n  }\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete() {\n    const selectedPixelShape = this.rootStore.segmentation.getSelectedShape();\n    const pixelSegDeleted = (selectedPixelShape === null || selectedPixelShape === void 0 ? void 0 : selectedPixelShape.editable) && selectedPixelShape.deleteSelectedPolygon();\n    if (pixelSegDeleted) {\n      return;\n    }\n    const selectedShape = this.getCurrentSelectedShape();\n    if (selectedShape) {\n      const pointsDeleted = selectedShape.deleteSelectedPoints();\n      if (!pointsDeleted) {\n        const {\n          selectedInstanceItems\n        } = this.rootStore.instance;\n        this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItems[0], [this.rootStore.frame.currentFrame]);\n        this.rootStore.filter.filterInstances();\n      }\n    }\n  }\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem(instanceItem, camera = this.rootStore.frame.currentCamera) {\n    var _instanceItem$cameras3;\n    if (this.rootStore.filter.filterMode) {\n      message.warning(i18n.translate('GRID_ERR_ADD_SHAPE_IN_FILTER_MODE'));\n      return;\n    }\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    if ((_instanceItem$cameras3 = instanceItem.cameras[camera]) === null || _instanceItem$cameras3 === void 0 ? void 0 : _instanceItem$cameras3.frames[currentFrame]) {\n      // already exist\n      return;\n    }\n    const imageBounds = this.rootStore.frame.getImageBoundsForCamera(camera, currentFrame);\n    const shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n    if (shapeInfo) {\n      if (shapeInfo.shapeType === ShapeType.PIXEL) {\n        // resolve pixel\n        const newData = this.rootStore.segmentation.resolvePixelShapeData(shapeInfo.shape);\n        if (!newData) {\n          return;\n        }\n        shapeInfo.shape = newData;\n      } else {\n        const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n        if (area < this.rootStore.config.minArea) {\n          message.warning(i18n.translate('MIN_AREA_ALERT'));\n          return;\n        }\n      }\n      const {\n        activeLayerIndex\n      } = this.rootStore.config;\n      this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, shapeInfo.shapeType, shapeInfo.shape, activeLayerIndex, shapeInfo.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(activeLayerIndex, currentFrame, camera), camera);\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  }\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable) {\n    this.grids.forEach(grid => {\n      Object.values(grid.shapes).forEach(({\n        shape\n      }) => {\n        shape.editable = editable;\n      });\n    });\n  }\n  hideOrShowReviews() {\n    const {\n      visible\n    } = this.rootStore.review;\n    for (let i = 0; i < this.grids.length; i += 1) {\n      const grid = this.grids[i];\n      grid.reviewAnchors.forEach(anchor => {\n        anchor.visible = visible;\n      });\n    }\n  }\n}","map":{"version":3,"names":["React","action","makeObservable","observable","message","debounce","GridView","GridViewStatus","Message","FilterDisplayRange","ReviewResult","ViewMode","calcShapeArea","i18n","BorderStyle","EventAction","ShapeType","Pixel","Rectangle","Dot","DEFAULT_CAMERA_NAME","GridStore","constructor","rootStore","cachedGridViews","grids","gridColIndex","gridContextMenuVisible","gridContextMenuPosition","x","y","gridContextMenuInstance","multiSelectMode","multiSelectMsg","multiSelectedGridKeys","Set","setGridColIndex","colIndex","openContextMenu","position","activeInstance","readonly","frame","isPlaying","closeContextMenu","undefined","setMultiSelectMode","mode","forEach","key","multiSelected","clear","updateMultiSelectMsg","setGridsMultiSelected","toGrid","selectedInstances","instance","length","currentFrame","currentCamera","selectedKey","generateGridKey","id","selectedGridIndex","findIndex","grid","gridIndex","fromGridIndex","Math","min","toGridIndex","max","i","add","toggleGridMultiSelected","has","delete","updateInstanceItemsForGrid","filter","filterMode","instanceId","frameIndex","camera","parseGridKey","instances","filteredInstances","cameras","filteredCameras","frames","instanceItems","isMultiSelected","selectedInstance","Object","values","items","setupShapesForGrid","imageLoaded","view","imageLoadError","shapesLoaded","autoFitShapes","shapes","shape","destroy","autoTracking","activeLayerIndex","labelMode","config","createShape","setShapeStyles","imageBounds","getImageBoundsForCamera","_instanceItem$cameras","instanceItem","frameData","layer","order","shapeType","PIXEL","getNextShapeOrder","getShapesLayerByIndex","colorConfig","color","category","name","label","setShapeColorConifg","fillColor","edgeColor","borderColor","pointColor","vertexColor","selected","scale","viewScale","editable","locked","addShapeListeners","DOT","uid","shapeInfo","predictShape","predictedShape","activeShapesLayer","borderStyle","DASHED","status","EMPTY","DEFAULT","updateReviewStatusForGrid","selectedInstanceItems","getReviewForInstanceItem","review","rejected","some","REJECT","reviewAnchorsLoaded","setupReviewsForGrid","reviewLayer","reviewAnchors","anchor","reviews","visible","createReviewAnchorByReview","addAnchorListeners","instanceItemReviews","r","instanceItemId","j","data","push","frameReviews","result","_instances$instanceId","_instances$instanceId2","_instances$instanceId3","addShapesToInstances","warning","translate","addShapesToInstance","resolvePixelShapeData","segmentation","_instanceItem$cameras2","newData","area","minArea","updateFrameShapeForInstanceItems","selectInstanceItem","selectInstance","autoOpenAttributesModal","updateShapesInteractive","interactive","ignoreIds","includes","updateShapesUserDataMode","userDataMode","updateShapesRotateHandleMode","shapeRotateHandleMode","rotateHandleMode","updateShapesRotateMode","shapeRotateMode","rotateMode","updateShapesShowAuxiliaryLines","showAuxiliaryLines","updatePixelShapesShowBounds","showPixelShapeBounds","showShapeBounds","updateShapesDoubleClickFinish","dblclickFinish","updateRectangleShapesAutoSnapTolerance","tolerance","autoSnapTolerance","updateShapesFill","fill","fillAlpha","alpha","updateShapesAlpha","updateShapesBorderAlpha","borderAlpha","updateShapesBorderWidth","borderWidth","updateDotsRadius","dotRadius","KEYPOINTS","vertexSize","updateShowSideLength","showSideLength","updateShowDirection","showDirection","updateShowVertex","showVertex","updateShowVertexOrder","showVertexOrder","updateVertexSize","updateLabelMode","multiSelectByInstance","open","content","createElement","count","size","duration","icon","className","_this$multiSelectMsg","call","filteredCameraNames","keys","frameIndexList","Number","moveMultiSelected","targetCategory","targetInstanceId","checkedCategories","pendingInstanceItems","pendingCameraFramesCount","multiCameraFramesAffected","_instanceItems$","sourceInstanceItem","affectedCameraFrames","error","allItems","ontology","getCategory","children","prevInstanceMap","currInstanceMap","prevRelationshipMap","currRelationshipMap","changeCategoryForInstanceItemPure","targetInstance","_targetInstance","targetInstanceItem","prevState","currState","number","_targetInstance2","relationships","undo","filterInstances","e","restKey","split","frameStr","replace","getGridView","viewContainer","labelContainer","getImageUrl","getFrameRotationForCamera","imageUrl","proxyResource","imageRotation","_this$rootStore$jobPr","layers","autoSnapPoint","enableReview","jobProxy","loadReviewEnabled","enableSnap","setupGrids","viewMode","GRID","frameCount","filterDisplayRange","SELECTED","resetView","Array","from","_","remove","on","s","setCamera","setFrame","shapeItem","CHANGED","setViewScaled","updateFrameShapeForInstanceItem","cancelShapeWorking","REMOVED","deleteFramesFromInstanceItem","CONTEXT_MENU","p","getCurrentSelectedGrid","find","getCurrentSelectedShape","selectedGrid","selectedPixelShape","getSelectedShape","pixelSegDeleted","deleteSelectedPolygon","selectedShape","pointsDeleted","deleteSelectedPoints","addShapeToInstanceItem","_instanceItem$cameras3","updateShapesEditable","hideOrShowReviews"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/GridStore.ts"],"sourcesContent":["import React from 'react';\nimport { action, makeObservable, observable } from 'mobx';\nimport { Container } from 'pixi.js';\nimport { message } from 'antd';\nimport { MessageType } from 'antd/lib/message';\nimport { debounce } from 'lodash';\nimport RootStore from './RootStore';\nimport GridView, { GridViewStatus } from '../view/GridView';\nimport Message from '../components/message/Message';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport { FilterDisplayRange, ReviewResult, ViewMode, Instance as IInstance, Relationship as IRelationship } from '../types';\nimport { calcShapeArea } from '../utils';\nimport i18n from '../locales';\nimport Shape, { BorderStyle, EventAction, ShapeRotateHandleMode, ShapeRotateMode, UserDataMode } from '../../common/shapes/Shape';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\nimport Pixel, { PixelData } from '../../common/shapes/Pixel';\nimport Rectangle from '../../common/shapes/Rectangle';\nimport Dot from '../../common/shapes/Dot';\nimport { DEFAULT_CAMERA_NAME } from '../constants';\n\n/**\n * store for grid view\n * @class\n */\nexport default class GridStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * cached grid views\n   */\n  cachedGridViews: Record<string, GridView> = {};\n\n  /**\n   * grids\n   */\n  grids: GridView[] = [];\n\n  /**\n   * grid col index\n   */\n  gridColIndex = -1;\n\n  /**\n   * grid context menu visibility\n   */\n  gridContextMenuVisible = false;\n\n  /**\n   * grid context menu position\n   */\n  gridContextMenuPosition = { x: 0, y: 0 };\n\n  /**\n   * grid active context menu instance\n   */\n  gridContextMenuInstance?: Instance;\n\n  /**\n   * multi select mode\n   */\n  multiSelectMode = false;\n\n  /**\n   * multi select message\n   */\n  multiSelectMsg?: MessageType;\n\n  /**\n   * multi selected grid keys\n   */\n  multiSelectedGridKeys: Set<string> = new Set();\n\n  constructor(rootStore: typeof RootStore) {\n    makeObservable(this, {\n      gridColIndex: observable,\n      gridContextMenuVisible: observable,\n      gridContextMenuPosition: observable,\n      gridContextMenuInstance: observable,\n      multiSelectMode: observable,\n      multiSelectedGridKeys: observable,\n      setGridColIndex: action,\n      openContextMenu: action,\n      closeContextMenu: action,\n      setMultiSelectMode: action,\n      setGridsMultiSelected: action,\n      toggleGridMultiSelected: action,\n      multiSelectByInstance: action,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  setGridColIndex = (colIndex: number) => {\n    this.gridColIndex = colIndex;\n  };\n\n  openContextMenu = debounce((position: { x: number; y: number }, activeInstance?: Instance) => {\n    if (this.rootStore.readonly || this.rootStore.frame.isPlaying) {\n      return;\n    }\n    this.gridContextMenuPosition = position;\n    this.gridContextMenuInstance = activeInstance;\n    this.gridContextMenuVisible = true;\n  }, 0);\n\n  closeContextMenu = () => {\n    this.gridContextMenuVisible = false;\n    this.gridContextMenuInstance = undefined;\n  };\n\n  setMultiSelectMode = (mode: boolean) => {\n    this.multiSelectMode = mode;\n    this.multiSelectedGridKeys.forEach((key) => {\n      if (this.cachedGridViews[key]) {\n        this.cachedGridViews[key].multiSelected = false;\n      }\n    });\n    this.multiSelectedGridKeys.clear();\n    this.updateMultiSelectMsg();\n  };\n\n  setGridsMultiSelected = (toGrid: GridView) => {\n    const { selectedInstances } = this.rootStore.instance;\n    if (selectedInstances.length === 1) {\n      const { currentFrame, currentCamera } = this.rootStore.frame;\n      const selectedKey = this.generateGridKey(currentFrame, currentCamera, selectedInstances[0].id);\n      const selectedGridIndex = this.grids.findIndex((grid) => grid.key === selectedKey);\n      const gridIndex = this.grids.findIndex((grid) => grid.key === toGrid.key);\n      if (selectedGridIndex >= 0 && gridIndex >= 0) {\n        const fromGridIndex = Math.min(selectedGridIndex, gridIndex);\n        const toGridIndex = Math.max(selectedGridIndex, gridIndex);\n        for (let i = fromGridIndex; i <= toGridIndex; i += 1) {\n          const grid = this.grids[i];\n          this.multiSelectedGridKeys.add(grid.key);\n          if (this.cachedGridViews[grid.key]) {\n            this.cachedGridViews[grid.key].multiSelected = true;\n          }\n        }\n        this.updateMultiSelectMsg();\n      }\n    }\n  };\n\n  toggleGridMultiSelected = (grid: GridView) => {\n    const { key } = grid;\n    if (this.multiSelectedGridKeys.has(key)) {\n      this.multiSelectedGridKeys.delete(key);\n      if (this.cachedGridViews[key]) {\n        this.cachedGridViews[key].multiSelected = false;\n      }\n    } else {\n      this.multiSelectedGridKeys.add(key);\n      if (this.cachedGridViews[key]) {\n        this.cachedGridViews[key].multiSelected = true;\n      }\n    }\n    this.updateMultiSelectMsg();\n  };\n\n  updateMultiSelectMsg() {\n    if (this.multiSelectMode) {\n      this.multiSelectMsg = message.open({\n        key: 'multi-select-msg',\n        content: React.createElement(Message, {\n          message: i18n.translate('GRID_MULTI_SELECT_MSG', { values: { count: this.multiSelectedGridKeys.size } }),\n        }),\n        duration: 0,\n        icon: null,\n        className: 'mode-message',\n      });\n    } else {\n      this.multiSelectMsg?.();\n    }\n  }\n\n  multiSelectByInstance(instanceId: string) {\n    if (!this.multiSelectMode) {\n      this.multiSelectMode = true;\n    }\n    const { filteredInstances } = this.rootStore.filter;\n    const { cameras: filteredCameras } = filteredInstances[instanceId];\n    const filteredCameraNames = Object.keys(filteredCameras);\n    for (let i = 0; i < filteredCameraNames.length; i += 1) {\n      const camera = filteredCameraNames[i];\n      const frames = filteredCameras[camera];\n      const frameIndexList = Object.keys(frames);\n      for (let j = 0; j < frameIndexList.length; j += 1) {\n        const frameIndex = Number(frameIndexList[j]);\n        const key = this.generateGridKey(frameIndex, camera, instanceId);\n        this.multiSelectedGridKeys.add(key);\n        if (this.cachedGridViews[key]) {\n          this.cachedGridViews[key].multiSelected = true;\n        }\n      }\n    }\n    this.updateMultiSelectMsg();\n  }\n\n  moveMultiSelected(targetCategory: string, targetInstanceId?: string) {\n    const checkedCategories = new Set();\n    checkedCategories.add(targetCategory);\n\n    const pendingInstanceItems: {\n      [instanceItemId: string]: {\n        sourceInstanceItem: InstanceItem;\n        affectedCameraFrames: Record<string, number[]>;\n      }\n    } = {};\n    const pendingCameraFramesCount: Record<string, Record<number, number>> = {};\n    let multiCameraFramesAffected = false;\n\n    this.multiSelectedGridKeys.forEach((key) => {\n      if (checkedCategories.size > 1) {\n        return;\n      }\n\n      const grid = this.cachedGridViews[key];\n      if (grid) {\n        const { camera, frameIndex, instanceItems } = grid;\n        const instance = instanceItems[0]?.instance;\n        if (instance?.category) {\n          checkedCategories.add(instance.category);\n          if (checkedCategories.size > 1) {\n            // 跨分类了\n            return;\n          }\n\n          if (instance.id === targetInstanceId) {\n            // source = target，跳过\n            return;\n          }\n\n          instanceItems.forEach((instanceItem) => {\n            if (!pendingInstanceItems[instanceItem.id]) {\n              pendingInstanceItems[instanceItem.id] = {\n                sourceInstanceItem: instanceItem,\n                affectedCameraFrames: {},\n              };\n            }\n            if (!pendingInstanceItems[instanceItem.id].affectedCameraFrames[camera]) {\n              pendingInstanceItems[instanceItem.id].affectedCameraFrames[camera] = [];\n            }\n            pendingInstanceItems[instanceItem.id].affectedCameraFrames[camera].push(frameIndex);\n\n            if (!pendingCameraFramesCount[camera]) {\n              pendingCameraFramesCount[camera] = {};\n            }\n            if (pendingCameraFramesCount[camera][frameIndex] === undefined) {\n              pendingCameraFramesCount[camera][frameIndex] = 0;\n            }\n            pendingCameraFramesCount[camera][frameIndex] += 1;\n            if (pendingCameraFramesCount[camera][frameIndex] > 1) {\n              multiCameraFramesAffected = true;\n            }\n          });\n        }\n      }\n    });\n\n    if (checkedCategories.size > 1) {\n      message.error(i18n.translate('FILTER_MOVE_TO_DIFF'));\n      return;\n    }\n\n    const allItems = Object.values(pendingInstanceItems);\n    if (allItems.length <= 0) {\n      message.error(i18n.translate('FILTER_MOVE_TO_EMPTY'));\n      return;\n    }\n\n    if (multiCameraFramesAffected) {\n      const category = this.rootStore.ontology.getCategory(targetCategory);\n      if (category?.children.length === 1 && category?.children[0].count === 1) {\n        message.error(i18n.translate('FILTER_MOVE_TO_OVERLAP'));\n        return;\n      }\n    }\n\n    const prevInstanceMap: Record<string, IInstance> = {};\n    const currInstanceMap: Record<string, IInstance> = {};\n    const prevRelationshipMap: Record<string, IRelationship> = {};\n    const currRelationshipMap: Record<string, IRelationship> = {};\n\n    try {\n      const { instances, changeCategoryForInstanceItemPure } = this.rootStore.instance;\n      let targetInstance: Instance | undefined;\n      if (targetInstanceId) {\n        targetInstance = instances[targetInstanceId];\n      }\n      for (let i = 0; i < allItems.length; i += 1) {\n        const { sourceInstanceItem, affectedCameraFrames } = allItems[i];\n        const { targetInstanceItem, prevState, currState } = changeCategoryForInstanceItemPure(\n          sourceInstanceItem,\n          targetCategory,\n          sourceInstanceItem.name,\n          affectedCameraFrames,\n          targetInstance?.number,\n        );\n        targetInstance = targetInstanceItem.instance;\n\n        // FIXME: 这里组装状态时，默认此操作下不会有组件重复\n        // eslint-disable-next-line no-loop-func\n        prevState.instances.forEach((instance) => {\n          // target instance 是上一次受影响的 instance\n          // 在下一次循环中，prev state 中无需保存上一次受影响的 instance\n          if (instance.id === targetInstance?.id) {\n            return;\n          }\n          if (!prevInstanceMap[instance.id]) {\n            prevInstanceMap[instance.id] = instance;\n          } else {\n            prevInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        currState.instances.forEach((instance) => {\n          if (!currInstanceMap[instance.id]) {\n            currInstanceMap[instance.id] = instance;\n          } else {\n            currInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        prevState.relationships.forEach((r) => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currState.relationships.forEach((r) => {\n          currRelationshipMap[r.id] = r;\n        });\n      }\n\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap),\n        relationships: Object.values(prevRelationshipMap),\n      }, {\n        instances: Object.values(currInstanceMap),\n        relationships: Object.values(currRelationshipMap),\n      });\n      this.setMultiSelectMode(false);\n      this.rootStore.filter.filterInstances();\n    } catch (e) {\n      message.error((e as Error).message);\n    }\n  }\n\n  generateGridKey(frameIndex: number, camera: string, instanceId?: string) {\n    if (this.rootStore.filter.filterMode) {\n      return `${instanceId}-F${frameIndex}-C${camera}`;\n    }\n    return `F${frameIndex}`;\n  }\n\n  parseGridKey(key: string) {\n    if (this.rootStore.filter.filterMode) {\n      const [instanceId, restKey = ''] = key.split('-F');\n      const [frameStr = '0', camera = DEFAULT_CAMERA_NAME] = restKey.split('-C');\n      return {\n        frameIndex: Number(frameStr),\n        camera,\n        instanceId,\n      };\n    }\n    const frameStr = key.replace('F', '');\n    return {\n      frameIndex: Number(frameStr),\n    };\n  }\n\n  getGridView(\n    key: string,\n    camera: string,\n    frameIndex: number,\n    viewContainer: Container,\n    labelContainer: HTMLElement,\n  ) {\n    const { getImageUrl, getFrameRotationForCamera } = this.rootStore.frame;\n    const imageUrl = this.rootStore.proxyResource(getImageUrl(camera, frameIndex));\n    const imageRotation = getFrameRotationForCamera(camera, frameIndex);\n    if (!this.cachedGridViews[key]) {\n      const { layers, autoSnapPoint } = this.rootStore.config;\n      this.cachedGridViews[key] = new GridView({\n        key,\n        camera,\n        frameIndex,\n        viewContainer,\n        labelContainer,\n        imageUrl,\n        imageRotation,\n        config: {\n          layers,\n          enableReview: this.rootStore.jobProxy?.loadReviewEnabled,\n          enableSnap: autoSnapPoint,\n        },\n      });\n    } else {\n      this.cachedGridViews[key].imageUrl = imageUrl;\n      this.cachedGridViews[key].imageRotation = imageRotation;\n      this.cachedGridViews[key].viewContainer = viewContainer;\n      this.cachedGridViews[key].labelContainer = labelContainer;\n    }\n    return this.cachedGridViews[key];\n  }\n\n  setupGrids(viewContainer: Container, labelContainer: HTMLElement) {\n    if (this.rootStore.config.viewMode === ViewMode.GRID) {\n      const { currentCamera, currentFrame, frameCount } = this.rootStore.frame;\n      const grids: GridView[] = [];\n      if (this.rootStore.filter.filterMode) {\n        // filter mode\n        const { filteredInstances, filterDisplayRange } = this.rootStore.filter;\n        const { instances, isMultiSelected, selectedInstances } = this.rootStore.instance;\n        Object.keys(filteredInstances).forEach((id) => {\n          const instance = instances[id];\n          if (filterDisplayRange === FilterDisplayRange.SELECTED) {\n            const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n            if (id !== selectedInstance?.id) {\n              return;\n            }\n          }\n          const { cameras: filteredCameras } = filteredInstances[id];\n          const filteredCameraNames = Object.keys(filteredCameras);\n          for (let i = 0; i < filteredCameraNames.length; i += 1) {\n            const camera = filteredCameraNames[i];\n            const frames = filteredCameras[camera];\n            const frameIndexList = Object.keys(frames);\n            for (let j = 0; j < frameIndexList.length; j += 1) {\n              const frameIndex = Number(frameIndexList[j]);\n              const key = this.generateGridKey(frameIndex, camera, id);\n              const grid = this.getGridView(\n                key,\n                camera,\n                frameIndex,\n                viewContainer,\n                labelContainer,\n              );\n              grid.selected = instance.selected\n                && currentFrame === frameIndex\n                && currentCamera === camera;\n              grid.multiSelected = this.multiSelectedGridKeys.has(key);\n              grid.instanceItems = frames[frameIndex];\n              grid.resetView();\n              grids.push(grid);\n              this.updateReviewStatusForGrid(grid);\n            }\n          }\n        });\n      } else {\n        // default grids\n        const { isMultiSelected, selectedInstances } = this.rootStore.instance;\n        const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n        const instanceItems = Object.values(selectedInstance?.items || {});\n        Array.from({ length: frameCount }).forEach((_, frameIndex) => {\n          const key = this.generateGridKey(frameIndex, currentCamera, selectedInstance?.id);\n          const grid = this.getGridView(\n            key,\n            currentCamera,\n            frameIndex,\n            viewContainer,\n            labelContainer,\n          );\n          grid.camera = currentCamera;\n          grid.selected = currentFrame === frameIndex;\n          grid.multiSelected = this.multiSelectedGridKeys.has(key);\n          grid.instanceItems = instanceItems;\n          grid.resetView();\n          grids.push(grid);\n          this.updateReviewStatusForGrid(grid);\n        });\n      }\n\n      Object.keys(this.cachedGridViews).forEach((key) => {\n        const grid = this.cachedGridViews[key];\n        if (!grids.includes(grid)) {\n          if (this.multiSelectedGridKeys.has(key)) {\n            // temp keep selected grid\n            grid.remove();\n          } else {\n            grid.destroy();\n            delete this.cachedGridViews[key];\n          }\n        }\n      });\n      this.grids = grids;\n    }\n  }\n\n  updateInstanceItemsForGrid = (grid: GridView) => {\n    if (this.rootStore.filter.filterMode) {\n      const { instanceId, frameIndex, camera } = this.parseGridKey(grid.key);\n      if (instanceId) {\n        const instance = this.rootStore.instance.instances[instanceId];\n        if (instance) {\n          const { filteredInstances } = this.rootStore.filter;\n          const { cameras: filteredCameras } = filteredInstances[instanceId];\n          const frames = filteredCameras[camera];\n          grid.instanceItems = frames[frameIndex];\n        }\n      }\n    } else {\n      const { isMultiSelected, selectedInstances } = this.rootStore.instance;\n      const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n      grid.instanceItems = Object.values(selectedInstance?.items || {});\n    }\n  };\n\n  setupShapesForGrid = (grid: GridView) => {\n    if (!grid.imageLoaded || !grid.view || grid.view.imageLoadError || grid.shapesLoaded) {\n      grid.autoFitShapes();\n      return;\n    }\n\n    const { instanceItems, shapes, camera, frameIndex } = grid;\n\n    // delete all shapes\n    Object.values(shapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    grid.shapes = {};\n\n    // add shapes\n    const { filterMode } = this.rootStore.filter;\n    const { autoTracking, activeLayerIndex, labelMode } = this.rootStore.config;\n    const { createShape, setShapeStyles } = this.rootStore.shape;\n    const imageBounds = this.rootStore.frame.getImageBoundsForCamera(camera, frameIndex);\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const instanceItem = instanceItems[i];\n      const frameData = instanceItem.cameras[camera]?.frames[frameIndex];\n      if (frameData) {\n        const { layer = activeLayerIndex } = frameData;\n        let order;\n        if (frameData.order !== undefined) {\n          order = frameData.order;\n        } else {\n          order = frameData.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer, frameIndex, camera);\n        }\n        const shape = createShape(\n          grid.view.getShapesLayerByIndex(layer),\n          imageBounds,\n          instanceItem.colorConfig.color,\n          instanceItem.instance.category,\n          instanceItem.name,\n          instanceItem,\n          frameData.shapeType,\n          frameData.shape,\n          order,\n          labelMode ? instanceItem.label : '',\n          camera,\n        );\n        instanceItem.setShapeColorConifg({\n          fillColor: shape.fillColor,\n          edgeColor: shape.borderColor,\n          pointColor: shape.vertexColor,\n          color: instanceItem.colorConfig.color\n        });\n\n        const selected = !filterMode || (\n          grid.camera === this.rootStore.frame.currentCamera && grid.frameIndex === this.rootStore.frame.currentFrame\n        );\n        shape.scale = grid.view.viewScale;\n        shape.editable = !this.rootStore.readonly && !frameData.locked;\n        shape.selected = instanceItem.selected && selected;\n        this.addShapeListeners(grid, shape);\n\n        setShapeStyles(shape, instanceItem, camera, frameIndex);\n        if (instanceItem.instance.selected && selected) {\n          shape.borderColor = 0xFFFF00;\n          if (shape.shapeType === ShapeType.DOT) {\n            shape.color = 0xFFFF00;\n          }\n        }\n\n        grid.shapes[shape.uid] = { shape, instanceItem };\n      } else if (!this.rootStore.readonly && autoTracking && !filterMode) {\n        // predict\n        const shapeInfo = instanceItem.predictShape(camera, frameIndex, imageBounds);\n        if (shapeInfo && shapeInfo.shapeType !== ShapeType.PIXEL) {\n          const predictedShape = createShape(\n            grid.view.activeShapesLayer,\n            imageBounds,\n            instanceItem.colorConfig.color,\n            instanceItem.instance.category,\n            instanceItem.name,\n            instanceItem,\n            shapeInfo.shapeType,\n            shapeInfo.shape,\n            9999, // predicted shape always on the top\n            labelMode ? instanceItem.label : '',\n          );\n          predictedShape.borderStyle = BorderStyle.DASHED;\n          predictedShape.borderColor = 0xFFFF00;\n          if (predictedShape.shapeType === ShapeType.DOT) {\n            predictedShape.color = 0xFFFF00;\n          }\n\n          predictedShape.scale = grid.view.viewScale;\n          predictedShape.selected = instanceItem.selected;\n          this.addShapeListeners(grid, predictedShape);\n\n          grid.shapes[predictedShape.uid] = { shape: predictedShape, instanceItem };\n        }\n      }\n    }\n\n    grid.status = Object.values(grid.shapes).filter(({ shape }) => shape.borderStyle !== BorderStyle.DASHED).length === 0\n      ? GridViewStatus.EMPTY\n      : GridViewStatus.DEFAULT;\n    grid.autoFitShapes();\n    grid.shapesLoaded = true;\n  };\n\n  updateReviewStatusForGrid = (grid: GridView) => {\n    const instanceItems = this.rootStore.filter.filterMode\n      ? grid.instanceItems\n      : this.rootStore.instance.selectedInstanceItems;\n    const { getReviewForInstanceItem } = this.rootStore.review;\n    grid.rejected = instanceItems.some((i) => getReviewForInstanceItem(i, grid.camera, grid.frameIndex) === ReviewResult.REJECT);\n    grid.reviewAnchorsLoaded = false;\n  };\n\n  setupReviewsForGrid = (grid: GridView) => {\n    if (!grid.view || !grid.view.reviewLayer || grid.view.imageLoadError || grid.reviewAnchorsLoaded) {\n      return;\n    }\n\n    grid.reviewAnchors.forEach((anchor) => {\n      anchor.destroy();\n    });\n    grid.reviewAnchors = [];\n\n    const { reviews, visible, createReviewAnchorByReview, addAnchorListeners } = this.rootStore.review;\n    const { selectedInstanceItems, instances } = this.rootStore.instance;\n    const instanceItems = this.rootStore.filter.filterMode\n      ? grid.instanceItems\n      : selectedInstanceItems;\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const instanceItem = instanceItems[i];\n      const instanceItemReviews = (reviews[grid.frameIndex] || []).filter((r) => r.instanceItemId === instanceItem.id && r.camera === grid.camera);\n      for (let j = 0; j < instanceItemReviews.length; j += 1) {\n        const review = instanceItemReviews[j];\n        const anchor = createReviewAnchorByReview(review, grid.view.reviewLayer, grid.view.viewScale);\n        if (anchor) {\n          anchor.data = review;\n          anchor.visible = visible;\n          addAnchorListeners(anchor);\n          grid.reviewAnchors.push(anchor);\n        }\n      }\n    }\n\n    if (instanceItems.length === 0) {\n      // missing reviews\n      const frameReviews = reviews[grid.frameIndex] || [];\n      for (let i = 0; i < frameReviews.length; i += 1) {\n        const review = frameReviews[i];\n        if (review.result === ReviewResult.REJECT && review.camera === grid.camera) {\n          const { instanceId, instanceItemId } = review;\n          if (!instanceId || !instanceItemId || !instances[instanceId]?.items[instanceItemId]?.cameras[grid.camera]?.frames[grid.frameIndex]) {\n            const anchor = createReviewAnchorByReview(review, grid.view.reviewLayer, grid.view.viewScale);\n            if (anchor) {\n              anchor.data = review;\n              anchor.visible = visible;\n              addAnchorListeners(anchor);\n              grid.reviewAnchors.push(anchor);\n            }\n          }\n        }\n      }\n    }\n\n    grid.reviewAnchorsLoaded = true;\n  };\n\n  addShapeListeners(grid: GridView, shape: Shape<ShapeData>) {\n    shape.on(EventAction.SELECTED, (s) => {\n      // set camera & frame index\n      if (this.rootStore.frame.currentCamera !== grid.camera) {\n        this.rootStore.frame.setCamera(grid.camera);\n      }\n      if (this.rootStore.frame.currentFrame !== grid.frameIndex) {\n        this.rootStore.frame.setFrame(grid.frameIndex);\n      }\n      // select instance item\n      const { instanceItem } = grid.shapes[s.uid] || {};\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      // update shape selected status\n      Object.values(grid.shapes).forEach((shapeItem) => {\n        shapeItem.shape.selected = shapeItem.shape.uid === shape.uid;\n      });\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      grid.setViewScaled();\n      const { instanceItem } = grid.shapes[s.uid] || {};\n      if (instanceItem) {\n        this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, grid.frameIndex, s.shapeType, data);\n        this.rootStore.cancelShapeWorking();\n      }\n    });\n    shape.on(EventAction.REMOVED, (s) => {\n      grid.setViewScaled();\n      const { instanceItem } = grid.shapes[s.uid] || {};\n      if (instanceItem) {\n        this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [grid.frameIndex], grid.camera);\n      }\n    });\n    shape.on(EventAction.CONTEXT_MENU, (s, p) => this.rootStore.openContextMenu(p));\n  }\n\n  getCurrentSelectedGrid() {\n    if (this.rootStore.filter.filterMode) {\n      const { selectedInstances } = this.rootStore.instance;\n      if (selectedInstances.length === 1) {\n        const { currentFrame, currentCamera } = this.rootStore.frame;\n        const key = this.generateGridKey(currentFrame, currentCamera, selectedInstances[0].id);\n        return this.grids.find((grid) => grid.key === key);\n      }\n    }\n    return this.grids[this.rootStore.frame.currentFrame];\n  }\n\n  getCurrentSelectedShape(): Shape<ShapeData> | undefined {\n    const selectedGrid = this.getCurrentSelectedGrid();\n    if (selectedGrid) {\n      const shapeItem = Object.values(selectedGrid?.shapes || {})\n        .find(({ shape }) => shape.selected && shape.borderStyle !== BorderStyle.DASHED);\n      return shapeItem?.shape;\n    }\n    return undefined;\n  }\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete() {\n    const selectedPixelShape = this.rootStore.segmentation.getSelectedShape();\n    const pixelSegDeleted = selectedPixelShape?.editable && selectedPixelShape.deleteSelectedPolygon();\n    if (pixelSegDeleted) {\n      return;\n    }\n\n    const selectedShape = this.getCurrentSelectedShape();\n    if (selectedShape) {\n      const pointsDeleted = selectedShape.deleteSelectedPoints();\n      if (!pointsDeleted) {\n        const { selectedInstanceItems } = this.rootStore.instance;\n        this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItems[0], [this.rootStore.frame.currentFrame]);\n        this.rootStore.filter.filterInstances();\n      }\n    }\n  }\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem(instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) {\n    if (this.rootStore.filter.filterMode) {\n      message.warning(i18n.translate('GRID_ERR_ADD_SHAPE_IN_FILTER_MODE'));\n      return;\n    }\n    const { currentFrame } = this.rootStore.frame;\n    if (instanceItem.cameras[camera]?.frames[currentFrame]) {\n      // already exist\n      return;\n    }\n    const imageBounds = this.rootStore.frame.getImageBoundsForCamera(camera, currentFrame);\n    const shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n    if (shapeInfo) {\n      if (shapeInfo.shapeType === ShapeType.PIXEL) {\n        // resolve pixel\n        const newData = this.rootStore.segmentation.resolvePixelShapeData(shapeInfo.shape as PixelData);\n        if (!newData) {\n          return;\n        }\n        shapeInfo.shape = newData;\n      } else {\n        const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n        if (area < this.rootStore.config.minArea) {\n          message.warning(i18n.translate('MIN_AREA_ALERT'));\n          return;\n        }\n      }\n      const { activeLayerIndex } = this.rootStore.config;\n      this.rootStore.instance.updateFrameShapeForInstanceItem(\n        instanceItem,\n        currentFrame,\n        shapeInfo.shapeType,\n        shapeInfo.shape,\n        activeLayerIndex,\n        shapeInfo.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(activeLayerIndex, currentFrame, camera),\n        camera,\n      );\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  }\n\n  /**\n   * add all predicted shapes to instances\n   * @param instances\n   */\n  addShapesToInstances = (instances: Instance[]) => {\n    message.warning(i18n.translate('GRID_ERR_ADD_SHAPES_TO_INSTANCES'));\n  };\n\n  /**\n   * add predicted shapes to instance\n   * @param instance\n   * @param camera\n   */\n  addShapesToInstance = (instance: Instance, camera = this.rootStore.frame.currentCamera) => {\n    if (this.rootStore.filter.filterMode) {\n      message.warning(i18n.translate('GRID_ERR_ADD_SHAPE_IN_FILTER_MODE'));\n      return;\n    }\n    const { activeLayerIndex } = this.rootStore.config;\n    const { resolvePixelShapeData } = this.rootStore.segmentation;\n    const { currentFrame, getImageBoundsForCamera, getNextShapeOrder } = this.rootStore.frame;\n    const imageBounds = getImageBoundsForCamera(camera, currentFrame);\n\n    const instanceItems: {\n      instanceItem: InstanceItem;\n      camera: string;\n      frameIndex: number;\n      shapeType: ShapeType;\n      shape: ShapeData;\n      layer: number;\n      order: number;\n    }[] = [];\n    Object.values(instance.items).forEach((instanceItem) => {\n      if (!instanceItem.cameras[camera]?.frames[currentFrame]) {\n        // not exist\n        const shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n        if (shapeInfo) {\n          if (shapeInfo.shapeType === ShapeType.PIXEL) {\n            // resolve pixel\n            const newData = resolvePixelShapeData(shapeInfo.shape as PixelData);\n            if (!newData) {\n              return;\n            }\n            shapeInfo.shape = newData;\n          } else {\n            const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n            if (area < this.rootStore.config.minArea) {\n              return;\n            }\n          }\n          instanceItems.push({\n            instanceItem,\n            camera,\n            frameIndex: currentFrame,\n            shapeType: shapeInfo.shapeType,\n            shape: shapeInfo.shape,\n            layer: activeLayerIndex,\n            order: shapeInfo.shapeType === ShapeType.PIXEL ? 0 : getNextShapeOrder(activeLayerIndex, currentFrame, camera),\n          });\n        }\n      }\n    });\n    if (instanceItems.length > 0) {\n      this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      // select\n      this.rootStore.instance.selectInstanceItem(null);\n      this.rootStore.instance.selectInstance(instance);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  };\n\n  /**\n   * update shapes interactive\n   * @param interactive\n   * @param ignoreIds\n   */\n  updateShapesInteractive = (interactive: boolean, ignoreIds?: string[]) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape, instanceItem }) => {\n        if (ignoreIds && ignoreIds.includes(shape.uid)) {\n          return;\n        }\n        shape.interactive = interactive;\n        if (interactive && instanceItem.selected) {\n          shape.selected = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable: boolean) {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.editable = editable;\n      });\n    });\n  }\n\n  /**\n   * update shapes user data mode\n   * @param userDataMode\n   */\n  updateShapesUserDataMode = (userDataMode: UserDataMode) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.userDataMode = userDataMode;\n      });\n    });\n  };\n\n  /**\n   * update rotate handle mode when shape rotate mode is handle\n   * @param shapeRotateHandleMode\n   */\n  updateShapesRotateHandleMode = (shapeRotateHandleMode: ShapeRotateHandleMode) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.rotateHandleMode = shapeRotateHandleMode;\n      });\n    });\n  };\n\n  /**\n   * update shapes rotate mode\n   * @param shapeRotateMode\n   */\n  updateShapesRotateMode = (shapeRotateMode: ShapeRotateMode) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.rotateMode = shapeRotateMode;\n      });\n    });\n  };\n\n  /**\n   * update shapes show auxiliary lie\n   * @param showAuxiliaryLines\n   */\n  updateShapesShowAuxiliaryLines = (showAuxiliaryLines: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        if (shape instanceof Rectangle) {\n          shape.showAuxiliaryLines = showAuxiliaryLines;\n        }\n      });\n    });\n  };\n\n  /**\n   * update pixel shapes show bounds\n   * @param showPixelShapeBounds\n   */\n  updatePixelShapesShowBounds = (showPixelShapeBounds: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        if (shape instanceof Pixel) {\n          shape.showShapeBounds = showPixelShapeBounds;\n        }\n      });\n    });\n  };\n\n  /**\n   * update shapes double click finish (only for pixel shape)\n   * @param dblclickFinish\n   */\n  updateShapesDoubleClickFinish = (dblclickFinish: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        if (shape.shapeType === ShapeType.PIXEL) {\n          (shape as Pixel).dblclickFinish = dblclickFinish;\n        }\n      });\n    });\n  };\n\n  /**\n   * update rectangle shapes auto snap tolerance\n   * @param tolerance\n   */\n  updateRectangleShapesAutoSnapTolerance = (tolerance: number) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        if (shape instanceof Rectangle) {\n          shape.autoSnapTolerance = tolerance;\n        }\n      });\n    });\n  };\n\n  updateShapesFill = (fill: boolean) => {\n    const fillAlpha = fill ? this.rootStore.shape.config.alpha / 100 : 0;\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.alpha = fillAlpha;\n      });\n    });\n  };\n\n  updateShapesAlpha = (alpha: number) => {\n    if (this.rootStore.shape.config.fill) {\n      this.grids.forEach((grid) => {\n        Object.values(grid.shapes).forEach(({ shape }) => {\n          shape.alpha = alpha;\n        });\n      });\n    }\n  };\n\n  updateShapesBorderAlpha = (borderAlpha: number) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.borderAlpha = borderAlpha;\n      });\n    });\n  };\n\n  updateShapesBorderWidth = (borderWidth: number) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.borderWidth = borderWidth;\n      });\n    });\n  };\n\n  updateDotsRadius = (dotRadius: number) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        if (shape instanceof Dot) {\n          shape.dotRadius = dotRadius;\n        } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n          shape.vertexSize = dotRadius;\n        }\n      });\n    });\n  };\n\n  updateShowSideLength = (showSideLength: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.showSideLength = showSideLength;\n      });\n    });\n  };\n\n  updateShowDirection = (showDirection: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.showDirection = showDirection;\n      });\n    });\n  };\n\n  updateShowVertex = (showVertex: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.showVertex = showVertex;\n      });\n    });\n  };\n\n  updateShowVertexOrder = (showVertexOrder: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n    });\n  };\n\n  updateVertexSize = (vertexSize: number) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape }) => {\n        if (shape.shapeType !== ShapeType.KEYPOINTS) {\n          shape.vertexSize = vertexSize;\n        }\n      });\n    });\n  };\n\n  updateLabelMode = (labelMode: boolean) => {\n    this.grids.forEach((grid) => {\n      Object.values(grid.shapes).forEach(({ shape, instanceItem }) => {\n        shape.label = labelMode ? instanceItem.label : '';\n      });\n    });\n  };\n\n  hideOrShowReviews() {\n    const { visible } = this.rootStore.review;\n    for (let i = 0; i < this.grids.length; i += 1) {\n      const grid = this.grids[i];\n      grid.reviewAnchors.forEach((anchor) => {\n        anchor.visible = visible;\n      });\n    }\n  }\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,MAAM,EAAEC,cAAc,EAAEC,UAAU,QAAQ,MAAM;AAEzD,SAASC,OAAO,QAAQ,MAAM;AAE9B,SAASC,QAAQ,QAAQ,QAAQ;AAEjC,OAAOC,QAAQ,IAAIC,cAAc,QAAQ,kBAAkB;AAC3D,OAAOC,OAAO,MAAM,+BAA+B;AAGnD,SAASC,kBAAkB,EAAEC,YAAY,EAAEC,QAAQ,QAA8D,UAAU;AAC3H,SAASC,aAAa,QAAQ,UAAU;AACxC,OAAOC,IAAI,MAAM,YAAY;AAC7B,SAAgBC,WAAW,EAAEC,WAAW,QAA8D,2BAA2B;AACjI,SAAoBC,SAAS,QAAQ,2BAA2B;AAChE,OAAOC,KAAK,MAAqB,2BAA2B;AAC5D,OAAOC,SAAS,MAAM,+BAA+B;AACrD,OAAOC,GAAG,MAAM,yBAAyB;AACzC,SAASC,mBAAmB,QAAQ,cAAc;;AAElD;AACA;AACA;AACA;AACA,eAAe,MAAMC,SAAS,CAAC;EAmD7BC,WAAWA,CAACC,SAA2B,EAAE;IAlDzC;AACF;AACA;IAFE,KAGAA,SAAS;IAET;AACF;AACA;IAFE,KAGAC,eAAe,GAA6B,CAAC,CAAC;IAE9C;AACF;AACA;IAFE,KAGAC,KAAK,GAAe,EAAE;IAEtB;AACF;AACA;IAFE,KAGAC,YAAY,GAAG,CAAC,CAAC;IAEjB;AACF;AACA;IAFE,KAGAC,sBAAsB,GAAG,KAAK;IAE9B;AACF;AACA;IAFE,KAGAC,uBAAuB,GAAG;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IAExC;AACF;AACA;IAFE,KAGAC,uBAAuB;IAEvB;AACF;AACA;IAFE,KAGAC,eAAe,GAAG,KAAK;IAEvB;AACF;AACA;IAFE,KAGAC,cAAc;IAEd;AACF;AACA;IAFE,KAGAC,qBAAqB,GAAgB,IAAIC,GAAG,CAAC,CAAC;IAAA,KAsB9CC,eAAe,GAAIC,QAAgB,IAAK;MACtC,IAAI,CAACX,YAAY,GAAGW,QAAQ;IAC9B,CAAC;IAAA,KAEDC,eAAe,GAAGjC,QAAQ,CAAC,CAACkC,QAAkC,EAAEC,cAAyB,KAAK;MAC5F,IAAI,IAAI,CAACjB,SAAS,CAACkB,QAAQ,IAAI,IAAI,CAAClB,SAAS,CAACmB,KAAK,CAACC,SAAS,EAAE;QAC7D;MACF;MACA,IAAI,CAACf,uBAAuB,GAAGW,QAAQ;MACvC,IAAI,CAACR,uBAAuB,GAAGS,cAAc;MAC7C,IAAI,CAACb,sBAAsB,GAAG,IAAI;IACpC,CAAC,EAAE,CAAC,CAAC;IAAA,KAELiB,gBAAgB,GAAG,MAAM;MACvB,IAAI,CAACjB,sBAAsB,GAAG,KAAK;MACnC,IAAI,CAACI,uBAAuB,GAAGc,SAAS;IAC1C,CAAC;IAAA,KAEDC,kBAAkB,GAAIC,IAAa,IAAK;MACtC,IAAI,CAACf,eAAe,GAAGe,IAAI;MAC3B,IAAI,CAACb,qBAAqB,CAACc,OAAO,CAAEC,GAAG,IAAK;QAC1C,IAAI,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,EAAE;UAC7B,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,CAACC,aAAa,GAAG,KAAK;QACjD;MACF,CAAC,CAAC;MACF,IAAI,CAAChB,qBAAqB,CAACiB,KAAK,CAAC,CAAC;MAClC,IAAI,CAACC,oBAAoB,CAAC,CAAC;IAC7B,CAAC;IAAA,KAEDC,qBAAqB,GAAIC,MAAgB,IAAK;MAC5C,MAAM;QAAEC;MAAkB,CAAC,GAAG,IAAI,CAAChC,SAAS,CAACiC,QAAQ;MACrD,IAAID,iBAAiB,CAACE,MAAM,KAAK,CAAC,EAAE;QAClC,MAAM;UAAEC,YAAY;UAAEC;QAAc,CAAC,GAAG,IAAI,CAACpC,SAAS,CAACmB,KAAK;QAC5D,MAAMkB,WAAW,GAAG,IAAI,CAACC,eAAe,CAACH,YAAY,EAAEC,aAAa,EAAEJ,iBAAiB,CAAC,CAAC,CAAC,CAACO,EAAE,CAAC;QAC9F,MAAMC,iBAAiB,GAAG,IAAI,CAACtC,KAAK,CAACuC,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAAChB,GAAG,KAAKW,WAAW,CAAC;QAClF,MAAMM,SAAS,GAAG,IAAI,CAACzC,KAAK,CAACuC,SAAS,CAAEC,IAAI,IAAKA,IAAI,CAAChB,GAAG,KAAKK,MAAM,CAACL,GAAG,CAAC;QACzE,IAAIc,iBAAiB,IAAI,CAAC,IAAIG,SAAS,IAAI,CAAC,EAAE;UAC5C,MAAMC,aAAa,GAAGC,IAAI,CAACC,GAAG,CAACN,iBAAiB,EAAEG,SAAS,CAAC;UAC5D,MAAMI,WAAW,GAAGF,IAAI,CAACG,GAAG,CAACR,iBAAiB,EAAEG,SAAS,CAAC;UAC1D,KAAK,IAAIM,CAAC,GAAGL,aAAa,EAAEK,CAAC,IAAIF,WAAW,EAAEE,CAAC,IAAI,CAAC,EAAE;YACpD,MAAMP,IAAI,GAAG,IAAI,CAACxC,KAAK,CAAC+C,CAAC,CAAC;YAC1B,IAAI,CAACtC,qBAAqB,CAACuC,GAAG,CAACR,IAAI,CAAChB,GAAG,CAAC;YACxC,IAAI,IAAI,CAACzB,eAAe,CAACyC,IAAI,CAAChB,GAAG,CAAC,EAAE;cAClC,IAAI,CAACzB,eAAe,CAACyC,IAAI,CAAChB,GAAG,CAAC,CAACC,aAAa,GAAG,IAAI;YACrD;UACF;UACA,IAAI,CAACE,oBAAoB,CAAC,CAAC;QAC7B;MACF;IACF,CAAC;IAAA,KAEDsB,uBAAuB,GAAIT,IAAc,IAAK;MAC5C,MAAM;QAAEhB;MAAI,CAAC,GAAGgB,IAAI;MACpB,IAAI,IAAI,CAAC/B,qBAAqB,CAACyC,GAAG,CAAC1B,GAAG,CAAC,EAAE;QACvC,IAAI,CAACf,qBAAqB,CAAC0C,MAAM,CAAC3B,GAAG,CAAC;QACtC,IAAI,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,EAAE;UAC7B,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,CAACC,aAAa,GAAG,KAAK;QACjD;MACF,CAAC,MAAM;QACL,IAAI,CAAChB,qBAAqB,CAACuC,GAAG,CAACxB,GAAG,CAAC;QACnC,IAAI,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,EAAE;UAC7B,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,CAACC,aAAa,GAAG,IAAI;QAChD;MACF;MACA,IAAI,CAACE,oBAAoB,CAAC,CAAC;IAC7B,CAAC;IAAA,KAyUDyB,0BAA0B,GAAIZ,IAAc,IAAK;MAC/C,IAAI,IAAI,CAAC1C,SAAS,CAACuD,MAAM,CAACC,UAAU,EAAE;QACpC,MAAM;UAAEC,UAAU;UAAEC,UAAU;UAAEC;QAAO,CAAC,GAAG,IAAI,CAACC,YAAY,CAAClB,IAAI,CAAChB,GAAG,CAAC;QACtE,IAAI+B,UAAU,EAAE;UACd,MAAMxB,QAAQ,GAAG,IAAI,CAACjC,SAAS,CAACiC,QAAQ,CAAC4B,SAAS,CAACJ,UAAU,CAAC;UAC9D,IAAIxB,QAAQ,EAAE;YACZ,MAAM;cAAE6B;YAAkB,CAAC,GAAG,IAAI,CAAC9D,SAAS,CAACuD,MAAM;YACnD,MAAM;cAAEQ,OAAO,EAAEC;YAAgB,CAAC,GAAGF,iBAAiB,CAACL,UAAU,CAAC;YAClE,MAAMQ,MAAM,GAAGD,eAAe,CAACL,MAAM,CAAC;YACtCjB,IAAI,CAACwB,aAAa,GAAGD,MAAM,CAACP,UAAU,CAAC;UACzC;QACF;MACF,CAAC,MAAM;QACL,MAAM;UAAES,eAAe;UAAEnC;QAAkB,CAAC,GAAG,IAAI,CAAChC,SAAS,CAACiC,QAAQ;QACtE,MAAMmC,gBAAgB,GAAG,CAACD,eAAe,GAAGnC,iBAAiB,CAAC,CAAC,CAAC,GAAGV,SAAS;QAC5EoB,IAAI,CAACwB,aAAa,GAAGG,MAAM,CAACC,MAAM,CAAC,CAAAF,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEG,KAAK,KAAI,CAAC,CAAC,CAAC;MACnE;IACF,CAAC;IAAA,KAEDC,kBAAkB,GAAI9B,IAAc,IAAK;MACvC,IAAI,CAACA,IAAI,CAAC+B,WAAW,IAAI,CAAC/B,IAAI,CAACgC,IAAI,IAAIhC,IAAI,CAACgC,IAAI,CAACC,cAAc,IAAIjC,IAAI,CAACkC,YAAY,EAAE;QACpFlC,IAAI,CAACmC,aAAa,CAAC,CAAC;QACpB;MACF;MAEA,MAAM;QAAEX,aAAa;QAAEY,MAAM;QAAEnB,MAAM;QAAED;MAAW,CAAC,GAAGhB,IAAI;;MAE1D;MACA2B,MAAM,CAACC,MAAM,CAACQ,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;QAAEsD;MAAM,CAAC,KAAK;QAC3CA,KAAK,CAACC,OAAO,CAAC,CAAC;MACjB,CAAC,CAAC;MACFtC,IAAI,CAACoC,MAAM,GAAG,CAAC,CAAC;;MAEhB;MACA,MAAM;QAAEtB;MAAW,CAAC,GAAG,IAAI,CAACxD,SAAS,CAACuD,MAAM;MAC5C,MAAM;QAAE0B,YAAY;QAAEC,gBAAgB;QAAEC;MAAU,CAAC,GAAG,IAAI,CAACnF,SAAS,CAACoF,MAAM;MAC3E,MAAM;QAAEC,WAAW;QAAEC;MAAe,CAAC,GAAG,IAAI,CAACtF,SAAS,CAAC+E,KAAK;MAC5D,MAAMQ,WAAW,GAAG,IAAI,CAACvF,SAAS,CAACmB,KAAK,CAACqE,uBAAuB,CAAC7B,MAAM,EAAED,UAAU,CAAC;MACpF,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,aAAa,CAAChC,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;QAAA,IAAAwC,qBAAA;QAChD,MAAMC,YAAY,GAAGxB,aAAa,CAACjB,CAAC,CAAC;QACrC,MAAM0C,SAAS,IAAAF,qBAAA,GAAGC,YAAY,CAAC3B,OAAO,CAACJ,MAAM,CAAC,cAAA8B,qBAAA,uBAA5BA,qBAAA,CAA8BxB,MAAM,CAACP,UAAU,CAAC;QAClE,IAAIiC,SAAS,EAAE;UACb,MAAM;YAAEC,KAAK,GAAGV;UAAiB,CAAC,GAAGS,SAAS;UAC9C,IAAIE,KAAK;UACT,IAAIF,SAAS,CAACE,KAAK,KAAKvE,SAAS,EAAE;YACjCuE,KAAK,GAAGF,SAAS,CAACE,KAAK;UACzB,CAAC,MAAM;YACLA,KAAK,GAAGF,SAAS,CAACG,SAAS,KAAKrG,SAAS,CAACsG,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC/F,SAAS,CAACmB,KAAK,CAAC6E,iBAAiB,CAACJ,KAAK,EAAElC,UAAU,EAAEC,MAAM,CAAC;UACzH;UACA,MAAMoB,KAAK,GAAGM,WAAW,CACvB3C,IAAI,CAACgC,IAAI,CAACuB,qBAAqB,CAACL,KAAK,CAAC,EACtCL,WAAW,EACXG,YAAY,CAACQ,WAAW,CAACC,KAAK,EAC9BT,YAAY,CAACzD,QAAQ,CAACmE,QAAQ,EAC9BV,YAAY,CAACW,IAAI,EACjBX,YAAY,EACZC,SAAS,CAACG,SAAS,EACnBH,SAAS,CAACZ,KAAK,EACfc,KAAK,EACLV,SAAS,GAAGO,YAAY,CAACY,KAAK,GAAG,EAAE,EACnC3C,MACF,CAAC;UACD+B,YAAY,CAACa,mBAAmB,CAAC;YAC/BC,SAAS,EAAEzB,KAAK,CAACyB,SAAS;YAC1BC,SAAS,EAAE1B,KAAK,CAAC2B,WAAW;YAC5BC,UAAU,EAAE5B,KAAK,CAAC6B,WAAW;YAC7BT,KAAK,EAAET,YAAY,CAACQ,WAAW,CAACC;UAClC,CAAC,CAAC;UAEF,MAAMU,QAAQ,GAAG,CAACrD,UAAU,IAC1Bd,IAAI,CAACiB,MAAM,KAAK,IAAI,CAAC3D,SAAS,CAACmB,KAAK,CAACiB,aAAa,IAAIM,IAAI,CAACgB,UAAU,KAAK,IAAI,CAAC1D,SAAS,CAACmB,KAAK,CAACgB,YAChG;UACD4C,KAAK,CAAC+B,KAAK,GAAGpE,IAAI,CAACgC,IAAI,CAACqC,SAAS;UACjChC,KAAK,CAACiC,QAAQ,GAAG,CAAC,IAAI,CAAChH,SAAS,CAACkB,QAAQ,IAAI,CAACyE,SAAS,CAACsB,MAAM;UAC9DlC,KAAK,CAAC8B,QAAQ,GAAGnB,YAAY,CAACmB,QAAQ,IAAIA,QAAQ;UAClD,IAAI,CAACK,iBAAiB,CAACxE,IAAI,EAAEqC,KAAK,CAAC;UAEnCO,cAAc,CAACP,KAAK,EAAEW,YAAY,EAAE/B,MAAM,EAAED,UAAU,CAAC;UACvD,IAAIgC,YAAY,CAACzD,QAAQ,CAAC4E,QAAQ,IAAIA,QAAQ,EAAE;YAC9C9B,KAAK,CAAC2B,WAAW,GAAG,QAAQ;YAC5B,IAAI3B,KAAK,CAACe,SAAS,KAAKrG,SAAS,CAAC0H,GAAG,EAAE;cACrCpC,KAAK,CAACoB,KAAK,GAAG,QAAQ;YACxB;UACF;UAEAzD,IAAI,CAACoC,MAAM,CAACC,KAAK,CAACqC,GAAG,CAAC,GAAG;YAAErC,KAAK;YAAEW;UAAa,CAAC;QAClD,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC1F,SAAS,CAACkB,QAAQ,IAAI+D,YAAY,IAAI,CAACzB,UAAU,EAAE;UAClE;UACA,MAAM6D,SAAS,GAAG3B,YAAY,CAAC4B,YAAY,CAAC3D,MAAM,EAAED,UAAU,EAAE6B,WAAW,CAAC;UAC5E,IAAI8B,SAAS,IAAIA,SAAS,CAACvB,SAAS,KAAKrG,SAAS,CAACsG,KAAK,EAAE;YACxD,MAAMwB,cAAc,GAAGlC,WAAW,CAChC3C,IAAI,CAACgC,IAAI,CAAC8C,iBAAiB,EAC3BjC,WAAW,EACXG,YAAY,CAACQ,WAAW,CAACC,KAAK,EAC9BT,YAAY,CAACzD,QAAQ,CAACmE,QAAQ,EAC9BV,YAAY,CAACW,IAAI,EACjBX,YAAY,EACZ2B,SAAS,CAACvB,SAAS,EACnBuB,SAAS,CAACtC,KAAK,EACf,IAAI;YAAE;YACNI,SAAS,GAAGO,YAAY,CAACY,KAAK,GAAG,EACnC,CAAC;YACDiB,cAAc,CAACE,WAAW,GAAGlI,WAAW,CAACmI,MAAM;YAC/CH,cAAc,CAACb,WAAW,GAAG,QAAQ;YACrC,IAAIa,cAAc,CAACzB,SAAS,KAAKrG,SAAS,CAAC0H,GAAG,EAAE;cAC9CI,cAAc,CAACpB,KAAK,GAAG,QAAQ;YACjC;YAEAoB,cAAc,CAACT,KAAK,GAAGpE,IAAI,CAACgC,IAAI,CAACqC,SAAS;YAC1CQ,cAAc,CAACV,QAAQ,GAAGnB,YAAY,CAACmB,QAAQ;YAC/C,IAAI,CAACK,iBAAiB,CAACxE,IAAI,EAAE6E,cAAc,CAAC;YAE5C7E,IAAI,CAACoC,MAAM,CAACyC,cAAc,CAACH,GAAG,CAAC,GAAG;cAAErC,KAAK,EAAEwC,cAAc;cAAE7B;YAAa,CAAC;UAC3E;QACF;MACF;MAEAhD,IAAI,CAACiF,MAAM,GAAGtD,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACvB,MAAM,CAAC,CAAC;QAAEwB;MAAM,CAAC,KAAKA,KAAK,CAAC0C,WAAW,KAAKlI,WAAW,CAACmI,MAAM,CAAC,CAACxF,MAAM,KAAK,CAAC,GACjHlD,cAAc,CAAC4I,KAAK,GACpB5I,cAAc,CAAC6I,OAAO;MAC1BnF,IAAI,CAACmC,aAAa,CAAC,CAAC;MACpBnC,IAAI,CAACkC,YAAY,GAAG,IAAI;IAC1B,CAAC;IAAA,KAEDkD,yBAAyB,GAAIpF,IAAc,IAAK;MAC9C,MAAMwB,aAAa,GAAG,IAAI,CAAClE,SAAS,CAACuD,MAAM,CAACC,UAAU,GAClDd,IAAI,CAACwB,aAAa,GAClB,IAAI,CAAClE,SAAS,CAACiC,QAAQ,CAAC8F,qBAAqB;MACjD,MAAM;QAAEC;MAAyB,CAAC,GAAG,IAAI,CAAChI,SAAS,CAACiI,MAAM;MAC1DvF,IAAI,CAACwF,QAAQ,GAAGhE,aAAa,CAACiE,IAAI,CAAElF,CAAC,IAAK+E,wBAAwB,CAAC/E,CAAC,EAAEP,IAAI,CAACiB,MAAM,EAAEjB,IAAI,CAACgB,UAAU,CAAC,KAAKvE,YAAY,CAACiJ,MAAM,CAAC;MAC5H1F,IAAI,CAAC2F,mBAAmB,GAAG,KAAK;IAClC,CAAC;IAAA,KAEDC,mBAAmB,GAAI5F,IAAc,IAAK;MACxC,IAAI,CAACA,IAAI,CAACgC,IAAI,IAAI,CAAChC,IAAI,CAACgC,IAAI,CAAC6D,WAAW,IAAI7F,IAAI,CAACgC,IAAI,CAACC,cAAc,IAAIjC,IAAI,CAAC2F,mBAAmB,EAAE;QAChG;MACF;MAEA3F,IAAI,CAAC8F,aAAa,CAAC/G,OAAO,CAAEgH,MAAM,IAAK;QACrCA,MAAM,CAACzD,OAAO,CAAC,CAAC;MAClB,CAAC,CAAC;MACFtC,IAAI,CAAC8F,aAAa,GAAG,EAAE;MAEvB,MAAM;QAAEE,OAAO;QAAEC,OAAO;QAAEC,0BAA0B;QAAEC;MAAmB,CAAC,GAAG,IAAI,CAAC7I,SAAS,CAACiI,MAAM;MAClG,MAAM;QAAEF,qBAAqB;QAAElE;MAAU,CAAC,GAAG,IAAI,CAAC7D,SAAS,CAACiC,QAAQ;MACpE,MAAMiC,aAAa,GAAG,IAAI,CAAClE,SAAS,CAACuD,MAAM,CAACC,UAAU,GAClDd,IAAI,CAACwB,aAAa,GAClB6D,qBAAqB;MACzB,KAAK,IAAI9E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,aAAa,CAAChC,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;QAChD,MAAMyC,YAAY,GAAGxB,aAAa,CAACjB,CAAC,CAAC;QACrC,MAAM6F,mBAAmB,GAAG,CAACJ,OAAO,CAAChG,IAAI,CAACgB,UAAU,CAAC,IAAI,EAAE,EAAEH,MAAM,CAAEwF,CAAC,IAAKA,CAAC,CAACC,cAAc,KAAKtD,YAAY,CAACnD,EAAE,IAAIwG,CAAC,CAACpF,MAAM,KAAKjB,IAAI,CAACiB,MAAM,CAAC;QAC5I,KAAK,IAAIsF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,mBAAmB,CAAC5G,MAAM,EAAE+G,CAAC,IAAI,CAAC,EAAE;UACtD,MAAMhB,MAAM,GAAGa,mBAAmB,CAACG,CAAC,CAAC;UACrC,MAAMR,MAAM,GAAGG,0BAA0B,CAACX,MAAM,EAAEvF,IAAI,CAACgC,IAAI,CAAC6D,WAAW,EAAE7F,IAAI,CAACgC,IAAI,CAACqC,SAAS,CAAC;UAC7F,IAAI0B,MAAM,EAAE;YACVA,MAAM,CAACS,IAAI,GAAGjB,MAAM;YACpBQ,MAAM,CAACE,OAAO,GAAGA,OAAO;YACxBE,kBAAkB,CAACJ,MAAM,CAAC;YAC1B/F,IAAI,CAAC8F,aAAa,CAACW,IAAI,CAACV,MAAM,CAAC;UACjC;QACF;MACF;MAEA,IAAIvE,aAAa,CAAChC,MAAM,KAAK,CAAC,EAAE;QAC9B;QACA,MAAMkH,YAAY,GAAGV,OAAO,CAAChG,IAAI,CAACgB,UAAU,CAAC,IAAI,EAAE;QACnD,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmG,YAAY,CAAClH,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;UAC/C,MAAMgF,MAAM,GAAGmB,YAAY,CAACnG,CAAC,CAAC;UAC9B,IAAIgF,MAAM,CAACoB,MAAM,KAAKlK,YAAY,CAACiJ,MAAM,IAAIH,MAAM,CAACtE,MAAM,KAAKjB,IAAI,CAACiB,MAAM,EAAE;YAAA,IAAA2F,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA;YAC1E,MAAM;cAAE/F,UAAU;cAAEuF;YAAe,CAAC,GAAGf,MAAM;YAC7C,IAAI,CAACxE,UAAU,IAAI,CAACuF,cAAc,IAAI,GAAAM,qBAAA,GAACzF,SAAS,CAACJ,UAAU,CAAC,cAAA6F,qBAAA,wBAAAC,sBAAA,GAArBD,qBAAA,CAAuB/E,KAAK,CAACyE,cAAc,CAAC,cAAAO,sBAAA,wBAAAC,sBAAA,GAA5CD,sBAAA,CAA8CxF,OAAO,CAACrB,IAAI,CAACiB,MAAM,CAAC,cAAA6F,sBAAA,uBAAlEA,sBAAA,CAAoEvF,MAAM,CAACvB,IAAI,CAACgB,UAAU,CAAC,GAAE;cAClI,MAAM+E,MAAM,GAAGG,0BAA0B,CAACX,MAAM,EAAEvF,IAAI,CAACgC,IAAI,CAAC6D,WAAW,EAAE7F,IAAI,CAACgC,IAAI,CAACqC,SAAS,CAAC;cAC7F,IAAI0B,MAAM,EAAE;gBACVA,MAAM,CAACS,IAAI,GAAGjB,MAAM;gBACpBQ,MAAM,CAACE,OAAO,GAAGA,OAAO;gBACxBE,kBAAkB,CAACJ,MAAM,CAAC;gBAC1B/F,IAAI,CAAC8F,aAAa,CAACW,IAAI,CAACV,MAAM,CAAC;cACjC;YACF;UACF;QACF;MACF;MAEA/F,IAAI,CAAC2F,mBAAmB,GAAG,IAAI;IACjC,CAAC;IA+HD;AACF;AACA;AACA;IAHE,KAIAoB,oBAAoB,GAAI5F,SAAqB,IAAK;MAChDhF,OAAO,CAAC6K,OAAO,CAACpK,IAAI,CAACqK,SAAS,CAAC,kCAAkC,CAAC,CAAC;IACrE,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKAC,mBAAmB,GAAG,CAAC3H,QAAkB,EAAE0B,MAAM,GAAG,IAAI,CAAC3D,SAAS,CAACmB,KAAK,CAACiB,aAAa,KAAK;MACzF,IAAI,IAAI,CAACpC,SAAS,CAACuD,MAAM,CAACC,UAAU,EAAE;QACpC3E,OAAO,CAAC6K,OAAO,CAACpK,IAAI,CAACqK,SAAS,CAAC,mCAAmC,CAAC,CAAC;QACpE;MACF;MACA,MAAM;QAAEzE;MAAiB,CAAC,GAAG,IAAI,CAAClF,SAAS,CAACoF,MAAM;MAClD,MAAM;QAAEyE;MAAsB,CAAC,GAAG,IAAI,CAAC7J,SAAS,CAAC8J,YAAY;MAC7D,MAAM;QAAE3H,YAAY;QAAEqD,uBAAuB;QAAEQ;MAAkB,CAAC,GAAG,IAAI,CAAChG,SAAS,CAACmB,KAAK;MACzF,MAAMoE,WAAW,GAAGC,uBAAuB,CAAC7B,MAAM,EAAExB,YAAY,CAAC;MAEjE,MAAM+B,aAQH,GAAG,EAAE;MACRG,MAAM,CAACC,MAAM,CAACrC,QAAQ,CAACsC,KAAK,CAAC,CAAC9C,OAAO,CAAEiE,YAAY,IAAK;QAAA,IAAAqE,sBAAA;QACtD,IAAI,GAAAA,sBAAA,GAACrE,YAAY,CAAC3B,OAAO,CAACJ,MAAM,CAAC,cAAAoG,sBAAA,uBAA5BA,sBAAA,CAA8B9F,MAAM,CAAC9B,YAAY,CAAC,GAAE;UACvD;UACA,MAAMkF,SAAS,GAAG3B,YAAY,CAAC4B,YAAY,CAAC3D,MAAM,EAAExB,YAAY,EAAEoD,WAAW,EAAE,IAAI,CAAC;UACpF,IAAI8B,SAAS,EAAE;YACb,IAAIA,SAAS,CAACvB,SAAS,KAAKrG,SAAS,CAACsG,KAAK,EAAE;cAC3C;cACA,MAAMiE,OAAO,GAAGH,qBAAqB,CAACxC,SAAS,CAACtC,KAAkB,CAAC;cACnE,IAAI,CAACiF,OAAO,EAAE;gBACZ;cACF;cACA3C,SAAS,CAACtC,KAAK,GAAGiF,OAAO;YAC3B,CAAC,MAAM;cACL,MAAMC,IAAI,GAAG5K,aAAa,CAACgI,SAAS,CAACvB,SAAS,EAAEuB,SAAS,CAACtC,KAAK,CAAC;cAChE,IAAIkF,IAAI,GAAG,IAAI,CAACjK,SAAS,CAACoF,MAAM,CAAC8E,OAAO,EAAE;gBACxC;cACF;YACF;YACAhG,aAAa,CAACiF,IAAI,CAAC;cACjBzD,YAAY;cACZ/B,MAAM;cACND,UAAU,EAAEvB,YAAY;cACxB2D,SAAS,EAAEuB,SAAS,CAACvB,SAAS;cAC9Bf,KAAK,EAAEsC,SAAS,CAACtC,KAAK;cACtBa,KAAK,EAAEV,gBAAgB;cACvBW,KAAK,EAAEwB,SAAS,CAACvB,SAAS,KAAKrG,SAAS,CAACsG,KAAK,GAAG,CAAC,GAAGC,iBAAiB,CAACd,gBAAgB,EAAE/C,YAAY,EAAEwB,MAAM;YAC/G,CAAC,CAAC;UACJ;QACF;MACF,CAAC,CAAC;MACF,IAAIO,aAAa,CAAChC,MAAM,GAAG,CAAC,EAAE;QAC5B,IAAI,CAAClC,SAAS,CAACiC,QAAQ,CAACkI,gCAAgC,CAACjG,aAAa,CAAC;QACvE;QACA,IAAI,CAAClE,SAAS,CAACiC,QAAQ,CAACmI,kBAAkB,CAAC,IAAI,CAAC;QAChD,IAAI,CAACpK,SAAS,CAACiC,QAAQ,CAACoI,cAAc,CAACpI,QAAQ,CAAC;QAChD,IAAI,CAACjC,SAAS,CAACiC,QAAQ,CAACqI,uBAAuB,CAAC,CAAC;MACnD;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;IAJE,KAKAC,uBAAuB,GAAG,CAACC,WAAoB,EAAEC,SAAoB,KAAK;MACxE,IAAI,CAACvK,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD,KAAK;UAAEW;QAAa,CAAC,KAAK;UAC9D,IAAI+E,SAAS,IAAIA,SAAS,CAACC,QAAQ,CAAC3F,KAAK,CAACqC,GAAG,CAAC,EAAE;YAC9C;UACF;UACArC,KAAK,CAACyF,WAAW,GAAGA,WAAW;UAC/B,IAAIA,WAAW,IAAI9E,YAAY,CAACmB,QAAQ,EAAE;YACxC9B,KAAK,CAAC8B,QAAQ,GAAG,IAAI;UACvB;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAcD;AACF;AACA;AACA;IAHE,KAIA8D,wBAAwB,GAAIC,YAA0B,IAAK;MACzD,IAAI,CAAC1K,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAAC6F,YAAY,GAAGA,YAAY;QACnC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAC,4BAA4B,GAAIC,qBAA4C,IAAK;MAC/E,IAAI,CAAC5K,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAACgG,gBAAgB,GAAGD,qBAAqB;QAChD,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAE,sBAAsB,GAAIC,eAAgC,IAAK;MAC7D,IAAI,CAAC/K,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAACmG,UAAU,GAAGD,eAAe;QACpC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAE,8BAA8B,GAAIC,kBAA2B,IAAK;MAChE,IAAI,CAAClL,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChD,IAAIA,KAAK,YAAYpF,SAAS,EAAE;YAC9BoF,KAAK,CAACqG,kBAAkB,GAAGA,kBAAkB;UAC/C;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAC,2BAA2B,GAAIC,oBAA6B,IAAK;MAC/D,IAAI,CAACpL,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChD,IAAIA,KAAK,YAAYrF,KAAK,EAAE;YAC1BqF,KAAK,CAACwG,eAAe,GAAGD,oBAAoB;UAC9C;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAE,6BAA6B,GAAIC,cAAuB,IAAK;MAC3D,IAAI,CAACvL,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChD,IAAIA,KAAK,CAACe,SAAS,KAAKrG,SAAS,CAACsG,KAAK,EAAE;YACtChB,KAAK,CAAW0G,cAAc,GAAGA,cAAc;UAClD;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAC,sCAAsC,GAAIC,SAAiB,IAAK;MAC9D,IAAI,CAACzL,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChD,IAAIA,KAAK,YAAYpF,SAAS,EAAE;YAC9BoF,KAAK,CAAC6G,iBAAiB,GAAGD,SAAS;UACrC;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDE,gBAAgB,GAAIC,IAAa,IAAK;MACpC,MAAMC,SAAS,GAAGD,IAAI,GAAG,IAAI,CAAC9L,SAAS,CAAC+E,KAAK,CAACK,MAAM,CAAC4G,KAAK,GAAG,GAAG,GAAG,CAAC;MACpE,IAAI,CAAC9L,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAACiH,KAAK,GAAGD,SAAS;QACzB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDE,iBAAiB,GAAID,KAAa,IAAK;MACrC,IAAI,IAAI,CAAChM,SAAS,CAAC+E,KAAK,CAACK,MAAM,CAAC0G,IAAI,EAAE;QACpC,IAAI,CAAC5L,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;UAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;YAAEsD;UAAM,CAAC,KAAK;YAChDA,KAAK,CAACiH,KAAK,GAAGA,KAAK;UACrB,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;IACF,CAAC;IAAA,KAEDE,uBAAuB,GAAIC,WAAmB,IAAK;MACjD,IAAI,CAACjM,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAACoH,WAAW,GAAGA,WAAW;QACjC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDC,uBAAuB,GAAIC,WAAmB,IAAK;MACjD,IAAI,CAACnM,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAACsH,WAAW,GAAGA,WAAW;QACjC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDC,gBAAgB,GAAIC,SAAiB,IAAK;MACxC,IAAI,CAACrM,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChD,IAAIA,KAAK,YAAYnF,GAAG,EAAE;YACxBmF,KAAK,CAACwH,SAAS,GAAGA,SAAS;UAC7B,CAAC,MAAM,IAAIxH,KAAK,CAACe,SAAS,KAAKrG,SAAS,CAAC+M,SAAS,EAAE;YAClDzH,KAAK,CAAC0H,UAAU,GAAGF,SAAS;UAC9B;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDG,oBAAoB,GAAIC,cAAuB,IAAK;MAClD,IAAI,CAACzM,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAAC4H,cAAc,GAAGA,cAAc;QACvC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDC,mBAAmB,GAAIC,aAAsB,IAAK;MAChD,IAAI,CAAC3M,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAAC8H,aAAa,GAAGA,aAAa;QACrC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDC,gBAAgB,GAAIC,UAAmB,IAAK;MAC1C,IAAI,CAAC7M,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAACgI,UAAU,GAAGA,UAAU;QAC/B,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDC,qBAAqB,GAAIC,eAAwB,IAAK;MACpD,IAAI,CAAC/M,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChDA,KAAK,CAACkI,eAAe,GAAGA,eAAe;QACzC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDC,gBAAgB,GAAIT,UAAkB,IAAK;MACzC,IAAI,CAACvM,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD;QAAM,CAAC,KAAK;UAChD,IAAIA,KAAK,CAACe,SAAS,KAAKrG,SAAS,CAAC+M,SAAS,EAAE;YAC3CzH,KAAK,CAAC0H,UAAU,GAAGA,UAAU;UAC/B;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAEDU,eAAe,GAAIhI,SAAkB,IAAK;MACxC,IAAI,CAACjF,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;QAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;UAAEsD,KAAK;UAAEW;QAAa,CAAC,KAAK;UAC9DX,KAAK,CAACuB,KAAK,GAAGnB,SAAS,GAAGO,YAAY,CAACY,KAAK,GAAG,EAAE;QACnD,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAr/BC3H,cAAc,CAAC,IAAI,EAAE;MACnBwB,YAAY,EAAEvB,UAAU;MACxBwB,sBAAsB,EAAExB,UAAU;MAClCyB,uBAAuB,EAAEzB,UAAU;MACnC4B,uBAAuB,EAAE5B,UAAU;MACnC6B,eAAe,EAAE7B,UAAU;MAC3B+B,qBAAqB,EAAE/B,UAAU;MACjCiC,eAAe,EAAEnC,MAAM;MACvBqC,eAAe,EAAErC,MAAM;MACvB2C,gBAAgB,EAAE3C,MAAM;MACxB6C,kBAAkB,EAAE7C,MAAM;MAC1BoD,qBAAqB,EAAEpD,MAAM;MAC7ByE,uBAAuB,EAAEzE,MAAM;MAC/B0O,qBAAqB,EAAE1O;IACzB,CAAC,CAAC;IAEF,IAAI,CAACsB,SAAS,GAAGA,SAAS;EAC5B;EAqEA6B,oBAAoBA,CAAA,EAAG;IACrB,IAAI,IAAI,CAACpB,eAAe,EAAE;MACxB,IAAI,CAACC,cAAc,GAAG7B,OAAO,CAACwO,IAAI,CAAC;QACjC3L,GAAG,EAAE,kBAAkB;QACvB4L,OAAO,EAAE7O,KAAK,CAAC8O,aAAa,CAACtO,OAAO,EAAE;UACpCJ,OAAO,EAAES,IAAI,CAACqK,SAAS,CAAC,uBAAuB,EAAE;YAAErF,MAAM,EAAE;cAAEkJ,KAAK,EAAE,IAAI,CAAC7M,qBAAqB,CAAC8M;YAAK;UAAE,CAAC;QACzG,CAAC,CAAC;QACFC,QAAQ,EAAE,CAAC;QACXC,IAAI,EAAE,IAAI;QACVC,SAAS,EAAE;MACb,CAAC,CAAC;IACJ,CAAC,MAAM;MAAA,IAAAC,oBAAA;MACL,CAAAA,oBAAA,OAAI,CAACnN,cAAc,cAAAmN,oBAAA,uBAAnBA,oBAAA,CAAAC,IAAA,KAAsB,CAAC;IACzB;EACF;EAEAV,qBAAqBA,CAAC3J,UAAkB,EAAE;IACxC,IAAI,CAAC,IAAI,CAAChD,eAAe,EAAE;MACzB,IAAI,CAACA,eAAe,GAAG,IAAI;IAC7B;IACA,MAAM;MAAEqD;IAAkB,CAAC,GAAG,IAAI,CAAC9D,SAAS,CAACuD,MAAM;IACnD,MAAM;MAAEQ,OAAO,EAAEC;IAAgB,CAAC,GAAGF,iBAAiB,CAACL,UAAU,CAAC;IAClE,MAAMsK,mBAAmB,GAAG1J,MAAM,CAAC2J,IAAI,CAAChK,eAAe,CAAC;IACxD,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8K,mBAAmB,CAAC7L,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;MACtD,MAAMU,MAAM,GAAGoK,mBAAmB,CAAC9K,CAAC,CAAC;MACrC,MAAMgB,MAAM,GAAGD,eAAe,CAACL,MAAM,CAAC;MACtC,MAAMsK,cAAc,GAAG5J,MAAM,CAAC2J,IAAI,CAAC/J,MAAM,CAAC;MAC1C,KAAK,IAAIgF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgF,cAAc,CAAC/L,MAAM,EAAE+G,CAAC,IAAI,CAAC,EAAE;QACjD,MAAMvF,UAAU,GAAGwK,MAAM,CAACD,cAAc,CAAChF,CAAC,CAAC,CAAC;QAC5C,MAAMvH,GAAG,GAAG,IAAI,CAACY,eAAe,CAACoB,UAAU,EAAEC,MAAM,EAAEF,UAAU,CAAC;QAChE,IAAI,CAAC9C,qBAAqB,CAACuC,GAAG,CAACxB,GAAG,CAAC;QACnC,IAAI,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,EAAE;UAC7B,IAAI,CAACzB,eAAe,CAACyB,GAAG,CAAC,CAACC,aAAa,GAAG,IAAI;QAChD;MACF;IACF;IACA,IAAI,CAACE,oBAAoB,CAAC,CAAC;EAC7B;EAEAsM,iBAAiBA,CAACC,cAAsB,EAAEC,gBAAyB,EAAE;IACnE,MAAMC,iBAAiB,GAAG,IAAI1N,GAAG,CAAC,CAAC;IACnC0N,iBAAiB,CAACpL,GAAG,CAACkL,cAAc,CAAC;IAErC,MAAMG,oBAKL,GAAG,CAAC,CAAC;IACN,MAAMC,wBAAgE,GAAG,CAAC,CAAC;IAC3E,IAAIC,yBAAyB,GAAG,KAAK;IAErC,IAAI,CAAC9N,qBAAqB,CAACc,OAAO,CAAEC,GAAG,IAAK;MAC1C,IAAI4M,iBAAiB,CAACb,IAAI,GAAG,CAAC,EAAE;QAC9B;MACF;MAEA,MAAM/K,IAAI,GAAG,IAAI,CAACzC,eAAe,CAACyB,GAAG,CAAC;MACtC,IAAIgB,IAAI,EAAE;QAAA,IAAAgM,eAAA;QACR,MAAM;UAAE/K,MAAM;UAAED,UAAU;UAAEQ;QAAc,CAAC,GAAGxB,IAAI;QAClD,MAAMT,QAAQ,IAAAyM,eAAA,GAAGxK,aAAa,CAAC,CAAC,CAAC,cAAAwK,eAAA,uBAAhBA,eAAA,CAAkBzM,QAAQ;QAC3C,IAAIA,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEmE,QAAQ,EAAE;UACtBkI,iBAAiB,CAACpL,GAAG,CAACjB,QAAQ,CAACmE,QAAQ,CAAC;UACxC,IAAIkI,iBAAiB,CAACb,IAAI,GAAG,CAAC,EAAE;YAC9B;YACA;UACF;UAEA,IAAIxL,QAAQ,CAACM,EAAE,KAAK8L,gBAAgB,EAAE;YACpC;YACA;UACF;UAEAnK,aAAa,CAACzC,OAAO,CAAEiE,YAAY,IAAK;YACtC,IAAI,CAAC6I,oBAAoB,CAAC7I,YAAY,CAACnD,EAAE,CAAC,EAAE;cAC1CgM,oBAAoB,CAAC7I,YAAY,CAACnD,EAAE,CAAC,GAAG;gBACtCoM,kBAAkB,EAAEjJ,YAAY;gBAChCkJ,oBAAoB,EAAE,CAAC;cACzB,CAAC;YACH;YACA,IAAI,CAACL,oBAAoB,CAAC7I,YAAY,CAACnD,EAAE,CAAC,CAACqM,oBAAoB,CAACjL,MAAM,CAAC,EAAE;cACvE4K,oBAAoB,CAAC7I,YAAY,CAACnD,EAAE,CAAC,CAACqM,oBAAoB,CAACjL,MAAM,CAAC,GAAG,EAAE;YACzE;YACA4K,oBAAoB,CAAC7I,YAAY,CAACnD,EAAE,CAAC,CAACqM,oBAAoB,CAACjL,MAAM,CAAC,CAACwF,IAAI,CAACzF,UAAU,CAAC;YAEnF,IAAI,CAAC8K,wBAAwB,CAAC7K,MAAM,CAAC,EAAE;cACrC6K,wBAAwB,CAAC7K,MAAM,CAAC,GAAG,CAAC,CAAC;YACvC;YACA,IAAI6K,wBAAwB,CAAC7K,MAAM,CAAC,CAACD,UAAU,CAAC,KAAKpC,SAAS,EAAE;cAC9DkN,wBAAwB,CAAC7K,MAAM,CAAC,CAACD,UAAU,CAAC,GAAG,CAAC;YAClD;YACA8K,wBAAwB,CAAC7K,MAAM,CAAC,CAACD,UAAU,CAAC,IAAI,CAAC;YACjD,IAAI8K,wBAAwB,CAAC7K,MAAM,CAAC,CAACD,UAAU,CAAC,GAAG,CAAC,EAAE;cACpD+K,yBAAyB,GAAG,IAAI;YAClC;UACF,CAAC,CAAC;QACJ;MACF;IACF,CAAC,CAAC;IAEF,IAAIH,iBAAiB,CAACb,IAAI,GAAG,CAAC,EAAE;MAC9B5O,OAAO,CAACgQ,KAAK,CAACvP,IAAI,CAACqK,SAAS,CAAC,qBAAqB,CAAC,CAAC;MACpD;IACF;IAEA,MAAMmF,QAAQ,GAAGzK,MAAM,CAACC,MAAM,CAACiK,oBAAoB,CAAC;IACpD,IAAIO,QAAQ,CAAC5M,MAAM,IAAI,CAAC,EAAE;MACxBrD,OAAO,CAACgQ,KAAK,CAACvP,IAAI,CAACqK,SAAS,CAAC,sBAAsB,CAAC,CAAC;MACrD;IACF;IAEA,IAAI8E,yBAAyB,EAAE;MAC7B,MAAMrI,QAAQ,GAAG,IAAI,CAACpG,SAAS,CAAC+O,QAAQ,CAACC,WAAW,CAACZ,cAAc,CAAC;MACpE,IAAI,CAAAhI,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE6I,QAAQ,CAAC/M,MAAM,MAAK,CAAC,IAAI,CAAAkE,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE6I,QAAQ,CAAC,CAAC,CAAC,CAACzB,KAAK,MAAK,CAAC,EAAE;QACxE3O,OAAO,CAACgQ,KAAK,CAACvP,IAAI,CAACqK,SAAS,CAAC,wBAAwB,CAAC,CAAC;QACvD;MACF;IACF;IAEA,MAAMuF,eAA0C,GAAG,CAAC,CAAC;IACrD,MAAMC,eAA0C,GAAG,CAAC,CAAC;IACrD,MAAMC,mBAAkD,GAAG,CAAC,CAAC;IAC7D,MAAMC,mBAAkD,GAAG,CAAC,CAAC;IAE7D,IAAI;MACF,MAAM;QAAExL,SAAS;QAAEyL;MAAkC,CAAC,GAAG,IAAI,CAACtP,SAAS,CAACiC,QAAQ;MAChF,IAAIsN,cAAoC;MACxC,IAAIlB,gBAAgB,EAAE;QACpBkB,cAAc,GAAG1L,SAAS,CAACwK,gBAAgB,CAAC;MAC9C;MACA,KAAK,IAAIpL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6L,QAAQ,CAAC5M,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;QAAA,IAAAuM,eAAA;QAC3C,MAAM;UAAEb,kBAAkB;UAAEC;QAAqB,CAAC,GAAGE,QAAQ,CAAC7L,CAAC,CAAC;QAChE,MAAM;UAAEwM,kBAAkB;UAAEC,SAAS;UAAEC;QAAU,CAAC,GAAGL,iCAAiC,CACpFX,kBAAkB,EAClBP,cAAc,EACdO,kBAAkB,CAACtI,IAAI,EACvBuI,oBAAoB,GAAAY,eAAA,GACpBD,cAAc,cAAAC,eAAA,uBAAdA,eAAA,CAAgBI,MAClB,CAAC;QACDL,cAAc,GAAGE,kBAAkB,CAACxN,QAAQ;;QAE5C;QACA;QACAyN,SAAS,CAAC7L,SAAS,CAACpC,OAAO,CAAEQ,QAAQ,IAAK;UAAA,IAAA4N,gBAAA;UACxC;UACA;UACA,IAAI5N,QAAQ,CAACM,EAAE,OAAAsN,gBAAA,GAAKN,cAAc,cAAAM,gBAAA,uBAAdA,gBAAA,CAAgBtN,EAAE,GAAE;YACtC;UACF;UACA,IAAI,CAAC2M,eAAe,CAACjN,QAAQ,CAACM,EAAE,CAAC,EAAE;YACjC2M,eAAe,CAACjN,QAAQ,CAACM,EAAE,CAAC,GAAGN,QAAQ;UACzC,CAAC,MAAM;YACLiN,eAAe,CAACjN,QAAQ,CAACM,EAAE,CAAC,CAAC0M,QAAQ,CAAC9F,IAAI,CAAC,GAAGlH,QAAQ,CAACgN,QAAQ,CAAC;UAClE;QACF,CAAC,CAAC;QACFU,SAAS,CAAC9L,SAAS,CAACpC,OAAO,CAAEQ,QAAQ,IAAK;UACxC,IAAI,CAACkN,eAAe,CAAClN,QAAQ,CAACM,EAAE,CAAC,EAAE;YACjC4M,eAAe,CAAClN,QAAQ,CAACM,EAAE,CAAC,GAAGN,QAAQ;UACzC,CAAC,MAAM;YACLkN,eAAe,CAAClN,QAAQ,CAACM,EAAE,CAAC,CAAC0M,QAAQ,CAAC9F,IAAI,CAAC,GAAGlH,QAAQ,CAACgN,QAAQ,CAAC;UAClE;QACF,CAAC,CAAC;QACFS,SAAS,CAACI,aAAa,CAACrO,OAAO,CAAEsH,CAAC,IAAK;UACrC,IAAI,CAACqG,mBAAmB,CAACrG,CAAC,CAACxG,EAAE,CAAC,EAAE;YAC9B6M,mBAAmB,CAACrG,CAAC,CAACxG,EAAE,CAAC,GAAGwG,CAAC;UAC/B;QACF,CAAC,CAAC;QACF4G,SAAS,CAACG,aAAa,CAACrO,OAAO,CAAEsH,CAAC,IAAK;UACrCsG,mBAAmB,CAACtG,CAAC,CAACxG,EAAE,CAAC,GAAGwG,CAAC;QAC/B,CAAC,CAAC;MACJ;MAEA,IAAI,CAAC/I,SAAS,CAAC+P,IAAI,CAAC5G,IAAI,CAAC;QACvBtF,SAAS,EAAEQ,MAAM,CAACC,MAAM,CAAC4K,eAAe,CAAC;QACzCY,aAAa,EAAEzL,MAAM,CAACC,MAAM,CAAC8K,mBAAmB;MAClD,CAAC,EAAE;QACDvL,SAAS,EAAEQ,MAAM,CAACC,MAAM,CAAC6K,eAAe,CAAC;QACzCW,aAAa,EAAEzL,MAAM,CAACC,MAAM,CAAC+K,mBAAmB;MAClD,CAAC,CAAC;MACF,IAAI,CAAC9N,kBAAkB,CAAC,KAAK,CAAC;MAC9B,IAAI,CAACvB,SAAS,CAACuD,MAAM,CAACyM,eAAe,CAAC,CAAC;IACzC,CAAC,CAAC,OAAOC,CAAC,EAAE;MACVpR,OAAO,CAACgQ,KAAK,CAAEoB,CAAC,CAAWpR,OAAO,CAAC;IACrC;EACF;EAEAyD,eAAeA,CAACoB,UAAkB,EAAEC,MAAc,EAAEF,UAAmB,EAAE;IACvE,IAAI,IAAI,CAACzD,SAAS,CAACuD,MAAM,CAACC,UAAU,EAAE;MACpC,OAAO,GAAGC,UAAU,KAAKC,UAAU,KAAKC,MAAM,EAAE;IAClD;IACA,OAAO,IAAID,UAAU,EAAE;EACzB;EAEAE,YAAYA,CAAClC,GAAW,EAAE;IACxB,IAAI,IAAI,CAAC1B,SAAS,CAACuD,MAAM,CAACC,UAAU,EAAE;MACpC,MAAM,CAACC,UAAU,EAAEyM,OAAO,GAAG,EAAE,CAAC,GAAGxO,GAAG,CAACyO,KAAK,CAAC,IAAI,CAAC;MAClD,MAAM,CAACC,QAAQ,GAAG,GAAG,EAAEzM,MAAM,GAAG9D,mBAAmB,CAAC,GAAGqQ,OAAO,CAACC,KAAK,CAAC,IAAI,CAAC;MAC1E,OAAO;QACLzM,UAAU,EAAEwK,MAAM,CAACkC,QAAQ,CAAC;QAC5BzM,MAAM;QACNF;MACF,CAAC;IACH;IACA,MAAM2M,QAAQ,GAAG1O,GAAG,CAAC2O,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC;IACrC,OAAO;MACL3M,UAAU,EAAEwK,MAAM,CAACkC,QAAQ;IAC7B,CAAC;EACH;EAEAE,WAAWA,CACT5O,GAAW,EACXiC,MAAc,EACdD,UAAkB,EAClB6M,aAAwB,EACxBC,cAA2B,EAC3B;IACA,MAAM;MAAEC,WAAW;MAAEC;IAA0B,CAAC,GAAG,IAAI,CAAC1Q,SAAS,CAACmB,KAAK;IACvE,MAAMwP,QAAQ,GAAG,IAAI,CAAC3Q,SAAS,CAAC4Q,aAAa,CAACH,WAAW,CAAC9M,MAAM,EAAED,UAAU,CAAC,CAAC;IAC9E,MAAMmN,aAAa,GAAGH,yBAAyB,CAAC/M,MAAM,EAAED,UAAU,CAAC;IACnE,IAAI,CAAC,IAAI,CAACzD,eAAe,CAACyB,GAAG,CAAC,EAAE;MAAA,IAAAoP,qBAAA;MAC9B,MAAM;QAAEC,MAAM;QAAEC;MAAc,CAAC,GAAG,IAAI,CAAChR,SAAS,CAACoF,MAAM;MACvD,IAAI,CAACnF,eAAe,CAACyB,GAAG,CAAC,GAAG,IAAI3C,QAAQ,CAAC;QACvC2C,GAAG;QACHiC,MAAM;QACND,UAAU;QACV6M,aAAa;QACbC,cAAc;QACdG,QAAQ;QACRE,aAAa;QACbzL,MAAM,EAAE;UACN2L,MAAM;UACNE,YAAY,GAAAH,qBAAA,GAAE,IAAI,CAAC9Q,SAAS,CAACkR,QAAQ,cAAAJ,qBAAA,uBAAvBA,qBAAA,CAAyBK,iBAAiB;UACxDC,UAAU,EAAEJ;QACd;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,IAAI,CAAC/Q,eAAe,CAACyB,GAAG,CAAC,CAACiP,QAAQ,GAAGA,QAAQ;MAC7C,IAAI,CAAC1Q,eAAe,CAACyB,GAAG,CAAC,CAACmP,aAAa,GAAGA,aAAa;MACvD,IAAI,CAAC5Q,eAAe,CAACyB,GAAG,CAAC,CAAC6O,aAAa,GAAGA,aAAa;MACvD,IAAI,CAACtQ,eAAe,CAACyB,GAAG,CAAC,CAAC8O,cAAc,GAAGA,cAAc;IAC3D;IACA,OAAO,IAAI,CAACvQ,eAAe,CAACyB,GAAG,CAAC;EAClC;EAEA2P,UAAUA,CAACd,aAAwB,EAAEC,cAA2B,EAAE;IAChE,IAAI,IAAI,CAACxQ,SAAS,CAACoF,MAAM,CAACkM,QAAQ,KAAKlS,QAAQ,CAACmS,IAAI,EAAE;MACpD,MAAM;QAAEnP,aAAa;QAAED,YAAY;QAAEqP;MAAW,CAAC,GAAG,IAAI,CAACxR,SAAS,CAACmB,KAAK;MACxE,MAAMjB,KAAiB,GAAG,EAAE;MAC5B,IAAI,IAAI,CAACF,SAAS,CAACuD,MAAM,CAACC,UAAU,EAAE;QACpC;QACA,MAAM;UAAEM,iBAAiB;UAAE2N;QAAmB,CAAC,GAAG,IAAI,CAACzR,SAAS,CAACuD,MAAM;QACvE,MAAM;UAAEM,SAAS;UAAEM,eAAe;UAAEnC;QAAkB,CAAC,GAAG,IAAI,CAAChC,SAAS,CAACiC,QAAQ;QACjFoC,MAAM,CAAC2J,IAAI,CAAClK,iBAAiB,CAAC,CAACrC,OAAO,CAAEc,EAAE,IAAK;UAC7C,MAAMN,QAAQ,GAAG4B,SAAS,CAACtB,EAAE,CAAC;UAC9B,IAAIkP,kBAAkB,KAAKvS,kBAAkB,CAACwS,QAAQ,EAAE;YACtD,MAAMtN,gBAAgB,GAAG,CAACD,eAAe,GAAGnC,iBAAiB,CAAC,CAAC,CAAC,GAAGV,SAAS;YAC5E,IAAIiB,EAAE,MAAK6B,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAE7B,EAAE,GAAE;cAC/B;YACF;UACF;UACA,MAAM;YAAEwB,OAAO,EAAEC;UAAgB,CAAC,GAAGF,iBAAiB,CAACvB,EAAE,CAAC;UAC1D,MAAMwL,mBAAmB,GAAG1J,MAAM,CAAC2J,IAAI,CAAChK,eAAe,CAAC;UACxD,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8K,mBAAmB,CAAC7L,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;YACtD,MAAMU,MAAM,GAAGoK,mBAAmB,CAAC9K,CAAC,CAAC;YACrC,MAAMgB,MAAM,GAAGD,eAAe,CAACL,MAAM,CAAC;YACtC,MAAMsK,cAAc,GAAG5J,MAAM,CAAC2J,IAAI,CAAC/J,MAAM,CAAC;YAC1C,KAAK,IAAIgF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgF,cAAc,CAAC/L,MAAM,EAAE+G,CAAC,IAAI,CAAC,EAAE;cACjD,MAAMvF,UAAU,GAAGwK,MAAM,CAACD,cAAc,CAAChF,CAAC,CAAC,CAAC;cAC5C,MAAMvH,GAAG,GAAG,IAAI,CAACY,eAAe,CAACoB,UAAU,EAAEC,MAAM,EAAEpB,EAAE,CAAC;cACxD,MAAMG,IAAI,GAAG,IAAI,CAAC4N,WAAW,CAC3B5O,GAAG,EACHiC,MAAM,EACND,UAAU,EACV6M,aAAa,EACbC,cACF,CAAC;cACD9N,IAAI,CAACmE,QAAQ,GAAG5E,QAAQ,CAAC4E,QAAQ,IAC5B1E,YAAY,KAAKuB,UAAU,IAC3BtB,aAAa,KAAKuB,MAAM;cAC7BjB,IAAI,CAACf,aAAa,GAAG,IAAI,CAAChB,qBAAqB,CAACyC,GAAG,CAAC1B,GAAG,CAAC;cACxDgB,IAAI,CAACwB,aAAa,GAAGD,MAAM,CAACP,UAAU,CAAC;cACvChB,IAAI,CAACiP,SAAS,CAAC,CAAC;cAChBzR,KAAK,CAACiJ,IAAI,CAACzG,IAAI,CAAC;cAChB,IAAI,CAACoF,yBAAyB,CAACpF,IAAI,CAAC;YACtC;UACF;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACL;QACA,MAAM;UAAEyB,eAAe;UAAEnC;QAAkB,CAAC,GAAG,IAAI,CAAChC,SAAS,CAACiC,QAAQ;QACtE,MAAMmC,gBAAgB,GAAG,CAACD,eAAe,GAAGnC,iBAAiB,CAAC,CAAC,CAAC,GAAGV,SAAS;QAC5E,MAAM4C,aAAa,GAAGG,MAAM,CAACC,MAAM,CAAC,CAAAF,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEG,KAAK,KAAI,CAAC,CAAC,CAAC;QAClEqN,KAAK,CAACC,IAAI,CAAC;UAAE3P,MAAM,EAAEsP;QAAW,CAAC,CAAC,CAAC/P,OAAO,CAAC,CAACqQ,CAAC,EAAEpO,UAAU,KAAK;UAC5D,MAAMhC,GAAG,GAAG,IAAI,CAACY,eAAe,CAACoB,UAAU,EAAEtB,aAAa,EAAEgC,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAE7B,EAAE,CAAC;UACjF,MAAMG,IAAI,GAAG,IAAI,CAAC4N,WAAW,CAC3B5O,GAAG,EACHU,aAAa,EACbsB,UAAU,EACV6M,aAAa,EACbC,cACF,CAAC;UACD9N,IAAI,CAACiB,MAAM,GAAGvB,aAAa;UAC3BM,IAAI,CAACmE,QAAQ,GAAG1E,YAAY,KAAKuB,UAAU;UAC3ChB,IAAI,CAACf,aAAa,GAAG,IAAI,CAAChB,qBAAqB,CAACyC,GAAG,CAAC1B,GAAG,CAAC;UACxDgB,IAAI,CAACwB,aAAa,GAAGA,aAAa;UAClCxB,IAAI,CAACiP,SAAS,CAAC,CAAC;UAChBzR,KAAK,CAACiJ,IAAI,CAACzG,IAAI,CAAC;UAChB,IAAI,CAACoF,yBAAyB,CAACpF,IAAI,CAAC;QACtC,CAAC,CAAC;MACJ;MAEA2B,MAAM,CAAC2J,IAAI,CAAC,IAAI,CAAC/N,eAAe,CAAC,CAACwB,OAAO,CAAEC,GAAG,IAAK;QACjD,MAAMgB,IAAI,GAAG,IAAI,CAACzC,eAAe,CAACyB,GAAG,CAAC;QACtC,IAAI,CAACxB,KAAK,CAACwK,QAAQ,CAAChI,IAAI,CAAC,EAAE;UACzB,IAAI,IAAI,CAAC/B,qBAAqB,CAACyC,GAAG,CAAC1B,GAAG,CAAC,EAAE;YACvC;YACAgB,IAAI,CAACqP,MAAM,CAAC,CAAC;UACf,CAAC,MAAM;YACLrP,IAAI,CAACsC,OAAO,CAAC,CAAC;YACd,OAAO,IAAI,CAAC/E,eAAe,CAACyB,GAAG,CAAC;UAClC;QACF;MACF,CAAC,CAAC;MACF,IAAI,CAACxB,KAAK,GAAGA,KAAK;IACpB;EACF;EA4LAgH,iBAAiBA,CAACxE,IAAc,EAAEqC,KAAuB,EAAE;IACzDA,KAAK,CAACiN,EAAE,CAACxS,WAAW,CAACkS,QAAQ,EAAGO,CAAC,IAAK;MACpC;MACA,IAAI,IAAI,CAACjS,SAAS,CAACmB,KAAK,CAACiB,aAAa,KAAKM,IAAI,CAACiB,MAAM,EAAE;QACtD,IAAI,CAAC3D,SAAS,CAACmB,KAAK,CAAC+Q,SAAS,CAACxP,IAAI,CAACiB,MAAM,CAAC;MAC7C;MACA,IAAI,IAAI,CAAC3D,SAAS,CAACmB,KAAK,CAACgB,YAAY,KAAKO,IAAI,CAACgB,UAAU,EAAE;QACzD,IAAI,CAAC1D,SAAS,CAACmB,KAAK,CAACgR,QAAQ,CAACzP,IAAI,CAACgB,UAAU,CAAC;MAChD;MACA;MACA,MAAM;QAAEgC;MAAa,CAAC,GAAGhD,IAAI,CAACoC,MAAM,CAACmN,CAAC,CAAC7K,GAAG,CAAC,IAAI,CAAC,CAAC;MACjD,IAAI,CAACpH,SAAS,CAACiC,QAAQ,CAACmI,kBAAkB,CAAC1E,YAAY,CAAC;MACxD;MACArB,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAE2Q,SAAS,IAAK;QAChDA,SAAS,CAACrN,KAAK,CAAC8B,QAAQ,GAAGuL,SAAS,CAACrN,KAAK,CAACqC,GAAG,KAAKrC,KAAK,CAACqC,GAAG;MAC9D,CAAC,CAAC;IACJ,CAAC,CAAC;IACFrC,KAAK,CAACiN,EAAE,CAACxS,WAAW,CAAC6S,OAAO,EAAE,CAACJ,CAAC,EAAE/I,IAAI,KAAK;MACzCxG,IAAI,CAAC4P,aAAa,CAAC,CAAC;MACpB,MAAM;QAAE5M;MAAa,CAAC,GAAGhD,IAAI,CAACoC,MAAM,CAACmN,CAAC,CAAC7K,GAAG,CAAC,IAAI,CAAC,CAAC;MACjD,IAAI1B,YAAY,EAAE;QAChB,IAAI,CAAC1F,SAAS,CAACiC,QAAQ,CAACsQ,+BAA+B,CAAC7M,YAAY,EAAEhD,IAAI,CAACgB,UAAU,EAAEuO,CAAC,CAACnM,SAAS,EAAEoD,IAAI,CAAC;QACzG,IAAI,CAAClJ,SAAS,CAACwS,kBAAkB,CAAC,CAAC;MACrC;IACF,CAAC,CAAC;IACFzN,KAAK,CAACiN,EAAE,CAACxS,WAAW,CAACiT,OAAO,EAAGR,CAAC,IAAK;MACnCvP,IAAI,CAAC4P,aAAa,CAAC,CAAC;MACpB,MAAM;QAAE5M;MAAa,CAAC,GAAGhD,IAAI,CAACoC,MAAM,CAACmN,CAAC,CAAC7K,GAAG,CAAC,IAAI,CAAC,CAAC;MACjD,IAAI1B,YAAY,EAAE;QAChB,IAAI,CAAC1F,SAAS,CAACiC,QAAQ,CAACyQ,4BAA4B,CAAChN,YAAY,EAAE,CAAChD,IAAI,CAACgB,UAAU,CAAC,EAAEhB,IAAI,CAACiB,MAAM,CAAC;MACpG;IACF,CAAC,CAAC;IACFoB,KAAK,CAACiN,EAAE,CAACxS,WAAW,CAACmT,YAAY,EAAE,CAACV,CAAC,EAAEW,CAAC,KAAK,IAAI,CAAC5S,SAAS,CAACe,eAAe,CAAC6R,CAAC,CAAC,CAAC;EACjF;EAEAC,sBAAsBA,CAAA,EAAG;IACvB,IAAI,IAAI,CAAC7S,SAAS,CAACuD,MAAM,CAACC,UAAU,EAAE;MACpC,MAAM;QAAExB;MAAkB,CAAC,GAAG,IAAI,CAAChC,SAAS,CAACiC,QAAQ;MACrD,IAAID,iBAAiB,CAACE,MAAM,KAAK,CAAC,EAAE;QAClC,MAAM;UAAEC,YAAY;UAAEC;QAAc,CAAC,GAAG,IAAI,CAACpC,SAAS,CAACmB,KAAK;QAC5D,MAAMO,GAAG,GAAG,IAAI,CAACY,eAAe,CAACH,YAAY,EAAEC,aAAa,EAAEJ,iBAAiB,CAAC,CAAC,CAAC,CAACO,EAAE,CAAC;QACtF,OAAO,IAAI,CAACrC,KAAK,CAAC4S,IAAI,CAAEpQ,IAAI,IAAKA,IAAI,CAAChB,GAAG,KAAKA,GAAG,CAAC;MACpD;IACF;IACA,OAAO,IAAI,CAACxB,KAAK,CAAC,IAAI,CAACF,SAAS,CAACmB,KAAK,CAACgB,YAAY,CAAC;EACtD;EAEA4Q,uBAAuBA,CAAA,EAAiC;IACtD,MAAMC,YAAY,GAAG,IAAI,CAACH,sBAAsB,CAAC,CAAC;IAClD,IAAIG,YAAY,EAAE;MAChB,MAAMZ,SAAS,GAAG/N,MAAM,CAACC,MAAM,CAAC,CAAA0O,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAElO,MAAM,KAAI,CAAC,CAAC,CAAC,CACxDgO,IAAI,CAAC,CAAC;QAAE/N;MAAM,CAAC,KAAKA,KAAK,CAAC8B,QAAQ,IAAI9B,KAAK,CAAC0C,WAAW,KAAKlI,WAAW,CAACmI,MAAM,CAAC;MAClF,OAAO0K,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAErN,KAAK;IACzB;IACA,OAAOzD,SAAS;EAClB;;EAEA;AACF;AACA;EACE+B,MAAMA,CAAA,EAAG;IACP,MAAM4P,kBAAkB,GAAG,IAAI,CAACjT,SAAS,CAAC8J,YAAY,CAACoJ,gBAAgB,CAAC,CAAC;IACzE,MAAMC,eAAe,GAAG,CAAAF,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAEjM,QAAQ,KAAIiM,kBAAkB,CAACG,qBAAqB,CAAC,CAAC;IAClG,IAAID,eAAe,EAAE;MACnB;IACF;IAEA,MAAME,aAAa,GAAG,IAAI,CAACN,uBAAuB,CAAC,CAAC;IACpD,IAAIM,aAAa,EAAE;MACjB,MAAMC,aAAa,GAAGD,aAAa,CAACE,oBAAoB,CAAC,CAAC;MAC1D,IAAI,CAACD,aAAa,EAAE;QAClB,MAAM;UAAEvL;QAAsB,CAAC,GAAG,IAAI,CAAC/H,SAAS,CAACiC,QAAQ;QACzD,IAAI,CAACjC,SAAS,CAACiC,QAAQ,CAACyQ,4BAA4B,CAAC3K,qBAAqB,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC/H,SAAS,CAACmB,KAAK,CAACgB,YAAY,CAAC,CAAC;QACnH,IAAI,CAACnC,SAAS,CAACuD,MAAM,CAACyM,eAAe,CAAC,CAAC;MACzC;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEwD,sBAAsBA,CAAC9N,YAA0B,EAAE/B,MAAM,GAAG,IAAI,CAAC3D,SAAS,CAACmB,KAAK,CAACiB,aAAa,EAAE;IAAA,IAAAqR,sBAAA;IAC9F,IAAI,IAAI,CAACzT,SAAS,CAACuD,MAAM,CAACC,UAAU,EAAE;MACpC3E,OAAO,CAAC6K,OAAO,CAACpK,IAAI,CAACqK,SAAS,CAAC,mCAAmC,CAAC,CAAC;MACpE;IACF;IACA,MAAM;MAAExH;IAAa,CAAC,GAAG,IAAI,CAACnC,SAAS,CAACmB,KAAK;IAC7C,KAAAsS,sBAAA,GAAI/N,YAAY,CAAC3B,OAAO,CAACJ,MAAM,CAAC,cAAA8P,sBAAA,uBAA5BA,sBAAA,CAA8BxP,MAAM,CAAC9B,YAAY,CAAC,EAAE;MACtD;MACA;IACF;IACA,MAAMoD,WAAW,GAAG,IAAI,CAACvF,SAAS,CAACmB,KAAK,CAACqE,uBAAuB,CAAC7B,MAAM,EAAExB,YAAY,CAAC;IACtF,MAAMkF,SAAS,GAAG3B,YAAY,CAAC4B,YAAY,CAAC3D,MAAM,EAAExB,YAAY,EAAEoD,WAAW,EAAE,IAAI,CAAC;IACpF,IAAI8B,SAAS,EAAE;MACb,IAAIA,SAAS,CAACvB,SAAS,KAAKrG,SAAS,CAACsG,KAAK,EAAE;QAC3C;QACA,MAAMiE,OAAO,GAAG,IAAI,CAAChK,SAAS,CAAC8J,YAAY,CAACD,qBAAqB,CAACxC,SAAS,CAACtC,KAAkB,CAAC;QAC/F,IAAI,CAACiF,OAAO,EAAE;UACZ;QACF;QACA3C,SAAS,CAACtC,KAAK,GAAGiF,OAAO;MAC3B,CAAC,MAAM;QACL,MAAMC,IAAI,GAAG5K,aAAa,CAACgI,SAAS,CAACvB,SAAS,EAAEuB,SAAS,CAACtC,KAAK,CAAC;QAChE,IAAIkF,IAAI,GAAG,IAAI,CAACjK,SAAS,CAACoF,MAAM,CAAC8E,OAAO,EAAE;UACxCrL,OAAO,CAAC6K,OAAO,CAACpK,IAAI,CAACqK,SAAS,CAAC,gBAAgB,CAAC,CAAC;UACjD;QACF;MACF;MACA,MAAM;QAAEzE;MAAiB,CAAC,GAAG,IAAI,CAAClF,SAAS,CAACoF,MAAM;MAClD,IAAI,CAACpF,SAAS,CAACiC,QAAQ,CAACsQ,+BAA+B,CACrD7M,YAAY,EACZvD,YAAY,EACZkF,SAAS,CAACvB,SAAS,EACnBuB,SAAS,CAACtC,KAAK,EACfG,gBAAgB,EAChBmC,SAAS,CAACvB,SAAS,KAAKrG,SAAS,CAACsG,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC/F,SAAS,CAACmB,KAAK,CAAC6E,iBAAiB,CAACd,gBAAgB,EAAE/C,YAAY,EAAEwB,MAAM,CAAC,EAC5HA,MACF,CAAC;MACD,IAAI,CAAC3D,SAAS,CAACiC,QAAQ,CAACmI,kBAAkB,CAAC1E,YAAY,CAAC;MACxD,IAAI,CAAC1F,SAAS,CAACiC,QAAQ,CAACqI,uBAAuB,CAAC,CAAC;IACnD;EACF;EA4FA;AACF;AACA;AACA;EACEoJ,oBAAoBA,CAAC1M,QAAiB,EAAE;IACtC,IAAI,CAAC9G,KAAK,CAACuB,OAAO,CAAEiB,IAAI,IAAK;MAC3B2B,MAAM,CAACC,MAAM,CAAC5B,IAAI,CAACoC,MAAM,CAAC,CAACrD,OAAO,CAAC,CAAC;QAAEsD;MAAM,CAAC,KAAK;QAChDA,KAAK,CAACiC,QAAQ,GAAGA,QAAQ;MAC3B,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EA+LA2M,iBAAiBA,CAAA,EAAG;IAClB,MAAM;MAAEhL;IAAQ,CAAC,GAAG,IAAI,CAAC3I,SAAS,CAACiI,MAAM;IACzC,KAAK,IAAIhF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC/C,KAAK,CAACgC,MAAM,EAAEe,CAAC,IAAI,CAAC,EAAE;MAC7C,MAAMP,IAAI,GAAG,IAAI,CAACxC,KAAK,CAAC+C,CAAC,CAAC;MAC1BP,IAAI,CAAC8F,aAAa,CAAC/G,OAAO,CAAEgH,MAAM,IAAK;QACrCA,MAAM,CAACE,OAAO,GAAGA,OAAO;MAC1B,CAAC,CAAC;IACJ;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module"}