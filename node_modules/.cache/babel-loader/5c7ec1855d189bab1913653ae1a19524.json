{"ast":null,"code":"import { makeAutoObservable, toJS } from 'mobx';\nimport { Graphics } from 'pixi.js';\nimport { utils } from '@appen/easy-form';\nimport Worker from '../worker/validate.worker';\nimport i18n from '../locales';\nimport { calcShapeArea, formatFrames, checkShapeInBounds } from '../utils';\nimport { ValidationType, ReviewResult } from '../types';\nimport { DEFAULT_MIN_AREA } from '../constants';\nimport { runCustomValidation } from '../../../utils';\nimport { ShapeType } from '../../common/shapes/types';\n/**\n * store for validation\n * @class\n */\nexport default class ValidationStore {\n  /**\n   * warnings count\n   * @getter\n   */\n  get warningCount() {\n    const reviews = this.rootStore.review.allReviews.filter(r => r.result === ReviewResult.REJECT);\n    return this.warnings.length + reviews.length;\n  }\n\n  /**\n   * has error or blocked issue\n   * @getter\n   */\n  get blocked() {\n    if (!this.rootStore.config.submitCheck) {\n      // only check frame valid annotate\n      return this.warnings.filter(warning => warning.type === ValidationType.FRAME_VALID_ANNOTATE).length > 0;\n    }\n    return this.hasCustomError || this.warnings.filter(warning => warning.blockSubmit === true).length > 0;\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * validate worker\n     */\n    this.worker = new Worker();\n    /**\n     * warning list\n     */\n    this.warnings = [];\n    /**\n     * has custom error\n     */\n    this.hasCustomError = false;\n    /**\n     * is checking\n     */\n    this.checking = false;\n    /**\n     * is canvas checking\n     */\n    this.canvasChecking = false;\n    /**\n     * check layer visibility\n     */\n    this.checkLayerVisible = true;\n    /**\n     * cached empty area results\n     */\n    this.emptyAreaResults = {};\n    /**\n     * stop canvas validation\n     */\n    this.stopValidate = () => {\n      this.worker.postMessage({\n        type: 'stop'\n      });\n    };\n    makeAutoObservable(this, {\n      rootStore: false,\n      worker: false,\n      emptyAreaResults: false,\n      blocked: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n    this.worker.addEventListener('message', e => {\n      const {\n        type,\n        finished = false\n      } = e.data;\n      if (!finished) {\n        if (type === ValidationType.EMPTY_AREA) {\n          const {\n            cameraName,\n            frameIndex,\n            emptyPolygons\n          } = e.data;\n          this.saveEmptyAreaResults(cameraName, frameIndex, emptyPolygons);\n          const {\n            currentFrame\n          } = this.rootStore.frame;\n          if (frameIndex === currentFrame) {\n            this.drawEmptyArea(cameraName, this.emptyAreaResults[cameraName][currentFrame]);\n          }\n        }\n        if (type === ValidationType.FULLY_COVERED) {\n          const {\n            cameraName,\n            frameIndex,\n            coveredShapes\n          } = e.data;\n          this.saveFullyCoveredResults(cameraName, frameIndex, coveredShapes);\n        }\n      } else {\n        this.canvasChecking = false;\n      }\n    });\n    this.worker.addEventListener('error', () => {\n      this.canvasChecking = false;\n    });\n  }\n\n  /**\n   * set check layer visibility\n   * @param visible\n   */\n  setCheckLayerVisibility(visible) {\n    this.checkLayerVisible = visible;\n    const {\n      cameraViews\n    } = this.rootStore.frame;\n    Object.values(cameraViews).forEach(cameraView => {\n      if (cameraView.checkLayer) {\n        cameraView.checkLayer.visible = visible;\n      }\n    });\n  }\n\n  /**\n   * trigger sync\n   */\n  async sync() {\n    if (this.checking || this.canvasChecking) {\n      return;\n    }\n    await this.defaultSync();\n    // validate canvas\n    this.validateCanvas();\n  }\n\n  /**\n   * trigger default sync\n   * @param isSubmit\n   */\n  async defaultSync(isSubmit = false) {\n    this.checking = true;\n    const [result] = await Promise.all([this.validate(isSubmit), new Promise(resolve => {\n      setTimeout(resolve, 300);\n    })]);\n    if (result) {\n      const {\n        results,\n        hasCustomError\n      } = result;\n      this.warnings = results;\n      this.hasCustomError = hasCustomError;\n    }\n    this.checking = false;\n  }\n\n  /**\n   * do validation\n   * @param isSubmit\n   */\n  validate(isSubmit = false) {\n    const {\n      validationConfig\n    } = this.rootStore.config;\n    return new Promise(async resolve => {\n      const results = [];\n      let hasCustomError = false;\n      const checkBoundary = validationConfig[ValidationType.OUT_OF_BOUNDARY];\n      if (checkBoundary && isSubmit) {\n        // only check all image boundary when submit\n        await this.rootStore.frame.fixImageSize();\n      }\n      const checkFrameValidAnnotate = validationConfig[ValidationType.FRAME_VALID_ANNOTATE];\n      const frameAnnotated = {};\n      const {\n        attributes: frameAttributes\n      } = this.rootStore.frame;\n      const {\n        instances\n      } = this.rootStore.instance;\n      Object.values(instances).forEach(instance => {\n        const firstFrame = Number(Object.keys(instance.frameStatus)[0]);\n\n        // check instance attributes empty\n        if (validationConfig[ValidationType.ATTR_EMPTY]) {\n          const {\n            labelConfig: instanceConfig\n          } = instance.categoryRef;\n          if (instanceConfig && (!instance.attributes || !utils.validate(instanceConfig, instance.attributes, {\n            check: true\n          }))) {\n            // instance attributes\n            results.push({\n              type: ValidationType.ATTR_EMPTY,\n              id: instance.id,\n              message: i18n.translate('VALIDATION_ATTR_EMPTY_INSTANCE_MSG'),\n              frames: [firstFrame],\n              blockSubmit: true\n            });\n          }\n        }\n\n        // instance items, check attributes empty & invalid shapes\n        const checkShapeArea = this.rootStore.config.minArea > 0 && validationConfig[ValidationType.INVALID_SHAPE];\n        Object.values(instance.items).forEach(item => {\n          var _tools$;\n          const {\n            labelConfig: itemConfig,\n            tools\n          } = item.categoryItemRef;\n          const edges = (_tools$ = tools[0]) === null || _tools$ === void 0 ? void 0 : _tools$.edges; // simply use first one because only one tool can be configured\n          const checkAttr = itemConfig && validationConfig[ValidationType.ATTR_EMPTY];\n          const checkShapeEdges = edges && validationConfig[ValidationType.INVALID_SHAPE];\n          if (checkAttr || checkShapeEdges || checkShapeArea || checkBoundary || checkFrameValidAnnotate) {\n            Object.values(item.cameras).forEach(camera => {\n              const allFrames = Object.values(camera.frames).map(({\n                frameIndex\n              }) => frameIndex);\n              const attrEmptyFrames = [];\n              const edgesInvalidFrames = [];\n              const areaInvalidFrames = [];\n              const boundaryInvalidFrames = [];\n              allFrames.forEach(frame => {\n                const frameData = camera.frames[frame];\n                const {\n                  attributes,\n                  shapeType,\n                  shape\n                } = frameData;\n                if (checkAttr) {\n                  if (!attributes || !utils.validate(itemConfig, attributes, {\n                    check: true\n                  })) {\n                    attrEmptyFrames.push(frame);\n                  }\n                }\n                if (checkShapeEdges && [ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW].includes(shapeType)) {\n                  const {\n                    points\n                  } = shape;\n                  if (shapeType === ShapeType.POLYGON ? points.length !== edges : points.length - 1 !== edges) {\n                    edgesInvalidFrames.push(frame);\n                  }\n                }\n                if (checkShapeArea) {\n                  const area = calcShapeArea(shapeType, shape);\n                  if (area < this.rootStore.config.minArea) {\n                    areaInvalidFrames.push(frame);\n                  }\n                }\n                if (checkBoundary) {\n                  const {\n                    imageWidth,\n                    imageHeight,\n                    rotation\n                  } = frameAttributes[camera.camera][frame];\n                  const exchange = rotation % Math.PI !== 0;\n                  if (imageWidth && imageWidth > 0 && imageHeight && imageHeight > 0) {\n                    const inBounds = checkShapeInBounds(shape, shapeType, {\n                      left: 0,\n                      top: 0,\n                      right: exchange ? imageHeight : imageWidth,\n                      bottom: exchange ? imageWidth : imageHeight\n                    });\n                    if (!inBounds) {\n                      boundaryInvalidFrames.push(frame);\n                    }\n                  }\n                }\n                if (checkFrameValidAnnotate) {\n                  if (!frameAnnotated[camera.camera]) {\n                    frameAnnotated[camera.camera] = {};\n                  }\n                  frameAnnotated[camera.camera][frame] = true;\n                }\n              });\n              if (attrEmptyFrames.length > 0) {\n                results.push({\n                  type: ValidationType.ATTR_EMPTY,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_ATTR_EMPTY_MSG', {\n                    values: {\n                      frames: formatFrames(attrEmptyFrames)\n                    }\n                  }),\n                  info: {\n                    instanceId: instance.id,\n                    instanceItemId: item.id,\n                    camera: camera.camera\n                  },\n                  frames: [...attrEmptyFrames],\n                  blockSubmit: true\n                });\n              }\n              if (edgesInvalidFrames.length > 0) {\n                results.push({\n                  type: ValidationType.INVALID_SHAPE,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_INVALID_SHAPE_MSG', {\n                    values: {\n                      frames: formatFrames(edgesInvalidFrames),\n                      count: edges\n                    }\n                  }),\n                  info: {\n                    instanceId: instance.id,\n                    instanceItemId: item.id,\n                    camera: camera.camera\n                  },\n                  frames: [...edgesInvalidFrames],\n                  blockSubmit: true\n                });\n              }\n              if (areaInvalidFrames.length > 0) {\n                results.push({\n                  type: ValidationType.INVALID_SHAPE,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_INVALID_SHAPE_AREA_MSG', {\n                    values: {\n                      frames: formatFrames(areaInvalidFrames),\n                      area: this.rootStore.config.minArea\n                    }\n                  }),\n                  info: {\n                    instanceId: instance.id,\n                    instanceItemId: item.id,\n                    camera: camera.camera\n                  },\n                  frames: [...areaInvalidFrames],\n                  blockSubmit: true\n                });\n              }\n              if (boundaryInvalidFrames.length > 0) {\n                results.push({\n                  type: ValidationType.OUT_OF_BOUNDARY,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_OUT_OF_BOUNDARY_MSG', {\n                    values: {\n                      frames: formatFrames(boundaryInvalidFrames)\n                    }\n                  }),\n                  info: {\n                    instanceId: instance.id,\n                    instanceItemId: item.id,\n                    camera: camera.camera\n                  },\n                  frames: [...boundaryInvalidFrames],\n                  blockSubmit: true\n                });\n              }\n            });\n          }\n        });\n        if (validationConfig[ValidationType.INSTANCE_ITEM_COUNT]) {\n          // check items count matches the ontology settings\n          const {\n            children\n          } = instance.categoryRef;\n          children.forEach(({\n            name,\n            count,\n            minCount,\n            maxCount\n          }) => {\n            const items = instance.getItemsByName(name);\n            if (count !== undefined) {\n              if (items.length !== count) {\n                results.push({\n                  type: ValidationType.INSTANCE_ITEM_COUNT,\n                  id: `${instance.id}-${name}`,\n                  message: i18n.translate('VALIDATION_INSTANCE_ITEM_COUNT_MSG', {\n                    values: {\n                      item: name,\n                      opt: '=',\n                      count\n                    }\n                  }),\n                  frames: [firstFrame],\n                  info: {\n                    instanceId: instance.id\n                  },\n                  blockSubmit: true\n                });\n              }\n            } else if (minCount !== undefined && items.length < minCount) {\n              results.push({\n                type: ValidationType.INSTANCE_ITEM_COUNT,\n                id: `${instance.id}-${name}`,\n                message: i18n.translate('VALIDATION_INSTANCE_ITEM_COUNT_MSG', {\n                  values: {\n                    item: name,\n                    opt: '≥',\n                    count: minCount\n                  }\n                }),\n                frames: [firstFrame],\n                info: {\n                  instanceId: instance.id\n                },\n                blockSubmit: true\n              });\n            } else if (maxCount !== undefined && items.length > maxCount) {\n              results.push({\n                type: ValidationType.INSTANCE_ITEM_COUNT,\n                id: `${instance.id}-${name}`,\n                message: i18n.translate('VALIDATION_INSTANCE_ITEM_COUNT_MSG', {\n                  values: {\n                    item: name,\n                    opt: '≤',\n                    count: maxCount\n                  }\n                }),\n                frames: [firstFrame],\n                info: {\n                  instanceId: instance.id\n                },\n                blockSubmit: true\n              });\n            }\n          });\n        }\n      });\n      const checkFrameAttr = validationConfig[ValidationType.ATTR_EMPTY] && this.rootStore.frame.frameConfig;\n      if (checkFrameValidAnnotate || checkFrameAttr) {\n        const {\n          cameras,\n          frameConfig,\n          isFrameValid\n        } = this.rootStore.frame;\n        Object.keys(cameras).forEach(camera => {\n          const invalidFrames = [];\n          cameras[camera].forEach((_, frameIndex) => {\n            if (checkFrameValidAnnotate) {\n              var _frameAnnotated$camer;\n              const valid = isFrameValid(camera, frameIndex);\n              const annotated = (_frameAnnotated$camer = frameAnnotated[camera]) === null || _frameAnnotated$camer === void 0 ? void 0 : _frameAnnotated$camer[frameIndex];\n              if (valid && !annotated) {\n                results.push({\n                  type: ValidationType.FRAME_VALID_ANNOTATE,\n                  id: `${camera}-${frameIndex}`,\n                  message: i18n.translate('VALIDATION_FRAME_VALID_ANNOTATE_VALID_MSG', {\n                    values: {\n                      frame: frameIndex + 1\n                    }\n                  }),\n                  frames: [frameIndex],\n                  info: {\n                    camera\n                  },\n                  blockSubmit: true\n                });\n              }\n              if (!valid && annotated) {\n                results.push({\n                  type: ValidationType.FRAME_VALID_ANNOTATE,\n                  id: `${camera}-${frameIndex}`,\n                  message: i18n.translate('VALIDATION_FRAME_VALID_ANNOTATE_INVALID_MSG', {\n                    values: {\n                      frame: frameIndex + 1\n                    }\n                  }),\n                  frames: [frameIndex],\n                  info: {\n                    camera\n                  },\n                  blockSubmit: true\n                });\n              }\n            }\n            if (checkFrameAttr) {\n              if (!frameAttributes[camera] || !frameAttributes[camera][frameIndex]) {\n                invalidFrames.push(frameIndex);\n                return;\n              }\n              const {\n                attributes\n              } = frameAttributes[camera][frameIndex];\n              if (!attributes || !utils.validate(frameConfig, attributes, {\n                check: true\n              })) {\n                invalidFrames.push(frameIndex);\n              }\n            }\n          });\n          if (invalidFrames.length > 0) {\n            results.push({\n              type: ValidationType.ATTR_EMPTY,\n              id: camera,\n              message: i18n.translate('VALIDATION_ATTR_EMPTY_FRAME_MSG', {\n                values: {\n                  frames: formatFrames(invalidFrames)\n                }\n              }),\n              info: {\n                camera,\n                type: 'frame'\n              },\n              frames: [...invalidFrames],\n              blockSubmit: true\n            });\n          }\n        });\n      }\n      if (validationConfig[ValidationType.CUSTOM]) {\n        var _this$rootStore$jobPr;\n        // get result link\n        let resultLink = '';\n        if (typeof ((_this$rootStore$jobPr = this.rootStore.jobProxy) === null || _this$rootStore$jobPr === void 0 ? void 0 : _this$rootStore$jobPr.reviewFrom) === 'string') {\n          resultLink = this.rootStore.jobProxy.reviewFrom;\n        }\n        if (!this.rootStore.readonly) {\n          try {\n            resultLink = await this.rootStore.saveResult();\n          } catch (e) {\n            resultLink = '';\n          }\n        }\n        // custom check\n        const customResult = await runCustomValidation(validationConfig[ValidationType.CUSTOM], resultLink);\n        customResult.results.forEach(result => {\n          results.push({\n            ...result,\n            type: ValidationType.CUSTOM\n          });\n        });\n        hasCustomError = customResult.hasCustomError;\n      }\n      resolve({\n        results,\n        hasCustomError\n      });\n    });\n  }\n\n  /**\n   * do canvas validation\n   */\n  validateCanvas() {\n    const {\n      validationConfig\n    } = this.rootStore.config;\n    if (validationConfig[ValidationType.EMPTY_AREA] || validationConfig[ValidationType.FULLY_COVERED]) {\n      this.canvasChecking = true;\n      this.worker.postMessage({\n        config: toJS(this.rootStore.config.validationConfig),\n        cameras: toJS(this.rootStore.frame.cameras),\n        cameraAttributes: toJS(this.rootStore.frame.attributes),\n        instances: this.rootStore.instance.instancesJSON()\n      });\n    }\n  }\n  /**\n   * save empty area results\n   * @param camera\n   * @param frameIndex\n   * @param polygons\n   */\n  saveEmptyAreaResults(camera, frameIndex, polygons) {\n    if (!this.emptyAreaResults[camera]) {\n      this.emptyAreaResults[camera] = {};\n    }\n    this.emptyAreaResults[camera][frameIndex] = [];\n    polygons.forEach((p, i) => {\n      const side = p[0];\n      const area = calcShapeArea(ShapeType.POLYGON, {\n        points: side.map(point => ({\n          x: point[0],\n          y: point[1]\n        }))\n      });\n      if (area < DEFAULT_MIN_AREA) {\n        return;\n      }\n      this.emptyAreaResults[camera][frameIndex].push(p);\n      const xArr = side.map(pair => pair[0]);\n      const yArr = side.map(pair => pair[1]);\n      const left = Math.min(...xArr);\n      const right = Math.max(...xArr);\n      const top = Math.min(...yArr);\n      const bottom = Math.max(...yArr);\n      this.warnings.push({\n        type: ValidationType.EMPTY_AREA,\n        id: `${camera}-${frameIndex}-${i}`,\n        message: i18n.translate('VALIDATION_TYPE_EMPTY_AREA_MSG', {\n          values: {\n            frame: frameIndex + 1\n          }\n        }),\n        frames: [frameIndex],\n        info: {\n          index: i,\n          bbox: {\n            left,\n            top,\n            right,\n            bottom\n          },\n          camera\n        }\n      });\n    });\n  }\n\n  /**\n   * save fully covered results\n   * @param camera\n   * @param frameIndex\n   * @param items\n   */\n  saveFullyCoveredResults(camera, frameIndex, items) {\n    items.forEach(({\n      instanceId,\n      instanceItemId\n    }) => {\n      this.warnings.push({\n        type: ValidationType.FULLY_COVERED,\n        id: `${camera}-${frameIndex}-${instanceItemId}`,\n        message: i18n.translate('VALIDATION_TYPE_FULLY_COVERED_MSG', {\n          values: {\n            frame: frameIndex + 1\n          }\n        }),\n        frames: [frameIndex],\n        info: {\n          instanceId,\n          instanceItemId,\n          camera\n        }\n      });\n    });\n  }\n\n  /**\n   * draw empty area\n   * @param polygons\n   */\n  drawEmptyArea(camera, polygons) {\n    const {\n      cameraViews\n    } = this.rootStore.frame;\n    const cameraView = cameraViews[camera];\n    if (cameraView && cameraView.checkLayer) {\n      cameraView.checkLayer.removeChildren();\n      const g = new Graphics();\n      g.lineStyle(4, 0xFF0000);\n      g.beginFill(0xFFFF00, 0.5);\n      polygons.forEach(polygon => {\n        if (polygon.length > 0) {\n          const side = polygon[0];\n          g.drawPolygon(side.flatMap(i => i));\n          const holes = polygon.slice(1);\n          holes.forEach(h => {\n            g.beginHole();\n            g.drawPolygon(h.flatMap(i => i));\n            g.endHole();\n          });\n        }\n      });\n      cameraView.checkLayer.addChild(g);\n    }\n  }\n\n  /**\n   * redraw by current frame info\n   */\n  redrawEmptyArea() {\n    const {\n      currentFrame,\n      cameraViews\n    } = this.rootStore.frame;\n    Object.keys(cameraViews).forEach(camera => {\n      const {\n        checkLayer\n      } = cameraViews[camera];\n      if (checkLayer) {\n        checkLayer.removeChildren();\n      }\n      if (this.emptyAreaResults[camera]) {\n        const emptyPolygons = this.emptyAreaResults[camera][currentFrame];\n        if (emptyPolygons) {\n          this.drawEmptyArea(camera, emptyPolygons);\n        }\n      }\n    });\n  }\n\n  /**\n   * worker terminate\n   */\n  terminate() {\n    this.worker.terminate();\n  }\n}","map":{"version":3,"names":["makeAutoObservable","toJS","Graphics","utils","Worker","i18n","calcShapeArea","formatFrames","checkShapeInBounds","ValidationType","ReviewResult","DEFAULT_MIN_AREA","runCustomValidation","ShapeType","ValidationStore","warningCount","reviews","rootStore","review","allReviews","filter","r","result","REJECT","warnings","length","blocked","config","submitCheck","warning","type","FRAME_VALID_ANNOTATE","hasCustomError","blockSubmit","constructor","worker","checking","canvasChecking","checkLayerVisible","emptyAreaResults","stopValidate","postMessage","autoBind","addEventListener","e","finished","data","EMPTY_AREA","cameraName","frameIndex","emptyPolygons","saveEmptyAreaResults","currentFrame","frame","drawEmptyArea","FULLY_COVERED","coveredShapes","saveFullyCoveredResults","setCheckLayerVisibility","visible","cameraViews","Object","values","forEach","cameraView","checkLayer","sync","defaultSync","validateCanvas","isSubmit","Promise","all","validate","resolve","setTimeout","results","validationConfig","checkBoundary","OUT_OF_BOUNDARY","fixImageSize","checkFrameValidAnnotate","frameAnnotated","attributes","frameAttributes","instances","instance","firstFrame","Number","keys","frameStatus","ATTR_EMPTY","labelConfig","instanceConfig","categoryRef","check","push","id","message","translate","frames","checkShapeArea","minArea","INVALID_SHAPE","items","item","_tools$","itemConfig","tools","categoryItemRef","edges","checkAttr","checkShapeEdges","cameras","camera","allFrames","map","attrEmptyFrames","edgesInvalidFrames","areaInvalidFrames","boundaryInvalidFrames","frameData","shapeType","shape","POLYGON","LINE","ARROW","includes","points","area","imageWidth","imageHeight","rotation","exchange","Math","PI","inBounds","left","top","right","bottom","info","instanceId","instanceItemId","count","INSTANCE_ITEM_COUNT","children","name","minCount","maxCount","getItemsByName","undefined","opt","checkFrameAttr","frameConfig","isFrameValid","invalidFrames","_","_frameAnnotated$camer","valid","annotated","CUSTOM","_this$rootStore$jobPr","resultLink","jobProxy","reviewFrom","readonly","saveResult","customResult","cameraAttributes","instancesJSON","polygons","p","i","side","point","x","y","xArr","pair","yArr","min","max","index","bbox","removeChildren","g","lineStyle","beginFill","polygon","drawPolygon","flatMap","holes","slice","h","beginHole","endHole","addChild","redrawEmptyArea","terminate"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/ValidationStore.ts"],"sourcesContent":["import { makeAutoObservable, toJS } from 'mobx';\nimport { Graphics } from 'pixi.js';\nimport { MultiPolygon } from 'polygon-clipping';\nimport { utils } from '@appen/easy-form';\nimport RootStore from './RootStore';\nimport Worker from '../worker/validate.worker';\nimport i18n from '../locales';\nimport { calcShapeArea, formatFrames, checkShapeInBounds } from '../utils';\nimport { ValidationType, ValidationResult, ReviewResult } from '../types';\nimport { DEFAULT_MIN_AREA } from '../constants';\nimport { runCustomValidation } from '../../../utils';\nimport { ShapeType } from '../../common/shapes/types';\nimport { PolygonData } from '../../common/shapes/Polygon';\nimport { LineData } from '../../common/shapes/Line';\n\n/**\n * store for validation\n * @class\n */\nexport default class ValidationStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * validate worker\n   */\n  worker = new Worker();\n\n  /**\n   * warning list\n   */\n  warnings: ValidationResult[] = [];\n\n  /**\n   * has custom error\n   */\n  hasCustomError = false;\n\n  /**\n   * is checking\n   */\n  checking = false;\n\n  /**\n   * is canvas checking\n   */\n  canvasChecking = false;\n\n  /**\n   * check layer visibility\n   */\n  checkLayerVisible = true;\n\n  /**\n   * cached empty area results\n   */\n  emptyAreaResults: {\n    [camera: string]: {\n      [frameIndex: number]: MultiPolygon;\n    }\n  } = {};\n\n  /**\n   * warnings count\n   * @getter\n   */\n  get warningCount() {\n    const reviews = this.rootStore.review.allReviews.filter((r) => r.result === ReviewResult.REJECT);\n    return this.warnings.length + reviews.length;\n  }\n\n  /**\n   * has error or blocked issue\n   * @getter\n   */\n  get blocked() {\n    if (!this.rootStore.config.submitCheck) {\n      // only check frame valid annotate\n      return this.warnings.filter((warning) => warning.type === ValidationType.FRAME_VALID_ANNOTATE).length > 0;\n    }\n    return this.hasCustomError || this.warnings.filter((warning) => warning.blockSubmit === true).length > 0;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      worker: false,\n      emptyAreaResults: false,\n      blocked: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n    this.worker.addEventListener('message', (e: MessageEvent) => {\n      const { type, finished = false } = e.data;\n      if (!finished) {\n        if (type === ValidationType.EMPTY_AREA) {\n          const { cameraName, frameIndex, emptyPolygons } = e.data;\n          this.saveEmptyAreaResults(cameraName, frameIndex, emptyPolygons);\n          const { currentFrame } = this.rootStore.frame;\n          if (frameIndex === currentFrame) {\n            this.drawEmptyArea(cameraName, this.emptyAreaResults[cameraName][currentFrame]);\n          }\n        }\n        if (type === ValidationType.FULLY_COVERED) {\n          const { cameraName, frameIndex, coveredShapes } = e.data;\n          this.saveFullyCoveredResults(cameraName, frameIndex, coveredShapes);\n        }\n      } else {\n        this.canvasChecking = false;\n      }\n    });\n    this.worker.addEventListener('error', () => {\n      this.canvasChecking = false;\n    });\n  }\n\n  /**\n   * set check layer visibility\n   * @param visible\n   */\n  setCheckLayerVisibility(visible: boolean) {\n    this.checkLayerVisible = visible;\n    const { cameraViews } = this.rootStore.frame;\n    Object.values(cameraViews).forEach((cameraView) => {\n      if (cameraView.checkLayer) {\n        cameraView.checkLayer.visible = visible;\n      }\n    });\n  }\n\n  /**\n   * trigger sync\n   */\n  async sync() {\n    if (this.checking || this.canvasChecking) {\n      return;\n    }\n    await this.defaultSync();\n    // validate canvas\n    this.validateCanvas();\n  }\n\n  /**\n   * trigger default sync\n   * @param isSubmit\n   */\n  async defaultSync(isSubmit = false) {\n    this.checking = true;\n    const [result] = await Promise.all([\n      this.validate(isSubmit),\n      new Promise((resolve) => {\n        setTimeout(resolve, 300);\n      }),\n    ]);\n    if (result) {\n      const { results, hasCustomError } = result as {results: ValidationResult[]; hasCustomError: boolean};\n      this.warnings = results;\n      this.hasCustomError = hasCustomError;\n    }\n    this.checking = false;\n  }\n\n  /**\n   * do validation\n   * @param isSubmit\n   */\n  validate(isSubmit = false) {\n    const { validationConfig } = this.rootStore.config;\n    return new Promise<{\n      results: ValidationResult[];\n      hasCustomError: boolean;\n    }>(async (resolve) => {\n      const results: ValidationResult[] = [];\n      let hasCustomError = false;\n\n      const checkBoundary = validationConfig[ValidationType.OUT_OF_BOUNDARY];\n      if (checkBoundary && isSubmit) {\n        // only check all image boundary when submit\n        await this.rootStore.frame.fixImageSize();\n      }\n\n      const checkFrameValidAnnotate = validationConfig[ValidationType.FRAME_VALID_ANNOTATE];\n      const frameAnnotated: {\n        [camera: string]: {\n          [frameIndex: number]: boolean;\n        }\n      } = {};\n      const { attributes: frameAttributes } = this.rootStore.frame;\n      const { instances } = this.rootStore.instance;\n      Object.values(instances).forEach((instance) => {\n        const firstFrame = Number(Object.keys(instance.frameStatus)[0]);\n\n        // check instance attributes empty\n        if (validationConfig[ValidationType.ATTR_EMPTY]) {\n          const { labelConfig: instanceConfig } = instance.categoryRef;\n          if (instanceConfig && (!instance.attributes || !utils.validate(instanceConfig, instance.attributes, { check: true }))) {\n            // instance attributes\n            results.push({\n              type: ValidationType.ATTR_EMPTY,\n              id: instance.id,\n              message: i18n.translate('VALIDATION_ATTR_EMPTY_INSTANCE_MSG'),\n              frames: [firstFrame],\n              blockSubmit: true,\n            });\n          }\n        }\n\n        // instance items, check attributes empty & invalid shapes\n        const checkShapeArea = this.rootStore.config.minArea > 0 && validationConfig[ValidationType.INVALID_SHAPE];\n        Object.values(instance.items).forEach((item) => {\n          const { labelConfig: itemConfig, tools } = item.categoryItemRef;\n          const edges = tools[0]?.edges; // simply use first one because only one tool can be configured\n          const checkAttr = itemConfig && validationConfig[ValidationType.ATTR_EMPTY];\n          const checkShapeEdges = edges && validationConfig[ValidationType.INVALID_SHAPE];\n          if (checkAttr || checkShapeEdges || checkShapeArea || checkBoundary || checkFrameValidAnnotate) {\n            Object.values(item.cameras).forEach((camera) => {\n              const allFrames = Object.values(camera.frames).map(({ frameIndex }) => frameIndex);\n              const attrEmptyFrames: number[] = [];\n              const edgesInvalidFrames: number[] = [];\n              const areaInvalidFrames: number[] = [];\n              const boundaryInvalidFrames: number[] = [];\n              allFrames.forEach((frame) => {\n                const frameData = camera.frames[frame];\n                const { attributes, shapeType, shape } = frameData;\n                if (checkAttr) {\n                  if (!attributes || !utils.validate(itemConfig!, attributes, { check: true })) {\n                    attrEmptyFrames.push(frame);\n                  }\n                }\n                if (checkShapeEdges && [ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW].includes(shapeType)) {\n                  const { points } = shape as PolygonData | LineData;\n                  if (shapeType === ShapeType.POLYGON ? points.length !== edges : (points.length - 1) !== edges) {\n                    edgesInvalidFrames.push(frame);\n                  }\n                }\n                if (checkShapeArea) {\n                  const area = calcShapeArea(shapeType, shape);\n                  if (area < this.rootStore.config.minArea) {\n                    areaInvalidFrames.push(frame);\n                  }\n                }\n                if (checkBoundary) {\n                  const { imageWidth, imageHeight, rotation } = frameAttributes[camera.camera][frame];\n                  const exchange = rotation % Math.PI !== 0;\n                  if (imageWidth && imageWidth > 0 && imageHeight && imageHeight > 0) {\n                    const inBounds = checkShapeInBounds(shape, shapeType, {\n                      left: 0,\n                      top: 0,\n                      right: exchange ? imageHeight : imageWidth,\n                      bottom: exchange ? imageWidth : imageHeight,\n                    });\n                    if (!inBounds) {\n                      boundaryInvalidFrames.push(frame);\n                    }\n                  }\n                }\n                if (checkFrameValidAnnotate) {\n                  if (!frameAnnotated[camera.camera]) {\n                    frameAnnotated[camera.camera] = {};\n                  }\n                  frameAnnotated[camera.camera][frame] = true;\n                }\n              });\n              if (attrEmptyFrames.length > 0) {\n                results.push({\n                  type: ValidationType.ATTR_EMPTY,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_ATTR_EMPTY_MSG', { values: { frames: formatFrames(attrEmptyFrames) } }),\n                  info: { instanceId: instance.id, instanceItemId: item.id, camera: camera.camera },\n                  frames: [...attrEmptyFrames],\n                  blockSubmit: true,\n                });\n              }\n              if (edgesInvalidFrames.length > 0) {\n                results.push({\n                  type: ValidationType.INVALID_SHAPE,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_INVALID_SHAPE_MSG', { values: { frames: formatFrames(edgesInvalidFrames), count: edges } }),\n                  info: { instanceId: instance.id, instanceItemId: item.id, camera: camera.camera },\n                  frames: [...edgesInvalidFrames],\n                  blockSubmit: true,\n                });\n              }\n              if (areaInvalidFrames.length > 0) {\n                results.push({\n                  type: ValidationType.INVALID_SHAPE,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_INVALID_SHAPE_AREA_MSG', { values: { frames: formatFrames(areaInvalidFrames), area: this.rootStore.config.minArea } }),\n                  info: { instanceId: instance.id, instanceItemId: item.id, camera: camera.camera },\n                  frames: [...areaInvalidFrames],\n                  blockSubmit: true,\n                });\n              }\n              if (boundaryInvalidFrames.length > 0) {\n                results.push({\n                  type: ValidationType.OUT_OF_BOUNDARY,\n                  id: `${instance.id}-${item.id}-${camera.camera}`,\n                  message: i18n.translate('VALIDATION_OUT_OF_BOUNDARY_MSG', { values: { frames: formatFrames(boundaryInvalidFrames) } }),\n                  info: { instanceId: instance.id, instanceItemId: item.id, camera: camera.camera },\n                  frames: [...boundaryInvalidFrames],\n                  blockSubmit: true,\n                });\n              }\n            });\n          }\n        });\n\n        if (validationConfig[ValidationType.INSTANCE_ITEM_COUNT]) {\n          // check items count matches the ontology settings\n          const { children } = instance.categoryRef;\n          children.forEach(({ name, count, minCount, maxCount }) => {\n            const items = instance.getItemsByName(name);\n            if (count !== undefined) {\n              if (items.length !== count) {\n                results.push({\n                  type: ValidationType.INSTANCE_ITEM_COUNT,\n                  id: `${instance.id}-${name}`,\n                  message: i18n.translate('VALIDATION_INSTANCE_ITEM_COUNT_MSG', { values: { item: name, opt: '=', count } }),\n                  frames: [firstFrame],\n                  info: { instanceId: instance.id },\n                  blockSubmit: true,\n                });\n              }\n            } else if ((minCount !== undefined && items.length < minCount)) {\n              results.push({\n                type: ValidationType.INSTANCE_ITEM_COUNT,\n                id: `${instance.id}-${name}`,\n                message: i18n.translate('VALIDATION_INSTANCE_ITEM_COUNT_MSG', { values: { item: name, opt: '≥', count: minCount } }),\n                frames: [firstFrame],\n                info: { instanceId: instance.id },\n                blockSubmit: true,\n              });\n            } else if (maxCount !== undefined && items.length > maxCount) {\n              results.push({\n                type: ValidationType.INSTANCE_ITEM_COUNT,\n                id: `${instance.id}-${name}`,\n                message: i18n.translate('VALIDATION_INSTANCE_ITEM_COUNT_MSG', { values: { item: name, opt: '≤', count: maxCount } }),\n                frames: [firstFrame],\n                info: { instanceId: instance.id },\n                blockSubmit: true,\n              });\n            }\n          });\n        }\n      });\n\n      const checkFrameAttr = validationConfig[ValidationType.ATTR_EMPTY] && this.rootStore.frame.frameConfig;\n      if (checkFrameValidAnnotate || checkFrameAttr) {\n        const { cameras, frameConfig, isFrameValid } = this.rootStore.frame;\n        Object.keys(cameras).forEach((camera) => {\n          const invalidFrames: number[] = [];\n          cameras[camera].forEach((_, frameIndex) => {\n            if (checkFrameValidAnnotate) {\n              const valid = isFrameValid(camera, frameIndex);\n              const annotated = frameAnnotated[camera]?.[frameIndex];\n              if (valid && !annotated) {\n                results.push({\n                  type: ValidationType.FRAME_VALID_ANNOTATE,\n                  id: `${camera}-${frameIndex}`,\n                  message: i18n.translate('VALIDATION_FRAME_VALID_ANNOTATE_VALID_MSG', { values: { frame: frameIndex + 1 } }),\n                  frames: [frameIndex],\n                  info: { camera },\n                  blockSubmit: true,\n                });\n              }\n              if (!valid && annotated) {\n                results.push({\n                  type: ValidationType.FRAME_VALID_ANNOTATE,\n                  id: `${camera}-${frameIndex}`,\n                  message: i18n.translate('VALIDATION_FRAME_VALID_ANNOTATE_INVALID_MSG', { values: { frame: frameIndex + 1 } }),\n                  frames: [frameIndex],\n                  info: { camera },\n                  blockSubmit: true,\n                });\n              }\n            }\n            if (checkFrameAttr) {\n              if (!frameAttributes[camera] || !frameAttributes[camera][frameIndex]) {\n                invalidFrames.push(frameIndex);\n                return;\n              }\n              const { attributes } = frameAttributes[camera][frameIndex];\n              if (!attributes || !utils.validate(frameConfig!, attributes, { check: true })) {\n                invalidFrames.push(frameIndex);\n              }\n            }\n          });\n          if (invalidFrames.length > 0) {\n            results.push({\n              type: ValidationType.ATTR_EMPTY,\n              id: camera,\n              message: i18n.translate('VALIDATION_ATTR_EMPTY_FRAME_MSG', { values: { frames: formatFrames(invalidFrames) } }),\n              info: { camera, type: 'frame' },\n              frames: [...invalidFrames],\n              blockSubmit: true,\n            });\n          }\n        });\n      }\n\n      if (validationConfig[ValidationType.CUSTOM]) {\n        // get result link\n        let resultLink = '';\n        if (typeof this.rootStore.jobProxy?.reviewFrom === 'string') {\n          resultLink = this.rootStore.jobProxy.reviewFrom;\n        }\n        if (!this.rootStore.readonly) {\n          try {\n            resultLink = await this.rootStore.saveResult();\n          } catch (e) {\n            resultLink = '';\n          }\n        }\n        // custom check\n        const customResult = await runCustomValidation(validationConfig[ValidationType.CUSTOM] as string[], resultLink);\n        customResult.results.forEach((result) => {\n          results.push({ ...result, type: ValidationType.CUSTOM });\n        });\n        hasCustomError = customResult.hasCustomError;\n      }\n\n      resolve({ results, hasCustomError });\n    });\n  }\n\n  /**\n   * do canvas validation\n   */\n  validateCanvas() {\n    const { validationConfig } = this.rootStore.config;\n    if (validationConfig[ValidationType.EMPTY_AREA] || validationConfig[ValidationType.FULLY_COVERED]) {\n      this.canvasChecking = true;\n      this.worker.postMessage({\n        config: toJS(this.rootStore.config.validationConfig),\n        cameras: toJS(this.rootStore.frame.cameras),\n        cameraAttributes: toJS(this.rootStore.frame.attributes),\n        instances: this.rootStore.instance.instancesJSON(),\n      });\n    }\n  }\n\n  /**\n   * stop canvas validation\n   */\n  stopValidate = () => {\n    this.worker.postMessage({\n      type: 'stop',\n    });\n  };\n\n  /**\n   * save empty area results\n   * @param camera\n   * @param frameIndex\n   * @param polygons\n   */\n  saveEmptyAreaResults(camera: string, frameIndex: number, polygons: MultiPolygon) {\n    if (!this.emptyAreaResults[camera]) {\n      this.emptyAreaResults[camera] = {};\n    }\n    this.emptyAreaResults[camera][frameIndex] = [];\n    polygons.forEach((p, i) => {\n      const side = p[0];\n      const area = calcShapeArea(ShapeType.POLYGON, { points: side.map((point) => ({ x: point[0], y: point[1] })) });\n      if (area < DEFAULT_MIN_AREA) {\n        return;\n      }\n      this.emptyAreaResults[camera][frameIndex].push(p);\n      const xArr = side.map((pair) => pair[0]);\n      const yArr = side.map((pair) => pair[1]);\n      const left = Math.min(...xArr);\n      const right = Math.max(...xArr);\n      const top = Math.min(...yArr);\n      const bottom = Math.max(...yArr);\n      this.warnings.push({\n        type: ValidationType.EMPTY_AREA,\n        id: `${camera}-${frameIndex}-${i}`,\n        message: i18n.translate('VALIDATION_TYPE_EMPTY_AREA_MSG', { values: { frame: frameIndex + 1 } }),\n        frames: [frameIndex],\n        info: {\n          index: i,\n          bbox: { left, top, right, bottom },\n          camera,\n        },\n      });\n    });\n  }\n\n  /**\n   * save fully covered results\n   * @param camera\n   * @param frameIndex\n   * @param items\n   */\n  saveFullyCoveredResults(camera: string, frameIndex: number, items: { instanceId: string; instanceItemId: string }[]) {\n    items.forEach(({ instanceId, instanceItemId }) => {\n      this.warnings.push({\n        type: ValidationType.FULLY_COVERED,\n        id: `${camera}-${frameIndex}-${instanceItemId}`,\n        message: i18n.translate('VALIDATION_TYPE_FULLY_COVERED_MSG', { values: { frame: frameIndex + 1 } }),\n        frames: [frameIndex],\n        info: {\n          instanceId,\n          instanceItemId,\n          camera,\n        },\n      });\n    });\n  }\n\n  /**\n   * draw empty area\n   * @param polygons\n   */\n  drawEmptyArea(camera: string, polygons: MultiPolygon) {\n    const { cameraViews } = this.rootStore.frame;\n    const cameraView = cameraViews[camera];\n    if (cameraView && cameraView.checkLayer) {\n      cameraView.checkLayer.removeChildren();\n      const g = new Graphics();\n      g.lineStyle(4, 0xFF0000);\n      g.beginFill(0xFFFF00, 0.5);\n      polygons.forEach((polygon) => {\n        if (polygon.length > 0) {\n          const side = polygon[0];\n          g.drawPolygon(side.flatMap((i) => i));\n\n          const holes = polygon.slice(1);\n          holes.forEach((h) => {\n            g.beginHole();\n            g.drawPolygon(h.flatMap((i) => i));\n            g.endHole();\n          });\n        }\n      });\n      cameraView.checkLayer.addChild(g);\n    }\n  }\n\n  /**\n   * redraw by current frame info\n   */\n  redrawEmptyArea() {\n    const { currentFrame, cameraViews } = this.rootStore.frame;\n    Object.keys(cameraViews).forEach((camera) => {\n      const { checkLayer } = cameraViews[camera];\n      if (checkLayer) {\n        checkLayer.removeChildren();\n      }\n      if (this.emptyAreaResults[camera]) {\n        const emptyPolygons = this.emptyAreaResults[camera][currentFrame];\n        if (emptyPolygons) {\n          this.drawEmptyArea(camera, emptyPolygons);\n        }\n      }\n    });\n  }\n\n  /**\n   * worker terminate\n   */\n  terminate() {\n    this.worker.terminate();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}