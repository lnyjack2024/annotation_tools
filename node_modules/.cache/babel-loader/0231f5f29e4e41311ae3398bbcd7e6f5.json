{"ast":null,"code":"import { Point, Rectangle as PIXIRectangle } from 'pixi.js';\nimport Flatten from '@flatten-js/core';\nimport Layer from './Layer';\nimport Shape, { BorderStyle } from './Shape';\nimport { ShapeType } from './types';\nimport ControlPoint from './controls/ControlPoint';\nimport ControlBar from './controls/ControlBar';\nimport ControlRotation from './controls/ControlRotation';\nimport { precise } from './utils';\nimport Cursor from '../Cursor';\nimport { getFourDotsRectVertex, computeRotatedPosition } from '../../../utils/math';\nexport let RectType = /*#__PURE__*/function (RectType) {\n  RectType[\"FOUR_DOTS_RECT\"] = \"fourDotsRect\";\n  RectType[\"DEFAULT\"] = \"default\";\n  return RectType;\n}({});\n/**\n * Rectangle shape\n * @class\n */\nexport default class Rectangle extends Shape {\n  /**\n   * get x\n   * @getter\n   */\n  get x() {\n    return this._x || 0;\n  }\n\n  /**\n   * set x\n   * @setter\n   */\n  set x(x) {\n    this._x = x;\n    this.normalize();\n  }\n\n  /**\n   * get y\n   * @getter\n   */\n  get y() {\n    return this._y || 0;\n  }\n\n  /**\n   * set y\n   * @setter\n   */\n  set y(y) {\n    this._y = y;\n    this.normalize();\n  }\n\n  /**\n   * get width\n   * @getter\n   */\n  get width() {\n    return this._width || 0;\n  }\n\n  /**\n   * set width\n   * @setter\n   */\n  set width(width) {\n    this._width = width;\n    this.normalize();\n  }\n\n  /**\n   * get height\n   * @getter\n   */\n  get height() {\n    return this._height || 0;\n  }\n\n  /**\n   * set height\n   * @setter\n   */\n  set height(height) {\n    this._height = height;\n    this.normalize();\n  }\n\n  /**\n   * get center\n   * @getter\n   */\n  get center() {\n    return this._center || 0;\n  }\n\n  /**\n   * set center\n   * @setter\n   */\n  set center(center) {\n    this._center = center;\n    this._centerLineEnabled = true;\n    this.normalize();\n  }\n\n  /**\n   * get centerline enabled\n   * @getter\n   */\n  get centerLineEnabled() {\n    return this._centerLineEnabled;\n  }\n\n  /**\n   * set tolerance alpha\n   * @setter\n   */\n  set toleranceAlpha(toleranceAlpha) {\n    const shouldUpdate = this._toleranceAlpha !== toleranceAlpha;\n    this._toleranceAlpha = toleranceAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get position\n   * @getter\n   */\n  get position() {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * set position\n   * @setter\n   */\n  set position(point) {\n    if (this.x !== point.x || this.y !== point.y) {\n      const currX = this.x;\n      this._x = precise(point.x);\n      this._y = precise(point.y);\n      if (this._autoSnapEnabled && !this._ctrlKey) {\n        const {\n          left,\n          top,\n          right,\n          bottom\n        } = this.shapeBounds;\n        const {\n          x: x1,\n          y: y1\n        } = this.snapToRectangle(new Point(left, top));\n        const {\n          x: x2,\n          y: y2\n        } = this.snapToRectangle(new Point(right, bottom));\n        const l1 = precise(x1);\n        const l2 = precise(x2 - this.width);\n        const t1 = precise(y1);\n        const t2 = precise(y2 - this.height);\n        if (x1 !== left && x2 !== right) {\n          this._x = Math.abs(x1 - left) < Math.abs(x2 - right) ? l1 : l2;\n        } else if (x1 !== left) {\n          this._x = l1;\n        } else if (x2 !== right) {\n          this._x = l2;\n        }\n        if (y1 !== top && y2 !== bottom) {\n          this._y = Math.abs(y1 - top) < Math.abs(y2 - bottom) ? t1 : t2;\n        } else if (y1 !== top) {\n          this._y = t1;\n        } else if (y2 !== bottom) {\n          this._y = t2;\n        }\n      }\n      if (this._centerLineEnabled) {\n        this._center = precise(this.center + this._x - currX);\n      }\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get pivot\n   * @getter\n   */\n  get pivot() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  }\n\n  /**\n   * set pivot\n   * @setter\n   */\n  set pivot(point) {\n    const {\n      x: px,\n      y: py\n    } = this.pivot;\n    const shouldUpdate = point.x !== px || point.y !== py;\n    this._x = point.x - this.width / 2;\n    this._y = point.y - this.height / 2;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get visible\n   * @getter\n   */\n  get visible() {\n    return this._visible;\n  }\n\n  /**\n   * set visible\n   * @setter\n   */\n  set visible(visible) {\n    const shouldUpdate = this._visible !== visible;\n    this._visible = visible;\n    if (shouldUpdate) {\n      this.instance.visible = visible;\n      this.instance.interactive = visible ? this.interactive : false;\n      this.labelContainer.visible = visible;\n      this.vertexesContainer.visible = visible;\n      this.userDataContainer.visible = visible;\n      this.controlsContainer.visible = visible;\n      if (this._rotateControl) {\n        this._rotateControl.control.visible = visible;\n      }\n      if (this.labelDom) {\n        this.labelDom.visible = visible;\n      }\n    }\n  }\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  get shapeBounds() {\n    const rotatedPoints = this.getRotatedPoints();\n    const left = Math.min(...rotatedPoints.map(p => p.x));\n    const right = Math.max(...rotatedPoints.map(p => p.x));\n    const top = Math.min(...rotatedPoints.map(p => p.y));\n    const bottom = Math.max(...rotatedPoints.map(p => p.y));\n    return {\n      left,\n      top,\n      right,\n      bottom\n    };\n  }\n\n  /**\n   * shape area\n   * @getter\n   */\n  get area() {\n    return this.width * this.height;\n  }\n\n  /**\n   * set styles for point\n   */\n\n  constructor(options) {\n    super(options);\n    this.shapeType = ShapeType.RECTANGLE;\n    /**\n     * LT vertex position x\n     * @private\n     */\n    this._x = void 0;\n    /**\n     * LT vertex position y\n     * @private\n     */\n    this._y = void 0;\n    /**\n     * rectangle width\n     * @private\n     */\n    this._width = void 0;\n    /**\n     * rectangle height\n     * @private\n     */\n    this._height = void 0;\n    /**\n     * rectangle center line position x\n     * @private\n     */\n    this._center = void 0;\n    /**\n     * rectangle center line enabled\n     * @private\n     */\n    this._centerLineEnabled = false;\n    /**\n     * rectangle tolerance range\n     * @private\n     */\n    this._tolerance = void 0;\n    /**\n     * tolerance area alpha\n     * @private\n     */\n    this._toleranceAlpha = 0.2;\n    /**\n     * auto snap enabled\n     * @private\n     */\n    this._autoSnapEnabled = false;\n    /**\n     * rectangle rectType\n     * @private\n     */\n    this._rectType = RectType.DEFAULT;\n    /**\n     * fourDotRectangle primeval points\n     * @private\n     */\n    this._fourPoints = [];\n    this.pointStyler = void 0;\n    /**\n     * set styles for edge\n     */\n    this.edgeStyler = void 0;\n    /**\n     * fourDotsRect mouseMove\n     */\n    this.mouseMoveFourDots = event => {\n      const len = this._fourPoints.length;\n      if (len < 4) {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        const localPoint = this._mapStageToLocalPosition(point);\n        this.drawFourDots(localPoint);\n      }\n    };\n    /**\n     * fourDotsRect mouseMove\n     */\n    this.mouseUpFourDots = event => {\n      const len = this._fourPoints.length;\n      const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this._mapStageToLocalPosition(point);\n      const distance = len > 0 ? Math.sqrt((localPoint.x - this._fourPoints[len - 1].x) ** 2 + (localPoint.y - this._fourPoints[len - 1].y) ** 2) : 0;\n      if (len < 4 && distance > 4 / this.scale) {\n        this._fourPoints.push(localPoint);\n        if (this._fourPoints.length >= 4) {\n          document.removeEventListener('mouseup', this.mouseUpFourDots, false);\n          document.removeEventListener('mousemove', this.mouseMoveFourDots, false);\n          this.computeFourDots();\n        } else {\n          this.drawFourDots(localPoint);\n        }\n      }\n    };\n    const {\n      x,\n      y,\n      width,\n      height,\n      center,\n      centerLineEnabled = false,\n      tolerance,\n      toleranceAlpha = 0.2,\n      autoSnapEnabled = false,\n      rectType = RectType.DEFAULT,\n      pointStyler,\n      edgeStyler\n    } = options;\n    this._centerLineEnabled = centerLineEnabled;\n    this._tolerance = tolerance;\n    this._toleranceAlpha = toleranceAlpha;\n    this._autoSnapEnabled = autoSnapEnabled;\n    this._rectType = rectType;\n    this.pointStyler = pointStyler;\n    this.edgeStyler = edgeStyler;\n    if (x !== undefined && y !== undefined && width !== undefined && height !== undefined) {\n      this._x = x;\n      this._y = y;\n      this._width = width;\n      this._height = height;\n      if (center !== undefined) {\n        this._center = center || x + width / 2;\n        this._centerLineEnabled = true; // update _centerLineEnabled if center is not undefined\n      }\n      this.normalize();\n    }\n  }\n\n  /**\n   * get point style\n   * @param pointIndex\n   */\n  getPointStyle(pointIndex) {\n    let color = this.displayVertexColor;\n    let type = this.vertexType;\n    if (this.pointStyler) {\n      const styles = this.pointStyler(pointIndex, null, this);\n      if (styles.color) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n    }\n    return {\n      color,\n      type\n    };\n  }\n\n  /**\n   * get edge style\n   * @param pointIndex\n   */\n  getEdgeStyle(pointIndex) {\n    let color = this.displayBorderColor;\n    let type = this.borderType;\n    let bold = this.borderBold;\n    if (this.edgeStyler) {\n      const styles = this.edgeStyler(pointIndex, null, this);\n      if (styles.color && !this.selected && !this.hovered) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n      if (styles.bold) {\n        bold = true;\n      }\n    }\n    return {\n      color,\n      type,\n      bold\n    };\n  }\n\n  /**\n   * draw shape\n   */\n  drawShape() {\n    this.instance.clear();\n    this._drawShapeFill();\n    this._drawShapeToleranceArea();\n    this._drawShapeLine();\n    // this._drawShapeVertex();\n    if (this._finished) {\n      this.drawShapeLabel();\n      this.attachControlPoints();\n    }\n  }\n\n  /**\n   * draw point\n   */\n  drawFourDotsRectPoint() {\n    this.instance.lineStyle(0);\n    this._fourPoints.forEach(_point => {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(_point.x, _point.y, 4 / this.scale);\n      this.instance.endFill();\n    });\n  }\n\n  /**\n   * draw shape fill\n   */\n  _drawShapeFill() {\n    this.instance.beginFill(this.fillColor, this.alpha);\n    this.instance.drawRect(this.x, this.y, this.width, this.height);\n    this.instance.endFill();\n  }\n\n  /**\n   * draw shape border\n   */\n  _drawShapeLine() {\n    const baseWidth = this.borderWidth / this.scale;\n    const boldWidth = baseWidth * 4;\n    const [s1, s2, s3, s4] = Array.from({\n      length: 4\n    }).map((_, i) => this.getEdgeStyle(i));\n    this.instance.moveTo(this.x, this.y);\n    this.instance.lineStyle(s1.bold ? boldWidth : baseWidth, s1.color, this.borderAlpha);\n    this.instance.drawLine(this.x + this.width, this.y, this.borderStyle, s1.type);\n    this.instance.lineStyle(s2.bold ? boldWidth : baseWidth, s2.color, this.borderAlpha);\n    this.instance.drawLine(this.x + this.width, this.y + this.height, this.borderStyle, s2.type);\n    this.instance.lineStyle(s3.bold ? boldWidth : baseWidth, s3.color, this.borderAlpha);\n    this.instance.drawLine(this.x, this.y + this.height, this.borderStyle, s3.type);\n    this.instance.lineStyle(s4.bold ? boldWidth : baseWidth, s4.color, this.borderAlpha);\n    this.instance.drawLine(this.x, this.y, this.borderStyle, s4.type);\n    // this.instance.closePath();\n\n    if (this._centerLineEnabled) {\n      this.instance.moveTo(this.center, this.y);\n      this.instance.drawLine(this.center, this.y + this.height, this.borderStyle);\n    }\n  }\n\n  /**\n   * draw shape vertexes\n   * @private\n   */\n  _drawShapeVertex() {\n    this.vertexesContainer.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n    const r = this.vertexSize / this.scale;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this.getPoints().forEach((point, index) => {\n      if (this.showVertex && (!this.editable || !this.selected)) {\n        // draw vertex dot\n        const {\n          color,\n          type\n        } = this.getPointStyle(index);\n        this.instance.beginFill(color, this.borderAlpha);\n        this.instance.drawVertex(point.x, point.y, r, type);\n        this.instance.endFill();\n      }\n    });\n  }\n\n  /**\n   * draw shape tolerance area\n   * @private\n   */\n  _drawShapeToleranceArea() {\n    if (!this._tolerance || this._toleranceAlpha === 0) {\n      return;\n    }\n    const {\n      width,\n      height,\n      min\n    } = this._tolerance;\n    let wt = this.width * width;\n    if (min !== undefined && wt < min) {\n      wt = min;\n    }\n    let ht = this.height * height;\n    if (min !== undefined && ht < min) {\n      ht = min;\n    }\n    if (wt > 0 || ht > 0) {\n      this.instance.lineStyle(0);\n      this.instance.beginFill(this.originColors.borderColor, this._toleranceAlpha);\n      this.instance.drawRect(this.x - wt, this.y - ht, this.width + wt * 2, this.height + ht * 2);\n      this.instance.beginHole();\n      this.instance.beginFill(0xFFFFFF);\n      this.instance.drawRect(this.x + wt, this.y + ht, this.width - wt * 2, this.height - ht * 2);\n      this.instance.endHole();\n      this.instance.endFill();\n      this.instance.hitArea = new PIXIRectangle(this.x, this.y, this.width, this.height);\n    }\n  }\n\n  /**\n   * drag to create\n   */\n  create(_point) {\n    this._finished = false;\n    if (this._rectType === RectType.DEFAULT) {\n      const mouseMove = event => {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        const localPoint = this._mapStageToLocalPosition(point);\n        this._draw(this.snapToRectangle(localPoint, event.ctrlKey));\n      };\n      const mouseUp = () => {\n        this.normalize();\n        this._finish();\n        document.removeEventListener('mousemove', mouseMove, false);\n        document.removeEventListener('mouseup', mouseUp, false);\n      };\n      document.addEventListener('mousemove', mouseMove, false);\n      document.addEventListener('mouseup', mouseUp, false);\n    } else if (this._rectType === RectType.FOUR_DOTS_RECT) {\n      this._fourPoints.push(_point);\n      document.addEventListener('mousemove', this.mouseMoveFourDots, false);\n      document.addEventListener('mouseup', this.mouseUpFourDots, false);\n    }\n  }\n  computeFourDots() {\n    const aPoint = this._fourPoints[0];\n    const bPoint = this._fourPoints[1];\n    const cPoint = this._fourPoints[2];\n    const dPoint = this._fourPoints[3];\n    const {\n      x,\n      y,\n      width,\n      height,\n      rotation\n    } = getFourDotsRectVertex(aPoint, bPoint, cPoint, dPoint);\n    this._x = x;\n    this._y = y;\n    this._width = width;\n    this._height = height;\n    this.normalize();\n    /**\n     * reset rotation after normalize\n     */\n    this.rotation = rotation;\n    this._finish();\n  }\n\n  /**\n   * draw fourDots\n   */\n  drawFourDots(localPoint) {\n    const len = this._fourPoints.length;\n    this.instance.clear();\n    if (len === 1) {\n      this.drawSubline(localPoint);\n    } else if (this._fourPoints.length >= 2) {\n      this.drawSubline(this._fourPoints[1]);\n    }\n    this.drawFourDotsRectPoint();\n    if (len < 4) {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(localPoint.x, localPoint.y, 6 / this.scale);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw fourDots subline\n   */\n  drawSubline(localPoint) {\n    const lineTo = (x, y) => {\n      if (this.borderStyle === BorderStyle.DASHED) {\n        this.instance.dashLineTo(x, y);\n      } else {\n        this.instance.lineTo(x, y);\n      }\n    };\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this.instance.moveTo(this._fourPoints[0].x, this._fourPoints[0].y);\n    lineTo(localPoint.x, localPoint.y);\n  }\n\n  /**\n   * get label position\n   */\n  getLabelPosition() {\n    return this.position;\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      rotation: this.rotation,\n      points: this.getRotatedPoints(),\n      ...(this._centerLineEnabled && {\n        center: this.center\n      })\n    };\n  }\n\n  /**\n   * get geo json\n   */\n  getAreaAsGeoJSON() {\n    const rotatedPoints = this.getRotatedPoints();\n    return [[rotatedPoints.map(p => [p.x, p.y])]];\n  }\n\n  /**\n   * attach control points\n   */\n  attachControlPoints() {\n    if (!this.editable) {\n      var _this$_rotateControl;\n      this.removeControls();\n      (_this$_rotateControl = this._rotateControl) === null || _this$_rotateControl === void 0 ? void 0 : _this$_rotateControl.remove();\n      return;\n    }\n    const points = this.getPoints();\n    const edgePoints = points.map((point, index) => {\n      const nextPoint = points[index + 1 < 4 ? index + 1 : 0];\n      return {\n        x: (point.x + nextPoint.x) / 2,\n        y: (point.y + nextPoint.y) / 2\n      };\n    });\n    if (this.selected) {\n      edgePoints.forEach((point, index) => {\n        const i = index + 4;\n        const size = index % 2 === 0 ? this.width : this.height;\n        if (!this._controls[i]) {\n          this._controls[i] = new ControlBar({\n            type: index % 2 === 0 ? 'horizonal' : 'vertical',\n            size,\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            cursor: this.getCursor(i),\n            onPositionChange: (x, y, event) => this._updateByBarPosition(index, x, y, event),\n            onFinish: () => this._finishResize()\n          });\n        } else {\n          this._controls[i].cursor = this.getCursor(i);\n          this._controls[i].position = point;\n          this._controls[i].size = size;\n        }\n        this._controls[i].add();\n      });\n      points.forEach((point, index) => {\n        const {\n          color: fillColor,\n          type\n        } = this.getPointStyle(index);\n\n        // create if never created before\n        if (!this._controls[index]) {\n          this._controls[index] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            fillColor,\n            type,\n            cursor: this.getCursor(index),\n            onPositionChange: (x, y, event) => this._updateByPointPosition(index, x, y, event),\n            onFinish: () => this._finishResize()\n          });\n        } else {\n          // update\n          this._controls[index].fillColor = fillColor;\n          this._controls[index].type = type;\n          this._controls[index].cursor = this.getCursor(index);\n          this._controls[index].position = point;\n        }\n        this._controls[index].add();\n      });\n      if (this._centerLineEnabled) {\n        const point = {\n          x: this.center,\n          y: this.y + this.height / 2\n        };\n        const size = this.height;\n        if (!this._controls[8]) {\n          this._controls[8] = new ControlBar({\n            type: 'vertical',\n            size,\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            cursor: Cursor.EW_RESIZE,\n            onPositionChange: x => {\n              this._center = Math.min(Math.max(x, this.x), this.x + this.width);\n              this.drawShape();\n            },\n            onFinish: () => this._finishResize()\n          });\n        } else {\n          this._controls[8].position = point;\n          this._controls[8].size = size;\n        }\n        this._controls[8].add();\n      }\n    } else {\n      this.removeControls();\n    }\n    if (this.rotatable) {\n      if (this.selected) {\n        const size = this.pivot.y - Math.abs(this.height) / 2 - 50 / this.scale;\n        if (!this._rotateControl) {\n          this._rotateControl = new ControlRotation({\n            container: this.container,\n            position: this.pivot,\n            size,\n            rotation: this.shapeContainer.rotation,\n            scale: this.scale,\n            color: this.selectedColor,\n            onRotationChange: angle => {\n              if (this.rotation !== undefined) {\n                this.rotation += angle;\n                if (this.rotation >= Math.PI) {\n                  this.rotation -= 2 * Math.PI;\n                }\n                if (this.rotation <= -Math.PI) {\n                  this.rotation += 2 * Math.PI;\n                }\n              }\n            },\n            onFinish: () => {\n              this._changed();\n            }\n          });\n        }\n        this._rotateControl.rotation = this.shapeContainer.rotation;\n        this._rotateControl.position = this.pivot;\n        this._rotateControl.size = size;\n        this._rotateControl.add();\n      } else {\n        var _this$_rotateControl2;\n        (_this$_rotateControl2 = this._rotateControl) === null || _this$_rotateControl2 === void 0 ? void 0 : _this$_rotateControl2.remove();\n      }\n    }\n  }\n\n  /**\n   * update rectangle x, y, width, height by dragging point\n   * @private\n   * @param index point index\n   * @param x new position x\n   * @param y new position y\n   * @param event\n   */\n  _updateByPointPosition(index, x, y, event) {\n    const position = this._keepPointInBounds(this.snapToRectangle(new Point(x, y), event.data.originalEvent.ctrlKey));\n    const points = this.getPoints();\n    const offsetX = position.x - points[index].x;\n    const offsetY = position.y - points[index].y;\n    if (this._x !== undefined && this._y !== undefined && this._width !== undefined && this._height !== undefined) {\n      switch (index) {\n        case 0:\n          this._x = position.x;\n          this._y = position.y;\n          this._width -= offsetX;\n          this._height -= offsetY;\n          break;\n        case 1:\n          this._y += position.y - this._y;\n          this._width += offsetX;\n          this._height -= offsetY;\n          break;\n        case 2:\n          this._width += offsetX;\n          this._height += offsetY;\n          break;\n        case 3:\n          this._x += position.x - this._x;\n          this._width -= offsetX;\n          this._height += offsetY;\n          break;\n        default:\n      }\n      if (this._centerLineEnabled) {\n        this._normalizeCenterLine();\n      }\n      this.drawShape();\n      this._updatePosition(true);\n      this._resizing();\n    }\n  }\n\n  /**\n   * update rectangle x, y, width, height by dragging edge\n   * @param index edge index, top -> right -> bottom -> left\n   * @param x new position x\n   * @param y new position y\n   * @param event\n   */\n  _updateByBarPosition(index, x, y, event) {\n    const position = this._keepPointInBounds(this.snapToRectangle(new Point(x, y), event.data.originalEvent.ctrlKey));\n    if (this._x !== undefined && this._y !== undefined && this._width !== undefined && this._height !== undefined) {\n      const offsetX = position.x - this._x;\n      const offsetY = position.y - this._y;\n      switch (index) {\n        case 0:\n          this._y = position.y;\n          this._height -= offsetY;\n          break;\n        case 1:\n          this._width = offsetX;\n          break;\n        case 2:\n          this._height = offsetY;\n          break;\n        case 3:\n          this._x = position.x;\n          this._width -= offsetX;\n          break;\n        default:\n      }\n      if (this._centerLineEnabled) {\n        this._normalizeCenterLine();\n      }\n      this.drawShape();\n      this._updatePosition(true);\n      this._resizing();\n    }\n  }\n\n  /**\n   * when finish resize\n   */\n  _finishResize() {\n    this.resizing = false;\n    this.normalize();\n    this._changed();\n  }\n\n  /**\n   * draw shape by the position\n   * @private\n   * @param point mouse position\n   */\n  _draw(point) {\n    const p = this._keepPointInBounds(point);\n    if (this._x === undefined || this._y === undefined) {\n      this._x = p.x;\n      this._y = p.y;\n    } else {\n      this._width = p.x - this._x;\n      this._height = p.y - this._y;\n      if (this._centerLineEnabled) {\n        this._center = this._x + this._width / 2;\n      }\n    }\n    this.drawShape();\n  }\n\n  /**\n   * normalize center line position\n   * @private\n   */\n  _normalizeCenterLine() {\n    if (this.center < this.x) {\n      this._center = this.x;\n    } else if (this.center > this.x + this.width) {\n      this._center = this.x + this.width;\n    }\n    if (this._center !== undefined) {\n      this._center = precise(this._center);\n    }\n  }\n\n  /**\n   * normalize rectangle shape, remove it if necessary\n   */\n  normalize() {\n    if (this._x === undefined || this._y === undefined || !this._width || !this._height) {\n      this._remove();\n      return;\n    }\n    if (this._width < 0) {\n      this._x += this._width;\n      this._width = Math.abs(this._width);\n    }\n    if (this._height < 0) {\n      this._y += this._height;\n      this._height = Math.abs(this._height);\n    }\n    this._x = precise(this._x);\n    this._y = precise(this._y);\n    this._width = precise(this._width);\n    this._height = precise(this._height);\n    if (this._centerLineEnabled) {\n      this._normalizeCenterLine();\n    }\n    this.drawShape();\n  }\n\n  /**\n   * get control cursor\n   * @returns corsor\n   */\n  getCursor(index) {\n    const rotateMultiple = Math.round(this.rotation / (Math.PI / 4));\n    let cursor = Cursor.DEFAULT;\n    switch (rotateMultiple) {\n      case 0:\n      case 4:\n      case -4:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE;\n        }\n        break;\n      case 2:\n      case -2:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.NESW_RESIZE : Cursor.NWSE_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.EW_RESIZE : Cursor.NS_RESIZE;\n        }\n        break;\n      case 1:\n      case -3:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.NESW_RESIZE : Cursor.NWSE_RESIZE;\n        }\n        break;\n      case -1:\n      case 3:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.EW_RESIZE : Cursor.NS_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE;\n        }\n        break;\n      default:\n        break;\n    }\n    return cursor;\n  }\n\n  /**\n   * get 4 points based on the position and size\n   */\n  getPoints() {\n    const right = precise(this.x + this.width);\n    const bottom = precise(this.y + this.height);\n    return [{\n      x: this.x,\n      y: this.y\n    }, {\n      x: right,\n      y: this.y\n    }, {\n      x: right,\n      y: bottom\n    }, {\n      x: this.x,\n      y: bottom\n    }];\n  }\n\n  /**\n   * get actual 4 points position\n   */\n  getRotatedPoints() {\n    const points = this.getPoints();\n    if (this.rotation !== 0) {\n      points.forEach(p => {\n        const point = computeRotatedPosition(this.pivot, p, this.rotation);\n        p.x = precise(point.x);\n        p.y = precise(point.y);\n      });\n    }\n    return points;\n  }\n\n  /**\n   * snap to point\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point, tolerance = 8) {\n    const t = tolerance / this.scale;\n\n    // bbox\n    const {\n      x,\n      y\n    } = point;\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.shapeBounds;\n    if (x < left - t || x > right + t || y < top - t || y > bottom + t) {\n      return null;\n    }\n    const points = this.getRotatedPoints();\n    // points\n    let nearestPoint;\n    let d;\n    points.forEach(p => {\n      const pointDistance = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);\n      if (pointDistance < t && (d === undefined || pointDistance < d)) {\n        d = pointDistance;\n        nearestPoint = p;\n      }\n    });\n    if (nearestPoint) {\n      return new Point(nearestPoint.x, nearestPoint.y);\n    }\n\n    // edges\n    const location = new Flatten.Point(x, y);\n    for (let i = 0; i < points.length; i += 1) {\n      const startPoint = new Flatten.Point(points[i].x, points[i].y);\n      const endPoint = new Flatten.Point(points[(i + 1) % 4].x, points[(i + 1) % 4].y);\n      const line = new Flatten.Segment(startPoint, endPoint);\n      const [distance, segment] = line.distanceTo(location);\n      if (distance < t) {\n        const {\n          ps,\n          pe\n        } = segment;\n        const edgePoint = ps.equalTo(location) ? pe : ps;\n        return new Point(edgePoint.x, edgePoint.y);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * snap to rectangle edges\n   * @param point\n   * @param ctrlKey\n   * @param tolerance\n   */\n  snapToRectangle(point, ctrlKey = false, tolerance = 8) {\n    if (!this._autoSnapEnabled || ctrlKey || this.rotation !== 0) {\n      return point;\n    }\n    return this.container instanceof Layer ? this.container.snapToRectangle(point, tolerance / this.scale) : Layer.prototype.snapToRectangle.call(this.app.stage, point, tolerance / this.scale);\n  }\n}","map":{"version":3,"names":["Point","Rectangle","PIXIRectangle","Flatten","Layer","Shape","BorderStyle","ShapeType","ControlPoint","ControlBar","ControlRotation","precise","Cursor","getFourDotsRectVertex","computeRotatedPosition","RectType","x","_x","normalize","y","_y","width","_width","height","_height","center","_center","_centerLineEnabled","centerLineEnabled","toleranceAlpha","shouldUpdate","_toleranceAlpha","drawShape","position","point","currX","_autoSnapEnabled","_ctrlKey","left","top","right","bottom","shapeBounds","x1","y1","snapToRectangle","x2","y2","l1","l2","t1","t2","Math","abs","pivot","px","py","visible","_visible","instance","interactive","labelContainer","vertexesContainer","userDataContainer","controlsContainer","_rotateControl","control","labelDom","rotatedPoints","getRotatedPoints","min","map","p","max","area","constructor","options","shapeType","RECTANGLE","_tolerance","_rectType","DEFAULT","_fourPoints","pointStyler","edgeStyler","mouseMoveFourDots","event","len","length","_mapScreenToStagePosition","clientX","clientY","localPoint","_mapStageToLocalPosition","drawFourDots","mouseUpFourDots","distance","sqrt","scale","push","document","removeEventListener","computeFourDots","tolerance","autoSnapEnabled","rectType","undefined","getPointStyle","pointIndex","color","displayVertexColor","type","vertexType","styles","getEdgeStyle","displayBorderColor","borderType","bold","borderBold","selected","hovered","clear","_drawShapeFill","_drawShapeToleranceArea","_drawShapeLine","_finished","drawShapeLabel","attachControlPoints","drawFourDotsRectPoint","lineStyle","forEach","_point","beginFill","selectedColor","drawCircle","endFill","fillColor","alpha","drawRect","baseWidth","borderWidth","boldWidth","s1","s2","s3","s4","Array","from","_","i","moveTo","borderAlpha","drawLine","borderStyle","_drawShapeVertex","removeChildren","showVertex","showVertexOrder","r","vertexSize","getPoints","index","editable","drawVertex","wt","ht","originColors","borderColor","beginHole","endHole","hitArea","create","mouseMove","_draw","ctrlKey","mouseUp","_finish","addEventListener","FOUR_DOTS_RECT","aPoint","bPoint","cPoint","dPoint","rotation","drawSubline","lineTo","DASHED","dashLineTo","getLabelPosition","getData","points","getAreaAsGeoJSON","_this$_rotateControl","removeControls","remove","edgePoints","nextPoint","size","_controls","container","cursor","getCursor","onPositionChange","_updateByBarPosition","onFinish","_finishResize","add","_updateByPointPosition","EW_RESIZE","rotatable","shapeContainer","onRotationChange","angle","PI","_changed","_this$_rotateControl2","_keepPointInBounds","data","originalEvent","offsetX","offsetY","_normalizeCenterLine","_updatePosition","_resizing","resizing","_remove","rotateMultiple","round","NWSE_RESIZE","NESW_RESIZE","NS_RESIZE","snapToPoint","t","nearestPoint","d","pointDistance","location","startPoint","endPoint","line","Segment","segment","distanceTo","ps","pe","edgePoint","equalTo","prototype","call","app","stage"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/Rectangle.ts"],"sourcesContent":["import { InteractionEvent, Point, Rectangle as PIXIRectangle } from 'pixi.js';\nimport Flatten from '@flatten-js/core';\nimport Layer from './Layer';\nimport Shape, { ShapeOptions, BorderStyle } from './Shape';\nimport { ShapeType, ShapeData, VertexStyles, EdgeStyles } from './types';\nimport ControlPoint from './controls/ControlPoint';\nimport ControlBar from './controls/ControlBar';\nimport ControlRotation from './controls/ControlRotation';\nimport { precise } from './utils';\nimport Cursor from '../Cursor';\nimport { getFourDotsRectVertex, computeRotatedPosition } from '../../../utils/math';\n\nexport enum RectType {\n  FOUR_DOTS_RECT = 'fourDotsRect',\n  DEFAULT = 'default',\n}\n\nexport interface RectangleData {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  points: {x: number, y: number}[];\n  rotation?: number;\n  // for center line rectangle\n  center?: number;\n}\n\nexport interface RectangleOptions extends ShapeOptions {\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  rectType?: RectType;\n  // for center line rectangle\n  centerLineEnabled?: boolean;\n  center?: number;\n  // tolerance\n  tolerance?: Tolerance;\n  toleranceAlpha?: number;\n  // for auto snap\n  autoSnapEnabled?: boolean;\n  pointStyler?: (pointIndex: number, userData: any, shape: Shape<ShapeData>) => VertexStyles;\n  edgeStyler?: (startPointIndex: number, userData: any, shape: Shape<ShapeData>) => EdgeStyles;\n}\n\ninterface Tolerance {\n  width: number;\n  height: number;\n  min?: number;\n}\n\n/**\n * Rectangle shape\n * @class\n */\nexport default class Rectangle extends Shape<RectangleData> {\n  shapeType = ShapeType.RECTANGLE;\n\n  /**\n   * LT vertex position x\n   * @private\n   */\n  private _x: number | undefined;\n\n  /**\n   * LT vertex position y\n   * @private\n   */\n  private _y: number | undefined;\n\n  /**\n   * rectangle width\n   * @private\n   */\n  private _width: number | undefined;\n\n  /**\n   * rectangle height\n   * @private\n   */\n  private _height: number | undefined;\n\n  /**\n   * rectangle center line position x\n   * @private\n   */\n  private _center: number | undefined;\n\n  /**\n   * rectangle center line enabled\n   * @private\n   */\n  private _centerLineEnabled = false;\n\n  /**\n   * rectangle tolerance range\n   * @private\n   */\n  private _tolerance?: Tolerance;\n\n  /**\n   * tolerance area alpha\n   * @private\n   */\n  private _toleranceAlpha = 0.2;\n\n  /**\n   * auto snap enabled\n   * @private\n   */\n  private _autoSnapEnabled = false;\n\n  /**\n   * rectangle rectType\n   * @private\n   */\n  private _rectType = RectType.DEFAULT;\n\n  /**\n   * fourDotRectangle primeval points\n   * @private\n   */\n  private _fourPoints: Point[] = [];\n\n  /**\n   * get x\n   * @getter\n   */\n  get x() {\n    return this._x || 0;\n  }\n\n  /**\n   * set x\n   * @setter\n   */\n  set x(x: number) {\n    this._x = x;\n    this.normalize();\n  }\n\n  /**\n   * get y\n   * @getter\n   */\n  get y() {\n    return this._y || 0;\n  }\n\n  /**\n   * set y\n   * @setter\n   */\n  set y(y: number) {\n    this._y = y;\n    this.normalize();\n  }\n\n  /**\n   * get width\n   * @getter\n   */\n  get width() {\n    return this._width || 0;\n  }\n\n  /**\n   * set width\n   * @setter\n   */\n  set width(width: number) {\n    this._width = width;\n    this.normalize();\n  }\n\n  /**\n   * get height\n   * @getter\n   */\n  get height() {\n    return this._height || 0;\n  }\n\n  /**\n   * set height\n   * @setter\n   */\n  set height(height: number) {\n    this._height = height;\n    this.normalize();\n  }\n\n  /**\n   * get center\n   * @getter\n   */\n  get center() {\n    return this._center || 0;\n  }\n\n  /**\n   * set center\n   * @setter\n   */\n  set center(center: number) {\n    this._center = center;\n    this._centerLineEnabled = true;\n    this.normalize();\n  }\n\n  /**\n   * get centerline enabled\n   * @getter\n   */\n  get centerLineEnabled() {\n    return this._centerLineEnabled;\n  }\n\n  /**\n   * set tolerance alpha\n   * @setter\n   */\n  set toleranceAlpha(toleranceAlpha: number) {\n    const shouldUpdate = this._toleranceAlpha !== toleranceAlpha;\n    this._toleranceAlpha = toleranceAlpha;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get position\n   * @getter\n   */\n  get position() {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * set position\n   * @setter\n   */\n  set position(point: Point) {\n    if (this.x !== point.x || this.y !== point.y) {\n      const currX = this.x;\n      this._x = precise(point.x);\n      this._y = precise(point.y);\n\n      if (this._autoSnapEnabled && !this._ctrlKey) {\n        const { left, top, right, bottom } = this.shapeBounds;\n        const { x: x1, y: y1 } = this.snapToRectangle(new Point(left, top));\n        const { x: x2, y: y2 } = this.snapToRectangle(new Point(right, bottom));\n        const l1 = precise(x1);\n        const l2 = precise(x2 - this.width);\n        const t1 = precise(y1);\n        const t2 = precise(y2 - this.height);\n        if (x1 !== left && x2 !== right) {\n          this._x = Math.abs(x1 - left) < Math.abs(x2 - right) ? l1 : l2;\n        } else if (x1 !== left) {\n          this._x = l1;\n        } else if (x2 !== right) {\n          this._x = l2;\n        }\n        if (y1 !== top && y2 !== bottom) {\n          this._y = Math.abs(y1 - top) < Math.abs(y2 - bottom) ? t1 : t2;\n        } else if (y1 !== top) {\n          this._y = t1;\n        } else if (y2 !== bottom) {\n          this._y = t2;\n        }\n      }\n\n      if (this._centerLineEnabled) {\n        this._center = precise(this.center + this._x - currX);\n      }\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get pivot\n   * @getter\n   */\n  get pivot() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  }\n\n  /**\n   * set pivot\n   * @setter\n   */\n  set pivot(point: Point) {\n    const { x: px, y: py } = this.pivot;\n    const shouldUpdate = point.x !== px || point.y !== py;\n    this._x = point.x - this.width / 2;\n    this._y = point.y - this.height / 2;\n    if (shouldUpdate) {\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get visible\n   * @getter\n   */\n  get visible() {\n    return this._visible;\n  }\n\n  /**\n   * set visible\n   * @setter\n   */\n  set visible(visible: boolean) {\n    const shouldUpdate = this._visible !== visible;\n    this._visible = visible;\n    if (shouldUpdate) {\n      this.instance.visible = visible;\n      this.instance.interactive = visible ? this.interactive : false;\n      this.labelContainer.visible = visible;\n      this.vertexesContainer.visible = visible;\n      this.userDataContainer.visible = visible;\n      this.controlsContainer.visible = visible;\n      if (this._rotateControl) {\n        this._rotateControl.control.visible = visible;\n      }\n      if (this.labelDom) {\n        this.labelDom.visible = visible;\n      }\n    }\n  }\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  get shapeBounds() {\n    const rotatedPoints = this.getRotatedPoints();\n    const left = Math.min(...rotatedPoints.map((p) => p.x));\n    const right = Math.max(...rotatedPoints.map((p) => p.x));\n    const top = Math.min(...rotatedPoints.map((p) => p.y));\n    const bottom = Math.max(...rotatedPoints.map((p) => p.y));\n    return { left, top, right, bottom };\n  }\n\n  /**\n   * shape area\n   * @getter\n   */\n  get area() {\n    return this.width * this.height;\n  }\n\n  /**\n   * set styles for point\n   */\n  pointStyler?: (pointIndex: number, userData: any, shape: Shape<ShapeData>) => VertexStyles;\n\n  /**\n   * set styles for edge\n   */\n  edgeStyler?: (startPointIndex: number, userData: any, shape: Shape<ShapeData>) => EdgeStyles;\n\n  constructor(options: RectangleOptions) {\n    super(options);\n\n    const { x, y, width, height, center, centerLineEnabled = false, tolerance, toleranceAlpha = 0.2, autoSnapEnabled = false, rectType = RectType.DEFAULT, pointStyler, edgeStyler } = options;\n    this._centerLineEnabled = centerLineEnabled;\n    this._tolerance = tolerance;\n    this._toleranceAlpha = toleranceAlpha;\n    this._autoSnapEnabled = autoSnapEnabled;\n    this._rectType = rectType;\n    this.pointStyler = pointStyler;\n    this.edgeStyler = edgeStyler;\n\n    if (x !== undefined && y !== undefined && width !== undefined && height !== undefined) {\n      this._x = x;\n      this._y = y;\n      this._width = width;\n      this._height = height;\n      if (center !== undefined) {\n        this._center = center || x + width / 2;\n        this._centerLineEnabled = true; // update _centerLineEnabled if center is not undefined\n      }\n      this.normalize();\n    }\n  }\n\n  /**\n   * get point style\n   * @param pointIndex\n   */\n  getPointStyle(pointIndex: number) {\n    let color = this.displayVertexColor;\n    let type = this.vertexType;\n    if (this.pointStyler) {\n      const styles = this.pointStyler(pointIndex, null, this);\n      if (styles.color) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n    }\n    return { color, type };\n  }\n\n  /**\n   * get edge style\n   * @param pointIndex\n   */\n  getEdgeStyle(pointIndex: number) {\n    let color = this.displayBorderColor;\n    let type = this.borderType;\n    let bold = this.borderBold;\n    if (this.edgeStyler) {\n      const styles = this.edgeStyler(pointIndex, null, this);\n      if (styles.color && !this.selected && !this.hovered) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n      if (styles.bold) {\n        bold = true;\n      }\n    }\n    return { color, type, bold };\n  }\n\n  /**\n   * draw shape\n   */\n  drawShape() {\n    this.instance.clear();\n    this._drawShapeFill();\n    this._drawShapeToleranceArea();\n    this._drawShapeLine();\n    // this._drawShapeVertex();\n    if (this._finished) {\n      this.drawShapeLabel();\n      this.attachControlPoints();\n    }\n  }\n\n  /**\n   * draw point\n   */\n  drawFourDotsRectPoint() {\n    this.instance.lineStyle(0);\n    this._fourPoints.forEach((_point:Point) => {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(_point.x, _point.y, 4 / this.scale);\n      this.instance.endFill();\n    });\n  }\n\n  /**\n   * draw shape fill\n   */\n  private _drawShapeFill() {\n    this.instance.beginFill(this.fillColor, this.alpha);\n    this.instance.drawRect(this.x, this.y, this.width, this.height);\n    this.instance.endFill();\n  }\n\n  /**\n   * draw shape border\n   */\n  private _drawShapeLine() {\n    const baseWidth = this.borderWidth / this.scale;\n    const boldWidth = baseWidth * 4;\n    const [s1, s2, s3, s4] = Array.from({ length: 4 }).map((_, i) => this.getEdgeStyle(i));\n    this.instance.moveTo(this.x, this.y);\n    this.instance.lineStyle(s1.bold ? boldWidth : baseWidth, s1.color, this.borderAlpha);\n    this.instance.drawLine(this.x + this.width, this.y, this.borderStyle, s1.type);\n    this.instance.lineStyle(s2.bold ? boldWidth : baseWidth, s2.color, this.borderAlpha);\n    this.instance.drawLine(this.x + this.width, this.y + this.height, this.borderStyle, s2.type);\n    this.instance.lineStyle(s3.bold ? boldWidth : baseWidth, s3.color, this.borderAlpha);\n    this.instance.drawLine(this.x, this.y + this.height, this.borderStyle, s3.type);\n    this.instance.lineStyle(s4.bold ? boldWidth : baseWidth, s4.color, this.borderAlpha);\n    this.instance.drawLine(this.x, this.y, this.borderStyle, s4.type);\n    // this.instance.closePath();\n\n    if (this._centerLineEnabled) {\n      this.instance.moveTo(this.center, this.y);\n      this.instance.drawLine(this.center, this.y + this.height, this.borderStyle);\n    }\n  }\n\n  /**\n   * draw shape vertexes\n   * @private\n   */\n  private _drawShapeVertex() {\n    this.vertexesContainer.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n\n    const r = this.vertexSize / this.scale;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this.getPoints().forEach((point, index) => {\n      if (this.showVertex && (!this.editable || !this.selected)) {\n        // draw vertex dot\n        const { color, type } = this.getPointStyle(index);\n        this.instance.beginFill(color, this.borderAlpha);\n        this.instance.drawVertex(point.x, point.y, r, type);\n        this.instance.endFill();\n      }\n    });\n  }\n\n  /**\n   * draw shape tolerance area\n   * @private\n   */\n  private _drawShapeToleranceArea() {\n    if (!this._tolerance || this._toleranceAlpha === 0) {\n      return;\n    }\n    const { width, height, min } = this._tolerance;\n    let wt = this.width * width;\n    if (min !== undefined && wt < min) {\n      wt = min;\n    }\n    let ht = this.height * height;\n    if (min !== undefined && ht < min) {\n      ht = min;\n    }\n    if (wt > 0 || ht > 0) {\n      this.instance.lineStyle(0);\n      this.instance.beginFill(this.originColors.borderColor, this._toleranceAlpha);\n      this.instance.drawRect(this.x - wt, this.y - ht, this.width + wt * 2, this.height + ht * 2);\n      this.instance.beginHole();\n      this.instance.beginFill(0xFFFFFF);\n      this.instance.drawRect(this.x + wt, this.y + ht, this.width - wt * 2, this.height - ht * 2);\n      this.instance.endHole();\n      this.instance.endFill();\n\n      this.instance.hitArea = new PIXIRectangle(this.x, this.y, this.width, this.height);\n    }\n  }\n\n  /**\n   * drag to create\n   */\n  create(_point:Point) {\n    this._finished = false;\n    if (this._rectType === RectType.DEFAULT) {\n      const mouseMove = (event: MouseEvent) => {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        const localPoint = this._mapStageToLocalPosition(point);\n        this._draw(this.snapToRectangle(localPoint, event.ctrlKey));\n      };\n      const mouseUp = () => {\n        this.normalize();\n        this._finish();\n        document.removeEventListener('mousemove', mouseMove, false);\n        document.removeEventListener('mouseup', mouseUp, false);\n      };\n      document.addEventListener('mousemove', mouseMove, false);\n      document.addEventListener('mouseup', mouseUp, false);\n    } else if (this._rectType === RectType.FOUR_DOTS_RECT) {\n      this._fourPoints.push(_point);\n      document.addEventListener('mousemove', this.mouseMoveFourDots, false);\n      document.addEventListener('mouseup', this.mouseUpFourDots, false);\n    }\n  }\n\n  /**\n   * fourDotsRect mouseMove\n   */\n  mouseMoveFourDots = (event:MouseEvent) => {\n    const len: number = this._fourPoints.length;\n    if (len < 4) {\n      const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this._mapStageToLocalPosition(point);\n      this.drawFourDots(localPoint);\n    }\n  };\n\n  /**\n   * fourDotsRect mouseMove\n   */\n  mouseUpFourDots = (event:MouseEvent) => {\n    const len: number = this._fourPoints.length;\n    const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n    const localPoint = this._mapStageToLocalPosition(point);\n    const distance: number = len > 0 ? Math.sqrt((localPoint.x - this._fourPoints[len - 1].x) ** 2 + (localPoint.y - this._fourPoints[len - 1].y) ** 2) : 0;\n    if (len < 4 && distance > (4 / this.scale)) {\n      this._fourPoints.push(localPoint);\n      if (this._fourPoints.length >= 4) {\n        document.removeEventListener('mouseup', this.mouseUpFourDots, false);\n        document.removeEventListener('mousemove', this.mouseMoveFourDots, false);\n        this.computeFourDots();\n      } else {\n        this.drawFourDots(localPoint);\n      }\n    }\n  };\n\n  computeFourDots() {\n    const aPoint:Point = this._fourPoints[0];\n    const bPoint:Point = this._fourPoints[1];\n    const cPoint:Point = this._fourPoints[2];\n    const dPoint:Point = this._fourPoints[3];\n\n    const { x, y, width, height, rotation } = getFourDotsRectVertex(aPoint, bPoint, cPoint, dPoint);\n    this._x = x;\n    this._y = y;\n    this._width = width;\n    this._height = height;\n    this.normalize();\n    /**\n     * reset rotation after normalize\n     */\n    this.rotation = rotation;\n    this._finish();\n  }\n\n  /**\n   * draw fourDots\n   */\n  drawFourDots(localPoint: Point) {\n    const len: number = this._fourPoints.length;\n    this.instance.clear();\n    if (len === 1) {\n      this.drawSubline(localPoint);\n    } else if (this._fourPoints.length >= 2) {\n      this.drawSubline(this._fourPoints[1]);\n    }\n    this.drawFourDotsRectPoint();\n    if (len < 4) {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(localPoint.x, localPoint.y, 6 / this.scale);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw fourDots subline\n   */\n  drawSubline(localPoint: Point) {\n    const lineTo = (x: number, y: number) => {\n      if (this.borderStyle === BorderStyle.DASHED) {\n        this.instance.dashLineTo(x, y);\n      } else {\n        this.instance.lineTo(x, y);\n      }\n    };\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this.instance.moveTo(this._fourPoints[0].x, this._fourPoints[0].y);\n    lineTo(localPoint.x, localPoint.y);\n  }\n\n  /**\n   * get label position\n   */\n  getLabelPosition() {\n    return this.position;\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      rotation: this.rotation,\n      points: this.getRotatedPoints(),\n      ...this._centerLineEnabled && {\n        center: this.center,\n      },\n    };\n  }\n\n  /**\n   * get geo json\n   */\n  getAreaAsGeoJSON() {\n    const rotatedPoints = this.getRotatedPoints();\n    return [[rotatedPoints.map((p) => [p.x, p.y] as [number, number])]];\n  }\n\n  /**\n   * attach control points\n   */\n  attachControlPoints() {\n    if (!this.editable) {\n      this.removeControls();\n      this._rotateControl?.remove();\n      return;\n    }\n\n    const points = this.getPoints();\n    const edgePoints = points.map((point, index) => {\n      const nextPoint = points[index + 1 < 4 ? index + 1 : 0];\n      return {\n        x: (point.x + nextPoint.x) / 2,\n        y: (point.y + nextPoint.y) / 2,\n      };\n    });\n    if (this.selected) {\n      edgePoints.forEach((point, index) => {\n        const i = index + 4;\n        const size = index % 2 === 0 ? this.width : this.height;\n        if (!this._controls[i]) {\n          this._controls[i] = new ControlBar({\n            type: index % 2 === 0 ? 'horizonal' : 'vertical',\n            size,\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            cursor: this.getCursor(i),\n            onPositionChange: (x, y, event) => this._updateByBarPosition(index, x, y, event),\n            onFinish: () => this._finishResize(),\n          });\n        } else {\n          this._controls[i].cursor = this.getCursor(i);\n          this._controls[i].position = point;\n          this._controls[i].size = size;\n        }\n        this._controls[i].add();\n      });\n\n      points.forEach((point, index) => {\n        const { color: fillColor, type } = this.getPointStyle(index);\n\n        // create if never created before\n        if (!this._controls[index]) {\n          this._controls[index] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            fillColor,\n            type,\n            cursor: this.getCursor(index),\n            onPositionChange: (x, y, event) => this._updateByPointPosition(index, x, y, event),\n            onFinish: () => this._finishResize(),\n          });\n        } else {\n          // update\n          (this._controls[index] as ControlPoint).fillColor = fillColor;\n          (this._controls[index] as ControlPoint).type = type;\n          this._controls[index].cursor = this.getCursor(index);\n          this._controls[index].position = point;\n        }\n        this._controls[index].add();\n      });\n\n      if (this._centerLineEnabled) {\n        const point = { x: this.center, y: this.y + this.height / 2 };\n        const size = this.height;\n        if (!this._controls[8]) {\n          this._controls[8] = new ControlBar({\n            type: 'vertical',\n            size,\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            cursor: Cursor.EW_RESIZE,\n            onPositionChange: (x) => {\n              this._center = Math.min(Math.max(x, this.x), this.x + this.width);\n              this.drawShape();\n            },\n            onFinish: () => this._finishResize(),\n          });\n        } else {\n          this._controls[8].position = point;\n          this._controls[8].size = size;\n        }\n        this._controls[8].add();\n      }\n    } else {\n      this.removeControls();\n    }\n\n    if (this.rotatable) {\n      if (this.selected) {\n        const size = this.pivot.y - Math.abs(this.height) / 2 - 50 / this.scale;\n        if (!this._rotateControl) {\n          this._rotateControl = new ControlRotation({\n            container: this.container,\n            position: this.pivot,\n            size,\n            rotation: this.shapeContainer.rotation,\n            scale: this.scale,\n            color: this.selectedColor,\n            onRotationChange: (angle) => {\n              if (this.rotation !== undefined) {\n                this.rotation += angle;\n                if (this.rotation >= Math.PI) {\n                  this.rotation -= 2 * Math.PI;\n                }\n                if (this.rotation <= -Math.PI) {\n                  this.rotation += 2 * Math.PI;\n                }\n              }\n            },\n            onFinish: () => {\n              this._changed();\n            }\n          });\n        }\n        this._rotateControl.rotation = this.shapeContainer.rotation;\n        this._rotateControl.position = this.pivot;\n        this._rotateControl.size = size;\n        this._rotateControl.add();\n      } else {\n        this._rotateControl?.remove();\n      }\n    }\n  }\n\n  /**\n   * update rectangle x, y, width, height by dragging point\n   * @private\n   * @param index point index\n   * @param x new position x\n   * @param y new position y\n   * @param event\n   */\n  private _updateByPointPosition(index: number, x: number, y: number, event: InteractionEvent) {\n    const position = this._keepPointInBounds(this.snapToRectangle(new Point(x, y), event.data.originalEvent.ctrlKey));\n    const points = this.getPoints();\n    const offsetX = position.x - points[index].x;\n    const offsetY = position.y - points[index].y;\n    if (this._x !== undefined && this._y !== undefined && this._width !== undefined && this._height !== undefined) {\n      switch (index) {\n        case 0:\n          this._x = position.x;\n          this._y = position.y;\n          this._width -= offsetX;\n          this._height -= offsetY;\n          break;\n        case 1:\n          this._y += position.y - this._y;\n          this._width += offsetX;\n          this._height -= offsetY;\n          break;\n        case 2:\n          this._width += offsetX;\n          this._height += offsetY;\n          break;\n        case 3:\n          this._x += position.x - this._x;\n          this._width -= offsetX;\n          this._height += offsetY;\n          break;\n        default:\n      }\n      if (this._centerLineEnabled) {\n        this._normalizeCenterLine();\n      }\n      this.drawShape();\n      this._updatePosition(true);\n      this._resizing();\n    }\n  }\n\n  /**\n   * update rectangle x, y, width, height by dragging edge\n   * @param index edge index, top -> right -> bottom -> left\n   * @param x new position x\n   * @param y new position y\n   * @param event\n   */\n  private _updateByBarPosition(index: number, x: number, y: number, event: InteractionEvent) {\n    const position = this._keepPointInBounds(this.snapToRectangle(new Point(x, y), event.data.originalEvent.ctrlKey));\n    if (this._x !== undefined && this._y !== undefined && this._width !== undefined && this._height !== undefined) {\n      const offsetX = position.x - this._x;\n      const offsetY = position.y - this._y;\n      switch (index) {\n        case 0:\n          this._y = position.y;\n          this._height -= offsetY;\n          break;\n        case 1:\n          this._width = offsetX;\n          break;\n        case 2:\n          this._height = offsetY;\n          break;\n        case 3:\n          this._x = position.x;\n          this._width -= offsetX;\n          break;\n        default:\n      }\n      if (this._centerLineEnabled) {\n        this._normalizeCenterLine();\n      }\n      this.drawShape();\n      this._updatePosition(true);\n      this._resizing();\n    }\n  }\n\n  /**\n   * when finish resize\n   */\n  private _finishResize() {\n    this.resizing = false;\n    this.normalize();\n    this._changed();\n  }\n\n  /**\n   * draw shape by the position\n   * @private\n   * @param point mouse position\n   */\n  private _draw(point: Point) {\n    const p = this._keepPointInBounds(point);\n    if (this._x === undefined || this._y === undefined) {\n      this._x = p.x;\n      this._y = p.y;\n    } else {\n      this._width = p.x - this._x;\n      this._height = p.y - this._y;\n      if (this._centerLineEnabled) {\n        this._center = this._x + this._width / 2;\n      }\n    }\n    this.drawShape();\n  }\n\n  /**\n   * normalize center line position\n   * @private\n   */\n  private _normalizeCenterLine() {\n    if (this.center < this.x) {\n      this._center = this.x;\n    } else if (this.center > this.x + this.width) {\n      this._center = this.x + this.width;\n    }\n    if (this._center !== undefined) {\n      this._center = precise(this._center);\n    }\n  }\n\n  /**\n   * normalize rectangle shape, remove it if necessary\n   */\n  normalize() {\n    if (this._x === undefined || this._y === undefined || !this._width || !this._height) {\n      this._remove();\n      return;\n    }\n\n    if (this._width < 0) {\n      this._x += this._width;\n      this._width = Math.abs(this._width);\n    }\n    if (this._height < 0) {\n      this._y += this._height;\n      this._height = Math.abs(this._height);\n    }\n    this._x = precise(this._x);\n    this._y = precise(this._y);\n    this._width = precise(this._width);\n    this._height = precise(this._height);\n\n    if (this._centerLineEnabled) {\n      this._normalizeCenterLine();\n    }\n    this.drawShape();\n  }\n\n  /**\n   * get control cursor\n   * @returns corsor\n   */\n  getCursor(index: number):Cursor {\n    const rotateMultiple = Math.round(this.rotation / (Math.PI / 4));\n    let cursor = Cursor.DEFAULT;\n    switch (rotateMultiple) {\n      case 0:\n      case 4:\n      case -4:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE;\n        }\n        break;\n      case 2:\n      case -2:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.NESW_RESIZE : Cursor.NWSE_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.EW_RESIZE : Cursor.NS_RESIZE;\n        }\n        break;\n      case 1:\n      case -3:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.NESW_RESIZE : Cursor.NWSE_RESIZE;\n        }\n        break;\n      case -1:\n      case 3:\n        if (index < 4) {\n          cursor = index % 2 === 0 ? Cursor.EW_RESIZE : Cursor.NS_RESIZE;\n        } else {\n          cursor = index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE;\n        }\n        break;\n      default:\n        break;\n    }\n    return cursor;\n  }\n\n  /**\n   * get 4 points based on the position and size\n   */\n  getPoints() {\n    const right = precise(this.x + this.width);\n    const bottom = precise(this.y + this.height);\n    return [\n      { x: this.x, y: this.y },\n      { x: right, y: this.y },\n      { x: right, y: bottom },\n      { x: this.x, y: bottom },\n    ];\n  }\n\n  /**\n   * get actual 4 points position\n   */\n  getRotatedPoints() {\n    const points = this.getPoints();\n    if (this.rotation !== 0) {\n      points.forEach((p) => {\n        const point = computeRotatedPosition(this.pivot, p, this.rotation);\n        p.x = precise(point.x);\n        p.y = precise(point.y);\n      });\n    }\n    return points;\n  }\n\n  /**\n   * snap to point\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point: Point, tolerance = 8) {\n    const t = tolerance / this.scale;\n\n    // bbox\n    const { x, y } = point;\n    const { left, right, top, bottom } = this.shapeBounds;\n    if (x < left - t || x > right + t || y < top - t || y > bottom + t) {\n      return null;\n    }\n\n    const points = this.getRotatedPoints();\n    // points\n    let nearestPoint: { x: number; y: number; } | undefined;\n    let d: number | undefined;\n    points.forEach((p) => {\n      const pointDistance = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);\n      if (pointDistance < t && (d === undefined || pointDistance < d)) {\n        d = pointDistance;\n        nearestPoint = p;\n      }\n    });\n    if (nearestPoint) {\n      return new Point(nearestPoint.x, nearestPoint.y);\n    }\n\n    // edges\n    const location = new Flatten.Point(x, y);\n    for (let i = 0; i < points.length; i += 1) {\n      const startPoint = new Flatten.Point(points[i].x, points[i].y);\n      const endPoint = new Flatten.Point(points[(i + 1) % 4].x, points[(i + 1) % 4].y);\n      const line = new Flatten.Segment(startPoint, endPoint);\n      const [distance, segment] = line.distanceTo(location);\n      if (distance < t) {\n        const { ps, pe } = segment;\n        const edgePoint = ps.equalTo(location) ? pe : ps;\n        return new Point(edgePoint.x, edgePoint.y);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * snap to rectangle edges\n   * @param point\n   * @param ctrlKey\n   * @param tolerance\n   */\n  snapToRectangle(point: Point, ctrlKey = false, tolerance = 8) {\n    if (!this._autoSnapEnabled || ctrlKey || this.rotation !== 0) {\n      return point;\n    }\n    return this.container instanceof Layer\n      ? this.container.snapToRectangle(point, tolerance / this.scale)\n      : Layer.prototype.snapToRectangle.call(this.app.stage, point, tolerance / this.scale);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}