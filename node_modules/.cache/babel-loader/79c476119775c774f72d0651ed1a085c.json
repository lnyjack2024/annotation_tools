{"ast":null,"code":"import { utils } from '@appen-china/easy-form';\nimport i18n from './locales';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const playMode = ['regionPlay', 'regionLoop', 'overallLoop'];\nexport const segmentType = {\n  overlap: 'Overlap',\n  speaking: 'Speaking',\n  noise: 'Noise'\n};\nexport const defaultColor = {\n  defaultAlpha: 0.5,\n  darkGray: '#2D2A34FF',\n  defaultGray: '#FFFFFF35',\n  defaultRed: '#FF0000FF',\n  defaultGreen: '#00FF00FF',\n  defaultWhite: '#FFFFFF99',\n  defaultBlue: '#0000FFFF'\n};\nexport const attributeType = {\n  segment: 'segment',\n  line: 'line'\n};\n\n/**\n * format in minutes:seconds:milliseconds, for example, 00:00:000\n * @param second\n * @returns {string}\n */\nexport const formatTimestamp = second => {\n  if (!second || isNaN(second)) {\n    return '00:00.000';\n  }\n  const arr = [];\n  arr.push(`${Math.floor(second / 60)}`.padStart(2, '0'));\n  second -= arr[0] * 60;\n  arr.push(`${Math.floor(second)}`.padStart(2, '0'));\n  second -= arr[1];\n  arr.push(second.toFixed(3).toString().slice(2));\n  return `${arr[0]}:${arr[1]}.${arr[2]}`; // arr.join(':');\n};\nexport const translate = word => i18n.translate(word);\nexport const shortText = (str = '', length = 18) => {\n  const text = Array.isArray(str) ? str.join(',') : str;\n  const len = strlen(text);\n  if (len > length) {\n    let strLen = 0;\n    let realLen = 0;\n    for (let i = 0; i < text.length; i += 1) {\n      const c = text.charCodeAt(i);\n      if (c >= 0x0001 && c <= 0x007e || c >= 0xff60 && c <= 0xff9f) {\n        realLen += 1;\n      } else {\n        realLen += 2;\n      }\n      if (realLen > length) {\n        break;\n      } else {\n        strLen += 1;\n      }\n    }\n    return `${text.substring(0, strLen)}...`;\n  }\n  return text;\n};\nexport const strlen = (str = '') => {\n  let len = 0;\n  for (let i = 0; i < str.length; i += 1) {\n    const c = str.charCodeAt(i);\n    if (c >= 0x0001 && c <= 0x007e || c >= 0xff60 && c <= 0xff9f) {\n      len += 1;\n    } else {\n      len += 2;\n    }\n  }\n  return len;\n};\nexport const tagType = {\n  tag: 'tag',\n  standalone: 'standalone'\n};\nexport const SegmentMode = {\n  continuous: 'continuous',\n  individual: 'individual'\n};\nexport const triggerForm = (config, values = {}) => {\n  const {\n    fields: configFields,\n    conditions = [],\n    effects = [],\n    rules = []\n  } = config;\n  const fields = (configFields || []).map(field => ({\n    ...field,\n    ...(values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n  const parsedValue = utils.parseFormFields(fields);\n  // trigger rule effects\n  const {\n    updatedValues: triggerValues,\n    updatedFields\n  } = rules.reduce((acc, curr) => utils.ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects), {\n    updatedFields: parsedValue.fields,\n    updatedValues: parsedValue.initialValues\n  });\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter(f => f.visible === false).forEach(f => {\n    if (f.name !== 'ef-ontology') {\n      updatedValues[f.name] = undefined;\n    }\n  });\n  return {\n    updatedValues,\n    updatedFields\n  };\n};\nexport const validateForm = (config, values = {}) => {\n  // trigger rule effects\n  const {\n    updatedFields\n  } = triggerForm(config, values);\n  const displayFields = updatedFields.filter(i => i.visible);\n  Object.keys(values).forEach(field => {\n    if (!displayFields.find(i => i.name === field)) {\n      // remove the key\n      delete values[field];\n    }\n  });\n  for (let i = 0; i < displayFields.length; i += 1) {\n    const field = displayFields[i];\n    const value = values[field.name];\n    if (field.required && (value === undefined || value === null || value === '')) {\n      return false;\n    }\n  }\n  return true;\n};\nexport const ValidDurationMode = {\n  attributes: 'attributes',\n  translations: 'translations'\n};\nexport const StyleConfigMode = {\n  segment: 'segment_attr',\n  line: 'line_attr'\n};\nexport const getConfigColor = (attributes = {}, groups = []) => {\n  let color = '';\n  for (let i = 0; i < groups.length; i += 1) {\n    const {\n      fill_color: fillColor,\n      attributes: condition\n    } = groups[i];\n    const isInclude = Object.keys(condition).every(key => {\n      var _ref;\n      return ((_ref = Array.isArray(attributes[key]) ? attributes[key].sort() : attributes[key]) === null || _ref === void 0 ? void 0 : _ref.toString()) === (Array.isArray(condition[key]) ? condition[key].sort() : condition[key]).toString();\n    });\n    if (isInclude) {\n      color = fillColor || '';\n    }\n  }\n  return color;\n};","map":{"version":3,"names":["utils","i18n","playMode","segmentType","overlap","speaking","noise","defaultColor","defaultAlpha","darkGray","defaultGray","defaultRed","defaultGreen","defaultWhite","defaultBlue","attributeType","segment","line","formatTimestamp","second","isNaN","arr","push","Math","floor","padStart","toFixed","toString","slice","translate","word","shortText","str","length","text","Array","isArray","join","len","strlen","strLen","realLen","i","c","charCodeAt","substring","tagType","tag","standalone","SegmentMode","continuous","individual","triggerForm","config","values","fields","configFields","conditions","effects","rules","map","field","name","undefined","defaultValue","parsedValue","parseFormFields","updatedValues","triggerValues","updatedFields","reduce","acc","curr","ruleTrigger","initialValues","filter","f","visible","forEach","validateForm","displayFields","Object","keys","find","value","required","ValidDurationMode","attributes","translations","StyleConfigMode","getConfigColor","groups","color","fill_color","fillColor","condition","isInclude","every","key","_ref","sort"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/constants.js"],"sourcesContent":["import { utils } from '@appen-china/easy-form';\nimport i18n from './locales';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const playMode = [\n  'regionPlay',\n  'regionLoop',\n  'overallLoop',\n];\nexport const segmentType = {\n  overlap: 'Overlap',\n  speaking: 'Speaking',\n  noise: 'Noise',\n};\nexport const defaultColor = {\n  defaultAlpha: 0.5,\n  darkGray: '#2D2A34FF',\n  defaultGray: '#FFFFFF35',\n  defaultRed: '#FF0000FF',\n  defaultGreen: '#00FF00FF',\n  defaultWhite: '#FFFFFF99',\n  defaultBlue: '#0000FFFF',\n};\nexport const attributeType = {\n  segment: 'segment',\n  line: 'line',\n};\n\n/**\n * format in minutes:seconds:milliseconds, for example, 00:00:000\n * @param second\n * @returns {string}\n */\nexport const formatTimestamp = (second) => {\n  if (!second || isNaN(second)) {\n    return '00:00.000';\n  }\n  const arr = [];\n  arr.push(`${Math.floor(second / 60)}`.padStart(2, '0'));\n  second -= arr[0] * 60;\n  arr.push(`${Math.floor(second)}`.padStart(2, '0'));\n  second -= arr[1];\n  arr.push(second.toFixed(3).toString().slice(2));\n  return `${arr[0]}:${arr[1]}.${arr[2]}`; // arr.join(':');\n};\n\nexport const translate = (word) => i18n.translate(word);\n\nexport const shortText = (str = '', length = 18) => {\n  const text = Array.isArray(str) ? str.join(',') : str;\n  const len = strlen(text);\n  if (len > length) {\n    let strLen = 0;\n    let realLen = 0;\n    for (let i = 0; i < text.length; i += 1) {\n      const c = text.charCodeAt(i);\n      if ((c >= 0x0001 && c <= 0x007e) || (c >= 0xff60 && c <= 0xff9f)) {\n        realLen += 1;\n      } else {\n        realLen += 2;\n      }\n      if (realLen > length) {\n        break;\n      } else {\n        strLen += 1;\n      }\n    }\n    return `${text.substring(0, strLen)}...`;\n  }\n  return text;\n};\n\nexport const strlen = (str = '') => {\n  let len = 0;\n  for (let i = 0; i < str.length; i += 1) {\n    const c = str.charCodeAt(i);\n    if ((c >= 0x0001 && c <= 0x007e) || (c >= 0xff60 && c <= 0xff9f)) {\n      len += 1;\n    } else {\n      len += 2;\n    }\n  }\n  return len;\n};\n\nexport const tagType = {\n  tag: 'tag',\n  standalone: 'standalone',\n};\n\nexport const SegmentMode = {\n  continuous: 'continuous',\n  individual: 'individual',\n};\n\nexport const triggerForm = (config, values = {}) => {\n  const { fields: configFields, conditions = [], effects = [], rules = [] } = config;\n  const fields = (configFields || []).map((field) => ({\n    ...field,\n    ...values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n\n  const parsedValue = utils.parseFormFields(fields);\n  // trigger rule effects\n  const { updatedValues: triggerValues, updatedFields } = rules.reduce(\n    (acc, curr) => utils.ruleTrigger(\n      curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects,\n    ),\n    { updatedFields: parsedValue.fields, updatedValues: parsedValue.initialValues },\n  );\n\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter((f) => f.visible === false).forEach((f) => {\n    if (f.name !== 'ef-ontology') {\n      updatedValues[f.name] = undefined;\n    }\n  });\n  return {\n    updatedValues,\n    updatedFields,\n  };\n};\n\nexport const validateForm = (config, values = {}) => {\n  // trigger rule effects\n  const { updatedFields } = triggerForm(config, values);\n\n  const displayFields = updatedFields.filter((i) => i.visible);\n\n  Object.keys(values).forEach((field) => {\n    if (!displayFields.find((i) => i.name === field)) {\n      // remove the key\n      delete values[field];\n    }\n  });\n\n  for (let i = 0; i < displayFields.length; i += 1) {\n    const field = displayFields[i];\n    const value = values[field.name];\n    if (field.required && (value === undefined || value === null || value === '')) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const ValidDurationMode = {\n  attributes: 'attributes',\n  translations: 'translations',\n};\n\nexport const StyleConfigMode = {\n  segment: 'segment_attr',\n  line: 'line_attr',\n};\n\nexport const getConfigColor = (attributes = {}, groups = []) => {\n  let color = '';\n  for (let i = 0; i < groups.length; i += 1) {\n    const { fill_color: fillColor, attributes: condition } = groups[i];\n    const isInclude = Object.keys(condition).every((key) => (Array.isArray(attributes[key]) ? attributes[key].sort() : attributes[key])?.toString()\n      ===\n      (Array.isArray(condition[key]) ? condition[key].sort() : condition[key]).toString());\n    if (isInclude) {\n      color = fillColor || '';\n    }\n  }\n  return color;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}