{"ast":null,"code":"import { Base64 } from 'js-base64';\nimport { isAnnotationReadonly, isReviewEditable, TOOL_MODE } from '../utils/tool-mode';\nimport { fetchResultByUrl } from '../utils';\nexport default class JobProxy {\n  constructor({\n    toolName,\n    toolMode,\n    jobId,\n    taskId,\n    recordId,\n    reviewUrl,\n    reviewFrom,\n    auditId,\n    saveContent,\n    loadContent\n  }) {\n    this.toolName = '';\n    this.toolMode = TOOL_MODE.LABELING;\n    this.jobId = '';\n    this.taskId = '';\n    this.recordId = '';\n    this.reviewUrl = '';\n    this.reviewFrom = '' || {} || undefined;\n    this.savedDataLoadError = false;\n    this.auditId = '';\n    this.auditDirectory = 'audit';\n    // folder to persis audits in a flow\n    this.saveContent = void 0;\n    this.loadContent = void 0;\n    this.saveFile = file => new Promise((resolve, reject) => {\n      if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n        reject('No saveContent function specified');\n      }\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = async () => {\n        const base64Str = reader.result;\n        const url = await this.saveContent(base64Str, file.type, `${Date.now()}.${file.name}`, this.jobId);\n        if (url) {\n          resolve(url);\n        } else {\n          reject();\n        }\n      };\n      reader.onerror = e => reject(e);\n    });\n    // annotation type, unique key for the processor\n    this.toolName = toolName;\n    this.setMode(toolMode);\n    this.setJobInfo(jobId, taskId, recordId);\n    this.setReviewUrl(reviewUrl);\n    this.setAuditId(auditId);\n\n    // saveContent & loadContent is provided by the platform\n    // if no these two functions, load & save reviews should be implemented by each tool self\n    this.saveContent = saveContent;\n    this.loadContent = loadContent;\n    this.reviewFrom = reviewFrom;\n  }\n  setMode(toolMode) {\n    if (Object.values(TOOL_MODE).includes(toolMode)) {\n      this.toolMode = toolMode;\n    } else {\n      // default is a labeling job\n      this.toolMode = TOOL_MODE.LABELING;\n    }\n  }\n  setJobInfo(jobId, taskId, recordId) {\n    this.jobId = jobId || `${this.toolName}_job`;\n    this.taskId = taskId || `${this.toolName}_task`;\n    this.recordId = recordId || `${this.toolName}_record`;\n  }\n  setReviewUrl(reviewUrl) {\n    this.reviewUrl = reviewUrl || '';\n  }\n  setAuditId(auditId) {\n    this.auditId = auditId || `${this.jobId}.${this.recordId}.audit`;\n  }\n  get reviewId() {\n    return `${this.jobId}.${this.taskId}.${this.recordId}.review`;\n  }\n  get resultId() {\n    return `${this.jobId}.${this.taskId}.${this.recordId}.result`;\n  }\n  get reviewFileName() {\n    return `${this.reviewId}.json`;\n  }\n  get auditFileName() {\n    return `${this.auditId}.json`;\n  }\n  get resultFileName() {\n    return `${this.resultId}.json`;\n  }\n  get resultStatFileName() {\n    return `${this.resultId}.stat.json`;\n  }\n  get reviewStatFileName() {\n    return `${this.reviewId}.stat.json`;\n  }\n  async load(filename, directory = this.jobId, onLoadError) {\n    if (!this.loadContent || {}.toString.call(this.loadContent) !== '[object Function]') {\n      throw new Error('No loadContent function specified');\n    }\n    let res;\n    let data;\n    try {\n      res = await this.loadContent(filename, directory);\n    } catch (e) {\n      // load error\n      if (onLoadError) {\n        onLoadError();\n      }\n    }\n    if (res) {\n      try {\n        data = JSON.parse(res);\n      } catch (e) {\n        // parse error\n      }\n    }\n    return data;\n  }\n  async loadSavedReviews() {\n    if (!isReviewEditable(this.toolMode)) {\n      // not load temp saved reviews when is not reviewable\n      return undefined;\n    }\n    return this.load(this.reviewFileName);\n  }\n  async loadReviewsFromAudit() {\n    return this.load(this.auditFileName, this.auditDirectory);\n  }\n  async loadReviewsFromReview(reviewUrl) {\n    let reviews;\n    if (this.toolMode !== TOOL_MODE.AUDIT) {\n      try {\n        reviews = await fetchResultByUrl(reviewUrl);\n      } catch (e) {\n        // get from review url error\n      }\n    }\n    return reviews;\n  }\n  async loadReviews(reviewUrl) {\n    // get temp saved reviews\n    let reviews = await this.loadSavedReviews();\n    const url = reviewUrl || this.reviewUrl;\n    if (!reviews && url) {\n      // get from review url first\n      reviews = await this.loadReviewsFromReview(url);\n    }\n    if (!reviews) {\n      // then get from audit if necessary\n      reviews = await this.loadReviewsFromAudit();\n    }\n    return reviews;\n  }\n  async saveReviews(data) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n    const {\n      filename,\n      directory\n    } = this.toolMode === TOOL_MODE.AUDIT ? {\n      filename: this.auditFileName,\n      directory: this.auditDirectory\n    } : {\n      filename: this.reviewFileName,\n      directory: this.jobId\n    };\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', filename, directory);\n  }\n  loadSavedResult() {\n    if (isAnnotationReadonly(this.toolMode)) {\n      // not load temp saved annotation when is readonly\n      return undefined;\n    }\n    this.savedDataLoadError = false;\n    return this.load(this.resultFileName, this.jobId, () => {\n      this.savedDataLoadError = true;\n      // eslint-disable-next-line no-console\n      console.log('Temp saved data load error');\n    });\n  }\n  async loadReviewFrom() {\n    let result;\n    if (typeof this.reviewFrom === 'object') {\n      result = this.reviewFrom;\n    } else if (typeof this.reviewFrom === 'string' && this.reviewFrom !== '') {\n      if (this.reviewFrom.startsWith('http')) {\n        result = await fetchResultByUrl(this.reviewFrom);\n      } else {\n        result = JSON.parse(this.reviewFrom);\n      }\n    }\n    return result;\n  }\n  async loadResult() {\n    // get temp saved annotations\n    let result = await this.loadSavedResult();\n\n    // get result from review_from\n    if (!result) {\n      result = await this.loadReviewFrom();\n    }\n    return result;\n  }\n  async saveResult(data, isSubmit = false) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', `${isSubmit ? `R.${new Date().getTime()}.` : ''}${this.resultFileName}`, this.jobId);\n  }\n  async saveResultStat(data) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', this.resultStatFileName, this.jobId);\n  }\n  async saveReviewStat(data) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', this.reviewStatFileName, this.jobId);\n  }\n}","map":{"version":3,"names":["Base64","isAnnotationReadonly","isReviewEditable","TOOL_MODE","fetchResultByUrl","JobProxy","constructor","toolName","toolMode","jobId","taskId","recordId","reviewUrl","reviewFrom","auditId","saveContent","loadContent","LABELING","undefined","savedDataLoadError","auditDirectory","saveFile","file","Promise","resolve","reject","toString","call","reader","FileReader","readAsDataURL","onload","base64Str","result","url","type","Date","now","name","onerror","e","setMode","setJobInfo","setReviewUrl","setAuditId","Object","values","includes","reviewId","resultId","reviewFileName","auditFileName","resultFileName","resultStatFileName","reviewStatFileName","load","filename","directory","onLoadError","Error","res","data","JSON","parse","loadSavedReviews","loadReviewsFromAudit","loadReviewsFromReview","reviews","AUDIT","loadReviews","saveReviews","encode","stringify","loadSavedResult","console","log","loadReviewFrom","startsWith","loadResult","saveResult","isSubmit","getTime","saveResultStat","saveReviewStat"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/libs/JobProxy.ts"],"sourcesContent":["import { Base64 } from 'js-base64';\nimport { AnnotationType } from '../types';\nimport { isAnnotationReadonly, isReviewEditable, TOOL_MODE } from '../utils/tool-mode';\nimport { fetchResultByUrl } from '../utils';\n\ninterface JobProxyParams {\n  toolName: AnnotationType;\n  toolMode?: string;\n  jobId?: string;\n  taskId?: string;\n  recordId?: string;\n  reviewUrl?: string;\n  reviewFrom?: any;\n  auditId?: string;\n  saveContent?: (binary: string, type: string, filename: string, jobId: string) => Promise<string>;\n  loadContent?: (filename: string, jobId: string) => Promise<string>;\n}\n\nexport default class JobProxy {\n  toolName = '';\n\n  toolMode = TOOL_MODE.LABELING;\n\n  jobId = '';\n\n  taskId = '';\n\n  recordId = '';\n\n  reviewUrl = '';\n\n  reviewFrom = '' || {} || undefined;\n\n  savedDataLoadError = false;\n\n  auditId = '';\n\n  auditDirectory = 'audit'; // folder to persis audits in a flow\n\n  saveContent: ((binary: string, type: string, filename: string, jobId: string) => Promise<string>) | undefined;\n\n  loadContent: ((filename: string, jobId: string) => Promise<string>) | undefined;\n\n  constructor({ toolName, toolMode, jobId, taskId, recordId, reviewUrl, reviewFrom, auditId, saveContent, loadContent }: JobProxyParams) {\n    // annotation type, unique key for the processor\n    this.toolName = toolName;\n\n    this.setMode(toolMode);\n    this.setJobInfo(jobId, taskId, recordId);\n    this.setReviewUrl(reviewUrl);\n    this.setAuditId(auditId);\n\n    // saveContent & loadContent is provided by the platform\n    // if no these two functions, load & save reviews should be implemented by each tool self\n    this.saveContent = saveContent;\n    this.loadContent = loadContent;\n\n    this.reviewFrom = reviewFrom;\n  }\n\n  setMode(toolMode?: string) {\n    if (Object.values(TOOL_MODE).includes(toolMode as TOOL_MODE)) {\n      this.toolMode = toolMode as TOOL_MODE;\n    } else {\n      // default is a labeling job\n      this.toolMode = TOOL_MODE.LABELING;\n    }\n  }\n\n  setJobInfo(jobId?: string, taskId?: string, recordId?: string) {\n    this.jobId = jobId || `${this.toolName}_job`;\n    this.taskId = taskId || `${this.toolName}_task`;\n    this.recordId = recordId || `${this.toolName}_record`;\n  }\n\n  setReviewUrl(reviewUrl?: string) {\n    this.reviewUrl = reviewUrl || '';\n  }\n\n  setAuditId(auditId?: string) {\n    this.auditId = auditId || `${this.jobId}.${this.recordId}.audit`;\n  }\n\n  get reviewId() {\n    return `${this.jobId}.${this.taskId}.${this.recordId}.review`;\n  }\n\n  get resultId() {\n    return `${this.jobId}.${this.taskId}.${this.recordId}.result`;\n  }\n\n  get reviewFileName() {\n    return `${this.reviewId}.json`;\n  }\n\n  get auditFileName() {\n    return `${this.auditId}.json`;\n  }\n\n  get resultFileName() {\n    return `${this.resultId}.json`;\n  }\n\n  get resultStatFileName() {\n    return `${this.resultId}.stat.json`;\n  }\n\n  get reviewStatFileName() {\n    return `${this.reviewId}.stat.json`;\n  }\n\n  private async load(filename: string, directory = this.jobId, onLoadError?: () => void) {\n    if (!this.loadContent || {}.toString.call(this.loadContent) !== '[object Function]') {\n      throw new Error('No loadContent function specified');\n    }\n\n    let res;\n    let data;\n    try {\n      res = await this.loadContent(filename, directory);\n    } catch (e) {\n      // load error\n      if (onLoadError) {\n        onLoadError();\n      }\n    }\n    if (res) {\n      try {\n        data = JSON.parse(res);\n      } catch (e) {\n        // parse error\n      }\n    }\n    return data;\n  }\n\n  private async loadSavedReviews() {\n    if (!isReviewEditable(this.toolMode)) {\n      // not load temp saved reviews when is not reviewable\n      return undefined;\n    }\n    return this.load(this.reviewFileName);\n  }\n\n  private async loadReviewsFromAudit() {\n    return this.load(this.auditFileName, this.auditDirectory);\n  }\n\n  private async loadReviewsFromReview(reviewUrl: string) {\n    let reviews;\n    if (this.toolMode !== TOOL_MODE.AUDIT) {\n      try {\n        reviews = await fetchResultByUrl(reviewUrl);\n      } catch (e) {\n        // get from review url error\n      }\n    }\n    return reviews;\n  }\n\n  async loadReviews(reviewUrl?: string) {\n    // get temp saved reviews\n    let reviews = await this.loadSavedReviews();\n    const url = reviewUrl || this.reviewUrl;\n    if (!reviews && url) {\n      // get from review url first\n      reviews = await this.loadReviewsFromReview(url);\n    }\n    if (!reviews) {\n      // then get from audit if necessary\n      reviews = await this.loadReviewsFromAudit();\n    }\n    return reviews;\n  }\n\n  async saveReviews(data: unknown) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n\n    const { filename, directory } = this.toolMode === TOOL_MODE.AUDIT ?\n      { filename: this.auditFileName, directory: this.auditDirectory } :\n      { filename: this.reviewFileName, directory: this.jobId };\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', filename, directory);\n  }\n\n  loadSavedResult() {\n    if (isAnnotationReadonly(this.toolMode)) {\n      // not load temp saved annotation when is readonly\n      return undefined;\n    }\n    this.savedDataLoadError = false\n    return this.load(this.resultFileName, this.jobId, () => {\n      this.savedDataLoadError = true;\n      // eslint-disable-next-line no-console\n      console.log('Temp saved data load error');\n    });\n  }\n\n  async loadReviewFrom() {\n    let result;\n    if (typeof this.reviewFrom === 'object') {\n      result = this.reviewFrom;\n    } else if (typeof this.reviewFrom === 'string' && this.reviewFrom !== '') {\n      if (this.reviewFrom.startsWith('http')) {\n        result = await fetchResultByUrl(this.reviewFrom);\n      } else {\n        result = JSON.parse(this.reviewFrom);\n      }\n    }\n    return result;\n  }\n\n  async loadResult() {\n    // get temp saved annotations\n    let result = await this.loadSavedResult();\n\n    // get result from review_from\n    if (!result) {\n      result = await this.loadReviewFrom();\n    }\n\n    return result;\n  }\n\n  async saveResult(data: unknown, isSubmit = false) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', `${isSubmit ? `R.${new Date().getTime()}.` : ''}${this.resultFileName}`, this.jobId);\n  }\n\n  async saveResultStat(data: unknown) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', this.resultStatFileName, this.jobId);\n  }\n\n  async saveReviewStat(data: unknown) {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      throw new Error('No saveContent function specified');\n    }\n    return this.saveContent(Base64.encode(JSON.stringify(data)), 'text/plain', this.reviewStatFileName, this.jobId);\n  }\n\n  saveFile = (file: File) => new Promise<string>((resolve, reject) => {\n    if (!this.saveContent || {}.toString.call(this.saveContent) !== '[object Function]') {\n      reject('No saveContent function specified');\n    }\n\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = async () => {\n      const base64Str = reader.result as string;\n      const url = await this.saveContent!(base64Str, file.type, `${Date.now()}.${file.name}`, this.jobId);\n      if (url) {\n        resolve(url);\n      } else {\n        reject();\n      }\n    };\n    reader.onerror = (e) => reject(e);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}