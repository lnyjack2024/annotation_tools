{"ast":null,"code":"import { notification } from 'antd';\nimport { Base64 } from 'js-base64';\nimport { utils as formUtils } from '@appen-china/easy-form';\nimport { FieldControlType, Mode } from '@appen-china/easy-form/es/types';\nimport store from '../store/RootStore';\nimport i18n from '../locales';\nimport Crunker from './crunker';\nimport { runCustomValidation } from '../../../utils';\nimport { ValidationType, TagType } from '../types';\nimport WavDecoder from './wav-decoder';\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result, ontology) {\n  return result.map(instance => {\n    const {\n      channelIndex\n    } = instance;\n    const newCategory = ontology[channelIndex];\n    return {\n      ...instance,\n      category: (newCategory === null || newCategory === void 0 ? void 0 : newCategory.class_name) || `${channelIndex + 1}`,\n      label: (newCategory === null || newCategory === void 0 ? void 0 : newCategory.display_name) || (newCategory === null || newCategory === void 0 ? void 0 : newCategory.class_name) || `${channelIndex + 1}`\n    };\n  });\n}\nexport function validate(customCheck, params) {\n  return new Promise(async resolve => {\n    const {\n      resultLink,\n      flowData\n    } = params;\n    const results = [];\n    let hasCustomError = false;\n    if (customCheck.length > 0) {\n      // custom check\n      const customResult = await runCustomValidation(customCheck, resultLink, flowData);\n      customResult.results.forEach(result => {\n        results.push({\n          ...result,\n          ...(result.info && result.info),\n          warningType: ValidationType.CUSTOM\n        });\n      });\n      hasCustomError = customResult.hasCustomError;\n    }\n    if (store.setting.scriptCheck) {\n      try {\n        var _store$jobProxy, _store$jobProxy$valid;\n        const validateResults = (await ((_store$jobProxy = store.jobProxy) === null || _store$jobProxy === void 0 ? void 0 : (_store$jobProxy$valid = _store$jobProxy.validateContent) === null || _store$jobProxy$valid === void 0 ? void 0 : _store$jobProxy$valid.call(_store$jobProxy, resultLink, flowData))) || [];\n        validateResults.forEach(result => {\n          var _result$data;\n          const out = JSON.parse((result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.out_str) || '{}');\n          if ((result === null || result === void 0 ? void 0 : result.status_code) === 200 && Array.isArray(out)) {\n            out.forEach(item => {\n              results.push({\n                id: item.id,\n                message: item.message,\n                frames: item.frames,\n                info: {\n                  ...item.info\n                },\n                blockSubmit: item.blockSubmit,\n                warningType: ValidationType.SCRIPT\n              });\n            });\n          } else {\n            hasCustomError = true;\n          }\n        });\n      } catch (error) {\n        hasCustomError = true;\n        console.log('script validation error', error);\n      }\n    }\n    resolve({\n      results,\n      hasCustomError\n    });\n  });\n}\n\n/* eslint-disable valid-jsdoc */\n/**\n * Returns the `requestAnimationFrame` function for the browser, or a shim with\n * `setTimeout` if the function is not found\n *\n * @return {function} Available `requestAnimationFrame` function for the browser\n */\nexport const requestAnimationFrame = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || (callback => setTimeout(callback, 1000 / 60))).bind(window);\nexport const cancelAnimationFrame = (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || (callback => clearTimeout(callback))).bind(window);\n\n/**\n * Create a function which will be called at the next requestAnimationFrame\n * cycle\n *\n * @param {function} func The function to call\n *\n * @return {func} The function wrapped within a requestAnimationFrame\n */\nexport function frame(func) {\n  return (...args) => requestAnimationFrame(() => func(...args));\n}\nexport const timeInterval = pxPerSec => {\n  let retVal = 1;\n  if (pxPerSec >= 1000) {\n    retVal = 0.01;\n  } else if (pxPerSec >= 500) {\n    retVal = 0.02;\n  } else if (pxPerSec >= 100) {\n    retVal = 0.1;\n  } else if (pxPerSec >= 50) {\n    retVal = 0.2;\n  } else if (pxPerSec >= 10) {\n    retVal = 1;\n  } else if (pxPerSec >= 5) {\n    retVal = 12;\n  } else if (pxPerSec >= 1) {\n    retVal = 24;\n  } else if (pxPerSec >= 0.5) {\n    retVal = 120;\n  } else if (pxPerSec >= 0.01) {\n    retVal = 600;\n  } else {\n    retVal = Math.ceil(1 / pxPerSec) * 60;\n  }\n  return retVal;\n};\nexport const formatTimeCallback = (secs, pxPerSec) => {\n  let seconds = Number(secs);\n  const minutes = Math.floor(seconds / 60);\n  seconds %= 60;\n\n  // fill up seconds with zeroes\n  let secondsStr = Math.round(seconds).toString();\n  if (pxPerSec >= 25 * 10) {\n    secondsStr = seconds.toFixed(3);\n  } else if (pxPerSec >= 25 * 1) {\n    secondsStr = seconds.toFixed(1);\n  }\n  secondsStr = seconds >= 10 ? secondsStr : `0${secondsStr}`;\n  return `${minutes || '00'}:${secondsStr}`;\n};\n\n/**\n * Apply a map of styles to an element\n *\n * @param {HTMLElement} el The element that the styles will be applied to\n * @param {Object} styles The map of propName: attribute, both are used as-is\n *\n * @return {HTMLElement} el\n */\nexport const setStyle = (el, styles) => {\n  Object.keys(styles).forEach(prop => {\n    if (el.style[prop] !== styles[prop]) {\n      el.style[prop] = styles[prop];\n    }\n  });\n  return el;\n};\n\n/**\n * parse config\n */\nexport function parseLabelConfig(configStr) {\n  if (configStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(configStr));\n      labelConfig.fields = parseFields(labelConfig);\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\nexport const verifyChannelForm = (config, attributes, channelName) => {\n  if (store.readonly) return {\n    result: true\n  };\n  const {\n    updatedValues,\n    updatedFields\n  } = triggerForm(config, attributes);\n  const index = updatedFields.findIndex(v => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  if (index < 0) {\n    return {\n      result: true,\n      data: updatedValues\n    };\n  }\n  const err = `${i18n.translate('DATA_ERROR_REQUIRED')}. Channel ${channelName}`;\n  return {\n    result: false,\n    error: err\n  };\n};\nexport const verifyCurrentForm = (config, instance, current) => {\n  if (store.readonly) return {\n    result: true\n  };\n  const {\n    updatedValues,\n    updatedFields\n  } = triggerForm(config, instance.attributes);\n  const index = updatedFields.findIndex(v => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  if (index < 0) return {\n    result: true,\n    data: updatedValues\n  };\n  const err = `${i18n.translate('DATA_ERROR_REQUIRED')} ${updatedFields[index].label}. Segment ${current + 1}`;\n  return {\n    result: false,\n    error: err\n  };\n};\nexport const triggerForm = (config, values = {}) => {\n  const {\n    fields: configFields,\n    conditions = [],\n    effects = [],\n    rules = []\n  } = config;\n  const fields = (configFields || []).map(field => ({\n    ...field,\n    ...(values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n  const parsedValue = formUtils.parseFormFields(fields);\n  // trigger rule effects\n  const {\n    updatedValues: triggerValues,\n    updatedFields\n  } = rules.reduce((acc, curr) => formUtils.ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects), {\n    updatedFields: parsedValue.fields,\n    updatedValues: parsedValue.initialValues\n  });\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter(f => f.visible === false).forEach(f => {\n    delete updatedValues[f.name];\n  });\n  return {\n    updatedValues,\n    updatedFields\n  };\n};\n\n/**\n * parse fields (with options)\n * @param config\n */\nexport function parseFields(config) {\n  return ((config === null || config === void 0 ? void 0 : config.fields) || []).map(field => {\n    const {\n      type,\n      valueType,\n      options = []\n    } = field;\n    const newField = {\n      ...field\n    };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    return newField;\n  });\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFieldMap(config) {\n  const map = {};\n  ((config === null || config === void 0 ? void 0 : config.fields) || []).forEach(field => {\n    const {\n      name,\n      label,\n      type,\n      valueType,\n      options = []\n    } = field;\n    const newField = {\n      name,\n      type,\n      label\n    };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * generate fields config\n * @param fields\n * @param attributes\n */\nexport function generateFieldsConfig(fields, attributes) {\n  let config = [];\n  const newFields = fields && fields.map(field => {\n    const tempField = {\n      ...field\n    };\n    if ((field === null || field === void 0 ? void 0 : field.type) === FieldControlType.RADIO) {\n      tempField.type = FieldControlType.SELECT;\n    }\n    if ((field === null || field === void 0 ? void 0 : field.type) === FieldControlType.CHECKBOX) {\n      tempField.type = FieldControlType.SELECT;\n      tempField.mode = Mode.MULTIPLE;\n    }\n    return tempField;\n  });\n  config = setInitialValues(newFields || [], attributes);\n  return config;\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields, values) {\n  return fields.map(field => ({\n    ...field,\n    ...(values && values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n}\nexport const fittingString = (_ctx, _str, maxWidth) => {\n  let str = _str;\n  let strWidth = _ctx.measureText(str).width;\n  const ellipsis = '…';\n  const ellipsisWidth = _ctx.measureText(ellipsis).width;\n  if (strWidth + ellipsisWidth <= maxWidth) {\n    return str;\n  }\n  let len = str.length;\n  while (strWidth + ellipsisWidth >= maxWidth && len > 0) {\n    str = str.slice(0, len);\n    strWidth = _ctx.measureText(str).width;\n    len -= 1;\n  }\n  return str + ellipsis;\n};\nexport const drawRoundedRect = (rect, r, ctx) => {\n  const ptA = {\n    x: rect.x + r,\n    y: rect.y\n  };\n  const ptB = {\n    x: rect.x + rect.width,\n    y: rect.y\n  };\n  const ptC = {\n    x: rect.x + rect.width,\n    y: rect.y + rect.height\n  };\n  const ptD = {\n    x: rect.x,\n    y: rect.y + rect.height\n  };\n  const ptE = {\n    x: rect.x,\n    y: rect.y\n  };\n  ctx.beginPath();\n  ctx.moveTo(ptA.x, ptA.y);\n  ctx.arcTo(ptB.x, ptB.y, ptC.x, ptC.y, r);\n  ctx.arcTo(ptC.x, ptC.y, ptD.x, ptD.y, r);\n  ctx.arcTo(ptD.x, ptD.y, ptE.x, ptE.y, r);\n  ctx.arcTo(ptE.x, ptE.y, ptA.x, ptA.y, r);\n  ctx.closePath();\n  ctx.fill();\n};\nexport const verifyForm = (config, attributes = {}) => {\n  if (store.readonly) return {\n    result: true\n  };\n  const {\n    updatedValues,\n    updatedFields\n  } = triggerForm(config, attributes);\n  const index = updatedFields.findIndex(v => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  return {\n    result: index < 0,\n    data: updatedValues\n  };\n};\nexport const wrapText = (ctx, text, x, sy, align, color, fontSize) => {\n  if (ctx) {\n    ctx.textAlign = align;\n    ctx.font = `${(fontSize || 12) * window.devicePixelRatio}px sans-serif`;\n    ctx.fillStyle = color || '#363B44';\n    ctx.fillText(text, x, sy);\n    ctx.stroke();\n  }\n};\nexport const bufferToWave = (audioBuffer, offset, len) => {\n  const numOfChan = audioBuffer.numberOfChannels;\n  const length = len * numOfChan * 2 + 44;\n  const buffer = new ArrayBuffer(length);\n  const view = new DataView(buffer);\n  const channels = [];\n  let i = 0;\n  let sample;\n  let pos = 0;\n\n  // write WAVE header\n  setUint32(0x46464952); // \"RIFF\"\n  setUint32(length - 8); // file length - 8\n  setUint32(0x45564157); // \"WAVE\"\n\n  setUint32(0x20746d66); // \"fmt \" chunk\n  setUint32(16); // length = 16\n  setUint16(1); // PCM (uncompressed)\n  setUint16(numOfChan);\n  setUint32(audioBuffer.sampleRate);\n  setUint32(audioBuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n  setUint16(numOfChan * 2); // block-align\n  setUint16(16); // 16-bit (hardcoded in this demo)\n\n  setUint32(0x61746164); // \"data\" - chunk\n  setUint32(length - pos - 4); // chunk length\n\n  // write interleaved data\n  for (i = 0; i < audioBuffer.numberOfChannels; i += 1) {\n    channels.push(audioBuffer.getChannelData(i));\n  }\n  while (pos < length) {\n    for (i = 0; i < numOfChan; i += 1) {\n      // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n      // eslint-disable-next-line no-bitwise\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n      view.setInt16(pos, sample, true); // update data chunk\n      pos += 2;\n    }\n    offset += 1; // next source sample\n  }\n\n  // create Blob\n  return new Blob([buffer], {\n    type: 'audio/mpeg'\n  });\n  function setUint16(data) {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  }\n  function setUint32(data) {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  }\n};\nexport const parseTagGroup = data => {\n  try {\n    const tagGroup = parseLabelConfig(data) || [];\n    tagGroup.forEach(group => {\n      if (!group.tags) {\n        throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(group)}`);\n      }\n      if (group.type === TagType.TAG) {\n        group.tags.forEach(tag => {\n          if (typeof tag.prefix !== 'string' || typeof tag.suffix !== 'string') {\n            throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n        });\n      } else if (group.type === TagType.STANDALONE) {\n        group.tags.forEach(tag => {\n          if (typeof tag.text !== 'string') {\n            throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n        });\n      } else {\n        throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_TYPE')} ${group.type}`);\n      }\n    });\n    return tagGroup;\n  } catch (error) {\n    notification.error({\n      message: error.message\n    });\n    return [];\n  }\n};\nexport const mergeChannel = async waveBuffer => {\n  if (!waveBuffer) return null;\n  const buffers = [];\n  const {\n    numberOfChannels,\n    sampleRate,\n    length\n  } = waveBuffer;\n  if (numberOfChannels > 1) {\n    for (let i = 0; i < numberOfChannels; i += 1) {\n      const audioBuffer = new AudioBuffer({\n        numberOfChannels: 1,\n        sampleRate,\n        length\n      });\n      audioBuffer.copyToChannel(waveBuffer.getChannelData(i), 0);\n      buffers.push(audioBuffer);\n    }\n    const crunker = new Crunker({\n      sampleRate\n    });\n    return crunker.mergeAudio(buffers);\n  }\n  return waveBuffer;\n};\nexport const decodeAudioData = async (arrayBuffer, sampleRate, multi) => {\n  const audioCtx = new AudioContext({\n    sampleRate\n  });\n  const promiseArray = [];\n  const size = 128 * 1024;\n  const num = Math.ceil(arrayBuffer.byteLength / size);\n  let channelCount = 1;\n  let length = 0;\n  const channelDatas = [];\n  for (let i = 0; i < num; i += 1) {\n    // eslint-disable-next-line no-loop-func\n    const buffer = new Promise(resolve => {\n      audioCtx.decodeAudioData(arrayBuffer.slice(size * i, size * (i + 1)), audioBuffer => {\n        if (multi && i === 0) {\n          channelCount = audioBuffer.numberOfChannels;\n        }\n        length += audioBuffer.length;\n        channelDatas[i] = {\n          bufferLen: audioBuffer.length,\n          channels: new Array(channelCount).fill(0).map((d, c) => audioBuffer.getChannelData(c))\n        };\n        resolve(true);\n      });\n    });\n    promiseArray.push(buffer);\n  }\n  await Promise.all(promiseArray);\n  const buffer = new AudioBuffer({\n    numberOfChannels: channelCount,\n    sampleRate,\n    length\n  });\n  for (let c = 0; c < channelCount; c += 1) {\n    const audioChannelBuffer = buffer.getChannelData(c);\n    let offset = 0;\n    for (let f = 0; f < channelDatas.length; f += 1) {\n      const {\n        bufferLen,\n        channels\n      } = channelDatas[f];\n      if (channels[c]) {\n        audioChannelBuffer.set(channels[c], offset);\n        offset += bufferLen;\n      }\n      delete channels[c];\n    }\n  }\n  return buffer;\n};\nexport const decodeWavData = arrayBuffer => {\n  const decodeData = WavDecoder.decodeSync(arrayBuffer);\n  const audioBuffer = new AudioBuffer({\n    numberOfChannels: decodeData.numberOfChannels,\n    sampleRate: decodeData.sampleRate,\n    length: decodeData.length\n  });\n  for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n    const audioChannelBuffer = audioBuffer.getChannelData(i);\n    for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n      audioChannelBuffer[j] = decodeData.channelData[i][j];\n    }\n  }\n  return audioBuffer;\n};\nexport const numberFixed = (num, fractionDigits) => num % 1 !== 0 ? num.toFixed(fractionDigits) : num;\nexport function loadAudioChunk(url, start, end) {\n  return new Promise(resolve => {\n    fetch(url, {\n      headers: {\n        Range: `bytes=${start}-${end}`\n      }\n    }).then(response => {\n      resolve(response.arrayBuffer());\n    }).catch(error => {\n      console.log('load audio chunk error===>', error);\n      resolve(null);\n    });\n  });\n}\n\n// 获取音频文件大小\nexport const getAudioFileSize = async url => {\n  const response = await fetch(url, {\n    method: 'HEAD'\n  });\n  const contentLength = response.headers.get('Content-Length');\n  return contentLength ? parseInt(contentLength, 10) : null;\n};","map":{"version":3,"names":["notification","Base64","utils","formUtils","FieldControlType","Mode","store","i18n","Crunker","runCustomValidation","ValidationType","TagType","WavDecoder","loadInstancesFromResult","result","ontology","map","instance","channelIndex","newCategory","category","class_name","label","display_name","validate","customCheck","params","Promise","resolve","resultLink","flowData","results","hasCustomError","length","customResult","forEach","push","info","warningType","CUSTOM","setting","scriptCheck","_store$jobProxy","_store$jobProxy$valid","validateResults","jobProxy","validateContent","call","_result$data","out","JSON","parse","data","out_str","status_code","Array","isArray","item","id","message","frames","blockSubmit","SCRIPT","error","console","log","requestAnimationFrame","window","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","callback","setTimeout","bind","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","clearTimeout","frame","func","args","timeInterval","pxPerSec","retVal","Math","ceil","formatTimeCallback","secs","seconds","Number","minutes","floor","secondsStr","round","toString","toFixed","setStyle","el","styles","Object","keys","prop","style","parseLabelConfig","configStr","labelConfig","decode","fields","parseFields","e","undefined","verifyChannelForm","config","attributes","channelName","readonly","updatedValues","updatedFields","triggerForm","index","findIndex","v","required","visible","defaultValue","err","translate","verifyCurrentForm","current","values","configFields","conditions","effects","rules","field","name","parsedValue","parseFormFields","triggerValues","reduce","acc","curr","ruleTrigger","initialValues","filter","f","type","valueType","options","newField","RADIO","SELECT","CHECKBOX","CASCADER","parseOptions","parseFieldMap","generateFieldsConfig","newFields","tempField","mode","MULTIPLE","setInitialValues","fittingString","_ctx","_str","maxWidth","str","strWidth","measureText","width","ellipsis","ellipsisWidth","len","slice","drawRoundedRect","rect","r","ctx","ptA","x","y","ptB","ptC","height","ptD","ptE","beginPath","moveTo","arcTo","closePath","fill","verifyForm","wrapText","text","sy","align","color","fontSize","textAlign","font","devicePixelRatio","fillStyle","fillText","stroke","bufferToWave","audioBuffer","offset","numOfChan","numberOfChannels","buffer","ArrayBuffer","view","DataView","channels","i","sample","pos","setUint32","setUint16","sampleRate","getChannelData","max","min","setInt16","Blob","parseTagGroup","tagGroup","group","tags","Error","stringify","TAG","tag","prefix","suffix","STANDALONE","mergeChannel","waveBuffer","buffers","AudioBuffer","copyToChannel","crunker","mergeAudio","decodeAudioData","arrayBuffer","multi","audioCtx","AudioContext","promiseArray","size","num","byteLength","channelCount","channelDatas","bufferLen","d","c","all","audioChannelBuffer","set","decodeWavData","decodeData","decodeSync","j","channelData","numberFixed","fractionDigits","loadAudioChunk","url","start","end","fetch","headers","Range","then","response","catch","getAudioFileSize","method","contentLength","get","parseInt"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/utils/index.ts"],"sourcesContent":["import { notification } from 'antd';\nimport { Base64 } from 'js-base64';\nimport { utils as formUtils } from '@appen-china/easy-form';\nimport { FormConfig, FieldControlType, Field, Mode } from '@appen-china/easy-form/es/types';\nimport store from '../store/RootStore';\nimport i18n from '../locales';\nimport Crunker from './crunker';\nimport { runCustomValidation } from '../../../utils';\nimport { ValidationType, Instance, Ontology, TagGroup, TagType, Tag, Standalone, LabelConfig, FieldConfig, FormValue } from '../types';\nimport { IWarning } from '../../common/tabs-menu/Validator';\nimport WavDecoder from './wav-decoder';\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result: Instance[], ontology: Ontology[]) {\n  return result.map((instance) => {\n    const { channelIndex } = instance;\n    const newCategory = ontology[channelIndex];\n    return {\n      ...instance,\n      category: newCategory?.class_name || `${channelIndex + 1}`,\n      label: newCategory?.display_name || newCategory?.class_name || `${channelIndex + 1}`,\n    };\n  });\n}\n\nexport function validate(\n  customCheck: string[],\n  params: {\n    resultLink?: string;\n    flowData?: string;\n  },\n) {\n  return new Promise<{\n    results: IWarning[];\n    hasCustomError: boolean;\n  }>(async (resolve) => {\n    const { resultLink, flowData } = params;\n    const results: IWarning[] = [];\n    let hasCustomError = false;\n\n    if (customCheck.length > 0) {\n      // custom check\n      const customResult = await runCustomValidation(customCheck, resultLink!, flowData);\n      customResult.results.forEach((result) => {\n        results.push({ ...result, ...result.info && result.info, warningType: ValidationType.CUSTOM });\n      });\n      hasCustomError = customResult.hasCustomError;\n    }\n\n    if (store.setting.scriptCheck) {\n      try {\n        const validateResults = await store.jobProxy?.validateContent?.(resultLink!, flowData) || [];\n        validateResults.forEach((result: any) => {\n          const out = JSON.parse(result?.data?.out_str || '{}');\n          if (result?.status_code === 200 && Array.isArray(out)) {\n            out.forEach((item) => {\n              results.push({\n                id: item.id,\n                message: item.message,\n                frames: item.frames,\n                info: { ...item.info },\n                blockSubmit: item.blockSubmit,\n                warningType: ValidationType.SCRIPT,\n              });\n            });\n          } else {\n            hasCustomError = true;\n          }\n        });\n      } catch (error) {\n        hasCustomError = true;\n        console.log('script validation error', error);\n      }\n    }\n\n    resolve({ results, hasCustomError });\n  });\n}\n\n/* eslint-disable valid-jsdoc */\n/**\n * Returns the `requestAnimationFrame` function for the browser, or a shim with\n * `setTimeout` if the function is not found\n *\n * @return {function} Available `requestAnimationFrame` function for the browser\n */\nexport const requestAnimationFrame = (\n  window.requestAnimationFrame ||\n  (window as any).webkitRequestAnimationFrame ||\n  (window as any).mozRequestAnimationFrame ||\n  (window as any).oRequestAnimationFrame ||\n  (window as any).msRequestAnimationFrame ||\n  ((callback) => setTimeout(callback, 1000 / 60))\n).bind(window);\n\nexport const cancelAnimationFrame = (\n  window.cancelAnimationFrame ||\n  (window as any).webkitCancelAnimationFrame ||\n  (window as any).mozCancelAnimationFrame ||\n  (window as any).oCancelAnimationFrame ||\n  (window as any).msCancelAnimationFrame ||\n  ((callback) => clearTimeout(callback))\n).bind(window);\n\n/**\n * Create a function which will be called at the next requestAnimationFrame\n * cycle\n *\n * @param {function} func The function to call\n *\n * @return {func} The function wrapped within a requestAnimationFrame\n */\nexport function frame(func: any) {\n  return (...args: any) => requestAnimationFrame(() => func(...args));\n}\n\nexport const timeInterval = (pxPerSec: number) => {\n  let retVal = 1;\n  if (pxPerSec >= 1000) {\n    retVal = 0.01;\n  } else if (pxPerSec >= 500) {\n    retVal = 0.02;\n  } else if (pxPerSec >= 100) {\n    retVal = 0.1;\n  } else if (pxPerSec >= 50) {\n    retVal = 0.2;\n  } else if (pxPerSec >= 10) {\n    retVal = 1;\n  } else if (pxPerSec >= 5) {\n    retVal = 12;\n  } else if (pxPerSec >= 1) {\n    retVal = 24;\n  } else if (pxPerSec >= 0.5) {\n    retVal = 120;\n  } else if (pxPerSec >= 0.01) {\n    retVal = 600;\n  } else {\n    retVal = Math.ceil(1 / pxPerSec) * 60;\n  }\n  return retVal;\n};\n\nexport const formatTimeCallback = (secs: number, pxPerSec: number) => {\n  let seconds = Number(secs);\n  const minutes = Math.floor(seconds / 60);\n  seconds %= 60;\n\n  // fill up seconds with zeroes\n  let secondsStr = Math.round(seconds).toString();\n  if (pxPerSec >= 25 * 10) {\n    secondsStr = seconds.toFixed(3);\n  } else if (pxPerSec >= 25 * 1) {\n    secondsStr = seconds.toFixed(1);\n  }\n  secondsStr = seconds >= 10 ? secondsStr : `0${secondsStr}`;\n  return `${minutes || '00'}:${secondsStr}`;\n};\n\n/**\n * Apply a map of styles to an element\n *\n * @param {HTMLElement} el The element that the styles will be applied to\n * @param {Object} styles The map of propName: attribute, both are used as-is\n *\n * @return {HTMLElement} el\n */\nexport const setStyle = (el: HTMLElement, styles: {[key: string]: any}) => {\n  Object.keys(styles).forEach((prop) => {\n    if ((el.style as any)[prop] !== styles[prop]) {\n      (el.style as any)[prop] = styles[prop];\n    }\n  });\n  return el;\n};\n\n/**\n * parse config\n */\nexport function parseLabelConfig(configStr?: string) {\n  if (configStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(configStr));\n      labelConfig.fields = parseFields(labelConfig);\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\nexport const verifyChannelForm = (config: FormConfig, attributes: FormValue, channelName: string) => {\n  if (store.readonly) return { result: true };\n  const { updatedValues, updatedFields } = triggerForm(config, attributes);\n  const index = updatedFields.findIndex((v) => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  if (index < 0) {\n    return { result: true, data: updatedValues };\n  }\n  const err = `${i18n.translate('DATA_ERROR_REQUIRED')}. Channel ${channelName}`;\n  return { result: false, error: err };\n};\n\nexport const verifyCurrentForm = (config: FormConfig, instance: Instance, current: number) => {\n  if (store.readonly) return { result: true };\n  const { updatedValues, updatedFields } = triggerForm(config, instance.attributes);\n  const index = updatedFields.findIndex((v) => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  if (index < 0) return { result: true, data: updatedValues };\n  const err = `${i18n.translate('DATA_ERROR_REQUIRED')} ${updatedFields[index].label}. Segment ${current + 1}`;\n  return { result: false, error: err };\n};\n\nexport const triggerForm = (config: FormConfig, values:{[key: string]: any} = {}) => {\n  const { fields: configFields, conditions = [], effects = [], rules = [] } = config;\n  const fields = (configFields || []).map((field) => ({\n    ...field,\n    ...values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n\n  const parsedValue = formUtils.parseFormFields(fields);\n  // trigger rule effects\n  const { updatedValues: triggerValues, updatedFields } = rules.reduce(\n    (acc, curr) => formUtils.ruleTrigger(\n      curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects,\n    ),\n    { updatedFields: parsedValue.fields, updatedValues: parsedValue.initialValues },\n  );\n\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter((f) => f.visible === false).forEach((f) => {\n    delete updatedValues[f.name];\n  });\n  return {\n    updatedValues,\n    updatedFields,\n  };\n};\n\n/**\n * parse fields (with options)\n * @param config\n */\nexport function parseFields(config?: LabelConfig) {\n  return (config?.fields || []).map((field) => {\n    const { type, valueType, options = [] } = field;\n    const newField = { ...field };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    return newField;\n  });\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFieldMap(config?: LabelConfig) {\n  const map: { [fieldName: string]: FieldConfig } = {};\n  (config?.fields || []).forEach((field) => {\n    const { name, label, type, valueType, options = [] } = field;\n    const newField: FieldConfig = { name, type, label };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * generate fields config\n * @param fields\n * @param attributes\n */\nexport function generateFieldsConfig(fields: Field[], attributes: any) {\n  let config: Field[] = [];\n  const newFields = fields && fields.map((field) => {\n    const tempField = { ...field };\n    if (field?.type === FieldControlType.RADIO) {\n      tempField.type = FieldControlType.SELECT;\n    }\n    if (field?.type === FieldControlType.CHECKBOX) {\n      tempField.type = FieldControlType.SELECT;\n      tempField.mode = Mode.MULTIPLE;\n    }\n    return tempField;\n  });\n  config = setInitialValues(newFields || [], attributes);\n  return config;\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields: Field[], values: any) {\n  return fields.map((field) => ({\n    ...field,\n    ...values && values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n}\n\nexport const fittingString = (_ctx: CanvasRenderingContext2D, _str: string, maxWidth: number) => {\n  let str = _str;\n  let strWidth = _ctx.measureText(str).width;\n  const ellipsis = '…';\n  const ellipsisWidth = _ctx.measureText(ellipsis).width;\n  if ((strWidth + ellipsisWidth) <= maxWidth) {\n    return str;\n  }\n  let len = str.length;\n  while ((strWidth + ellipsisWidth) >= maxWidth && len > 0) {\n    str = str.slice(0, len);\n    strWidth = _ctx.measureText(str).width;\n    len -= 1;\n  }\n  return str + ellipsis;\n};\n\nexport const drawRoundedRect = (rect: { x: number, y: number, width: number, height: number }, r: number, ctx: CanvasRenderingContext2D) => {\n  const ptA = { x: rect.x + r, y: rect.y };\n  const ptB = { x: rect.x + rect.width, y: rect.y };\n  const ptC = { x: rect.x + rect.width, y: rect.y + rect.height };\n  const ptD = { x: rect.x, y: rect.y + rect.height };\n  const ptE = { x: rect.x, y: rect.y };\n  ctx.beginPath();\n  ctx.moveTo(ptA.x, ptA.y);\n  ctx.arcTo(ptB.x, ptB.y, ptC.x, ptC.y, r);\n  ctx.arcTo(ptC.x, ptC.y, ptD.x, ptD.y, r);\n  ctx.arcTo(ptD.x, ptD.y, ptE.x, ptE.y, r);\n  ctx.arcTo(ptE.x, ptE.y, ptA.x, ptA.y, r);\n  ctx.closePath();\n  ctx.fill();\n};\n\nexport const verifyForm = (config: FormConfig, attributes:{[key: string]: any} = {}) => {\n  if (store.readonly) return { result: true };\n  const { updatedValues, updatedFields } = triggerForm(config, attributes);\n  const index = updatedFields.findIndex((v) => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  return { result: index < 0, data: updatedValues };\n};\n\nexport const wrapText = (ctx: CanvasRenderingContext2D | null, text: string, x: number, sy: number, align: CanvasTextAlign, color?: string, fontSize?: number) => {\n  if (ctx) {\n    ctx.textAlign = align;\n    ctx.font = `${(fontSize || 12) * window.devicePixelRatio}px sans-serif`;\n    ctx.fillStyle = color || '#363B44';\n    ctx.fillText(text, x, sy);\n    ctx.stroke();\n  }\n};\n\nexport const bufferToWave = (audioBuffer: AudioBuffer, offset: number, len: number) => {\n  const numOfChan = audioBuffer.numberOfChannels;\n  const length = len * numOfChan * 2 + 44;\n  const buffer = new ArrayBuffer(length);\n  const view = new DataView(buffer);\n  const channels: Float32Array[] = [];\n  let i = 0; let sample;\n  let pos = 0;\n\n  // write WAVE header\n  setUint32(0x46464952); // \"RIFF\"\n  setUint32(length - 8); // file length - 8\n  setUint32(0x45564157); // \"WAVE\"\n\n  setUint32(0x20746d66); // \"fmt \" chunk\n  setUint32(16); // length = 16\n  setUint16(1); // PCM (uncompressed)\n  setUint16(numOfChan);\n  setUint32(audioBuffer.sampleRate);\n  setUint32(audioBuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n  setUint16(numOfChan * 2); // block-align\n  setUint16(16); // 16-bit (hardcoded in this demo)\n\n  setUint32(0x61746164); // \"data\" - chunk\n  setUint32(length - pos - 4); // chunk length\n\n  // write interleaved data\n  for (i = 0; i < audioBuffer.numberOfChannels; i += 1) { channels.push(audioBuffer.getChannelData(i)); }\n\n  while (pos < length) {\n    for (i = 0; i < numOfChan; i += 1) { // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n      // eslint-disable-next-line no-bitwise\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n      view.setInt16(pos, sample, true); // update data chunk\n      pos += 2;\n    }\n    offset += 1; // next source sample\n  }\n\n  // create Blob\n  return new Blob([buffer], { type: 'audio/mpeg' });\n\n  function setUint16(data: number) {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  }\n\n  function setUint32(data: number) {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  }\n};\n\nexport const parseTagGroup = (data: string) => {\n  try {\n    const tagGroup = (parseLabelConfig(data) || []) as TagGroup[];\n    tagGroup.forEach((group) => {\n      if (!group.tags) {\n        throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(group)}`);\n      }\n      if (group.type === TagType.TAG) {\n        (group.tags as Tag[]).forEach((tag) => {\n          if (typeof tag.prefix !== 'string' || typeof tag.suffix !== 'string') {\n            throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n        });\n      } else if (group.type === TagType.STANDALONE) {\n        (group.tags as Standalone[]).forEach((tag) => {\n          if (typeof tag.text !== 'string') {\n            throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n        });\n      } else {\n        throw new Error(`${i18n.translate('PAYLOAD_ERROR_INVALID_TAG_TYPE')} ${group.type}`);\n      }\n    });\n    return tagGroup;\n  } catch (error) {\n    notification.error({ message: (error as Error).message });\n    return [];\n  }\n};\n\nexport const mergeChannel = async (waveBuffer: AudioBuffer | null) => {\n  if (!waveBuffer) return null;\n  const buffers: AudioBuffer[] = [];\n  const { numberOfChannels, sampleRate, length } = waveBuffer;\n  if (numberOfChannels > 1) {\n    for (let i = 0; i < numberOfChannels; i += 1) {\n      const audioBuffer = new AudioBuffer({\n        numberOfChannels: 1,\n        sampleRate,\n        length,\n      });\n      audioBuffer.copyToChannel(waveBuffer.getChannelData(i), 0);\n      buffers.push(audioBuffer);\n    }\n    const crunker = new Crunker({ sampleRate });\n    return crunker.mergeAudio(buffers);\n  }\n  return waveBuffer;\n};\n\nexport const decodeAudioData = async (arrayBuffer: ArrayBuffer, sampleRate: number, multi?: boolean) => {\n  const audioCtx = new AudioContext({ sampleRate });\n  const promiseArray: Promise<unknown>[] = [];\n  const size = 128 * 1024;\n  const num = Math.ceil(arrayBuffer.byteLength / size);\n\n  let channelCount = 1;\n  let length = 0;\n  const channelDatas: { bufferLen: number; channels: Float32Array[] }[] = [];\n  for (let i = 0; i < num; i += 1) {\n    // eslint-disable-next-line no-loop-func\n    const buffer = new Promise((resolve) => {\n      audioCtx.decodeAudioData(\n        arrayBuffer.slice(size * i, size * (i + 1)),\n        (audioBuffer) => {\n          if (multi && i === 0) {\n            channelCount = audioBuffer.numberOfChannels;\n          }\n          length += audioBuffer.length;\n          channelDatas[i] = {\n            bufferLen: audioBuffer.length,\n            channels: new Array(channelCount).fill(0).map((d, c) => audioBuffer.getChannelData(c)),\n          };\n          resolve(true);\n        },\n      );\n    });\n    promiseArray.push(buffer);\n  }\n  await Promise.all(promiseArray);\n  const buffer = new AudioBuffer({\n    numberOfChannels: channelCount,\n    sampleRate,\n    length,\n  });\n  for (let c = 0; c < channelCount; c += 1) {\n    const audioChannelBuffer = buffer.getChannelData(c);\n    let offset = 0;\n    for (let f = 0; f < channelDatas.length; f += 1) {\n      const { bufferLen, channels } = channelDatas[f];\n      if (channels[c]) {\n        audioChannelBuffer.set(channels[c], offset);\n        offset += bufferLen;\n      }\n      delete channels[c];\n    }\n  }\n\n  return buffer;\n};\n\nexport const decodeWavData = (arrayBuffer: ArrayBuffer) => {\n  const decodeData = WavDecoder.decodeSync(arrayBuffer);\n  const audioBuffer = new AudioBuffer({\n    numberOfChannels: decodeData.numberOfChannels,\n    sampleRate: decodeData.sampleRate,\n    length: decodeData.length,\n  });\n  for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n    const audioChannelBuffer = audioBuffer.getChannelData(i);\n    for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n      audioChannelBuffer[j] = decodeData.channelData[i][j];\n    }\n  }\n  return audioBuffer;\n};\n\nexport const numberFixed = (num: number, fractionDigits?: number) => (num % 1 !== 0 ? num.toFixed(fractionDigits) : num);\n\nexport function loadAudioChunk(url: string, start: number, end: number) {\n  return new Promise<ArrayBuffer | null>((resolve) => {\n    fetch(url, {\n      headers: {\n        Range: `bytes=${start}-${end}`\n      }\n    })\n      .then((response) => {\n        resolve(response.arrayBuffer());\n      })\n      .catch((error) => {\n        console.log('load audio chunk error===>', error);\n        resolve(null);\n      });\n  });\n}\n\n// 获取音频文件大小\nexport const getAudioFileSize = async (url: string) => {\n  const response = await fetch(url, { method: 'HEAD' });\n  const contentLength = response.headers.get('Content-Length');\n  return contentLength ? parseInt(contentLength, 10) : null;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}