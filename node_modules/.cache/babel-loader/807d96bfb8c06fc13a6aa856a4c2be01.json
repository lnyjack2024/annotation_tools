{"ast":null,"code":"/* eslint-disable class-methods-use-this */\nimport EventEmitter from 'eventemitter3';\nimport { cloneDeep } from 'lodash';\nimport { drawLine, drawRect, drawRectBorder, drawRoundedRect, drawCircle, drawScale } from '../utils/canvas';\nimport Cursor from '../components/common/Cursor';\nexport let EventAction = /*#__PURE__*/function (EventAction) {\n  EventAction[\"HEIGHT_CHANGE\"] = \"height-change\";\n  EventAction[\"VISIBLE_FRAMES_UPDATE\"] = \"visible-frames-update\";\n  EventAction[\"CURRENT_FRAME_CHANGE\"] = \"current-frame-change\";\n  EventAction[\"ITEMS_OFFSET_CHANGE\"] = \"items-offset-change\";\n  return EventAction;\n}({});\nvar HoverType = /*#__PURE__*/function (HoverType) {\n  HoverType[\"SCROLLBAR_X\"] = \"scrollbarX\";\n  HoverType[\"SCROLLBAR_Y\"] = \"scrollbarY\";\n  HoverType[\"SCROLLBAR_Y_CONTAINER\"] = \"scrollbarYContainer\";\n  return HoverType;\n}(HoverType || {});\nconst rangeFramesSet = [1000, 500, 200, 100, 50, 20, 10, 5]; // set of supported frames per range\nconst scrollbarColor = '#777B82';\nexport default class FramesRenderer extends EventEmitter {\n  /**\n   * get scrollable\n   * @getter\n   */\n  get scrollable() {\n    return this._scrollable;\n  }\n\n  /**\n   * set scrollable\n   * @setter\n   */\n  set scrollable(scrollable) {\n    const shouldUpdate = this._scrollable !== scrollable;\n    this._scrollable = scrollable;\n    if (shouldUpdate) {\n      this.setupCanvas();\n    }\n  }\n\n  /**\n   * invalid frames\n   */\n\n  /**\n   * set invalid frames\n   * @setter\n   */\n  set invalidFrames(frames) {\n    this._invalidFrames = [...frames];\n    this.drawFrames();\n  }\n\n  /**\n   * frame items\n   * @private\n   */\n\n  /**\n   * get frame items\n   * @getter\n   */\n  get items() {\n    return this._items;\n  }\n\n  /**\n   * set frame items\n   * @setter\n   */\n  set items(items) {\n    const originItemsLen = Object.keys(this._items).length;\n    this._items = cloneDeep(items);\n    this._allItems = Object.keys(this._items).map((id, index) => ({\n      id,\n      index\n    }));\n    const height = Object.keys(this._items).length * this.itemHeight;\n    if (height > this.itemsContainerHeight && !this.scrollable) {\n      this._scrollable = true;\n      this.setupCanvas();\n    } else if (height <= this.itemsContainerHeight && this.scrollable && !this.fixHeight) {\n      this._scrollable = false;\n      this.setupCanvas();\n    }\n    if (originItemsLen !== Object.keys(items).length && !this.scrollable) {\n      // when items length changes, and not scrollable, need resize canvas and redraw\n      this.setupCanvas();\n    } else {\n      // just redraw\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * all items with id and actual index\n   * @private\n   */\n\n  /**\n   * get current frame\n   * @getter\n   */\n  get currentFrame() {\n    return this._currentFrame;\n  }\n  set currentFrame(frameIndex) {\n    const shouldUpdate = this._currentFrame !== frameIndex;\n    this._currentFrame = frameIndex;\n    if (shouldUpdate) {\n      this.focusFrame(frameIndex);\n    }\n  }\n\n  /**\n   * hovered frame index\n   * @private\n   */\n\n  /**\n   * get current range index\n   * @getter\n   */\n  get currentRangeIndex() {\n    return this._currentRangeIndex;\n  }\n\n  /**\n   * set current range index\n   * @setters\n   */\n  set currentRangeIndex(index) {\n    const rangeIndex = Math.min(Math.max(index, this._initialRangeIndex), rangeFramesSet.length - 1);\n    const shouldUpdate = this._currentRangeIndex !== rangeIndex;\n    this._currentRangeIndex = rangeIndex;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * current range start frame (used for drawing)\n   * @private\n   */\n\n  /**\n   * get items offset\n   * @getter\n   */\n  get itemsOffset() {\n    return this._itemsOffset;\n  }\n\n  /**\n   * set items offset\n   * @setter\n   */\n  set itemsOffset(o) {\n    const offset = o * window.devicePixelRatio;\n    const shouldUpdate = this._itemsOffset !== offset;\n    this._itemsOffset = offset;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * vertical scrollbar height\n   * @private\n   */\n\n  /**\n   * get item height\n   */\n  get itemHeight() {\n    return this._itemHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames height\n   * @private\n   */\n\n  /**\n   * get frames height\n   */\n  get framesHeight() {\n    return this._framesHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames scale enable\n   */\n\n  /**\n   * base range width\n   */\n  get baseRangeWidth() {\n    return 18 * 5 * window.devicePixelRatio;\n  }\n\n  /**\n   * canvas padding right\n   */\n  get paddingRight() {\n    return 18 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar height\n   */\n  get scrollbarXHeight() {\n    return 10 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar offset y (from frames container top)\n   */\n  get scrollbarXOffsetY() {\n    return 22 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar width\n   */\n  get scrollbarYWidth() {\n    return 10 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar offset x (from items container right)\n   */\n  get scrollbarYOffsetX() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block height\n   */\n  get itemBlockHeight() {\n    return 12 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block offset y (in the item container)\n   */\n  get itemBlockOffsetY() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item card height\n   */\n  get itemCardHeight() {\n    return 16 * window.devicePixelRatio;\n  }\n\n  /**\n   * items container height (when not collapsed)\n   */\n  get itemsContainerHeight() {\n    return 275 * window.devicePixelRatio;\n  }\n\n  /**\n   * frames container height\n   */\n  get itemsTotalHeight() {\n    if (this.scrollable) {\n      return this.itemsContainerHeight;\n    }\n    return Object.keys(this._items).length * this.itemHeight;\n  }\n\n  /**\n   * current range frames\n   */\n  get rangeFrames() {\n    return rangeFramesSet[this._currentRangeIndex];\n  }\n\n  /**\n   * current per frame width\n   */\n  get perFrameWidth() {\n    return this._currentRangeIndex <= this._initialRangeIndex ? (this.canvas.width - this.paddingRight) / this.frameCount : this.baseRangeWidth / this.rangeFrames;\n  }\n\n  /**\n   * current card width\n   */\n  get cardWidth() {\n    return this.perFrameWidth - this.cardOffsetX * 2;\n  }\n\n  /**\n   * card offset x (base on item)\n   */\n  get cardOffsetX() {\n    return 1 * window.devicePixelRatio;\n  }\n\n  /**\n   * card offset y (base on item)\n   */\n  get cardOffsetY() {\n    return (this.itemHeight - this.itemCardHeight) / 2;\n  }\n\n  /**\n   * constructor\n   * @param canvas\n   * @param frameCount\n   * @param options\n   */\n  constructor(container, frameCount, {\n    itemHeight,\n    framesHeight,\n    bgColor,\n    itemColor,\n    itemSelectedColor,\n    cardColor,\n    scaleEnabled,\n    fixHeight\n  } = {}) {\n    super();\n    /**\n     * canvas container\n     * @member\n     */\n    this.container = void 0;\n    /**\n     * canvas dom element\n     * @member\n     */\n    this.canvas = void 0;\n    /**\n     * frame tip element\n     * @member\n     */\n    this.frameTip = void 0;\n    /**\n     * frames count\n     * @member\n     */\n    this.frameCount = void 0;\n    /**\n     * frames background color\n     * @member\n     */\n    this.bgColor = void 0;\n    /**\n     * item default color\n     * @member\n     */\n    this.itemColor = void 0;\n    /**\n     * item selected color\n     * @member\n     */\n    this.itemSelectedColor = void 0;\n    /**\n     * card color\n     * @member\n     */\n    this.cardColor = void 0;\n    /**\n     * is frames container height fix\n     * @member\n     */\n    this.fixHeight = false;\n    /**\n     * scrollable\n     * @private\n     */\n    this._scrollable = false;\n    this._invalidFrames = [];\n    this._items = {};\n    this._allItems = [];\n    /**\n     * current frame index\n     * @private\n     */\n    this._currentFrame = 0;\n    this._hoveredFrame = -1;\n    /**\n     * hovered item index\n     * @private\n     */\n    this._hoveredItemIndex = -1;\n    /**\n     * initial calculated range index (largest frames per range)\n     * @private\n     */\n    this._initialRangeIndex = 0;\n    /**\n     * current range index in the rangeFramesSet\n     * @private\n     */\n    this._currentRangeIndex = 0;\n    this._currentRangeStart = 0;\n    /**\n     * current range start frame offset (used for drawing)\n     * @private\n     */\n    this._currentRangeStartOffset = 0;\n    /**\n     * current offset in canvas when zooming, dragging and so on\n     * @private\n     */\n    this._baseOffset = 0;\n    /**\n     * current offset frame index in canvas when zooming, dragging and so on\n     * @private\n     */\n    this._baseOffsetFrame = 0;\n    /**\n     * is mouse down on horizontal scrollbar\n     * @private\n     */\n    this._isScrollXDown = false;\n    /**\n     * base offset when mouse down on horizontal scrollbar\n     * @private\n     */\n    this._scrollXDownBaseOffsetFrame = 0;\n    /**\n     * client X when mouse down on horizontal scrollbar\n     * @private\n     */\n    this._scrollXDownClientX = 0;\n    /**\n     * horizontal scrollbar width\n     * @private\n     */\n    this._scrollXWidth = 0;\n    /**\n     * horizontal scrollbar offset\n     * @private\n     */\n    this._scrollXOffset = 0;\n    /**\n     * items offset\n     * @private\n     */\n    this._itemsOffset = 0;\n    this._scrollYHeight = 0;\n    /**\n     * vertical scrollbar offset\n     * @private\n     */\n    this._scrollYOffset = 0;\n    /**\n     * is mouse down on vertical scrollbar\n     * @private\n     */\n    this._isScrollYDown = false;\n    /**\n     * items offset when mouse down on vertical scrollbar\n     * @private\n     */\n    this._scrollYDownItemsOffset = 0;\n    /**\n     * client y when mouse down on vertical scrollbar\n     * @private\n     */\n    this._scrollYDownClientY = 0;\n    /**\n     * item height\n     * @private\n     */\n    this._itemHeight = 20;\n    this._framesHeight = 36;\n    this._scaleEnabled = true;\n    /**\n     * set up canvas size\n     */\n    this.setupCanvas = () => {\n      const {\n        width\n      } = this.canvas.getBoundingClientRect();\n      const originCanvasWidth = this.canvas.width;\n      this.canvas.width = width * window.devicePixelRatio;\n      this.canvas.height = this.itemsTotalHeight + this.framesHeight;\n      this.emit(EventAction.HEIGHT_CHANGE, this.canvas.height / window.devicePixelRatio);\n      this.setupRangeIndexes(originCanvasWidth !== this.canvas.width);\n      this.drawFrames();\n    };\n    /**\n     * mouse wheel\n     * @param e\n     */\n    this.wheel = e => {\n      if (e.altKey) {\n        this.zoom(e);\n      } else {\n        // scroll y\n        this.updateItemsScroll(this._itemsOffset + e.deltaY);\n      }\n    };\n    /**\n     * zooming\n     * @param e\n     */\n    this.zoom = e => {\n      const hover = this.getMouseHover(e.clientX, e.clientY);\n      if (hover === HoverType.SCROLLBAR_Y_CONTAINER || hover === HoverType.SCROLLBAR_Y) {\n        return;\n      }\n      // zoom to scale frames\n      const {\n        left\n      } = this.canvas.getBoundingClientRect();\n      this._baseOffset = (e.clientX - left) * window.devicePixelRatio;\n      this._baseOffsetFrame = this.getFrameByClientX(e.clientX);\n      if (e.deltaY > 0) {\n        this._currentRangeIndex += 1;\n      } else {\n        this._currentRangeIndex -= 1;\n      }\n      this._currentRangeIndex = Math.min(Math.max(this._currentRangeIndex, this._initialRangeIndex), rangeFramesSet.length - 1);\n      this.emit(EventAction.VISIBLE_FRAMES_UPDATE, this._currentRangeIndex, rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex));\n      this.drawFrames();\n      this.canvasMove(e);\n    };\n    /**\n     * mouse down on canvas\n     * @param e\n     */\n    this.canvasDown = e => {\n      const hover = this.getMouseHover(e.clientX, e.clientY);\n      if (hover === HoverType.SCROLLBAR_X) {\n        // click on horizontal scrollbar\n        this._isScrollXDown = true;\n        this._scrollXDownBaseOffsetFrame = this._baseOffsetFrame;\n        this._scrollXDownClientX = e.clientX;\n      } else if (hover === HoverType.SCROLLBAR_Y) {\n        // click on vertical scrollbar\n        this._isScrollYDown = true;\n        this._scrollYDownItemsOffset = this._itemsOffset;\n        this._scrollYDownClientY = e.clientY;\n      } else if (this._hoveredFrame >= 0) {\n        this.currentFrame = this._hoveredFrame;\n        this.emit(EventAction.CURRENT_FRAME_CHANGE, this._currentFrame, this._hoveredItemIndex);\n      }\n    };\n    /**\n     * mouse move on canvas\n     * @param e\n     */\n    this.canvasMove = e => {\n      this.setCursor(Cursor.DEFAULT);\n      const hover = this.getMouseHover(e.clientX, e.clientY);\n      if (hover === HoverType.SCROLLBAR_X) {\n        // hover on horizontal scrollbar\n        this.setCursor(Cursor.POINTER);\n      } else if (hover === HoverType.SCROLLBAR_Y) {\n        this.canvasLeave();\n        this.setCursor(Cursor.POINTER);\n      } else if (hover === HoverType.SCROLLBAR_Y_CONTAINER) {\n        this.canvasLeave();\n      } else {\n        this._hoveredFrame = this.getFrameByClientX(e.clientX);\n        this._hoveredItemIndex = this.getItemIndexByClientY(e.clientY);\n        this.drawFrames();\n        this.updateFrameTip();\n      }\n    };\n    /**\n     * mouse leave canvas\n     */\n    this.canvasLeave = () => {\n      this._hoveredFrame = -1;\n      this._hoveredItemIndex = -1;\n      this.drawFrames();\n      this.updateFrameTip();\n    };\n    /**\n     * mouse move on document (dragging scrollbar)\n     * @param e\n     */\n    this.cursorMove = e => {\n      if (this._isScrollXDown) {\n        // move horizontal scrollbar\n        const offset = (e.clientX - this._scrollXDownClientX) * window.devicePixelRatio;\n        const frames = Math.floor(offset / (this.canvas.width - this.paddingRight) * this.frameCount);\n        this._baseOffsetFrame = this._scrollXDownBaseOffsetFrame + frames;\n        this._hoveredFrame = -1;\n        this._hoveredItemIndex = -1;\n        this.drawFrames();\n        this.updateFrameTip();\n      } else if (this._isScrollYDown) {\n        // move vertical scrollbar\n        const offset = (e.clientY - this._scrollYDownClientY) * window.devicePixelRatio;\n        const itemsOffset = this._scrollYDownItemsOffset + offset / this.itemsContainerHeight * this._allItems.length * this.itemHeight;\n        this.updateItemsScroll(itemsOffset);\n      }\n    };\n    /**\n     * mouse up on document (dragging scrollbar)\n     */\n    this.cursorUp = () => {\n      if (this._isScrollXDown) {\n        this._isScrollXDown = false;\n        this._scrollXDownBaseOffsetFrame = 0;\n        this._scrollXDownClientX = 0;\n      }\n      if (this._isScrollYDown) {\n        this._isScrollYDown = false;\n        this._scrollYDownItemsOffset = 0;\n        this._scrollYDownClientY = 0;\n      }\n    };\n    this._scaleEnabled = scaleEnabled === undefined ? true : scaleEnabled;\n    this.container = container;\n    this.frameCount = frameCount;\n    if (itemHeight) {\n      this._itemHeight = itemHeight;\n    }\n    if (framesHeight) {\n      this._framesHeight = framesHeight;\n    }\n    this.bgColor = bgColor || '#3D424D';\n    this.itemColor = itemColor || '#343846';\n    this.itemSelectedColor = itemSelectedColor || '#2F3340';\n    this.cardColor = cardColor || '#5C5F6B';\n    this.fixHeight = fixHeight || false;\n    this.container.style.position = 'relative';\n    // create canvas dom\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this.canvas.style.display = 'block';\n    this.container.appendChild(this.canvas);\n    // create tip dom\n    this.frameTip = document.createElement('div');\n    this.frameTip.style.position = 'absolute';\n    this.frameTip.style.background = '#34CBD1';\n    this.frameTip.style.padding = '0 2px';\n    this.frameTip.style.borderRadius = '2px';\n    this.frameTip.style.fontSize = '10px';\n    this.frameTip.style.color = '#252935';\n    this.frameTip.style.lineHeight = '12px';\n    this.frameTip.style.height = '12px';\n    this.frameTip.style.top = '-14px';\n    this.frameTip.style.display = 'none';\n    this.container.appendChild(this.frameTip);\n    this.addEventListeners();\n    this.setupCanvas();\n  }\n\n  /**\n   * update one item's frame status\n   * @param id\n   * @param frameStatus\n   */\n  updateItemFrameStatus(id, frameStatus) {\n    if (this._items[id]) {\n      this._items[id].frameStatus = cloneDeep(frameStatus);\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * add event listeners\n   */\n  addEventListeners() {\n    document.addEventListener('mousemove', this.cursorMove);\n    document.addEventListener('mouseup', this.cursorUp);\n    window.addEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').addEventListener('change', this.setupCanvas);\n    this.canvas.addEventListener('wheel', this.wheel);\n    this.canvas.addEventListener('mousedown', this.canvasDown);\n    this.canvas.addEventListener('mousemove', this.canvasMove);\n    this.canvas.addEventListener('mouseleave', this.canvasLeave);\n  }\n\n  /**\n   * remove event listeners\n   */\n  removeEventListeners() {\n    document.removeEventListener('mousemove', this.cursorMove);\n    document.removeEventListener('mouseup', this.cursorUp);\n    window.removeEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').removeEventListener('change', this.setupCanvas);\n    this.canvas.removeEventListener('wheel', this.wheel);\n    this.canvas.removeEventListener('mousedown', this.canvasDown);\n    this.canvas.removeEventListener('mousemove', this.canvasMove);\n    this.canvas.removeEventListener('mouseleave', this.canvasLeave);\n  }\n  /**\n   * calculate initial range index\n   */\n  setupRangeIndexes(update) {\n    if (update) {\n      const estimatedRangeFrames = this.frameCount / (this.canvas.width - this.paddingRight) * this.baseRangeWidth;\n      let rangeIndex = 0;\n      while (rangeFramesSet[rangeIndex] > estimatedRangeFrames && rangeIndex < rangeFramesSet.length) {\n        rangeIndex += 1;\n      }\n      this._initialRangeIndex = rangeIndex > 0 ? rangeIndex - 1 : 0;\n      this._currentRangeIndex = this._initialRangeIndex;\n    }\n    this.emit(EventAction.VISIBLE_FRAMES_UPDATE, this._currentRangeIndex, rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex));\n  }\n\n  /**\n   * draw frames\n   */\n  drawFrames() {\n    const ctx = this.canvas.getContext('2d');\n    if (ctx) {\n      ctx.save();\n\n      // clear canvas\n      const {\n        width,\n        height\n      } = this.canvas;\n      ctx.clearRect(0, 0, width, height);\n\n      // calc current range\n      this._currentRangeStart = Math.floor(this._baseOffsetFrame / this.rangeFrames) * this.rangeFrames;\n      if (this._currentRangeStart === 0) {\n        // reset offset to 0\n        this._currentRangeStartOffset = 0;\n      } else {\n        this._currentRangeStartOffset = this._baseOffset - (this._baseOffsetFrame - this._currentRangeStart) * this.perFrameWidth;\n        const firstFrameOffset = this._baseOffset - this._baseOffsetFrame * this.perFrameWidth;\n        const lastFrameOffset = this._baseOffset + (this.frameCount - 1 - this._baseOffsetFrame) * this.perFrameWidth;\n        if (firstFrameOffset > 0) {\n          this._currentRangeStartOffset -= firstFrameOffset;\n        } else if (lastFrameOffset < width - this.paddingRight) {\n          this._currentRangeStartOffset += width - this.paddingRight - lastFrameOffset;\n        }\n      }\n      this.drawFrameItems(ctx);\n      this.drawFrameScales(ctx);\n      ctx.restore();\n    }\n  }\n\n  /**\n   * draw frame items\n   * @param ctx\n   */\n  drawFrameItems(ctx) {\n    if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n      // block cursor & cards\n      this.drawItems(ctx, 'blocks');\n      this.drawFrameHint(ctx);\n      this.drawItems(ctx, 'cards');\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    } else {\n      // line cursor & blocks\n      this.drawItems(ctx);\n      this.drawFrameHint(ctx);\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    }\n  }\n\n  /**\n   * draw items\n   * @param ctx\n   * @param type empty means all items\n   */\n  drawItems(ctx, type) {\n    let items = this._allItems;\n    if (type === 'blocks') {\n      items = items.filter(({\n        id\n      }) => !this._items[id].showCards);\n    } else if (type === 'cards') {\n      items = items.filter(({\n        id\n      }) => this._items[id].showCards);\n    }\n    const width = this.canvas.width - this.paddingRight;\n    items.forEach(({\n      id,\n      index\n    }) => {\n      const {\n        frameStatus,\n        frameColor = {},\n        color,\n        showCards,\n        selected\n      } = this._items[id];\n      const itemOffset = index * this.itemHeight;\n      if (itemOffset + this.itemHeight <= this._itemsOffset || itemOffset - this._itemsOffset >= this.itemsTotalHeight) {\n        // out of container\n        return;\n      }\n      const height = this.itemHeight;\n      const offsetY = itemOffset - this._itemsOffset;\n\n      // draw background\n      drawRect(ctx, 0, offsetY, width, height, selected ? this.itemSelectedColor : this.itemColor);\n      if (index !== 0) {\n        drawLine(ctx, 0, offsetY - 0.5, width, offsetY - 0.5, 'rgba(255, 255, 255, 0.1)');\n      }\n      if (type === 'cards') {\n        // add bottom line when drawing cards\n        drawLine(ctx, 0, offsetY + height - 0.5, width, offsetY + height - 0.5, 'rgba(255, 255, 255, 0.1)');\n      }\n      if (showCards && this._currentRangeIndex === rangeFramesSet.length - 1) {\n        // draw cards\n        const drawCard = (frame, frameOffset) => {\n          if (frameOffset + this.cardOffsetX < width) {\n            let cWidth = this.cardWidth;\n            if (frameOffset + this.cardOffsetX + cWidth > width) {\n              cWidth = width - (frameOffset + this.cardOffsetX);\n            }\n            if (frameStatus[frame] !== undefined) {\n              const cardColor = frameColor[frame] || this.cardColor;\n              drawRect(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, cardColor);\n              if (frameStatus[frame] === true && frameOffset + this.perFrameWidth / 2 < width) {\n                drawCircle(ctx, frameOffset + this.perFrameWidth / 2, offsetY + this.itemHeight / 2, 2, '#FFFFFF');\n              }\n            }\n            if (frame === this._currentFrame && selected) {\n              drawRectBorder(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, '#FFFFFF');\n            }\n          }\n        };\n        const drawRangeCards = (start, offset) => {\n          Array.from({\n            length: 5\n          }).forEach((_, i) => {\n            const frame = start + i;\n            if (frameStatus[frame] !== undefined || frame === this._currentFrame && selected) {\n              const frameOffset = offset + this.perFrameWidth * i;\n              drawCard(frame, frameOffset);\n            }\n          });\n        };\n        if (this._currentRangeIndex <= this._initialRangeIndex) {\n          // just draw all frames\n          Array.from({\n            length: this.frameCount\n          }).forEach((_, i) => {\n            drawCard(i, this.perFrameWidth * i);\n          });\n        } else {\n          let rangeStart = this._currentRangeStart;\n          let rangeStartOffset = this._currentRangeStartOffset;\n          while (rangeStartOffset + this.baseRangeWidth >= 0 && rangeStart >= 0) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart -= this.rangeFrames;\n            rangeStartOffset -= this.baseRangeWidth;\n          }\n          rangeStart = this._currentRangeStart + this.rangeFrames;\n          rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n          while (rangeStartOffset < width && rangeStart < this.frameCount) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart += this.rangeFrames;\n            rangeStartOffset += this.baseRangeWidth;\n          }\n        }\n      } else {\n        // draw block\n        const statusFrames = Object.keys(frameStatus).map(i => Number(i));\n        let lastStartIndex = 0;\n        for (let i = 0; i < statusFrames.length; i += 1) {\n          if (i === statusFrames.length - 1 || statusFrames[i + 1] - statusFrames[i] > 1) {\n            const startFrame = statusFrames[lastStartIndex];\n            const endFrame = statusFrames[i] + 1;\n            let startOffset = this._currentRangeStartOffset + (startFrame - this._currentRangeStart) * this.perFrameWidth;\n            let endOffset = this._currentRangeStartOffset + (endFrame - this._currentRangeStart) * this.perFrameWidth;\n            startOffset = Math.min(Math.max(startOffset, 0), width);\n            endOffset = Math.min(Math.max(endOffset, 0), width);\n            if (endOffset > startOffset) {\n              // only draw when visible\n              drawRect(ctx, startOffset, offsetY + this.itemBlockOffsetY, endOffset - startOffset, this.itemBlockHeight, color);\n            }\n            lastStartIndex = i + 1;\n          }\n        }\n      }\n    });\n    if (type !== 'cards') {\n      // no need to draw vertical scroll bar when drawing cards\n      const visibleItemsCount = this.itemsTotalHeight / this.itemHeight;\n      if (visibleItemsCount < this._allItems.length) {\n        // draw scroll y\n        this._scrollYHeight = visibleItemsCount / this._allItems.length * this.itemsTotalHeight;\n        this._scrollYOffset = this._itemsOffset / (this._allItems.length * this.itemHeight) * this.itemsTotalHeight;\n        drawRoundedRect(ctx, width + this.scrollbarYOffsetX, this._scrollYOffset, this.scrollbarYWidth, this._scrollYHeight, 6, scrollbarColor);\n      } else {\n        this._scrollYHeight = 0;\n        this._scrollYOffset = 0;\n      }\n    }\n  }\n\n  /**\n   * draw invalid frame style\n   * @param ctx\n   */\n  drawInvalidFrames(ctx) {\n    // draw invalid frames\n    this._invalidFrames.forEach(frameIndex => {\n      const offsetX = this.getOffsetByFrame(frameIndex);\n      if (offsetX >= 0) {\n        drawRect(ctx, offsetX, 0, Math.max(this.perFrameWidth, 1 * window.devicePixelRatio), this.itemsTotalHeight, 'rgba(220, 70, 36, 0.3)');\n      }\n    });\n  }\n\n  /**\n   * draw frame hint (for current frame & hovered frame)\n   * @param ctx\n   * @param type\n   */\n  drawFrameHint(ctx, type) {\n    const frame = type === 'hover' ? this._hoveredFrame : this._currentFrame;\n    const shouldDraw = type !== 'hover' || this._hoveredFrame !== this._currentFrame;\n    if (shouldDraw) {\n      const offsetX = this.getOffsetByFrame(frame);\n      if (offsetX >= 0) {\n        if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n          // block\n          drawRect(ctx, offsetX, 0, this.perFrameWidth, this.itemsTotalHeight, 'rgba(41, 44, 56, 0.4)');\n          if (type === 'hover' && this._hoveredItemIndex >= 0) {\n            const offsetY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset;\n            drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, 'rgba(255, 255, 255, 0.4)');\n          }\n          if (type !== 'hover') {\n            const selectedIndex = this._allItems.findIndex(i => this.items[i.id].selected);\n            const offsetY = selectedIndex * this.itemHeight - this._itemsOffset;\n            drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, '#FFFFFF');\n          }\n        } else {\n          // line\n          drawLine(ctx, offsetX + 0.5, 0, offsetX + 0.5, this.itemsTotalHeight, type === 'hover' ? 'rgba(255, 255, 255, 0.4)' : '#FFFFFF');\n        }\n      }\n    }\n  }\n\n  /**\n   * draw frame scales\n   * @param ctx\n   */\n  drawFrameScales(ctx) {\n    if (!this._scaleEnabled) return;\n    const width = this.canvas.width - this.paddingRight;\n    const offsetY = this.itemsTotalHeight;\n    const scaleWidth = this.perFrameWidth * this.rangeFrames;\n    const scaleHeight = 16 * window.devicePixelRatio;\n    const scaleHeightShort = 4 * window.devicePixelRatio;\n\n    // draw scales top border\n    drawRect(ctx, 0, offsetY, width, offsetY, this.bgColor);\n    drawLine(ctx, 0, offsetY + 0.5, width, offsetY + 0.5, 'rgba(255, 255, 255, 0.1)');\n    if (this._currentRangeIndex <= this._initialRangeIndex) {\n      const rangeCount = this.frameCount / this.rangeFrames;\n      const rangeWidth = width / rangeCount;\n      if (rangeWidth > this.baseRangeWidth * 5) {\n        for (let i = 0; i < this.frameCount; i += 1) {\n          drawScale(ctx, i * this.perFrameWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i, false);\n        }\n      } else {\n        for (let i = 0; i < rangeCount; i += 1) {\n          drawScale(ctx, i * rangeWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i * this.rangeFrames);\n        }\n      }\n      this._scrollXWidth = 0;\n      this._scrollXOffset = 0;\n    } else {\n      let rangeStart = this._currentRangeStart;\n      let rangeStartOffset = this._currentRangeStartOffset;\n      while (rangeStartOffset + this.baseRangeWidth >= 0 && rangeStart >= 0) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart -= this.rangeFrames;\n        rangeStartOffset -= this.baseRangeWidth;\n      }\n      rangeStart = this._currentRangeStart + this.rangeFrames;\n      rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n      while (rangeStartOffset < width && rangeStart < this.frameCount) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart += this.rangeFrames;\n        rangeStartOffset += this.baseRangeWidth;\n      }\n    }\n\n    // draw scrollbar\n    this._scrollXWidth = Math.max(Math.ceil(width / this.perFrameWidth / this.frameCount * width), 42);\n    this._scrollXOffset = (this._currentRangeStart - this._currentRangeStartOffset / this.perFrameWidth) / this.frameCount * width;\n    drawRoundedRect(ctx, this._scrollXOffset, offsetY + this.scrollbarXOffsetY, this._scrollXWidth, this.scrollbarXHeight, 6, scrollbarColor);\n  }\n\n  /**\n   * update frame tip text and posistion\n   */\n  updateFrameTip() {\n    if (this._hoveredFrame >= 0) {\n      this.frameTip.innerText = `${this._hoveredFrame + 1}`;\n      const {\n        width\n      } = this.frameTip.getBoundingClientRect();\n      const frameOffset = this.getOffsetByFrame(this._hoveredFrame) / window.devicePixelRatio;\n      let offset = frameOffset - width / 2;\n      if (this.currentRangeIndex === rangeFramesSet.length - 1) {\n        offset += this.perFrameWidth / 2 / window.devicePixelRatio;\n      }\n      this.frameTip.style.left = `${offset}px`;\n      this.frameTip.style.display = 'block';\n    } else {\n      this.frameTip.style.display = 'none';\n    }\n  }\n\n  /**\n   * update items scroll and emit event\n   */\n  updateItemsScroll(itemsOffset) {\n    const allItemsHeight = this._allItems.length * this.itemHeight;\n    if (allItemsHeight <= this.itemsContainerHeight) {\n      // not scrollable\n      return;\n    }\n    this._itemsOffset = itemsOffset;\n    if (this._itemsOffset < 0) {\n      this._itemsOffset = 0;\n    } else if (this._itemsOffset > allItemsHeight - this.itemsTotalHeight) {\n      this._itemsOffset = allItemsHeight - this.itemsTotalHeight;\n    }\n    this.drawFrames();\n    this.emit(EventAction.ITEMS_OFFSET_CHANGE, this._itemsOffset / window.devicePixelRatio);\n  }\n\n  /**\n   * get frame by clientX\n   * @param clientX\n   * @returns\n   */\n  getFrameByClientX(clientX) {\n    const {\n      left\n    } = this.canvas.getBoundingClientRect();\n    const offset = (clientX - left) * window.devicePixelRatio;\n    let frame = this._currentRangeStart + Math.floor((offset - this._currentRangeStartOffset) / this.perFrameWidth);\n    if (frame >= this.frameCount) {\n      frame = this.frameCount - 1;\n    } else if (frame < 0) {\n      frame = 0;\n    }\n    return frame;\n  }\n\n  /**\n   * get item index by clientY\n   * @param clientY\n   * @returns\n   */\n  getItemIndexByClientY(clientY) {\n    const {\n      top\n    } = this.canvas.getBoundingClientRect();\n    const offset = (clientY - top) * window.devicePixelRatio;\n    const index = Math.floor((offset + this._itemsOffset) / this.itemHeight);\n    if (index > Object.keys(this._items).length - 1) {\n      return -1;\n    }\n    return index;\n  }\n\n  /**\n   * get offset by frame index\n   * @param frame\n   * @param checkOutside\n   * @returns\n   */\n  getOffsetByFrame(frame, checkOutside = true) {\n    const offset = this._currentRangeStartOffset + (frame - this._currentRangeStart) * this.perFrameWidth;\n    if (checkOutside && (offset < 0 || offset > this.canvas.width - this.paddingRight)) {\n      return -1;\n    }\n    return offset;\n  }\n\n  /**\n   * check hover item\n   * @param clientX\n   * @param clientY\n   * @returns\n   */\n  getMouseHover(clientX, clientY) {\n    const {\n      width: canvasWidth,\n      height: canvasHeight\n    } = this.canvas;\n    const {\n      left,\n      top,\n      width,\n      height\n    } = this.canvas.getBoundingClientRect();\n    const offsetX = clientX - left;\n    const offsetY = clientY - top;\n    const scrollbarOffsetY = this.itemsTotalHeight + this.scrollbarXOffsetY;\n    if (offsetX / width >= this._scrollXOffset / canvasWidth && offsetX / width <= (this._scrollXOffset + this._scrollXWidth) / canvasWidth && offsetY / height >= scrollbarOffsetY / canvasHeight && offsetY / height <= (scrollbarOffsetY + this.scrollbarXHeight) / canvasHeight) {\n      return HoverType.SCROLLBAR_X;\n    }\n    const scrollbarOffsetX = canvasWidth - this.paddingRight + this.scrollbarYOffsetX;\n    if (offsetX / width >= scrollbarOffsetX / canvasWidth && offsetX / width <= (scrollbarOffsetX + this.scrollbarYWidth) / canvasWidth && offsetY / height >= this._scrollYOffset / canvasHeight && offsetY / height <= (this._scrollYOffset + this._scrollYHeight) / canvasHeight) {\n      return HoverType.SCROLLBAR_Y;\n    }\n    if (offsetX * window.devicePixelRatio > canvasWidth - this.paddingRight && offsetX * window.devicePixelRatio <= canvasWidth) {\n      return HoverType.SCROLLBAR_Y_CONTAINER;\n    }\n    return undefined;\n  }\n\n  /**\n   * set cursor for progress bar\n   * @param cursor\n   */\n  setCursor(cursor) {\n    if (this.canvas.style.cursor !== cursor) {\n      this.canvas.style.cursor = cursor;\n    }\n  }\n\n  /**\n   * focus to specific frame if not in the progress bar view\n   * @param frame\n   */\n  focusFrame(frame) {\n    const offset = this.getOffsetByFrame(frame, false);\n    const right = this.canvas.width - this.paddingRight - this.perFrameWidth;\n    if (offset < 0) {\n      // move left\n      this._baseOffsetFrame = frame;\n      this._baseOffset = this.perFrameWidth;\n    } else if (offset > right) {\n      // move right\n      this._baseOffsetFrame = frame;\n      this._baseOffset = right - this.perFrameWidth;\n    }\n    this.drawFrames();\n  }\n}","map":{"version":3,"names":["EventEmitter","cloneDeep","drawLine","drawRect","drawRectBorder","drawRoundedRect","drawCircle","drawScale","Cursor","EventAction","HoverType","rangeFramesSet","scrollbarColor","FramesRenderer","scrollable","_scrollable","shouldUpdate","setupCanvas","invalidFrames","frames","_invalidFrames","drawFrames","items","_items","originItemsLen","Object","keys","length","_allItems","map","id","index","height","itemHeight","itemsContainerHeight","fixHeight","currentFrame","_currentFrame","frameIndex","focusFrame","currentRangeIndex","_currentRangeIndex","rangeIndex","Math","min","max","_initialRangeIndex","itemsOffset","_itemsOffset","o","offset","window","devicePixelRatio","_itemHeight","framesHeight","_framesHeight","baseRangeWidth","paddingRight","scrollbarXHeight","scrollbarXOffsetY","scrollbarYWidth","scrollbarYOffsetX","itemBlockHeight","itemBlockOffsetY","itemCardHeight","itemsTotalHeight","rangeFrames","perFrameWidth","canvas","width","frameCount","cardWidth","cardOffsetX","cardOffsetY","constructor","container","bgColor","itemColor","itemSelectedColor","cardColor","scaleEnabled","frameTip","_hoveredFrame","_hoveredItemIndex","_currentRangeStart","_currentRangeStartOffset","_baseOffset","_baseOffsetFrame","_isScrollXDown","_scrollXDownBaseOffsetFrame","_scrollXDownClientX","_scrollXWidth","_scrollXOffset","_scrollYHeight","_scrollYOffset","_isScrollYDown","_scrollYDownItemsOffset","_scrollYDownClientY","_scaleEnabled","getBoundingClientRect","originCanvasWidth","emit","HEIGHT_CHANGE","setupRangeIndexes","wheel","e","altKey","zoom","updateItemsScroll","deltaY","hover","getMouseHover","clientX","clientY","SCROLLBAR_Y_CONTAINER","SCROLLBAR_Y","left","getFrameByClientX","VISIBLE_FRAMES_UPDATE","_","i","slice","canvasMove","canvasDown","SCROLLBAR_X","CURRENT_FRAME_CHANGE","setCursor","DEFAULT","POINTER","canvasLeave","getItemIndexByClientY","updateFrameTip","cursorMove","floor","cursorUp","undefined","style","position","document","createElement","display","appendChild","background","padding","borderRadius","fontSize","color","lineHeight","top","addEventListeners","updateItemFrameStatus","frameStatus","addEventListener","matchMedia","removeEventListeners","removeEventListener","update","estimatedRangeFrames","ctx","getContext","save","clearRect","firstFrameOffset","lastFrameOffset","drawFrameItems","drawFrameScales","restore","drawItems","drawFrameHint","drawInvalidFrames","type","filter","showCards","forEach","frameColor","selected","itemOffset","offsetY","drawCard","frame","frameOffset","cWidth","drawRangeCards","start","Array","from","rangeStart","rangeStartOffset","statusFrames","Number","lastStartIndex","startFrame","endFrame","startOffset","endOffset","visibleItemsCount","offsetX","getOffsetByFrame","shouldDraw","selectedIndex","findIndex","scaleWidth","scaleHeight","scaleHeightShort","rangeCount","rangeWidth","ceil","innerText","allItemsHeight","ITEMS_OFFSET_CHANGE","checkOutside","canvasWidth","canvasHeight","scrollbarOffsetY","scrollbarOffsetX","cursor","right"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/libs/FramesRenderer.ts"],"sourcesContent":["/* eslint-disable class-methods-use-this */\nimport EventEmitter from 'eventemitter3';\nimport { cloneDeep } from 'lodash';\nimport { drawLine, drawRect, drawRectBorder, drawRoundedRect, drawCircle, drawScale } from '../utils/canvas';\nimport Cursor from '../components/common/Cursor';\n\nexport interface FrameItem {\n  frameStatus: {\n    [frameIndex: number]: boolean; // true means is key frame\n  };\n  frameColor?: {\n    [frameIndex: number]: string;\n  };\n  color: string;\n  showCards?: boolean;\n  selected?: boolean;\n}\n\nexport enum EventAction {\n  HEIGHT_CHANGE = 'height-change',\n  VISIBLE_FRAMES_UPDATE = 'visible-frames-update',\n  CURRENT_FRAME_CHANGE = 'current-frame-change',\n  ITEMS_OFFSET_CHANGE = 'items-offset-change',\n}\n\nenum HoverType {\n  SCROLLBAR_X = 'scrollbarX',\n  SCROLLBAR_Y = 'scrollbarY',\n  SCROLLBAR_Y_CONTAINER = 'scrollbarYContainer',\n}\n\nconst rangeFramesSet = [1000, 500, 200, 100, 50, 20, 10, 5]; // set of supported frames per range\nconst scrollbarColor = '#777B82';\n\nexport default class FramesRenderer extends EventEmitter {\n  /**\n   * canvas container\n   * @member\n   */\n  container: HTMLDivElement;\n\n  /**\n   * canvas dom element\n   * @member\n   */\n  canvas: HTMLCanvasElement;\n\n  /**\n   * frame tip element\n   * @member\n   */\n  frameTip: HTMLDivElement;\n\n  /**\n   * frames count\n   * @member\n   */\n  frameCount: number;\n\n  /**\n   * frames background color\n   * @member\n   */\n  bgColor: string;\n\n  /**\n   * item default color\n   * @member\n   */\n  itemColor: string;\n\n  /**\n   * item selected color\n   * @member\n   */\n  itemSelectedColor: string;\n\n  /**\n   * card color\n   * @member\n   */\n  cardColor: string;\n\n  /**\n   * is frames container height fix\n   * @member\n   */\n  fixHeight = false;\n\n  /**\n   * scrollable\n   * @private\n   */\n  private _scrollable = false;\n\n  /**\n   * get scrollable\n   * @getter\n   */\n  get scrollable() {\n    return this._scrollable;\n  }\n\n  /**\n   * set scrollable\n   * @setter\n   */\n  set scrollable(scrollable: boolean) {\n    const shouldUpdate = this._scrollable !== scrollable;\n    this._scrollable = scrollable;\n    if (shouldUpdate) {\n      this.setupCanvas();\n    }\n  }\n\n  /**\n   * invalid frames\n   */\n  private _invalidFrames: number[] = [];\n\n  /**\n   * set invalid frames\n   * @setter\n   */\n  set invalidFrames(frames: number[]) {\n    this._invalidFrames = [...frames];\n    this.drawFrames();\n  }\n\n  /**\n   * frame items\n   * @private\n   */\n  private _items: { [id: string]: FrameItem } = {};\n\n  /**\n   * get frame items\n   * @getter\n   */\n  get items() {\n    return this._items;\n  }\n\n  /**\n   * set frame items\n   * @setter\n   */\n  set items(items: { [id: string]: FrameItem }) {\n    const originItemsLen = Object.keys(this._items).length;\n    this._items = cloneDeep(items);\n    this._allItems = Object.keys((this._items)).map((id, index) => ({ id, index }));\n    const height = Object.keys(this._items).length * this.itemHeight;\n    if (height > this.itemsContainerHeight && !this.scrollable) {\n      this._scrollable = true;\n      this.setupCanvas();\n    } else if (height <= this.itemsContainerHeight && this.scrollable && !this.fixHeight) {\n      this._scrollable = false;\n      this.setupCanvas();\n    } if (originItemsLen !== Object.keys(items).length && !this.scrollable) {\n      // when items length changes, and not scrollable, need resize canvas and redraw\n      this.setupCanvas();\n    } else {\n      // just redraw\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * all items with id and actual index\n   * @private\n   */\n  private _allItems: { id: string; index: number }[] = [];\n\n  /**\n   * current frame index\n   * @private\n   */\n  private _currentFrame = 0;\n\n  /**\n   * get current frame\n   * @getter\n   */\n  get currentFrame() {\n    return this._currentFrame;\n  }\n\n  set currentFrame(frameIndex: number) {\n    const shouldUpdate = this._currentFrame !== frameIndex;\n    this._currentFrame = frameIndex;\n    if (shouldUpdate) {\n      this.focusFrame(frameIndex);\n    }\n  }\n\n  /**\n   * hovered frame index\n   * @private\n   */\n  private _hoveredFrame = -1;\n\n  /**\n   * hovered item index\n   * @private\n   */\n  private _hoveredItemIndex = -1;\n\n  /**\n   * initial calculated range index (largest frames per range)\n   * @private\n   */\n  private _initialRangeIndex = 0;\n\n  /**\n   * current range index in the rangeFramesSet\n   * @private\n   */\n  private _currentRangeIndex = 0;\n\n  /**\n   * get current range index\n   * @getter\n   */\n  get currentRangeIndex() {\n    return this._currentRangeIndex;\n  }\n\n  /**\n   * set current range index\n   * @setters\n   */\n  set currentRangeIndex(index: number) {\n    const rangeIndex = Math.min(Math.max(index, this._initialRangeIndex), rangeFramesSet.length - 1);\n    const shouldUpdate = this._currentRangeIndex !== rangeIndex;\n    this._currentRangeIndex = rangeIndex;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * current range start frame (used for drawing)\n   * @private\n   */\n  private _currentRangeStart = 0;\n\n  /**\n   * current range start frame offset (used for drawing)\n   * @private\n   */\n  private _currentRangeStartOffset = 0;\n\n  /**\n   * current offset in canvas when zooming, dragging and so on\n   * @private\n   */\n  private _baseOffset = 0;\n\n  /**\n   * current offset frame index in canvas when zooming, dragging and so on\n   * @private\n   */\n  private _baseOffsetFrame = 0;\n\n  /**\n   * is mouse down on horizontal scrollbar\n   * @private\n   */\n  private _isScrollXDown = false;\n\n  /**\n   * base offset when mouse down on horizontal scrollbar\n   * @private\n   */\n  private _scrollXDownBaseOffsetFrame = 0;\n\n  /**\n   * client X when mouse down on horizontal scrollbar\n   * @private\n   */\n  private _scrollXDownClientX = 0;\n\n  /**\n   * horizontal scrollbar width\n   * @private\n   */\n  private _scrollXWidth = 0;\n\n  /**\n   * horizontal scrollbar offset\n   * @private\n   */\n  private _scrollXOffset = 0;\n\n  /**\n   * items offset\n   * @private\n   */\n  private _itemsOffset = 0;\n\n  /**\n   * get items offset\n   * @getter\n   */\n  get itemsOffset() {\n    return this._itemsOffset;\n  }\n\n  /**\n   * set items offset\n   * @setter\n   */\n  set itemsOffset(o: number) {\n    const offset = o * window.devicePixelRatio;\n    const shouldUpdate = this._itemsOffset !== offset;\n    this._itemsOffset = offset;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * vertical scrollbar height\n   * @private\n   */\n  private _scrollYHeight = 0;\n\n  /**\n   * vertical scrollbar offset\n   * @private\n   */\n  private _scrollYOffset = 0;\n\n  /**\n   * is mouse down on vertical scrollbar\n   * @private\n   */\n  private _isScrollYDown = false;\n\n  /**\n   * items offset when mouse down on vertical scrollbar\n   * @private\n   */\n  private _scrollYDownItemsOffset = 0;\n\n  /**\n   * client y when mouse down on vertical scrollbar\n   * @private\n   */\n  private _scrollYDownClientY = 0;\n\n  /**\n   * item height\n   * @private\n   */\n  private _itemHeight = 20;\n\n  /**\n   * get item height\n   */\n  get itemHeight() {\n    return this._itemHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames height\n   * @private\n   */\n  private _framesHeight = 36;\n\n  /**\n   * get frames height\n   */\n  get framesHeight() {\n    return this._framesHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames scale enable\n   */\n  private _scaleEnabled = true;\n\n  /**\n   * base range width\n   */\n  get baseRangeWidth() {\n    return 18 * 5 * window.devicePixelRatio;\n  }\n\n  /**\n   * canvas padding right\n   */\n  get paddingRight() {\n    return 18 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar height\n   */\n  get scrollbarXHeight() {\n    return 10 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar offset y (from frames container top)\n   */\n  get scrollbarXOffsetY() {\n    return 22 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar width\n   */\n  get scrollbarYWidth() {\n    return 10 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar offset x (from items container right)\n   */\n  get scrollbarYOffsetX() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block height\n   */\n  get itemBlockHeight() {\n    return 12 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block offset y (in the item container)\n   */\n  get itemBlockOffsetY() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item card height\n   */\n  get itemCardHeight() {\n    return 16 * window.devicePixelRatio;\n  }\n\n  /**\n   * items container height (when not collapsed)\n   */\n  get itemsContainerHeight() {\n    return 275 * window.devicePixelRatio;\n  }\n\n  /**\n   * frames container height\n   */\n  get itemsTotalHeight() {\n    if (this.scrollable) {\n      return this.itemsContainerHeight;\n    }\n    return Object.keys(this._items).length * this.itemHeight;\n  }\n\n  /**\n   * current range frames\n   */\n  get rangeFrames() {\n    return rangeFramesSet[this._currentRangeIndex];\n  }\n\n  /**\n   * current per frame width\n   */\n  get perFrameWidth() {\n    return this._currentRangeIndex <= this._initialRangeIndex\n      ? (this.canvas.width - this.paddingRight) / this.frameCount\n      : this.baseRangeWidth / this.rangeFrames;\n  }\n\n  /**\n   * current card width\n   */\n  get cardWidth() {\n    return this.perFrameWidth - this.cardOffsetX * 2;\n  }\n\n  /**\n   * card offset x (base on item)\n   */\n  get cardOffsetX() {\n    return 1 * window.devicePixelRatio;\n  }\n\n  /**\n   * card offset y (base on item)\n   */\n  get cardOffsetY() {\n    return (this.itemHeight - this.itemCardHeight) / 2;\n  }\n\n  /**\n   * constructor\n   * @param canvas\n   * @param frameCount\n   * @param options\n   */\n  constructor(\n    container: HTMLDivElement,\n    frameCount: number,\n    { itemHeight, framesHeight, bgColor, itemColor, itemSelectedColor, cardColor, scaleEnabled, fixHeight }: {\n      itemHeight?: number,\n      framesHeight?: number,\n      bgColor?: string,\n      itemColor?: string,\n      itemSelectedColor?: string,\n      cardColor?: string,\n      scaleEnabled?: boolean,\n      fixHeight?: boolean,\n    } = {},\n  ) {\n    super();\n    this._scaleEnabled = scaleEnabled === undefined ? true : scaleEnabled;\n    this.container = container;\n    this.frameCount = frameCount;\n    if (itemHeight) {\n      this._itemHeight = itemHeight;\n    }\n    if (framesHeight) {\n      this._framesHeight = framesHeight;\n    }\n    this.bgColor = bgColor || '#3D424D';\n    this.itemColor = itemColor || '#343846';\n    this.itemSelectedColor = itemSelectedColor || '#2F3340';\n    this.cardColor = cardColor || '#5C5F6B';\n    this.fixHeight = fixHeight || false;\n\n    this.container.style.position = 'relative';\n    // create canvas dom\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this.canvas.style.display = 'block';\n    this.container.appendChild(this.canvas);\n    // create tip dom\n    this.frameTip = document.createElement('div');\n    this.frameTip.style.position = 'absolute';\n    this.frameTip.style.background = '#34CBD1';\n    this.frameTip.style.padding = '0 2px';\n    this.frameTip.style.borderRadius = '2px';\n    this.frameTip.style.fontSize = '10px';\n    this.frameTip.style.color = '#252935';\n    this.frameTip.style.lineHeight = '12px';\n    this.frameTip.style.height = '12px';\n    this.frameTip.style.top = '-14px';\n    this.frameTip.style.display = 'none';\n    this.container.appendChild(this.frameTip);\n\n    this.addEventListeners();\n    this.setupCanvas();\n  }\n\n  /**\n   * update one item's frame status\n   * @param id\n   * @param frameStatus\n   */\n  updateItemFrameStatus(id: string, frameStatus: { [frameIndex: number]: boolean }) {\n    if (this._items[id]) {\n      this._items[id].frameStatus = cloneDeep(frameStatus);\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * add event listeners\n   */\n  addEventListeners() {\n    document.addEventListener('mousemove', this.cursorMove);\n    document.addEventListener('mouseup', this.cursorUp);\n    window.addEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').addEventListener('change', this.setupCanvas);\n    this.canvas.addEventListener('wheel', this.wheel);\n    this.canvas.addEventListener('mousedown', this.canvasDown);\n    this.canvas.addEventListener('mousemove', this.canvasMove);\n    this.canvas.addEventListener('mouseleave', this.canvasLeave);\n  }\n\n  /**\n   * remove event listeners\n   */\n  removeEventListeners() {\n    document.removeEventListener('mousemove', this.cursorMove);\n    document.removeEventListener('mouseup', this.cursorUp);\n    window.removeEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').removeEventListener('change', this.setupCanvas);\n    this.canvas.removeEventListener('wheel', this.wheel);\n    this.canvas.removeEventListener('mousedown', this.canvasDown);\n    this.canvas.removeEventListener('mousemove', this.canvasMove);\n    this.canvas.removeEventListener('mouseleave', this.canvasLeave);\n  }\n\n  /**\n   * set up canvas size\n   */\n  setupCanvas = () => {\n    const { width } = this.canvas.getBoundingClientRect();\n    const originCanvasWidth = this.canvas.width;\n    this.canvas.width = width * window.devicePixelRatio;\n    this.canvas.height = this.itemsTotalHeight + this.framesHeight;\n    this.emit(EventAction.HEIGHT_CHANGE, this.canvas.height / window.devicePixelRatio);\n\n    this.setupRangeIndexes(originCanvasWidth !== this.canvas.width);\n    this.drawFrames();\n  };\n\n  /**\n   * calculate initial range index\n   */\n  setupRangeIndexes(update: boolean) {\n    if (update) {\n      const estimatedRangeFrames = (this.frameCount / (this.canvas.width - this.paddingRight)) * this.baseRangeWidth;\n      let rangeIndex = 0;\n      while (rangeFramesSet[rangeIndex] > estimatedRangeFrames && rangeIndex < rangeFramesSet.length) {\n        rangeIndex += 1;\n      }\n      this._initialRangeIndex = rangeIndex > 0 ? rangeIndex - 1 : 0;\n      this._currentRangeIndex = this._initialRangeIndex;\n    }\n    this.emit(\n      EventAction.VISIBLE_FRAMES_UPDATE,\n      this._currentRangeIndex,\n      rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex),\n    );\n  }\n\n  /**\n   * draw frames\n   */\n  drawFrames() {\n    const ctx = this.canvas.getContext('2d');\n    if (ctx) {\n      ctx.save();\n\n      // clear canvas\n      const { width, height } = this.canvas;\n      ctx.clearRect(0, 0, width, height);\n\n      // calc current range\n      this._currentRangeStart = Math.floor(this._baseOffsetFrame / this.rangeFrames) * this.rangeFrames;\n      if (this._currentRangeStart === 0) {\n        // reset offset to 0\n        this._currentRangeStartOffset = 0;\n      } else {\n        this._currentRangeStartOffset = this._baseOffset - (this._baseOffsetFrame - this._currentRangeStart) * this.perFrameWidth;\n        const firstFrameOffset = this._baseOffset - this._baseOffsetFrame * this.perFrameWidth;\n        const lastFrameOffset = this._baseOffset + (this.frameCount - 1 - this._baseOffsetFrame) * this.perFrameWidth;\n        if (firstFrameOffset > 0) {\n          this._currentRangeStartOffset -= firstFrameOffset;\n        } else if (lastFrameOffset < (width - this.paddingRight)) {\n          this._currentRangeStartOffset += width - this.paddingRight - lastFrameOffset;\n        }\n      }\n\n      this.drawFrameItems(ctx);\n      this.drawFrameScales(ctx);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n   * draw frame items\n   * @param ctx\n   */\n  drawFrameItems(ctx: CanvasRenderingContext2D) {\n    if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n      // block cursor & cards\n      this.drawItems(ctx, 'blocks');\n      this.drawFrameHint(ctx);\n      this.drawItems(ctx, 'cards');\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    } else {\n      // line cursor & blocks\n      this.drawItems(ctx);\n      this.drawFrameHint(ctx);\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    }\n  }\n\n  /**\n   * draw items\n   * @param ctx\n   * @param type empty means all items\n   */\n  drawItems(ctx: CanvasRenderingContext2D, type?: string) {\n    let items = this._allItems;\n    if (type === 'blocks') {\n      items = items.filter(({ id }) => !this._items[id].showCards);\n    } else if (type === 'cards') {\n      items = items.filter(({ id }) => this._items[id].showCards);\n    }\n\n    const width = this.canvas.width - this.paddingRight;\n    items.forEach(({ id, index }) => {\n      const { frameStatus, frameColor = {}, color, showCards, selected } = this._items[id];\n      const itemOffset = index * this.itemHeight;\n      if ((itemOffset + this.itemHeight) <= this._itemsOffset || (itemOffset - this._itemsOffset) >= this.itemsTotalHeight) {\n        // out of container\n        return;\n      }\n\n      const height = this.itemHeight;\n      const offsetY = itemOffset - this._itemsOffset;\n\n      // draw background\n      drawRect(ctx, 0, offsetY, width, height, selected ? this.itemSelectedColor : this.itemColor);\n      if (index !== 0) {\n        drawLine(ctx, 0, offsetY - 0.5, width, offsetY - 0.5, 'rgba(255, 255, 255, 0.1)');\n      }\n      if (type === 'cards') {\n        // add bottom line when drawing cards\n        drawLine(ctx, 0, offsetY + height - 0.5, width, offsetY + height - 0.5, 'rgba(255, 255, 255, 0.1)');\n      }\n\n      if (showCards && this._currentRangeIndex === rangeFramesSet.length - 1) {\n        // draw cards\n        const drawCard = (frame: number, frameOffset: number) => {\n          if (frameOffset + this.cardOffsetX < width) {\n            let cWidth = this.cardWidth;\n            if (frameOffset + this.cardOffsetX + cWidth > width) {\n              cWidth = width - (frameOffset + this.cardOffsetX);\n            }\n            if (frameStatus[frame] !== undefined) {\n              const cardColor = frameColor[frame] || this.cardColor;\n              drawRect(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, cardColor);\n              if (frameStatus[frame] === true && frameOffset + this.perFrameWidth / 2 < width) {\n                drawCircle(ctx, frameOffset + this.perFrameWidth / 2, offsetY + this.itemHeight / 2, 2, '#FFFFFF');\n              }\n            }\n            if (frame === this._currentFrame && selected) {\n              drawRectBorder(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, '#FFFFFF');\n            }\n          }\n        };\n        const drawRangeCards = (start: number, offset: number) => {\n          Array.from({ length: 5 }).forEach((_, i) => {\n            const frame = start + i;\n            if (frameStatus[frame] !== undefined || (frame === this._currentFrame && selected)) {\n              const frameOffset = offset + this.perFrameWidth * i;\n              drawCard(frame, frameOffset);\n            }\n          });\n        };\n\n        if (this._currentRangeIndex <= this._initialRangeIndex) {\n          // just draw all frames\n          Array.from({ length: this.frameCount }).forEach((_, i) => {\n            drawCard(i, this.perFrameWidth * i);\n          });\n        } else {\n          let rangeStart = this._currentRangeStart;\n          let rangeStartOffset = this._currentRangeStartOffset;\n          while ((rangeStartOffset + this.baseRangeWidth) >= 0 && rangeStart >= 0) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart -= this.rangeFrames;\n            rangeStartOffset -= this.baseRangeWidth;\n          }\n          rangeStart = this._currentRangeStart + this.rangeFrames;\n          rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n          while (rangeStartOffset < width && rangeStart < this.frameCount) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart += this.rangeFrames;\n            rangeStartOffset += this.baseRangeWidth;\n          }\n        }\n      } else {\n        // draw block\n        const statusFrames = Object.keys(frameStatus).map((i) => Number(i));\n        let lastStartIndex = 0;\n        for (let i = 0; i < statusFrames.length; i += 1) {\n          if (i === statusFrames.length - 1 || statusFrames[i + 1] - statusFrames[i] > 1) {\n            const startFrame = statusFrames[lastStartIndex];\n            const endFrame = statusFrames[i] + 1;\n            let startOffset = this._currentRangeStartOffset + (startFrame - this._currentRangeStart) * this.perFrameWidth;\n            let endOffset = this._currentRangeStartOffset + (endFrame - this._currentRangeStart) * this.perFrameWidth;\n            startOffset = Math.min(Math.max(startOffset, 0), width);\n            endOffset = Math.min(Math.max(endOffset, 0), width);\n            if (endOffset > startOffset) {\n              // only draw when visible\n              drawRect(ctx, startOffset, offsetY + this.itemBlockOffsetY, endOffset - startOffset, this.itemBlockHeight, color);\n            }\n            lastStartIndex = i + 1;\n          }\n        }\n      }\n    });\n\n    if (type !== 'cards') {\n      // no need to draw vertical scroll bar when drawing cards\n      const visibleItemsCount = this.itemsTotalHeight / this.itemHeight;\n      if (visibleItemsCount < this._allItems.length) {\n        // draw scroll y\n        this._scrollYHeight = (visibleItemsCount / this._allItems.length) * this.itemsTotalHeight;\n        this._scrollYOffset = (this._itemsOffset / (this._allItems.length * this.itemHeight)) * this.itemsTotalHeight;\n        drawRoundedRect(ctx, width + this.scrollbarYOffsetX, this._scrollYOffset, this.scrollbarYWidth, this._scrollYHeight, 6, scrollbarColor);\n      } else {\n        this._scrollYHeight = 0;\n        this._scrollYOffset = 0;\n      }\n    }\n  }\n\n  /**\n   * draw invalid frame style\n   * @param ctx\n   */\n  drawInvalidFrames(ctx: CanvasRenderingContext2D) {\n    // draw invalid frames\n    this._invalidFrames.forEach((frameIndex) => {\n      const offsetX = this.getOffsetByFrame(frameIndex);\n      if (offsetX >= 0) {\n        drawRect(ctx, offsetX, 0, Math.max(this.perFrameWidth, 1 * window.devicePixelRatio), this.itemsTotalHeight, 'rgba(220, 70, 36, 0.3)');\n      }\n    });\n  }\n\n  /**\n   * draw frame hint (for current frame & hovered frame)\n   * @param ctx\n   * @param type\n   */\n  drawFrameHint(ctx: CanvasRenderingContext2D, type?: string) {\n    const frame = type === 'hover' ? this._hoveredFrame : this._currentFrame;\n    const shouldDraw = type !== 'hover' || this._hoveredFrame !== this._currentFrame;\n    if (shouldDraw) {\n      const offsetX = this.getOffsetByFrame(frame);\n      if (offsetX >= 0) {\n        if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n          // block\n          drawRect(ctx, offsetX, 0, this.perFrameWidth, this.itemsTotalHeight, 'rgba(41, 44, 56, 0.4)');\n          if (type === 'hover' && this._hoveredItemIndex >= 0) {\n            const offsetY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset;\n            drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, 'rgba(255, 255, 255, 0.4)');\n          }\n          if (type !== 'hover') {\n            const selectedIndex = this._allItems.findIndex((i) => this.items[i.id].selected);\n            const offsetY = selectedIndex * this.itemHeight - this._itemsOffset;\n            drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, '#FFFFFF');\n          }\n        } else {\n          // line\n          drawLine(ctx, offsetX + 0.5, 0, offsetX + 0.5, this.itemsTotalHeight, type === 'hover' ? 'rgba(255, 255, 255, 0.4)' : '#FFFFFF');\n        }\n      }\n    }\n  }\n\n  /**\n   * draw frame scales\n   * @param ctx\n   */\n  drawFrameScales(ctx: CanvasRenderingContext2D) {\n    if (!this._scaleEnabled) return;\n    const width = this.canvas.width - this.paddingRight;\n    const offsetY = this.itemsTotalHeight;\n    const scaleWidth = this.perFrameWidth * this.rangeFrames;\n    const scaleHeight = 16 * window.devicePixelRatio;\n    const scaleHeightShort = 4 * window.devicePixelRatio;\n\n    // draw scales top border\n    drawRect(ctx, 0, offsetY, width, offsetY, this.bgColor);\n    drawLine(ctx, 0, offsetY + 0.5, width, offsetY + 0.5, 'rgba(255, 255, 255, 0.1)');\n\n    if (this._currentRangeIndex <= this._initialRangeIndex) {\n      const rangeCount = this.frameCount / this.rangeFrames;\n      const rangeWidth = width / rangeCount;\n      if (rangeWidth > this.baseRangeWidth * 5) {\n        for (let i = 0; i < this.frameCount; i += 1) {\n          drawScale(ctx, i * this.perFrameWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i, false);\n        }\n      } else {\n        for (let i = 0; i < rangeCount; i += 1) {\n          drawScale(ctx, i * rangeWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i * this.rangeFrames);\n        }\n      }\n\n      this._scrollXWidth = 0;\n      this._scrollXOffset = 0;\n    } else {\n      let rangeStart = this._currentRangeStart;\n      let rangeStartOffset = this._currentRangeStartOffset;\n      while ((rangeStartOffset + this.baseRangeWidth) >= 0 && rangeStart >= 0) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart -= this.rangeFrames;\n        rangeStartOffset -= this.baseRangeWidth;\n      }\n      rangeStart = this._currentRangeStart + this.rangeFrames;\n      rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n      while (rangeStartOffset < width && rangeStart < this.frameCount) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart += this.rangeFrames;\n        rangeStartOffset += this.baseRangeWidth;\n      }\n    }\n\n    // draw scrollbar\n    this._scrollXWidth = Math.max(Math.ceil((width / this.perFrameWidth / this.frameCount) * width), 42);\n    this._scrollXOffset = ((this._currentRangeStart - this._currentRangeStartOffset / this.perFrameWidth) / this.frameCount) * width;\n    drawRoundedRect(ctx, this._scrollXOffset, offsetY + this.scrollbarXOffsetY, this._scrollXWidth, this.scrollbarXHeight, 6, scrollbarColor);\n  }\n\n  /**\n   * update frame tip text and posistion\n   */\n  updateFrameTip() {\n    if (this._hoveredFrame >= 0) {\n      this.frameTip.innerText = `${this._hoveredFrame + 1}`;\n      const { width } = this.frameTip.getBoundingClientRect();\n      const frameOffset = this.getOffsetByFrame(this._hoveredFrame) / window.devicePixelRatio;\n      let offset = frameOffset - width / 2;\n      if (this.currentRangeIndex === rangeFramesSet.length - 1) {\n        offset += (this.perFrameWidth / 2) / window.devicePixelRatio;\n      }\n      this.frameTip.style.left = `${offset}px`;\n      this.frameTip.style.display = 'block';\n    } else {\n      this.frameTip.style.display = 'none';\n    }\n  }\n\n  /**\n   * update items scroll and emit event\n   */\n  updateItemsScroll(itemsOffset: number) {\n    const allItemsHeight = this._allItems.length * this.itemHeight;\n    if (allItemsHeight <= this.itemsContainerHeight) {\n      // not scrollable\n      return;\n    }\n    this._itemsOffset = itemsOffset;\n    if (this._itemsOffset < 0) {\n      this._itemsOffset = 0;\n    } else if (this._itemsOffset > allItemsHeight - this.itemsTotalHeight) {\n      this._itemsOffset = allItemsHeight - this.itemsTotalHeight;\n    }\n    this.drawFrames();\n    this.emit(EventAction.ITEMS_OFFSET_CHANGE, this._itemsOffset / window.devicePixelRatio);\n  }\n\n  /**\n   * get frame by clientX\n   * @param clientX\n   * @returns\n   */\n  getFrameByClientX(clientX: number) {\n    const { left } = this.canvas.getBoundingClientRect();\n    const offset = (clientX - left) * window.devicePixelRatio;\n    let frame = this._currentRangeStart + Math.floor((offset - this._currentRangeStartOffset) / this.perFrameWidth);\n    if (frame >= this.frameCount) {\n      frame = this.frameCount - 1;\n    } else if (frame < 0) {\n      frame = 0;\n    }\n    return frame;\n  }\n\n  /**\n   * get item index by clientY\n   * @param clientY\n   * @returns\n   */\n  getItemIndexByClientY(clientY: number) {\n    const { top } = this.canvas.getBoundingClientRect();\n    const offset = (clientY - top) * window.devicePixelRatio;\n    const index = Math.floor((offset + this._itemsOffset) / this.itemHeight);\n    if (index > Object.keys(this._items).length - 1) {\n      return -1;\n    }\n    return index;\n  }\n\n  /**\n   * get offset by frame index\n   * @param frame\n   * @param checkOutside\n   * @returns\n   */\n  getOffsetByFrame(frame: number, checkOutside = true) {\n    const offset = this._currentRangeStartOffset + (frame - this._currentRangeStart) * this.perFrameWidth;\n    if (checkOutside && (offset < 0 || offset > (this.canvas.width - this.paddingRight))) {\n      return -1;\n    }\n    return offset;\n  }\n\n  /**\n   * check hover item\n   * @param clientX\n   * @param clientY\n   * @returns\n   */\n  getMouseHover(clientX: number, clientY: number) {\n    const { width: canvasWidth, height: canvasHeight } = this.canvas;\n    const { left, top, width, height } = this.canvas.getBoundingClientRect();\n    const offsetX = clientX - left;\n    const offsetY = clientY - top;\n\n    const scrollbarOffsetY = this.itemsTotalHeight + this.scrollbarXOffsetY;\n    if (\n      offsetX / width >= this._scrollXOffset / canvasWidth &&\n      offsetX / width <= (this._scrollXOffset + this._scrollXWidth) / canvasWidth &&\n      offsetY / height >= scrollbarOffsetY / canvasHeight &&\n      offsetY / height <= (scrollbarOffsetY + this.scrollbarXHeight) / canvasHeight\n    ) {\n      return HoverType.SCROLLBAR_X;\n    }\n\n    const scrollbarOffsetX = canvasWidth - this.paddingRight + this.scrollbarYOffsetX;\n    if (\n      offsetX / width >= scrollbarOffsetX / canvasWidth &&\n      offsetX / width <= (scrollbarOffsetX + this.scrollbarYWidth) / canvasWidth &&\n      offsetY / height >= this._scrollYOffset / canvasHeight &&\n      offsetY / height <= (this._scrollYOffset + this._scrollYHeight) / canvasHeight\n    ) {\n      return HoverType.SCROLLBAR_Y;\n    }\n\n    if (\n      offsetX * window.devicePixelRatio > canvasWidth - this.paddingRight &&\n      offsetX * window.devicePixelRatio <= canvasWidth\n    ) {\n      return HoverType.SCROLLBAR_Y_CONTAINER;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * set cursor for progress bar\n   * @param cursor\n   */\n  setCursor(cursor: Cursor) {\n    if (this.canvas.style.cursor !== cursor) {\n      this.canvas.style.cursor = cursor;\n    }\n  }\n\n  /**\n   * focus to specific frame if not in the progress bar view\n   * @param frame\n   */\n  focusFrame(frame: number) {\n    const offset = this.getOffsetByFrame(frame, false);\n    const right = this.canvas.width - this.paddingRight - this.perFrameWidth;\n    if (offset < 0) {\n      // move left\n      this._baseOffsetFrame = frame;\n      this._baseOffset = this.perFrameWidth;\n    } else if (offset > right) {\n      // move right\n      this._baseOffsetFrame = frame;\n      this._baseOffset = right - this.perFrameWidth;\n    }\n    this.drawFrames();\n  }\n\n  /**\n   * mouse wheel\n   * @param e\n   */\n  wheel = (e: WheelEvent) => {\n    if (e.altKey) {\n      this.zoom(e);\n    } else {\n      // scroll y\n      this.updateItemsScroll(this._itemsOffset + e.deltaY);\n    }\n  };\n\n  /**\n   * zooming\n   * @param e\n   */\n  zoom = (e: WheelEvent) => {\n    const hover = this.getMouseHover(e.clientX, e.clientY);\n    if (hover === HoverType.SCROLLBAR_Y_CONTAINER || hover === HoverType.SCROLLBAR_Y) {\n      return;\n    }\n    // zoom to scale frames\n    const { left } = this.canvas.getBoundingClientRect();\n    this._baseOffset = (e.clientX - left) * window.devicePixelRatio;\n    this._baseOffsetFrame = this.getFrameByClientX(e.clientX);\n    if (e.deltaY > 0) {\n      this._currentRangeIndex += 1;\n    } else {\n      this._currentRangeIndex -= 1;\n    }\n    this._currentRangeIndex = Math.min(Math.max(this._currentRangeIndex, this._initialRangeIndex), rangeFramesSet.length - 1);\n    this.emit(EventAction.VISIBLE_FRAMES_UPDATE, this._currentRangeIndex, rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex));\n    this.drawFrames();\n    this.canvasMove(e);\n  };\n\n  /**\n   * mouse down on canvas\n   * @param e\n   */\n  canvasDown = (e: MouseEvent) => {\n    const hover = this.getMouseHover(e.clientX, e.clientY);\n    if (hover === HoverType.SCROLLBAR_X) {\n      // click on horizontal scrollbar\n      this._isScrollXDown = true;\n      this._scrollXDownBaseOffsetFrame = this._baseOffsetFrame;\n      this._scrollXDownClientX = e.clientX;\n    } else if (hover === HoverType.SCROLLBAR_Y) {\n      // click on vertical scrollbar\n      this._isScrollYDown = true;\n      this._scrollYDownItemsOffset = this._itemsOffset;\n      this._scrollYDownClientY = e.clientY;\n    } else if (this._hoveredFrame >= 0) {\n      this.currentFrame = this._hoveredFrame;\n      this.emit(EventAction.CURRENT_FRAME_CHANGE, this._currentFrame, this._hoveredItemIndex);\n    }\n  };\n\n  /**\n   * mouse move on canvas\n   * @param e\n   */\n  canvasMove = (e: MouseEvent) => {\n    this.setCursor(Cursor.DEFAULT);\n    const hover = this.getMouseHover(e.clientX, e.clientY);\n    if (hover === HoverType.SCROLLBAR_X) {\n      // hover on horizontal scrollbar\n      this.setCursor(Cursor.POINTER);\n    } else if (hover === HoverType.SCROLLBAR_Y) {\n      this.canvasLeave();\n      this.setCursor(Cursor.POINTER);\n    } else if (hover === HoverType.SCROLLBAR_Y_CONTAINER) {\n      this.canvasLeave();\n    } else {\n      this._hoveredFrame = this.getFrameByClientX(e.clientX);\n      this._hoveredItemIndex = this.getItemIndexByClientY(e.clientY);\n      this.drawFrames();\n      this.updateFrameTip();\n    }\n  };\n\n  /**\n   * mouse leave canvas\n   */\n  canvasLeave = () => {\n    this._hoveredFrame = -1;\n    this._hoveredItemIndex = -1;\n    this.drawFrames();\n    this.updateFrameTip();\n  };\n\n  /**\n   * mouse move on document (dragging scrollbar)\n   * @param e\n   */\n  cursorMove = (e: MouseEvent) => {\n    if (this._isScrollXDown) {\n      // move horizontal scrollbar\n      const offset = (e.clientX - this._scrollXDownClientX) * window.devicePixelRatio;\n      const frames = Math.floor((offset / (this.canvas.width - this.paddingRight)) * this.frameCount);\n      this._baseOffsetFrame = this._scrollXDownBaseOffsetFrame + frames;\n      this._hoveredFrame = -1;\n      this._hoveredItemIndex = -1;\n      this.drawFrames();\n      this.updateFrameTip();\n    } else if (this._isScrollYDown) {\n      // move vertical scrollbar\n      const offset = (e.clientY - this._scrollYDownClientY) * window.devicePixelRatio;\n      const itemsOffset = this._scrollYDownItemsOffset + (offset / this.itemsContainerHeight) * this._allItems.length * this.itemHeight;\n      this.updateItemsScroll(itemsOffset);\n    }\n  };\n\n  /**\n   * mouse up on document (dragging scrollbar)\n   */\n  cursorUp = () => {\n    if (this._isScrollXDown) {\n      this._isScrollXDown = false;\n      this._scrollXDownBaseOffsetFrame = 0;\n      this._scrollXDownClientX = 0;\n    }\n    if (this._isScrollYDown) {\n      this._isScrollYDown = false;\n      this._scrollYDownItemsOffset = 0;\n      this._scrollYDownClientY = 0;\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}