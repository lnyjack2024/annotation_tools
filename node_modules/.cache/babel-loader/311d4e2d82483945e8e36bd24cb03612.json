{"ast":null,"code":"import { makeAutoObservable, toJS } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { notification } from 'antd';\nimport { isEqual } from 'lodash';\nimport i18n from '../locales';\nimport { UpdateType } from '../types';\nimport { SegmentMode, colors } from '../components/Wave/types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * channel instances map\n   * @getter\n   */\n  get channelInstancesMap() {\n    const map = {};\n    this.allInstances.forEach(instance => {\n      if (!map[instance.channelIndex]) {\n        map[instance.channelIndex] = [];\n      }\n      map[instance.channelIndex].push(instance);\n    });\n    for (let i = 0; i < this.rootStore.waveform.channelCount; i += 1) {\n      if (!map[i]) {\n        map[i] = [];\n      } else {\n        map[i].sort((a, b) => a.start - b.start);\n      }\n    }\n    return map;\n  }\n  /**\n   * selected instance\n   */\n  get selectedInstance() {\n    return this.selectedInstanceId ? toJS(this.instances[this.selectedInstanceId]) : null;\n  }\n\n  /**\n   * selected instance number\n   */\n  get selectedIndex() {\n    return this.selectedInstance ? this.displayInstances.findIndex(v => v.id === this.selectedInstanceId) : -1;\n  }\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    return Object.values(this.instances).sort((a, b) => a.start - b.start);\n  }\n  get displayInstances() {\n    return this.allInstances.filter(v => this.rootStore.waveform.hideChannels.indexOf(v.channelIndex) < 0);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * all instances\n     */\n    this.instances = {};\n    /**\n     * selected instances\n     */\n    this.selectedInstanceId = void 0;\n    /**\n     * update instances\n     */\n    this.updatedInstances = {};\n    /**\n     * get instance by id\n     * @param instanceId\n     */\n    this.getInstanceById = instanceId => this.instances[instanceId];\n    this.updateInstances = instances => {\n      this.instances = {\n        ...toJS(this.instances),\n        ...instances\n      };\n    };\n    /**\n     * set selected instance\n     */\n    this.setSelectedInstance = id => {\n      if (this.selectedInstanceId === id) return;\n      if (!this.rootStore.review.isSelectInstanceEnable) {\n        notification.error({\n          message: i18n.translate('QC_REASON_LABEL')\n        });\n        return false;\n      }\n      this.selectedInstanceId = id;\n    };\n    makeAutoObservable(this, {\n      rootStore: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(list) {\n    if (list.length) {\n      const instances = {};\n      list.forEach(instance => {\n        var _this$rootStore$ontol;\n        instances[instance.id] = {\n          ...instance,\n          color: ((_this$rootStore$ontol = this.rootStore.ontology.getCategoryByIndex(instance.channelIndex)) === null || _this$rootStore$ontol === void 0 ? void 0 : _this$rootStore$ontol.displayColor) || colors[instance.channelIndex] || '#A1A1A1'\n        };\n      });\n      this.instances = instances;\n    }\n  }\n  /**\n   * init instances of continuous mode\n   */\n  initInstances(duration, channelCount) {\n    if (this.rootStore.waveform.segmentMode === SegmentMode.CONTINUOUS) {\n      const allInstances = Object.values(toJS(this.instances)).sort((a, b) => a.start - b.start);\n      const instances = {};\n      const create = (category, channelIndex, start, end) => {\n        const id = uuidv4();\n        instances[id] = {\n          id,\n          channelIndex,\n          start,\n          end,\n          category: (category === null || category === void 0 ? void 0 : category.className) || `${channelIndex + 1}`,\n          label: (category === null || category === void 0 ? void 0 : category.displayName) || (category === null || category === void 0 ? void 0 : category.className) || `${channelIndex + 1}`,\n          color: (category === null || category === void 0 ? void 0 : category.displayColor) || colors[channelIndex] || '#A1A1A1'\n        };\n      };\n      for (let i = 0; i < channelCount; i += 1) {\n        const category = this.rootStore.ontology.getCategoryByIndex(i);\n        const channelInstances = allInstances.filter(ins => ins.channelIndex === i);\n        if (channelInstances.length > 0) {\n          let prevEnd = 0;\n          channelInstances.forEach((ins, n) => {\n            if (ins.start > prevEnd) {\n              create(category, i, prevEnd, ins.start);\n            }\n            instances[ins.id] = ins;\n            prevEnd = ins.end;\n            if (n === channelInstances.length - 1 && ins.end < duration) {\n              create(category, i, ins.end, duration);\n            }\n          });\n        } else {\n          create(category, i, 0, duration);\n        }\n      }\n      this.instances = instances;\n    }\n  }\n\n  /**\n   * delete instance\n   * @param id\n   */\n  deleteInstance(id) {\n    if (!this.rootStore.review.drawMode) return;\n    if (this.instances[id]) {\n      const updatedInstances = {};\n      if (this.rootStore.waveform.segmentMode === SegmentMode.CONTINUOUS) {\n        const {\n          channelIndex,\n          start,\n          end\n        } = this.instances[id];\n        if (start === 0 && end === 0) return;\n        if (start === 0) {\n          const nextInstance = this.channelInstancesMap[channelIndex].find(i => i.start === end);\n          if (nextInstance) {\n            updatedInstances[nextInstance.id] = {\n              ...toJS(nextInstance),\n              start: 0\n            };\n            updatedInstances[id] = null;\n          }\n        } else {\n          const prevInstance = this.channelInstancesMap[channelIndex].find(i => i.end === start);\n          if (prevInstance) {\n            updatedInstances[prevInstance.id] = {\n              ...toJS(prevInstance),\n              end\n            };\n            updatedInstances[id] = null;\n          }\n        }\n      } else {\n        updatedInstances[id] = null;\n      }\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n  /**\n   * set updated instances\n   */\n  setUpdatedInstances(instances, type) {\n    const ids = Object.keys(instances);\n    if (ids.length === 0) {\n      return;\n    }\n    if (type !== UpdateType.INIT) {\n      const updatedInstances = {};\n      const oldInstances = {};\n      ids.forEach(id => {\n        const oldInstance = this.instances[id];\n        oldInstances[id] = oldInstance ? toJS(oldInstance) : null;\n        const instance = instances[id];\n        if (isEqual(instance, oldInstance) === false) {\n          if (instance) {\n            updatedInstances[id] = instance;\n          } else {\n            delete this.instances[id];\n            if (this.selectedInstanceId === id) {\n              this.selectedInstanceId = undefined;\n            }\n          }\n        }\n      });\n      if (type !== UpdateType.UNDOREDO && type !== UpdateType.REMOVE_MISSED) {\n        this.changeUndo(oldInstances, instances);\n      }\n      this.updateInstances(updatedInstances);\n    }\n\n    // store change => canvas change\n    if (type !== UpdateType.MODIFY) {\n      this.updatedInstances = instances;\n    }\n  }\n  changeUndo(oldInstances, updatedInstances) {\n    const before = [];\n    const after = [];\n    before.push({\n      type: 'instance',\n      status: {\n        ...oldInstances\n      }\n    });\n    after.push({\n      type: 'instance',\n      status: {\n        ...updatedInstances\n      }\n    });\n    this.rootStore.undo.saveStatus(before, after);\n  }\n}","map":{"version":3,"names":["makeAutoObservable","toJS","v4","uuidv4","notification","isEqual","i18n","UpdateType","SegmentMode","colors","InstanceStore","channelInstancesMap","map","allInstances","forEach","instance","channelIndex","push","i","rootStore","waveform","channelCount","sort","a","b","start","selectedInstance","selectedInstanceId","instances","selectedIndex","displayInstances","findIndex","v","id","Object","values","filter","hideChannels","indexOf","constructor","updatedInstances","getInstanceById","instanceId","updateInstances","setSelectedInstance","review","isSelectInstanceEnable","error","message","translate","autoBind","init","list","length","_this$rootStore$ontol","color","ontology","getCategoryByIndex","displayColor","initInstances","duration","segmentMode","CONTINUOUS","create","category","end","className","label","displayName","channelInstances","ins","prevEnd","n","deleteInstance","drawMode","nextInstance","find","prevInstance","setUpdatedInstances","type","ids","keys","INIT","oldInstances","oldInstance","undefined","UNDOREDO","REMOVE_MISSED","changeUndo","MODIFY","before","after","status","undo","saveStatus"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/store/InstanceStore.ts"],"sourcesContent":["import { makeAutoObservable, toJS } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { notification } from 'antd';\nimport { isEqual } from 'lodash';\nimport RootStore from './RootStore';\nimport { Status } from './UndoStore';\nimport i18n from '../locales';\nimport { Instance, UpdateType, Category } from '../types';\nimport { SegmentMode, colors } from '../components/Wave/types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * all instances\n   */\n  instances: { [instanceId: string]: Instance } = {};\n\n  /**\n   * selected instances\n   */\n  selectedInstanceId: string | undefined;\n\n  /**\n   * update instances\n   */\n  updatedInstances: { [id: string]: Instance | null } = {};\n\n  /**\n   * channel instances map\n   * @getter\n   */\n  get channelInstancesMap() {\n    const map: { [channelIndex: number]: Instance[] } = {};\n    this.allInstances.forEach((instance) => {\n      if (!map[instance.channelIndex]) {\n        map[instance.channelIndex] = [];\n      }\n      map[instance.channelIndex].push(instance);\n    });\n    for (let i = 0; i < this.rootStore.waveform.channelCount; i += 1) {\n      if (!map[i]) {\n        map[i] = [];\n      } else {\n        map[i].sort((a, b) => a.start - b.start);\n      }\n    }\n    return map;\n  };\n\n  /**\n   * selected instance\n   */\n  get selectedInstance() {\n    return this.selectedInstanceId ? toJS(this.instances[this.selectedInstanceId]) : null;\n  }\n\n  /**\n   * selected instance number\n   */\n  get selectedIndex() {\n    return this.selectedInstance ? this.displayInstances.findIndex((v) => v.id === this.selectedInstanceId) : -1;\n  };\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    return Object.values(this.instances).sort((a, b) => a.start - b.start);\n  }\n\n  get displayInstances() {\n    return this.allInstances.filter((v) => this.rootStore.waveform.hideChannels.indexOf(v.channelIndex) < 0);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(list: Instance[]) {\n    if (list.length) {\n      const instances: {[id: string]: Instance} = {};\n      list.forEach((instance) => {\n        instances[instance.id] = {\n          ...instance,\n          color: this.rootStore.ontology.getCategoryByIndex(instance.channelIndex)?.displayColor || colors[instance.channelIndex] || '#A1A1A1',\n        };\n      });\n      this.instances = instances;\n    }\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById = (instanceId: string) => this.instances[instanceId];\n\n  /**\n   * init instances of continuous mode\n   */\n  initInstances(duration: number, channelCount: number) {\n    if (this.rootStore.waveform.segmentMode === SegmentMode.CONTINUOUS) {\n      const allInstances = Object.values(toJS(this.instances)).sort((a, b) => a.start - b.start);\n      const instances: {[id: string]: Instance} = {};\n      const create = (category: Category, channelIndex: number, start: number, end: number) => {\n        const id = uuidv4();\n        instances[id] = {\n          id,\n          channelIndex,\n          start,\n          end,\n          category: category?.className || `${channelIndex + 1}`,\n          label: category?.displayName || category?.className || `${channelIndex + 1}`,\n          color: category?.displayColor || colors[channelIndex] || '#A1A1A1',\n        };\n      };\n      for (let i = 0; i < channelCount; i += 1) {\n        const category = this.rootStore.ontology.getCategoryByIndex(i);\n        const channelInstances = allInstances.filter((ins) => ins.channelIndex === i);\n        if (channelInstances.length > 0) {\n          let prevEnd = 0;\n          channelInstances.forEach((ins, n) => {\n            if (ins.start > prevEnd) {\n              create(category, i, prevEnd, ins.start);\n            }\n            instances[ins.id] = ins;\n            prevEnd = ins.end;\n            if (n === channelInstances.length - 1 && ins.end < duration) {\n              create(category, i, ins.end, duration);\n            }\n          });\n        } else {\n          create(category, i, 0, duration);\n        }\n      }\n      this.instances = instances;\n    }\n  }\n\n  /**\n   * delete instance\n   * @param id\n   */\n  deleteInstance(id: string) {\n    if (!this.rootStore.review.drawMode) return;\n    if (this.instances[id]) {\n      const updatedInstances: { [id: string]: Instance | null; } = {};\n      if (this.rootStore.waveform.segmentMode === SegmentMode.CONTINUOUS) {\n        const { channelIndex, start, end } = this.instances[id];\n        if (start === 0 && end === 0) return;\n        if (start === 0) {\n          const nextInstance = this.channelInstancesMap[channelIndex].find((i) => i.start === end);\n          if (nextInstance) {\n            updatedInstances[nextInstance.id] = {\n              ...toJS(nextInstance),\n              start: 0\n            };\n            updatedInstances[id] = null;\n          }\n        } else {\n          const prevInstance = this.channelInstancesMap[channelIndex].find((i) => i.end === start);\n          if (prevInstance) {\n            updatedInstances[prevInstance.id] = {\n              ...toJS(prevInstance),\n              end\n            };\n            updatedInstances[id] = null;\n          }\n        }\n      } else {\n        updatedInstances[id] = null;\n      }\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n\n  updateInstances = (instances: { [id: string]: Instance }) => {\n    this.instances = {\n      ...toJS(this.instances),\n      ...instances\n    };\n  };\n\n  /**\n   * set updated instances\n   */\n  setUpdatedInstances(instances: { [id: string]: Instance | null }, type?: string) {\n    const ids = Object.keys(instances);\n    if (ids.length === 0) {\n      return;\n    }\n    if (type !== UpdateType.INIT) {\n      const updatedInstances: { [id: string]: Instance } = {};\n      const oldInstances: { [id: string]: Instance | null } = {};\n      ids.forEach((id) => {\n        const oldInstance = this.instances[id];\n        oldInstances[id] = oldInstance ? toJS(oldInstance) : null;\n        const instance = instances[id];\n        if (isEqual(instance, oldInstance) === false) {\n          if (instance) {\n            updatedInstances[id] = instance;\n          } else {\n            delete this.instances[id];\n            if (this.selectedInstanceId === id) {\n              this.selectedInstanceId = undefined;\n            }\n          }\n        }\n      });\n      if (type !== UpdateType.UNDOREDO && type !== UpdateType.REMOVE_MISSED) {\n        this.changeUndo(oldInstances, instances);\n      }\n      this.updateInstances(updatedInstances);\n    }\n\n    // store change => canvas change\n    if (type !== UpdateType.MODIFY) {\n      this.updatedInstances = instances;\n    }\n  }\n\n  changeUndo(\n    oldInstances: { [id: string]: Instance | null },\n    updatedInstances: { [id: string]: Instance | null }\n  ) {\n    const before: Status[] = [];\n    const after: Status[] = [];\n    before.push({ type: 'instance',\n      status: {\n        ...oldInstances,\n      }\n    });\n    after.push({ type: 'instance',\n      status: {\n        ...updatedInstances,\n      }\n    });\n    this.rootStore.undo.saveStatus(before, after);\n  }\n\n  /**\n   * set selected instance\n   */\n  setSelectedInstance = (id?: string) => {\n    if (this.selectedInstanceId === id) return;\n    if (!this.rootStore.review.isSelectInstanceEnable) {\n      notification.error({ message: i18n.translate('QC_REASON_LABEL') });\n      return false;\n    }\n    this.selectedInstanceId = id;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}