{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/TextAnnotationApp.jsx\";\n/* eslint-disable no-nested-ternary */\n/* eslint-disable react/no-access-state-in-setstate */\n/* eslint-disable no-undef */\n/* eslint-disable no-underscore-dangle */\nimport React, { createContext } from 'react';\nimport { Editor, EditorState, convertFromRaw, getDefaultKeyBinding } from 'draft-js';\nimport { notification, message } from 'antd';\nimport { uniq } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport localMessage, { setLocale } from './locale';\nimport { LabelTag, InsertionTag, ConnectionTag } from './components/tag';\nimport { isAnnotationReadonly, isRework, isReviewEditable, isPreview } from '../../utils/tool-mode';\nimport Sidebar from './components/sidebar';\nimport { genTagMap, renderTagMap, genDisplayLabels } from './utils/tagMapUtil';\nimport ReviewForm from './components/reviewForm';\nimport UndoRedo from './components/UndoRedo';\nimport ReviewMode from './components/ReviewMode';\nimport Save from './components/Save';\nimport { isAppenCloud } from '../../utils';\nimport AppenLogo from '../common/AppenLogo';\nimport store from './store/RootStore';\nimport './TextAnnotationApp.scss';\nimport 'draft-js/dist/Draft.css';\nimport { FIND_BLOCK, FIND_BLOCK_SELECTED, FOCUS_COLOR, DEFAULT_COLOR, FONT_COLOR, BASE_COLOR, HISTORY_SIZE, FONT_SIZE, TAG_HEIGHT, LINE_HEIGHT, EDITOR_PADDING, COMPOSITION, SELECTION, ACTION, KEY_COMMAND, RECALL_TYPE, HOVER_COLOR, FONT_SPACE, FOCUS_TYPE, HOVER_ALPHA, ACTIVE_ALPHA, DEFAULT_ALPHA } from './store/constant';\nimport { isArabic, convertArrayToColor, convertColorToArray, getSliceHead, setSelection, closeSelection, getTextByInsertion, getTargetWrapperDataSet, isElementInViewport, escapeCharacter, getConfigByKeys } from './utils/helper';\nimport { isLabel, isInsertion, isConnection, isQATag } from './store/tag_mode';\nimport { ReviewItemResult, TAG, ReviewMode as ReviewModeType } from './types';\nimport TagInfoMap from './utils/TagInfoMap';\nconst storageKey = 'text-annotation-label-content';\nlet defaultLabelsDrawerFlag = false;\ntry {\n  const s = localStorage.getItem(storageKey);\n  defaultLabelsDrawerFlag = s === 'true';\n} catch (e) {\n  // get error\n}\nexport const TextToolContext = createContext();\nexport default class TextAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.addHistory = (type, data) => {\n      let targetList;\n      if (this.undoLock) {\n        // Add history to redo list\n        targetList = this.redoList;\n      } else if (this.redoLock) {\n        // Add history back to undo list\n        targetList = this.undoList;\n        // Clear redo list\n      } else {\n        // Add history to redo list\n        targetList = this.undoList;\n        this.redoList = [];\n      }\n      let {\n        length\n      } = targetList;\n      if (length > HISTORY_SIZE) {\n        targetList.shift();\n        length -= 1;\n      }\n      if (type === ACTION.EDIT_SINGLE_ADD && length >= 1) {\n        const prev = targetList[length - 1];\n        if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_ADD) && prev.data.prevSlice === '' && prev.data.end === data.prevStart) {\n          targetList.pop();\n          targetList.push({\n            type: ACTION.EDIT_DEFAULT,\n            data: {\n              prevSlice: '',\n              slice: prev.data.slice + data.slice,\n              prevStart: prev.data.prevStart,\n              prevEnd: prev.data.prevEnd,\n              start: data.start,\n              end: data.end\n            }\n          });\n        } else targetList.push({\n          type,\n          data\n        });\n      } else if (type === ACTION.EDIT_SINGLE_DEL && length >= 1) {\n        const prev = targetList[length - 1];\n        if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_DEL) && prev.data.slice === '' && data.prevEnd === prev.data.start) {\n          targetList.pop();\n          targetList.push({\n            type: ACTION.EDIT_DEFAULT,\n            data: {\n              slice: '',\n              prevSlice: data.prevSlice + prev.data.prevSlice,\n              prevStart: data.end,\n              prevEnd: prev.data.prevEnd,\n              start: data.start,\n              end: data.end\n            }\n          });\n        } else targetList.push({\n          type,\n          data\n        });\n      } else targetList.push({\n        type,\n        data\n      });\n    };\n    this.executeHistory = recallType => {\n      // Execute history\n      let targetList;\n      if (recallType === RECALL_TYPE.UNDO) {\n        // Get from undo list\n        this.undoLock = true;\n        targetList = this.undoList;\n      } else if (recallType === RECALL_TYPE.REDO) {\n        // Get from redo list\n        this.redoLock = true;\n        targetList = this.redoList;\n      }\n      if (targetList.length === 0) {\n        this.undoLock = false;\n        this.redoLock = false;\n        return;\n      }\n      const item = targetList.pop();\n      const {\n        data\n      } = item;\n      let nextEditorState = this.state.editorState;\n      switch (item.type) {\n        case ACTION.EDIT_SINGLE_ADD:\n        case ACTION.EDIT_SINGLE_DEL:\n        case ACTION.EDIT_DEFAULT:\n        case ACTION.EDIT_REPLACE:\n          {\n            const newData = {\n              prevSlice: data.slice,\n              slice: data.prevSlice,\n              start: data.prevEnd,\n              end: data.prevEnd,\n              prevStart: data.prevStart,\n              prevEnd: data.end,\n              ...(item.type === ACTION.EDIT_REPLACE && {\n                tags: data.prevTags,\n                prevTags: data.tags\n              })\n            };\n            // nextEditorState = this.onContentChange(nextEditorState, newData);\n            nextEditorState = setSelection(this.onContentChange(nextEditorState, newData, item.type), newData.start, newData.end);\n            break;\n          }\n        case ACTION.ADD_INSERTION:\n          {\n            const {\n              type,\n              id\n            } = data.insertion;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.ADD_LABEL:\n          {\n            const {\n              type,\n              id\n            } = data.label;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.ADD_MISSING_REVIEW:\n          {\n            const {\n              preReview,\n              id\n            } = data;\n            if (preReview) {\n              const {\n                editorState\n              } = this.addReview(nextEditorState, id, {\n                ...preReview\n              });\n              nextEditorState = editorState;\n            } else {\n              const {\n                editorState\n              } = this.deleteQATag(id);\n              nextEditorState = editorState;\n            }\n            break;\n          }\n        case ACTION.ADD_CONNECTION:\n          {\n            const {\n              type,\n              id\n            } = data;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.DEL_LABEL:\n          {\n            const {\n              relatedConnections,\n              label\n            } = data;\n            nextEditorState = this.addLabel(nextEditorState, label, relatedConnections);\n            break;\n          }\n        case ACTION.DEL_MISSING_REVIEW:\n          {\n            const {\n              label,\n              review\n            } = data;\n            const {\n              editorState\n            } = this.addQALabel(nextEditorState, label, {\n              ...review\n            });\n            nextEditorState = editorState;\n            break;\n          }\n        case ACTION.DEL_INSERTION:\n          {\n            const {\n              relatedConnections,\n              insertion\n            } = data;\n            nextEditorState = this.addInsertion(nextEditorState, insertion, relatedConnections);\n            break;\n          }\n        case ACTION.DEL_CONNECTION:\n          {\n            const {\n              connection\n            } = data;\n            nextEditorState = this.addConnection(nextEditorState, connection);\n            break;\n          }\n        case ACTION.EDIT_REPLACE_ALL:\n          {\n            const {\n              text: currentText,\n              prevText,\n              prevResults,\n              results\n            } = data;\n            store.ontology.text = prevText;\n            store.ontology.setResults(prevResults);\n            this.raw = this.renderTextArea(prevText);\n            nextEditorState = EditorState.set(nextEditorState, {\n              currentContent: convertFromRaw(this.raw)\n            });\n            this.addHistory(ACTION.EDIT_REPLACE_ALL, {\n              text: prevText,\n              prevText: currentText,\n              prevResults: results,\n              results: prevResults\n            });\n            break;\n          }\n        case ACTION.ADD_REVIEW:\n          {\n            const {\n              preReview,\n              id\n            } = data;\n            if (preReview) {\n              const {\n                editorState\n              } = this.addReview(nextEditorState, id, {\n                ...preReview\n              });\n              nextEditorState = editorState;\n            } else {\n              const {\n                editorState\n              } = this.deleteReview(id);\n              nextEditorState = editorState;\n            }\n            break;\n          }\n        case ACTION.DELETE_REVIEW:\n          {\n            const {\n              review,\n              id\n            } = data;\n            const {\n              editorState\n            } = this.addReview(nextEditorState, id, {\n              ...review\n            });\n            nextEditorState = editorState;\n            break;\n          }\n        case ACTION.ADD_REVIEWS:\n          {\n            nextEditorState = this.deleteReviewItems(data);\n            break;\n          }\n        case ACTION.DELETE_REVIEWS:\n          {\n            nextEditorState = this.addReviewItems(nextEditorState, data);\n            break;\n          }\n        default:\n          break;\n      }\n      this.renderAndSave(nextEditorState);\n      this.undoLock = false;\n      this.redoLock = false;\n    };\n    this.renderAndSave = (_editorState, shouldRenderTags = true, shouldResetCurrentState = false, shouldSaveURL = false) => {\n      const editorState = _editorState || this.state.editorState;\n      const {\n        hasFocus\n      } = editorState.getSelection();\n      const top = this.editorWrapper.scrollTop;\n      // window.ew = this.editorWrapper;\n      return new Promise(resolve => {\n        if (shouldResetCurrentState) {\n          this.resetCurrentFrom();\n        }\n        this.setState({\n          editorState\n        });\n        if (shouldSaveURL) {\n          this.exportResult();\n        }\n        resolve();\n      }).then(() => {\n        if (shouldRenderTags) {\n          const {\n            nextEditorState,\n            tagMap\n          } = this.measureTags(editorState);\n          return new Promise(resolve => {\n            this.setState({\n              editorState: nextEditorState\n            }, () => {\n              store.ontology.updateOntologiesStatusMap();\n            });\n            resolve(tagMap);\n          });\n        }\n      }).then(tagMap => {\n        if (shouldRenderTags) {\n          this.renderTags(tagMap);\n          return new Promise(resolve => {\n            this.setState({\n              editorWidth: this.editorWrapper.offsetWidth - EDITOR_PADDING * 2,\n              editorHeight: this.editorWrapper.scrollHeight - EDITOR_PADDING * 2,\n              tagMap\n            });\n            resolve();\n          });\n        }\n      }).then(() => {\n        if (hasFocus) {\n          // move back to current selection after composition end\n          if (this.compositionTop >= 0) {\n            this.editor.focus({\n              y: this.compositionTop\n            });\n            this.compositionTop = -1;\n          } else this.editor.focus({\n            y: top\n          });\n        }\n        return new Promise(resolve => resolve());\n      }).then(() => {\n        const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n        this.setState({\n          displayLabels\n        });\n      });\n    };\n    this.updateEditorAndRender = options => {\n      let {\n        editorState\n      } = this.state;\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      if (options && typeof options[Symbol.iterator] === 'function') {\n        return this.renderAndSave(editorState, ...options);\n      }\n      return this.renderAndSave(editorState);\n    };\n    this.onChange = editorState => {\n      // ignore composition operation\n      if (this.compositionFlag === COMPOSITION.ENABLED) return;\n      // get operation type ( handled operation not included )\n      const prevEditorState = this.state.editorState;\n      const prevText = store.ontology.text;\n      const text = editorState.getCurrentContent().getPlainText();\n      let prevStart = prevEditorState.getSelection().getStartOffset();\n      const prevEnd = prevEditorState.getSelection().getEndOffset();\n      const start = editorState.getSelection().getStartOffset();\n      const end = editorState.getSelection().getEndOffset();\n      const {\n        hasFocus\n      } = editorState.getSelection();\n      const {\n        hasFocus: prevFocus\n      } = prevEditorState.getSelection();\n      if (hasFocus !== prevFocus) {\n        // when focus change update new editor state and return without doing anything\n        const nextEditorState = EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        });\n        this.renderAndSave(nextEditorState, null, false);\n        return;\n      }\n      if (this.inputFlag || this.pasteFlag || this.compositionFlag === COMPOSITION.PENDING || prevText !== text) {\n        /* text changed:\n         * 1. deleted by delete key\n         * 2. deleted by drag + delete key\n         * 3. deleted by drag + cut operation\n         * 4. insert/replace by (drag) + simply typing\n         * 5. insert/replace by (drag) + composition typing\n         * 6. insert/replace by (drag) + paste operation\n         * 7. redo && undo\n         */\n        if (prevStart === prevEnd && start === prevStart - 1) prevStart -= 1;\n        const prevSlice = prevText.slice(prevStart, prevEnd);\n        const slice = text.slice(prevStart, end);\n        const data = {\n          prevSlice,\n          slice,\n          prevStart,\n          prevEnd,\n          start,\n          end\n        };\n        const nextEditorState = this.onContentChange(editorState, data);\n        // reset flag\n        this.inputFlag = false;\n        this.pasteFlag = false;\n        this.compositionFlag = COMPOSITION.DISABLED;\n        this.renderAndSave(nextEditorState);\n      } else {\n        /* selection changed\n         * 1. simply select\n         * 2. click select: add insertion\n         * 3. drag select: add label\n         */\n        const data = {\n          start,\n          end\n        };\n        const {\n          nextEditorState,\n          type\n        } = this.onSelectionChange(editorState, data);\n        const shouldRender = type !== SELECTION.MOVE;\n        this.renderAndSave(nextEditorState, shouldRender, shouldRender);\n      }\n    };\n    this.renderTags = tagMap => {\n      const spanMap = this.getAnchorElementsByHeads();\n      const newTagMap = renderTagMap(tagMap, spanMap);\n      return newTagMap;\n    };\n    this.onSave = async () => {\n      if (isPreview(this.toolMode)) return;\n      try {\n        if (!isAnnotationReadonly(this.toolMode)) {\n          await this.exportResult();\n        }\n        if (isReviewEditable(this.toolMode)) {\n          await this.submitReviews(false);\n        }\n        message.success(localMessage('saveSuccess'));\n      } catch (e) {\n        message.warning(localMessage('saveFail'));\n      }\n    };\n    this.onSubmit = async params => {\n      const invalid = params && params.validityFlag === 'false';\n      if (store.config.submitCheck && (!invalid || !store.config.skipCheckForInvalidData)) {\n        // validate before submit\n        await store.validation.defaultSync();\n        if (store.validation.blocked) {\n          throw new Error(localMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n      return this.exportResult(true);\n    };\n    this.exportResult = (isSubmit = false) => {\n      if (isAnnotationReadonly(this.toolMode)) return;\n      return store.saveResult(isSubmit);\n    };\n    this.measureTags = editorState => {\n      const {\n        raw\n      } = this;\n      const {\n        text\n      } = store.ontology;\n      const {\n        labels,\n        insertions\n      } = store.ontology.getResults();\n      const spanMap = this.getAnchorElementsByHeads();\n      const offsetTops = uniq(labels.map(label => {\n        var _spanMap$get;\n        return (_spanMap$get = spanMap.get(label.start)) === null || _spanMap$get === void 0 ? void 0 : _spanMap$get.offsetTop;\n      }).concat(insertions.map(insertion => {\n        var _spanMap$get2;\n        return (_spanMap$get2 = spanMap.get(insertion.at)) === null || _spanMap$get2 === void 0 ? void 0 : _spanMap$get2.offsetTop;\n      })));\n      const occupyMap = new Map();\n      offsetTops.forEach(offsetTop => {\n        occupyMap.set(offsetTop, []);\n      });\n\n      // get label offsets\n      const tagMap = genTagMap(store.ontology.getResults(), store.ontology.ontologyConfigMap, spanMap, occupyMap, text);\n      const ranges = raw.blocks[0].inlineStyleRanges;\n      const style = {\n        ...this.state.style\n      };\n      ranges.filter(item => item.style.slice(0, 6) === 'ANCHOR').forEach(item => {\n        const span = this.getAnchorElementByHead(item.offset);\n        if (span) {\n          const occupyList = occupyMap.get(span.offsetTop);\n          const lineHeight = occupyList.map(it => it.top > 0 ? it.top - FONT_SIZE + TAG_HEIGHT : -it.top).sort((a, b) => a - b).pop() * 2 + LINE_HEIGHT;\n          style[`LINEHEIGHT_${lineHeight}`] = {\n            lineHeight: `${lineHeight}px`\n          };\n          ranges.push({\n            offset: item.offset,\n            length: item.length,\n            style: `LINEHEIGHT_${lineHeight}`\n          });\n        }\n      });\n      const nextEditorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      this.setState({\n        style\n      });\n      return {\n        nextEditorState,\n        tagMap\n      };\n    };\n    this.onSelectionChange = (editorState, data) => {\n      const {\n        start,\n        end\n      } = data;\n      const {\n        currentBrush\n      } = this.state;\n      if (!this.mouseFlag) {\n        return {\n          nextEditorState: editorState,\n          type: SELECTION.MOVE\n        };\n      }\n      if (start === end && isInsertion(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n        const fbAt = strlen(store.ontology.text.slice(0, start));\n        const nextEditorState = this.addInsertion(editorState, {\n          at: fbAt,\n          value: currentBrush.text,\n          keys: currentBrush.keys,\n          type: TAG.INSERTION\n        });\n        return {\n          nextEditorState,\n          type: SELECTION.CLICK\n        };\n      }\n      if (start !== end && isLabel(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n        const fbStart = strlen(store.ontology.text.slice(0, start));\n        const fbEnd = strlen(store.ontology.text.slice(0, end));\n        if (isQATag(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n          const {\n            editorState: nextEditorState\n          } = this.addQALabel(editorState, {\n            start: fbStart,\n            end: fbEnd,\n            value: currentBrush.text,\n            keys: currentBrush.keys,\n            type: currentBrush.type\n          }, {\n            result: ReviewItemResult.MISSING\n          }, true, true);\n          return {\n            nextEditorState,\n            type: SELECTION.DRAG\n          };\n        }\n        const nextEditorState = this.addLabel(editorState, {\n          start: fbStart,\n          end: fbEnd,\n          value: currentBrush.text,\n          keys: currentBrush.keys,\n          type: currentBrush.type\n        });\n        return {\n          nextEditorState,\n          type: SELECTION.DRAG\n        };\n      }\n      return {\n        nextEditorState: editorState,\n        type: SELECTION.MOVE\n      };\n    };\n    this.deleteTag = (type, id) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (isQATag(type) && store.config.reviewMode !== ReviewModeType.REVIEW) {\n        return editorState;\n      }\n      if (!isQATag(type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n        return;\n      }\n      if (isAnnotationReadonly(this.toolMode)) {\n        return editorState;\n      }\n      const operation = store.ontology.deleteTag(type, id);\n      switch (true) {\n        case isLabel(type):\n          this.addHistory(ACTION.DEL_LABEL, operation);\n          break;\n        case isConnection(type):\n          this.addHistory(ACTION.DEL_CONNECTION, operation);\n          break;\n        case isInsertion(type):\n          this.addHistory(ACTION.DEL_INSERTION, operation);\n          break;\n        default:\n          break;\n      }\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.addInsertion = (editorState, {\n      at,\n      value,\n      id,\n      keys,\n      type\n    }, relatedConnections = []) => {\n      const {\n        state: {\n          currentBrush\n        },\n        toolMode\n      } = this;\n      const {\n        text\n      } = store.ontology;\n      if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n      if (at === strlen(text)) return editorState; // prevent insert to the end of content\n      // eslint-disable-next-line no-restricted-syntax\n      for (const item of store.ontology.results.insertions) {\n        if (item.at === at && item.value === currentBrush.text) return editorState;\n      }\n      if (!id) id = uuidv4();\n      const arabic = isArabic(substr(text, at));\n      if (arabic && at) at -= 1;\n      const newItem = {\n        type,\n        at,\n        value,\n        id,\n        text: getTextByInsertion(store.ontology.text, {\n          at,\n          value\n        }),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_INSERTION, {\n        insertion: newItem,\n        relatedConnections\n      });\n      store.ontology.addResultItem(newItem, relatedConnections);\n      this.raw = this.renderTextArea();\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return editorState;\n    };\n    this.addConnection = (editorState, {\n      fromId,\n      fromType,\n      toId,\n      toType,\n      value,\n      id,\n      keys,\n      type\n    }) => {\n      const {\n        state: {\n          currentBrush\n        },\n        toolMode\n      } = this;\n      if (isAnnotationReadonly(toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n      if (fromId === toId) return editorState;\n      if (isQATag(fromType) || isQATag(toType)) return editorState; // can't add connection for qa tool\n\n      if (store.ontology.results.connections.some(item => item.fromId === fromId && item.toId === toId && item.value === currentBrush.text)) return editorState;\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        fromId,\n        fromType,\n        toId,\n        toType,\n        value,\n        id,\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_CONNECTION, newItem);\n      store.ontology.addResultItem(newItem);\n      this.raw = this.renderTextArea();\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      return editorState;\n    };\n    this.addLabel = (editorState, {\n      start,\n      end,\n      value,\n      id,\n      keys,\n      type\n    }, relatedConnections = []) => {\n      const {\n        toolMode\n      } = this;\n      const {\n        ontology,\n        config\n      } = store;\n      const {\n        text\n      } = store.ontology;\n      if (config.reviewMode === ReviewModeType.REVIEW && !isQATag(type)) return editorState;\n      if (isAnnotationReadonly(this.toolMode) && !isQATag(type)) return editorState;\n      if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return editorState; // qa mode can only use qa tool, work mode can only use normal tool\n\n      // slice should not begin with \\n\n      if (substr(text, start, 1) === '\\n') return editorState;\n      if (ontology.results.labels.some(item => item.start === start && item.end === end && item.value === value)) return editorState;\n\n      // generate new label\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        start,\n        end,\n        value,\n        id,\n        text: substr(text, start, end - start),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_LABEL, {\n        label: newItem,\n        relatedConnections\n      });\n      ontology.addResultItem(newItem, relatedConnections);\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return editorState;\n    };\n    this.addQALabel = (editorState, {\n      start,\n      end,\n      value,\n      id,\n      keys,\n      type\n    }, reviewInfo, needUnRedo = true, needOpenReview = false) => {\n      const {\n        toolMode\n      } = this;\n      const {\n        ontology,\n        config,\n        review\n      } = store;\n      const {\n        text\n      } = ontology;\n      if (config.reviewMode === ReviewModeType.REVIEW && !isQATag(type)) return {\n        editorState,\n        operation: null\n      };\n      if (isAnnotationReadonly(this.toolMode) && !isQATag(type)) return {\n        editorState,\n        operation: null\n      };\n      if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return {\n        editorState,\n        operation: null\n      }; // qa mode can only use qa tool, work mode can only use normal tool\n\n      // slice should not begin with \\n\n      if (substr(text, start, 1) === '\\n') return {\n        editorState,\n        operation: null\n      };\n      if (review.reviews.missing.some(item => item.start === start && item.end === end && item.value === value)) return {\n        editorState,\n        operation: null\n      };\n\n      // generate new label\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        start,\n        end,\n        value,\n        id,\n        text: substr(text, start, end - start),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      if (needOpenReview) {\n        this.setState({\n          tagOpenReview: {\n            ...newItem\n          }\n        });\n      }\n      const operation = review.addMissingReview(newItem, id, {\n        ...reviewInfo\n      });\n      if (needUnRedo) {\n        this.addHistory(ACTION.ADD_MISSING_REVIEW, operation);\n      }\n\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return {\n        editorState,\n        operation\n      };\n    };\n    this.deleteQATag = (id, needUnRedo = true) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (store.config.reviewMode !== ReviewModeType.REVIEW) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      if (isAnnotationReadonly(this.toolMode)) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      const operation = store.review.deleteMissingReview(id);\n      if (needUnRedo) {\n        this.addHistory(ACTION.DEL_MISSING_REVIEW, operation);\n      }\n      this.raw = this.renderTextArea();\n      return {\n        editorState: EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        }),\n        operation\n      };\n    };\n    this.deleteReview = (reviewId, needUnRedo = true) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      const operation = store.review.deleteReview(reviewId);\n      if (needUnRedo) {\n        this.addHistory(ACTION.DELETE_REVIEW, operation);\n      }\n      this.raw = this.renderTextArea();\n      return {\n        editorState: EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        }),\n        operation\n      };\n    };\n    this.addReview = (editorState, reviewId, review, needUnRedo = true) => {\n      const {\n        state: {\n          editorState: currEditorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState: currEditorState,\n          operation: null\n        };\n      }\n      const operation = store.review.setReview(reviewId, {\n        ...review\n      });\n      if (needUnRedo) {\n        this.addHistory(ACTION.ADD_REVIEW, operation);\n      }\n      this.raw = this.renderTextArea();\n      return {\n        editorState: EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        }),\n        operation\n      };\n    };\n    this.deleteReviewItemById = reviewId => {\n      if (reviewId) {\n        let nextEditorState = this.state.editorState;\n        const reviewItem = store.ontology.getItemById(reviewId);\n        if (reviewItem && isQATag(reviewItem.type)) {\n          const {\n            editorState\n          } = this.deleteQATag(reviewItem.id);\n          nextEditorState = editorState;\n        } else {\n          const {\n            editorState\n          } = this.deleteReview(reviewId);\n          nextEditorState = editorState;\n        }\n        this.renderAndSave(nextEditorState);\n      }\n    };\n    this.deleteReviewItemsById = reviewIds => {\n      const operations = [];\n      reviewIds === null || reviewIds === void 0 ? void 0 : reviewIds.forEach(reviewId => {\n        if (reviewId) {\n          const reviewItem = store.ontology.getItemById(reviewId);\n          if (reviewItem && isQATag(reviewItem.type)) {\n            const {\n              operation\n            } = this.deleteQATag(reviewItem.id, false);\n            if (operation) {\n              operations.push(operation);\n            }\n          } else {\n            const {\n              operation\n            } = this.deleteReview(reviewId, false);\n            if (operation) {\n              operations.push(operation);\n            }\n          }\n        }\n      });\n      this.addHistory(ACTION.DELETE_REVIEWS, operations);\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.deleteReviewItems = reviewItems => {\n      const operations = [];\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return editorState;\n      }\n      reviewItems === null || reviewItems === void 0 ? void 0 : reviewItems.forEach(reviewItem => {\n        const {\n          review,\n          id\n        } = reviewItem;\n        if (review.result === ReviewItemResult.MISSING) {\n          const {\n            operation\n          } = this.deleteQATag(id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const {\n            operation\n          } = this.deleteReview(id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      });\n      this.addHistory(ACTION.DELETE_REVIEWS, operations);\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.addReviewItems = (editorState, reviewItems) => {\n      const operations = [];\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return editorState;\n      }\n      reviewItems === null || reviewItems === void 0 ? void 0 : reviewItems.forEach(reviewItem => {\n        const {\n          review,\n          id\n        } = reviewItem;\n        if (review.result === ReviewItemResult.MISSING) {\n          const {\n            operation\n          } = this.addQALabel(editorState, reviewItem.label, {\n            ...review\n          }, false, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const {\n            operation\n          } = this.addReview(editorState, id, {\n            ...review\n          }, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      });\n      this.addHistory(ACTION.ADD_REVIEWS, operations);\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.deleteReviewHandle = reviewItem => {\n      if (reviewItem) {\n        let nextEditorState = this.state.editorState;\n        if (isQATag(reviewItem.type)) {\n          const {\n            editorState\n          } = this.deleteQATag(reviewItem.id);\n          nextEditorState = editorState;\n        } else {\n          const {\n            editorState\n          } = this.deleteReview(reviewItem.id);\n          nextEditorState = editorState;\n        }\n        this.renderAndSave(nextEditorState);\n      }\n    };\n    this.onDeleteReview = () => {\n      const {\n        tagOpenReview\n      } = this.state;\n      this.deleteReviewHandle(tagOpenReview);\n    };\n    // create new RawDraftContentState and update customeStyleMap\n    // update: raw, style, sliceMap\n    this.renderTextArea = _text => {\n      const {\n        ontology\n      } = store;\n      const {\n        ontologyConfigMap\n      } = ontology;\n      const {\n        currentClick,\n        currentHover,\n        foundTags,\n        foundTagSelectedIndex,\n        needJumpFound\n      } = this.state;\n      const style = {\n        ...this.state.style\n      };\n      const text = _text || store.ontology.text;\n      const {\n        labels,\n        insertions\n      } = ontology.getResults();\n      // render missing labels as normal labels\n\n      // slice text to segments\n      const slices = uniq(labels.map(label => label.start).concat(labels.map(label => label.end)).concat(insertions.map(insertion => insertion.at)).concat(foundTags.map(t => t.start)).concat(foundTags.map(t => t.end)).concat([0, text.length]).sort((a, b) => a - b));\n      const labelHeads = uniq(labels.map(label => label.start));\n      const insertionHeads = uniq(insertions.map(insertion => insertion.at));\n      const foundTagHeads = uniq(foundTags.map(tag => tag.start));\n\n      // .concat(insertions.map((insertion) => insertion.at)));\n      const raw = {\n        blocks: [{\n          text,\n          key: 'span-wrapper',\n          type: 'unstyled',\n          depth: 0,\n          inlineStyleRanges: [{\n            offset: 0,\n            length: text.length,\n            style: 'DEFAULT_STYLE'\n          }],\n          children: [],\n          entityRanges: [],\n          data: {}\n        }],\n        entityMap: {}\n      };\n      let sliceCount = 0;\n      // 对重叠的tag进行背景色叠加\n      const ranges = raw.blocks[0].inlineStyleRanges;\n      this.sliceMap = new Map();\n      slices.forEach((anchor, index, array) => {\n        // set slice\n        if (!index) return;\n        const {\n          prev,\n          next\n        } = {\n          prev: array[index - 1],\n          next: anchor\n        };\n        const match = labels.filter(label => label.start <= prev && label.end > prev);\n        let currentRGB = [0, 0, 0];\n        let currentAlpha = 0;\n        let nextAlpha = DEFAULT_ALPHA;\n        let isCoverbyQa = false;\n        let keepRGB = null;\n        match.some(label => {\n          const labelItem = getConfigByKeys(ontologyConfigMap, label.keys);\n          const tempRGB = convertColorToArray(labelItem.color);\n          if (!keepRGB) isCoverbyQa = isQATag(label.type);\n          // render clicked tag in priority\n          if (currentClick.id === label.id || currentClick.fromId === label.id || currentClick.toId === label.id) {\n            keepRGB = tempRGB.map((value, i) => value * ACTIVE_ALPHA);\n            isCoverbyQa = isQATag(label.type);\n            return true;\n          }\n          if (!keepRGB && currentHover.id === label.id || currentHover.fromId === label.id || currentHover.toId === label.id) {\n            keepRGB = tempRGB.map(v => v * HOVER_ALPHA);\n          }\n          if (!keepRGB) {\n            currentRGB = currentRGB.map((value, i) => value + tempRGB[i] * nextAlpha);\n            currentAlpha += nextAlpha;\n            nextAlpha = DEFAULT_ALPHA * (1 - currentAlpha) * (1 - currentAlpha);\n          }\n          return false;\n        });\n        // background of found tag\n        foundTags.filter(tag => tag.start <= prev && tag.end > prev).some(tag => {\n          const tagIndex = foundTags.findIndex(f => f.start === tag.start);\n          if (tagIndex !== undefined) {\n            keepRGB = foundTagSelectedIndex === tagIndex && !needJumpFound ? [255, 230, 0] : [255, 169, 64, 0.20];\n            return true;\n          }\n          return false;\n        });\n        const baseRGB = convertColorToArray(BASE_COLOR);\n        currentRGB = keepRGB || currentRGB.map((value, i) => Math.min(255, value + baseRGB[i] * (1 - currentAlpha)));\n        const currentColor = convertArrayToColor(currentRGB);\n        if (!style[`BACKGROUND_${currentColor}`]) style[`BACKGROUND_${currentColor}`] = {\n          backgroundColor: currentColor\n        };\n        if (isCoverbyQa) ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: 'MISSING_STYLE'\n        });\n        ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: `BACKGROUND_${currentColor}`\n        });\n        ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: `SLICE_${prev}_${next}`\n        });\n        // set slice head if for label/insertion slice\n        if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0) {\n          const slice = substr(text, prev, next - prev);\n          const head = getSliceHead(slice);\n          ranges.push({\n            offset: prev,\n            length: strlen(head),\n            style: `ANCHOR_${prev}`\n          });\n        }\n        if (foundTagHeads.indexOf(prev) >= 0) {\n          const tagIndex = foundTags.findIndex(f => f.start === prev);\n          if (tagIndex !== undefined) {\n            const tag = foundTags[tagIndex];\n            ranges.push({\n              offset: prev,\n              length: tag.end - tag.start,\n              style: foundTagSelectedIndex === tagIndex && !needJumpFound ? 'FIND_BLOCK_SELECTED' : 'FIND_BLOCK'\n            });\n          }\n        }\n        if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0 || foundTagHeads.indexOf(prev) >= 0) {\n          const slice = substr(text, prev, next - prev);\n          const head = getSliceHead(slice);\n          // set sliceMap\n          this.sliceMap.set(prev, sliceCount);\n          if (head !== slice) sliceCount += 1;\n        }\n        sliceCount += 1;\n      });\n      // update new style\n      this.setState({\n        style\n      });\n      return raw;\n    };\n    this.onMouseMove = e => {\n      const box = this.svg.getBoundingClientRect();\n      this.setState({\n        currentMouse: {\n          left: e.clientX - box.x,\n          top: e.clientY - box.y\n        }\n      });\n    };\n    this.moveFocusToTag = tag => {\n      let currentClick = {\n        ...this.state.currentClick\n      };\n      const {\n        tagMap\n      } = this.state;\n      if (tag == null) return;\n      currentClick = {\n        id: tag.id,\n        fromId: tag.fromId,\n        toId: tag.toId,\n        fromType: tag.fromType,\n        toType: tag.toType\n      };\n      const {\n        top\n      } = tagMap.getItem(tag.id, tag.type);\n      const {\n        clientHeight,\n        scrollTop\n      } = this.editorWrapper;\n      if (top < scrollTop || top > clientHeight + scrollTop) {\n        this.editor.focus({\n          y: top\n        });\n      }\n      this.setState({\n        currentClick\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    };\n    this.onKeyDown = e => {\n      if (window.disableTextHotKeys) {\n        return;\n      }\n      const {\n        currentClick,\n        editorState\n      } = this.state;\n      const {\n        keyCode,\n        ctrlKey,\n        altKey\n      } = e;\n      const config = [];\n      store.ontology.ontologyConfigMap.forEach(value => {\n        config.push(value);\n      });\n      if (ctrlKey) {\n        switch (true) {\n          case keyCode >= 48 && keyCode <= 57:\n            {\n              // 0 - 9\n              e.preventDefault();\n              const index = e.keyCode - 49;\n              if (index === -1) {\n                this.setCurrentBrush(null);\n              }\n              if (config[index]) {\n                this.setCurrentBrush(config[index]);\n              }\n              break;\n            }\n          case keyCode === 90:\n            e.preventDefault();\n            this.executeHistory(RECALL_TYPE.UNDO);\n            break;\n          // Z\n          case keyCode === 89:\n            e.preventDefault();\n            this.executeHistory(RECALL_TYPE.REDO);\n            break;\n          // Y\n          case keyCode === 83:\n            e.preventDefault();\n            this.onSave();\n            break;\n          // S\n          case keyCode === 82:\n            {\n              // R\n              e.preventDefault();\n              const nTag = store.ontology.moveToTagByStep(currentClick.id, 1, true);\n              this.moveFocusToTag(nTag);\n              break;\n            }\n          case keyCode === 81:\n            {\n              // Q\n              e.preventDefault();\n              if (currentClick.id == null) break;\n              let nxtTag;\n              if (altKey) {\n                nxtTag = store.ontology.stepToTag(currentClick.id, -1);\n              } else {\n                nxtTag = store.ontology.moveToTagByStep(currentClick.id, -1);\n              }\n              this.moveFocusToTag(nxtTag);\n              break;\n            }\n          case keyCode === 69:\n            {\n              // E\n              e.preventDefault();\n              if (currentClick.id == null) break;\n              let nextTag;\n              if (altKey) {\n                nextTag = store.ontology.stepToTag(currentClick.id, 1);\n              } else {\n                nextTag = store.ontology.moveToTagByStep(currentClick.id, 1);\n              }\n              this.moveFocusToTag(nextTag);\n              break;\n            }\n          default:\n            break;\n        }\n      } else if ((currentClick === null || currentClick === void 0 ? void 0 : currentClick.id) !== null && isReviewEditable(this.toolMode) && !isQATag(currentClick.type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n        switch (keyCode) {\n          case 49:\n            // 1\n            e.preventDefault();\n            e.stopPropagation();\n            this.addReview(editorState, currentClick.id, {\n              result: 'pass'\n            });\n            break;\n          // 2\n          case 50:\n            {\n              e.preventDefault();\n              e.stopPropagation();\n              let tagReviewInfo = store.review.getReview(currentClick.id);\n              if (!tagReviewInfo || tagReviewInfo.result !== ReviewItemResult.REJECT) {\n                tagReviewInfo = {\n                  result: 'reject',\n                  id: currentClick.id,\n                  type: []\n                };\n              }\n              const item = store.ontology.getItem(currentClick.type, currentClick.id);\n              this.setState({\n                tagOpenReview: item,\n                tagReviewInfo\n              });\n              this.editor.blur();\n              break;\n            }\n          default:\n            break;\n        }\n      }\n    };\n    // update text\n    this.onContentChange = (editorState, data, type) => {\n      const {\n        currentBrush,\n        editorState: preState,\n        findPanelVisible,\n        inputEnable\n      } = this.state;\n      if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW || (currentBrush || findPanelVisible || !inputEnable) && type === undefined || this.props.read_only) {\n        return preState;\n      }\n      const {\n        slice,\n        prevSlice,\n        tags,\n        prevTags\n      } = data;\n      let {\n        prevStart,\n        prevEnd\n      } = data;\n      if (prevSlice.length === 1 && slice.length === 0) this.addHistory(ACTION.EDIT_SINGLE_DEL, data);else if (prevSlice.length === 0 && slice.length === 1) this.addHistory(ACTION.EDIT_SINGLE_ADD, data);else if (type === ACTION.EDIT_REPLACE) this.addHistory(ACTION.EDIT_REPLACE, data);else this.addHistory(ACTION.EDIT_DEFAULT, data);\n      prevStart = strlen(store.ontology.text.slice(0, data.prevStart));\n      prevEnd = strlen(store.ontology.text.slice(0, data.prevEnd));\n      store.ontology.text = store.ontology.text.slice(0, data.prevStart) + data.slice + store.ontology.text.slice(data.prevEnd);\n      // update labels and insertions\n      const offset = slice.length - prevSlice.length;\n      if (type === ACTION.EDIT_REPLACE && prevTags) {\n        const {\n          insertions = [],\n          labels = [],\n          connections = []\n        } = prevTags;\n        [...insertions, ...labels, ...connections].forEach(t => {\n          store.ontology.deleteTag(t.type, t.id);\n        });\n      }\n      store.ontology.tagMove(prevStart, prevEnd, offset);\n      if (type === ACTION.EDIT_REPLACE && tags) {\n        const {\n          insertions = [],\n          labels = [],\n          connections = []\n        } = tags;\n        [...insertions, ...labels, ...connections].forEach(t => {\n          store.ontology.addResultItem(t);\n        });\n      }\n\n      // update rawDraftContentState, using new text and results\n      // this.updateFindTags();\n      this.raw = this.renderTextArea();\n\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      return editorState;\n    };\n    this.resetCurrentFocus = (attribute = 'currentClick', shouldUpdate) => new Promise(resolve => {\n      this.setState({\n        [`${attribute}`]: {\n          id: null,\n          from: null,\n          to: null\n        }\n      }, () => resolve('state updated'));\n    }).then(() => {\n      if (shouldUpdate) {\n        return this.updateEditorAndRender();\n      }\n    });\n    this.resetCurrentFrom = () => {\n      this.setState({\n        currentFrom: {\n          type: null,\n          id: null,\n          offset: null\n        }\n      });\n    };\n    // to status for tag: connection mode and other mode\n    this.onTagClick = (e, type, id) => {\n      const {\n        currentFrom,\n        currentBrush,\n        editorState,\n        tagMap\n      } = this.state;\n      const offset = tagMap.getItem(id, type);\n      this.editor.blur();\n      if (!isConnection(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) return;\n\n      // connecting mode only applys to label and insertion\n      if (isLabel(type) || isInsertion(type)) {\n        // if there is no starting point, setup the starting point\n        if (!currentFrom.type) {\n          this.setState({\n            currentFrom: {\n              type,\n              id,\n              offset\n            }\n          });\n        } else {\n          const nextEditorState = this.addConnection(editorState, {\n            fromId: currentFrom.id,\n            fromType: currentFrom.type,\n            toId: id,\n            toType: type,\n            type: TAG.CONNECTION,\n            value: currentBrush.text,\n            keys: currentBrush.keys\n          });\n          this.renderAndSave(nextEditorState, true, true);\n        }\n      }\n    };\n    this.onTagDoubleClick = e => {\n      // only work in qa mode\n      if (!store.reviewable && !store.isRework) {\n        return;\n      }\n      const {\n        id,\n        type\n      } = getTargetWrapperDataSet(e);\n      const item = store.ontology.getItem(type, id);\n      const tagReviewInfo = store.review.getReview(id);\n      this.setState({\n        tagOpenReview: item,\n        tagReviewInfo\n      });\n      this.editor.blur();\n    };\n    // mouseEvent includes: mouse enter, mouse leave, mouse click, mouse context menu\n    this.TagMouseEvent = (e, type, id, focusType, active) => {\n      const {\n        currentClick: {\n          id: currId\n        }\n      } = this.state;\n      const tag = store.ontology.getItem(type, id);\n      if (!tag) {\n        return;\n      }\n      let attribute = '';\n      if (focusType === FOCUS_TYPE.HOVER) {\n        if (currId === tag.id && active) return;\n        attribute = 'currentHover';\n      } else if (focusType === FOCUS_TYPE.CLICK) {\n        attribute = 'currentClick';\n        this.editor.blur();\n      }\n\n      // active status: mouse enter | mouse click\n      if (active) {\n        if (focusType === FOCUS_TYPE.CLICK) {\n          this.onTagClick(e, type, id);\n        }\n        // ranges.push({ offset: label.start, length: label.end - label.start, style: `${focusType}_STYLE_${color}` });\n        this.setState({\n          [`${attribute}`]: {\n            id: tag.id,\n            fromId: tag === null || tag === void 0 ? void 0 : tag.fromId,\n            toId: tag === null || tag === void 0 ? void 0 : tag.toId,\n            fromType: tag === null || tag === void 0 ? void 0 : tag.fromType,\n            toType: tag === null || tag === void 0 ? void 0 : tag.toType,\n            type: tag === null || tag === void 0 ? void 0 : tag.type\n          }\n        }, () => {\n          this.updateEditorAndRender();\n        });\n      } else {\n        // unactive status: mouse leave | mouse context menu\n        const tagType = type;\n        this.resetCurrentFocus(attribute, true).then(() => {\n          if (focusType === FOCUS_TYPE.CLICK) {\n            this.onContextMenu(e, tag.id, tagType);\n          }\n        });\n      }\n    };\n    this.onContextMenu = (e, id, type) => {\n      let nextEditorState;\n      switch (type) {\n        case TAG.LABEL:\n        case TAG.CONNECTION:\n        case TAG.INSERTION:\n          nextEditorState = this.deleteTag(type, id);\n          break;\n        case TAG.LABEL_QA:\n          {\n            const {\n              editorState\n            } = this.deleteQATag(id);\n            nextEditorState = editorState;\n            break;\n          }\n        default:\n          return;\n      }\n      this.renderAndSave(nextEditorState);\n    };\n    this.focusSelectedFoundTag = () => {\n      this.updateEditorAndRender();\n      const {\n        foundTags,\n        foundTagSelectedIndex\n      } = this.state;\n      const selectedTag = foundTags[foundTagSelectedIndex];\n      if (selectedTag) {\n        const span = this.getAnchorElementByHead(selectedTag.start);\n        if (span && this.editorWrapper && !isElementInViewport(span, this.editorWrapper)) {\n          const {\n            top\n          } = span.getBoundingClientRect();\n          const offsetHeight = this.editorWrapper.clientHeight / 2;\n          const scrollTop = this.editorWrapper.scrollTop + top - offsetHeight;\n          this.editorWrapper.scroll(0, scrollTop);\n        }\n      }\n    };\n    this.updateFindTags = () => new Promise(resolve => {\n      const {\n        findStr\n      } = this.state;\n      const str = store.ontology.text;\n      const reg = new RegExp(escapeCharacter(findStr), 'g');\n      const ans = [];\n      if (findStr) {\n        let matched = null;\n        let i = 0;\n        // eslint-disable-next-line no-cond-assign\n        while ((matched = reg.exec(str)) !== null) {\n          const temp = {\n            start: matched.index,\n            end: matched.index + findStr.length,\n            id: i\n          };\n          ans.push(temp);\n          i += 1;\n        }\n      }\n      this.setState({\n        foundTags: ans,\n        foundTagSelectedIndex: -1\n      }, () => {\n        resolve();\n      });\n    });\n    this.setCurrentBrush = (item, input = false) => {\n      this.setState({\n        currentBrush: item,\n        inputEnable: input\n      });\n    };\n    this.setFormVisible = () => {\n      this.setState({\n        tagOpenReview: null,\n        tagReviewInfo: null\n      });\n    };\n    this.genKeyCommand = e => {\n      if (e.metaKey || e.altKey) return KEY_COMMAND.INVALID_KEY;\n      switch (e.keyCode) {\n        case 90:\n          // prevent default undo\n          e.preventDefault();\n          if (e.ctrlKey) return KEY_COMMAND.HANDLE_UNDO;\n          return getDefaultKeyBinding(e);\n        case 89:\n          // prevent default redo\n          e.preventDefault();\n          if (e.ctrlKey) return KEY_COMMAND.HANDLE_REDO;\n          return getDefaultKeyBinding(e);\n        case 13:\n          e.preventDefault();\n          return KEY_COMMAND.HANDLE_RETURN;\n        default:\n          return getDefaultKeyBinding(e);\n      }\n    };\n    this.handleKeyCommand = command => {\n      const {\n        editorState\n      } = this.state;\n      switch (command) {\n        case KEY_COMMAND.INVALID_KEY:\n          return 'handled';\n        case KEY_COMMAND.HANDLE_RETURN:\n          {\n            const start = editorState.getSelection().getStartOffset();\n            const end = editorState.getSelection().getEndOffset();\n            const nextEditorState = setSelection(this.onContentChange(editorState, {\n              slice: '\\n',\n              prevSlice: store.ontology.text.slice(start, end),\n              prevStart: start,\n              prevEnd: end,\n              start: start + 1,\n              end: start + 1\n            }), start + 1, start + 1);\n            this.renderAndSave(nextEditorState);\n            return 'handled';\n          }\n        case KEY_COMMAND.HANDLE_UNDO:\n          return 'handled';\n        case KEY_COMMAND.HANDLE_REDO:\n          return 'handled';\n        default:\n          return 'not-handled';\n      }\n    };\n    // Get one anchor by slice head\n    this.getAnchorElementByHead = at => {\n      const {\n        sliceMap\n      } = this;\n      const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n      const id = `span-wrapper-0-${sliceMap.get(at)}`;\n      const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n      return span;\n    };\n    // Get all anchors at one time\n    this.getAnchorElementsByHeads = () => {\n      const {\n        sliceMap\n      } = this;\n      const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n      const spanMap = new Map();\n      sliceMap.forEach((value, key) => {\n        const id = `span-wrapper-0-${sliceMap.get(key)}`;\n        const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n        spanMap.set(key, span);\n      });\n      return spanMap;\n    };\n    this.onMouseDown = e => {\n      if (e.which === 1) {\n        this.mouseFlag = true;\n      }\n      const onMouseUp = () => {\n        this.mouseFlag = false;\n        window.removeEventListener('mouseup', onMouseUp);\n      };\n      window.addEventListener('mouseup', onMouseUp);\n    };\n    this.onCompositionEnd = () => {\n      this.compositionFlag = COMPOSITION.PENDING;\n    };\n    this.onCompositionStart = () => {\n      this.compositionFlag = COMPOSITION.ENABLED;\n      this.compositionTop = this.editorWrapper.scrollTop;\n    };\n    this.handleBeforeInput = () => {\n      this.inputFlag = true;\n      return 'not-handled';\n    };\n    this.handlePastedText = () => {\n      this.pasteFlag = true;\n      return 'not-handled';\n    };\n    setLocale(props.locale);\n    this.raw = {\n      blocks: [],\n      entityMap: {}\n    };\n    this.sliceMap = new Map();\n    this.state = {\n      findStr: '',\n      foundTags: [],\n      needJumpFound: false,\n      foundTagSelectedIndex: 0,\n      findPanelVisible: false,\n      displayLabels: [],\n      labelsDrawerOpen: defaultLabelsDrawerFlag,\n      style: {\n        FIND_BLOCK,\n        FIND_BLOCK_SELECTED\n      },\n      tagOpenReview: null,\n      tagReviewInfo: null,\n      editorState: EditorState.createEmpty(),\n      currentBrush: null,\n      editorHeight: null,\n      editorWidth: null,\n      tagMap: new TagInfoMap(),\n      currentClick: {\n        id: null,\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null\n      },\n      currentHover: {\n        id: '',\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null\n      },\n      currentFrom: {\n        type: null,\n        id: null,\n        offset: null\n      },\n      currentMouse: {\n        left: 0,\n        top: 0\n      },\n      inputEnable: false\n    };\n    this.compositionTop = -1;\n    this.compositionFlag = COMPOSITION.DISABLED;\n    this.inputFlag = false;\n    this.mouseFlag = false;\n    this.pasteFlag = false;\n    this.undoLock = false;\n    this.redoLock = false;\n    this.redoList = [];\n    this.undoList = [];\n\n    // user setting\n    this.fontColor = FONT_COLOR;\n    this.toolMode = this.props.jobProxy.toolMode || this.props.mode;\n    store.jobProxy = this.props.jobProxy;\n  }\n  submitReviews(isSubmit = true) {\n    return store.saveReviews(isSubmit);\n  }\n  getReviews() {\n    return this.submitReviews();\n  }\n  getStatistics() {\n    return store.getAuditStatistics();\n  }\n  async componentDidMount() {\n    this.toolMode = this.props.jobProxy.toolMode;\n    let {\n      content\n    } = this.props;\n    let results;\n\n    // insert qa tool's label\n    try {\n      const resultRes = await this.props.jobProxy.loadResult();\n      if ((resultRes === null || resultRes === void 0 ? void 0 : resultRes.results) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.content)) {\n        content = resultRes.content;\n        results = resultRes.results;\n      } else if ((resultRes === null || resultRes === void 0 ? void 0 : resultRes.labels) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.connections) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.insertions)) {\n        results = resultRes;\n      }\n    } catch (e) {\n      notification.error({\n        message: localMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // init store\n    try {\n      await store.init({\n        ...this.props,\n        content: content || ''\n      });\n    } catch (e) {\n      notification.error({\n        message: e.message,\n        duration: null\n      });\n      return;\n    }\n\n    // initialize results\n    store.ontology.parseResults(results);\n    const reviewRes = await this.props.jobProxy.loadReviews();\n    if (reviewRes) {\n      store.review.parseReview(reviewRes);\n    }\n\n    // initialize raw\n    this.raw = this.renderTextArea();\n    // apply composition lock\n    // if (this.state.labelsDrawerOpen) {\n    //   const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n    //   this.setState({ displayLabels });\n    // }\n    this.editorWrapper.addEventListener('compositionstart', this.onCompositionStart);\n    this.editorWrapper.addEventListener('compositionend', this.onCompositionEnd);\n    this.editorWrapper.addEventListener('mousedown', this.onMouseDown);\n    this.editorWrapper.addEventListener('dragstart', e => e.preventDefault());\n    this.editorWrapper.addEventListener('contextmenu', e => {\n      e.preventDefault();\n      this.resetCurrentFrom();\n      this.resetCurrentFocus('currentClick', true);\n    });\n    this.editorWrapper.addEventListener('mousemove', this.onMouseMove);\n    window.addEventListener('keydown', this.onKeyDown);\n    window.addEventListener('resize', () => this.renderAndSave(null, true, false, false));\n\n    // initialize customStyleMap\n    this.setState({\n      style: {\n        ...this.state.style,\n        DEFAULT_STYLE: {\n          color: this.fontColor,\n          fontSize: `${FONT_SIZE}px`,\n          lineHeight: `${LINE_HEIGHT}px`,\n          letterSpacing: `${FONT_SPACE}px`\n        },\n        MISSING_STYLE: {\n          color: '#000000'\n        }\n      }\n    });\n    this.renderAndSave(EditorState.createWithContent(convertFromRaw(this.raw)), true, true, false);\n    // use url file backup to replace content, results, and reviews information\n    // use local storage backup to replace text, results, and reviews information\n    // save every 5 minutes\n    setInterval(() => {\n      this.onSave();\n    }, 1000 * 60 * 5);\n    if (this.props.renderComplete) {\n      this.props.renderComplete();\n    }\n  }\n  render() {\n    var _currentFrom$offset, _currentFrom$offset2;\n    const {\n      editorState,\n      style,\n      currentBrush,\n      editorWidth,\n      editorHeight,\n      currentClick,\n      currentHover,\n      currentMouse,\n      currentFrom,\n      tagMap,\n      tagOpenReview,\n      tagReviewInfo,\n      inputEnable\n    } = this.state;\n    const {\n      config\n    } = store;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"app-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1446,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-wrapper\",\n      onClick: () => {\n        this.editorOnFocus = false;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1447,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-left-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1448,\n        columnNumber: 11\n      }\n    }, isAppenCloud() && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"logo\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1450,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(AppenLogo, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1451,\n        columnNumber: 15\n      }\n    })), /*#__PURE__*/React.createElement(ReviewMode, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1454,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"divider\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1455,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(UndoRedo, {\n      undoHandle: () => this.executeHistory(RECALL_TYPE.UNDO),\n      redoHandle: () => this.executeHistory(RECALL_TYPE.REDO),\n      undoList: this.undoList,\n      redoList: this.redoList,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1456,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"divider\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1462,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Save, {\n      onSave: this.onSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1463,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-right-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1465,\n        columnNumber: 11\n      }\n    })), /*#__PURE__*/React.createElement(TextToolContext.Provider, {\n      value: {\n        moveFocusToTag: this.moveFocusToTag,\n        deleteReviewItemById: this.deleteReviewItemById,\n        deleteReviewItemsById: this.deleteReviewItemsById\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1469,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Sidebar, {\n      showReview: isRework(this.toolMode) || isReviewEditable(this.toolMode),\n      onClick: () => {\n        this.editorOnFocus = false;\n      },\n      currentBrush: currentBrush,\n      inputEnable: inputEnable,\n      setCurrentBrush: this.setCurrentBrush,\n      items: tagMap,\n      contentReadyOnly: this.props.read_only,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1470,\n        columnNumber: 11\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"right-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1480,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"editor-wrapper\",\n      ref: r => {\n        this.editorWrapper = r;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1481,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"svg-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1485,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"svg\", {\n      ref: r => {\n        this.svg = r;\n      },\n      style: {\n        height: `${editorHeight}px`,\n        width: `${editorWidth}px`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1486,\n        columnNumber: 15\n      }\n    }, Object.entries(tagMap.connections).map(([id, connect]) => /*#__PURE__*/React.createElement(\"g\", {\n      key: id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1488,\n        columnNumber: 19\n      }\n    }, /*#__PURE__*/React.createElement(\"path\", {\n      d: connect.path,\n      stroke: currentHover.id === id ? HOVER_COLOR : currentClick.id === id ? FOCUS_COLOR : DEFAULT_COLOR,\n      fill: \"#00000000\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1489,\n        columnNumber: 21\n      }\n    }))), currentFrom.type ? /*#__PURE__*/React.createElement(\"path\", {\n      d: `M ${(_currentFrom$offset = currentFrom.offset) === null || _currentFrom$offset === void 0 ? void 0 : _currentFrom$offset.left} ${(_currentFrom$offset2 = currentFrom.offset) === null || _currentFrom$offset2 === void 0 ? void 0 : _currentFrom$offset2.top} L ${currentMouse.left} ${currentMouse.top}`,\n      stroke: FOCUS_COLOR,\n      fill: \"#00000000\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1497,\n        columnNumber: 19\n      }\n    }) : null)), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tags-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1501,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tags-panel\",\n      style: {\n        height: `${editorHeight}px`,\n        width: `${editorWidth}px`\n      },\n      onDoubleClick: this.onTagDoubleClick,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1502,\n        columnNumber: 15\n      }\n    }, Object.entries(tagMap.labels).map(([id, label]) => {\n      var _store$review$getRevi;\n      return /*#__PURE__*/React.createElement(LabelTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi = store.review.getReview(id)) === null || _store$review$getRevi === void 0 ? void 0 : _store$review$getRevi.result,\n        label: label,\n        isHover: currentHover.id === id || currentHover.fromId === id || currentHover.toId === id,\n        isClick: currentClick.id === id || currentClick.fromId === id || currentClick.toId === id,\n        labelMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1508,\n          columnNumber: 19\n        }\n      });\n    }), Object.entries(tagMap.insertions).map(([id, insertion]) => {\n      var _store$review$getRevi2;\n      return /*#__PURE__*/React.createElement(InsertionTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi2 = store.review.getReview(id)) === null || _store$review$getRevi2 === void 0 ? void 0 : _store$review$getRevi2.result,\n        insertion: insertion,\n        isHover: currentHover.id === id || currentHover.fromId === id || currentHover.toId === id,\n        isClick: currentClick.id === id || currentClick.fromId === id || currentClick.toId === id,\n        insertionMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1526,\n          columnNumber: 19\n        }\n      });\n    }), Object.entries(tagMap.connections).map(([id, connection]) => {\n      var _store$review$getRevi3;\n      return /*#__PURE__*/React.createElement(ConnectionTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi3 = store.review.getReview(id)) === null || _store$review$getRevi3 === void 0 ? void 0 : _store$review$getRevi3.result,\n        connection: connection,\n        isHover: currentHover.id === id,\n        isClick: currentClick.id === id,\n        connectionMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1544,\n          columnNumber: 19\n        }\n      });\n    }))), /*#__PURE__*/React.createElement(\"div\", {\n      onClick: () => {\n        this.editor.focus();\n        this.resetCurrentFocus('currentClick', true);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1555,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(Editor, {\n      ref: r => {\n        this.editor = r;\n      },\n      editorState: editorState,\n      customStyleMap: style,\n      onChange: this.onChange,\n      handlePastedText: this.handlePastedText,\n      handleBeforeInput: this.handleBeforeInput,\n      handleKeyCommand: this.handleKeyCommand,\n      keyBindingFn: this.genKeyCommand,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1561,\n        columnNumber: 15\n      }\n    })))), /*#__PURE__*/React.createElement(ReviewForm, {\n      toolMode: this.toolMode,\n      tagReviewInfo: tagReviewInfo,\n      tagOpenReview: tagOpenReview,\n      issueTypes: this.props.issue_types,\n      setFormVisible: this.setFormVisible,\n      onConfirm: review => {\n        this.addReview(editorState, tagOpenReview === null || tagOpenReview === void 0 ? void 0 : tagOpenReview.id, review);\n        store.ontology.updateOntologiesStatusMap();\n      },\n      onDelete: this.onDeleteReview,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1581,\n        columnNumber: 9\n      }\n    }));\n  }\n}","map":{"version":3,"names":["React","createContext","Editor","EditorState","convertFromRaw","getDefaultKeyBinding","notification","message","uniq","substr","strlen","v4","uuidv4","localMessage","setLocale","LabelTag","InsertionTag","ConnectionTag","isAnnotationReadonly","isRework","isReviewEditable","isPreview","Sidebar","genTagMap","renderTagMap","genDisplayLabels","ReviewForm","UndoRedo","ReviewMode","Save","isAppenCloud","AppenLogo","store","FIND_BLOCK","FIND_BLOCK_SELECTED","FOCUS_COLOR","DEFAULT_COLOR","FONT_COLOR","BASE_COLOR","HISTORY_SIZE","FONT_SIZE","TAG_HEIGHT","LINE_HEIGHT","EDITOR_PADDING","COMPOSITION","SELECTION","ACTION","KEY_COMMAND","RECALL_TYPE","HOVER_COLOR","FONT_SPACE","FOCUS_TYPE","HOVER_ALPHA","ACTIVE_ALPHA","DEFAULT_ALPHA","isArabic","convertArrayToColor","convertColorToArray","getSliceHead","setSelection","closeSelection","getTextByInsertion","getTargetWrapperDataSet","isElementInViewport","escapeCharacter","getConfigByKeys","isLabel","isInsertion","isConnection","isQATag","ReviewItemResult","TAG","ReviewModeType","TagInfoMap","storageKey","defaultLabelsDrawerFlag","s","localStorage","getItem","e","TextToolContext","TextAnnotationApp","Component","constructor","props","addHistory","type","data","targetList","undoLock","redoList","redoLock","undoList","length","shift","EDIT_SINGLE_ADD","prev","EDIT_DEFAULT","prevSlice","end","prevStart","pop","push","slice","prevEnd","start","EDIT_SINGLE_DEL","executeHistory","recallType","UNDO","REDO","item","nextEditorState","state","editorState","EDIT_REPLACE","newData","tags","prevTags","onContentChange","ADD_INSERTION","id","insertion","deleteTag","ADD_LABEL","label","ADD_MISSING_REVIEW","preReview","addReview","deleteQATag","ADD_CONNECTION","DEL_LABEL","relatedConnections","addLabel","DEL_MISSING_REVIEW","review","addQALabel","DEL_INSERTION","addInsertion","DEL_CONNECTION","connection","addConnection","EDIT_REPLACE_ALL","text","currentText","prevText","prevResults","results","ontology","setResults","raw","renderTextArea","set","currentContent","ADD_REVIEW","deleteReview","DELETE_REVIEW","ADD_REVIEWS","deleteReviewItems","DELETE_REVIEWS","addReviewItems","renderAndSave","_editorState","shouldRenderTags","shouldResetCurrentState","shouldSaveURL","hasFocus","getSelection","top","editorWrapper","scrollTop","Promise","resolve","resetCurrentFrom","setState","exportResult","then","tagMap","measureTags","updateOntologiesStatusMap","renderTags","editorWidth","offsetWidth","editorHeight","scrollHeight","compositionTop","editor","focus","y","displayLabels","labels","ontologyConfigMap","updateEditorAndRender","options","Symbol","iterator","onChange","compositionFlag","ENABLED","prevEditorState","getCurrentContent","getPlainText","getStartOffset","getEndOffset","prevFocus","inputFlag","pasteFlag","PENDING","DISABLED","onSelectionChange","shouldRender","MOVE","spanMap","getAnchorElementsByHeads","newTagMap","onSave","toolMode","submitReviews","success","warning","onSubmit","params","invalid","validityFlag","config","submitCheck","skipCheckForInvalidData","validation","defaultSync","blocked","Error","isSubmit","saveResult","insertions","getResults","offsetTops","map","_spanMap$get","get","offsetTop","concat","_spanMap$get2","at","occupyMap","Map","forEach","ranges","blocks","inlineStyleRanges","style","filter","span","getAnchorElementByHead","offset","occupyList","lineHeight","it","sort","a","b","currentBrush","mouseFlag","fbAt","value","keys","INSERTION","CLICK","fbStart","fbEnd","result","MISSING","DRAG","reviewMode","REVIEW","operation","arabic","newItem","isReview","addResultItem","fromId","fromType","toId","toType","connections","some","LABELING","reviewInfo","needUnRedo","needOpenReview","reviews","missing","tagOpenReview","addMissingReview","deleteMissingReview","reviewId","currEditorState","setReview","deleteReviewItemById","reviewItem","getItemById","deleteReviewItemsById","reviewIds","operations","reviewItems","deleteReviewHandle","onDeleteReview","_text","currentClick","currentHover","foundTags","foundTagSelectedIndex","needJumpFound","slices","t","labelHeads","insertionHeads","foundTagHeads","tag","key","depth","children","entityRanges","entityMap","sliceCount","sliceMap","anchor","index","array","next","match","currentRGB","currentAlpha","nextAlpha","isCoverbyQa","keepRGB","labelItem","tempRGB","color","i","v","tagIndex","findIndex","f","undefined","baseRGB","Math","min","currentColor","backgroundColor","indexOf","head","onMouseMove","box","svg","getBoundingClientRect","currentMouse","left","clientX","x","clientY","moveFocusToTag","clientHeight","onKeyDown","window","disableTextHotKeys","keyCode","ctrlKey","altKey","preventDefault","setCurrentBrush","nTag","moveToTagByStep","nxtTag","stepToTag","nextTag","stopPropagation","tagReviewInfo","getReview","REJECT","blur","preState","findPanelVisible","inputEnable","read_only","tagMove","resetCurrentFocus","attribute","shouldUpdate","from","to","currentFrom","onTagClick","CONNECTION","onTagDoubleClick","reviewable","TagMouseEvent","focusType","active","currId","HOVER","tagType","onContextMenu","LABEL","LABEL_QA","focusSelectedFoundTag","selectedTag","offsetHeight","scroll","updateFindTags","findStr","str","reg","RegExp","ans","matched","exec","temp","input","setFormVisible","genKeyCommand","metaKey","INVALID_KEY","HANDLE_UNDO","HANDLE_REDO","HANDLE_RETURN","handleKeyCommand","command","wrapper","querySelector","onMouseDown","which","onMouseUp","removeEventListener","addEventListener","onCompositionEnd","onCompositionStart","handleBeforeInput","handlePastedText","locale","labelsDrawerOpen","createEmpty","fontColor","jobProxy","mode","saveReviews","getReviews","getStatistics","getAuditStatistics","componentDidMount","content","resultRes","loadResult","error","duration","init","parseResults","reviewRes","loadReviews","parseReview","DEFAULT_STYLE","fontSize","letterSpacing","MISSING_STYLE","createWithContent","setInterval","renderComplete","render","_currentFrom$offset","_currentFrom$offset2","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","onClick","editorOnFocus","undoHandle","redoHandle","Provider","showReview","items","contentReadyOnly","ref","r","height","width","Object","entries","connect","d","path","stroke","fill","onDoubleClick","_store$review$getRevi","reviewResult","isHover","isClick","labelMouseEvent","_store$review$getRevi2","insertionMouseEvent","_store$review$getRevi3","connectionMouseEvent","customStyleMap","keyBindingFn","issueTypes","issue_types","onConfirm","onDelete"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/TextAnnotationApp.jsx"],"sourcesContent":["/* eslint-disable no-nested-ternary */\n/* eslint-disable react/no-access-state-in-setstate */\n/* eslint-disable no-undef */\n/* eslint-disable no-underscore-dangle */\nimport React, { createContext } from 'react';\nimport { Editor, EditorState, convertFromRaw, getDefaultKeyBinding } from 'draft-js';\nimport { notification, message } from 'antd';\nimport { uniq } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport localMessage, { setLocale } from './locale';\nimport { LabelTag, InsertionTag, ConnectionTag } from './components/tag';\nimport { isAnnotationReadonly, isRework, isReviewEditable, isPreview } from '../../utils/tool-mode';\nimport Sidebar from './components/sidebar';\nimport { genTagMap, renderTagMap, genDisplayLabels } from './utils/tagMapUtil';\n\nimport ReviewForm from './components/reviewForm';\nimport UndoRedo from './components/UndoRedo';\nimport ReviewMode from './components/ReviewMode';\nimport Save from './components/Save';\nimport { isAppenCloud } from '../../utils';\nimport AppenLogo from '../common/AppenLogo';\nimport store from './store/RootStore';\nimport './TextAnnotationApp.scss';\nimport 'draft-js/dist/Draft.css';\nimport {\n  FIND_BLOCK,\n  FIND_BLOCK_SELECTED,\n  FOCUS_COLOR, DEFAULT_COLOR,\n  FONT_COLOR, BASE_COLOR, HISTORY_SIZE,\n  FONT_SIZE, TAG_HEIGHT,\n  LINE_HEIGHT, EDITOR_PADDING,\n  COMPOSITION, SELECTION, ACTION, KEY_COMMAND,\n  RECALL_TYPE,\n  HOVER_COLOR,\n  FONT_SPACE, FOCUS_TYPE,\n  HOVER_ALPHA,\n  ACTIVE_ALPHA,\n  DEFAULT_ALPHA,\n} from './store/constant';\nimport {\n  isArabic,\n  convertArrayToColor,\n  convertColorToArray,\n  getSliceHead,\n  setSelection,\n  closeSelection,\n  getTextByInsertion,\n  getTargetWrapperDataSet,\n  isElementInViewport,\n  escapeCharacter,\n  getConfigByKeys,\n} from './utils/helper';\nimport {\n  isLabel,\n  isInsertion,\n  isConnection,\n  isQATag,\n} from './store/tag_mode';\nimport { ReviewItemResult, TAG, ReviewMode as ReviewModeType } from './types';\nimport TagInfoMap from './utils/TagInfoMap';\n\nconst storageKey = 'text-annotation-label-content';\nlet defaultLabelsDrawerFlag = false;\ntry {\n  const s = localStorage.getItem(storageKey);\n  defaultLabelsDrawerFlag = s === 'true';\n} catch (e) {\n  // get error\n}\n\nexport const TextToolContext = createContext();\nexport default class TextAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    setLocale(props.locale);\n    this.raw = { blocks: [], entityMap: {} };\n    this.sliceMap = new Map();\n    this.state = {\n      findStr: '',\n      foundTags: [],\n      needJumpFound: false,\n      foundTagSelectedIndex: 0,\n      findPanelVisible: false,\n      displayLabels: [],\n      labelsDrawerOpen: defaultLabelsDrawerFlag,\n      style: {\n        FIND_BLOCK,\n        FIND_BLOCK_SELECTED,\n      },\n      tagOpenReview: null,\n      tagReviewInfo: null,\n      editorState: EditorState.createEmpty(),\n      currentBrush: null,\n      editorHeight: null,\n      editorWidth: null,\n      tagMap: new TagInfoMap(),\n      currentClick: {\n        id: null,\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null,\n      },\n      currentHover: {\n        id: '',\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null,\n      },\n      currentFrom: {\n        type: null,\n        id: null,\n        offset: null,\n      },\n      currentMouse: {\n        left: 0,\n        top: 0,\n      },\n      inputEnable: false,\n    };\n\n    this.compositionTop = -1;\n    this.compositionFlag = COMPOSITION.DISABLED;\n    this.inputFlag = false;\n    this.mouseFlag = false;\n    this.pasteFlag = false;\n    this.undoLock = false;\n    this.redoLock = false;\n    this.redoList = [];\n    this.undoList = [];\n\n    // user setting\n    this.fontColor = FONT_COLOR;\n    this.toolMode = this.props.jobProxy.toolMode || this.props.mode;\n    store.jobProxy = this.props.jobProxy;\n  };\n\n  addHistory = (type, data) => {\n    let targetList;\n    if (this.undoLock) {\n      // Add history to redo list\n      targetList = this.redoList;\n    } else if (this.redoLock) {\n      // Add history back to undo list\n      targetList = this.undoList;\n      // Clear redo list\n    } else {\n      // Add history to redo list\n      targetList = this.undoList;\n      this.redoList = [];\n    }\n    let { length } = targetList;\n    if (length > HISTORY_SIZE) {\n      targetList.shift();\n      length -= 1;\n    }\n    if (type === ACTION.EDIT_SINGLE_ADD && length >= 1) {\n      const prev = targetList[length - 1];\n      if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_ADD) && (prev.data.prevSlice === '' && prev.data.end === data.prevStart)) {\n        targetList.pop();\n        targetList.push({\n          type: ACTION.EDIT_DEFAULT,\n          data: {\n            prevSlice: '',\n            slice: prev.data.slice + data.slice,\n            prevStart: prev.data.prevStart,\n            prevEnd: prev.data.prevEnd,\n            start: data.start,\n            end: data.end,\n          }\n        });\n      } else targetList.push({ type, data });\n    } else if (type === ACTION.EDIT_SINGLE_DEL && length >= 1) {\n      const prev = targetList[length - 1];\n      if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_DEL) && (prev.data.slice === '' && data.prevEnd === prev.data.start)) {\n        targetList.pop();\n        targetList.push({\n          type: ACTION.EDIT_DEFAULT,\n          data: {\n            slice: '',\n            prevSlice: data.prevSlice + prev.data.prevSlice,\n            prevStart: data.end,\n            prevEnd: prev.data.prevEnd,\n            start: data.start,\n            end: data.end,\n          }\n        });\n      } else targetList.push({ type, data });\n    } else targetList.push({ type, data });\n  };\n\n  executeHistory = (recallType) => {\n    // Execute history\n    let targetList;\n    if (recallType === RECALL_TYPE.UNDO) {\n      // Get from undo list\n      this.undoLock = true;\n      targetList = this.undoList;\n    } else if (recallType === RECALL_TYPE.REDO) {\n      // Get from redo list\n      this.redoLock = true;\n      targetList = this.redoList;\n    }\n    if (targetList.length === 0) {\n      this.undoLock = false;\n      this.redoLock = false;\n      return;\n    }\n    const item = targetList.pop();\n    const { data } = item;\n    let nextEditorState = this.state.editorState;\n    switch (item.type) {\n      case ACTION.EDIT_SINGLE_ADD:\n      case ACTION.EDIT_SINGLE_DEL:\n      case ACTION.EDIT_DEFAULT:\n      case ACTION.EDIT_REPLACE:\n      {\n        const newData = {\n          prevSlice: data.slice,\n          slice: data.prevSlice,\n          start: data.prevEnd,\n          end: data.prevEnd,\n          prevStart: data.prevStart,\n          prevEnd: data.end,\n          ...item.type === ACTION.EDIT_REPLACE && {\n            tags: data.prevTags,\n            prevTags: data.tags,\n          }\n        };\n        // nextEditorState = this.onContentChange(nextEditorState, newData);\n        nextEditorState = setSelection(this.onContentChange(nextEditorState, newData, item.type), newData.start, newData.end);\n        break;\n      }\n      case ACTION.ADD_INSERTION:\n      {\n        const { type, id } = data.insertion;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.ADD_LABEL:\n      {\n        const { type, id } = data.label;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.ADD_MISSING_REVIEW:\n      {\n        const { preReview, id } = data;\n        if (preReview) {\n          const { editorState } = this.addReview(nextEditorState, id, { ...preReview });\n          nextEditorState = editorState;\n        } else {\n          const { editorState } = this.deleteQATag(id);\n          nextEditorState = editorState;\n        }\n        break;\n      }\n      case ACTION.ADD_CONNECTION:\n      {\n        const { type, id } = data;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.DEL_LABEL:\n      {\n        const { relatedConnections, label } = data;\n        nextEditorState = this.addLabel(nextEditorState, label, relatedConnections);\n        break;\n      }\n      case ACTION.DEL_MISSING_REVIEW:\n      {\n        const { label, review } = data;\n        const { editorState } = this.addQALabel(nextEditorState, label, { ...review });\n        nextEditorState = editorState;\n\n        break;\n      }\n      case ACTION.DEL_INSERTION:\n      {\n        const { relatedConnections, insertion } = data;\n\n        nextEditorState = this.addInsertion(nextEditorState, insertion, relatedConnections);\n        break;\n      }\n      case ACTION.DEL_CONNECTION:\n      {\n        const { connection } = data;\n        nextEditorState = this.addConnection(nextEditorState, connection);\n        break;\n      }\n      case ACTION.EDIT_REPLACE_ALL:\n      {\n        const { text: currentText, prevText, prevResults, results } = data;\n        store.ontology.text = prevText;\n        store.ontology.setResults(prevResults);\n        this.raw = this.renderTextArea(prevText);\n        nextEditorState = EditorState.set(nextEditorState, { currentContent: convertFromRaw(this.raw) });\n        this.addHistory(ACTION.EDIT_REPLACE_ALL, {\n          text: prevText,\n          prevText: currentText,\n          prevResults: results,\n          results: prevResults,\n        });\n        break;\n      }\n      case ACTION.ADD_REVIEW: {\n        const { preReview, id } = data;\n        if (preReview) {\n          const { editorState } = this.addReview(nextEditorState, id, { ...preReview });\n          nextEditorState = editorState;\n        } else {\n          const { editorState } = this.deleteReview(id);\n          nextEditorState = editorState;\n        }\n        break;\n      }\n      case ACTION.DELETE_REVIEW: {\n        const { review, id } = data;\n        const { editorState } = this.addReview(nextEditorState, id, { ...review });\n        nextEditorState = editorState;\n        break;\n      }\n      case ACTION.ADD_REVIEWS: {\n        nextEditorState = this.deleteReviewItems(data);\n        break;\n      }\n      case ACTION.DELETE_REVIEWS: {\n        nextEditorState = this.addReviewItems(nextEditorState, data);\n        break;\n      }\n      default:\n        break;\n    }\n\n    this.renderAndSave(nextEditorState);\n    this.undoLock = false;\n    this.redoLock = false;\n  };\n\n  renderAndSave = (\n    _editorState,\n    shouldRenderTags = true,\n    shouldResetCurrentState = false,\n    shouldSaveURL = false,\n  ) => {\n    const editorState = _editorState || this.state.editorState;\n    const { hasFocus } = editorState.getSelection();\n    const top = this.editorWrapper.scrollTop;\n    // window.ew = this.editorWrapper;\n    return new Promise((resolve) => {\n      if (shouldResetCurrentState) {\n        this.resetCurrentFrom();\n      }\n      this.setState({ editorState });\n      if (shouldSaveURL) {\n        this.exportResult();\n      }\n      resolve();\n    }).then(() => {\n      if (shouldRenderTags) {\n        const { nextEditorState, tagMap } = this.measureTags(editorState);\n        return new Promise((resolve) => {\n          this.setState({ editorState: nextEditorState }, () => {\n            store.ontology.updateOntologiesStatusMap();\n          });\n          resolve(tagMap);\n        });\n      }\n    }).then((tagMap) => {\n      if (shouldRenderTags) {\n        this.renderTags(tagMap);\n        return new Promise((resolve) => {\n          this.setState({\n            editorWidth: this.editorWrapper.offsetWidth - EDITOR_PADDING * 2,\n            editorHeight: this.editorWrapper.scrollHeight - EDITOR_PADDING * 2,\n            tagMap,\n          });\n          resolve();\n        });\n      }\n    }).then(() => {\n      if (hasFocus) {\n        // move back to current selection after composition end\n        if (this.compositionTop >= 0) {\n          this.editor.focus({ y: this.compositionTop });\n          this.compositionTop = -1;\n        } else this.editor.focus({ y: top });\n      }\n      return new Promise((resolve) => resolve());\n    })\n      .then(() => {\n        const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n        this.setState({ displayLabels });\n      });\n  };\n\n  updateEditorAndRender = (options) => {\n    let { editorState } = this.state;\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    if (options && typeof options[Symbol.iterator] === 'function') {\n      return this.renderAndSave(editorState, ...options);\n    }\n\n    return this.renderAndSave(editorState);\n  };\n\n  onChange = (editorState) => {\n    // ignore composition operation\n    if (this.compositionFlag === COMPOSITION.ENABLED) return;\n    // get operation type ( handled operation not included )\n    const prevEditorState = this.state.editorState;\n    const prevText = store.ontology.text;\n    const text = editorState.getCurrentContent().getPlainText();\n    let prevStart = prevEditorState.getSelection().getStartOffset();\n    const prevEnd = prevEditorState.getSelection().getEndOffset();\n    const start = editorState.getSelection().getStartOffset();\n    const end = editorState.getSelection().getEndOffset();\n    const { hasFocus } = editorState.getSelection();\n    const { hasFocus: prevFocus } = prevEditorState.getSelection();\n\n    if (hasFocus !== prevFocus) { // when focus change update new editor state and return without doing anything\n      const nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n      this.renderAndSave(nextEditorState, null, false);\n      return;\n    }\n\n    if (this.inputFlag || this.pasteFlag || this.compositionFlag === COMPOSITION.PENDING || prevText !== text) {\n      /* text changed:\n       * 1. deleted by delete key\n       * 2. deleted by drag + delete key\n       * 3. deleted by drag + cut operation\n       * 4. insert/replace by (drag) + simply typing\n       * 5. insert/replace by (drag) + composition typing\n       * 6. insert/replace by (drag) + paste operation\n       * 7. redo && undo\n       */\n      if (prevStart === prevEnd && start === prevStart - 1) prevStart -= 1;\n      const prevSlice = prevText.slice(prevStart, prevEnd);\n      const slice = text.slice(prevStart, end);\n      const data = { prevSlice, slice, prevStart, prevEnd, start, end };\n      const nextEditorState = this.onContentChange(editorState, data);\n      // reset flag\n      this.inputFlag = false;\n      this.pasteFlag = false;\n      this.compositionFlag = COMPOSITION.DISABLED;\n      this.renderAndSave(nextEditorState);\n    } else {\n      /* selection changed\n       * 1. simply select\n       * 2. click select: add insertion\n       * 3. drag select: add label\n       */\n      const data = { start, end };\n      const { nextEditorState, type } = this.onSelectionChange(editorState, data);\n      const shouldRender = type !== SELECTION.MOVE;\n      this.renderAndSave(nextEditorState, shouldRender, shouldRender);\n    }\n  };\n\n  renderTags = (tagMap) => {\n    const spanMap = this.getAnchorElementsByHeads();\n    const newTagMap = renderTagMap(tagMap, spanMap);\n    return newTagMap;\n  };\n\n  onSave = async () => {\n    if (isPreview(this.toolMode)) return;\n    try {\n      if (!isAnnotationReadonly(this.toolMode)) {\n        await this.exportResult();\n      }\n      if (isReviewEditable(this.toolMode)) {\n        await this.submitReviews(false);\n      }\n      message.success(localMessage('saveSuccess'));\n    } catch (e) {\n      message.warning(localMessage('saveFail'));\n    }\n  };\n\n  onSubmit = async (params) => {\n    const invalid = params && params.validityFlag === 'false';\n    if (store.config.submitCheck && (\n      !invalid || !store.config.skipCheckForInvalidData\n    )) {\n      // validate before submit\n      await store.validation.defaultSync();\n      if (store.validation.blocked) {\n        throw new Error(localMessage('SUBMIT_CHECK_FAIL'));\n      }\n    }\n    return this.exportResult(true);\n  };\n\n  exportResult = (isSubmit = false) => {\n    if (isAnnotationReadonly(this.toolMode)) return;\n    return store.saveResult(isSubmit);\n  };\n\n  submitReviews(isSubmit = true) {\n    return store.saveReviews(isSubmit);\n  }\n\n  getReviews() {\n    return this.submitReviews();\n  }\n\n  getStatistics() {\n    return store.getAuditStatistics();\n  }\n\n  measureTags = (editorState) => {\n    const { raw } = this;\n    const { text } = store.ontology;\n    const { labels, insertions } = store.ontology.getResults();\n\n    const spanMap = this.getAnchorElementsByHeads();\n    const offsetTops = uniq((labels.map((label) => spanMap.get(label.start)?.offsetTop))\n      .concat(insertions.map((insertion) => spanMap.get(insertion.at)?.offsetTop)));\n    const occupyMap = new Map();\n    offsetTops.forEach((offsetTop) => { occupyMap.set(offsetTop, []); });\n\n    // get label offsets\n    const tagMap = genTagMap(store.ontology.getResults(), store.ontology.ontologyConfigMap, spanMap, occupyMap, text);\n    const ranges = raw.blocks[0].inlineStyleRanges;\n    const style = { ...this.state.style };\n    ranges.filter((item) => item.style.slice(0, 6) === 'ANCHOR').forEach((item) => {\n      const span = this.getAnchorElementByHead(item.offset);\n      if (span) {\n        const occupyList = occupyMap.get(span.offsetTop);\n        const lineHeight = occupyList.map((it) => (it.top > 0 ? it.top - FONT_SIZE + TAG_HEIGHT : -it.top))\n          .sort((a, b) => (a - b)).pop() * 2 + LINE_HEIGHT;\n        style[`LINEHEIGHT_${lineHeight}`] = { lineHeight: `${lineHeight}px` };\n        ranges.push({ offset: item.offset, length: item.length, style: `LINEHEIGHT_${lineHeight}` });\n      }\n    });\n    const nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    this.setState({ style });\n    return { nextEditorState, tagMap };\n  };\n\n  onSelectionChange = (editorState, data) => {\n    const { start, end } = data;\n    const { currentBrush } = this.state;\n    if (!this.mouseFlag) {\n      return { nextEditorState: editorState, type: SELECTION.MOVE };\n    } if (start === end && isInsertion(currentBrush?.type)) {\n      const fbAt = strlen(store.ontology.text.slice(0, start));\n      const nextEditorState = this.addInsertion(editorState, { at: fbAt, value: currentBrush.text, keys: currentBrush.keys, type: TAG.INSERTION });\n      return { nextEditorState, type: SELECTION.CLICK };\n    } if (start !== end && isLabel(currentBrush?.type)) {\n      const fbStart = strlen(store.ontology.text.slice(0, start));\n      const fbEnd = strlen(store.ontology.text.slice(0, end));\n      if (isQATag(currentBrush?.type)) {\n        const { editorState: nextEditorState } = this.addQALabel(editorState, { start: fbStart, end: fbEnd, value: currentBrush.text, keys: currentBrush.keys, type: currentBrush.type }, { result: ReviewItemResult.MISSING }, true, true);\n        return { nextEditorState, type: SELECTION.DRAG };\n      }\n      const nextEditorState = this.addLabel(editorState, { start: fbStart, end: fbEnd, value: currentBrush.text, keys: currentBrush.keys, type: currentBrush.type });\n      return { nextEditorState, type: SELECTION.DRAG };\n    }\n    return { nextEditorState: editorState, type: SELECTION.MOVE };\n  };\n\n  deleteTag = (type, id) => {\n    const { state: { editorState } } = this;\n    if (isQATag(type) && store.config.reviewMode !== ReviewModeType.REVIEW) {\n      return editorState;\n    }\n    if (!isQATag(type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n      return;\n    }\n    if (isAnnotationReadonly(this.toolMode)) {\n      return editorState;\n    }\n\n    const operation = store.ontology.deleteTag(type, id);\n    switch (true) {\n      case (isLabel(type)): this.addHistory(ACTION.DEL_LABEL, operation); break;\n      case (isConnection(type)): this.addHistory(ACTION.DEL_CONNECTION, operation); break;\n      case (isInsertion(type)): this.addHistory(ACTION.DEL_INSERTION, operation); break;\n      default: break;\n    }\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  addInsertion = (editorState, { at, value, id, keys, type }, relatedConnections = []) => {\n    const { state: { currentBrush }, toolMode } = this;\n    const { text } = store.ontology;\n    if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n    if (at === strlen(text)) return editorState; // prevent insert to the end of content\n    // eslint-disable-next-line no-restricted-syntax\n    for (const item of store.ontology.results.insertions) {\n      if (item.at === at && item.value === currentBrush.text) return editorState;\n    }\n    if (!id) id = uuidv4();\n    const arabic = isArabic(substr(text, at));\n    if (arabic && at) at -= 1;\n    const newItem = {\n      type,\n      at,\n      value,\n      id,\n      text: getTextByInsertion(store.ontology.text, { at, value }),\n      isReview: isReviewEditable(toolMode),\n      keys,\n    };\n\n    this.addHistory(ACTION.ADD_INSERTION, {\n      insertion: newItem,\n      relatedConnections,\n    });\n\n    store.ontology.addResultItem(newItem, relatedConnections);\n\n    this.raw = this.renderTextArea();\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return editorState;\n  };\n\n  addConnection = (editorState, { fromId, fromType, toId, toType, value, id, keys, type }) => {\n    const { state: { currentBrush }, toolMode } = this;\n    if (isAnnotationReadonly(toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n    if (fromId === toId) return editorState;\n    if (isQATag(fromType) || isQATag(toType)) return editorState; // can't add connection for qa tool\n\n    if (store.ontology.results.connections.some((item) => item.fromId === fromId && item.toId === toId && item.value === currentBrush.text)) return editorState;\n\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      fromId,\n      fromType,\n      toId,\n      toType,\n      value,\n      id,\n      isReview: isReviewEditable(toolMode),\n      keys,\n    };\n    this.addHistory(ACTION.ADD_CONNECTION, newItem);\n    store.ontology.addResultItem(newItem);\n\n    this.raw = this.renderTextArea();\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    return editorState;\n  };\n\n  addLabel = (editorState, { start, end, value, id, keys, type }, relatedConnections = []) => {\n    const { toolMode } = this;\n    const { ontology, config } = store;\n    const { text } = store.ontology;\n\n    if (config.reviewMode === ReviewModeType.REVIEW && (!isQATag(type))) return editorState;\n    if (isAnnotationReadonly(this.toolMode) && (!isQATag(type))) return editorState;\n    if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return editorState; // qa mode can only use qa tool, work mode can only use normal tool\n\n    // slice should not begin with \\n\n    if (substr(text, start, 1) === '\\n') return editorState;\n\n    if (ontology.results.labels.some((item) => item.start === start && item.end === end && item.value === value)) return editorState;\n\n    // generate new label\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      start,\n      end,\n      value,\n      id,\n      text: substr(text, start, end - start),\n      isReview: isReviewEditable(toolMode),\n      keys\n    };\n\n    this.addHistory(ACTION.ADD_LABEL, {\n      label: newItem,\n      relatedConnections,\n    });\n\n    ontology.addResultItem(newItem, relatedConnections);\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return editorState;\n  };\n\n  addQALabel = (editorState, { start, end, value, id, keys, type }, reviewInfo, needUnRedo = true, needOpenReview = false) => {\n    const { toolMode } = this;\n    const { ontology, config, review } = store;\n    const { text } = ontology;\n    if (config.reviewMode === ReviewModeType.REVIEW && (!isQATag(type))) return { editorState, operation: null };\n    if (isAnnotationReadonly(this.toolMode) && (!isQATag(type))) return { editorState, operation: null };\n    if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return { editorState, operation: null }; // qa mode can only use qa tool, work mode can only use normal tool\n\n    // slice should not begin with \\n\n    if (substr(text, start, 1) === '\\n') return { editorState, operation: null };\n\n    if (review.reviews.missing.some((item) => item.start === start && item.end === end && item.value === value)) return { editorState, operation: null };\n\n    // generate new label\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      start,\n      end,\n      value,\n      id,\n      text: substr(text, start, end - start),\n      isReview: isReviewEditable(toolMode),\n      keys\n    };\n    if (needOpenReview) {\n      this.setState({ tagOpenReview: { ...newItem } });\n    }\n\n    const operation = review.addMissingReview(newItem, id, { ...reviewInfo });\n    if (needUnRedo) {\n      this.addHistory(ACTION.ADD_MISSING_REVIEW, operation);\n    }\n\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return { editorState, operation };\n  };\n\n  deleteQATag = (id, needUnRedo = true) => {\n    const { state: { editorState } } = this;\n\n    if (store.config.reviewMode !== ReviewModeType.REVIEW) {\n      return { editorState, operation: null };\n    }\n    if (isAnnotationReadonly(this.toolMode)) {\n      return { editorState, operation: null };\n    }\n    const operation = store.review.deleteMissingReview(id);\n    if (needUnRedo) {\n      this.addHistory(ACTION.DEL_MISSING_REVIEW, operation);\n    }\n    this.raw = this.renderTextArea();\n    return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n  };\n\n  deleteReview = (reviewId, needUnRedo = true) => {\n    const { state: { editorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState, operation: null };\n    }\n    const operation = store.review.deleteReview(reviewId);\n    if (needUnRedo) {\n      this.addHistory(ACTION.DELETE_REVIEW, operation);\n    }\n    this.raw = this.renderTextArea();\n    return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n  };\n\n  addReview = (editorState, reviewId, review, needUnRedo = true) => {\n    const { state: { editorState: currEditorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState: currEditorState, operation: null };\n    }\n    const operation = store.review.setReview(reviewId, {\n      ...review\n    });\n    if (needUnRedo) {\n      this.addHistory(ACTION.ADD_REVIEW, operation);\n    }\n    this.raw = this.renderTextArea();\n    return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n  };\n\n  deleteReviewItemById = (reviewId) => {\n    if (reviewId) {\n      let nextEditorState = this.state.editorState;\n      const reviewItem = store.ontology.getItemById(reviewId);\n      if (reviewItem && isQATag(reviewItem.type)) {\n        const { editorState } = this.deleteQATag(reviewItem.id);\n        nextEditorState = editorState;\n      } else {\n        const { editorState } = this.deleteReview(reviewId);\n        nextEditorState = editorState;\n      }\n      this.renderAndSave(nextEditorState);\n    }\n  };\n\n  deleteReviewItemsById = (reviewIds) => {\n    const operations = [];\n    reviewIds?.forEach((reviewId) => {\n      if (reviewId) {\n        const reviewItem = store.ontology.getItemById(reviewId);\n        if (reviewItem && isQATag(reviewItem.type)) {\n          const { operation } = this.deleteQATag(reviewItem.id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const { operation } = this.deleteReview(reviewId, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      }\n    });\n    this.addHistory(ACTION.DELETE_REVIEWS, operations);\n    const { state: { editorState } } = this;\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  deleteReviewItems = (reviewItems) => {\n    const operations = [];\n    const { state: { editorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return editorState;\n    }\n    reviewItems?.forEach((reviewItem) => {\n      const { review, id } = reviewItem;\n      if (review.result === ReviewItemResult.MISSING) {\n        const { operation } = this.deleteQATag(id, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      } else {\n        const { operation } = this.deleteReview(id, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      }\n    });\n    this.addHistory(ACTION.DELETE_REVIEWS, operations);\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  addReviewItems = (editorState, reviewItems) => {\n    const operations = [];\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return editorState;\n    }\n    reviewItems?.forEach((reviewItem) => {\n      const { review, id } = reviewItem;\n      if (review.result === ReviewItemResult.MISSING) {\n        const { operation } = this.addQALabel(editorState, reviewItem.label, { ...review }, false, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      } else {\n        const { operation } = this.addReview(editorState, id, { ...review }, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      }\n    });\n    this.addHistory(ACTION.ADD_REVIEWS, operations);\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  deleteReviewHandle = (reviewItem) => {\n    if (reviewItem) {\n      let nextEditorState = this.state.editorState;\n      if (isQATag(reviewItem.type)) {\n        const { editorState } = this.deleteQATag(reviewItem.id);\n        nextEditorState = editorState;\n      } else {\n        const { editorState } = this.deleteReview(reviewItem.id);\n        nextEditorState = editorState;\n      }\n      this.renderAndSave(nextEditorState);\n    }\n  };\n\n  onDeleteReview = () => {\n    const { tagOpenReview } = this.state;\n    this.deleteReviewHandle(tagOpenReview);\n  };\n\n  // create new RawDraftContentState and update customeStyleMap\n  // update: raw, style, sliceMap\n  renderTextArea = (_text) => {\n    const { ontology } = store;\n    const { ontologyConfigMap } = ontology;\n    const {\n      currentClick, currentHover,\n      foundTags, foundTagSelectedIndex, needJumpFound,\n    } = this.state;\n    const style = { ...this.state.style };\n    const text = _text || store.ontology.text;\n    const { labels, insertions } = ontology.getResults();\n    // render missing labels as normal labels\n\n    // slice text to segments\n    const slices = uniq(\n      (labels.map((label) => label.start))\n        .concat(labels.map((label) => label.end))\n        .concat(insertions.map((insertion) => insertion.at))\n        .concat(foundTags.map((t) => t.start))\n        .concat(foundTags.map((t) => t.end))\n        .concat([0, text.length])\n        .sort((a, b) => a - b)\n    );\n    const labelHeads = uniq((labels.map((label) => label.start)));\n    const insertionHeads = uniq((insertions.map((insertion) => insertion.at)));\n    const foundTagHeads = uniq((foundTags.map((tag) => tag.start)));\n\n    // .concat(insertions.map((insertion) => insertion.at)));\n    const raw = {\n      blocks: [{\n        text,\n        key: 'span-wrapper',\n        type: 'unstyled',\n        depth: 0,\n        inlineStyleRanges: [\n          { offset: 0, length: text.length, style: 'DEFAULT_STYLE' }],\n        children: [],\n        entityRanges: [],\n        data: {},\n      }],\n      entityMap: {}\n    };\n    let sliceCount = 0;\n    // 对重叠的tag进行背景色叠加\n    const ranges = raw.blocks[0].inlineStyleRanges;\n    this.sliceMap = new Map();\n    slices.forEach((anchor, index, array) => {\n      // set slice\n      if (!index) return;\n      const { prev, next } = { prev: array[index - 1], next: anchor };\n      const match = labels.filter((label) => (label.start <= prev && label.end > prev));\n      let currentRGB = [0, 0, 0];\n      let currentAlpha = 0;\n      let nextAlpha = DEFAULT_ALPHA;\n      let isCoverbyQa = false;\n      let keepRGB = null;\n      match.some((label) => {\n        const labelItem = getConfigByKeys(ontologyConfigMap, label.keys);\n        const tempRGB = convertColorToArray(labelItem.color);\n        if (!keepRGB) isCoverbyQa = isQATag(label.type);\n        // render clicked tag in priority\n        if (currentClick.id === label.id || currentClick.fromId === label.id || currentClick.toId === label.id) {\n          keepRGB = tempRGB.map((value, i) => value * ACTIVE_ALPHA);\n          isCoverbyQa = isQATag(label.type);\n          return true;\n        }\n\n        if ((!keepRGB && currentHover.id === label.id) || currentHover.fromId === label.id || currentHover.toId === label.id) {\n          keepRGB = tempRGB.map((v) => v * HOVER_ALPHA);\n        }\n\n        if (!keepRGB) {\n          currentRGB = currentRGB.map((value, i) => value + tempRGB[i] * nextAlpha);\n          currentAlpha += nextAlpha;\n          nextAlpha = DEFAULT_ALPHA * (1 - currentAlpha) * (1 - currentAlpha);\n        }\n        return false;\n      });\n      // background of found tag\n      foundTags\n        .filter((tag) => (tag.start <= prev && tag.end > prev))\n        .some((tag) => {\n          const tagIndex = foundTags.findIndex((f) => f.start === tag.start);\n          if (tagIndex !== undefined) {\n            keepRGB = foundTagSelectedIndex === tagIndex && !needJumpFound ? [255, 230, 0] : [255, 169, 64, 0.20];\n            return true;\n          }\n          return false;\n        });\n      const baseRGB = convertColorToArray(BASE_COLOR);\n      currentRGB = keepRGB || currentRGB.map((value, i) => Math.min(255, value + baseRGB[i] * (1 - currentAlpha)));\n      const currentColor = convertArrayToColor(currentRGB);\n\n      if (!style[`BACKGROUND_${currentColor}`]) style[`BACKGROUND_${currentColor}`] = { backgroundColor: currentColor };\n\n      if (isCoverbyQa) ranges.push({ offset: prev, length: next - prev, style: 'MISSING_STYLE' });\n      ranges.push({ offset: prev, length: next - prev, style: `BACKGROUND_${currentColor}` });\n      ranges.push({ offset: prev, length: next - prev, style: `SLICE_${prev}_${next}` });\n      // set slice head if for label/insertion slice\n      if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0) {\n        const slice = substr(text, prev, next - prev);\n        const head = getSliceHead(slice);\n        ranges.push({ offset: prev, length: strlen(head), style: `ANCHOR_${prev}` });\n      }\n      if (foundTagHeads.indexOf(prev) >= 0) {\n        const tagIndex = foundTags.findIndex((f) => f.start === prev);\n        if (tagIndex !== undefined) {\n          const tag = foundTags[tagIndex];\n          ranges.push({\n            offset: prev,\n            length: tag.end - tag.start,\n            style: foundTagSelectedIndex === tagIndex && !needJumpFound ? 'FIND_BLOCK_SELECTED' : 'FIND_BLOCK',\n          });\n        }\n      }\n\n      if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0 || foundTagHeads.indexOf(prev) >= 0) {\n        const slice = substr(text, prev, next - prev);\n        const head = getSliceHead(slice);\n        // set sliceMap\n        this.sliceMap.set(prev, sliceCount);\n        if (head !== slice) sliceCount += 1;\n      }\n      sliceCount += 1;\n    });\n    // update new style\n    this.setState({ style });\n    return raw;\n  };\n\n  async componentDidMount() {\n    this.toolMode = this.props.jobProxy.toolMode;\n    let { content } = this.props;\n    let results;\n\n    // insert qa tool's label\n    try {\n      const resultRes = await this.props.jobProxy.loadResult();\n      if (resultRes?.results && resultRes?.content) {\n        content = resultRes.content;\n        results = resultRes.results;\n      } else if (resultRes?.labels && resultRes?.connections && resultRes?.insertions) {\n        results = resultRes;\n      }\n    } catch (e) {\n      notification.error({ message: localMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // init store\n    try {\n      await store.init({ ...this.props, content: content || '' });\n    } catch (e) {\n      notification.error({ message: e.message, duration: null });\n      return;\n    }\n\n    // initialize results\n    store.ontology.parseResults(results);\n\n    const reviewRes = await this.props.jobProxy.loadReviews();\n    if (reviewRes) {\n      store.review.parseReview(reviewRes);\n    }\n\n    // initialize raw\n    this.raw = this.renderTextArea();\n    // apply composition lock\n    // if (this.state.labelsDrawerOpen) {\n    //   const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n    //   this.setState({ displayLabels });\n    // }\n    this.editorWrapper.addEventListener('compositionstart', this.onCompositionStart);\n    this.editorWrapper.addEventListener('compositionend', this.onCompositionEnd);\n\n    this.editorWrapper.addEventListener('mousedown', this.onMouseDown);\n    this.editorWrapper.addEventListener('dragstart', (e) => e.preventDefault());\n    this.editorWrapper.addEventListener('contextmenu', (e) => {\n      e.preventDefault();\n      this.resetCurrentFrom();\n      this.resetCurrentFocus('currentClick', true);\n    });\n    this.editorWrapper.addEventListener('mousemove', this.onMouseMove);\n\n    window.addEventListener('keydown', this.onKeyDown);\n    window.addEventListener('resize', () => this.renderAndSave(null, true, false, false));\n\n    // initialize customStyleMap\n    this.setState({\n      style: {\n        ...this.state.style,\n        DEFAULT_STYLE: {\n          color: this.fontColor,\n          fontSize: `${FONT_SIZE}px`,\n          lineHeight: `${LINE_HEIGHT}px`,\n          letterSpacing: `${FONT_SPACE}px`,\n        },\n        MISSING_STYLE: {\n          color: '#000000',\n        }\n      },\n    });\n    this.renderAndSave(EditorState.createWithContent(convertFromRaw(this.raw)), true, true, false);\n    // use url file backup to replace content, results, and reviews information\n    // use local storage backup to replace text, results, and reviews information\n    // save every 5 minutes\n    setInterval(() => {\n      this.onSave();\n    }, 1000 * 60 * 5);\n    if (this.props.renderComplete) {\n      this.props.renderComplete();\n    }\n  }\n\n  onMouseMove = (e) => {\n    const box = this.svg.getBoundingClientRect();\n    this.setState({\n      currentMouse: {\n        left: e.clientX - box.x,\n        top: e.clientY - box.y,\n      }\n    });\n  };\n\n  moveFocusToTag = (tag) => {\n    let currentClick = { ...this.state.currentClick };\n    const { tagMap } = this.state;\n    if (tag == null) return;\n    currentClick = {\n      id: tag.id,\n      fromId: tag.fromId,\n      toId: tag.toId,\n      fromType: tag.fromType,\n      toType: tag.toType,\n    };\n    const { top } = tagMap.getItem(tag.id, tag.type);\n    const { clientHeight, scrollTop } = this.editorWrapper;\n    if (top < scrollTop || top > clientHeight + scrollTop) {\n      this.editor.focus({ y: top });\n    }\n\n    this.setState({ currentClick }, () => {\n      this.updateEditorAndRender();\n    });\n  };\n\n  onKeyDown = (e) => {\n    if (window.disableTextHotKeys) {\n      return;\n    }\n    const { currentClick, editorState } = this.state;\n    const { keyCode, ctrlKey, altKey } = e;\n    const config = [];\n    store.ontology.ontologyConfigMap.forEach((value) => { config.push(value); });\n    if (ctrlKey) {\n      switch (true) {\n        case (keyCode >= 48 && keyCode <= 57): {\n          // 0 - 9\n          e.preventDefault();\n          const index = e.keyCode - 49;\n          if (index === -1) {\n            this.setCurrentBrush(null);\n          }\n          if (config[index]) {\n            this.setCurrentBrush(config[index]);\n          }\n          break; }\n        case (keyCode === 90): e.preventDefault(); this.executeHistory(RECALL_TYPE.UNDO); break; // Z\n        case (keyCode === 89): e.preventDefault(); this.executeHistory(RECALL_TYPE.REDO); break; // Y\n        case (keyCode === 83): e.preventDefault(); this.onSave(); break; // S\n        case (keyCode === 82): { // R\n          e.preventDefault();\n          const nTag = store.ontology.moveToTagByStep(currentClick.id, 1, true);\n          this.moveFocusToTag(nTag);\n          break;\n        }\n        case (keyCode === 81): { // Q\n          e.preventDefault();\n          if (currentClick.id == null) break;\n          let nxtTag;\n          if (altKey) {\n            nxtTag = store.ontology.stepToTag(currentClick.id, -1);\n          } else {\n            nxtTag = store.ontology.moveToTagByStep(currentClick.id, -1);\n          }\n          this.moveFocusToTag(nxtTag);\n          break;\n        }\n        case (keyCode === 69): { // E\n          e.preventDefault();\n          if (currentClick.id == null) break;\n          let nextTag;\n          if (altKey) {\n            nextTag = store.ontology.stepToTag(currentClick.id, 1);\n          } else {\n            nextTag = store.ontology.moveToTagByStep(currentClick.id, 1);\n          }\n          this.moveFocusToTag(nextTag);\n          break;\n        }\n        default: break;\n      }\n    } else if (currentClick?.id !== null && isReviewEditable(this.toolMode) && !isQATag(currentClick.type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n      switch (keyCode) {\n        case 49: // 1\n          e.preventDefault();\n          e.stopPropagation();\n          this.addReview(editorState, currentClick.id, {\n            result: 'pass',\n          });\n          break;\n        // 2\n        case 50: {\n          e.preventDefault();\n          e.stopPropagation();\n          let tagReviewInfo = store.review.getReview(currentClick.id);\n          if (!tagReviewInfo || tagReviewInfo.result !== ReviewItemResult.REJECT) {\n            tagReviewInfo = { result: 'reject', id: currentClick.id, type: [] };\n          }\n          const item = store.ontology.getItem(currentClick.type, currentClick.id);\n\n          this.setState({ tagOpenReview: item, tagReviewInfo });\n          this.editor.blur();\n          break;\n        }\n        default: break;\n      }\n    }\n  };\n\n  // update text\n  onContentChange = (editorState, data, type) => {\n    const { currentBrush, editorState: preState, findPanelVisible, inputEnable } = this.state;\n\n    if (\n      (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW)\n      || ((currentBrush || findPanelVisible || !inputEnable) && type === undefined)\n      || this.props.read_only\n    ) {\n      return preState;\n    }\n    const { slice, prevSlice, tags, prevTags } = data;\n    let { prevStart, prevEnd } = data;\n\n    if (prevSlice.length === 1 && slice.length === 0) this.addHistory(ACTION.EDIT_SINGLE_DEL, data);\n    else if (prevSlice.length === 0 && slice.length === 1) this.addHistory(ACTION.EDIT_SINGLE_ADD, data);\n    else if (type === ACTION.EDIT_REPLACE) this.addHistory(ACTION.EDIT_REPLACE, data);\n    else this.addHistory(ACTION.EDIT_DEFAULT, data);\n\n    prevStart = strlen(store.ontology.text.slice(0, data.prevStart));\n    prevEnd = strlen(store.ontology.text.slice(0, data.prevEnd));\n    store.ontology.text = store.ontology.text.slice(0, data.prevStart) + data.slice + store.ontology.text.slice(data.prevEnd);\n    // update labels and insertions\n    const offset = slice.length - prevSlice.length;\n\n    if (type === ACTION.EDIT_REPLACE && prevTags) {\n      const { insertions = [], labels = [], connections = [] } = prevTags;\n      [...insertions, ...labels, ...connections].forEach((t) => {\n        store.ontology.deleteTag(t.type, t.id);\n      });\n    }\n    store.ontology.tagMove(prevStart, prevEnd, offset);\n    if (type === ACTION.EDIT_REPLACE && tags) {\n      const { insertions = [], labels = [], connections = [] } = tags;\n      [...insertions, ...labels, ...connections].forEach((t) => {\n        store.ontology.addResultItem(t);\n      });\n    }\n\n    // update rawDraftContentState, using new text and results\n    // this.updateFindTags();\n    this.raw = this.renderTextArea();\n\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    return editorState;\n  };\n\n  resetCurrentFocus = (attribute = 'currentClick', shouldUpdate) => new Promise((resolve) => {\n    this.setState({\n      [`${attribute}`]: { id: null, from: null, to: null },\n    }, () => resolve('state updated'));\n  }).then(() => {\n    if (shouldUpdate) {\n      return this.updateEditorAndRender();\n    }\n  });\n\n  resetCurrentFrom = () => {\n    this.setState({\n      currentFrom: { type: null, id: null, offset: null },\n    });\n  };\n\n  // to status for tag: connection mode and other mode\n  onTagClick = (e, type, id) => {\n    const { currentFrom, currentBrush, editorState, tagMap } = this.state;\n    const offset = tagMap.getItem(id, type);\n    this.editor.blur();\n    if (!isConnection(currentBrush?.type)) return;\n\n    // connecting mode only applys to label and insertion\n    if (isLabel(type) || isInsertion(type)) {\n      // if there is no starting point, setup the starting point\n      if (!currentFrom.type) {\n        this.setState({\n          currentFrom: {\n            type,\n            id,\n            offset,\n          }\n        });\n      } else {\n        const nextEditorState = this.addConnection(editorState, { fromId: currentFrom.id, fromType: currentFrom.type, toId: id, toType: type, type: TAG.CONNECTION, value: currentBrush.text, keys: currentBrush.keys });\n        this.renderAndSave(nextEditorState, true, true);\n      }\n    }\n  };\n\n  onTagDoubleClick = (e) => {\n    // only work in qa mode\n    if (!store.reviewable && !store.isRework) {\n      return;\n    }\n    const { id, type } = getTargetWrapperDataSet(e);\n    const item = store.ontology.getItem(type, id);\n    const tagReviewInfo = store.review.getReview(id);\n    this.setState({ tagOpenReview: item, tagReviewInfo });\n    this.editor.blur();\n  };\n\n  // mouseEvent includes: mouse enter, mouse leave, mouse click, mouse context menu\n  TagMouseEvent = (e, type, id, focusType, active) => {\n    const { currentClick: { id: currId } } = this.state;\n    const tag = store.ontology.getItem(type, id);\n    if (!tag) {\n      return;\n    }\n\n    let attribute = '';\n    if (focusType === FOCUS_TYPE.HOVER) {\n      if (currId === tag.id && active) return;\n      attribute = 'currentHover';\n    } else if (focusType === FOCUS_TYPE.CLICK) {\n      attribute = 'currentClick';\n      this.editor.blur();\n    }\n\n    // active status: mouse enter | mouse click\n    if (active) {\n      if (focusType === FOCUS_TYPE.CLICK) {\n        this.onTagClick(e, type, id);\n      }\n      // ranges.push({ offset: label.start, length: label.end - label.start, style: `${focusType}_STYLE_${color}` });\n      this.setState({\n        [`${attribute}`]: {\n          id: tag.id,\n          fromId: tag?.fromId,\n          toId: tag?.toId,\n          fromType: tag?.fromType,\n          toType: tag?.toType,\n          type: tag?.type,\n        }\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    } else { // unactive status: mouse leave | mouse context menu\n      const tagType = type;\n      this.resetCurrentFocus(attribute, true).then(() => {\n        if (focusType === FOCUS_TYPE.CLICK) {\n          this.onContextMenu(e, tag.id, tagType);\n        }\n      });\n    }\n  };\n\n  onContextMenu = (e, id, type) => {\n    let nextEditorState;\n    switch (type) {\n      case TAG.LABEL:\n      case TAG.CONNECTION:\n      case TAG.INSERTION:\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      case TAG.LABEL_QA:\n      {\n        const { editorState } = this.deleteQATag(id);\n        nextEditorState = editorState;\n        break;\n      }\n      default: return;\n    }\n    this.renderAndSave(nextEditorState);\n  };\n\n\n\n  focusSelectedFoundTag = () => {\n    this.updateEditorAndRender();\n    const { foundTags, foundTagSelectedIndex } = this.state;\n    const selectedTag = foundTags[foundTagSelectedIndex];\n    if (selectedTag) {\n      const span = this.getAnchorElementByHead(selectedTag.start);\n      if (span && this.editorWrapper && !isElementInViewport(span, this.editorWrapper)) {\n        const { top } = span.getBoundingClientRect();\n        const offsetHeight = this.editorWrapper.clientHeight / 2;\n        const scrollTop = this.editorWrapper.scrollTop + top - offsetHeight;\n        this.editorWrapper.scroll(0, scrollTop);\n      }\n    }\n  };\n\n  updateFindTags = () => new Promise((resolve) => {\n    const { findStr } = this.state;\n    const str = store.ontology.text;\n    const reg = new RegExp(escapeCharacter(findStr), 'g');\n    const ans = [];\n    if (findStr) {\n      let matched = null;\n      let i = 0;\n      // eslint-disable-next-line no-cond-assign\n      while ((matched = reg.exec(str)) !== null) {\n        const temp = {\n          start: matched.index,\n          end: matched.index + findStr.length,\n          id: i,\n        };\n        ans.push(temp);\n        i += 1;\n      }\n    }\n    this.setState({ foundTags: ans, foundTagSelectedIndex: -1 }, () => {\n      resolve();\n    });\n  });\n\n  render() {\n    const {\n      editorState,\n      style,\n      currentBrush,\n      editorWidth,\n      editorHeight,\n      currentClick,\n      currentHover,\n      currentMouse,\n      currentFrom,\n      tagMap,\n      tagOpenReview,\n      tagReviewInfo,\n\n      inputEnable,\n    } = this.state;\n    const { config } = store;\n    return (\n      <div className=\"app-wrapper\">\n        <div className=\"topbar-wrapper\" onClick={() => { this.editorOnFocus = false; }}>\n          <div className=\"topbar-left-wrapper\">\n            {isAppenCloud() && (\n            <div className=\"logo\">\n              <AppenLogo />\n            </div>\n            )}\n            <ReviewMode />\n            <div className=\"divider\" />\n            <UndoRedo\n              undoHandle={() => this.executeHistory(RECALL_TYPE.UNDO)}\n              redoHandle={() => this.executeHistory(RECALL_TYPE.REDO)}\n              undoList={this.undoList}\n              redoList={this.redoList}\n            />\n            <div className=\"divider\" />\n            <Save onSave={this.onSave} />\n          </div>\n          <div className=\"topbar-right-wrapper\">\n            {/* <LabelScan onToggle={this.toggleLabelsDrawer} /> */}\n          </div>\n        </div>\n        <TextToolContext.Provider value={{ moveFocusToTag: this.moveFocusToTag, deleteReviewItemById: this.deleteReviewItemById, deleteReviewItemsById: this.deleteReviewItemsById }}>\n          <Sidebar\n            showReview={isRework(this.toolMode) || isReviewEditable(this.toolMode)}\n            onClick={() => { this.editorOnFocus = false; }}\n            currentBrush={currentBrush}\n            inputEnable={inputEnable}\n            setCurrentBrush={this.setCurrentBrush}\n            items={tagMap}\n            contentReadyOnly={this.props.read_only}\n          />\n        </TextToolContext.Provider>\n        <div className=\"right-wrapper\">\n          <div\n            className=\"editor-wrapper\"\n            ref={(r) => { this.editorWrapper = r; }}\n          >\n            <div className=\"svg-wrapper\">\n              <svg ref={(r) => { this.svg = r; }} style={{ height: `${editorHeight}px`, width: `${editorWidth}px` }}>\n                {Object.entries(tagMap.connections).map(([id, connect]) => (\n                  <g key={id}>\n                    <path\n                      d={connect.path}\n                      stroke={currentHover.id === id ? HOVER_COLOR : currentClick.id === id ? FOCUS_COLOR : DEFAULT_COLOR}\n                      fill=\"#00000000\"\n                    />\n                  </g>\n                ))}\n                {currentFrom.type ?\n                  <path d={`M ${currentFrom.offset?.left} ${currentFrom.offset?.top} L ${currentMouse.left} ${currentMouse.top}`} stroke={FOCUS_COLOR} fill=\"#00000000\" /> :\n                  null}\n              </svg>\n            </div>\n            <div className=\"tags-wrapper\">\n              <div\n                className=\"tags-panel\"\n                style={{ height: `${editorHeight}px`, width: `${editorWidth}px` }}\n                onDoubleClick={this.onTagDoubleClick}\n              >\n                {Object.entries(tagMap.labels).map(([id, label]) => (\n                  <LabelTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    label={label}\n                    isHover={\n                      (currentHover.id === id) ||\n                      currentHover.fromId === id ||\n                      currentHover.toId === id\n                    }\n                    isClick={\n                      (currentClick.id === id) ||\n                      currentClick.fromId === id ||\n                      currentClick.toId === id\n                    }\n                    labelMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n                {Object.entries(tagMap.insertions).map(([id, insertion]) => (\n                  <InsertionTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    insertion={insertion}\n                    isHover={\n                      (currentHover.id === id) ||\n                      currentHover.fromId === id ||\n                      currentHover.toId === id\n                    }\n                    isClick={\n                      (currentClick.id === id) ||\n                      currentClick.fromId === id ||\n                      currentClick.toId === id\n                    }\n                    insertionMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n                {Object.entries(tagMap.connections).map(([id, connection]) => (\n                  <ConnectionTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    connection={connection}\n                    isHover={currentHover.id === id}\n                    isClick={currentClick.id === id}\n                    connectionMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n              </div>\n            </div>\n            <div\n              onClick={() => {\n                this.editor.focus();\n                this.resetCurrentFocus('currentClick', true);\n              }}\n            >\n              <Editor\n                ref={(r) => { this.editor = r; }}\n                editorState={editorState}\n                customStyleMap={style}\n                onChange={this.onChange}\n                handlePastedText={this.handlePastedText}\n                handleBeforeInput={this.handleBeforeInput}\n                handleKeyCommand={this.handleKeyCommand}\n                keyBindingFn={this.genKeyCommand}\n              />\n            </div>\n          </div>\n          {/* {labelsDrawerOpen && (\n            <LabelsDisplay\n              title={localMessage('LABEL_CONTENT')}\n              labelsDrawerOpen={labelsDrawerOpen}\n              displayLabels={displayLabels}\n            />\n          )} */}\n        </div>\n        <ReviewForm\n          toolMode={this.toolMode}\n          tagReviewInfo={tagReviewInfo}\n          tagOpenReview={tagOpenReview}\n          issueTypes={this.props.issue_types}\n          setFormVisible={this.setFormVisible}\n          onConfirm={(review) => {\n            this.addReview(editorState, tagOpenReview?.id, review);\n            store.ontology.updateOntologiesStatusMap();\n          }}\n          onDelete={this.onDeleteReview}\n        />\n      </div>\n    );\n  };\n\n  setCurrentBrush = (item, input = false) => {\n    this.setState({ currentBrush: item, inputEnable: input });\n  };\n\n  setFormVisible = () => {\n    this.setState({ tagOpenReview: null, tagReviewInfo: null });\n  };\n\n  genKeyCommand = (e) => {\n    if (e.metaKey || e.altKey) return KEY_COMMAND.INVALID_KEY;\n    switch (e.keyCode) {\n      case 90:\n        // prevent default undo\n        e.preventDefault();\n        if (e.ctrlKey) return KEY_COMMAND.HANDLE_UNDO;\n        return getDefaultKeyBinding(e);\n      case 89:\n        // prevent default redo\n        e.preventDefault();\n        if (e.ctrlKey) return KEY_COMMAND.HANDLE_REDO;\n        return getDefaultKeyBinding(e);\n      case 13:\n        e.preventDefault();\n        return KEY_COMMAND.HANDLE_RETURN;\n      default:\n        return getDefaultKeyBinding(e);\n    }\n  };\n\n  handleKeyCommand = (command) => {\n    const { editorState } = this.state;\n    switch (command) {\n      case KEY_COMMAND.INVALID_KEY: return 'handled';\n      case KEY_COMMAND.HANDLE_RETURN:\n      {\n        const start = editorState.getSelection().getStartOffset();\n        const end = editorState.getSelection().getEndOffset();\n        const nextEditorState = setSelection(this.onContentChange(editorState, {\n          slice: '\\n',\n          prevSlice: store.ontology.text.slice(start, end),\n          prevStart: start,\n          prevEnd: end,\n          start: start + 1,\n          end: start + 1,\n        }), start + 1, start + 1);\n        this.renderAndSave(nextEditorState);\n        return 'handled';\n      }\n      case KEY_COMMAND.HANDLE_UNDO: return 'handled';\n      case KEY_COMMAND.HANDLE_REDO: return 'handled';\n      default: return 'not-handled';\n    }\n  };\n\n  // Get one anchor by slice head\n  getAnchorElementByHead = (at) => {\n    const { sliceMap } = this;\n    const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n    const id = `span-wrapper-0-${sliceMap.get(at)}`;\n    const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n    return span;\n  };\n\n  // Get all anchors at one time\n  getAnchorElementsByHeads = () => {\n    const { sliceMap } = this;\n    const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n    const spanMap = new Map();\n    sliceMap.forEach((value, key) => {\n      const id = `span-wrapper-0-${sliceMap.get(key)}`;\n      const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n      spanMap.set(key, span);\n    });\n    return spanMap;\n  };\n\n  onMouseDown = (e) => {\n    if (e.which === 1) {\n      this.mouseFlag = true;\n    }\n    const onMouseUp = () => {\n      this.mouseFlag = false;\n      window.removeEventListener('mouseup', onMouseUp);\n    };\n    window.addEventListener('mouseup', onMouseUp);\n  };\n\n  onCompositionEnd = () => {\n    this.compositionFlag = COMPOSITION.PENDING;\n  };\n\n  onCompositionStart = () => {\n    this.compositionFlag = COMPOSITION.ENABLED;\n    this.compositionTop = this.editorWrapper.scrollTop;\n  };\n\n  handleBeforeInput = () => { this.inputFlag = true; return 'not-handled'; };\n\n  handlePastedText = () => { this.pasteFlag = true; return 'not-handled'; };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}