{"ast":null,"code":"import{Container}from'pixi.js';import polygonClipping from'polygon-clipping';import{ShapeType}from'./types';import ShapeGraphics from'./ShapeGraphics';export function coverTest(shape,shapes){if(shapes.length<=0){return false;}const{left:cLeft,top:cTop,right:cRight,bottom:cBottom}=shape.instance.getLocalBounds();const shapeBounds=shapes.map(s=>s.instance.getLocalBounds());const intersectedBounds=[];// if covered by any front shape, should be selected\nconst isCoveredByAnyShape=shapeBounds.some(bounds=>{const{left,top,right,bottom}=bounds;const covered=cLeft>=left&&cRight<=right&&cTop>=top&&cBottom<=bottom;const intersected=cLeft<=right&&cRight>=left&&cTop<=bottom&&cBottom>=top;if(intersected){intersectedBounds.push(bounds);}return covered;});if(isCoveredByAnyShape){return isCoveredByAnyShape;}// if covered by front shapes bounding box, should be selected\nif(intersectedBounds.length<=0){return false;}let{left,top,right,bottom}=intersectedBounds[0];for(let i=1;i<intersectedBounds.length;i+=1){const bounds=intersectedBounds[i];if(left<=bounds.right&&right>=bounds.left&&top<=bounds.bottom&&bottom>=bounds.top){left=Math.min(left,bounds.left);top=Math.min(top,bounds.top);right=Math.max(right,bounds.right);bottom=Math.max(bottom,bounds.bottom);}}return cLeft>=left&&cTop>=top&&cRight<=right&&cBottom<=bottom;}export function hitTesting(point,localPoint,rootChildren){const allShapes=[];let snappingPoint=null;const getIntersections=children=>{let shapes=[];for(let i=0;i<children.length;i+=1){const child=children[i];if(child.visible){if(child instanceof ShapeGraphics){if(!snappingPoint&&child.shape.finished&&!child.shape.resizing&&!child.shape.dragging){const sp=child.shape.snapToPoint(localPoint);if(sp){snappingPoint=sp;}}if(child.interactive&&child.shape.finished){allShapes.push(child.shape);if(child.shape.shapeType===ShapeType.LINE){if(child.hitArea.contains(localPoint.x,localPoint.y)){shapes.push(child.shape);}}else if(child.containsPoint(point)){shapes.push(child.shape);}}}else if(child instanceof Container){shapes=[...shapes,...getIntersections(child.children)];}}}return shapes;};const originalIntersections=getIntersections(rootChildren);const filteredIntersectionIds=[];let intersections=[];if(originalIntersections.length>1){// filter out some shapes that cover all intersections\nfor(let i=0;i<originalIntersections.length;i+=1){const curr=originalIntersections[i];const others=[...originalIntersections.slice(0,i),...originalIntersections.slice(i+1)];if(others.every(o=>coverTest(o,[curr]))){filteredIntersectionIds.push(curr.uid);}else{intersections.push(curr);}}}else{intersections=[...originalIntersections];}intersections.sort((a,b)=>{const abox=a.instance.getLocalBounds();const bbox=b.instance.getLocalBounds();return abox.width*abox.height-bbox.width*bbox.height;});// sort by area, small shapes have higher priority\nlet intersection;for(let i=0;i<intersections.length;i+=1){const curr=intersections[i];const otherIntersections=[...intersections.slice(0,i),...intersections.slice(i+1)];if(coverTest(curr,otherIntersections)){// covered by other intersections\nintersection=curr;break;}const fronts=allShapes.filter(s=>s.order>curr.order&&!filteredIntersectionIds.includes(s.uid));if(coverTest(curr,fronts)){// covered by front shapes\nintersection=curr;break;}}return{intersection:intersection||intersections[0],snappingPoint};}export function findIntersections(currentShapeData,currentShapeBounds,currentShapeType,shapes){const intersections=[];for(let i=0;i<shapes.length;i+=1){const shape=shapes[i];const{shapeBounds}=shape;if(shapeBounds.left<currentShapeBounds.right&&shapeBounds.right>currentShapeBounds.left&&shapeBounds.top<currentShapeBounds.bottom&&shapeBounds.bottom>currentShapeBounds.top){// bbox intersects\nif(currentShapeType===ShapeType.DOT||shape.shapeType===ShapeType.DOT){// one of the shapes is dot\nintersections.push(shape);}else{const shapeData=shape.getAreaAsGeoJSON();const intersection=polygonClipping.intersection(currentShapeData,shapeData);if(intersection.length>0){intersections.push(shape);}}}}return intersections;}export function precise(num){return Math.round(num*1000000)/1000000;}export function normalizePoints(points){const newPoints=[];points.forEach((point,index)=>{const nextPoint=points[index===points.length-1?0:index+1];const npx=precise(nextPoint[0]);const npy=precise(nextPoint[1]);const px=precise(point[0]);const py=precise(point[1]);if(px!==npx||py!==npy){newPoints.push({x:px,y:py});}});return newPoints;}export function drawVertex(graphics,x,y,size){graphics.drawCircle(x,y,size);}","map":{"version":3,"names":["Container","polygonClipping","ShapeType","ShapeGraphics","coverTest","shape","shapes","length","left","cLeft","top","cTop","right","cRight","bottom","cBottom","instance","getLocalBounds","shapeBounds","map","s","intersectedBounds","isCoveredByAnyShape","some","bounds","covered","intersected","push","i","Math","min","max","hitTesting","point","localPoint","rootChildren","allShapes","snappingPoint","getIntersections","children","child","visible","finished","resizing","dragging","sp","snapToPoint","interactive","shapeType","LINE","hitArea","contains","x","y","containsPoint","originalIntersections","filteredIntersectionIds","intersections","curr","others","slice","every","o","uid","sort","a","b","abox","bbox","width","height","intersection","otherIntersections","fronts","filter","order","includes","findIntersections","currentShapeData","currentShapeBounds","currentShapeType","DOT","shapeData","getAreaAsGeoJSON","precise","num","round","normalizePoints","points","newPoints","forEach","index","nextPoint","npx","npy","px","py","drawVertex","graphics","size","drawCircle"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/utils.ts"],"sourcesContent":["import { Container, DisplayObject, Graphics, Point, Rectangle } from 'pixi.js';\nimport polygonClipping, { Geom } from 'polygon-clipping';\nimport { ShapeType, ShapeData } from './types';\nimport ShapeGraphics from './ShapeGraphics';\nimport type Shape from './Shape';\n\nexport function coverTest(shape: Shape<ShapeType>, shapes: Shape<ShapeType>[]) {\n  if (shapes.length <= 0) {\n    return false;\n  }\n  const { left: cLeft, top: cTop, right: cRight, bottom: cBottom } = shape.instance.getLocalBounds();\n  const shapeBounds = shapes.map((s) => s.instance.getLocalBounds());\n  const intersectedBounds: Rectangle[] = [];\n\n  // if covered by any front shape, should be selected\n  const isCoveredByAnyShape = shapeBounds.some((bounds) => {\n    const { left, top, right, bottom } = bounds;\n    const covered = cLeft >= left && cRight <= right && cTop >= top && cBottom <= bottom;\n    const intersected = cLeft <= right && cRight >= left && cTop <= bottom && cBottom >= top;\n    if (intersected) {\n      intersectedBounds.push(bounds);\n    }\n    return covered;\n  });\n  if (isCoveredByAnyShape) {\n    return isCoveredByAnyShape;\n  }\n\n  // if covered by front shapes bounding box, should be selected\n  if (intersectedBounds.length <= 0) {\n    return false;\n  }\n  let { left, top, right, bottom } = intersectedBounds[0];\n  for (let i = 1; i < intersectedBounds.length; i += 1) {\n    const bounds = intersectedBounds[i];\n    if (left <= bounds.right && right >= bounds.left && top <= bounds.bottom && bottom >= bounds.top) {\n      left = Math.min(left, bounds.left);\n      top = Math.min(top, bounds.top);\n      right = Math.max(right, bounds.right);\n      bottom = Math.max(bottom, bounds.bottom);\n    }\n  }\n  return cLeft >= left && cTop >= top && cRight <= right && cBottom <= bottom;\n}\n\nexport function hitTesting(point: Point, localPoint: Point, rootChildren: DisplayObject[]) {\n  const allShapes: Shape<ShapeType>[] = [];\n  let snappingPoint: Point | null = null;\n\n  const getIntersections = (children: DisplayObject[]) => {\n    let shapes: Shape<ShapeType>[] = [];\n    for (let i = 0; i < children.length; i += 1) {\n      const child = children[i];\n      if (child.visible) {\n        if (child instanceof ShapeGraphics) {\n          if (!snappingPoint && child.shape.finished && !child.shape.resizing && !child.shape.dragging) {\n            const sp = child.shape.snapToPoint(localPoint);\n            if (sp) {\n              snappingPoint = sp;\n            }\n          }\n          if (child.interactive && child.shape.finished) {\n            allShapes.push(child.shape);\n            if (child.shape.shapeType === ShapeType.LINE) {\n              if (child.hitArea.contains(localPoint.x, localPoint.y)) {\n                shapes.push(child.shape);\n              }\n            } else if (child.containsPoint(point)) {\n              shapes.push(child.shape);\n            }\n          }\n        } else if (child instanceof Container) {\n          shapes = [...shapes, ...getIntersections(child.children)];\n        }\n      }\n    }\n    return shapes;\n  };\n\n  const originalIntersections = getIntersections(rootChildren);\n  const filteredIntersectionIds: string[] = [];\n  let intersections: Shape<ShapeType>[] = [];\n  if (originalIntersections.length > 1) {\n    // filter out some shapes that cover all intersections\n    for (let i = 0; i < originalIntersections.length; i += 1) {\n      const curr = originalIntersections[i];\n      const others = [...originalIntersections.slice(0, i), ...originalIntersections.slice(i + 1)];\n      if (others.every((o) => coverTest(o, [curr]))) {\n        filteredIntersectionIds.push(curr.uid);\n      } else {\n        intersections.push(curr);\n      }\n    }\n  } else {\n    intersections = [...originalIntersections];\n  }\n\n  intersections.sort((a, b) => {\n    const abox = a.instance.getLocalBounds();\n    const bbox = b.instance.getLocalBounds();\n    return abox.width * abox.height - bbox.width * bbox.height;\n  }); // sort by area, small shapes have higher priority\n\n  let intersection;\n  for (let i = 0; i < intersections.length; i += 1) {\n    const curr = intersections[i];\n    const otherIntersections = [...intersections.slice(0, i), ...intersections.slice(i + 1)];\n    if (coverTest(curr, otherIntersections)) {\n      // covered by other intersections\n      intersection = curr;\n      break;\n    }\n    const fronts = allShapes.filter((s) => s.order > curr.order && !filteredIntersectionIds.includes(s.uid));\n    if (coverTest(curr, fronts)) {\n      // covered by front shapes\n      intersection = curr;\n      break;\n    }\n  }\n\n  return {\n    intersection: intersection || intersections[0],\n    snappingPoint,\n  };\n}\n\nexport function findIntersections(\n  currentShapeData: Geom,\n  currentShapeBounds: { left: number, top: number, right: number, bottom: number },\n  currentShapeType: ShapeType,\n  shapes: Shape<ShapeData>[],\n): Shape<ShapeData>[] {\n  const intersections: Shape<ShapeData>[] = [];\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    const { shapeBounds } = shape;\n    if (\n      shapeBounds.left < currentShapeBounds.right &&\n      shapeBounds.right > currentShapeBounds.left &&\n      shapeBounds.top < currentShapeBounds.bottom &&\n      shapeBounds.bottom > currentShapeBounds.top\n    ) {\n      // bbox intersects\n      if (currentShapeType === ShapeType.DOT || shape.shapeType === ShapeType.DOT) {\n        // one of the shapes is dot\n        intersections.push(shape);\n      } else {\n        const shapeData = shape.getAreaAsGeoJSON();\n        const intersection = polygonClipping.intersection(currentShapeData, shapeData);\n        if (intersection.length > 0) {\n          intersections.push(shape);\n        }\n      }\n    }\n  }\n  return intersections;\n}\n\nexport function precise(num: number) {\n  return Math.round(num * 1000000) / 1000000;\n}\n\nexport function normalizePoints(points: [number, number][]) {\n  const newPoints: { x: number; y: number }[] = [];\n  points.forEach((point, index) => {\n    const nextPoint = points[index === points.length - 1 ? 0 : index + 1];\n    const npx = precise(nextPoint[0]);\n    const npy = precise(nextPoint[1]);\n    const px = precise(point[0]);\n    const py = precise(point[1]);\n    if (px !== npx || py !== npy) {\n      newPoints.push({ x: px, y: py });\n    }\n  });\n  return newPoints;\n}\n\nexport function drawVertex(graphics: Graphics, x: number, y: number, size: number) {\n  graphics.drawCircle(x, y, size);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}