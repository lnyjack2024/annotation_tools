{"ast":null,"code":"import { utils } from '@appen-china/easy-form';\nimport { FieldControlType } from '@appen-china/easy-form/es/types';\n// eslint-disable-next-line import/prefer-default-export\nexport function triggerFormRules(config, values) {\n  const {\n    fields: configFields,\n    conditions = [],\n    effects = [],\n    rules = []\n  } = config;\n  const fields = (configFields || []).map(field => ({\n    ...field,\n    ...(values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n  const parsedValue = utils.parseFormFields(fields);\n  // trigger rule effects\n  const {\n    updatedFields,\n    updatedValues\n  } = rules.reduce((acc, curr) => utils.ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects), {\n    updatedFields: parsedValue.fields,\n    updatedValues: parsedValue.initialValues\n  });\n\n  // remove invisible values\n  updatedFields.forEach(f => {\n    if (!f.visible) {\n      delete updatedValues[f.name];\n    }\n  });\n  return {\n    updatedValues,\n    updatedFields\n  };\n}\n\n/**\n * get field option label\n * @param value\n * @param options\n */\nexport function getFieldOptionLabel(value, options) {\n  const option = options.find(o => o.value === value);\n  return (option === null || option === void 0 ? void 0 : option.label) || `${value}`;\n}\n\n/**\n * get field display label\n * @param value\n * @param field\n */\nexport function getFieldDisplayLabel(fieldValue, field) {\n  let displayValue = '';\n  if (fieldValue !== undefined && fieldValue !== null) {\n    if (field === null || field === void 0 ? void 0 : field.options) {\n      displayValue = Array.isArray(fieldValue) ? `${fieldValue.map(v => getFieldOptionLabel(v, field.options))}` : getFieldOptionLabel(fieldValue, field.options);\n    } else {\n      displayValue = `${fieldValue}`;\n    }\n  }\n  return displayValue;\n}\n\n/**\n * get field option item‘s reference url\n * @param value\n * @param field\n * @param keys match by keys order\n */\nexport function getReferenceImageUrl(fieldValue, field, keys = ['value']) {\n  if ((field === null || field === void 0 ? void 0 : field.type) !== FieldControlType.RADIO) {\n    return;\n  }\n  let referenceImage = '';\n  if (fieldValue !== undefined && fieldValue !== null) {\n    if (field === null || field === void 0 ? void 0 : field.options) {\n      const option = field === null || field === void 0 ? void 0 : field.options.find(o => {\n        for (let index = 0; index < keys.length; index += 1) {\n          const element = keys[index];\n          if (o[element] === fieldValue) {\n            return true;\n          }\n        }\n        return false;\n      });\n      referenceImage = (option === null || option === void 0 ? void 0 : option.referenceUrl) || '';\n    }\n  }\n  return referenceImage;\n}\n;\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config) {\n  const map = {};\n  ((config === null || config === void 0 ? void 0 : config.fields) || []).forEach(field => {\n    const {\n      name,\n      label,\n      type,\n      valueType,\n      options = []\n    } = field;\n    const newField = {\n      name,\n      type,\n      label\n    };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = utils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}","map":{"version":3,"names":["utils","FieldControlType","triggerFormRules","config","values","fields","configFields","conditions","effects","rules","map","field","name","undefined","defaultValue","parsedValue","parseFormFields","updatedFields","updatedValues","reduce","acc","curr","ruleTrigger","initialValues","forEach","f","visible","getFieldOptionLabel","value","options","option","find","o","label","getFieldDisplayLabel","fieldValue","displayValue","Array","isArray","v","getReferenceImageUrl","keys","type","RADIO","referenceImage","index","length","element","referenceUrl","parseFields","valueType","newField","SELECT","CHECKBOX","CASCADER","parseOptions"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/utils/form.ts"],"sourcesContent":["import { utils } from '@appen-china/easy-form';\nimport { FormConfig, FieldValue, FieldOption, FieldControlType } from '@appen-china/easy-form/es/types';\n\nexport interface FieldConfig {\n  name: string;\n  type: FieldControlType;\n  label?: string;\n  options?: FieldOption[];\n}\n\n// eslint-disable-next-line import/prefer-default-export\nexport function triggerFormRules(config: FormConfig, values: any) {\n  const { fields: configFields, conditions = [], effects = [], rules = [] } = config;\n  const fields = (configFields || []).map((field) => ({\n    ...field,\n    ...values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n\n  const parsedValue = utils.parseFormFields(fields);\n  // trigger rule effects\n  const { updatedFields, updatedValues } = rules.reduce(\n    (acc, curr) => utils.ruleTrigger(\n      curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects,\n    ),\n    { updatedFields: parsedValue.fields, updatedValues: parsedValue.initialValues },\n  );\n\n  // remove invisible values\n  updatedFields.forEach((f) => {\n    if (!f.visible) {\n      delete updatedValues[f.name];\n    }\n  });\n  return {\n    updatedValues,\n    updatedFields,\n  };\n}\n\n/**\n * get field option label\n * @param value\n * @param options\n */\nexport function getFieldOptionLabel(value: FieldValue, options: FieldOption[]) {\n  const option = options.find((o) => o.value === value);\n  return option?.label || `${value}`;\n}\n\n/**\n * get field display label\n * @param value\n * @param field\n */\nexport function getFieldDisplayLabel(fieldValue: FieldValue | FieldValue[], field?: FieldConfig) {\n  let displayValue = '';\n  if (fieldValue !== undefined && fieldValue !== null) {\n    if (field?.options) {\n      displayValue = Array.isArray(fieldValue)\n        ? `${fieldValue.map((v) => getFieldOptionLabel(v, field.options!))}`\n        : getFieldOptionLabel(fieldValue, field.options);\n    } else {\n      displayValue = `${fieldValue}`;\n    }\n  }\n  return displayValue;\n}\n\n/**\n * get field option item‘s reference url\n * @param value\n * @param field\n * @param keys match by keys order\n */\nexport function getReferenceImageUrl(fieldValue: FieldValue, field?: FieldConfig, keys: ('value' | 'label')[] = ['value']) {\n  if (field?.type !== FieldControlType.RADIO) {\n    return;\n  }\n  let referenceImage = '';\n  if (fieldValue !== undefined && fieldValue !== null) {\n    if (field?.options) {\n      const option = field?.options.find((o) => {\n        for (let index = 0; index < keys.length; index += 1) {\n          const element = keys[index];\n          if (o[element] === fieldValue) {\n            return true;\n          }\n        }\n        return false;\n      });\n      referenceImage = option?.referenceUrl || '';\n    }\n  }\n  return referenceImage;\n};\n\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config?: FormConfig) {\n  const map: { [fieldName: string]: FieldConfig } = {};\n  (config?.fields || []).forEach((field) => {\n    const { name, label, type, valueType, options = [] } = field;\n    const newField: FieldConfig = { name, type, label };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = utils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}