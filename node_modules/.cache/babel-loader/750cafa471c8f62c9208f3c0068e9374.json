{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\n/*:: import type {\n  CellRenderer,\n  CellRangeRenderer,\n  CellPosition,\n  CellSize,\n  CellSizeGetter,\n  NoContentRenderer,\n  Scroll,\n  ScrollbarPresenceChange,\n  RenderedSection,\n  OverscanIndicesGetter,\n  Alignment,\n  CellCache,\n  StyleCache,\n} from './types';*/\n/*:: import type {AnimationTimeoutId} from '../utils/requestAnimationTimeout';*/\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport calculateSizeAndPositionDataAndUpdateScrollOffset from './utils/calculateSizeAndPositionDataAndUpdateScrollOffset';\nimport ScalingCellSizeAndPositionManager from './utils/ScalingCellSizeAndPositionManager';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport defaultOverscanIndicesGetter, { SCROLL_DIRECTION_BACKWARD, SCROLL_DIRECTION_FORWARD } from './defaultOverscanIndicesGetter';\nimport updateScrollIndexHelper from './utils/updateScrollIndexHelper';\nimport defaultCellRangeRenderer from './defaultCellRangeRenderer';\nimport scrollbarSize from 'dom-helpers/scrollbarSize';\nimport { polyfill } from 'react-lifecycles-compat';\nimport { requestAnimationTimeout, cancelAnimationTimeout } from '../utils/requestAnimationTimeout';\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nexport var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\nvar renderNull /*: NoContentRenderer*/ = function renderNull() {\n  return null;\n};\n/*:: type ScrollPosition = {\n  scrollTop?: number,\n  scrollLeft?: number,\n};*/\n/*:: type Props = {\n  'aria-label': string,\n  'aria-readonly'?: boolean,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   *-/\n  autoContainerWidth: boolean,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   *-/\n  autoHeight: boolean,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   *-/\n  autoWidth: boolean,\n\n  /** Responsible for rendering a cell given an row and column index.  *-/\n  cellRenderer: CellRenderer,\n\n  /** Responsible for rendering a group of cells given their index ranges.  *-/\n  cellRangeRenderer: CellRangeRenderer,\n\n  /** Optional custom CSS class name to attach to root Grid element.  *-/\n  className?: string,\n\n  /** Number of columns in grid.  *-/\n  columnCount: number,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  *-/\n  columnWidth: CellSize,\n\n  /** Unfiltered props for the Grid container. *-/\n  containerProps?: Object,\n\n  /** ARIA role for the cell-container.  *-/\n  containerRole: string,\n\n  /** Optional inline style applied to inner cell-container *-/\n  containerStyle: Object,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   *-/\n  deferredMeasurementCache?: Object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   *-/\n  estimatedColumnSize: number,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   *-/\n  estimatedRowSize: number,\n\n  /** Exposed for testing purposes only.  *-/\n  getScrollbarSize: () => number,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  *-/\n  height: number,\n\n  /** Optional custom id to attach to root Grid element.  *-/\n  id?: string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   *-/\n  isScrolling?: boolean,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   *-/\n  isScrollingOptOut: boolean,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  *-/\n  noContentRenderer: NoContentRenderer,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   *-/\n  onScroll: (params: Scroll) => void,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   *-/\n  onScrollbarPresenceChange: (params: ScrollbarPresenceChange) => void,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  *-/\n  onSectionRendered: (params: RenderedSection) => void,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   *-/\n  overscanColumnCount: number,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   *-/\n  overscanIndicesGetter: OverscanIndicesGetter,\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   *-/\n  overscanRowCount: number,\n\n  /** ARIA role for the grid element.  *-/\n  role: string,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   *-/\n  rowHeight: CellSize,\n\n  /** Number of rows in grid.  *-/\n  rowCount: number,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. *-/\n  scrollingResetTimeInterval: number,\n\n  /** Horizontal offset. *-/\n  scrollLeft?: number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   *-/\n  scrollToAlignment: Alignment,\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) *-/\n  scrollToColumn: number,\n\n  /** Vertical offset. *-/\n  scrollTop?: number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) *-/\n  scrollToRow: number,\n\n  /** Optional inline style *-/\n  style: Object,\n\n  /** Tab index for focus *-/\n  tabIndex: ?number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  *-/\n  width: number,\n\n  /** Reference to DOM node *-/\n  elementRef?: React.Ref<React.ElementType>,\n};*/\n/*:: type InstanceProps = {\n  prevColumnWidth: CellSize,\n  prevRowHeight: CellSize,\n\n  prevColumnCount: number,\n  prevRowCount: number,\n  prevIsScrolling: boolean,\n  prevScrollToColumn: number,\n  prevScrollToRow: number,\n\n  columnSizeAndPositionManager: ScalingCellSizeAndPositionManager,\n  rowSizeAndPositionManager: ScalingCellSizeAndPositionManager,\n\n  scrollbarSize: number,\n  scrollbarSizeMeasured: boolean,\n};*/\n/*:: type State = {\n  instanceProps: InstanceProps,\n  isScrolling: boolean,\n  scrollDirectionHorizontal: -1 | 1,\n  scrollDirectionVertical: -1 | 1,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollPositionChangeReason: 'observed' | 'requested' | null,\n  needToResetStyleCache: boolean,\n};*/\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\nvar Grid = /*#__PURE__*/function (_React$PureComponent) {\n  function Grid(props /*: Props*/) {\n    var _this;\n    _classCallCheck(this, Grid);\n    _this = _callSuper(this, Grid, [props]);\n    // Invokes onSectionRendered callback only when start/stop row or column indices change\n    _defineProperty(_this, \"_onGridRenderedMemoizer\", createCallbackMemoizer());\n    _defineProperty(_this, \"_onScrollMemoizer\", createCallbackMemoizer(false));\n    _defineProperty(_this, \"_deferredInvalidateColumnIndex\", null);\n    _defineProperty(_this, \"_deferredInvalidateRowIndex\", null);\n    _defineProperty(_this, \"_recomputeScrollLeftFlag\", false);\n    _defineProperty(_this, \"_recomputeScrollTopFlag\", false);\n    _defineProperty(_this, \"_horizontalScrollBarSize\", 0);\n    _defineProperty(_this, \"_verticalScrollBarSize\", 0);\n    _defineProperty(_this, \"_scrollbarPresenceChanged\", false);\n    _defineProperty(_this, \"_scrollingContainer\", void 0);\n    _defineProperty(_this, \"_childrenToDisplay\", void 0);\n    _defineProperty(_this, \"_columnStartIndex\", void 0);\n    _defineProperty(_this, \"_columnStopIndex\", void 0);\n    _defineProperty(_this, \"_rowStartIndex\", void 0);\n    _defineProperty(_this, \"_rowStopIndex\", void 0);\n    _defineProperty(_this, \"_renderedColumnStartIndex\", 0);\n    _defineProperty(_this, \"_renderedColumnStopIndex\", 0);\n    _defineProperty(_this, \"_renderedRowStartIndex\", 0);\n    _defineProperty(_this, \"_renderedRowStopIndex\", 0);\n    _defineProperty(_this, \"_initialScrollTop\", void 0);\n    _defineProperty(_this, \"_initialScrollLeft\", void 0);\n    _defineProperty(_this, \"_disablePointerEventsTimeoutId\", void 0);\n    _defineProperty(_this, \"_styleCache\", {});\n    _defineProperty(_this, \"_cellCache\", {});\n    _defineProperty(_this, \"_debounceScrollEndedCallback\", function () {\n      _this._disablePointerEventsTimeoutId = null;\n      // isScrolling is used to determine if we reset styleCache\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    });\n    _defineProperty(_this, \"_invokeOnGridRenderedHelper\", function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    });\n    _defineProperty(_this, \"_setScrollingContainerRef\", function (ref /*: Element*/) {\n      _this._scrollingContainer = ref;\n      if (typeof _this.props.elementRef === 'function') {\n        _this.props.elementRef(ref);\n      } else if (_typeof(_this.props.elementRef) === 'object') {\n        _this.props.elementRef.current = ref;\n      }\n    });\n    _defineProperty(_this, \"_onScroll\", function (event /*: Event*/) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target /*: any*/);\n      }\n    });\n    var columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n    return _this;\n  }\n\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n  _inherits(Grid, _React$PureComponent);\n  return _createClass(Grid, [{\n    key: \"getOffsetForCell\",\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$alignment = _ref.alignment,\n        alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment,\n        _ref$columnIndex = _ref.columnIndex,\n        columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex,\n        _ref$rowIndex = _ref.rowIndex,\n        rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;\n      var offsetProps = _objectSpread(_objectSpread({}, this.props), {}, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n\n    /**\n     * Gets estimated total rows' height.\n     */\n  }, {\n    key: \"getTotalRowsHeight\",\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * Gets estimated total columns' width.\n     */\n  }, {\n    key: \"getTotalColumnsWidth\",\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n  }, {\n    key: \"handleScrollEvent\",\n    value: function handleScrollEvent(_ref2 /*:: */) {\n      var _ref2$scrollLeft = _ref2 /*:: */.scrollLeft,\n        scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft,\n        _ref2$scrollTop = _ref2 /*:: */.scrollTop,\n        scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop;\n      // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n      if (scrollTopParam < 0) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      this._debounceScrollEnded();\n      var _this$props = this.props,\n        autoHeight = _this$props.autoHeight,\n        autoWidth = _this$props.autoWidth,\n        height = _this$props.height,\n        width = _this$props.width;\n      var instanceProps = this.state.instanceProps;\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n        var newState /*: $Shape<State>*/ = {\n          isScrolling: true,\n          scrollDirectionHorizontal: scrollDirectionHorizontal,\n          scrollDirectionVertical: scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n  }, {\n    key: \"invalidateCellSizeAfterRender\",\n    value: function invalidateCellSizeAfterRender(_ref3 /*:: */) {\n      var columnIndex = _ref3 /*:: */.columnIndex,\n        rowIndex = _ref3 /*:: */.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n  }, {\n    key: \"measureAllCells\",\n    value: function measureAllCells() {\n      var _this$props2 = this.props,\n        columnCount = _this$props2.columnCount,\n        rowCount = _this$props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n  }, {\n    key: \"recomputeGridSize\",\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$columnIndex = _ref4.columnIndex,\n        columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex,\n        _ref4$rowIndex = _ref4.rowIndex,\n        rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;\n      var _this$props3 = this.props,\n        scrollToColumn = _this$props3.scrollToColumn,\n        scrollToRow = _this$props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);\n\n      // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow);\n\n      // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n\n    /**\n     * Ensure column and row are visible.\n     */\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(_ref5 /*:: */) {\n      var columnIndex = _ref5 /*:: */.columnIndex,\n        rowIndex = _ref5 /*:: */.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props;\n\n      // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_objectSpread(_objectSpread({}, props), {}, {\n          scrollToColumn: columnIndex\n        }));\n      }\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_objectSpread(_objectSpread({}, props), {}, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n        getScrollbarSize = _this$props4.getScrollbarSize,\n        height = _this$props4.height,\n        scrollLeft = _this$props4.scrollLeft,\n        scrollToColumn = _this$props4.scrollToColumn,\n        scrollTop = _this$props4.scrollTop,\n        scrollToRow = _this$props4.scrollToRow,\n        width = _this$props4.width;\n      var instanceProps = this.state.instanceProps;\n\n      // Reset initial offsets to be ignored in browser\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0;\n\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n      this._handleInvalidatedGridSize();\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = _objectSpread(_objectSpread({}, prevState), {}, {\n            needToResetStyleCache: false\n          });\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      }\n\n      // refs don't work in `react-test-renderer`\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      }\n\n      // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      }\n\n      // Update onRowsRendered callback\n      this._invokeOnGridRenderedHelper();\n\n      // Initialize onScroll callback\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n      var _this2 = this;\n      var _this$props5 = this.props,\n        autoHeight = _this$props5.autoHeight,\n        autoWidth = _this$props5.autoWidth,\n        columnCount = _this$props5.columnCount,\n        height = _this$props5.height,\n        rowCount = _this$props5.rowCount,\n        scrollToAlignment = _this$props5.scrollToAlignment,\n        scrollToColumn = _this$props5.scrollToColumn,\n        scrollToRow = _this$props5.scrollToRow,\n        width = _this$props5.width;\n      var _this$state = this.state,\n        scrollLeft = _this$state.scrollLeft,\n        scrollPositionChangeReason = _this$state.scrollPositionChangeReason,\n        scrollTop = _this$state.scrollTop,\n        instanceProps = _this$state.instanceProps;\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n      this._handleInvalidatedGridSize();\n\n      // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;\n\n      // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnGridRenderedHelper();\n\n      // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n        autoContainerWidth = _this$props6.autoContainerWidth,\n        autoHeight = _this$props6.autoHeight,\n        autoWidth = _this$props6.autoWidth,\n        className = _this$props6.className,\n        containerProps = _this$props6.containerProps,\n        containerRole = _this$props6.containerRole,\n        containerStyle = _this$props6.containerStyle,\n        height = _this$props6.height,\n        id = _this$props6.id,\n        noContentRenderer = _this$props6.noContentRenderer,\n        role = _this$props6.role,\n        style = _this$props6.style,\n        tabIndex = _this$props6.tabIndex,\n        width = _this$props6.width;\n      var _this$state2 = this.state,\n        instanceProps = _this$state2.instanceProps,\n        needToResetStyleCache = _this$state2.needToResetStyleCache;\n      var isScrolling = this._isScrolling();\n      var gridStyle /*: Object*/ = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      }\n\n      // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      }\n\n      // calculate children to render here\n      this._calculateChildrenToRender(this.props, this.state);\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      }\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return /*#__PURE__*/React.createElement(\"div\", _extends({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        \"aria-label\": this.props['aria-label'],\n        \"aria-readonly\": this.props['aria-readonly'],\n        className: clsx('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: _objectSpread(_objectSpread({}, gridStyle), style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && /*#__PURE__*/React.createElement(\"div\", {\n        className: \"ReactVirtualized__Grid__innerScrollContainer\",\n        role: containerRole,\n        style: _objectSpread({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n  }, {\n    key: \"_calculateChildrenToRender\",\n    value: function _calculateChildrenToRender() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n        cellRangeRenderer = props.cellRangeRenderer,\n        columnCount = props.columnCount,\n        deferredMeasurementCache = props.deferredMeasurementCache,\n        height = props.height,\n        overscanColumnCount = props.overscanColumnCount,\n        overscanIndicesGetter = props.overscanIndicesGetter,\n        overscanRowCount = props.overscanRowCount,\n        rowCount = props.rowCount,\n        width = props.width,\n        isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n        scrollDirectionVertical = state.scrollDirectionVertical,\n        instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n      var isScrolling = this._isScrolling(props, state);\n      this._childrenToDisplay = [];\n\n      // Render only enough columns and rows to cover the visible area of the grid.\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex;\n\n        // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          }\n\n          // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        });\n\n        // update the indices\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n  }, {\n    key: \"_debounceScrollEnded\",\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n      this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: \"_handleInvalidatedGridSize\",\n    value:\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref6 /*:: */) {\n      var _this3 = this;\n      var scrollLeft = _ref6 /*:: */.scrollLeft,\n        scrollTop = _ref6 /*:: */.scrollTop,\n        totalColumnsWidth = _ref6 /*:: */.totalColumnsWidth,\n        totalRowsHeight = _ref6 /*:: */.totalRowsHeight;\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n            scrollTop = _ref7.scrollTop;\n          var _this3$props = _this3.props,\n            height = _this3$props.height,\n            onScroll = _this3$props.onScroll,\n            width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_isScrolling\",\n    value: function _isScrolling() /*: boolean*/{\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: \"_maybeCallOnScrollbarPresenceChange\",\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n        onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: \"scrollToPosition\",\n    value:\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    function scrollToPosition(_ref8 /*:: */) {\n      var scrollLeft = _ref8 /*:: */.scrollLeft,\n        scrollTop = _ref8 /*:: */.scrollTop;\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: \"_updateScrollLeftForScrollToColumn\",\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: \"_resetStyleCache\",\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut;\n\n      // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n      this._cellCache = {};\n      this._styleCache = {};\n\n      // Copy over the visible cell styles so avoid unnecessary re-render.\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n          this._styleCache[key] = styleCache[key];\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateScrollTopForScrollToRow\",\n    value: function _updateScrollTopForScrollToRow() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State>*/{\n      var newState = {};\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0;\n\n        // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        Object.assign(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n      var instanceProps = prevState.instanceProps;\n\n      // Initially we should not clearStyleCache\n      newState.needToResetStyleCache = false;\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      }\n\n      // If scrolling is controlled outside this component, clear cache when scrolling stops\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        Object.assign(newState, {\n          isScrolling: false\n        });\n      }\n      var maybeStateA;\n      var maybeStateB;\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow;\n\n      // getting scrollBarSize (moved from componentWillMount)\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n      newState.instanceProps = instanceProps;\n      return _objectSpread(_objectSpread(_objectSpread({}, newState), maybeStateA), maybeStateB);\n    }\n  }, {\n    key: \"_getEstimatedColumnSize\",\n    value: function _getEstimatedColumnSize(props /*: Props*/) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: \"_getEstimatedRowSize\",\n    value: function _getEstimatedRowSize(props /*: Props*/) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: \"_getScrollToPositionStateUpdate\",\n    value:\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    function _getScrollToPositionStateUpdate(_ref9 /*:: */) /*: $Shape<State>*/{\n      var prevState = _ref9 /*:: */.prevState,\n        scrollLeft = _ref9 /*:: */.scrollLeft,\n        scrollTop = _ref9 /*:: */.scrollTop;\n      var newState /*: Object*/ = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n      return {};\n    }\n  }, {\n    key: \"_wrapSizeGetter\",\n    value: function _wrapSizeGetter(value /*: CellSize*/) /*: CellSizeGetter*/{\n      return typeof value === 'function' ? value : function () {\n        return value /*: any*/;\n      };\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft(nextProps /*: Props*/, prevState /*: State*/) {\n      var columnCount = nextProps.columnCount,\n        height = nextProps.height,\n        scrollToAlignment = nextProps.scrollToAlignment,\n        scrollToColumn = nextProps.scrollToColumn,\n        width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n        instanceProps = prevState.instanceProps;\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: \"_getScrollLeftForScrollToColumnStateUpdate\",\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State>*/{\n      var scrollLeft = prevState.scrollLeft;\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n      return {};\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop(nextProps /*: Props*/, prevState /*: State*/) {\n      var height = nextProps.height,\n        rowCount = nextProps.rowCount,\n        scrollToAlignment = nextProps.scrollToAlignment,\n        scrollToRow = nextProps.scrollToRow,\n        width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n        instanceProps = prevState.instanceProps;\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: \"_getScrollTopForScrollToRowStateUpdate\",\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State>*/{\n      var scrollTop = prevState.scrollTop;\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n      return {};\n    }\n  }]);\n}(React.PureComponent);\n_defineProperty(Grid, \"defaultProps\", {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: defaultCellRangeRenderer,\n  containerRole: 'row',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: scrollbarSize,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: defaultOverscanIndicesGetter,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n});\npolyfill(Grid);\nexport default Grid;","map":{"version":3,"names":["_extends","_typeof","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_inherits","_defineProperty","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","_callSuper","_isNativeReflectConstruct","Reflect","construct","constructor","Boolean","prototype","valueOf","call","React","clsx","calculateSizeAndPositionDataAndUpdateScrollOffset","ScalingCellSizeAndPositionManager","createCallbackMemoizer","defaultOverscanIndicesGetter","SCROLL_DIRECTION_BACKWARD","SCROLL_DIRECTION_FORWARD","updateScrollIndexHelper","defaultCellRangeRenderer","scrollbarSize","polyfill","requestAnimationTimeout","cancelAnimationTimeout","DEFAULT_SCROLLING_RESET_TIME_INTERVAL","SCROLL_POSITION_CHANGE_REASONS","OBSERVED","REQUESTED","renderNull","Grid","_React$PureComponent","props","_this","_disablePointerEventsTimeoutId","setState","isScrolling","needToResetStyleCache","onSectionRendered","_onGridRenderedMemoizer","callback","indices","columnOverscanStartIndex","_columnStartIndex","columnOverscanStopIndex","_columnStopIndex","columnStartIndex","_renderedColumnStartIndex","columnStopIndex","_renderedColumnStopIndex","rowOverscanStartIndex","_rowStartIndex","rowOverscanStopIndex","_rowStopIndex","rowStartIndex","_renderedRowStartIndex","rowStopIndex","_renderedRowStopIndex","ref","_scrollingContainer","elementRef","current","event","target","handleScrollEvent","columnSizeAndPositionManager","cellCount","columnCount","cellSizeGetter","params","_wrapSizeGetter","columnWidth","estimatedCellSize","_getEstimatedColumnSize","rowSizeAndPositionManager","rowCount","rowHeight","_getEstimatedRowSize","state","instanceProps","prevColumnWidth","prevRowHeight","prevColumnCount","prevRowCount","prevIsScrolling","prevScrollToColumn","scrollToColumn","prevScrollToRow","scrollToRow","scrollbarSizeMeasured","scrollDirectionHorizontal","scrollDirectionVertical","scrollLeft","scrollTop","scrollPositionChangeReason","_initialScrollTop","_getCalculatedScrollTop","_initialScrollLeft","_getCalculatedScrollLeft","key","value","getOffsetForCell","_ref","undefined","_ref$alignment","alignment","scrollToAlignment","_ref$columnIndex","columnIndex","_ref$rowIndex","rowIndex","offsetProps","getTotalRowsHeight","getTotalSize","getTotalColumnsWidth","_ref2","_ref2$scrollLeft","scrollLeftParam","_ref2$scrollTop","scrollTopParam","_debounceScrollEnded","_this$props","autoHeight","autoWidth","height","width","totalRowsHeight","totalColumnsWidth","Math","min","max","newState","_invokeOnScrollMemoizer","invalidateCellSizeAfterRender","_ref3","_deferredInvalidateColumnIndex","_deferredInvalidateRowIndex","measureAllCells","_this$props2","getSizeAndPositionOfCell","recomputeGridSize","_ref4","_ref4$columnIndex","_ref4$rowIndex","_this$props3","resetCell","_recomputeScrollLeftFlag","_recomputeScrollTopFlag","_styleCache","_cellCache","forceUpdate","scrollToCell","_ref5","_updateScrollLeftForScrollToColumn","_updateScrollTopForScrollToRow","componentDidMount","_this$props4","getScrollbarSize","_handleInvalidatedGridSize","prevState","stateUpdate","_getScrollToPositionStateUpdate","sizeIsBiggerThanZero","_invokeOnGridRenderedHelper","_maybeCallOnScrollbarPresenceChange","componentDidUpdate","prevProps","_this2","_this$props5","_this$state","columnOrRowCountJustIncreasedFromZero","sizeJustIncreasedFromZero","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToIndex","size","updateScrollIndexCallback","componentWillUnmount","render","_this$props6","autoContainerWidth","className","containerProps","containerRole","containerStyle","id","noContentRenderer","role","style","tabIndex","_this$state2","_isScrolling","gridStyle","boxSizing","direction","position","WebkitOverflowScrolling","willChange","_resetStyleCache","_calculateChildrenToRender","verticalScrollBarSize","horizontalScrollBarSize","_horizontalScrollBarSize","_verticalScrollBarSize","_scrollbarPresenceChanged","overflowX","overflowY","childrenToDisplay","_childrenToDisplay","showNoContentRenderer","createElement","_setScrollingContainerRef","onScroll","_onScroll","maxWidth","maxHeight","overflow","pointerEvents","cellRenderer","cellRangeRenderer","deferredMeasurementCache","overscanColumnCount","overscanIndicesGetter","overscanRowCount","isScrollingOptOut","visibleColumnIndices","getVisibleCellRange","containerSize","offset","visibleRowIndices","horizontalOffsetAdjustment","getOffsetAdjustment","verticalOffsetAdjustment","start","stop","overscanColumnIndices","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanRowIndices","overscanStartIndex","overscanStopIndex","hasFixedHeight","has","hasFixedWidth","cellCache","parent","styleCache","scrollingResetTimeInterval","_debounceScrollEndedCallback","_ref6","_this3","_onScrollMemoizer","_ref7","_this3$props","clientHeight","clientWidth","scrollHeight","scrollWidth","hasOwnProperty","onScrollbarPresenceChange","horizontal","vertical","scrollToPosition","_ref8","_getScrollLeftForScrollToColumnStateUpdate","concat","_getScrollTopForScrollToRowStateUpdate","getDerivedStateFromProps","nextProps","assign","configure","maybeStateA","maybeStateB","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","updateScrollOffsetForScrollToIndex","estimatedColumnSize","estimatedRowSize","_ref9","finalColumn","targetIndex","scrollBarSize","getUpdatedOffsetForIndex","align","currentOffset","calculatedScrollLeft","finalRow","calculatedScrollTop","PureComponent"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/react-virtualized/dist/es/Grid/Grid.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\n/*:: import type {\n  CellRenderer,\n  CellRangeRenderer,\n  CellPosition,\n  CellSize,\n  CellSizeGetter,\n  NoContentRenderer,\n  Scroll,\n  ScrollbarPresenceChange,\n  RenderedSection,\n  OverscanIndicesGetter,\n  Alignment,\n  CellCache,\n  StyleCache,\n} from './types';*/\n/*:: import type {AnimationTimeoutId} from '../utils/requestAnimationTimeout';*/\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport calculateSizeAndPositionDataAndUpdateScrollOffset from './utils/calculateSizeAndPositionDataAndUpdateScrollOffset';\nimport ScalingCellSizeAndPositionManager from './utils/ScalingCellSizeAndPositionManager';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport defaultOverscanIndicesGetter, { SCROLL_DIRECTION_BACKWARD, SCROLL_DIRECTION_FORWARD } from './defaultOverscanIndicesGetter';\nimport updateScrollIndexHelper from './utils/updateScrollIndexHelper';\nimport defaultCellRangeRenderer from './defaultCellRangeRenderer';\nimport scrollbarSize from 'dom-helpers/scrollbarSize';\nimport { polyfill } from 'react-lifecycles-compat';\nimport { requestAnimationTimeout, cancelAnimationTimeout } from '../utils/requestAnimationTimeout';\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nexport var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\nvar renderNull /*: NoContentRenderer*/ = function renderNull() {\n  return null;\n};\n/*:: type ScrollPosition = {\n  scrollTop?: number,\n  scrollLeft?: number,\n};*/\n/*:: type Props = {\n  'aria-label': string,\n  'aria-readonly'?: boolean,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   *-/\n  autoContainerWidth: boolean,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   *-/\n  autoHeight: boolean,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   *-/\n  autoWidth: boolean,\n\n  /** Responsible for rendering a cell given an row and column index.  *-/\n  cellRenderer: CellRenderer,\n\n  /** Responsible for rendering a group of cells given their index ranges.  *-/\n  cellRangeRenderer: CellRangeRenderer,\n\n  /** Optional custom CSS class name to attach to root Grid element.  *-/\n  className?: string,\n\n  /** Number of columns in grid.  *-/\n  columnCount: number,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  *-/\n  columnWidth: CellSize,\n\n  /** Unfiltered props for the Grid container. *-/\n  containerProps?: Object,\n\n  /** ARIA role for the cell-container.  *-/\n  containerRole: string,\n\n  /** Optional inline style applied to inner cell-container *-/\n  containerStyle: Object,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   *-/\n  deferredMeasurementCache?: Object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   *-/\n  estimatedColumnSize: number,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   *-/\n  estimatedRowSize: number,\n\n  /** Exposed for testing purposes only.  *-/\n  getScrollbarSize: () => number,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  *-/\n  height: number,\n\n  /** Optional custom id to attach to root Grid element.  *-/\n  id?: string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   *-/\n  isScrolling?: boolean,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   *-/\n  isScrollingOptOut: boolean,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  *-/\n  noContentRenderer: NoContentRenderer,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   *-/\n  onScroll: (params: Scroll) => void,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   *-/\n  onScrollbarPresenceChange: (params: ScrollbarPresenceChange) => void,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  *-/\n  onSectionRendered: (params: RenderedSection) => void,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   *-/\n  overscanColumnCount: number,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   *-/\n  overscanIndicesGetter: OverscanIndicesGetter,\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   *-/\n  overscanRowCount: number,\n\n  /** ARIA role for the grid element.  *-/\n  role: string,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   *-/\n  rowHeight: CellSize,\n\n  /** Number of rows in grid.  *-/\n  rowCount: number,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. *-/\n  scrollingResetTimeInterval: number,\n\n  /** Horizontal offset. *-/\n  scrollLeft?: number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   *-/\n  scrollToAlignment: Alignment,\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) *-/\n  scrollToColumn: number,\n\n  /** Vertical offset. *-/\n  scrollTop?: number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) *-/\n  scrollToRow: number,\n\n  /** Optional inline style *-/\n  style: Object,\n\n  /** Tab index for focus *-/\n  tabIndex: ?number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  *-/\n  width: number,\n\n  /** Reference to DOM node *-/\n  elementRef?: React.Ref<React.ElementType>,\n};*/\n/*:: type InstanceProps = {\n  prevColumnWidth: CellSize,\n  prevRowHeight: CellSize,\n\n  prevColumnCount: number,\n  prevRowCount: number,\n  prevIsScrolling: boolean,\n  prevScrollToColumn: number,\n  prevScrollToRow: number,\n\n  columnSizeAndPositionManager: ScalingCellSizeAndPositionManager,\n  rowSizeAndPositionManager: ScalingCellSizeAndPositionManager,\n\n  scrollbarSize: number,\n  scrollbarSizeMeasured: boolean,\n};*/\n/*:: type State = {\n  instanceProps: InstanceProps,\n  isScrolling: boolean,\n  scrollDirectionHorizontal: -1 | 1,\n  scrollDirectionVertical: -1 | 1,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollPositionChangeReason: 'observed' | 'requested' | null,\n  needToResetStyleCache: boolean,\n};*/\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\nvar Grid = /*#__PURE__*/function (_React$PureComponent) {\n  function Grid(props /*: Props*/) {\n    var _this;\n    _classCallCheck(this, Grid);\n    _this = _callSuper(this, Grid, [props]);\n    // Invokes onSectionRendered callback only when start/stop row or column indices change\n    _defineProperty(_this, \"_onGridRenderedMemoizer\", createCallbackMemoizer());\n    _defineProperty(_this, \"_onScrollMemoizer\", createCallbackMemoizer(false));\n    _defineProperty(_this, \"_deferredInvalidateColumnIndex\", null);\n    _defineProperty(_this, \"_deferredInvalidateRowIndex\", null);\n    _defineProperty(_this, \"_recomputeScrollLeftFlag\", false);\n    _defineProperty(_this, \"_recomputeScrollTopFlag\", false);\n    _defineProperty(_this, \"_horizontalScrollBarSize\", 0);\n    _defineProperty(_this, \"_verticalScrollBarSize\", 0);\n    _defineProperty(_this, \"_scrollbarPresenceChanged\", false);\n    _defineProperty(_this, \"_scrollingContainer\", void 0);\n    _defineProperty(_this, \"_childrenToDisplay\", void 0);\n    _defineProperty(_this, \"_columnStartIndex\", void 0);\n    _defineProperty(_this, \"_columnStopIndex\", void 0);\n    _defineProperty(_this, \"_rowStartIndex\", void 0);\n    _defineProperty(_this, \"_rowStopIndex\", void 0);\n    _defineProperty(_this, \"_renderedColumnStartIndex\", 0);\n    _defineProperty(_this, \"_renderedColumnStopIndex\", 0);\n    _defineProperty(_this, \"_renderedRowStartIndex\", 0);\n    _defineProperty(_this, \"_renderedRowStopIndex\", 0);\n    _defineProperty(_this, \"_initialScrollTop\", void 0);\n    _defineProperty(_this, \"_initialScrollLeft\", void 0);\n    _defineProperty(_this, \"_disablePointerEventsTimeoutId\", void 0);\n    _defineProperty(_this, \"_styleCache\", {});\n    _defineProperty(_this, \"_cellCache\", {});\n    _defineProperty(_this, \"_debounceScrollEndedCallback\", function () {\n      _this._disablePointerEventsTimeoutId = null;\n      // isScrolling is used to determine if we reset styleCache\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    });\n    _defineProperty(_this, \"_invokeOnGridRenderedHelper\", function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    });\n    _defineProperty(_this, \"_setScrollingContainerRef\", function (ref /*: Element*/) {\n      _this._scrollingContainer = ref;\n      if (typeof _this.props.elementRef === 'function') {\n        _this.props.elementRef(ref);\n      } else if (_typeof(_this.props.elementRef) === 'object') {\n        _this.props.elementRef.current = ref;\n      }\n    });\n    _defineProperty(_this, \"_onScroll\", function (event /*: Event*/) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent((event.target /*: any*/));\n      }\n    });\n    var columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n    return _this;\n  }\n\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n  _inherits(Grid, _React$PureComponent);\n  return _createClass(Grid, [{\n    key: \"getOffsetForCell\",\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$alignment = _ref.alignment,\n        alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment,\n        _ref$columnIndex = _ref.columnIndex,\n        columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex,\n        _ref$rowIndex = _ref.rowIndex,\n        rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;\n      var offsetProps = _objectSpread(_objectSpread({}, this.props), {}, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n\n    /**\n     * Gets estimated total rows' height.\n     */\n  }, {\n    key: \"getTotalRowsHeight\",\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * Gets estimated total columns' width.\n     */\n  }, {\n    key: \"getTotalColumnsWidth\",\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n  }, {\n    key: \"handleScrollEvent\",\n    value: function handleScrollEvent(_ref2 /*:: */) {\n      var _ref2$scrollLeft = _ref2 /*:: */.scrollLeft,\n        scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft,\n        _ref2$scrollTop = _ref2 /*:: */.scrollTop,\n        scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop;\n      // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n      if (scrollTopParam < 0) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      this._debounceScrollEnded();\n      var _this$props = this.props,\n        autoHeight = _this$props.autoHeight,\n        autoWidth = _this$props.autoWidth,\n        height = _this$props.height,\n        width = _this$props.width;\n      var instanceProps = this.state.instanceProps;\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n        var newState /*: $Shape<State>*/ = {\n          isScrolling: true,\n          scrollDirectionHorizontal: scrollDirectionHorizontal,\n          scrollDirectionVertical: scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n  }, {\n    key: \"invalidateCellSizeAfterRender\",\n    value: function invalidateCellSizeAfterRender(_ref3 /*:: */) {\n      var columnIndex = _ref3 /*:: */.columnIndex,\n        rowIndex = _ref3 /*:: */.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n  }, {\n    key: \"measureAllCells\",\n    value: function measureAllCells() {\n      var _this$props2 = this.props,\n        columnCount = _this$props2.columnCount,\n        rowCount = _this$props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n  }, {\n    key: \"recomputeGridSize\",\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$columnIndex = _ref4.columnIndex,\n        columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex,\n        _ref4$rowIndex = _ref4.rowIndex,\n        rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;\n      var _this$props3 = this.props,\n        scrollToColumn = _this$props3.scrollToColumn,\n        scrollToRow = _this$props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);\n\n      // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow);\n\n      // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n\n    /**\n     * Ensure column and row are visible.\n     */\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(_ref5 /*:: */) {\n      var columnIndex = _ref5 /*:: */.columnIndex,\n        rowIndex = _ref5 /*:: */.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props;\n\n      // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_objectSpread(_objectSpread({}, props), {}, {\n          scrollToColumn: columnIndex\n        }));\n      }\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_objectSpread(_objectSpread({}, props), {}, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n        getScrollbarSize = _this$props4.getScrollbarSize,\n        height = _this$props4.height,\n        scrollLeft = _this$props4.scrollLeft,\n        scrollToColumn = _this$props4.scrollToColumn,\n        scrollTop = _this$props4.scrollTop,\n        scrollToRow = _this$props4.scrollToRow,\n        width = _this$props4.width;\n      var instanceProps = this.state.instanceProps;\n\n      // Reset initial offsets to be ignored in browser\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0;\n\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n      this._handleInvalidatedGridSize();\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = _objectSpread(_objectSpread({}, prevState), {}, {\n            needToResetStyleCache: false\n          });\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      }\n\n      // refs don't work in `react-test-renderer`\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      }\n\n      // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      }\n\n      // Update onRowsRendered callback\n      this._invokeOnGridRenderedHelper();\n\n      // Initialize onScroll callback\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n      var _this2 = this;\n      var _this$props5 = this.props,\n        autoHeight = _this$props5.autoHeight,\n        autoWidth = _this$props5.autoWidth,\n        columnCount = _this$props5.columnCount,\n        height = _this$props5.height,\n        rowCount = _this$props5.rowCount,\n        scrollToAlignment = _this$props5.scrollToAlignment,\n        scrollToColumn = _this$props5.scrollToColumn,\n        scrollToRow = _this$props5.scrollToRow,\n        width = _this$props5.width;\n      var _this$state = this.state,\n        scrollLeft = _this$state.scrollLeft,\n        scrollPositionChangeReason = _this$state.scrollPositionChangeReason,\n        scrollTop = _this$state.scrollTop,\n        instanceProps = _this$state.instanceProps;\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n      this._handleInvalidatedGridSize();\n\n      // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;\n\n      // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnGridRenderedHelper();\n\n      // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n        autoContainerWidth = _this$props6.autoContainerWidth,\n        autoHeight = _this$props6.autoHeight,\n        autoWidth = _this$props6.autoWidth,\n        className = _this$props6.className,\n        containerProps = _this$props6.containerProps,\n        containerRole = _this$props6.containerRole,\n        containerStyle = _this$props6.containerStyle,\n        height = _this$props6.height,\n        id = _this$props6.id,\n        noContentRenderer = _this$props6.noContentRenderer,\n        role = _this$props6.role,\n        style = _this$props6.style,\n        tabIndex = _this$props6.tabIndex,\n        width = _this$props6.width;\n      var _this$state2 = this.state,\n        instanceProps = _this$state2.instanceProps,\n        needToResetStyleCache = _this$state2.needToResetStyleCache;\n      var isScrolling = this._isScrolling();\n      var gridStyle /*: Object*/ = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      }\n\n      // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      }\n\n      // calculate children to render here\n      this._calculateChildrenToRender(this.props, this.state);\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      }\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return /*#__PURE__*/React.createElement(\"div\", _extends({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        \"aria-label\": this.props['aria-label'],\n        \"aria-readonly\": this.props['aria-readonly'],\n        className: clsx('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: _objectSpread(_objectSpread({}, gridStyle), style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && /*#__PURE__*/React.createElement(\"div\", {\n        className: \"ReactVirtualized__Grid__innerScrollContainer\",\n        role: containerRole,\n        style: _objectSpread({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n  }, {\n    key: \"_calculateChildrenToRender\",\n    value: function _calculateChildrenToRender() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n        cellRangeRenderer = props.cellRangeRenderer,\n        columnCount = props.columnCount,\n        deferredMeasurementCache = props.deferredMeasurementCache,\n        height = props.height,\n        overscanColumnCount = props.overscanColumnCount,\n        overscanIndicesGetter = props.overscanIndicesGetter,\n        overscanRowCount = props.overscanRowCount,\n        rowCount = props.rowCount,\n        width = props.width,\n        isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n        scrollDirectionVertical = state.scrollDirectionVertical,\n        instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n      var isScrolling = this._isScrolling(props, state);\n      this._childrenToDisplay = [];\n\n      // Render only enough columns and rows to cover the visible area of the grid.\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex;\n\n        // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          }\n\n          // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        });\n\n        // update the indices\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n  }, {\n    key: \"_debounceScrollEnded\",\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n      this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: \"_handleInvalidatedGridSize\",\n    value:\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref6 /*:: */) {\n      var _this3 = this;\n      var scrollLeft = _ref6 /*:: */.scrollLeft,\n        scrollTop = _ref6 /*:: */.scrollTop,\n        totalColumnsWidth = _ref6 /*:: */.totalColumnsWidth,\n        totalRowsHeight = _ref6 /*:: */.totalRowsHeight;\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n            scrollTop = _ref7.scrollTop;\n          var _this3$props = _this3.props,\n            height = _this3$props.height,\n            onScroll = _this3$props.onScroll,\n            width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_isScrolling\",\n    value: function _isScrolling() /*: boolean*/{\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: \"_maybeCallOnScrollbarPresenceChange\",\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n        onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: \"scrollToPosition\",\n    value:\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    function scrollToPosition(_ref8 /*:: */) {\n      var scrollLeft = _ref8 /*:: */.scrollLeft,\n        scrollTop = _ref8 /*:: */.scrollTop;\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: \"_updateScrollLeftForScrollToColumn\",\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: \"_resetStyleCache\",\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut;\n\n      // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n      this._cellCache = {};\n      this._styleCache = {};\n\n      // Copy over the visible cell styles so avoid unnecessary re-render.\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n          this._styleCache[key] = styleCache[key];\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateScrollTopForScrollToRow\",\n    value: function _updateScrollTopForScrollToRow() {\n      var props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state /*: State*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State>*/{\n      var newState = {};\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0;\n\n        // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        Object.assign(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n      var instanceProps = prevState.instanceProps;\n\n      // Initially we should not clearStyleCache\n      newState.needToResetStyleCache = false;\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      }\n\n      // If scrolling is controlled outside this component, clear cache when scrolling stops\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        Object.assign(newState, {\n          isScrolling: false\n        });\n      }\n      var maybeStateA;\n      var maybeStateB;\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow;\n\n      // getting scrollBarSize (moved from componentWillMount)\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n      newState.instanceProps = instanceProps;\n      return _objectSpread(_objectSpread(_objectSpread({}, newState), maybeStateA), maybeStateB);\n    }\n  }, {\n    key: \"_getEstimatedColumnSize\",\n    value: function _getEstimatedColumnSize(props /*: Props*/) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: \"_getEstimatedRowSize\",\n    value: function _getEstimatedRowSize(props /*: Props*/) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: \"_getScrollToPositionStateUpdate\",\n    value:\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    function _getScrollToPositionStateUpdate(_ref9 /*:: */) /*: $Shape<State>*/{\n      var prevState = _ref9 /*:: */.prevState,\n        scrollLeft = _ref9 /*:: */.scrollLeft,\n        scrollTop = _ref9 /*:: */.scrollTop;\n      var newState /*: Object*/ = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n      return {};\n    }\n  }, {\n    key: \"_wrapSizeGetter\",\n    value: function _wrapSizeGetter(value /*: CellSize*/) /*: CellSizeGetter*/{\n      return typeof value === 'function' ? value : function () {\n        return (value /*: any*/);\n      };\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft(nextProps /*: Props*/, prevState /*: State*/) {\n      var columnCount = nextProps.columnCount,\n        height = nextProps.height,\n        scrollToAlignment = nextProps.scrollToAlignment,\n        scrollToColumn = nextProps.scrollToColumn,\n        width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n        instanceProps = prevState.instanceProps;\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: \"_getScrollLeftForScrollToColumnStateUpdate\",\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State>*/{\n      var scrollLeft = prevState.scrollLeft;\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n      return {};\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop(nextProps /*: Props*/, prevState /*: State*/) {\n      var height = nextProps.height,\n        rowCount = nextProps.rowCount,\n        scrollToAlignment = nextProps.scrollToAlignment,\n        scrollToRow = nextProps.scrollToRow,\n        width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n        instanceProps = prevState.instanceProps;\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: \"_getScrollTopForScrollToRowStateUpdate\",\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State>*/{\n      var scrollTop = prevState.scrollTop;\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n      return {};\n    }\n  }]);\n}(React.PureComponent);\n_defineProperty(Grid, \"defaultProps\", {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: defaultCellRangeRenderer,\n  containerRole: 'row',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: scrollbarSize,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: defaultOverscanIndicesGetter,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n});\npolyfill(Grid);\nexport default Grid;"],"mappings":"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ACrD,SAASC,QAAQ,QAAQ,yBAAyB;AAClD,SAASC,uBAAuB,EAAEC,sBAAsB,QAAQ,kCAAkC;;AAElG;AACA;AACA;AACA;AACA,OAAO,IAAIC,qCAAqC,GAAG,GAAG;;AAEtD;AACA;AACA;AACA;AACA,IAAIC,8BAA8B,GAAG;EACnCC,QAAQ,EAAE,UAAU;EACpBC,SAAS,EAAE;AACb,CAAC;AACD,IAAIC,UAAU,CAAC,0BAA0B,SAASA,UAAUA,CAAA,EAAG;EAC7D,OAAO,IAAI;AACb,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module"}