{"ast":null,"code":"/**\r\n * Global constant CCW defines counter clockwise direction of arc\r\n * @type {boolean}\r\n */\nconst CCW = true;\n\n/**\r\n * Global constant CW defines clockwise direction of arc\r\n * @type {boolean}\r\n */\nconst CW = false;\n\n/**\r\n * Defines orientation for face of the polygon: clockwise, counter clockwise\r\n * or not orientable in the case of self-intersection\r\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\r\n */\nconst ORIENTATION = {\n  CCW: -1,\n  CW: 1,\n  NOT_ORIENTABLE: 0\n};\nconst PIx2 = 2 * Math.PI;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\nconst BOUNDARY = 2;\nconst CONTAINS = 3;\nconst INTERLACE = 4;\nconst OVERLAP_SAME = 1;\nconst OVERLAP_OPPOSITE = 2;\nvar Constants = /*#__PURE__*/Object.freeze({\n  CCW: CCW,\n  CW: CW,\n  ORIENTATION: ORIENTATION,\n  PIx2: PIx2,\n  INSIDE: INSIDE,\n  OUTSIDE: OUTSIDE,\n  BOUNDARY: BOUNDARY,\n  CONTAINS: CONTAINS,\n  INTERLACE: INTERLACE,\n  OVERLAP_SAME: OVERLAP_SAME,\n  OVERLAP_OPPOSITE: OVERLAP_OPPOSITE\n});\n\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\n\n/**\r\n * Floating point comparison tolerance.\r\n * Default value is 0.000001 (10e-6)\r\n * @type {number}\r\n */\nlet DP_TOL = 0.000001;\n\n/**\r\n * Set new floating point comparison tolerance\r\n * @param {number} tolerance\r\n */\nfunction setTolerance(tolerance) {\n  DP_TOL = tolerance;\n}\n\n/**\r\n * Get floating point comparison tolerance\r\n * @returns {number}\r\n */\nfunction getTolerance() {\n  return DP_TOL;\n}\nconst DECIMALS = 3;\n\n/**\r\n * Returns *true* if value comparable to zero\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\nfunction EQ_0(x) {\n  return x < DP_TOL && x > -DP_TOL;\n}\n\n/**\r\n * Returns *true* if two values are equal up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\nfunction EQ(x, y) {\n  return x - y < DP_TOL && x - y > -DP_TOL;\n}\n\n/**\r\n * Returns *true* if first argument greater than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\nfunction GT(x, y) {\n  return x - y > DP_TOL;\n}\n\n/**\r\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @returns {boolean}\r\n */\nfunction GE(x, y) {\n  return x - y > -DP_TOL;\n}\n\n/**\r\n * Returns *true* if first argument less than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\nfunction LT(x, y) {\n  return x - y < -DP_TOL;\n}\n\n/**\r\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\nfunction LE(x, y) {\n  return x - y < DP_TOL;\n}\nvar Utils = /*#__PURE__*/Object.freeze({\n  setTolerance: setTolerance,\n  getTolerance: getTolerance,\n  DECIMALS: DECIMALS,\n  EQ_0: EQ_0,\n  EQ: EQ,\n  GT: GT,\n  GE: GE,\n  LT: LT,\n  LE: LE\n});\n\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\n\n/**\r\n * Class of system errors\r\n */\nclass Errors {\n  /**\r\n   * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\r\n   * @returns {ReferenceError}\r\n   */\n  static get ILLEGAL_PARAMETERS() {\n    return new ReferenceError('Illegal Parameters');\n  }\n\n  /**\r\n   * Throw error ZERO_DIVISION to catch situation of zero division\r\n   * @returns {Error}\r\n   */\n  static get ZERO_DIVISION() {\n    return new Error('Zero division');\n  }\n\n  /**\r\n   * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\r\n   * @returns {Error}\r\n   */\n  static get UNRESOLVED_BOUNDARY_CONFLICT() {\n    return new Error('Unresolved boundary conflict in boolean operation');\n  }\n\n  /**\r\n   * Error to throw from LinkedList:testInfiniteLoop static method\r\n   * in case when circular loop detected in linked list\r\n   * @returns {Error}\r\n   */\n  static get INFINITE_LOOP() {\n    return new Error('Infinite loop');\n  }\n}\nvar errors = /*#__PURE__*/Object.freeze({\n  default: Errors\n});\nlet Flatten = {\n  Utils: Utils,\n  Errors: Errors,\n  Matrix: undefined,\n  Planar_set: undefined,\n  Point: undefined,\n  Vector: undefined,\n  Line: undefined,\n  Circle: undefined,\n  Segment: undefined,\n  Arc: undefined,\n  Box: undefined,\n  Edge: undefined,\n  Face: undefined,\n  Ray: undefined,\n  Ray_shooting: undefined,\n  Multiline: undefined,\n  Polygon: undefined,\n  Distance: undefined\n};\nfor (let c in Constants) {\n  Flatten[c] = Constants[c];\n}\nObject.defineProperty(Flatten, 'DP_TOL', {\n  get: function () {\n    return getTolerance();\n  },\n  set: function (value) {\n    setTolerance(value);\n  }\n});\n\n/**\r\n * Class implements bidirectional non-circular linked list. <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\nclass LinkedList {\n  constructor(first, last) {\n    this.first = first;\n    this.last = last || this.first;\n  }\n\n  /**\r\n   * Throw an error if circular loop detected in the linked list\r\n   * @param {LinkedListElement} first element to start iteration\r\n   * @throws {Flatten.Errors.INFINITE_LOOP}\r\n   */\n  static testInfiniteLoop(first) {\n    let edge = first;\n    let controlEdge = first;\n    do {\n      if (edge != first && edge === controlEdge) {\n        throw Flatten.Errors.INFINITE_LOOP; // new Error(\"Infinite loop\")\n      }\n      edge = edge.next;\n      controlEdge = controlEdge.next.next;\n    } while (edge != first);\n  }\n\n  /**\r\n   * Return number of elements in the list\r\n   * @returns {number}\r\n   */\n  get size() {\n    let counter = 0;\n    for (let edge of this) {\n      counter++;\n    }\n    return counter;\n  }\n\n  /**\r\n   * Return array of elements from start to end,\r\n   * If start or end not defined, take first as start, last as end\r\n   * @returns {Array}\r\n   */\n  toArray() {\n    let start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let elements = [];\n    let from = start || this.first;\n    let to = end || this.last;\n    let element = from;\n    if (element === undefined) return elements;\n    do {\n      elements.push(element);\n      element = element.next;\n    } while (element !== to.next);\n    return elements;\n  }\n\n  /**\r\n   * Append new element to the end of the list\r\n   * @param {LinkedListElement} element\r\n   * @returns {LinkedList}\r\n   */\n  append(element) {\n    if (this.isEmpty()) {\n      this.first = element;\n    } else {\n      element.prev = this.last;\n      this.last.next = element;\n    }\n\n    // update edge to be last\n    this.last = element;\n\n    // nullify non-circular links\n    this.last.next = undefined;\n    this.first.prev = undefined;\n    return this;\n  }\n\n  /**\r\n   * Insert new element to the list after elementBefore\r\n   * @param {LinkedListElement} newElement\r\n   * @param {LinkedListElement} elementBefore\r\n   * @returns {LinkedList}\r\n   */\n  insert(newElement, elementBefore) {\n    if (this.isEmpty()) {\n      this.first = newElement;\n      this.last = newElement;\n    } else if (elementBefore === null || elementBefore === undefined) {\n      newElement.next = this.first;\n      this.first.prev = newElement;\n      this.first = newElement;\n    } else {\n      /* set links to new element */\n      let elementAfter = elementBefore.next;\n      elementBefore.next = newElement;\n      if (elementAfter) elementAfter.prev = newElement;\n\n      /* set links from new element */\n      newElement.prev = elementBefore;\n      newElement.next = elementAfter;\n\n      /* extend list if new element added after the last element */\n      if (this.last === elementBefore) this.last = newElement;\n    }\n    // nullify non-circular links\n    this.last.next = undefined;\n    this.first.prev = undefined;\n    return this;\n  }\n\n  /**\r\n   * Remove element from the list\r\n   * @param {LinkedListElement} element\r\n   * @returns {LinkedList}\r\n   */\n  remove(element) {\n    // special case if last edge removed\n    if (element === this.first && element === this.last) {\n      this.first = undefined;\n      this.last = undefined;\n    } else {\n      // update linked list\n      if (element.prev) element.prev.next = element.next;\n      if (element.next) element.next.prev = element.prev;\n      // update first if need\n      if (element === this.first) {\n        this.first = element.next;\n      }\n      // update last if need\n      if (element === this.last) {\n        this.last = element.prev;\n      }\n    }\n    return this;\n  }\n\n  /**\r\n   * Return true if list is empty\r\n   * @returns {boolean}\r\n   */\n  isEmpty() {\n    return this.first === undefined;\n  }\n  [Symbol.iterator]() {\n    let value = undefined;\n    return {\n      next: () => {\n        value = value ? value.next : this.first;\n        return {\n          value: value,\n          done: value === undefined\n        };\n      }\n    };\n  }\n}\n\n/**\r\n * Created by Alex Bol on 12/02/2018.\r\n */\n\nlet {\n  INSIDE: INSIDE$1,\n  OUTSIDE: OUTSIDE$1,\n  BOUNDARY: BOUNDARY$1,\n  OVERLAP_SAME: OVERLAP_SAME$1,\n  OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1\n} = Flatten;\nconst NOT_VERTEX = 0;\nconst START_VERTEX = 1;\nconst END_VERTEX = 2;\nconst BOOLEAN_UNION = 1;\nconst BOOLEAN_INTERSECT = 2;\nconst BOOLEAN_SUBTRACT = 3;\n\n/**\r\n * Unify two polygons polygons and returns new polygon. <br/>\r\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\nfunction unify(polygon1, polygon2) {\n  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\n  return res_poly;\n}\n\n/**\r\n * Subtract second polygon from the first and returns new polygon\r\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\nfunction subtract(polygon1, polygon2) {\n  let polygon2_tmp = polygon2.clone();\n  let polygon2_reversed = polygon2_tmp.reverse();\n  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\n  return res_poly;\n}\n\n/**\r\n * Intersect two polygons and returns new polygon\r\n * Point belongs to the resultes polygon is it belongs to the first AND to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\nfunction intersect(polygon1, polygon2) {\n  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\n  return res_poly;\n}\n\n/**\r\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\r\n * The first array are shapes from the first polygon, the second array are shapes from the second\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[][]}\r\n */\nfunction innerClip(polygon1, polygon2) {\n  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\n  let clip_shapes1 = [];\n  for (let face of res_poly.faces) {\n    clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n  }\n  let clip_shapes2 = [];\n  for (let face of wrk_poly.faces) {\n    clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\n  }\n  return [clip_shapes1, clip_shapes2];\n}\n\n/**\r\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[]}\r\n */\nfunction outerClip(polygon1, polygon2) {\n  let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\n  let clip_shapes1 = [];\n  for (let face of res_poly.faces) {\n    clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n  }\n  return clip_shapes1;\n}\n\n/**\r\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\r\n * Points in the first array belong to first polygon, points from the second - to the second.\r\n * Points in each array are ordered according to the direction of the correspondent polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Point[][]}\r\n */\nfunction calculateIntersections(polygon1, polygon2) {\n  let res_poly = polygon1.clone();\n  let wrk_poly = polygon2.clone();\n\n  // get intersection points\n  let intersections = getIntersections(res_poly, wrk_poly);\n\n  // sort intersection points\n  sortIntersections(intersections);\n\n  // split by intersection points\n  splitByIntersections(res_poly, intersections.int_points1_sorted);\n  splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n  // filter duplicated intersection points\n  filterDuplicatedIntersections(intersections);\n  let ip_sorted1 = intersections.int_points1_sorted.map(int_point => int_point.pt);\n  let ip_sorted2 = intersections.int_points2_sorted.map(int_point => int_point.pt);\n  return [ip_sorted1, ip_sorted2];\n}\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\n  // keep not intersected faces for further remove and merge\n  let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\n  let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\n\n  // calculate inclusion flag for not intersected faces\n  calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\n  calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\n\n  // initialize inclusion flags for edges incident to intersections\n  initializeInclusionFlags(intersections.int_points1);\n  initializeInclusionFlags(intersections.int_points2);\n\n  // calculate inclusion flags only for edges incident to intersections\n  calculateInclusionFlags(intersections.int_points1, wrk_poly);\n  calculateInclusionFlags(intersections.int_points2, res_poly);\n\n  // fix boundary conflicts\n  while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\n  // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\n\n  // Set overlapping flags for boundary chains: SAME or OPPOSITE\n  setOverlappingFlags(intersections);\n\n  // remove not relevant chains between intersection points\n  removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\n  removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\n\n  // remove not relevant not intersected faces from res_polygon and wrk_polygon\n  // if op == UNION, remove faces that are included in wrk_polygon without intersection\n  // if op == INTERSECT, remove faces that are not included into wrk_polygon\n  removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\n  removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\n}\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\n  // add edges of wrk_poly into the edge container of res_poly\n  copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\n\n  // swap links from res_poly to wrk_poly and vice versa\n  swapLinks(res_poly, wrk_poly, intersections);\n\n  // remove old faces\n  removeOldFaces(res_poly, intersections.int_points1);\n  removeOldFaces(wrk_poly, intersections.int_points2);\n\n  // restore faces\n  restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\n  restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\n\n  // merge relevant not intersected faces from wrk_polygon to res_polygon\n  // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\n}\nfunction booleanOpBinary(polygon1, polygon2, op, restore) {\n  let res_poly = polygon1.clone();\n  let wrk_poly = polygon2.clone();\n\n  // get intersection points\n  let intersections = getIntersections(res_poly, wrk_poly);\n\n  // sort intersection points\n  sortIntersections(intersections);\n\n  // split by intersection points\n  splitByIntersections(res_poly, intersections.int_points1_sorted);\n  splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n  // filter duplicated intersection points\n  filterDuplicatedIntersections(intersections);\n\n  // calculate inclusion and remove not relevant edges\n  filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\n  if (restore) {\n    swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\n  }\n  return [res_poly, wrk_poly];\n}\nfunction getIntersections(polygon1, polygon2) {\n  let intersections = {\n    int_points1: [],\n    int_points2: []\n  };\n\n  // calculate intersections\n  for (let edge1 of polygon1.edges) {\n    // request edges of polygon2 in the box of edge1\n    let resp = polygon2.edges.search(edge1.box);\n\n    // for each edge2 in response\n    for (let edge2 of resp) {\n      // calculate intersections between edge1 and edge2\n      let ip = edge1.shape.intersect(edge2.shape);\n\n      // for each intersection point\n      for (let pt of ip) {\n        addToIntPoints(edge1, pt, intersections.int_points1);\n        addToIntPoints(edge2, pt, intersections.int_points2);\n      }\n    }\n  }\n  return intersections;\n}\nfunction addToIntPoints(edge, pt, int_points) {\n  let id = int_points.length;\n  let shapes = edge.shape.split(pt);\n\n  // if (shapes.length < 2) return;\n  if (shapes.length === 0) return; // Point does not belong to edge ?\n\n  let len = 0;\n  if (shapes[0] === null) {\n    // point incident to edge start vertex\n    len = 0;\n  } else if (shapes[1] === null) {\n    // point incident to edge end vertex\n    len = edge.shape.length;\n  } else {\n    // Edge was split into to edges\n    len = shapes[0].length;\n  }\n  let is_vertex = NOT_VERTEX;\n  if (EQ(len, 0)) {\n    is_vertex |= START_VERTEX;\n  }\n  if (EQ(len, edge.shape.length)) {\n    is_vertex |= END_VERTEX;\n  }\n  // Fix intersection point which is end point of the last edge\n  let arc_length = is_vertex & END_VERTEX && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;\n  int_points.push({\n    id: id,\n    pt: pt,\n    arc_length: arc_length,\n    edge_before: edge,\n    edge_after: undefined,\n    face: edge.face,\n    is_vertex: is_vertex\n  });\n}\nfunction sortIntersections(intersections) {\n  // if (intersections.int_points1.length === 0) return;\n\n  // augment intersections with new sorted arrays\n  // intersections.int_points1_sorted = intersections.int_points1.slice().sort(compareFn);\n  // intersections.int_points2_sorted = intersections.int_points2.slice().sort(compareFn);\n  intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n  intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n}\nfunction getSortedArray(int_points) {\n  let faceMap = new Map();\n  let id = 0;\n  // Create integer id's for faces\n  for (let ip of int_points) {\n    if (!faceMap.has(ip.face)) {\n      faceMap.set(ip.face, id);\n      id++;\n    }\n  }\n  // Augment intersection points with face id's\n  for (let ip of int_points) {\n    ip.faceId = faceMap.get(ip.face);\n  }\n  // Clone and sort\n  let int_points_sorted = int_points.slice().sort(compareFn);\n  return int_points_sorted;\n}\nfunction compareFn(ip1, ip2) {\n  // compare face id's\n  if (ip1.faceId < ip2.faceId) {\n    return -1;\n  }\n  if (ip1.faceId > ip2.faceId) {\n    return 1;\n  }\n  // same face - compare arc_length\n  if (ip1.arc_length < ip2.arc_length) {\n    return -1;\n  }\n  if (ip1.arc_length > ip2.arc_length) {\n    return 1;\n  }\n  return 0;\n}\nfunction splitByIntersections(polygon, int_points) {\n  if (!int_points) return;\n  for (let int_point of int_points) {\n    let edge = int_point.edge_before;\n\n    // recalculate vertex flag: it may be changed after previous split\n    int_point.is_vertex = NOT_VERTEX;\n    if (edge.shape.start.equalTo(int_point.pt)) {\n      int_point.is_vertex |= START_VERTEX;\n    }\n    if (edge.shape.end.equalTo(int_point.pt)) {\n      int_point.is_vertex |= END_VERTEX;\n    }\n    if (int_point.is_vertex & START_VERTEX) {\n      // nothing to split\n      int_point.edge_before = edge.prev;\n      int_point.is_vertex = END_VERTEX;\n      continue;\n    }\n    if (int_point.is_vertex & END_VERTEX) {\n      // nothing to split\n      continue;\n    }\n    let newEdge = polygon.addVertex(int_point.pt, edge);\n    int_point.edge_before = newEdge;\n  }\n  for (let int_point of int_points) {\n    int_point.edge_after = int_point.edge_before.next;\n  }\n}\nfunction filterDuplicatedIntersections(intersections) {\n  if (intersections.int_points1.length < 2) return;\n  let do_squeeze = false;\n  let int_point_ref1;\n  let int_point_ref2;\n  let int_point_cur1;\n  let int_point_cur2;\n  for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\n    if (intersections.int_points1_sorted[i].id === -1) continue;\n    int_point_ref1 = intersections.int_points1_sorted[i];\n    int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n    for (let j = i + 1; j < intersections.int_points1_sorted.length; j++) {\n      int_point_cur1 = intersections.int_points1_sorted[j];\n      if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\n        break;\n      }\n      if (int_point_cur1.id === -1) continue;\n      int_point_cur2 = intersections.int_points2[int_point_cur1.id];\n      if (int_point_cur2.id === -1) continue;\n      if (int_point_cur1.edge_before === int_point_ref1.edge_before && int_point_cur1.edge_after === int_point_ref1.edge_after && int_point_cur2.edge_before === int_point_ref2.edge_before && int_point_cur2.edge_after === int_point_ref2.edge_after) {\n        int_point_cur1.id = -1;\n        /* to be deleted */\n        int_point_cur2.id = -1;\n        /* to be deleted */\n        do_squeeze = true;\n      }\n    }\n  }\n  int_point_ref2 = intersections.int_points2_sorted[0];\n  int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n  for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\n    let int_point_cur2 = intersections.int_points2_sorted[i];\n    if (int_point_cur2.id == -1) continue;\n    /* already deleted */\n\n    if (int_point_ref2.id == -1 || /* can't be reference if already deleted */\n    !EQ(int_point_cur2.arc_length, int_point_ref2.arc_length)) {\n      int_point_ref2 = int_point_cur2;\n      int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n      continue;\n    }\n    let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\n    if (int_point_cur1.edge_before === int_point_ref1.edge_before && int_point_cur1.edge_after === int_point_ref1.edge_after && int_point_cur2.edge_before === int_point_ref2.edge_before && int_point_cur2.edge_after === int_point_ref2.edge_after) {\n      int_point_cur1.id = -1;\n      /* to be deleted */\n      int_point_cur2.id = -1;\n      /* to be deleted */\n      do_squeeze = true;\n    }\n  }\n  if (do_squeeze) {\n    intersections.int_points1 = intersections.int_points1.filter(int_point => int_point.id >= 0);\n    intersections.int_points2 = intersections.int_points2.filter(int_point => int_point.id >= 0);\n\n    // update id's\n    intersections.int_points1.forEach((int_point, index) => int_point.id = index);\n    intersections.int_points2.forEach((int_point, index) => int_point.id = index);\n\n    // re-create sorted\n    intersections.int_points1_sorted = [];\n    intersections.int_points2_sorted = [];\n    sortIntersections(intersections);\n  }\n}\nfunction getNotIntersectedFaces(poly, int_points) {\n  let notIntersected = [];\n  for (let face of poly.faces) {\n    if (!int_points.find(ip => ip.face === face)) {\n      notIntersected.push(face);\n    }\n  }\n  return notIntersected;\n}\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2) {\n  for (let face of notIntersectedFaces) {\n    face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\n    face.first.setInclusion(poly2);\n  }\n}\nfunction initializeInclusionFlags(int_points) {\n  for (let int_point of int_points) {\n    int_point.edge_before.bvStart = undefined;\n    int_point.edge_before.bvEnd = undefined;\n    int_point.edge_before.bv = undefined;\n    int_point.edge_before.overlap = undefined;\n    int_point.edge_after.bvStart = undefined;\n    int_point.edge_after.bvEnd = undefined;\n    int_point.edge_after.bv = undefined;\n    int_point.edge_after.overlap = undefined;\n  }\n  for (let int_point of int_points) {\n    int_point.edge_before.bvEnd = BOUNDARY$1;\n    int_point.edge_after.bvStart = BOUNDARY$1;\n  }\n}\nfunction calculateInclusionFlags(int_points, polygon) {\n  for (let int_point of int_points) {\n    int_point.edge_before.setInclusion(polygon);\n    int_point.edge_after.setInclusion(polygon);\n  }\n}\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections) {\n  let cur_face;\n  let first_int_point_in_face_id;\n  let next_int_point1;\n  let num_int_points = int_points1_sorted.length;\n  let iterate_more = false;\n  for (let i = 0; i < num_int_points; i++) {\n    let cur_int_point1 = int_points1_sorted[i];\n\n    // Find boundary chain in the polygon1\n    if (cur_int_point1.face !== cur_face) {\n      // next chain started\n      first_int_point_in_face_id = i; // cur_int_point1;\n      cur_face = cur_int_point1.face;\n    }\n\n    // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n    let int_points_cur_pool_start = i;\n    let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\n    let next_int_point_id;\n    if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points && int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n      next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n    } else {\n      // get first point from the same face\n      next_int_point_id = first_int_point_in_face_id;\n    }\n\n    // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n    // has same face both in res_poly and in wrk_poly\n    let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\n    next_int_point1 = null;\n    for (let j = next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n      let next_int_point1_tmp = int_points1_sorted[j];\n      if (next_int_point1_tmp.face === cur_face && int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\n        next_int_point1 = next_int_point1_tmp;\n        break;\n      }\n    }\n    if (next_int_point1 === null) continue;\n    let edge_from1 = cur_int_point1.edge_after;\n    let edge_to1 = next_int_point1.edge_before;\n\n    // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\n    if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv != BOUNDARY$1) {\n      edge_from1.bv = edge_to1.bv;\n      continue;\n    }\n    if (edge_from1.bv != BOUNDARY$1 && edge_to1.bv === BOUNDARY$1) {\n      edge_to1.bv = edge_from1.bv;\n      continue;\n    }\n\n    // Set up all boundary values for middle edges. Need for cases 2 and 3\n    if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1 || edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1 || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1) {\n      let edge_tmp = edge_from1.next;\n      while (edge_tmp != edge_to1) {\n        edge_tmp.bvStart = undefined;\n        edge_tmp.bvEnd = undefined;\n        edge_tmp.bv = undefined;\n        edge_tmp.setInclusion(poly2);\n        edge_tmp = edge_tmp.next;\n      }\n    }\n\n    // Case #2. Both of the ends boundary. Check all the edges in the middle\n    // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\n    if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1) {\n      let edge_tmp = edge_from1.next;\n      let new_bv;\n      while (edge_tmp != edge_to1) {\n        if (edge_tmp.bv != BOUNDARY$1) {\n          if (new_bv === undefined) {\n            // first not boundary edge between from and to\n            new_bv = edge_tmp.bv;\n          } else {\n            // another not boundary edge between from and to\n            if (edge_tmp.bv != new_bv) {\n              // and it has different bv - can't resolve conflict\n              throw Flatten.Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n            }\n          }\n        }\n        edge_tmp = edge_tmp.next;\n      }\n      if (new_bv != undefined) {\n        edge_from1.bv = new_bv;\n        edge_to1.bv = new_bv;\n      }\n      continue; // all middle edges are boundary, proceed with this\n    }\n\n    // Case 3. One of the ends is inner, another is outer\n    if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1 || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1) {\n      let edge_tmp = edge_from1;\n      // Find missing intersection point\n      while (edge_tmp != edge_to1) {\n        if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\n          let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\n          if (dist < 10 * Flatten.DP_TOL) {\n            // it should be very close\n            // let pt = edge_tmp.end;\n            // add to the list of intersections of poly1\n            addToIntPoints(edge_tmp, segment.ps, int_points1);\n\n            // split edge_tmp in poly1 if need\n            let int_point1 = int_points1[int_points1.length - 1];\n            if (int_point1.is_vertex & START_VERTEX) {\n              // nothing to split\n              int_point1.edge_after = edge_tmp;\n              int_point1.edge_before = edge_tmp.prev;\n              edge_tmp.bvStart = BOUNDARY$1;\n              edge_tmp.bv = undefined;\n              edge_tmp.setInclusion(poly2);\n            } else if (int_point1.is_vertex & END_VERTEX) {\n              // nothing to split\n              int_point1.edge_after = edge_tmp.next;\n              edge_tmp.bvEnd = BOUNDARY$1;\n              edge_tmp.bv = undefined;\n              edge_tmp.setInclusion(poly2);\n            } else {\n              // split edge here\n              let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\n              int_point1.edge_before = newEdge1;\n              int_point1.edge_after = newEdge1.next;\n              newEdge1.setInclusion(poly2);\n              newEdge1.next.bvStart = BOUNDARY$1;\n              newEdge1.next.bvEnd = undefined;\n              newEdge1.next.bv = undefined;\n              newEdge1.next.setInclusion(poly2);\n            }\n\n            // add to the list of intersections of poly2\n            let edge2 = poly2.findEdgeByPoint(segment.pe);\n            addToIntPoints(edge2, segment.pe, int_points2);\n            // split edge2 in poly2 if need\n            let int_point2 = int_points2[int_points2.length - 1];\n            if (int_point2.is_vertex & START_VERTEX) {\n              // nothing to split\n              int_point2.edge_after = edge2;\n              int_point2.edge_before = edge2.prev;\n            } else if (int_point2.is_vertex & END_VERTEX) {\n              // nothing to split\n              int_point2.edge_after = edge2.next;\n            } else {\n              // split edge here\n              // first locate int_points that may refer to edge2 as edge.after\n              // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\n              let int_point2_edge_after = int_points2.find(int_point => int_point.edge_after === edge2);\n              let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\n              int_point2.edge_before = newEdge2;\n              int_point2.edge_after = newEdge2.next;\n              if (int_point2_edge_after) int_point2_edge_after.edge_after = newEdge2;\n              newEdge2.bvStart = undefined;\n              newEdge2.bvEnd = BOUNDARY$1;\n              newEdge2.bv = undefined;\n              newEdge2.setInclusion(poly1);\n              newEdge2.next.bvStart = BOUNDARY$1;\n              newEdge2.next.bvEnd = undefined;\n              newEdge2.next.bv = undefined;\n              newEdge2.next.setInclusion(poly1);\n            }\n            sortIntersections(intersections);\n            iterate_more = true;\n            break;\n          }\n        }\n        edge_tmp = edge_tmp.next;\n      }\n\n      // we changed intersections inside loop, have to exit and repair again\n      if (iterate_more) break;\n      throw Flatten.Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n    }\n  }\n  return iterate_more;\n}\nfunction setOverlappingFlags(intersections) {\n  let cur_face = undefined;\n  let first_int_point_in_face_id = undefined;\n  let next_int_point1 = undefined;\n  let num_int_points = intersections.int_points1.length;\n  for (let i = 0; i < num_int_points; i++) {\n    let cur_int_point1 = intersections.int_points1_sorted[i];\n\n    // Find boundary chain in the polygon1\n    if (cur_int_point1.face !== cur_face) {\n      // next chain started\n      first_int_point_in_face_id = i; // cur_int_point1;\n      cur_face = cur_int_point1.face;\n    }\n\n    // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n    let int_points_cur_pool_start = i;\n    let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\n    let next_int_point_id;\n    if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points && intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n      next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n    } else {\n      // get first point from the same face\n      next_int_point_id = first_int_point_in_face_id;\n    }\n\n    // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n    // has same face both in res_poly and in wrk_poly\n    let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\n    next_int_point1 = null;\n    for (let j = next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n      let next_int_point1_tmp = intersections.int_points1_sorted[j];\n      if (next_int_point1_tmp.face === cur_face && intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\n        next_int_point1 = next_int_point1_tmp;\n        break;\n      }\n    }\n    if (next_int_point1 === null) continue;\n    let edge_from1 = cur_int_point1.edge_after;\n    let edge_to1 = next_int_point1.edge_before;\n    if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))\n      // not a boundary chain - skip\n      continue;\n    if (edge_from1 !== edge_to1)\n      //  one edge chain    TODO: support complex case\n      continue;\n\n    /* Find boundary chain in polygon2 between same intersection points */\n    let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\n    let next_int_point2 = intersections.int_points2[next_int_point1.id];\n    let edge_from2 = cur_int_point2.edge_after;\n    let edge_to2 = next_int_point2.edge_before;\n\n    /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\n    /* check also that chain consist of one or two edges */\n    if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {\n      cur_int_point2 = intersections.int_points2[next_int_point1.id];\n      next_int_point2 = intersections.int_points2[cur_int_point1.id];\n      edge_from2 = cur_int_point2.edge_after;\n      edge_to2 = next_int_point2.edge_before;\n    }\n    if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) continue; // not an overlapping chain - skip   TODO: fix boundary conflict\n\n    // Set overlapping flag - one-to-one case\n    edge_from1.setOverlap(edge_from2);\n  }\n}\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon) {\n  if (!int_points) return;\n  let cur_face = undefined;\n  let first_int_point_in_face_num = undefined;\n  let int_point_current;\n  let int_point_next;\n  for (let i = 0; i < int_points.length; i++) {\n    int_point_current = int_points[i];\n    if (int_point_current.face !== cur_face) {\n      // next face started\n      first_int_point_in_face_num = i;\n      cur_face = int_point_current.face;\n    }\n    if (cur_face.isEmpty())\n      // ??\n      continue;\n\n    // Get next int point from the same face that current\n\n    // Count how many duplicated points with same <x,y> in \"points from\" pool ?\n    let int_points_from_pull_start = i;\n    let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\n    let next_int_point_num;\n    if (int_points_from_pull_start + int_points_from_pull_num < int_points.length && int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\n      next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\n    } else {\n      // get first point from the same face\n      next_int_point_num = first_int_point_in_face_num;\n    }\n    int_point_next = int_points[next_int_point_num];\n\n    /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\n    let int_points_to_pull_start = next_int_point_num;\n    let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\n    let edge_from = int_point_current.edge_after;\n    let edge_to = int_point_next.edge_before;\n    if (edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION || edge_from.bv === OUTSIDE$1 && edge_to.bv === OUTSIDE$1 && op === BOOLEAN_INTERSECT || (edge_from.bv === OUTSIDE$1 || edge_to.bv === OUTSIDE$1) && op === BOOLEAN_SUBTRACT && !is_res_polygon || (edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon || edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && edge_from.overlap & OVERLAP_SAME$1 && is_res_polygon || edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && edge_from.overlap & OVERLAP_OPPOSITE$1) {\n      polygon.removeChain(cur_face, edge_from, edge_to);\n\n      /* update all points in \"points from\" pull */\n      for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\n        int_points[k].edge_after = undefined;\n      }\n\n      /* update all points in \"points to\" pull */\n      for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\n        int_points[k].edge_before = undefined;\n      }\n    }\n\n    /* skip to the last point in \"points from\" group */\n    i += int_points_from_pull_num - 1;\n  }\n}\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face) {\n  let int_point_current;\n  let int_point_next;\n  let int_points_pool_num = 1;\n  if (int_points.length == 1) return 1;\n  int_point_current = int_points[cur_int_point_num];\n  for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\n    if (int_point_current.face != cur_face) {\n      /* next face started */\n      break;\n    }\n    int_point_next = int_points[i];\n    if (!(int_point_next.pt.equalTo(int_point_current.pt) && int_point_next.edge_before === int_point_current.edge_before && int_point_next.edge_after === int_point_current.edge_after)) {\n      break; /* next point is different - break and exit */\n    }\n    int_points_pool_num++; /* duplicated intersection point - increase counter */\n  }\n  return int_points_pool_num;\n}\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points) {\n  for (let face of wrk_polygon.faces) {\n    for (let edge of face) {\n      res_polygon.edges.add(edge);\n    }\n    // If union - add face from wrk_polygon that is not intersected with res_polygon\n    if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\n    int_points.find(ip => ip.face === face) === undefined) {\n      res_polygon.addFace(face.first, face.last);\n    }\n  }\n}\nfunction swapLinks(res_polygon, wrk_polygon, intersections) {\n  if (intersections.int_points1.length === 0) return;\n  for (let i = 0; i < intersections.int_points1.length; i++) {\n    let int_point1 = intersections.int_points1[i];\n    let int_point2 = intersections.int_points2[i];\n\n    // Simple case - find continuation on the other polygon\n\n    // Process edge from res_polygon\n    if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {\n      // swap need\n      if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {\n        // simple case\n        // Connect edges\n        int_point1.edge_before.next = int_point2.edge_after;\n        int_point2.edge_after.prev = int_point1.edge_before;\n\n        // Fill in missed links in intersection points\n        int_point1.edge_after = int_point2.edge_after;\n        int_point2.edge_before = int_point1.edge_before;\n      }\n    }\n    // Process edge from wrk_polygon\n    if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {\n      // swap need\n      if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {\n        // simple case\n        // Connect edges\n        int_point2.edge_before.next = int_point1.edge_after;\n        int_point1.edge_after.prev = int_point2.edge_before;\n\n        // Complete missed links\n        int_point2.edge_after = int_point1.edge_after;\n        int_point1.edge_before = int_point2.edge_before;\n      }\n    }\n\n    // Continuation not found - complex case\n    // Continuation will be found on the same polygon.\n    // It happens when intersection point is actually touching point\n    // Polygon1\n    if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {\n      // still swap need\n      for (let int_point of intersections.int_points1_sorted) {\n        if (int_point === int_point1) continue; // skip same\n        if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n          if (int_point.pt.equalTo(int_point1.pt)) {\n            // Connect edges\n            int_point1.edge_before.next = int_point.edge_after;\n            int_point.edge_after.prev = int_point1.edge_before;\n\n            // Complete missed links\n            int_point1.edge_after = int_point.edge_after;\n            int_point.edge_before = int_point1.edge_before;\n          }\n        }\n      }\n    }\n    // Polygon2\n    if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {\n      // still swap need\n      for (let int_point of intersections.int_points2_sorted) {\n        if (int_point === int_point2) continue; // skip same\n        if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n          if (int_point.pt.equalTo(int_point2.pt)) {\n            // Connect edges\n            int_point2.edge_before.next = int_point.edge_after;\n            int_point.edge_after.prev = int_point2.edge_before;\n\n            // Complete missed links\n            int_point2.edge_after = int_point.edge_after;\n            int_point.edge_before = int_point2.edge_before;\n          }\n        }\n      }\n    }\n  }\n  // Sanity check that no dead ends left\n}\nfunction removeOldFaces(polygon, int_points) {\n  for (let int_point of int_points) {\n    polygon.faces.delete(int_point.face);\n    int_point.face = undefined;\n    if (int_point.edge_before) int_point.edge_before.face = undefined;\n    if (int_point.edge_after) int_point.edge_after.face = undefined;\n  }\n}\nfunction restoreFaces(polygon, int_points, other_int_points) {\n  // For each intersection point - create new face\n  for (let int_point of int_points) {\n    if (int_point.edge_before === undefined || int_point.edge_after === undefined)\n      // completely deleted\n      continue;\n    if (int_point.face)\n      // already restored\n      continue;\n    if (int_point.edge_after.face || int_point.edge_before.face)\n      // Face already created. Possible case in duplicated intersection points\n      continue;\n    let first = int_point.edge_after; // face start\n    let last = int_point.edge_before; // face end;\n\n    LinkedList.testInfiniteLoop(first); // check and throw error if infinite loop found\n\n    let face = polygon.addFace(first, last);\n\n    // Mark intersection points from the newly create face\n    // to avoid multiple creation of the same face\n    // Face was assigned to each edge of new face in addFace function\n    for (let int_point_tmp of int_points) {\n      if (int_point_tmp.edge_before && int_point_tmp.edge_after && int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n        int_point_tmp.face = face;\n      }\n    }\n    // Mark other intersection points as well\n    for (let int_point_tmp of other_int_points) {\n      if (int_point_tmp.edge_before && int_point_tmp.edge_after && int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n        int_point_tmp.face = face;\n      }\n    }\n  }\n}\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon) {\n  for (let face of notIntersectedFaces) {\n    let rel = face.first.bv;\n    if (op === BOOLEAN_UNION && rel === INSIDE$1 || op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon || op === BOOLEAN_SUBTRACT && rel === OUTSIDE$1 && !is_res_polygon || op === BOOLEAN_INTERSECT && rel === OUTSIDE$1) {\n      polygon.deleteFace(face);\n    }\n  }\n}\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\n  BOOLEAN_UNION: BOOLEAN_UNION,\n  BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\n  BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\n  unify: unify,\n  subtract: subtract,\n  intersect: intersect,\n  innerClip: innerClip,\n  outerClip: outerClip,\n  calculateIntersections: calculateIntersections,\n  addToIntPoints: addToIntPoints,\n  getSortedArray: getSortedArray,\n  splitByIntersections: splitByIntersections,\n  filterDuplicatedIntersections: filterDuplicatedIntersections,\n  removeNotRelevantChains: removeNotRelevantChains,\n  removeOldFaces: removeOldFaces,\n  restoreFaces: restoreFaces\n});\n\n/*\r\n    Dimensionally extended 9-intersected model\r\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\r\n */\n// const DISJOINT = RegExp('FF.FF....');\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\nconst INSIDE$2 = RegExp('T.F..F...');\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\nclass DE9IM {\n  /**\r\n   * Create new instance of DE9IM matrix\r\n   */\n  constructor() {\n    /**\r\n     * Array representing 3x3 intersection matrix\r\n     * @type {Shape[]}\r\n     */\n    this.m = new Array(9).fill(undefined);\n  }\n\n  /**\r\n   * Get Interior To Interior intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get I2I() {\n    return this.m[0];\n  }\n\n  /**\r\n   * Set Interior To Interior intersection\r\n   * @param geom\r\n   */\n  set I2I(geom) {\n    this.m[0] = geom;\n  }\n\n  /**\r\n   * Get Interior To Boundary intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get I2B() {\n    return this.m[1];\n  }\n\n  /**\r\n   * Set Interior to Boundary intersection\r\n   * @param geomc\r\n   */\n  set I2B(geom) {\n    this.m[1] = geom;\n  }\n\n  /**\r\n   * Get Interior To Exterior intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get I2E() {\n    return this.m[2];\n  }\n\n  /**\r\n   * Set Interior to Exterior intersection\r\n   * @param geom\r\n   */\n  set I2E(geom) {\n    this.m[2] = geom;\n  }\n\n  /**\r\n   * Get Boundary To Interior intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get B2I() {\n    return this.m[3];\n  }\n\n  /**\r\n   * Set Boundary to Interior intersection\r\n   * @param geom\r\n   */\n  set B2I(geom) {\n    this.m[3] = geom;\n  }\n\n  /**\r\n   * Get Boundary To Boundary intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get B2B() {\n    return this.m[4];\n  }\n\n  /**\r\n   * Set Boundary to Boundary intersection\r\n   * @param geom\r\n   */\n  set B2B(geom) {\n    this.m[4] = geom;\n  }\n\n  /**\r\n   * Get Boundary To Exterior intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get B2E() {\n    return this.m[5];\n  }\n\n  /**\r\n   * Set Boundary to Exterior intersection\r\n   * @param geom\r\n   */\n  set B2E(geom) {\n    this.m[5] = geom;\n  }\n\n  /**\r\n   * Get Exterior To Interior intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get E2I() {\n    return this.m[6];\n  }\n\n  /**\r\n   * Set Exterior to Interior intersection\r\n   * @param geom\r\n   */\n  set E2I(geom) {\n    this.m[6] = geom;\n  }\n\n  /**\r\n   * Get Exterior To Boundary intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get E2B() {\n    return this.m[7];\n  }\n\n  /**\r\n   * Set Exterior to Boundary intersection\r\n   * @param geom\r\n   */\n  set E2B(geom) {\n    this.m[7] = geom;\n  }\n\n  /**\r\n   * Get Exterior to Exterior intersection\r\n   * @returns {Shape[] | undefined}\r\n   */\n  get E2E() {\n    return this.m[8];\n  }\n\n  /**\r\n   * Set Exterior to Exterior intersection\r\n   * @param geom\r\n   */\n  set E2E(geom) {\n    this.m[8] = geom;\n  }\n\n  /**\r\n   * Return de9im matrix as string where<br/>\r\n   * - intersection is 'T'<br/>\r\n   * - not intersected is 'F'<br/>\r\n   * - not relevant is '*'<br/>\r\n   * For example, string 'FF**FF****' means 'DISJOINT'\r\n   * @returns {string}\r\n   */\n  toString() {\n    return this.m.map(e => {\n      if (e instanceof Array && e.length > 0) {\n        return 'T';\n      } else if (e instanceof Array && e.length === 0) {\n        return 'F';\n      } else {\n        return '*';\n      }\n    }).join(\"\");\n  }\n  equal() {\n    return EQUAL.test(this.toString());\n  }\n  intersect() {\n    return INTERSECT.test(this.toString());\n  }\n  touch() {\n    return TOUCH.test(this.toString());\n  }\n  inside() {\n    return INSIDE$2.test(this.toString());\n  }\n  covered() {\n    return COVERED.test(this.toString());\n  }\n}\n\n/**\r\n * Intersection\r\n *\r\n * */\n\nfunction intersectLine2Line(line1, line2) {\n  let ip = [];\n  let [A1, B1, C1] = line1.standard;\n  let [A2, B2, C2] = line2.standard;\n\n  /* Cramer's rule */\n  let det = A1 * B2 - B1 * A2;\n  let detX = C1 * B2 - B1 * C2;\n  let detY = A1 * C2 - C1 * A2;\n  if (!Flatten.Utils.EQ_0(det)) {\n    let x, y;\n    if (B1 === 0) {\n      // vertical line x  = C1/A1, where A1 == +1 or -1\n      x = C1 / A1;\n      y = detY / det;\n    } else if (B2 === 0) {\n      // vertical line x = C2/A2, where A2 = +1 or -1\n      x = C2 / A2;\n      y = detY / det;\n    } else if (A1 === 0) {\n      // horizontal line y = C1/B1, where B1 = +1 or -1\n      x = detX / det;\n      y = C1 / B1;\n    } else if (A2 === 0) {\n      // horizontal line y = C2/B2, where B2 = +1 or -1\n      x = detX / det;\n      y = C2 / B2;\n    } else {\n      x = detX / det;\n      y = detY / det;\n    }\n    ip.push(new Flatten.Point(x, y));\n  }\n  return ip;\n}\nfunction intersectLine2Circle(line, circle) {\n  let ip = [];\n  let prj = circle.pc.projectionOn(line); // projection of circle center on line\n  let dist = circle.pc.distanceTo(prj)[0]; // distance from circle center to projection\n\n  if (Flatten.Utils.EQ(dist, circle.r)) {\n    // line tangent to circle - return single intersection point\n    ip.push(prj);\n  } else if (Flatten.Utils.LT(dist, circle.r)) {\n    // return two intersection points\n    let delta = Math.sqrt(circle.r * circle.r - dist * dist);\n    let v_trans, pt;\n    v_trans = line.norm.rotate90CCW().multiply(delta);\n    pt = prj.translate(v_trans);\n    ip.push(pt);\n    v_trans = line.norm.rotate90CW().multiply(delta);\n    pt = prj.translate(v_trans);\n    ip.push(pt);\n  }\n  return ip;\n}\nfunction intersectLine2Box(line, box) {\n  let ips = [];\n  for (let seg of box.toSegments()) {\n    let ips_tmp = intersectSegment2Line(seg, line);\n    for (let pt of ips_tmp) {\n      if (!ptInIntPoints(pt, ips)) {\n        ips.push(pt);\n      }\n    }\n  }\n  return ips;\n}\nfunction intersectLine2Arc(line, arc) {\n  let ip = [];\n  if (intersectLine2Box(line, arc.box).length === 0) {\n    return ip;\n  }\n  let circle = new Flatten.Circle(arc.pc, arc.r);\n  let ip_tmp = intersectLine2Circle(line, circle);\n  for (let pt of ip_tmp) {\n    if (pt.on(arc)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectSegment2Line(seg, line) {\n  let ip = [];\n\n  // Boundary cases\n  if (seg.ps.on(line)) {\n    ip.push(seg.ps);\n  }\n  // If both ends lay on line, return two intersection points\n  if (seg.pe.on(line) && !seg.isZeroLength()) {\n    ip.push(seg.pe);\n  }\n  if (ip.length > 0) {\n    return ip; // done, intersection found\n  }\n\n  // If zero-length segment and nothing found, return no intersections\n  if (seg.isZeroLength()) {\n    return ip;\n  }\n\n  // Not a boundary case, check if both points are on the same side and\n  // hence there is no intersection\n  if (seg.ps.leftTo(line) && seg.pe.leftTo(line) || !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\n    return ip;\n  }\n\n  // Calculate intersection between lines\n  let line1 = new Flatten.Line(seg.ps, seg.pe);\n  return intersectLine2Line(line1, line);\n}\nfunction intersectSegment2Segment(seg1, seg2) {\n  let ip = [];\n\n  // quick reject\n  if (seg1.box.not_intersect(seg2.box)) {\n    return ip;\n  }\n\n  // Special case of seg1 zero length\n  if (seg1.isZeroLength()) {\n    if (seg1.ps.on(seg2)) {\n      ip.push(seg1.ps);\n    }\n    return ip;\n  }\n\n  // Special case of seg2 zero length\n  if (seg2.isZeroLength()) {\n    if (seg2.ps.on(seg1)) {\n      ip.push(seg2.ps);\n    }\n    return ip;\n  }\n\n  // Neither seg1 nor seg2 is zero length\n  let line1 = new Flatten.Line(seg1.ps, seg1.pe);\n  let line2 = new Flatten.Line(seg2.ps, seg2.pe);\n\n  // Check overlapping between segments in case of incidence\n  // If segments touching, add one point. If overlapping, add two points\n  if (line1.incidentTo(line2)) {\n    if (seg1.ps.on(seg2)) {\n      ip.push(seg1.ps);\n    }\n    if (seg1.pe.on(seg2)) {\n      ip.push(seg1.pe);\n    }\n    if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\n      ip.push(seg2.ps);\n    }\n    if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\n      ip.push(seg2.pe);\n    }\n  } else {\n    /* not incident - parallel or intersect */\n    // Calculate intersection between lines\n    let new_ip = intersectLine2Line(line1, line2);\n    if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\n      ip.push(new_ip[0]);\n    }\n\n    // Fix missing intersection\n    // const tol = 10*Flatten.DP_TOL;\n    // if (ip.length === 0 && new_ip.length > 0 && (new_ip[0].distanceTo(seg1)[0] < tol || new_ip[0].distanceTo(seg2)[0] < tol) ) {\n    //     if (seg1.start.distanceTo(seg2)[0] < tol) {\n    //         ip.push(new_ip[0]);\n    //     }\n    //     else if (seg1.end.distanceTo(seg2)[0] < tol) {\n    //         ip.push(new_ip[0]);\n    //     }\n    //     else if (seg2.start.distanceTo(seg1)[0] < tol) {\n    //         ip.push(new_ip[0]);\n    //     }\n    //     else if (seg2.end.distanceTo(seg1)[0] < tol) {\n    //         ip.push(new_ip[0]);\n    //     }\n    // }\n  }\n  return ip;\n}\nfunction intersectSegment2Circle(segment, circle) {\n  let ips = [];\n  if (segment.box.not_intersect(circle.box)) {\n    return ips;\n  }\n\n  // Special case of zero length segment\n  if (segment.isZeroLength()) {\n    let [dist, shortest_segment] = segment.ps.distanceTo(circle.pc);\n    if (Flatten.Utils.EQ(dist, circle.r)) {\n      ips.push(segment.ps);\n    }\n    return ips;\n  }\n\n  // Non zero-length segment\n  let line = new Flatten.Line(segment.ps, segment.pe);\n  let ips_tmp = intersectLine2Circle(line, circle);\n  for (let ip of ips_tmp) {\n    if (ip.on(segment)) {\n      ips.push(ip);\n    }\n  }\n  return ips;\n}\nfunction intersectSegment2Arc(segment, arc) {\n  let ip = [];\n  if (segment.box.not_intersect(arc.box)) {\n    return ip;\n  }\n\n  // Special case of zero-length segment\n  if (segment.isZeroLength()) {\n    if (segment.ps.on(arc)) {\n      ip.push(segment.ps);\n    }\n    return ip;\n  }\n\n  // Non-zero length segment\n  let line = new Flatten.Line(segment.ps, segment.pe);\n  let circle = new Flatten.Circle(arc.pc, arc.r);\n  let ip_tmp = intersectLine2Circle(line, circle);\n  for (let pt of ip_tmp) {\n    if (pt.on(segment) && pt.on(arc)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectSegment2Box(segment, box) {\n  let ips = [];\n  for (let seg of box.toSegments()) {\n    let ips_tmp = intersectSegment2Segment(seg, segment);\n    for (let ip of ips_tmp) {\n      ips.push(ip);\n    }\n  }\n  return ips;\n}\nfunction intersectCircle2Circle(circle1, circle2) {\n  let ip = [];\n  if (circle1.box.not_intersect(circle2.box)) {\n    return ip;\n  }\n  let vec = new Flatten.Vector(circle1.pc, circle2.pc);\n  let r1 = circle1.r;\n  let r2 = circle2.r;\n\n  // Degenerated circle\n  if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2)) return ip;\n\n  // In case of equal circles return one leftmost point\n  if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\n    ip.push(circle1.pc.translate(-r1, 0));\n    return ip;\n  }\n  let dist = circle1.pc.distanceTo(circle2.pc)[0];\n  if (Flatten.Utils.GT(dist, r1 + r2))\n    // circles too far, no intersections\n    return ip;\n  if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))\n    // one circle is contained within another, no intersections\n    return ip;\n\n  // Normalize vector.\n  vec.x /= dist;\n  vec.y /= dist;\n  let pt;\n\n  // Case of touching from outside or from inside - single intersection point\n  // TODO: check this specifically not sure if correct\n  if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\n    pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\n    ip.push(pt);\n    return ip;\n  }\n\n  // Case of two intersection points\n\n  // Distance from first center to center of common chord:\n  //   a = (r1^2 - r2^2 + d^2) / 2d\n  // Separate for better accuracy\n  let a = r1 * r1 / (2 * dist) - r2 * r2 / (2 * dist) + dist / 2;\n  let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\n  let h = Math.sqrt(r1 * r1 - a * a);\n  // let norm;\n\n  // norm = vec.rotate90CCW().multiply(h);\n  pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n  ip.push(pt);\n\n  // norm = vec.rotate90CW();\n  pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n  ip.push(pt);\n  return ip;\n}\nfunction intersectCircle2Box(circle, box) {\n  let ips = [];\n  for (let seg of box.toSegments()) {\n    let ips_tmp = intersectSegment2Circle(seg, circle);\n    for (let ip of ips_tmp) {\n      ips.push(ip);\n    }\n  }\n  return ips;\n}\nfunction intersectArc2Arc(arc1, arc2) {\n  var ip = [];\n  if (arc1.box.not_intersect(arc2.box)) {\n    return ip;\n  }\n\n  // Special case: overlapping arcs\n  // May return up to 4 intersection points\n  if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\n    let pt;\n    pt = arc1.start;\n    if (pt.on(arc2)) ip.push(pt);\n    pt = arc1.end;\n    if (pt.on(arc2)) ip.push(pt);\n    pt = arc2.start;\n    if (pt.on(arc1)) ip.push(pt);\n    pt = arc2.end;\n    if (pt.on(arc1)) ip.push(pt);\n    return ip;\n  }\n\n  // Common case\n  let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\n  let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\n  let ip_tmp = circle1.intersect(circle2);\n  for (let pt of ip_tmp) {\n    if (pt.on(arc1) && pt.on(arc2)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectArc2Circle(arc, circle) {\n  let ip = [];\n  if (arc.box.not_intersect(circle.box)) {\n    return ip;\n  }\n\n  // Case when arc center incident to circle center\n  // Return arc's end points as 2 intersection points\n  if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\n    ip.push(arc.start);\n    ip.push(arc.end);\n    return ip;\n  }\n\n  // Common case\n  let circle1 = circle;\n  let circle2 = new Flatten.Circle(arc.pc, arc.r);\n  let ip_tmp = intersectCircle2Circle(circle1, circle2);\n  for (let pt of ip_tmp) {\n    if (pt.on(arc)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectArc2Box(arc, box) {\n  let ips = [];\n  for (let seg of box.toSegments()) {\n    let ips_tmp = intersectSegment2Arc(seg, arc);\n    for (let ip of ips_tmp) {\n      ips.push(ip);\n    }\n  }\n  return ips;\n}\nfunction intersectEdge2Segment(edge, segment) {\n  return edge.isSegment() ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\n}\nfunction intersectEdge2Arc(edge, arc) {\n  return edge.isSegment() ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\n}\nfunction intersectEdge2Line(edge, line) {\n  return edge.isSegment() ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\n}\nfunction intersectEdge2Circle(edge, circle) {\n  return edge.isSegment() ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\n}\nfunction intersectSegment2Polygon(segment, polygon) {\n  let ip = [];\n  for (let edge of polygon.edges) {\n    for (let pt of intersectEdge2Segment(edge, segment)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectArc2Polygon(arc, polygon) {\n  let ip = [];\n  for (let edge of polygon.edges) {\n    for (let pt of intersectEdge2Arc(edge, arc)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectLine2Polygon(line, polygon) {\n  let ip = [];\n  if (polygon.isEmpty()) {\n    return ip;\n  }\n  for (let edge of polygon.edges) {\n    for (let pt of intersectEdge2Line(edge, line)) {\n      if (!ptInIntPoints(pt, ip)) {\n        ip.push(pt);\n      }\n    }\n  }\n  return line.sortPoints(ip);\n}\nfunction intersectCircle2Polygon(circle, polygon) {\n  let ip = [];\n  if (polygon.isEmpty()) {\n    return ip;\n  }\n  for (let edge of polygon.edges) {\n    for (let pt of intersectEdge2Circle(edge, circle)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectEdge2Edge(edge1, edge2) {\n  const shape1 = edge1.shape;\n  const shape2 = edge2.shape;\n  return edge1.isSegment() ? edge2.isSegment() ? intersectSegment2Segment(shape1, shape2) : intersectSegment2Arc(shape1, shape2) : edge2.isSegment() ? intersectSegment2Arc(shape2, shape1) : intersectArc2Arc(shape1, shape2);\n}\nfunction intersectEdge2Polygon(edge, polygon) {\n  let ip = [];\n  if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\n    return ip;\n  }\n  let resp_edges = polygon.edges.search(edge.shape.box);\n  for (let resp_edge of resp_edges) {\n    for (let pt of intersectEdge2Edge(edge, resp_edge)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\n  let ip = [];\n  if (polygon1.isEmpty() || polygon2.isEmpty()) {\n    return ip;\n  }\n  if (polygon1.box.not_intersect(polygon2.box)) {\n    return ip;\n  }\n  for (let edge1 of polygon1.edges) {\n    for (let pt of intersectEdge2Polygon(edge1, polygon2)) {\n      ip.push(pt);\n    }\n  }\n  return ip;\n}\nfunction intersectShape2Polygon(shape, polygon) {\n  if (shape instanceof Flatten.Line) {\n    return intersectLine2Polygon(shape, polygon);\n  } else if (shape instanceof Flatten.Segment) {\n    return intersectSegment2Polygon(shape, polygon);\n  } else if (shape instanceof Flatten.Arc) {\n    return intersectArc2Polygon(shape, polygon);\n  } else {\n    return [];\n  }\n}\nfunction ptInIntPoints(new_pt, ip) {\n  return ip.some(pt => pt.equalTo(new_pt));\n}\n\n/**\r\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\r\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\r\n */\nclass Multiline extends LinkedList {\n  constructor() {\n    super();\n    if (arguments.length === 0) {\n      return;\n    }\n    if (arguments.length == 1) {\n      if ((arguments.length <= 0 ? undefined : arguments[0]) instanceof Array) {\n        let shapes = arguments.length <= 0 ? undefined : arguments[0];\n        if (shapes.length == 0) return;\n\n        // TODO: more strict validation:\n        // there may be only one line\n        // only first and last may be rays\n        let validShapes = shapes.every(shape => {\n          return shape instanceof Flatten.Segment || shape instanceof Flatten.Arc || shape instanceof Flatten.Ray || shape instanceof Flatten.Line;\n        });\n        for (let shape of shapes) {\n          let edge = new Flatten.Edge(shape);\n          this.append(edge);\n        }\n      }\n    }\n  }\n\n  /**\r\n   * (Getter) Return array of edges\r\n   * @returns {Edge[]}\r\n   */\n  get edges() {\n    return [...this];\n  }\n\n  /**\r\n   * (Getter) Return bounding box of the multiline\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return this.edges.reduce((acc, edge) => acc = acc.merge(edge.box), new Flatten.Box());\n  }\n\n  /**\r\n   * (Getter) Returns array of vertices\r\n   * @returns {Point[]}\r\n   */\n  get vertices() {\n    let v = this.edges.map(edge => edge.start);\n    v.push(this.last.end);\n    return v;\n  }\n\n  /**\r\n   * Return new cloned instance of Multiline\r\n   * @returns {Multiline}\r\n   */\n  clone() {\n    return new Multiline(this.toShapes());\n  }\n\n  /**\r\n   * Split edge and add new vertex, return new edge inserted\r\n   * @param {Point} pt - point on edge that will be added as new vertex\r\n   * @param {Edge} edge - edge to split\r\n   * @returns {Edge}\r\n   */\n  addVertex(pt, edge) {\n    let shapes = edge.shape.split(pt);\n    // if (shapes.length < 2) return;\n\n    if (shapes[0] === null)\n      // point incident to edge start vertex, return previous edge\n      return edge.prev;\n    if (shapes[1] === null)\n      // point incident to edge end vertex, return edge itself\n      return edge;\n    let newEdge = new Flatten.Edge(shapes[0]);\n    let edgeBefore = edge.prev;\n\n    /* Insert first split edge into linked list after edgeBefore */\n    this.insert(newEdge, edgeBefore); // edge.face ?\n\n    // Update edge shape with second split edge keeping links\n    edge.shape = shapes[1];\n    return newEdge;\n  }\n\n  /**\r\n   * Split edges of multiline with intersection points and return mutated multiline\r\n   * @param {Point[]} ip - array of points to be added as new vertices\r\n   * @returns {Multiline}\r\n   */\n  split(ip) {\n    for (let pt of ip) {\n      let edge = this.findEdgeByPoint(pt);\n      this.addVertex(pt, edge);\n    }\n    return this;\n  }\n\n  /**\r\n   * Returns edge which contains given point\r\n   * @param {Point} pt\r\n   * @returns {Edge}\r\n   */\n  findEdgeByPoint(pt) {\n    let edgeFound;\n    for (let edge of this) {\n      if (edge.shape.contains(pt)) {\n        edgeFound = edge;\n        break;\n      }\n    }\n    return edgeFound;\n  }\n\n  /**\r\n   * Returns new multiline translated by vector vec\r\n   * @param {Vector} vec\r\n   * @returns {Multiline}\r\n   */\n  translate(vec) {\n    return new Multiline(this.edges.map(edge => edge.shape.translate(vec)));\n  }\n\n  /**\r\n   * Return new multiline rotated by given angle around given point\r\n   * If point omitted, rotate around origin (0,0)\r\n   * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n   * @param {number} angle - rotation angle in radians\r\n   * @param {Point} center - rotation center, default is (0,0)\r\n   * @returns {Multiline} - new rotated polygon\r\n   */\n  rotate() {\n    let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Flatten.Point();\n    return new Multiline(this.edges.map(edge => edge.shape.rotate(angle, center)));\n  }\n\n  /**\r\n   * Return new multiline transformed using affine transformation matrix\r\n   * Method does not support unbounded shapes\r\n   * @param {Matrix} matrix - affine transformation matrix\r\n   * @returns {Multiline} - new multiline\r\n   */\n  transform() {\n    let matrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Flatten.Matrix();\n    return new Multiline(this.edges.map(edge => edge.shape.transform(matrix)));\n  }\n\n  /**\r\n   * Transform multiline into array of shapes\r\n   * @returns {Shape[]}\r\n   */\n  toShapes() {\n    return this.edges.map(edge => edge.shape.clone());\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return this.edges.map(edge => edge.toJSON());\n  }\n\n  /**\r\n   * Return string to draw multiline in svg\r\n   * @param attrs  - an object with attributes for svg path element,\r\n   * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n   * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n   * TODO: support infinite Ray and Line\r\n   * @returns {string}\r\n   */\n  svg() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      stroke,\n      strokeWidth,\n      fill,\n      fillRule,\n      fillOpacity,\n      id,\n      className\n    } = attrs;\n    let id_str = id && id.length > 0 ? \"id=\\\"\".concat(id, \"\\\"\") : \"\";\n    let class_str = className && className.length > 0 ? \"class=\\\"\".concat(className, \"\\\"\") : \"\";\n    let svgStr = \"\\n<path stroke=\\\"\".concat(stroke || \"black\", \"\\\" stroke-width=\\\"\").concat(strokeWidth || 1, \"\\\" fill=\\\"\").concat(fill || \"lightcyan\", \"\\\" fill-rule=\\\"\").concat(fillRule || \"evenodd\", \"\\\" fill-opacity=\\\"\").concat(fillOpacity || 1.0, \"\\\" \").concat(id_str, \" \").concat(class_str, \" d=\\\"\");\n    svgStr += \"\\nM\".concat(this.first.start.x, \",\").concat(this.first.start.y);\n    for (let edge of this) {\n      svgStr += edge.svg();\n    }\n    svgStr += \" z\";\n    svgStr += \"\\\" >\\n</path>\";\n    return svgStr;\n  }\n}\nFlatten.Multiline = Multiline;\n\n/**\r\n * Shortcut function to create multiline\r\n * @param args\r\n */\nconst multiline = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return new Flatten.Multiline(...args);\n};\nFlatten.multiline = multiline;\n\n/**\r\n * @module RayShoot\r\n */\n\n/**\r\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\r\n * @param {Polgon} polygon - polygon to test\r\n * @param {Point} point - point to test\r\n * @returns {Flatten.Inside|Flatten.OUTSIDE|Flatten.Boundary}\r\n */\nfunction ray_shoot(polygon, point) {\n  let contains = undefined;\n\n  // 1. Quick reject\n  // if (polygon.box.not_intersect(point.box)) {\n  //     return Flatten.OUTSIDE;\n  // }\n\n  let ray = new Flatten.Ray(point);\n  let line = new Flatten.Line(ray.pt, ray.norm);\n\n  // 2. Locate relevant edges of the polygon\n  const searchBox = new Flatten.Box(ray.box.xmin - Flatten.DP_TOL, ray.box.ymin - Flatten.DP_TOL, ray.box.xmax, ray.box.ymax + Flatten.DP_TOL);\n  if (polygon.box.not_intersect(searchBox)) {\n    return Flatten.OUTSIDE;\n  }\n  let resp_edges = polygon.edges.search(searchBox);\n  if (resp_edges.length == 0) {\n    return Flatten.OUTSIDE;\n  }\n\n  // 2.5 Check if boundary\n  for (let edge of resp_edges) {\n    if (edge.shape.contains(point)) {\n      return Flatten.BOUNDARY;\n    }\n  }\n\n  // 3. Calculate intersections\n  let intersections = [];\n  for (let edge of resp_edges) {\n    for (let ip of ray.intersect(edge.shape)) {\n      // If intersection is equal to query point then point lays on boundary\n      if (ip.equalTo(point)) {\n        return Flatten.BOUNDARY;\n      }\n      intersections.push({\n        pt: ip,\n        edge: edge\n      });\n    }\n  }\n\n  // 4. Sort intersection in x-ascending order\n  intersections.sort((i1, i2) => {\n    if (LT(i1.pt.x, i2.pt.x)) {\n      return -1;\n    }\n    if (GT(i1.pt.x, i2.pt.x)) {\n      return 1;\n    }\n    return 0;\n  });\n\n  // 5. Count real intersections, exclude touching\n  let counter = 0;\n  for (let i = 0; i < intersections.length; i++) {\n    let intersection = intersections[i];\n    if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n      /* skip same point between same edges if already counted */\n      if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.edge.prev === intersections[i - 1].edge) {\n        continue;\n      }\n      let prev_edge = intersection.edge.prev;\n      while (EQ_0(prev_edge.length)) {\n        prev_edge = prev_edge.prev;\n      }\n      let prev_tangent = prev_edge.shape.tangentInEnd();\n      let prev_point = intersection.pt.translate(prev_tangent);\n      let cur_tangent = intersection.edge.shape.tangentInStart();\n      let cur_point = intersection.pt.translate(cur_tangent);\n      let prev_on_the_left = prev_point.leftTo(line);\n      let cur_on_the_left = cur_point.leftTo(line);\n      if (prev_on_the_left && !cur_on_the_left || !prev_on_the_left && cur_on_the_left) {\n        counter++;\n      }\n    } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n      /* skip same point between same edges if already counted */\n      if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.edge.next === intersections[i - 1].edge) {\n        continue;\n      }\n      let next_edge = intersection.edge.next;\n      while (EQ_0(next_edge.length)) {\n        next_edge = next_edge.next;\n      }\n      let next_tangent = next_edge.shape.tangentInStart();\n      let next_point = intersection.pt.translate(next_tangent);\n      let cur_tangent = intersection.edge.shape.tangentInEnd();\n      let cur_point = intersection.pt.translate(cur_tangent);\n      let next_on_the_left = next_point.leftTo(line);\n      let cur_on_the_left = cur_point.leftTo(line);\n      if (next_on_the_left && !cur_on_the_left || !next_on_the_left && cur_on_the_left) {\n        counter++;\n      }\n    } else {\n      /* intersection point is not a coincident with a vertex */\n      if (intersection.edge.shape instanceof Flatten.Segment) {\n        counter++;\n      } else {\n        /* Check if ray does not touch the curve in the extremal (top or bottom) point */\n        let box = intersection.edge.shape.box;\n        if (!(EQ(intersection.pt.y, box.ymin) || EQ(intersection.pt.y, box.ymax))) {\n          counter++;\n        }\n      }\n    }\n  }\n\n  // 6. Odd or even?\n  contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\n  return contains;\n}\n\n/*\r\n    Calculate relationship between two shapes and return result in the form of\r\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\r\n */\n\n/**\r\n * Returns true if shapes are topologically equal:  their interiors intersect and\r\n * no part of the interior or boundary of one geometry intersects the exterior of the other\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction equal(shape1, shape2) {\n  return relate(shape1, shape2).equal();\n}\n\n/**\r\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction intersect$1(shape1, shape2) {\n  return relate(shape1, shape2).intersect();\n}\n\n/**\r\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction touch(shape1, shape2) {\n  return relate(shape1, shape2).touch();\n}\n\n/**\r\n * Returns true if shapes have no points in common neither in interior nor in boundary\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction disjoint(shape1, shape2) {\n  return !intersect$1(shape1, shape2);\n}\n\n/**\r\n * Returns true shape1 lies in the interior of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction inside(shape1, shape2) {\n  return relate(shape1, shape2).inside();\n}\n\n/**\r\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction covered(shape1, shape2) {\n  return relate(shape1, shape2).covered();\n}\n\n/**\r\n * Returns true shape1's interior contains shape2 <br/>\r\n * Same as inside(shape2, shape1)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction contain(shape1, shape2) {\n  return inside(shape2, shape1);\n}\n\n/**\r\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\nfunction cover(shape1, shape2) {\n  return covered(shape2, shape1);\n}\n\n/**\r\n * Returns relation between two shapes as intersection 3x3 matrix, where each\r\n * element contains relevant intersection as array of shapes.\r\n * If there is no intersection, element contains empty array\r\n * If intersection is irrelevant it left undefined. (For example, intersection\r\n * between two exteriors is usually irrelevant)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {DE9IM}\r\n */\nfunction relate(shape1, shape2) {\n  if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\n    return relateLine2Line(shape1, shape2);\n  } else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\n    return relateLine2Circle(shape1, shape2);\n  } else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\n    return relateLine2Box(shape1, shape2);\n  } else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Polygon) {\n    return relateLine2Polygon(shape1, shape2);\n  } else if ((shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc) && shape2 instanceof Flatten.Polygon) {\n    return relateShape2Polygon(shape1, shape2);\n  } else if ((shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc) && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\n    return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\n  } else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\n    return relatePolygon2Polygon(shape1, shape2);\n  } else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\n    return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\n  } else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\n    return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\n  } else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\n    return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\n  }\n}\nfunction relateLine2Line(line1, line2) {\n  let denim = new DE9IM();\n  let ip = intersectLine2Line(line1, line2);\n  if (ip.length === 0) {\n    // parallel or equal ?\n    if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\n      denim.I2I = [line1]; // equal  'T.F...F..'  - no boundary\n      denim.I2E = [];\n      denim.E2I = [];\n    } else {\n      // parallel - disjoint 'FFTFF*T**'\n      denim.I2I = [];\n      denim.I2E = [line1];\n      denim.E2I = [line2];\n    }\n  } else {\n    // intersect   'T********'\n    denim.I2I = ip;\n    denim.I2E = line1.split(ip);\n    denim.E2I = line2.split(ip);\n  }\n  return denim;\n}\nfunction relateLine2Circle(line, circle) {\n  let denim = new DE9IM();\n  let ip = intersectLine2Circle(line, circle);\n  if (ip.length === 0) {\n    denim.I2I = [];\n    denim.I2B = [];\n    denim.I2E = [line];\n    denim.E2I = [circle];\n  } else if (ip.length === 1) {\n    denim.I2I = [];\n    denim.I2B = ip;\n    denim.I2E = line.split(ip);\n    denim.E2I = [circle];\n  } else {\n    // ip.length == 2\n    let multiline = new Multiline([line]);\n    let ip_sorted = line.sortPoints(ip);\n    multiline.split(ip_sorted);\n    let splitShapes = multiline.toShapes();\n    denim.I2I = [splitShapes[1]];\n    denim.I2B = ip_sorted;\n    denim.I2E = [splitShapes[0], splitShapes[2]];\n    denim.E2I = new Flatten.Polygon([circle.toArc()]).cut(multiline);\n  }\n  return denim;\n}\nfunction relateLine2Box(line, box) {\n  let denim = new DE9IM();\n  let ip = intersectLine2Box(line, box);\n  if (ip.length === 0) {\n    denim.I2I = [];\n    denim.I2B = [];\n    denim.I2E = [line];\n    denim.E2I = [box];\n  } else if (ip.length === 1) {\n    denim.I2I = [];\n    denim.I2B = ip;\n    denim.I2E = line.split(ip);\n    denim.E2I = [box];\n  } else {\n    // ip.length == 2\n    let multiline = new Multiline([line]);\n    let ip_sorted = line.sortPoints(ip);\n    multiline.split(ip_sorted);\n    let splitShapes = multiline.toShapes();\n\n    /* Are two intersection points on the same segment of the box boundary ? */\n    if (box.toSegments().some(segment => segment.contains(ip[0]) && segment.contains(ip[1]))) {\n      denim.I2I = []; // case of touching\n      denim.I2B = [splitShapes[1]];\n      denim.I2E = [splitShapes[0], splitShapes[2]];\n      denim.E2I = [box];\n    } else {\n      // case of intersection\n      denim.I2I = [splitShapes[1]]; // [segment(ip[0], ip[1])];\n      denim.I2B = ip_sorted;\n      denim.I2E = [splitShapes[0], splitShapes[2]];\n      denim.E2I = new Flatten.Polygon(box.toSegments()).cut(multiline);\n    }\n  }\n  return denim;\n}\nfunction relateLine2Polygon(line, polygon) {\n  let denim = new DE9IM();\n  let ip = intersectLine2Polygon(line, polygon);\n  let multiline = new Multiline([line]);\n  let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\n  multiline.split(ip_sorted);\n  [...multiline].forEach(edge => edge.setInclusion(polygon));\n  denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n  denim.I2B = [...multiline].slice(1).map(edge => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start);\n  denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n  denim.E2I = polygon.cut(multiline);\n  return denim;\n}\nfunction relateShape2Polygon(shape, polygon) {\n  let denim = new DE9IM();\n  let ip = intersectShape2Polygon(shape, polygon);\n  let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\n  let multiline = new Multiline([shape]);\n  multiline.split(ip_sorted);\n  [...multiline].forEach(edge => edge.setInclusion(polygon));\n  denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n  denim.I2B = [...multiline].slice(1).map(edge => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start);\n  denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n  denim.B2I = [];\n  denim.B2B = [];\n  denim.B2E = [];\n  for (let pt of [shape.start, shape.end]) {\n    switch (ray_shoot(polygon, pt)) {\n      case Flatten.INSIDE:\n        denim.B2I.push(pt);\n        break;\n      case Flatten.BOUNDARY:\n        denim.B2B.push(pt);\n        break;\n      case Flatten.OUTSIDE:\n        denim.B2E.push(pt);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // denim.E2I  TODO: calculate, not clear what is expected result\n\n  return denim;\n}\nfunction relatePolygon2Polygon(polygon1, polygon2) {\n  let denim = new DE9IM();\n  let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\n  let boolean_intersection = intersect(polygon1, polygon2);\n  let boolean_difference1 = subtract(polygon1, polygon2);\n  let boolean_difference2 = subtract(polygon2, polygon1);\n  let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\n  let outer_clip_shapes1 = outerClip(polygon1, polygon2);\n  let outer_clip_shapes2 = outerClip(polygon2, polygon1);\n  denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\n  denim.I2B = inner_clip_shapes2;\n  denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\n  denim.B2I = inner_clip_shapes1;\n  denim.B2B = ip_sorted1;\n  denim.B2E = outer_clip_shapes1;\n  denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\n  denim.E2B = outer_clip_shapes2;\n  // denim.E2E    not relevant meanwhile\n\n  return denim;\n}\nvar Relations = /*#__PURE__*/Object.freeze({\n  equal: equal,\n  intersect: intersect$1,\n  touch: touch,\n  disjoint: disjoint,\n  inside: inside,\n  covered: covered,\n  contain: contain,\n  cover: cover,\n  relate: relate\n});\n\n/**\r\n * Class representing an affine transformation 3x3 matrix:\r\n * <pre>\r\n *      [ a  c  tx\r\n * A =    b  d  ty\r\n *        0  0  1  ]\r\n * </pre\r\n * @type {Matrix}\r\n */\nclass Matrix {\n  /**\r\n   * Construct new instance of affine transformation matrix <br/>\r\n   * If parameters omitted, construct identity matrix a = 1, d = 1\r\n   * @param {number} a - position(0,0)   sx*cos(alpha)\r\n   * @param {number} b - position (0,1)  sx*sin(alpha)\r\n   * @param {number} c - position (1,0)  -sy*sin(alpha)\r\n   * @param {number} d - position (1,1)  sy*cos(alpha)\r\n   * @param {number} tx - position (2,0) translation by x\r\n   * @param {number} ty - position (2,1) translation by y\r\n   */\n  constructor() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    let tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n\n  /**\r\n   * Return new cloned instance of matrix\r\n   * @return {Matrix}\r\n   **/\n  clone() {\n    return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\n  }\n  /**\r\n   * Transform vector [x,y] using transformation matrix. <br/>\r\n   * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\r\n   * The result is also an abstract vector [x',y'] = A * [x,y]:\r\n   * <code>\r\n   * [x'       [ ax + by + tx\r\n   *  y'   =     cx + dy + ty\r\n   *  1]                    1 ]\r\n   * </code>\r\n   * @param {number[]} vector - array[2] of numbers\r\n   * @returns {number[]} transformation result - array[2] of numbers\r\n   */\n  transform(vector) {\n    return [vector[0] * this.a + vector[1] * this.c + this.tx, vector[0] * this.b + vector[1] * this.d + this.ty];\n  }\n  /**\r\n   * Returns result of multiplication of this matrix by other matrix\r\n   * @param {Matrix} other_matrix - matrix to multiply by\r\n   * @returns {Matrix}\r\n   */\n  multiply(other_matrix) {\n    return new Matrix(this.a * other_matrix.a + this.c * other_matrix.b, this.b * other_matrix.a + this.d * other_matrix.b, this.a * other_matrix.c + this.c * other_matrix.d, this.b * other_matrix.c + this.d * other_matrix.d, this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx, this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty);\n  }\n  /**\r\n   * Return new matrix as a result of multiplication of the current matrix\r\n   * by the matrix(1,0,0,1,tx,ty)\r\n   * @param {number} tx - translation by x\r\n   * @param {number} ty - translation by y\r\n   * @returns {Matrix}\r\n   */\n  translate() {\n    let tx, ty;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (args.length == 1 && args[0] instanceof Flatten.Vector) {\n      tx = args[0].x;\n      ty = args[0].y;\n    } else if (args.length == 2 && typeof args[0] == \"number\" && typeof args[1] == \"number\") {\n      tx = args[0];\n      ty = args[1];\n    } else {\n      throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n    return this.multiply(new Matrix(1, 0, 0, 1, tx, ty));\n  }\n  /**\r\n   * Return new matrix as a result of multiplication of the current matrix\r\n   * by the matrix that defines rotation by given angle (in radians) around\r\n   * point (0,0) in counter clockwise direction\r\n   * @param {number} angle - angle in radians\r\n   * @returns {Matrix}\r\n   */\n  rotate(angle) {\n    let cos = Math.cos(angle);\n    let sin = Math.sin(angle);\n    return this.multiply(new Matrix(cos, sin, -sin, cos, 0, 0));\n  }\n  /**\r\n   * Return new matrix as a result of multiplication of the current matrix\r\n   * by the matrix (sx,0,0,sy,0,0) that defines scaling\r\n   * @param {number} sx\r\n   * @param {number} sy\r\n   * @returns {Matrix}\r\n   */\n  scale(sx, sy) {\n    return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\n  }\n  /**\r\n   * Returns true if two matrix are equal parameter by parameter\r\n   * @param {Matrix} matrix - other matrix\r\n   * @returns {boolean} true if equal, false otherwise\r\n   */\n  equalTo(matrix) {\n    if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\n    if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\n    if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\n    if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\n    if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\n    if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\n    return true;\n  }\n}\nFlatten.Matrix = Matrix;\n/**\r\n * Function to create matrix equivalent to \"new\" constructor\r\n * @param args\r\n */\nconst matrix = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  return new Flatten.Matrix(...args);\n};\nFlatten.matrix = matrix;\n\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\n\n/**\r\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\r\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\r\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\r\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\r\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\r\n * This interface is described in typescript definition file *index.d.ts*\r\n *\r\n * Axis aligned rectangle is an example of such interval.\r\n * We may look at rectangle as an interval between its low left and top right corners.\r\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\r\n * of Interval interface implementation\r\n * @type {Interval}\r\n */\nconst Interval = class Interval {\n  /**\r\n   * Accept two comparable values and creates new instance of interval\r\n   * Predicate Interval.comparable_less(low, high) supposed to return true on these values\r\n   * @param low\r\n   * @param high\r\n   */\n  constructor(low, high) {\n    this.low = low;\n    this.high = high;\n  }\n\n  /**\r\n   * Clone interval\r\n   * @returns {Interval}\r\n   */\n  clone() {\n    return new Interval(this.low, this.high);\n  }\n\n  /**\r\n   * Propery max returns clone of this interval\r\n   * @returns {Interval}\r\n   */\n  get max() {\n    return this.clone(); // this.high;\n  }\n\n  /**\r\n   * Predicate returns true is this interval less than other interval\r\n   * @param other_interval\r\n   * @returns {boolean}\r\n   */\n  less_than(other_interval) {\n    return this.low < other_interval.low || this.low == other_interval.low && this.high < other_interval.high;\n  }\n\n  /**\r\n   * Predicate returns true is this interval equals to other interval\r\n   * @param other_interval\r\n   * @returns {boolean}\r\n   */\n  equal_to(other_interval) {\n    return this.low == other_interval.low && this.high == other_interval.high;\n  }\n\n  /**\r\n   * Predicate returns true if this interval intersects other interval\r\n   * @param other_interval\r\n   * @returns {boolean}\r\n   */\n  intersect(other_interval) {\n    return !this.not_intersect(other_interval);\n  }\n\n  /**\r\n   * Predicate returns true if this interval does not intersect other interval\r\n   * @param other_interval\r\n   * @returns {boolean}\r\n   */\n  not_intersect(other_interval) {\n    return this.high < other_interval.low || other_interval.high < this.low;\n  }\n\n  /**\r\n   * Returns new interval merged with other interval\r\n   * @param {Interval} interval - Other interval to merge with\r\n   * @returns {Interval}\r\n   */\n  merge(other_interval) {\n    return new Interval(this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low), this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high));\n  }\n\n  /**\r\n   * Returns how key should return\r\n   */\n  output() {\n    return [this.low, this.high];\n  }\n\n  /**\r\n   * Function returns maximum between two comparable values\r\n   * @param interval1\r\n   * @param interval2\r\n   * @returns {Interval}\r\n   */\n  static comparable_max(interval1, interval2) {\n    return interval1.merge(interval2);\n  }\n\n  /**\r\n   * Predicate returns true if first value less than second value\r\n   * @param val1\r\n   * @param val2\r\n   * @returns {boolean}\r\n   */\n  static comparable_less_than(val1, val2) {\n    return val1 < val2;\n  }\n};\n\n/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\n\nclass Node {\n  constructor() {\n    let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let left = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let right = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : RB_TREE_COLOR_BLACK;\n    this.left = left; // reference to left child node\n    this.right = right; // reference to right child node\n    this.parent = parent; // reference to parent node\n    this.color = color;\n    this.item = {\n      key: key,\n      value: value\n    }; // key is supposed to be instance of Interval\n\n    /* If not, this should by an array of two numbers */\n    if (key && key instanceof Array && key.length == 2) {\n      if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n        this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n      }\n    }\n    this.max = this.item.key ? this.item.key.max : undefined;\n  }\n  isNil() {\n    return this.item.key === undefined && this.item.value === undefined && this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK;\n  }\n  less_than(other_node) {\n    // if tree stores only keys\n    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n      return this.item.key.less_than(other_node.item.key);\n    } else {\n      // if tree stores keys and values\n      let value_less_than = this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) : this.item.value < other_node.item.value;\n      return this.item.key.less_than(other_node.item.key) || this.item.key.equal_to(other_node.item.key) && value_less_than;\n    }\n\n    // if (this.item.value && other_node.item.value) {\n    //     let item_less_than = this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\n    //         this.item.value < other_node.item.value;\n    //     return this.item.key.less_than(other_node.item.key) ||\n    //         this.item.key.equal_to((other_node.item.key)) && item_less_than;\n    // }\n    // else {\n    //     return this.item.key.less_than(other_node.item.key);\n    // }\n  }\n  equal_to(other_node) {\n    // if tree stores only keys\n    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n      return this.item.key.equal_to(other_node.item.key);\n    } else {\n      // if tree stores keys and values\n      let value_equal = this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) : this.item.value == other_node.item.value;\n      return this.item.key.equal_to(other_node.item.key) && value_equal;\n    }\n\n    // let value_equal = true;\n    // if (this.item.value && other_node.item.value) {\n    //     value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\n    //         this.item.value == other_node.item.value;\n    // }\n    // return this.item.key.equal_to(other_node.item.key) && value_equal;\n  }\n  intersect(other_node) {\n    return this.item.key.intersect(other_node.item.key);\n  }\n  copy_data(other_node) {\n    this.item.key = other_node.item.key.clone();\n    this.item.value = other_node.item.value && other_node.item.value.clone ? other_node.item.value.clone() : other_node.item.value;\n  }\n  update_max() {\n    // use key (Interval) max property instead of key.high\n    this.max = this.item.key ? this.item.key.max : undefined;\n    if (this.right && this.right.max) {\n      const comparable_max = this.item.key.constructor.comparable_max; // static method\n      this.max = comparable_max(this.max, this.right.max);\n    }\n    if (this.left && this.left.max) {\n      const comparable_max = this.item.key.constructor.comparable_max; // static method\n      this.max = comparable_max(this.max, this.left.max);\n    }\n  }\n\n  // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n  not_intersect_left_subtree(search_node) {\n    const comparable_less_than = this.item.key.constructor.comparable_less_than; // static method\n    let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n    return comparable_less_than(high, search_node.item.key.low);\n  }\n\n  // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n  not_intersect_right_subtree(search_node) {\n    const comparable_less_than = this.item.key.constructor.comparable_less_than; // static method\n    let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n    return comparable_less_than(search_node.item.key.high, low);\n  }\n}\n\n/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\n\n// const nil_node = new Node();\n\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\r\n * @type {IntervalTree}\r\n */\nclass IntervalTree {\n  /**\r\n   * Construct new empty instance of IntervalTree\r\n   */\n  constructor() {\n    this.root = null;\n    this.nil_node = new Node();\n  }\n\n  /**\r\n   * Returns number of items stored in the interval tree\r\n   * @returns {number}\r\n   */\n  get size() {\n    let count = 0;\n    this.tree_walk(this.root, () => count++);\n    return count;\n  }\n\n  /**\r\n   * Returns array of sorted keys in the ascending order\r\n   * @returns {Array}\r\n   */\n  get keys() {\n    let res = [];\n    this.tree_walk(this.root, node => res.push(node.item.key.output ? node.item.key.output() : node.item.key));\n    return res;\n  }\n\n  /**\r\n   * Return array of values in the ascending keys order\r\n   * @returns {Array}\r\n   */\n  get values() {\n    let res = [];\n    this.tree_walk(this.root, node => res.push(node.item.value));\n    return res;\n  }\n\n  /**\r\n   * Returns array of items (<key,value> pairs) in the ascended keys order\r\n   * @returns {Array}\r\n   */\n  get items() {\n    let res = [];\n    this.tree_walk(this.root, node => res.push({\n      key: node.item.key.output ? node.item.key.output() : node.item.key,\n      value: node.item.value\n    }));\n    return res;\n  }\n\n  /**\r\n   * Returns true if tree is empty\r\n   * @returns {boolean}\r\n   */\n  isEmpty() {\n    return this.root == null || this.root == this.nil_node;\n  }\n\n  /**\r\n   * Insert new item into interval tree\r\n   * @param {Interval} key - interval object or array of two numbers [low, high]\r\n   * @param {any} value - value representing any object (optional)\r\n   * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\r\n   */\n  insert(key) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : key;\n    if (key === undefined) return;\n    let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n    this.tree_insert(insert_node);\n    this.recalc_max(insert_node);\n    return insert_node;\n  }\n\n  /**\r\n   * Returns true if item {key,value} exist in the tree\r\n   * @param {Interval} key - interval correspondent to keys stored in the tree\r\n   * @param {any} value - value object to be checked\r\n   * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\r\n   */\n  exist(key) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : key;\n    let search_node = new Node(key, value);\n    return this.tree_search(this.root, search_node) ? true : false;\n  }\n\n  /**\r\n   * Remove entry {key, value} from the tree\r\n   * @param {Interval} key - interval correspondent to keys stored in the tree\r\n   * @param {any} value - value object\r\n   * @returns {boolean} true if item {key, value} deleted, false if not found\r\n   */\n  remove(key) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : key;\n    let search_node = new Node(key, value);\n    let delete_node = this.tree_search(this.root, search_node);\n    if (delete_node) {\n      this.tree_delete(delete_node);\n    }\n    return delete_node;\n  }\n\n  /**\r\n   * Returns array of entry values which keys intersect with given interval <br/>\r\n   * If no values stored in the tree, returns array of keys which intersect given interval\r\n   * @param {Interval} interval - search interval, or tuple [low, high]\r\n   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\r\n   * @returns {Array}\r\n   */\n  search(interval) {\n    let outputMapperFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (value, key) => value === key ? key.output() : value;\n    let search_node = new Node(interval);\n    let resp_nodes = [];\n    this.tree_search_interval(this.root, search_node, resp_nodes);\n    return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key));\n  }\n\n  /**\r\n   * Returns true if intersection between given and any interval stored in the tree found\r\n   * @param {Interval} interval - search interval or tuple [low, high]\r\n   * @returns {boolean}\r\n   */\n  intersect_any(interval) {\n    let search_node = new Node(interval);\n    let found = this.tree_find_any_interval(this.root, search_node);\n    return found;\n  }\n\n  /**\r\n   * Tree visitor. For each node implement a callback function. <br/>\r\n   * Method calls a callback function with two parameters (key, value)\r\n   * @param visitor(key,value) - function to be called for each tree item\r\n   */\n  forEach(visitor) {\n    this.tree_walk(this.root, node => visitor(node.item.key, node.item.value));\n  }\n\n  /** Value Mapper. Walk through every node and map node value to another value\r\n  * @param callback(value,key) - function to be called for each tree item\r\n  */\n  map(callback) {\n    const tree = new IntervalTree();\n    this.tree_walk(this.root, node => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n    return tree;\n  }\n  recalc_max(node) {\n    let node_current = node;\n    while (node_current.parent != null) {\n      node_current.parent.update_max();\n      node_current = node_current.parent;\n    }\n  }\n  tree_insert(insert_node) {\n    let current_node = this.root;\n    let parent_node = null;\n    if (this.root == null || this.root == this.nil_node) {\n      this.root = insert_node;\n    } else {\n      while (current_node != this.nil_node) {\n        parent_node = current_node;\n        if (insert_node.less_than(current_node)) {\n          current_node = current_node.left;\n        } else {\n          current_node = current_node.right;\n        }\n      }\n      insert_node.parent = parent_node;\n      if (insert_node.less_than(parent_node)) {\n        parent_node.left = insert_node;\n      } else {\n        parent_node.right = insert_node;\n      }\n    }\n    this.insert_fixup(insert_node);\n  }\n\n  // After insertion insert_node may have red-colored parent, and this is a single possible violation\n  // Go upwords to the root and re-color until violation will be resolved\n  insert_fixup(insert_node) {\n    let current_node;\n    let uncle_node;\n    current_node = insert_node;\n    while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\n      if (current_node.parent == current_node.parent.parent.left) {\n        // parent is left child of grandfather\n        uncle_node = current_node.parent.parent.right; // right brother of parent\n        if (uncle_node.color == RB_TREE_COLOR_RED) {\n          // Case 1. Uncle is red\n          // re-color father and uncle into black\n          current_node.parent.color = RB_TREE_COLOR_BLACK;\n          uncle_node.color = RB_TREE_COLOR_BLACK;\n          current_node.parent.parent.color = RB_TREE_COLOR_RED;\n          current_node = current_node.parent.parent;\n        } else {\n          // Case 2 & 3. Uncle is black\n          if (current_node == current_node.parent.right) {\n            // Case 2. Current if right child\n            // This case is transformed into Case 3.\n            current_node = current_node.parent;\n            this.rotate_left(current_node);\n          }\n          current_node.parent.color = RB_TREE_COLOR_BLACK; // Case 3. Current is left child.\n          // Re-color father and grandfather, rotate grandfather right\n          current_node.parent.parent.color = RB_TREE_COLOR_RED;\n          this.rotate_right(current_node.parent.parent);\n        }\n      } else {\n        // parent is right child of grandfather\n        uncle_node = current_node.parent.parent.left; // left brother of parent\n        if (uncle_node.color == RB_TREE_COLOR_RED) {\n          // Case 4. Uncle is red\n          // re-color father and uncle into black\n          current_node.parent.color = RB_TREE_COLOR_BLACK;\n          uncle_node.color = RB_TREE_COLOR_BLACK;\n          current_node.parent.parent.color = RB_TREE_COLOR_RED;\n          current_node = current_node.parent.parent;\n        } else {\n          if (current_node == current_node.parent.left) {\n            // Case 5. Current is left child\n            // Transform into case 6\n            current_node = current_node.parent;\n            this.rotate_right(current_node);\n          }\n          current_node.parent.color = RB_TREE_COLOR_BLACK; // Case 6. Current is right child.\n          // Re-color father and grandfather, rotate grandfather left\n          current_node.parent.parent.color = RB_TREE_COLOR_RED;\n          this.rotate_left(current_node.parent.parent);\n        }\n      }\n    }\n    this.root.color = RB_TREE_COLOR_BLACK;\n  }\n  tree_delete(delete_node) {\n    let cut_node; // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n    let fix_node; // node to fix rb tree property   (\"x\" from 14.4)\n\n    if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {\n      // delete_node has less then 2 children\n      cut_node = delete_node;\n    } else {\n      // delete_node has 2 children\n      cut_node = this.tree_successor(delete_node);\n    }\n\n    // fix_node if single child of cut_node\n    if (cut_node.left != this.nil_node) {\n      fix_node = cut_node.left;\n    } else {\n      fix_node = cut_node.right;\n    }\n\n    // remove cut_node from parent\n    /*if (fix_node != this.nil_node) {*/\n    fix_node.parent = cut_node.parent;\n    /*}*/\n\n    if (cut_node == this.root) {\n      this.root = fix_node;\n    } else {\n      if (cut_node == cut_node.parent.left) {\n        cut_node.parent.left = fix_node;\n      } else {\n        cut_node.parent.right = fix_node;\n      }\n      cut_node.parent.update_max(); // update max property of the parent\n    }\n    this.recalc_max(fix_node); // update max property upward from fix_node to root\n\n    // COPY DATA !!!\n    // Delete_node becomes cut_node, it means that we cannot hold reference\n    // to node in outer structure and we will have to delete by key, additional search need\n    if (cut_node != delete_node) {\n      delete_node.copy_data(cut_node);\n      delete_node.update_max(); // update max property of the cut node at the new place\n      this.recalc_max(delete_node); // update max property upward from delete_node to root\n    }\n    if ( /*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\n      this.delete_fixup(fix_node);\n    }\n  }\n  delete_fixup(fix_node) {\n    let current_node = fix_node;\n    let brother_node;\n    while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\n      if (current_node == current_node.parent.left) {\n        // fix node is left child\n        brother_node = current_node.parent.right;\n        if (brother_node.color == RB_TREE_COLOR_RED) {\n          // Case 1. Brother is red\n          brother_node.color = RB_TREE_COLOR_BLACK; // re-color brother\n          current_node.parent.color = RB_TREE_COLOR_RED; // re-color father\n          this.rotate_left(current_node.parent);\n          brother_node = current_node.parent.right; // update brother\n        }\n        // Derive to cases 2..4: brother is black\n        if (brother_node.left.color == RB_TREE_COLOR_BLACK && brother_node.right.color == RB_TREE_COLOR_BLACK) {\n          // case 2: both nephews black\n          brother_node.color = RB_TREE_COLOR_RED; // re-color brother\n          current_node = current_node.parent; // continue iteration\n        } else {\n          if (brother_node.right.color == RB_TREE_COLOR_BLACK) {\n            // case 3: left nephew red, right nephew black\n            brother_node.color = RB_TREE_COLOR_RED; // re-color brother\n            brother_node.left.color = RB_TREE_COLOR_BLACK; // re-color nephew\n            this.rotate_right(brother_node);\n            brother_node = current_node.parent.right; // update brother\n            // Derive to case 4: left nephew black, right nephew red\n          }\n          // case 4: left nephew black, right nephew red\n          brother_node.color = current_node.parent.color;\n          current_node.parent.color = RB_TREE_COLOR_BLACK;\n          brother_node.right.color = RB_TREE_COLOR_BLACK;\n          this.rotate_left(current_node.parent);\n          current_node = this.root; // exit from loop\n        }\n      } else {\n        // fix node is right child\n        brother_node = current_node.parent.left;\n        if (brother_node.color == RB_TREE_COLOR_RED) {\n          // Case 1. Brother is red\n          brother_node.color = RB_TREE_COLOR_BLACK; // re-color brother\n          current_node.parent.color = RB_TREE_COLOR_RED; // re-color father\n          this.rotate_right(current_node.parent);\n          brother_node = current_node.parent.left; // update brother\n        }\n        // Go to cases 2..4\n        if (brother_node.left.color == RB_TREE_COLOR_BLACK && brother_node.right.color == RB_TREE_COLOR_BLACK) {\n          // case 2\n          brother_node.color = RB_TREE_COLOR_RED; // re-color brother\n          current_node = current_node.parent; // continue iteration\n        } else {\n          if (brother_node.left.color == RB_TREE_COLOR_BLACK) {\n            // case 3: right nephew red, left nephew black\n            brother_node.color = RB_TREE_COLOR_RED; // re-color brother\n            brother_node.right.color = RB_TREE_COLOR_BLACK; // re-color nephew\n            this.rotate_left(brother_node);\n            brother_node = current_node.parent.left; // update brother\n            // Derive to case 4: right nephew black, left nephew red\n          }\n          // case 4: right nephew black, left nephew red\n          brother_node.color = current_node.parent.color;\n          current_node.parent.color = RB_TREE_COLOR_BLACK;\n          brother_node.left.color = RB_TREE_COLOR_BLACK;\n          this.rotate_right(current_node.parent);\n          current_node = this.root; // force exit from loop\n        }\n      }\n    }\n    current_node.color = RB_TREE_COLOR_BLACK;\n  }\n  tree_search(node, search_node) {\n    if (node == null || node == this.nil_node) return undefined;\n    if (search_node.equal_to(node)) {\n      return node;\n    }\n    if (search_node.less_than(node)) {\n      return this.tree_search(node.left, search_node);\n    } else {\n      return this.tree_search(node.right, search_node);\n    }\n  }\n\n  // Original search_interval method; container res support push() insertion\n  // Search all intervals intersecting given one\n  tree_search_interval(node, search_node, res) {\n    if (node != null && node != this.nil_node) {\n      // if (node->left != this.nil_node && node->left->max >= low) {\n      if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n        this.tree_search_interval(node.left, search_node, res);\n      }\n      // if (low <= node->high && node->low <= high) {\n      if (node.intersect(search_node)) {\n        res.push(node);\n      }\n      // if (node->right != this.nil_node && node->low <= high) {\n      if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n        this.tree_search_interval(node.right, search_node, res);\n      }\n    }\n  }\n  tree_find_any_interval(node, search_node) {\n    let found = false;\n    if (node != null && node != this.nil_node) {\n      // if (node->left != this.nil_node && node->left->max >= low) {\n      if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n        found = this.tree_find_any_interval(node.left, search_node);\n      }\n      // if (low <= node->high && node->low <= high) {\n      if (!found) {\n        found = node.intersect(search_node);\n      }\n      // if (node->right != this.nil_node && node->low <= high) {\n      if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n        found = this.tree_find_any_interval(node.right, search_node);\n      }\n    }\n    return found;\n  }\n  local_minimum(node) {\n    let node_min = node;\n    while (node_min.left != null && node_min.left != this.nil_node) {\n      node_min = node_min.left;\n    }\n    return node_min;\n  }\n\n  // not in use\n  local_maximum(node) {\n    let node_max = node;\n    while (node_max.right != null && node_max.right != this.nil_node) {\n      node_max = node_max.right;\n    }\n    return node_max;\n  }\n  tree_successor(node) {\n    let node_successor;\n    let current_node;\n    let parent_node;\n    if (node.right != this.nil_node) {\n      node_successor = this.local_minimum(node.right);\n    } else {\n      current_node = node;\n      parent_node = node.parent;\n      while (parent_node != null && parent_node.right == current_node) {\n        current_node = parent_node;\n        parent_node = parent_node.parent;\n      }\n      node_successor = parent_node;\n    }\n    return node_successor;\n  }\n\n  //           |            right-rotate(T,y)       |\n  //           y            ---------------.       x\n  //          / \\                                  / \\\n  //         x   c          left-rotate(T,x)      a   y\n  //        / \\             <---------------         / \\\n  //       a   b                                    b   c\n\n  rotate_left(x) {\n    let y = x.right;\n    x.right = y.left; // b goes to x.right\n\n    if (y.left != this.nil_node) {\n      y.left.parent = x; // x becomes parent of b\n    }\n    y.parent = x.parent; // move parent\n\n    if (x == this.root) {\n      this.root = y; // y becomes root\n    } else {\n      // y becomes child of x.parent\n      if (x == x.parent.left) {\n        x.parent.left = y;\n      } else {\n        x.parent.right = y;\n      }\n    }\n    y.left = x; // x becomes left child of y\n    x.parent = y; // and y becomes parent of x\n\n    if (x != null && x != this.nil_node) {\n      x.update_max();\n    }\n    y = x.parent;\n    if (y != null && y != this.nil_node) {\n      y.update_max();\n    }\n  }\n  rotate_right(y) {\n    let x = y.left;\n    y.left = x.right; // b goes to y.left\n\n    if (x.right != this.nil_node) {\n      x.right.parent = y; // y becomes parent of b\n    }\n    x.parent = y.parent; // move parent\n\n    if (y == this.root) {\n      // x becomes root\n      this.root = x;\n    } else {\n      // y becomes child of x.parent\n      if (y == y.parent.left) {\n        y.parent.left = x;\n      } else {\n        y.parent.right = x;\n      }\n    }\n    x.right = y; // y becomes right child of x\n    y.parent = x; // and x becomes parent of y\n\n    if (y != null && y != this.nil_node) {\n      y.update_max();\n    }\n    x = y.parent;\n    if (x != null && x != this.nil_node) {\n      x.update_max();\n    }\n  }\n  tree_walk(node, action) {\n    if (node != null && node != this.nil_node) {\n      this.tree_walk(node.left, action);\n      // arr.push(node.toArray());\n      action(node);\n      this.tree_walk(node.right, action);\n    }\n  }\n\n  /* Return true if all red nodes have exactly two black child nodes */\n  testRedBlackProperty() {\n    let res = true;\n    this.tree_walk(this.root, function (node) {\n      if (node.color == RB_TREE_COLOR_RED) {\n        if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\n          res = false;\n        }\n      }\n    });\n    return res;\n  }\n\n  /* Throw error if not every path from root to bottom has same black height */\n  testBlackHeightProperty(node) {\n    let height = 0;\n    let heightLeft = 0;\n    let heightRight = 0;\n    if (node.color == RB_TREE_COLOR_BLACK) {\n      height++;\n    }\n    if (node.left != this.nil_node) {\n      heightLeft = this.testBlackHeightProperty(node.left);\n    } else {\n      heightLeft = 1;\n    }\n    if (node.right != this.nil_node) {\n      heightRight = this.testBlackHeightProperty(node.right);\n    } else {\n      heightRight = 1;\n    }\n    if (heightLeft != heightRight) {\n      throw new Error('Red-black height property violated');\n    }\n    height += heightLeft;\n    return height;\n  }\n}\n\n/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\n\n/**\r\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n * Set properties and methods\r\n */\nclass PlanarSet extends Set {\n  /**\r\n   * Create new instance of PlanarSet\r\n   * @param shapes - array or set of geometric objects to store in planar set\r\n   * Each object should have a <b>box</b> property\r\n   */\n  constructor(shapes) {\n    super(shapes);\n    this.index = new IntervalTree();\n    this.forEach(shape => this.index.insert(shape));\n  }\n\n  /**\r\n   * Add new shape to planar set and to its spatial index.<br/>\r\n   * If shape already exist, it will not be added again.\r\n   * This happens with no error, it is possible to use <i>size</i> property to check if\r\n   * a shape was actually added.<br/>\r\n   * Method returns planar set object updated and may be chained\r\n   * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n   * @returns {PlanarSet}\r\n   */\n  add(shape) {\n    let size = this.size;\n    super.add(shape);\n    // size not changed - item not added, probably trying to add same item twice\n    if (this.size > size) {\n      let node = this.index.insert(shape.box, shape);\n    }\n    return this; // in accordance to Set.add interface\n  }\n\n  /**\r\n   * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n   * @param {Shape} shape - shape to be deleted\r\n   * @returns {boolean}\r\n   */\n  delete(shape) {\n    let deleted = super.delete(shape);\n    if (deleted) {\n      this.index.remove(shape.box, shape);\n    }\n    return deleted;\n  }\n\n  /**\r\n   * Clear planar set\r\n   */\n  clear() {\n    super.clear();\n    this.index = new IntervalTree();\n  }\n\n  /**\r\n   * 2d range search in planar set.<br/>\r\n   * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n   * @param {Box} box - query box\r\n   * @returns {Shapes[]}\r\n   */\n  search(box) {\n    let resp = this.index.search(box);\n    return resp;\n  }\n\n  /**\r\n   * Point location test. Returns array of shapes which contains given point\r\n   * @param {Point} point - query point\r\n   * @returns {Array}\r\n   */\n  hit(point) {\n    let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n    let resp = this.index.search(box);\n    return resp.filter(shape => point.on(shape));\n  }\n\n  /**\r\n   * Returns svg string to draw all shapes in planar set\r\n   * @returns {String}\r\n   */\n  svg() {\n    let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\n    return svgcontent;\n  }\n}\nFlatten.PlanarSet = PlanarSet;\n\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\n\n/**\r\n *\r\n * Class representing a point\r\n * @type {Point}\r\n */\nclass Point {\n  /**\r\n   * Point may be constructed by two numbers, or by array of two numbers\r\n   * @param {number} x - x-coordinate (float number)\r\n   * @param {number} y - y-coordinate (float number)\r\n   */\n  constructor() {\n    /**\r\n     * x-coordinate (float number)\r\n     * @type {number}\r\n     */\n    this.x = 0;\n    /**\r\n     * y-coordinate (float number)\r\n     * @type {number}\r\n     */\n    this.y = 0;\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    if (args.length === 0) {\n      return;\n    }\n    if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n      let arr = args[0];\n      if (typeof arr[0] == \"number\" && typeof arr[1] == \"number\") {\n        this.x = arr[0];\n        this.y = arr[1];\n        return;\n      }\n    }\n    if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\n      let {\n        x,\n        y\n      } = args[0];\n      this.x = x;\n      this.y = y;\n      return;\n    }\n    if (args.length === 2) {\n      if (typeof args[0] == \"number\" && typeof args[1] == \"number\") {\n        this.x = args[0];\n        this.y = args[1];\n        return;\n      }\n    }\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Returns bounding box of a point\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return new Flatten.Box(this.x, this.y, this.x, this.y);\n  }\n\n  /**\r\n   * Return new cloned instance of point\r\n   * @returns {Point}\r\n   */\n  clone() {\n    return new Flatten.Point(this.x, this.y);\n  }\n  get vertices() {\n    return [this.clone()];\n  }\n\n  /**\r\n   * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n   * @param {Point} pt Query point\r\n   * @returns {boolean}\r\n   */\n  equalTo(pt) {\n    return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\n  }\n\n  /**\r\n   * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n   * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\r\n   * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n   * @param {Point} pt Query point\r\n   * @returns {boolean}\r\n   */\n  lessThan(pt) {\n    if (Flatten.Utils.LT(this.y, pt.y)) return true;\n    if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x)) return true;\n    return false;\n  }\n\n  /**\r\n   * Returns new point rotated by given angle around given center point.\r\n   * If center point is omitted, rotates around zero point (0,0).\r\n   * Positive value of angle defines rotation in counter clockwise direction,\r\n   * negative angle defines rotation in clockwise clockwise direction\r\n   * @param {number} angle - angle in radians\r\n   * @param {Point} [center=(0,0)] center\r\n   * @returns {Point}\r\n   */\n  rotate(angle) {\n    let center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      x: 0,\n      y: 0\n    };\n    var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\n    var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\n    return new Flatten.Point(x_rot, y_rot);\n  }\n\n  /**\r\n   * Returns new point translated by given vector.\r\n   * Translation vector may by also defined by a pair of numbers.\r\n   * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n   * @param {number|number} - Translation vector defined as pair of numbers\r\n   * @returns {Point}\r\n   */\n  translate() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    if (args.length == 1 && (args[0] instanceof Flatten.Vector || !isNaN(args[0].x) && !isNaN(args[0].y))) {\n      return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\n    }\n    if (args.length == 2 && typeof args[0] == \"number\" && typeof args[1] == \"number\") {\n      return new Flatten.Point(this.x + args[0], this.y + args[1]);\n    }\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Return new point transformed by affine transformation matrix m\r\n   * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n   * @returns {Point}\r\n   */\n  transform(m) {\n    // let [x,y] = m.transform([this.x,this.y]);\n    return new Flatten.Point(m.transform([this.x, this.y]));\n  }\n\n  /**\r\n   * Returns projection point on given line\r\n   * @param {Line} line Line this point be projected on\r\n   * @returns {Point}\r\n   */\n  projectionOn(line) {\n    if (this.equalTo(line.pt))\n      // this point equal to line anchor point\n      return this.clone();\n    let vec = new Flatten.Vector(this, line.pt);\n    if (Flatten.Utils.EQ_0(vec.cross(line.norm)))\n      // vector to point from anchor point collinear to normal vector\n      return line.pt.clone();\n    let dist = vec.dot(line.norm); // signed distance\n    let proj_vec = line.norm.multiply(dist);\n    return this.translate(proj_vec);\n  }\n\n  /**\r\n   * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n   * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n   * @param {Line} line Query line\r\n   * @returns {boolean}\r\n   */\n  leftTo(line) {\n    let vec = new Flatten.Vector(line.pt, this);\n    let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\n    return onLeftSemiPlane;\n  }\n\n  /**\r\n   * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n   * @returns {number} distance from point to shape\r\n   * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n   */\n  distanceTo(shape) {\n    if (shape instanceof Point) {\n      let dx = shape.x - this.x;\n      let dy = shape.y - this.y;\n      return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\n    }\n    if (shape instanceof Flatten.Line) {\n      return Flatten.Distance.point2line(this, shape);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return Flatten.Distance.point2circle(this, shape);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return Flatten.Distance.point2segment(this, shape);\n    }\n    if (shape instanceof Flatten.Arc) {\n      // let [dist, ...rest] = Distance.point2arc(this, shape);\n      // return dist;\n      return Flatten.Distance.point2arc(this, shape);\n    }\n    if (shape instanceof Flatten.Polygon) {\n      // let [dist, ...rest] = Distance.point2polygon(this, shape);\n      // return dist;\n      return Flatten.Distance.point2polygon(this, shape);\n    }\n    if (shape instanceof Flatten.PlanarSet) {\n      return Flatten.Distance.shape2planarSet(this, shape);\n    }\n  }\n\n  /**\r\n   * Returns true if point is on a shape, false otherwise\r\n   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n   * @returns {boolean}\r\n   */\n  on(shape) {\n    if (shape instanceof Flatten.Point) {\n      return this.equalTo(shape);\n    }\n    if (shape instanceof Flatten.Line) {\n      return shape.contains(this);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return shape.contains(this);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return shape.contains(this);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return shape.contains(this);\n    }\n    if (shape instanceof Flatten.Polygon) {\n      return shape.contains(this);\n    }\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return Object.assign({}, this, {\n      name: \"point\"\n    });\n  }\n\n  /**\r\n   * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n   * Accept any valid attributes of svg elements as svg object\r\n   * Defaults attribues are: <br/>\r\n   * {\r\n   *    r:\"3\",\r\n   *    stroke:\"black\",\r\n   *    strokeWidth:\"1\",\r\n   *    fill:\"red\"\r\n   * }\r\n   * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n   * @returns {String}\r\n   */\n  svg() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      r,\n      stroke,\n      strokeWidth,\n      fill,\n      id,\n      className\n    } = attrs;\n    // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n    let id_str = id && id.length > 0 ? \"id=\\\"\".concat(id, \"\\\"\") : \"\";\n    let class_str = className && className.length > 0 ? \"class=\\\"\".concat(className, \"\\\"\") : \"\";\n    return \"\\n<circle cx=\\\"\".concat(this.x, \"\\\" cy=\\\"\").concat(this.y, \"\\\" r=\\\"\").concat(r || 3, \"\\\" stroke=\\\"\").concat(stroke || \"black\", \"\\\" stroke-width=\\\"\").concat(strokeWidth || 1, \"\\\" fill=\\\"\").concat(fill || \"red\", \"\\\" \").concat(id_str, \" \").concat(class_str, \" />\");\n  }\n}\nFlatten.Point = Point;\n/**\r\n * Function to create point equivalent to \"new\" constructor\r\n * @param args\r\n */\nconst point = function () {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n  return new Flatten.Point(...args);\n};\nFlatten.point = point;\n\n// export {Point};\n\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\n\n/**\r\n * Class representing a vector\r\n * @type {Vector}\r\n */\nclass Vector {\n  /**\r\n   * Vector may be constructed by two points, or by two float numbers,\r\n   * or by array of two numbers\r\n   * @param {Point} ps - start point\r\n   * @param {Point} pe - end point\r\n   */\n  constructor() {\n    /**\r\n     * x-coordinate of a vector (float number)\r\n     * @type {number}\r\n     */\n    this.x = 0;\n    /**\r\n     * y-coordinate of a vector (float number)\r\n     * @type {number}\r\n     */\n    this.y = 0;\n\n    /* return zero vector */\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    if (args.length === 0) {\n      return;\n    }\n    if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n      let arr = args[0];\n      if (typeof arr[0] == \"number\" && typeof arr[1] == \"number\") {\n        this.x = arr[0];\n        this.y = arr[1];\n        return;\n      }\n    }\n    if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\n      let {\n        x,\n        y\n      } = args[0];\n      this.x = x;\n      this.y = y;\n      return;\n    }\n    if (args.length === 2) {\n      let a1 = args[0];\n      let a2 = args[1];\n      if (typeof a1 == \"number\" && typeof a2 == \"number\") {\n        this.x = a1;\n        this.y = a2;\n        return;\n      }\n      if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n        this.x = a2.x - a1.x;\n        this.y = a2.y - a1.y;\n        return;\n      }\n    }\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Method clone returns new instance of Vector\r\n   * @returns {Vector}\r\n   */\n  clone() {\n    return new Flatten.Vector(this.x, this.y);\n  }\n\n  /**\r\n   * Slope of the vector in radians from 0 to 2PI\r\n   * @returns {number}\r\n   */\n  get slope() {\n    let angle = Math.atan2(this.y, this.x);\n    if (angle < 0) angle = 2 * Math.PI + angle;\n    return angle;\n  }\n\n  /**\r\n   * Length of vector\r\n   * @returns {number}\r\n   */\n  get length() {\n    return Math.sqrt(this.dot(this));\n  }\n\n  /**\r\n   * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\r\n   * tolerance\r\n   * @param {Vector} v\r\n   * @returns {boolean}\r\n   */\n  equalTo(v) {\n    return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\n  }\n\n  /**\r\n   * Returns new vector multiplied by scalar\r\n   * @param {number} scalar\r\n   * @returns {Vector}\r\n   */\n  multiply(scalar) {\n    return new Flatten.Vector(scalar * this.x, scalar * this.y);\n  }\n\n  /**\r\n   * Returns scalar product (dot product) of two vectors <br/>\r\n   * <code>dot_product = (this * v)</code>\r\n   * @param {Vector} v Other vector\r\n   * @returns {number}\r\n   */\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n\n  /**\r\n   * Returns vector product (cross product) of two vectors <br/>\r\n   * <code>cross_product = (this x v)</code>\r\n   * @param {Vector} v Other vector\r\n   * @returns {number}\r\n   */\n  cross(v) {\n    return this.x * v.y - this.y * v.x;\n  }\n\n  /**\r\n   * Returns unit vector.<br/>\r\n   * Throw error if given vector has zero length\r\n   * @returns {Vector}\r\n   */\n  normalize() {\n    if (!Flatten.Utils.EQ_0(this.length)) {\n      return new Flatten.Vector(this.x / this.length, this.y / this.length);\n    }\n    throw Flatten.Errors.ZERO_DIVISION;\n  }\n\n  /**\r\n   * Returns new vector rotated by given angle,\r\n   * positive angle defines rotation in counter clockwise direction,\r\n   * negative - in clockwise direction\r\n   * @param {number} angle - Angle in radians\r\n   * @returns {Vector}\r\n   */\n  rotate(angle) {\n    let point = new Flatten.Point(this.x, this.y);\n    let rpoint = point.rotate(angle);\n    return new Flatten.Vector(rpoint.x, rpoint.y);\n  }\n\n  /**\r\n   * Returns vector rotated 90 degrees counter clockwise\r\n   * @returns {Vector}\r\n   */\n  rotate90CCW() {\n    return new Flatten.Vector(-this.y, this.x);\n  }\n  /**\r\n   * Returns vector rotated 90 degrees clockwise\r\n   * @returns {Vector}\r\n   */\n  rotate90CW() {\n    return new Flatten.Vector(this.y, -this.x);\n  }\n  /**\r\n   * Return inverted vector\r\n   * @returns {Vector}\r\n   */\n  invert() {\n    return new Flatten.Vector(-this.x, -this.y);\n  }\n\n  /**\r\n   * Return result of addition of other vector to this vector as a new vector\r\n   * @param {Vector} v Other vector\r\n   * @returns {Vector}\r\n   */\n  add(v) {\n    return new Flatten.Vector(this.x + v.x, this.y + v.y);\n  }\n\n  /**\r\n   * Return result of subtraction of other vector from current vector as a new vector\r\n   * @param {Vector} v Another vector\r\n   * @returns {Vector}\r\n   */\n  subtract(v) {\n    return new Flatten.Vector(this.x - v.x, this.y - v.y);\n  }\n\n  /**\r\n   * Return angle between this vector and other vector. <br/>\r\n   * Angle is measured from 0 to 2*PI in the counter clockwise direction\r\n   * from current vector to other.\r\n   * @param {Vector} v Another vector\r\n   * @returns {number}\r\n   */\n  angleTo(v) {\n    let norm1 = this.normalize();\n    let norm2 = v.normalize();\n    let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\n    if (angle < 0) angle += 2 * Math.PI;\n    return angle;\n  }\n\n  /**\r\n   * Return vector projection of the current vector on another vector\r\n   * @param {Vector} v Another vector\r\n   * @returns {Vector}\r\n   */\n  projectionOn(v) {\n    let n = v.normalize();\n    let d = this.dot(n);\n    return n.multiply(d);\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return Object.assign({}, this, {\n      name: \"vector\"\n    });\n  }\n}\nFlatten.Vector = Vector;\n\n/**\r\n * Function to create vector equivalent to \"new\" constructor\r\n * @param args\r\n */\nconst vector = function () {\n  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    args[_key8] = arguments[_key8];\n  }\n  return new Flatten.Vector(...args);\n};\nFlatten.vector = vector;\n\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\n\n/**\r\n * Class representing a segment\r\n * @type {Segment}\r\n */\nclass Segment {\n  /**\r\n   *\r\n   * @param {Point} ps - start point\r\n   * @param {Point} pe - end point\r\n   */\n  constructor() {\n    /**\r\n     * Start point\r\n     * @type {Point}\r\n     */\n    this.ps = new Flatten.Point();\n    /**\r\n     * End Point\r\n     * @type {Point}\r\n     */\n    this.pe = new Flatten.Point();\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    if (args.length === 0) {\n      return;\n    }\n    if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\n      let coords = args[0];\n      this.ps = new Flatten.Point(coords[0], coords[1]);\n      this.pe = new Flatten.Point(coords[2], coords[3]);\n      return;\n    }\n    if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\n      let {\n        ps,\n        pe\n      } = args[0];\n      this.ps = new Flatten.Point(ps.x, ps.y);\n      this.pe = new Flatten.Point(pe.x, pe.y);\n      return;\n    }\n\n    // second point omitted issue #84\n    if (args.length === 1 && args[0] instanceof Flatten.Point) {\n      this.ps = args[0].clone();\n      return;\n    }\n    if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\n      this.ps = args[0].clone();\n      this.pe = args[1].clone();\n      return;\n    }\n    if (args.length === 4) {\n      this.ps = new Flatten.Point(args[0], args[1]);\n      this.pe = new Flatten.Point(args[2], args[3]);\n      return;\n    }\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Return new cloned instance of segment\r\n   * @returns {Segment}\r\n   */\n  clone() {\n    return new Flatten.Segment(this.start, this.end);\n  }\n\n  /**\r\n   * Start point\r\n   * @returns {Point}\r\n   */\n  get start() {\n    return this.ps;\n  }\n\n  /**\r\n   * End point\r\n   * @returns {Point}\r\n   */\n  get end() {\n    return this.pe;\n  }\n\n  /**\r\n   * Returns array of start and end point\r\n   * @returns [Point,Point]\r\n   */\n  get vertices() {\n    return [this.ps.clone(), this.pe.clone()];\n  }\n\n  /**\r\n   * Length of a segment\r\n   * @returns {number}\r\n   */\n  get length() {\n    return this.start.distanceTo(this.end)[0];\n  }\n\n  /**\r\n   * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n   * @returns {number}\r\n   */\n  get slope() {\n    let vec = new Flatten.Vector(this.start, this.end);\n    return vec.slope;\n  }\n\n  /**\r\n   * Bounding box\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return new Flatten.Box(Math.min(this.start.x, this.end.x), Math.min(this.start.y, this.end.y), Math.max(this.start.x, this.end.x), Math.max(this.start.y, this.end.y));\n  }\n\n  /**\r\n   * Returns true if equals to query segment, false otherwise\r\n   * @param {Seg} seg - query segment\r\n   * @returns {boolean}\r\n   */\n  equalTo(seg) {\n    return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\n  }\n\n  /**\r\n   * Returns true if segment contains point\r\n   * @param {Point} pt Query point\r\n   * @returns {boolean}\r\n   */\n  contains(pt) {\n    return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\n  }\n\n  /**\r\n   * Returns array of intersection points between segment and other shape\r\n   * @param {Shape} shape - Shape of the one of supported types <br/>\r\n   * @returns {Point[]}\r\n   */\n  intersect(shape) {\n    if (shape instanceof Flatten.Point) {\n      return this.contains(shape) ? [shape] : [];\n    }\n    if (shape instanceof Flatten.Line) {\n      return intersectSegment2Line(this, shape);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return intersectSegment2Segment(this, shape);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return intersectSegment2Circle(this, shape);\n    }\n    if (shape instanceof Flatten.Box) {\n      return intersectSegment2Box(this, shape);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return intersectSegment2Arc(this, shape);\n    }\n    if (shape instanceof Flatten.Polygon) {\n      return intersectSegment2Polygon(this, shape);\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n   * @returns {number} distance from segment to shape\r\n   * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\r\n   */\n  distanceTo(shape) {\n    if (shape instanceof Flatten.Point) {\n      let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Circle) {\n      let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Line) {\n      let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Segment) {\n      let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Arc) {\n      let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Polygon) {\n      let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.PlanarSet) {\n      let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n      return [dist, shortest_segment];\n    }\n  }\n\n  /**\r\n   * Returns unit vector in the direction from start to end\r\n   * @returns {Vector}\r\n   */\n  tangentInStart() {\n    let vec = new Flatten.Vector(this.start, this.end);\n    return vec.normalize();\n  }\n\n  /**\r\n   * Return unit vector in the direction from end to start\r\n   * @returns {Vector}\r\n   */\n  tangentInEnd() {\n    let vec = new Flatten.Vector(this.end, this.start);\n    return vec.normalize();\n  }\n\n  /**\r\n   * Returns new segment with swapped start and end points\r\n   * @returns {Segment}\r\n   */\n  reverse() {\n    return new Segment(this.end, this.start);\n  }\n\n  /**\r\n   * When point belongs to segment, return array of two segments split by given point,\r\n   * if point is inside segment. Returns clone of this segment if query point is incident\r\n   * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n   * @param {Point} pt Query point\r\n   * @returns {Segment[]}\r\n   */\n  split(pt) {\n    if (this.start.equalTo(pt)) return [null, this.clone()];\n    if (this.end.equalTo(pt)) return [this.clone(), null];\n    return [new Flatten.Segment(this.start, pt), new Flatten.Segment(pt, this.end)];\n  }\n\n  /**\r\n   * Return middle point of the segment\r\n   * @returns {Point}\r\n   */\n  middle() {\n    return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n  }\n  distanceToPoint(pt) {\n    let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\n    return dist;\n  }\n  definiteIntegral() {\n    let ymin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n    let dx = this.end.x - this.start.x;\n    let dy1 = this.start.y - ymin;\n    let dy2 = this.end.y - ymin;\n    return dx * (dy1 + dy2) / 2;\n  }\n\n  /**\r\n   * Returns new segment translated by vector vec\r\n   * @param {Vector} vec\r\n   * @returns {Segment}\r\n   */\n  translate() {\n    return new Segment(this.ps.translate(...arguments), this.pe.translate(...arguments));\n  }\n\n  /**\r\n   * Return new segment rotated by given angle around given point\r\n   * If point omitted, rotate around origin (0,0)\r\n   * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n   * @param {number} angle - rotation angle in radians\r\n   * @param {Point} center - center point, default is (0,0)\r\n   * @returns {Segment}\r\n   */\n  rotate() {\n    let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Flatten.Point();\n    let m = new Flatten.Matrix();\n    m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\n    return this.transform(m);\n  }\n\n  /**\r\n   * Return new segment transformed using affine transformation matrix\r\n   * @param {Matrix} matrix - affine transformation matrix\r\n   * @returns {Segment} - transformed segment\r\n   */\n  transform() {\n    let matrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Flatten.Matrix();\n    return new Segment(this.ps.transform(matrix), this.pe.transform(matrix));\n  }\n\n  /**\r\n   * Returns true if segment start is equal to segment end up to DP_TOL\r\n   * @returns {boolean}\r\n   */\n  isZeroLength() {\n    return this.ps.equalTo(this.pe);\n  }\n\n  /**\r\n   * Sort given array of points from segment start to end, assuming all points lay on the segment\r\n   * @param {Point[]} - array of points\r\n   * @returns {Point[]} new array sorted\r\n   */\n  sortPoints(pts) {\n    let line = new Flatten.Line(this.start, this.end);\n    return line.sortPoints(pts);\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return Object.assign({}, this, {\n      name: \"segment\"\n    });\n  }\n\n  /**\r\n   * Return string to draw segment in svg\r\n   * @param {Object} attrs - an object with attributes for svg path element,\r\n   * like \"stroke\", \"strokeWidth\" <br/>\r\n   * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n   * @returns {string}\r\n   */\n  svg() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      stroke,\n      strokeWidth,\n      id,\n      className\n    } = attrs;\n    // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n    let id_str = id && id.length > 0 ? \"id=\\\"\".concat(id, \"\\\"\") : \"\";\n    let class_str = className && className.length > 0 ? \"class=\\\"\".concat(className, \"\\\"\") : \"\";\n    return \"\\n<line x1=\\\"\".concat(this.start.x, \"\\\" y1=\\\"\").concat(this.start.y, \"\\\" x2=\\\"\").concat(this.end.x, \"\\\" y2=\\\"\").concat(this.end.y, \"\\\" stroke=\\\"\").concat(stroke || \"black\", \"\\\" stroke-width=\\\"\").concat(strokeWidth || 1, \"\\\" \").concat(id_str, \" \").concat(class_str, \" />\");\n  }\n}\nFlatten.Segment = Segment;\n/**\r\n * Shortcut method to create new segment\r\n */\nconst segment = function () {\n  for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    args[_key10] = arguments[_key10];\n  }\n  return new Flatten.Segment(...args);\n};\nFlatten.segment = segment;\n\n/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\n\nlet {\n  vector: vector$1\n} = Flatten;\n\n/**\r\n * Class representing a line\r\n * @type {Line}\r\n */\nclass Line {\n  /**\r\n   * Line may be constructed by point and normal vector or by two points that a line passes through\r\n   * @param {Point} pt - point that a line passes through\r\n   * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n   */\n  constructor() {\n    /**\r\n     * Point a line passes through\r\n     * @type {Point}\r\n     */\n    this.pt = new Flatten.Point();\n    /**\r\n     * Normal vector to a line <br/>\r\n     * Vector is normalized (length == 1)<br/>\r\n     * Direction of the vector is chosen to satisfy inequality norm * p >= 0\r\n     * @type {Vector}\r\n     */\n    this.norm = new Flatten.Vector(0, 1);\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n    if (args.length == 0) {\n      return;\n    }\n    if (args.length == 1 && args[0] instanceof Object && args[0].name === \"line\") {\n      let {\n        pt,\n        norm\n      } = args[0];\n      this.pt = new Flatten.Point(pt);\n      this.norm = new Flatten.Vector(norm);\n      return;\n    }\n    if (args.length == 2) {\n      let a1 = args[0];\n      let a2 = args[1];\n      if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n        this.pt = a1;\n        this.norm = Line.points2norm(a1, a2);\n        if (this.norm.dot(vector$1(this.pt.x, this.pt.y)) >= 0) {\n          this.norm.invert();\n        }\n        return;\n      }\n      if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\n        if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\n          throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n        this.pt = a1.clone();\n        this.norm = a2.clone();\n        this.norm = this.norm.normalize();\n        if (this.norm.dot(vector$1(this.pt.x, this.pt.y)) >= 0) {\n          this.norm.invert();\n        }\n        return;\n      }\n      if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\n        if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\n          throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n        this.pt = a2.clone();\n        this.norm = a1.clone();\n        this.norm = this.norm.normalize();\n        if (this.norm.dot(vector$1(this.pt.x, this.pt.y)) >= 0) {\n          this.norm.invert();\n        }\n        return;\n      }\n    }\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Return new cloned instance of line\r\n   * @returns {Line}\r\n   */\n  clone() {\n    return new Flatten.Line(this.pt, this.norm);\n  }\n\n  /* The following methods need for implementation of Edge interface\r\n  /**\r\n   * Line has no start point\r\n   * @returns {undefined}\r\n   */\n  get start() {\n    return undefined;\n  }\n\n  /**\r\n   * Line has no end point\r\n   */\n  get end() {\n    return undefined;\n  }\n\n  /**\r\n   * Return positive infinity number as length\r\n   * @returns {number}\r\n   */\n  get length() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  /**\r\n   * Returns infinite box\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return new Flatten.Box(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n  }\n\n  /**\r\n   * Middle point is undefined\r\n   * @returns {undefined}\r\n   */\n  get middle() {\n    return undefined;\n  }\n\n  /**\r\n   * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n   * @returns {number} - slope of the line\r\n   */\n  get slope() {\n    let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n    return vec.slope;\n  }\n\n  /**\r\n   * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n   * @code [A, B, C] = line.standard\r\n   * @returns {number[]} - array of coefficients\r\n   */\n  get standard() {\n    let A = this.norm.x;\n    let B = this.norm.y;\n    let C = this.norm.dot(this.pt);\n    return [A, B, C];\n  }\n\n  /**\r\n   * Return true if parallel or incident to other line\r\n   * @param {Line} other_line - line to check\r\n   * @returns {boolean}\r\n   */\n  parallelTo(other_line) {\n    return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\n  }\n\n  /**\r\n   * Returns true if incident to other line\r\n   * @param {Line} other_line - line to check\r\n   * @returns {boolean}\r\n   */\n  incidentTo(other_line) {\n    return this.parallelTo(other_line) && this.pt.on(other_line);\n  }\n\n  /**\r\n   * Returns true if point belongs to line\r\n   * @param {Point} pt Query point\r\n   * @returns {boolean}\r\n   */\n  contains(pt) {\n    if (this.pt.equalTo(pt)) {\n      return true;\n    }\n    /* Line contains point if vector to point is orthogonal to the line normal vector */\n    let vec = new Flatten.Vector(this.pt, pt);\n    return Flatten.Utils.EQ_0(this.norm.dot(vec));\n  }\n\n  /**\r\n   * Return coordinate of the point that lays on the line in the transformed\r\n   * coordinate system where center is the projection of the point(0,0) to\r\n   * the line and axe y is collinear to the normal vector. <br/>\r\n   * This method assumes that point lays on the line and does not check it\r\n   * @param {Point} pt - point on line\r\n   * @returns {number}\r\n   */\n  coord(pt) {\n    return vector$1(pt.x, pt.y).cross(this.norm);\n  }\n\n  /**\r\n   * Returns array of intersection points\r\n   * @param {Shape} shape - shape to intersect with\r\n   * @returns {Point[]}\r\n   */\n  intersect(shape) {\n    if (shape instanceof Flatten.Point) {\n      return this.contains(shape) ? [shape] : [];\n    }\n    if (shape instanceof Flatten.Line) {\n      return intersectLine2Line(this, shape);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return intersectLine2Circle(this, shape);\n    }\n    if (shape instanceof Flatten.Box) {\n      return intersectLine2Box(this, shape);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return intersectSegment2Line(shape, this);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return intersectLine2Arc(this, shape);\n    }\n    if (shape instanceof Flatten.Polygon) {\n      return intersectLine2Polygon(this, shape);\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n   * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n   * @returns {Number}\r\n   * @returns {Segment}\r\n   */\n  distanceTo(shape) {\n    if (shape instanceof Flatten.Point) {\n      let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.Circle) {\n      let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.Segment) {\n      let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\n      return [distance, shortest_segment.reverse()];\n    }\n    if (shape instanceof Flatten.Arc) {\n      let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\n      return [distance, shortest_segment.reverse()];\n    }\n    if (shape instanceof Flatten.Polygon) {\n      let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n      return [distance, shortest_segment];\n    }\n  }\n\n  /**\r\n   * Split line with array of points and return array of shapes\r\n   * Assumed that all points lay on the line\r\n   * @param {Point[]}\r\n   * @returns {Shape[]}\r\n   */\n  split(pt) {\n    if (pt instanceof Flatten.Point) {\n      return [new Flatten.Ray(pt, this.norm.invert()), new Flatten.Ray(pt, this.norm)];\n    } else {\n      let multiline = new Flatten.Multiline([this]);\n      let sorted_points = this.sortPoints(pt);\n      multiline.split(sorted_points);\n      return multiline.toShapes();\n    }\n  }\n\n  /**\r\n   * Sort given array of points that lay on line with respect to coordinate on a line\r\n   * The method assumes that points lay on the line and does not check this\r\n   * @param {Point[]} pts - array of points\r\n   * @returns {Point[]} new array sorted\r\n   */\n  sortPoints(pts) {\n    return pts.slice().sort((pt1, pt2) => {\n      if (this.coord(pt1) < this.coord(pt2)) {\n        return -1;\n      }\n      if (this.coord(pt1) > this.coord(pt2)) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return Object.assign({}, this, {\n      name: \"line\"\n    });\n  }\n\n  /**\r\n   * Return string to draw svg segment representing line inside given box\r\n   * @param {Box} box Box representing drawing area\r\n   * @param {Object} attrs - an object with attributes of svg circle element\r\n   */\n  svg(box) {\n    let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let ip = intersectLine2Box(this, box);\n    if (ip.length === 0) return \"\";\n    let ps = ip[0];\n    let pe = ip.length == 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\n    if (pe === undefined) pe = ps;\n    let segment = new Flatten.Segment(ps, pe);\n    return segment.svg(attrs);\n  }\n  static points2norm(pt1, pt2) {\n    if (pt1.equalTo(pt2)) {\n      throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n    let vec = new Flatten.Vector(pt1, pt2);\n    let unit = vec.normalize();\n    return unit.rotate90CCW();\n  }\n}\nFlatten.Line = Line;\n/**\r\n * Function to create line equivalent to \"new\" constructor\r\n * @param args\r\n */\nconst line = function () {\n  for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    args[_key12] = arguments[_key12];\n  }\n  return new Flatten.Line(...args);\n};\nFlatten.line = line;\n\n/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\n\n/**\r\n * Class representing a circle\r\n * @type {Circle}\r\n */\nclass Circle {\n  /**\r\n   *\r\n   * @param {Point} pc - circle center point\r\n   * @param {number} r - circle radius\r\n   */\n  constructor() {\n    /**\r\n     * Circle center\r\n     * @type {Point}\r\n     */\n    this.pc = new Flatten.Point();\n    /**\r\n     * Circle radius\r\n     * @type {number}\r\n     */\n    this.r = 1;\n    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      args[_key13] = arguments[_key13];\n    }\n    if (args.length == 1 && args[0] instanceof Object && args[0].name === \"circle\") {\n      let {\n        pc,\n        r\n      } = args[0];\n      this.pc = new Flatten.Point(pc);\n      this.r = r;\n      return;\n    } else {\n      let [pc, r] = [...args];\n      if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n      if (r !== undefined) this.r = r;\n      return;\n    }\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Return new cloned instance of circle\r\n   * @returns {Circle}\r\n   */\n  clone() {\n    return new Flatten.Circle(this.pc.clone(), this.r);\n  }\n\n  /**\r\n   * Circle center\r\n   * @returns {Point}\r\n   */\n  get center() {\n    return this.pc;\n  }\n\n  /**\r\n   * Circle bounding box\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return new Flatten.Box(this.pc.x - this.r, this.pc.y - this.r, this.pc.x + this.r, this.pc.y + this.r);\n  }\n\n  /**\r\n   * Return true if circle contains shape: no point of shape lies outside of the circle\r\n   * @param {Shape} shape - test shape\r\n   * @returns {boolean}\r\n   */\n  contains(shape) {\n    if (shape instanceof Flatten.Point) {\n      return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) && Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return this.intersect(shape).length === 0 && Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) && Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return this.intersect(shape).length === 0 && Flatten.Utils.LE(shape.r, this.r) && Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\n    }\n\n    /* TODO: box, polygon */\n  }\n\n  /**\r\n   * Transform circle to closed arc\r\n   * @param {boolean} counterclockwise\r\n   * @returns {Arc}\r\n   */\n  toArc() {\n    let counterclockwise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n  }\n\n  /**\r\n   * Returns array of intersection points between circle and other shape\r\n   * @param {Shape} shape Shape of the one of supported types\r\n   * @returns {Point[]}\r\n   */\n  intersect(shape) {\n    if (shape instanceof Flatten.Point) {\n      return this.contains(shape) ? [shape] : [];\n    }\n    if (shape instanceof Flatten.Line) {\n      return intersectLine2Circle(shape, this);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return intersectSegment2Circle(shape, this);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return intersectCircle2Circle(shape, this);\n    }\n    if (shape instanceof Flatten.Box) {\n      return intersectCircle2Box(this, shape);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return intersectArc2Circle(shape, this);\n    }\n    if (shape instanceof Flatten.Polygon) {\n      return intersectCircle2Polygon(this, shape);\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n   * @returns {number} distance from circle to shape\r\n   * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n     */\n  distanceTo(shape) {\n    if (shape instanceof Flatten.Point) {\n      let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.Circle) {\n      let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.Line) {\n      let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.Segment) {\n      let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.Arc) {\n      let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.Polygon) {\n      let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n      return [distance, shortest_segment];\n    }\n    if (shape instanceof Flatten.PlanarSet) {\n      let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n      return [dist, shortest_segment];\n    }\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return Object.assign({}, this, {\n      name: \"circle\"\n    });\n  }\n\n  /**\r\n   * Return string to draw circle in svg\r\n   * @param {Object} attrs - an object with attributes of svg circle element,\r\n   * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n   * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n   * @returns {string}\r\n   */\n  svg() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      stroke,\n      strokeWidth,\n      fill,\n      fillOpacity,\n      id,\n      className\n    } = attrs;\n    // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n    let id_str = id && id.length > 0 ? \"id=\\\"\".concat(id, \"\\\"\") : \"\";\n    let class_str = className && className.length > 0 ? \"class=\\\"\".concat(className, \"\\\"\") : \"\";\n    return \"\\n<circle cx=\\\"\".concat(this.pc.x, \"\\\" cy=\\\"\").concat(this.pc.y, \"\\\" r=\\\"\").concat(this.r, \"\\\" stroke=\\\"\").concat(stroke || \"black\", \"\\\" stroke-width=\\\"\").concat(strokeWidth || 1, \"\\\" fill=\\\"\").concat(fill || \"none\", \"\\\" fill-opacity=\\\"\").concat(fillOpacity || 1.0, \"\\\" \").concat(id_str, \" \").concat(class_str, \" />\");\n  }\n}\nFlatten.Circle = Circle;\n/**\r\n * Shortcut to create new circle\r\n * @param args\r\n */\nconst circle = function () {\n  for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n    args[_key14] = arguments[_key14];\n  }\n  return new Flatten.Circle(...args);\n};\nFlatten.circle = circle;\n\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\n\n/**\r\n * Class representing a circular arc\r\n * @type {Arc}\r\n */\nclass Arc {\n  /**\r\n   *\r\n   * @param {Point} pc - arc center\r\n   * @param {number} r - arc radius\r\n   * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n   * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n   * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counter clockwise\r\n   */\n  constructor() {\n    /**\r\n     * Arc center\r\n     * @type {Point}\r\n     */\n    this.pc = new Flatten.Point();\n    /**\r\n     * Arc radius\r\n     * @type {number}\r\n     */\n    this.r = 1;\n    /**\r\n     * Arc start angle in radians\r\n     * @type {number}\r\n     */\n    this.startAngle = 0;\n    /**\r\n     * Arc end angle in radians\r\n     * @type {number}\r\n     */\n    this.endAngle = 2 * Math.PI;\n    /**\r\n     * Arc orientation\r\n     * @type {boolean}\r\n     */\n    this.counterClockwise = Flatten.CCW;\n    for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n      args[_key15] = arguments[_key15];\n    }\n    if (args.length == 0) return;\n    if (args.length == 1 && args[0] instanceof Object && args[0].name === \"arc\") {\n      let {\n        pc,\n        r,\n        startAngle,\n        endAngle,\n        counterClockwise\n      } = args[0];\n      this.pc = new Flatten.Point(pc.x, pc.y);\n      this.r = r;\n      this.startAngle = startAngle;\n      this.endAngle = endAngle;\n      this.counterClockwise = counterClockwise;\n      return;\n    } else {\n      let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\n      if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n      if (r !== undefined) this.r = r;\n      if (startAngle !== undefined) this.startAngle = startAngle;\n      if (endAngle !== undefined) this.endAngle = endAngle;\n      if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\n      return;\n    }\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Return new cloned instance of arc\r\n   * @returns {Arc}\r\n   */\n  clone() {\n    return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\n  }\n\n  /**\r\n   * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n   * @returns {number}\r\n   */\n  get sweep() {\n    if (Flatten.Utils.EQ(this.startAngle, this.endAngle)) return 0.0;\n    if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\n      return Flatten.PIx2;\n    }\n    let sweep;\n    if (this.counterClockwise) {\n      sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ? this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\n    } else {\n      sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ? this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\n    }\n    if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\n      sweep -= Flatten.PIx2;\n    }\n    if (Flatten.Utils.LT(sweep, 0)) {\n      sweep += Flatten.PIx2;\n    }\n    return sweep;\n  }\n\n  /**\r\n   * Get start point of arc\r\n   * @returns {Point}\r\n   */\n  get start() {\n    let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n    return p0.rotate(this.startAngle, this.pc);\n  }\n\n  /**\r\n   * Get end point of arc\r\n   * @returns {Point}\r\n   */\n  get end() {\n    let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n    return p0.rotate(this.endAngle, this.pc);\n  }\n\n  /**\r\n   * Get center of arc\r\n   * @returns {Point}\r\n   */\n  get center() {\n    return this.pc.clone();\n  }\n  get vertices() {\n    return [this.start.clone(), this.end.clone()];\n  }\n\n  /**\r\n   * Get arc length\r\n   * @returns {number}\r\n   */\n  get length() {\n    return Math.abs(this.sweep * this.r);\n  }\n\n  /**\r\n   * Get bounding box of the arc\r\n   * @returns {Box}\r\n   */\n  get box() {\n    let func_arcs = this.breakToFunctional();\n    let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\n    box = box.merge(this.end.box);\n    return box;\n  }\n\n  /**\r\n   * Returns true if arc contains point, false otherwise\r\n   * @param {Point} pt - point to test\r\n   * @returns {boolean}\r\n   */\n  contains(pt) {\n    // first check if  point on circle (pc,r)\n    if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r)) return false;\n\n    // point on circle\n\n    if (pt.equalTo(this.start)) return true;\n    let angle = new Flatten.Vector(this.pc, pt).slope;\n    let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\n    return Flatten.Utils.LE(test_arc.length, this.length);\n  }\n\n  /**\r\n   * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n   * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n   * empty array.\r\n   * @param {Point} pt Query point\r\n   * @returns {Arc[]}\r\n   */\n  split(pt) {\n    if (this.start.equalTo(pt)) return [null, this.clone()];\n    if (this.end.equalTo(pt)) return [this.clone(), null];\n    let angle = new Flatten.Vector(this.pc, pt).slope;\n    return [new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise), new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)];\n  }\n\n  /**\r\n   * Return middle point of the arc\r\n   * @returns {Point}\r\n   */\n  middle() {\n    let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\n    let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n    return arc.end;\n  }\n\n  /**\r\n   * Returns chord height (\"sagitta\") of the arc\r\n   * @returns {number}\r\n   */\n  chordHeight() {\n    return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\n  }\n\n  /**\r\n   * Returns array of intersection points between arc and other shape\r\n   * @param {Shape} shape Shape of the one of supported types <br/>\r\n   * @returns {Points[]}\r\n   */\n  intersect(shape) {\n    if (shape instanceof Flatten.Point) {\n      return this.contains(shape) ? [shape] : [];\n    }\n    if (shape instanceof Flatten.Line) {\n      return intersectLine2Arc(shape, this);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return intersectArc2Circle(this, shape);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return intersectSegment2Arc(shape, this);\n    }\n    if (shape instanceof Flatten.Box) {\n      return intersectArc2Box(this, shape);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return intersectArc2Arc(this, shape);\n    }\n    if (shape instanceof Flatten.Polygon) {\n      return intersectArc2Polygon(this, shape);\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n   * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n   * @returns {number} distance from arc to shape\r\n   * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n     */\n  distanceTo(shape) {\n    if (shape instanceof Flatten.Point) {\n      let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Circle) {\n      let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Line) {\n      let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Segment) {\n      let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Arc) {\n      let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Polygon) {\n      let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.PlanarSet) {\n      let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n      return [dist, shortest_segment];\n    }\n  }\n\n  /**\r\n   * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n   * @returns {Arcs[]}\r\n   */\n  breakToFunctional() {\n    let func_arcs_array = [];\n    let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\n    let pts = [this.pc.translate(this.r, 0), this.pc.translate(0, this.r), this.pc.translate(-this.r, 0), this.pc.translate(0, -this.r)];\n\n    // If arc contains extreme point,\n    // create test arc started at start point and ended at this extreme point\n    let test_arcs = [];\n    for (let i = 0; i < 4; i++) {\n      if (pts[i].on(this)) {\n        test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\n      }\n    }\n    if (test_arcs.length == 0) {\n      // arc does contain any extreme point\n      func_arcs_array.push(this.clone());\n    } else {\n      // arc passes extreme point\n      // sort these arcs by length\n      test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\n      for (let i = 0; i < test_arcs.length; i++) {\n        let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n        let new_arc;\n        if (prev_arc) {\n          new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\n        } else {\n          new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\n        }\n        if (!Flatten.Utils.EQ_0(new_arc.length)) {\n          func_arcs_array.push(new_arc.clone());\n        }\n      }\n\n      // add last sub arc\n      let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n      let new_arc;\n      if (prev_arc) {\n        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\n      } else {\n        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\n      }\n      // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\n      if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2 * Math.PI)) {\n        func_arcs_array.push(new_arc.clone());\n      }\n    }\n    return func_arcs_array;\n  }\n\n  /**\r\n   * Return tangent unit vector in the start point in the direction from start to end\r\n   * @returns {Vector}\r\n   */\n  tangentInStart() {\n    let vec = new Flatten.Vector(this.pc, this.start);\n    let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\n    let tangent = vec.rotate(angle).normalize();\n    return tangent;\n  }\n\n  /**\r\n   * Return tangent unit vector in the end point in the direction from end to start\r\n   * @returns {Vector}\r\n   */\n  tangentInEnd() {\n    let vec = new Flatten.Vector(this.pc, this.end);\n    let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\n    let tangent = vec.rotate(angle).normalize();\n    return tangent;\n  }\n\n  /**\r\n   * Returns new arc with swapped start and end angles and reversed direction\r\n   * @returns {Arc}\r\n   */\n  reverse() {\n    return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\n  }\n\n  /**\r\n   * Returns new arc translated by vector vec\r\n   * @param {Vector} vec\r\n   * @returns {Segment}\r\n   */\n  translate() {\n    let arc = this.clone();\n    arc.pc = this.pc.translate(...arguments);\n    return arc;\n  }\n\n  /**\r\n   * Return new segment rotated by given angle around given point\r\n   * If point omitted, rotate around origin (0,0)\r\n   * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n   * @param {number} angle - rotation angle in radians\r\n   * @param {Point} center - center point, default is (0,0)\r\n   * @returns {Arc}\r\n   */\n  rotate() {\n    let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Flatten.Point();\n    let m = new Flatten.Matrix();\n    m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\n    return this.transform(m);\n  }\n\n  /**\r\n   * Return new arc scaled by scaleX, scaleY.\r\n   * @param {number} scaleX - scale value by X\r\n   * @param {number} scaleY - scale value by Y\r\n   * @returns {Arc}\r\n   */\n  scale() {\n    let scaleX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let m = new Flatten.Matrix();\n    m = m.scale(scaleX, scaleY);\n    return this.transform(m);\n  }\n\n  /**\r\n   * Return new arc transformed using affine transformation matrix <br/>\r\n   * Note 1. Non-equal scaling by x and y (abs(matrix[0]) != abs(matrix[3])) produce illegal result because\r\n   * it should create elliptic arc but this package does not support ellipses\r\n   * Note 2. Mirror transformation (matrix[0] * matrix[3] < 0) change direction of the arc to the opposite\r\n   * TODO: support non-equal scaling arc to ellipse or throw exception ?\r\n   * @param {Matrix} matrix - affine transformation matrix\r\n   * @returns {Arc}\r\n   */\n  transform() {\n    let matrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Flatten.Matrix();\n    let newStart = this.start.transform(matrix);\n    let newEnd = this.end.transform(matrix);\n    let newCenter = this.pc.transform(matrix);\n    let newDirection = this.counterClockwise;\n    if (matrix.a * matrix.d < 0) {\n      newDirection = !newDirection;\n    }\n    let arc = Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\n    return arc;\n  }\n  static arcSE(center, start, end, counterClockwise) {\n    let {\n      vector\n    } = Flatten;\n    let startAngle = vector(center, start).slope;\n    let endAngle = vector(center, end).slope;\n    if (Flatten.Utils.EQ(startAngle, endAngle)) {\n      endAngle += 2 * Math.PI;\n      counterClockwise = true;\n    }\n    let r = vector(center, start).length;\n    return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\n  }\n  definiteIntegral() {\n    let ymin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let f_arcs = this.breakToFunctional();\n    let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\n    return area;\n  }\n  circularSegmentDefiniteIntegral(ymin) {\n    let line = new Flatten.Line(this.start, this.end);\n    let onLeftSide = this.pc.leftTo(line);\n    let segment = new Flatten.Segment(this.start, this.end);\n    let areaTrapez = segment.definiteIntegral(ymin);\n    let areaCircularSegment = this.circularSegmentArea();\n    let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\n    return area;\n  }\n  circularSegmentArea() {\n    return 0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep));\n  }\n\n  /**\r\n   * Sort given array of points from arc start to end, assuming all points lay on the arc\r\n   * @param {Point[]} array of points\r\n   * @returns {Point[]} new array sorted\r\n   */\n  sortPoints(pts) {\n    let {\n      vector\n    } = Flatten;\n    return pts.slice().sort((pt1, pt2) => {\n      let slope1 = vector(this.pc, pt1).slope;\n      let slope2 = vector(this.pc, pt2).slope;\n      if (slope1 < slope2) {\n        return -1;\n      }\n      if (slope1 > slope2) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return Object.assign({}, this, {\n      name: \"arc\"\n    });\n  }\n\n  /**\r\n   * Return string to draw arc in svg\r\n   * @param {Object} attrs - an object with attributes of svg path element,\r\n   * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n   * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n   * @returns {string}\r\n   */\n  svg() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\n    let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\n    let {\n      stroke,\n      strokeWidth,\n      fill,\n      id,\n      className\n    } = attrs;\n    // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n    let id_str = id && id.length > 0 ? \"id=\\\"\".concat(id, \"\\\"\") : \"\";\n    let class_str = className && className.length > 0 ? \"class=\\\"\".concat(className, \"\\\"\") : \"\";\n    if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\n      let circle = new Flatten.Circle(this.pc, this.r);\n      return circle.svg(attrs);\n    } else {\n      return \"\\n<path d=\\\"M\".concat(this.start.x, \",\").concat(this.start.y, \"\\n                             A\").concat(this.r, \",\").concat(this.r, \" 0 \").concat(largeArcFlag, \",\").concat(sweepFlag, \" \").concat(this.end.x, \",\").concat(this.end.y, \"\\\"\\n                    stroke=\\\"\").concat(stroke || \"black\", \"\\\" stroke-width=\\\"\").concat(strokeWidth || 1, \"\\\" fill=\\\"\").concat(fill || \"none\", \"\\\" \").concat(id_str, \" \").concat(class_str, \" />\");\n    }\n  }\n}\nFlatten.Arc = Arc;\n/**\r\n * Function to create arc equivalent to \"new\" constructor\r\n * @param args\r\n */\nconst arc = function () {\n  for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n    args[_key16] = arguments[_key16];\n  }\n  return new Flatten.Arc(...args);\n};\nFlatten.arc = arc;\n\n/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\n\n/**\r\n * Class Box represent bounding box of the shape\r\n * @type {Box}\r\n */\nclass Box {\n  /**\r\n   *\r\n   * @param {number} xmin - minimal x coordinate\r\n   * @param {number} ymin - minimal y coordinate\r\n   * @param {number} xmax - maximal x coordinate\r\n   * @param {number} ymax - maximal y coordinate\r\n   */\n  constructor() {\n    let xmin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let ymin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let xmax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let ymax = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    /**\r\n     * Minimal x coordinate\r\n     * @type {number}\r\n     */\n    this.xmin = xmin;\n    /**\r\n     * Minimal y coordinate\r\n     * @type {number}\r\n     */\n    this.ymin = ymin;\n    /**\r\n     * Maximal x coordinate\r\n     * @type {number}\r\n     */\n    this.xmax = xmax;\n    /**\r\n     * Maximal y coordinate\r\n     * @type {number}\r\n     */\n    this.ymax = ymax;\n  }\n\n  /**\r\n   * Return new cloned instance of box\r\n   * @returns {Box}\r\n   */\n  clone() {\n    return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\n  }\n\n  /**\r\n   * Property low need for interval tree interface\r\n   * @returns {Point}\r\n   */\n  get low() {\n    return new Flatten.Point(this.xmin, this.ymin);\n  }\n\n  /**\r\n   * Property high need for interval tree interface\r\n   * @returns {Point}\r\n   */\n  get high() {\n    return new Flatten.Point(this.xmax, this.ymax);\n  }\n\n  /**\r\n   * Property max returns the box itself !\r\n   * @returns {Box}\r\n   */\n  get max() {\n    return this.clone();\n  }\n\n  /**\r\n   * Return center of the box\r\n   * @returns {Point}\r\n   */\n  get center() {\n    return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\n  }\n\n  /**\r\n   * Return property box like all other shapes\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return this.clone();\n  }\n\n  /**\r\n   * Returns true if not intersected with other box\r\n   * @param {Box} other_box - other box to test\r\n   * @returns {boolean}\r\n   */\n  not_intersect(other_box) {\n    return this.xmax < other_box.xmin || this.xmin > other_box.xmax || this.ymax < other_box.ymin || this.ymin > other_box.ymax;\n  }\n\n  /**\r\n   * Returns true if intersected with other box\r\n   * @param {Box} other_box - Query box\r\n   * @returns {boolean}\r\n   */\n  intersect(other_box) {\n    return !this.not_intersect(other_box);\n  }\n\n  /**\r\n   * Returns new box merged with other box\r\n   * @param {Box} other_box - Other box to merge with\r\n   * @returns {Box}\r\n   */\n  merge(other_box) {\n    return new Box(this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin), this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin), this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax), this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax));\n  }\n\n  /**\r\n   * Defines predicate \"less than\" between two boxes. Need for interval index\r\n   * @param {Box} other_box - other box\r\n   * @returns {boolean} - true if this box less than other box, false otherwise\r\n   */\n  less_than(other_box) {\n    if (this.low.lessThan(other_box.low)) return true;\n    if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high)) return true;\n    return false;\n  }\n\n  /**\r\n   * Returns true if this box is equal to other box, false otherwise\r\n   * @param {Box} other_box - query box\r\n   * @returns {boolean}\r\n   */\n  equal_to(other_box) {\n    return this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high);\n  }\n  output() {\n    return this.clone();\n  }\n  static comparable_max(box1, box2) {\n    // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\n    return box1.merge(box2);\n  }\n  static comparable_less_than(pt1, pt2) {\n    return pt1.lessThan(pt2);\n  }\n\n  /**\r\n   * Set new values to the box object\r\n   * @param {number} xmin - miminal x coordinate\r\n   * @param {number} ymin - minimal y coordinate\r\n   * @param {number} xmax - maximal x coordinate\r\n   * @param {number} ymax - maximal y coordinate\r\n   */\n  set(xmin, ymin, xmax, ymax) {\n    this.xmin = xmin;\n    this.ymin = ymin;\n    this.xmax = xmax;\n    this.ymax = ymax;\n  }\n\n  /**\r\n   * Transform box into array of points from low left corner in counter clockwise\r\n   * @returns {Point[]}\r\n   */\n  toPoints() {\n    return [new Flatten.Point(this.xmin, this.ymin), new Flatten.Point(this.xmax, this.ymin), new Flatten.Point(this.xmax, this.ymax), new Flatten.Point(this.xmin, this.ymax)];\n  }\n\n  /**\r\n   * Transform box into array of segments from low left corner in counter clockwise\r\n   * @returns {Segment[]}\r\n   */\n  toSegments() {\n    let pts = this.toPoints();\n    return [new Flatten.Segment(pts[0], pts[1]), new Flatten.Segment(pts[1], pts[2]), new Flatten.Segment(pts[2], pts[3]), new Flatten.Segment(pts[3], pts[0])];\n  }\n\n  /**\r\n   * Return string to draw circle in svg\r\n   * @param {Object} attrs - an object with attributes of svg rectangle element,\r\n   * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n   * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n   * @returns {string}\r\n   */\n  svg() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      stroke,\n      strokeWidth,\n      fill,\n      id,\n      className\n    } = attrs;\n    // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n    let id_str = id && id.length > 0 ? \"id=\\\"\".concat(id, \"\\\"\") : \"\";\n    let class_str = className && className.length > 0 ? \"class=\\\"\".concat(className, \"\\\"\") : \"\";\n    let width = this.xmax - this.xmin;\n    let height = this.ymax - this.ymin;\n    return \"\\n<rect x=\\\"\".concat(this.xmin, \"\\\" y=\\\"\").concat(this.ymin, \"\\\" width=\").concat(width, \" height=\").concat(height, \" stroke=\\\"\").concat(stroke || \"black\", \"\\\" stroke-width=\\\"\").concat(strokeWidth || 1, \"\\\" fill=\\\"\").concat(fill || \"none\", \"\\\" \").concat(id_str, \" \").concat(class_str, \" />\");\n  }\n}\nFlatten.Box = Box;\n/**\r\n * Shortcut to create new circle\r\n * @param args\r\n * @returns {Box}\r\n */\nconst box = function () {\n  for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n    args[_key17] = arguments[_key17];\n  }\n  return new Flatten.Box(...args);\n};\nFlatten.box = box;\n\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\n\n/**\r\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n * Each edge contains references to the next and previous edges in the face of the polygon.\r\n *\r\n * @type {Edge}\r\n */\nclass Edge {\n  /**\r\n   * Construct new instance of edge\r\n   * @param {Shape} shape Shape of type Segment or Arc\r\n   */\n  constructor(shape) {\n    /**\r\n     * Shape of the edge: Segment or Arc\r\n     * @type {Segment|Arc}\r\n     */\n    this.shape = shape;\n    /**\r\n     * Pointer to the next edge in the face\r\n     * @type {Edge}\r\n     */\n    this.next = undefined;\n    /**\r\n     * Pointer to the previous edge in the face\r\n     * @type {Edge}\r\n     */\n    this.prev = undefined;\n    /**\r\n     * Pointer to the face containing this edge\r\n     * @type {Face}\r\n     */\n    this.face = undefined;\n    /**\r\n     * \"Arc distance\" from the face start\r\n     * @type {number}\r\n     */\n    this.arc_length = 0;\n    /**\r\n     * Start inclusion flag (inside/outside/boundary)\r\n     * @type {*}\r\n     */\n    this.bvStart = undefined;\n    /**\r\n     * End inclusion flag (inside/outside/boundary)\r\n     * @type {*}\r\n     */\n    this.bvEnd = undefined;\n    /**\r\n     * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n     * @type {*}\r\n     */\n    this.bv = undefined;\n    /**\r\n     * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n     * @type {*}\r\n     */\n    this.overlap = undefined;\n  }\n\n  /**\r\n   * Get edge start point\r\n   */\n  get start() {\n    return this.shape.start;\n  }\n\n  /**\r\n   * Get edge end point\r\n   */\n  get end() {\n    return this.shape.end;\n  }\n\n  /**\r\n   * Get edge length\r\n   */\n  get length() {\n    return this.shape.length;\n  }\n\n  /**\r\n   * Get bounding box of the edge\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return this.shape.box;\n  }\n  isSegment() {\n    return this.shape instanceof Flatten.Segment;\n  }\n  isArc() {\n    return this.shape instanceof Flatten.Arc;\n  }\n\n  /**\r\n   * Get middle point of the edge\r\n   * @returns {Point}\r\n   */\n  middle() {\n    return this.shape.middle();\n  }\n\n  /**\r\n   * Returns true if point belongs to the edge, false otherwise\r\n   * @param {Point} pt - test point\r\n   */\n  contains(pt) {\n    return this.shape.contains(pt);\n  }\n\n  /**\r\n   * Set inclusion flag of the edge with respect to another polygon\r\n   * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n   * @param polygon\r\n   */\n  setInclusion(polygon) {\n    if (this.bv !== undefined) return this.bv;\n    if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\n      this.bv = Flatten.OUTSIDE;\n      return this.bv;\n    }\n    if (this.bvStart === undefined) {\n      this.bvStart = ray_shoot(polygon, this.start);\n    }\n    if (this.bvEnd === undefined) {\n      this.bvEnd = ray_shoot(polygon, this.end);\n    }\n    /* At least one end outside - the whole edge outside */\n    if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\n      this.bv = Flatten.OUTSIDE;\n    }\n    /* At least one end inside - the whole edge inside */else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\n      this.bv = Flatten.INSIDE;\n    }\n    /* Both are boundary - check the middle point */else {\n      let bvMiddle = ray_shoot(polygon, this.middle());\n      // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\n      // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\n      this.bv = bvMiddle;\n    }\n    return this.bv;\n  }\n\n  /**\r\n   * Set overlapping between two coincident boundary edges\r\n   * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n   * @param edge\r\n   */\n  setOverlap(edge) {\n    let flag = undefined;\n    let shape1 = this.shape;\n    let shape2 = edge.shape;\n    if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\n      if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\n        flag = Flatten.OVERLAP_SAME;\n      } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\n        flag = Flatten.OVERLAP_OPPOSITE;\n      }\n    } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\n      if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\n      shape1.middle().equalTo(shape2.middle())) {\n        flag = Flatten.OVERLAP_SAME;\n      } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\n      shape1.middle().equalTo(shape2.middle())) {\n        flag = Flatten.OVERLAP_OPPOSITE;\n      }\n    } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc || shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\n      if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\n        flag = Flatten.OVERLAP_SAME;\n      } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\n        flag = Flatten.OVERLAP_OPPOSITE;\n      }\n    }\n\n    /* Do not update overlap flag if already set on previous chain */\n    if (this.overlap === undefined) this.overlap = flag;\n    if (edge.overlap === undefined) edge.overlap = flag;\n  }\n  svg() {\n    if (this.shape instanceof Flatten.Segment) {\n      return \" L\".concat(this.shape.end.x, \",\").concat(this.shape.end.y);\n    } else if (this.shape instanceof Flatten.Arc) {\n      let arc = this.shape;\n      let largeArcFlag;\n      let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n\n      // Draw full circe arc as special case: split it into two half-circles\n      if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\n        let sign = arc.counterClockwise ? 1 : -1;\n        let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\n        let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\n        largeArcFlag = \"0\";\n        return \" A\".concat(halfArc1.r, \",\").concat(halfArc1.r, \" 0 \").concat(largeArcFlag, \",\").concat(sweepFlag, \" \").concat(halfArc1.end.x, \",\").concat(halfArc1.end.y, \"\\n                    A\").concat(halfArc2.r, \",\").concat(halfArc2.r, \" 0 \").concat(largeArcFlag, \",\").concat(sweepFlag, \" \").concat(halfArc2.end.x, \",\").concat(halfArc2.end.y);\n      } else {\n        largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n        return \" A\".concat(arc.r, \",\").concat(arc.r, \" 0 \").concat(largeArcFlag, \",\").concat(sweepFlag, \" \").concat(arc.end.x, \",\").concat(arc.end.y);\n      }\n    }\n  }\n  toJSON() {\n    return this.shape.toJSON();\n  }\n}\nFlatten.Edge = Edge;\n\n/**\r\n * Class implements circular bidirectional linked list <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\nclass CircularLinkedList extends LinkedList {\n  constructor(first, last) {\n    super(first, last);\n    this.setCircularLinks();\n  }\n  setCircularLinks() {\n    if (this.isEmpty()) return;\n    this.last.next = this.first;\n    this.first.prev = this.last;\n  }\n  [Symbol.iterator]() {\n    let element = undefined;\n    return {\n      next: () => {\n        let value = element ? element : this.first;\n        let done = this.first ? element ? element === this.first : false : true;\n        element = value ? value.next : undefined;\n        return {\n          value: value,\n          done: done\n        };\n      }\n    };\n  }\n  /**\r\n   * Append new element to the end of the list\r\n   * @param {LinkedListElement} element - new element to be appended\r\n   * @returns {CircularLinkedList}\r\n   */\n  append(element) {\n    super.append(element);\n    this.setCircularLinks();\n    return this;\n  }\n\n  /**\r\n   * Insert new element to the list after elementBefore\r\n   * @param {LinkedListElement} newElement - new element to be inserted\r\n   * @param {LinkedListElement} elementBefore - element in the list to insert after it\r\n   * @returns {CircularLinkedList}\r\n   */\n  insert(newElement, elementBefore) {\n    super.insert(newElement, elementBefore);\n    this.setCircularLinks();\n    return this;\n  }\n\n  /**\r\n   * Remove element from the list\r\n   * @param {LinkedListElement} element - element to be removed from the list\r\n   * @returns {CircularLinkedList}\r\n   */\n  remove(element) {\n    super.remove(element);\n    // this.setCircularLinks();\n    return this;\n  }\n}\n\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\n\n/**\r\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\r\n * Face object cannot be instantiated with a constructor.\r\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n * <br/>\r\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n * Container of edges is a property of the polygon object. <br/>\r\n *\r\n * @example\r\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n * for (let edge of face) {\r\n *      console.log(edge.shape.length)     // do something\r\n * }\r\n *\r\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n * let edge = face.first;\r\n * do {\r\n *   console.log(edge.shape.length);   // do something\r\n *   edge = edge.next;\r\n * } while (edge != face.first)\r\n */\nclass Face extends CircularLinkedList {\n  constructor(polygon) {\n    super(); // construct empty list of edges\n    /**\r\n     * Reference to the first edge in face\r\n     */\n    // this.first;\n    /**\r\n     * Reference to the last edge in face\r\n     */\n    // this.last;\n\n    this._box = undefined; // new Box();\n    this._orientation = undefined;\n    for (var _len18 = arguments.length, args = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n      args[_key18 - 1] = arguments[_key18];\n    }\n    if (args.length == 0) {\n      return;\n    }\n\n    /* If passed an array it supposed to be:\r\n     1) array of shapes that performs close loop or\r\n     2) array of points that performs set of vertices\r\n     */\n    if (args.length == 1) {\n      if (args[0] instanceof Array) {\n        // let argsArray = args[0];\n        let shapes = args[0]; // argsArray[0];\n        if (shapes.length == 0) return;\n\n        /* array of Flatten.Points */\n        if (shapes.every(shape => {\n          return shape instanceof Flatten.Point;\n        })) {\n          let segments = Face.points2segments(shapes);\n          this.shapes2face(polygon.edges, segments);\n        }\n        /* array of points as pairs of numbers */else if (shapes.every(shape => {\n          return shape instanceof Array && shape.length === 2;\n        })) {\n          let points = shapes.map(shape => new Flatten.Point(shape[0], shape[1]));\n          let segments = Face.points2segments(points);\n          this.shapes2face(polygon.edges, segments);\n        }\n        /* array of segments ot arcs */else if (shapes.every(shape => {\n          return shape instanceof Flatten.Segment || shape instanceof Flatten.Arc;\n        })) {\n          this.shapes2face(polygon.edges, shapes);\n        }\n        // this is from JSON.parse object\n        else if (shapes.every(shape => {\n          return shape.name === \"segment\" || shape.name === \"arc\";\n        })) {\n          let flattenShapes = [];\n          for (let shape of shapes) {\n            let flattenShape;\n            if (shape.name === \"segment\") {\n              flattenShape = new Flatten.Segment(shape);\n            } else {\n              flattenShape = new Flatten.Arc(shape);\n            }\n            flattenShapes.push(flattenShape);\n          }\n          this.shapes2face(polygon.edges, flattenShapes);\n        }\n      }\n      /* Create new face and copy edges into polygon.edges set */else if (args[0] instanceof Face) {\n        let face = args[0];\n        this.first = face.first;\n        this.last = face.last;\n        for (let edge of face) {\n          polygon.edges.add(edge);\n        }\n      }\n      /* Instantiate face from a circle in CCW orientation */else if (args[0] instanceof Flatten.Circle) {\n        this.shapes2face(polygon.edges, [args[0].toArc(Flatten.CCW)]);\n      }\n      /* Instantiate face from a box in CCW orientation */else if (args[0] instanceof Flatten.Box) {\n        let box = args[0];\n        this.shapes2face(polygon.edges, [new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)), new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)), new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)), new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))]);\n      }\n    }\n    /* If passed two edges, consider them as start and end of the face loop */\n    /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\n    /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\n    if (args.length == 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\n      this.first = args[0]; // first edge in face or undefined\n      this.last = args[1]; // last edge in face or undefined\n      this.last.next = this.first;\n      this.first.prev = this.last;\n\n      // set arc length\n      this.setArcLength();\n\n      // this.box = this.getBox();\n      // this.orientation = this.getOrientation();      // face direction cw or ccw\n    }\n  }\n\n  /**\r\n   * Return array of edges from first to last\r\n   * @returns {Array}\r\n   */\n  get edges() {\n    return this.toArray();\n  }\n\n  /**\r\n   * Return array of shapes which comprise face\r\n   * @returns {Array}\r\n   */\n  get shapes() {\n    return this.edges.map(edge => edge.shape.clone());\n  }\n\n  /**\r\n   * Return bounding box of the face\r\n   * @returns {Box}\r\n   */\n  get box() {\n    if (this._box === undefined) {\n      let box = new Flatten.Box();\n      for (let edge of this) {\n        box = box.merge(edge.box);\n      }\n      this._box = box;\n    }\n    return this._box;\n  }\n  static points2segments(points) {\n    let segments = [];\n    for (let i = 0; i < points.length; i++) {\n      // skip zero length segment\n      if (points[i].equalTo(points[(i + 1) % points.length])) continue;\n      segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\n    }\n    return segments;\n  }\n  shapes2face(edges, shapes) {\n    for (let shape of shapes) {\n      let edge = new Flatten.Edge(shape);\n      this.append(edge);\n      // this.box = this.box.merge(shape.box);\n      edges.add(edge);\n    }\n    // this.orientation = this.getOrientation();              // face direction cw or ccw\n  }\n\n  /**\r\n   * Append edge after the last edge of the face (and before the first edge). <br/>\r\n   * @param {Edge} edge - Edge to be appended to the linked list\r\n   * @returns {Face}\r\n   */\n  append(edge) {\n    super.append(edge);\n    // set arc length\n    this.setOneEdgeArcLength(edge);\n    edge.face = this;\n    // edges.add(edge);      // Add new edges into edges container\n    return this;\n  }\n\n  /**\r\n   * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n   * @param {Edge} newEdge - Edge to be inserted into linked list\r\n   * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n   * @returns {Face}\r\n   */\n  insert(newEdge, edgeBefore) {\n    super.insert(newEdge, edgeBefore);\n    // set arc length\n    this.setOneEdgeArcLength(newEdge);\n    newEdge.face = this;\n    return this;\n  }\n\n  /**\r\n   * Remove the given edge from the linked list of the face <br/>\r\n   * @param {Edge} edge - Edge to be removed\r\n   * @returns {Face}\r\n   */\n  remove(edge) {\n    super.remove(edge);\n    // Recalculate arc length\n    this.setArcLength();\n    return this;\n  }\n\n  /**\r\n   * Reverse orientation of the face: first edge become last and vice a verse,\r\n   * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\r\n   * clockwise, it becomes counter clockwise and vice versa\r\n   */\n  reverse() {\n    // collect edges in revert order with reverted shapes\n    let edges = [];\n    let edge_tmp = this.last;\n    do {\n      // reverse shape\n      edge_tmp.shape = edge_tmp.shape.reverse();\n      edges.push(edge_tmp);\n      edge_tmp = edge_tmp.prev;\n    } while (edge_tmp !== this.last);\n\n    // restore linked list\n    this.first = undefined;\n    this.last = undefined;\n    for (let edge of edges) {\n      if (this.first === undefined) {\n        edge.prev = edge;\n        edge.next = edge;\n        this.first = edge;\n        this.last = edge;\n      } else {\n        // append to end\n        edge.prev = this.last;\n        this.last.next = edge;\n\n        // update edge to be last\n        this.last = edge;\n\n        // restore circular links\n        this.last.next = this.first;\n        this.first.prev = this.last;\n      }\n      // set arc length\n      this.setOneEdgeArcLength(edge);\n    }\n\n    // Recalculate orientation, if set\n    if (this._orientation !== undefined) {\n      this._orientation = undefined;\n      this._orientation = this.orientation();\n    }\n  }\n\n  /**\r\n   * Set arc_length property for each of the edges in the face.\r\n   * Arc_length of the edge it the arc length from the first edge of the face\r\n   */\n  setArcLength() {\n    for (let edge of this) {\n      this.setOneEdgeArcLength(edge);\n      edge.face = this;\n    }\n  }\n  setOneEdgeArcLength(edge) {\n    if (edge === this.first) {\n      edge.arc_length = 0.0;\n    } else {\n      edge.arc_length = edge.prev.arc_length + edge.prev.length;\n    }\n  }\n\n  /**\r\n   * Returns the absolute value of the area of the face\r\n   * @returns {number}\r\n   */\n  area() {\n    return Math.abs(this.signedArea());\n  }\n\n  /**\r\n   * Returns signed area of the simple face.\r\n   * Face is simple if it has no self intersections that change its orientation.\r\n   * Then the area will be positive if the orientation of the face is clockwise,\r\n   * and negative if orientation is counterclockwise.\r\n   * It may be zero if polygon is degenerated.\r\n   * @returns {number}\r\n   */\n  signedArea() {\n    let sArea = 0;\n    let ymin = this.box.ymin;\n    for (let edge of this) {\n      sArea += edge.shape.definiteIntegral(ymin);\n    }\n    return sArea;\n  }\n\n  /**\r\n   * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n   * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n   * and the sign of the integral will be defined by the direction of the curve.\r\n   * When the integral (\"signed area\") will be negative, direction is counter clockwise,\r\n   * when positive - clockwise and when it is zero, polygon is not orientable.\r\n   * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n   * @returns {number}\r\n   */\n  orientation() {\n    if (this._orientation === undefined) {\n      let area = this.signedArea();\n      if (Flatten.Utils.EQ_0(area)) {\n        this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\n      } else if (Flatten.Utils.LT(area, 0)) {\n        this._orientation = Flatten.ORIENTATION.CCW;\n      } else {\n        this._orientation = Flatten.ORIENTATION.CW;\n      }\n    }\n    return this._orientation;\n  }\n\n  /**\r\n   * Returns true if face of the polygon is simple (no self-intersection points found)\r\n   * NOTE: this method is incomplete because it does not exclude touching points.\r\n   * Self intersection test should check if polygon change orientation in the test point.\r\n   * @param {Edges} edges - reference to polygon.edges to provide search index\r\n   * @returns {boolean}\r\n   */\n  isSimple(edges) {\n    let ip = Face.getSelfIntersections(this, edges, true);\n    return ip.length == 0;\n  }\n  static getSelfIntersections(face, edges) {\n    let exitOnFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let int_points = [];\n\n    // calculate intersections\n    for (let edge1 of face) {\n      // request edges of polygon in the box of edge1\n      let resp = edges.search(edge1.box);\n\n      // for each edge2 in response\n      for (let edge2 of resp) {\n        // Skip itself\n        if (edge1 === edge2) continue;\n\n        // Skip is edge2 belongs to another face\n        if (edge2.face !== face) continue;\n\n        // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\n        if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment && (edge1.next === edge2 || edge1.prev === edge2)) continue;\n\n        // calculate intersections between edge1 and edge2\n        let ip = edge1.shape.intersect(edge2.shape);\n\n        // for each intersection point\n        for (let pt of ip) {\n          // skip start-end connections\n          if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev) continue;\n          if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next) continue;\n          int_points.push(pt);\n          if (exitOnFirst) break;\n        }\n        if (int_points.length > 0 && exitOnFirst) break;\n      }\n      if (int_points.length > 0 && exitOnFirst) break;\n    }\n    return int_points;\n  }\n\n  /**\r\n   * Returns edge which contains given point\r\n   * @param {Point} pt - test point\r\n   * @returns {Edge}\r\n   */\n  findEdgeByPoint(pt) {\n    let edgeFound;\n    for (let edge of this) {\n      if (edge.shape.contains(pt)) {\n        edgeFound = edge;\n        break;\n      }\n    }\n    return edgeFound;\n  }\n\n  /**\r\n   * Returns new polygon created from one face\r\n   * @returns {Polygon}\r\n   */\n  toPolygon() {\n    return new Flatten.Polygon(this.shapes);\n  }\n  toJSON() {\n    return this.edges.map(edge => edge.toJSON());\n  }\n\n  /**\r\n   * Returns string to be assigned to \"d\" attribute inside defined \"path\"\r\n   * @returns {string}\r\n   */\n  svg() {\n    let svgStr = \"\\nM\".concat(this.first.start.x, \",\").concat(this.first.start.y);\n    for (let edge of this) {\n      svgStr += edge.svg();\n    }\n    svgStr += \" z\";\n    return svgStr;\n  }\n}\nFlatten.Face = Face;\n\n/**\r\n * Class representing a ray (a half-infinite line).\r\n * @type {Ray}\r\n */\nclass Ray {\n  /**\r\n   * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\r\n   * on a ray fit an equation: <br />\r\n   *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\r\n   * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\r\n   * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\r\n   * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\r\n   * @param {Point} pt - start point\r\n   * @param {Vector} norm - normal vector\r\n   */\n  constructor() {\n    this.pt = new Flatten.Point();\n    this.norm = new Flatten.Vector(0, 1);\n    for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n      args[_key19] = arguments[_key19];\n    }\n    if (args.length == 0) {\n      return;\n    }\n    if (args.length >= 1 && args[0] instanceof Flatten.Point) {\n      this.pt = args[0].clone();\n    }\n    if (args.length === 1) {\n      return;\n    }\n    if (args.length === 2 && args[1] instanceof Flatten.Vector) {\n      this.norm = args[1].clone();\n      return;\n    }\n\n    // if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n    //     this.pt = new Flatten.Point(args[0], args[1]);\n    //     return;\n    // }\n\n    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n  }\n\n  /**\r\n   * Return new cloned instance of ray\r\n   * @returns {Ray}\r\n   */\n  clone() {\n    return new Ray(this.pt, this.norm);\n  }\n\n  /**\r\n   * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\r\n   * @returns {number} - slope of the line\r\n   */\n  get slope() {\n    let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n    return vec.slope;\n  }\n\n  /**\r\n   * Returns half-infinite bounding box of the ray\r\n   * @returns {Box} - bounding box\r\n   */\n  get box() {\n    let slope = this.slope;\n    return new Flatten.Box(slope > Math.PI / 2 && slope < 3 * Math.PI / 2 ? Number.NEGATIVE_INFINITY : this.pt.x, slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY, slope >= Math.PI / 2 && slope <= 3 * Math.PI / 2 ? this.pt.x : Number.POSITIVE_INFINITY, slope >= Math.PI && slope <= 2 * Math.PI || slope == 0 ? this.pt.y : Number.POSITIVE_INFINITY);\n  }\n\n  /**\r\n   * Return ray start point\r\n   * @returns {Point} - ray start point\r\n   */\n  get start() {\n    return this.pt;\n  }\n\n  /**\r\n   * Ray has no end point?\r\n   * @returns {undefined}\r\n   */\n  get end() {\n    return undefined;\n  }\n\n  /**\r\n   * Return positive infinity number as length\r\n   * @returns {number}\r\n   */\n  get length() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  /**\r\n   * Returns true if point belongs to ray\r\n   * @param {Point} pt Query point\r\n   * @returns {boolean}\r\n   */\n  contains(pt) {\n    if (this.pt.equalTo(pt)) {\n      return true;\n    }\n    /* Ray contains point if vector to point is orthogonal to the ray normal vector\r\n        and cross product from vector to point is positive */\n    let vec = new Flatten.Vector(this.pt, pt);\n    return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm), 0);\n  }\n\n  /**\r\n   * Split ray with point and return array of segment and new ray\r\n   * @param {Point} pt\r\n   * @returns [Segment,Ray]\r\n   */\n  split(pt) {\n    if (!this.contains(pt)) return [];\n    if (this.pt.equalTo(pt)) {\n      return [this];\n    }\n    return [new Flatten.Segment(this.pt, pt), new Flatten.Ray(pt, this.norm)];\n  }\n\n  /**\r\n   * Returns array of intersection points between ray and segment or arc\r\n   * @param {Segment|Arc} - Shape to intersect with ray\r\n   * @returns {Array} array of intersection points\r\n   */\n  intersect(shape) {\n    if (shape instanceof Flatten.Segment) {\n      return this.intersectRay2Segment(this, shape);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return this.intersectRay2Arc(this, shape);\n    }\n  }\n  intersectRay2Segment(ray, segment) {\n    let ip = [];\n\n    // if (ray.box.not_intersect(segment.box)) {\n    //     return ip;\n    // }\n\n    let line = new Flatten.Line(ray.start, ray.norm);\n    let ip_tmp = line.intersect(segment);\n    for (let pt of ip_tmp) {\n      // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n      if (ray.contains(pt)) {\n        ip.push(pt);\n      }\n    }\n\n    /* If there were two intersection points between line and ray,\r\n    and now there is exactly one left, it means ray starts between these points\r\n    and there is another intersection point - start of the ray */\n    if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\n      ip.push(ray.start);\n    }\n    return ip;\n  }\n  intersectRay2Arc(ray, arc) {\n    let ip = [];\n\n    // if (ray.box.not_intersect(arc.box)) {\n    //     return ip;\n    // }\n\n    let line = new Flatten.Line(ray.start, ray.norm);\n    let ip_tmp = line.intersect(arc);\n    for (let pt of ip_tmp) {\n      // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n      if (ray.contains(pt)) {\n        ip.push(pt);\n      }\n    }\n    return ip;\n  }\n\n  /**\r\n   * Return string to draw svg segment representing ray inside given box\r\n   * @param {Box} box Box representing drawing area\r\n   * @param {Object} attrs - an object with attributes of svg segment element\r\n   */\n  svg(box) {\n    let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let line = new Flatten.Line(this.pt, this.norm);\n    let ip = intersectLine2Box(line, box);\n    ip = ip.filter(pt => this.contains(pt));\n    if (ip.length === 0 || ip.length === 2) return \"\";\n    let segment = new Flatten.Segment(this.pt, ip[0]);\n    return segment.svg(attrs);\n  }\n}\nFlatten.Ray = Ray;\nconst ray = function () {\n  for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n    args[_key20] = arguments[_key20];\n  }\n  return new Flatten.Ray(...args);\n};\nFlatten.ray = ray;\n\n/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\n\n/**\r\n * Class representing a polygon.<br/>\r\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n * @type {Polygon}\r\n */\nclass Polygon {\n  /**\r\n   * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\r\n   * Constructor accepts as argument array that define loop of shapes\r\n   * or array of arrays in case of multi polygon <br/>\r\n   * Loop may be defined in different ways: <br/>\r\n   * - array of shapes of type Segment or Arc <br/>\r\n   * - array of points (Flatten.Point) <br/>\r\n   * - array of numeric pairs which represent points <br/>\r\n   * - box or circle object <br/>\r\n   * Alternatively, it is possible to use polygon.addFace method\r\n   * @param {args} - array of shapes or array of arrays\r\n   */\n  constructor() {\n    /**\r\n     * Container of faces (closed loops), may be empty\r\n     * @type {PlanarSet}\r\n     */\n    this.faces = new Flatten.PlanarSet();\n    /**\r\n     * Container of edges\r\n     * @type {PlanarSet}\r\n     */\n    this.edges = new Flatten.PlanarSet();\n\n    /* It may be array of something that may represent one loop (face) or\r\n     array of arrays that represent multiple loops\r\n     */\n    let args = [...arguments];\n    if (args.length === 1 && (args[0] instanceof Array && args[0].length > 0 || args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\n      let argsArray = args[0];\n      if (args[0] instanceof Array && args[0].every(loop => {\n        return loop instanceof Array;\n      })) {\n        if (argsArray.every(el => {\n          return el instanceof Array && el.length === 2 && typeof el[0] === \"number\" && typeof el[1] === \"number\";\n        })) {\n          this.faces.add(new Flatten.Face(this, argsArray)); // one-loop polygon as array of pairs of numbers\n        } else {\n          for (let loop of argsArray) {\n            // multi-loop polygon\n            /* Check extra level of nesting for GeoJSON-style multi polygons */\n            if (loop instanceof Array && loop[0] instanceof Array && loop[0].every(el => {\n              return el instanceof Array && el.length === 2 && typeof el[0] === \"number\" && typeof el[1] === \"number\";\n            })) {\n              for (let loop1 of loop) {\n                this.faces.add(new Flatten.Face(this, loop1));\n              }\n            } else {\n              this.faces.add(new Flatten.Face(this, loop));\n            }\n          }\n        }\n      } else {\n        this.faces.add(new Flatten.Face(this, argsArray)); // one-loop polygon\n      }\n    }\n  }\n\n  /**\r\n   * (Getter) Returns bounding box of the polygon\r\n   * @returns {Box}\r\n   */\n  get box() {\n    return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\n  }\n\n  /**\r\n   * (Getter) Returns array of vertices\r\n   * @returns {Array}\r\n   */\n  get vertices() {\n    return [...this.edges].map(edge => edge.start);\n  }\n\n  /**\r\n   * Create new cloned instance of the polygon\r\n   * @returns {Polygon}\r\n   */\n  clone() {\n    let polygon = new Polygon();\n    for (let face of this.faces) {\n      polygon.addFace(face.shapes);\n    }\n    return polygon;\n  }\n\n  /**\r\n   * Return true is polygon has no edges\r\n   * @returns {boolean}\r\n   */\n  isEmpty() {\n    return this.edges.size === 0;\n  }\n\n  /**\r\n   * Return true if polygon is valid for boolean operations\r\n   * Polygon is valid if <br/>\r\n   * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n   * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n   * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n   * @returns {boolean}\r\n   */\n  isValid() {\n    let valid = true;\n    // 1. Polygon is invalid if at least one face is not simple\n    for (let face of this.faces) {\n      if (!face.isSimple(this.edges)) {\n        valid = false;\n        break;\n      }\n    }\n    // 2. TODO: check if no island inside island and no hole inside hole\n    // 3. TODO: check the there is no intersection between faces\n    return valid;\n  }\n\n  /**\r\n   * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n   * @returns {number}\r\n   */\n  area() {\n    let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\n    return Math.abs(signedArea);\n  }\n\n  /**\r\n   * Add new face to polygon. Returns added face\r\n   * @param {Points[]|Segments[]|Arcs[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\r\n   * 1) array of points that describe closed path (edges are segments) <br/>\r\n   * 2) array of shapes (segments and arcs) which describe closed path <br/>\r\n   * 3) circle - will be added as counterclockwise arc <br/>\r\n   * 4) box - will be added as counterclockwise rectangle <br/>\r\n   * You can chain method face.reverse() is you need to change direction of the creates face\r\n   * @returns {Face}\r\n   */\n  addFace() {\n    for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n      args[_key21] = arguments[_key21];\n    }\n    let face = new Flatten.Face(this, ...args);\n    this.faces.add(face);\n    return face;\n  }\n\n  /**\r\n   * Delete existing face from polygon\r\n   * @param {Face} face Face to be deleted\r\n   * @returns {boolean}\r\n   */\n  deleteFace(face) {\n    for (let edge of face) {\n      let deleted = this.edges.delete(edge);\n    }\n    let deleted = this.faces.delete(face);\n    return deleted;\n  }\n\n  /**\r\n   * Delete chain of edges from the face.\r\n   * @param {Face} face Face to remove chain\r\n   * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n   * @param {Edge} edgeTo End of the chain of edges to be removed\r\n   */\n  removeChain(face, edgeFrom, edgeTo) {\n    // Special case: all edges removed\n    if (edgeTo.next === edgeFrom) {\n      this.deleteFace(face);\n      return;\n    }\n    for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n      face.remove(edge);\n      this.edges.delete(edge); // delete from PlanarSet of edges and update index\n      if (face.isEmpty()) {\n        this.deleteFace(face); // delete from PlanarSet of faces and update index\n        break;\n      }\n    }\n  }\n\n  /**\r\n   * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n   * When edge is split, new edge created from the start of the edge to the new vertex\r\n   * and inserted before current edge.\r\n   * Current edge is trimmed and updated.\r\n   * Method returns new edge added. If no edge added, it returns edge before vertex\r\n   * @param {Point} pt Point to be added as a new vertex\r\n   * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n   * @returns {Edge}\r\n   */\n  addVertex(pt, edge) {\n    let shapes = edge.shape.split(pt);\n    // if (shapes.length < 2) return;\n\n    if (shapes[0] === null)\n      // point incident to edge start vertex, return previous edge\n      return edge.prev;\n    if (shapes[1] === null)\n      // point incident to edge end vertex, return edge itself\n      return edge;\n    let newEdge = new Flatten.Edge(shapes[0]);\n    let edgeBefore = edge.prev;\n\n    /* Insert first split edge into linked list after edgeBefore */\n    edge.face.insert(newEdge, edgeBefore);\n\n    // Remove old edge from edges container and 2d index\n    this.edges.delete(edge);\n\n    // Insert new edge to the edges container and 2d index\n    this.edges.add(newEdge);\n\n    // Update edge shape with second split edge keeping links\n    edge.shape = shapes[1];\n\n    // Add updated edge to the edges container and 2d index\n    this.edges.add(edge);\n    return newEdge;\n  }\n\n  /**\r\n   * Cut polygon with multiline and return array of new polygons\r\n   * Multiline should be constructed from a line with intersection point, see notebook:\r\n   * https://next.observablehq.com/@alexbol99/cut-polygon-with-line\r\n   * @param {Multiline} multiline\r\n   * @returns {Polygon[]}\r\n   */\n  cut(multiline) {\n    let cutPolygons = [this.clone()];\n    for (let edge of multiline) {\n      if (edge.setInclusion(this) !== Flatten.INSIDE) continue;\n      let cut_edge_start = edge.shape.start;\n      let cut_edge_end = edge.shape.end;\n      let newCutPolygons = [];\n      for (let polygon of cutPolygons) {\n        if (polygon.findEdgeByPoint(cut_edge_start) === undefined) {\n          newCutPolygons.push(polygon);\n        } else {\n          let [cutPoly1, cutPoly2] = polygon.cutFace(cut_edge_start, cut_edge_end);\n          newCutPolygons.push(cutPoly1, cutPoly2);\n        }\n      }\n      cutPolygons = newCutPolygons;\n    }\n    return cutPolygons;\n  }\n\n  /**\r\n   * Cut face of polygon with a segment between two points and create two new polygons\r\n   * Supposed that a segments between points does not intersect any other edge\r\n   * @param {Point} pt1\r\n   * @param {Point} pt2\r\n   * @returns {Polygon[]}\r\n   */\n  cutFace(pt1, pt2) {\n    let edge1 = this.findEdgeByPoint(pt1);\n    let edge2 = this.findEdgeByPoint(pt2);\n    if (edge1.face != edge2.face) return;\n\n    // Cut face into two and create new polygon with two faces\n    let edgeBefore1 = this.addVertex(pt1, edge1);\n    edge2 = this.findEdgeByPoint(pt2);\n    let edgeBefore2 = this.addVertex(pt2, edge2);\n    let face = edgeBefore1.face;\n    let newEdge1 = new Flatten.Edge(new Flatten.Segment(edgeBefore1.end, edgeBefore2.end));\n    let newEdge2 = new Flatten.Edge(new Flatten.Segment(edgeBefore2.end, edgeBefore1.end));\n\n    // Swap links\n    edgeBefore1.next.prev = newEdge2;\n    newEdge2.next = edgeBefore1.next;\n    edgeBefore1.next = newEdge1;\n    newEdge1.prev = edgeBefore1;\n    edgeBefore2.next.prev = newEdge1;\n    newEdge1.next = edgeBefore2.next;\n    edgeBefore2.next = newEdge2;\n    newEdge2.prev = edgeBefore2;\n\n    // Insert new edge to the edges container and 2d index\n    this.edges.add(newEdge1);\n    this.edges.add(newEdge2);\n\n    // Add two new faces\n    let face1 = this.addFace(newEdge1, edgeBefore1);\n    let face2 = this.addFace(newEdge2, edgeBefore2);\n\n    // Remove old face\n    this.faces.delete(face);\n    return [face1.toPolygon(), face2.toPolygon()];\n  }\n\n  /**\r\n   * Returns the first founded edge of polygon that contains given point\r\n   * @param {Point} pt\r\n   * @returns {Edge}\r\n   */\n  findEdgeByPoint(pt) {\n    let edge;\n    for (let face of this.faces) {\n      edge = face.findEdgeByPoint(pt);\n      if (edge != undefined) break;\n    }\n    return edge;\n  }\n\n  /**\r\n   * Split polygon into array of polygons, where each polygon is an island with all\r\n   * hole that it contains\r\n   * @returns {Flatten.Polygon[]}\r\n   */\n  splitToIslands() {\n    let polygons = this.toArray(); // split into array of one-loop polygons\n    /* Sort polygons by area in descending order */\n    polygons.sort((polygon1, polygon2) => polygon2.area() - polygon1.area());\n    /* define orientation of the island by orientation of the first polygon in array */\n    let orientation = [...polygons[0].faces][0].orientation();\n    /* Create output array from polygons with same orientation as a first polygon (array of islands) */\n    let newPolygons = polygons.filter(polygon => [...polygon.faces][0].orientation() === orientation);\n    for (let polygon of polygons) {\n      let face = [...polygon.faces][0];\n      if (face.orientation() === orientation) continue; // skip same orientation\n      /* Proceed with opposite orientation */\n      /* Look if any of island polygons contains tested polygon as a hole */\n      for (let islandPolygon of newPolygons) {\n        if (face.shapes.every(shape => islandPolygon.contains(shape))) {\n          islandPolygon.addFace(face.shapes); // add polygon as a hole in islandPolygon\n          break;\n        }\n      }\n    }\n    // TODO: assert if not all polygons added into output\n    return newPolygons;\n  }\n\n  /**\r\n   * Reverse orientation of all faces to opposite\r\n   * @returns {Polygon}\r\n   */\n  reverse() {\n    for (let face of this.faces) {\n      face.reverse();\n    }\n    return this;\n  }\n\n  /**\r\n   * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\r\n   * false otherwise\r\n   * @param {Shape} shape - test shape\r\n   * @returns {boolean}\r\n   */\n  contains(shape) {\n    if (shape instanceof Flatten.Point) {\n      let rel = ray_shoot(this, shape);\n      return rel === Flatten.INSIDE || rel === Flatten.BOUNDARY;\n    } else {\n      return cover(this, shape);\n    }\n  }\n\n  /**\r\n   * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n   * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n   * @returns {Number | Segment}\r\n   */\n  distanceTo(shape) {\n    // let {Distance} = Flatten;\n\n    if (shape instanceof Flatten.Point) {\n      let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [dist, shortest_segment];\n    }\n    if (shape instanceof Flatten.Circle || shape instanceof Flatten.Line || shape instanceof Flatten.Segment || shape instanceof Flatten.Arc) {\n      let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\n      shortest_segment = shortest_segment.reverse();\n      return [dist, shortest_segment];\n    }\n\n    /* this method is bit faster */\n    if (shape instanceof Flatten.Polygon) {\n      let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n      let dist, shortest_segment;\n      for (let edge of this.edges) {\n        // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\n        let min_stop = min_dist_and_segment[0];\n        [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\n        if (Flatten.Utils.LT(dist, min_stop)) {\n          min_dist_and_segment = [dist, shortest_segment];\n        }\n      }\n      return min_dist_and_segment;\n    }\n  }\n\n  /**\r\n   * Return array of intersection points between polygon and other shape\r\n   * @param shape Shape of the one of supported types <br/>\r\n   * @returns {Point[]}\r\n   */\n  intersect(shape) {\n    if (shape instanceof Flatten.Point) {\n      return this.contains(shape) ? [shape] : [];\n    }\n    if (shape instanceof Flatten.Line) {\n      return intersectLine2Polygon(shape, this);\n    }\n    if (shape instanceof Flatten.Circle) {\n      return intersectCircle2Polygon(shape, this);\n    }\n    if (shape instanceof Flatten.Segment) {\n      return intersectSegment2Polygon(shape, this);\n    }\n    if (shape instanceof Flatten.Arc) {\n      return intersectArc2Polygon(shape, this);\n    }\n    if (shape instanceof Flatten.Polygon) {\n      return intersectPolygon2Polygon(shape, this);\n    }\n  }\n\n  /**\r\n   * Returns new polygon translated by vector vec\r\n   * @param {Vector} vec\r\n   * @returns {Polygon}\r\n   */\n  translate(vec) {\n    let newPolygon = new Polygon();\n    for (let face of this.faces) {\n      newPolygon.addFace(face.shapes.map(shape => shape.translate(vec)));\n    }\n    return newPolygon;\n  }\n\n  /**\r\n   * Return new polygon rotated by given angle around given point\r\n   * If point omitted, rotate around origin (0,0)\r\n   * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n   * @param {number} angle - rotation angle in radians\r\n   * @param {Point} center - rotation center, default is (0,0)\r\n   * @returns {Polygon} - new rotated polygon\r\n   */\n  rotate() {\n    let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Flatten.Point();\n    let newPolygon = new Polygon();\n    for (let face of this.faces) {\n      newPolygon.addFace(face.shapes.map(shape => shape.rotate(angle, center)));\n    }\n    return newPolygon;\n  }\n\n  /**\r\n   * Return new polygon transformed using affine transformation matrix\r\n   * @param {Matrix} matrix - affine transformation matrix\r\n   * @returns {Polygon} - new polygon\r\n   */\n  transform() {\n    let matrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Flatten.Matrix();\n    let newPolygon = new Polygon();\n    for (let face of this.faces) {\n      newPolygon.addFace(face.shapes.map(shape => shape.transform(matrix)));\n    }\n    return newPolygon;\n  }\n\n  /**\r\n   * This method returns an object that defines how data will be\r\n   * serialized when called JSON.stringify() method\r\n   * @returns {Object}\r\n   */\n  toJSON() {\n    return [...this.faces].map(face => face.toJSON());\n  }\n\n  /**\r\n   * Transform all faces into array of polygons\r\n   * @returns {Flatten.Polygon[]}\r\n   */\n  toArray() {\n    return [...this.faces].map(face => face.toPolygon());\n  }\n\n  /**\r\n   * Return string to draw polygon in svg\r\n   * @param attrs  - an object with attributes for svg path element,\r\n   * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n   * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n   * @returns {string}\r\n   */\n  svg() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      stroke,\n      strokeWidth,\n      fill,\n      fillRule,\n      fillOpacity,\n      id,\n      className\n    } = attrs;\n    // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n    let id_str = id && id.length > 0 ? \"id=\\\"\".concat(id, \"\\\"\") : \"\";\n    let class_str = className && className.length > 0 ? \"class=\\\"\".concat(className, \"\\\"\") : \"\";\n    let svgStr = \"\\n<path stroke=\\\"\".concat(stroke || \"black\", \"\\\" stroke-width=\\\"\").concat(strokeWidth || 1, \"\\\" fill=\\\"\").concat(fill || \"lightcyan\", \"\\\" fill-rule=\\\"\").concat(fillRule || \"evenodd\", \"\\\" fill-opacity=\\\"\").concat(fillOpacity || 1.0, \"\\\" \").concat(id_str, \" \").concat(class_str, \" d=\\\"\");\n    for (let face of this.faces) {\n      svgStr += face.svg();\n    }\n    svgStr += \"\\\" >\\n</path>\";\n    return svgStr;\n  }\n}\nFlatten.Polygon = Polygon;\n\n/**\r\n * Shortcut method to create new polygon\r\n */\nconst polygon = function () {\n  for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n    args[_key22] = arguments[_key22];\n  }\n  return new Flatten.Polygon(...args);\n};\nFlatten.polygon = polygon;\nclass Distance {\n  /**\r\n   * Calculate distance and shortest segment between points\r\n   * @param pt1\r\n   * @param pt2\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static point2point(pt1, pt2) {\n    return pt1.distanceTo(pt2);\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between point and line\r\n   * @param pt\r\n   * @param line\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static point2line(pt, line) {\n    let closest_point = pt.projectionOn(line);\n    let vec = new Flatten.Vector(pt, closest_point);\n    return [vec.length, new Flatten.Segment(pt, closest_point)];\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between point and circle\r\n   * @param pt\r\n   * @param circle\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static point2circle(pt, circle) {\n    let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\n    if (Flatten.Utils.EQ_0(dist2center)) {\n      return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\n    } else {\n      let dist = Math.abs(dist2center - circle.r);\n      let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\n      let closest_point = circle.pc.translate(v);\n      return [dist, new Flatten.Segment(pt, closest_point)];\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between point and segment\r\n   * @param pt\r\n   * @param segment\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static point2segment(pt, segment) {\n    /* Degenerated case of zero-length segment */\n    if (segment.start.equalTo(segment.end)) {\n      return Distance.point2point(pt, segment.start);\n    }\n    let v_seg = new Flatten.Vector(segment.start, segment.end);\n    let v_ps2pt = new Flatten.Vector(segment.start, pt);\n    let v_pe2pt = new Flatten.Vector(segment.end, pt);\n    let start_sp = v_seg.dot(v_ps2pt);\n    /* dot product v_seg * v_ps2pt */\n    let end_sp = -v_seg.dot(v_pe2pt);\n    /* minus dot product v_seg * v_pe2pt */\n\n    let dist;\n    let closest_point;\n    if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {\n      /* point inside segment scope */\n      let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\n      /* unit vector ||v_unit|| = 1 */\n      dist = Math.abs(v_unit.cross(v_ps2pt));\n      /* dist = abs(v_unit x v_ps2pt) */\n      closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\n      return [dist, new Flatten.Segment(pt, closest_point)];\n    } else if (start_sp < 0) {\n      /* point is out of scope closer to ps */\n      return pt.distanceTo(segment.start);\n    } else {\n      /* point is out of scope closer to pe */\n      return pt.distanceTo(segment.end);\n    }\n  }\n  /**\r\n   * Calculate distance and shortest segment between point and arc\r\n   * @param pt\r\n   * @param arc\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static point2arc(pt, arc) {\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n    let dist_and_segment = [];\n    let dist, shortest_segment;\n    [dist, shortest_segment] = Distance.point2circle(pt, circle);\n    if (shortest_segment.end.on(arc)) {\n      dist_and_segment.push(Distance.point2circle(pt, circle));\n    }\n    dist_and_segment.push(Distance.point2point(pt, arc.start));\n    dist_and_segment.push(Distance.point2point(pt, arc.end));\n    Distance.sort(dist_and_segment);\n    return dist_and_segment[0];\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between segment and line\r\n   * @param seg\r\n   * @param line\r\n   * @returns {Number | Segment}\r\n   */\n  static segment2line(seg, line) {\n    let ip = seg.intersect(line);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])]; // distance = 0, closest point is the first point\n    }\n    let dist_and_segment = [];\n    dist_and_segment.push(Distance.point2line(seg.start, line));\n    dist_and_segment.push(Distance.point2line(seg.end, line));\n    Distance.sort(dist_and_segment);\n    return dist_and_segment[0];\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between two segments\r\n   * @param seg1\r\n   * @param seg2\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static segment2segment(seg1, seg2) {\n    let ip = intersectSegment2Segment(seg1, seg2);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])]; // distance = 0, closest point is the first point\n    }\n\n    // Seg1 and seg2 not intersected\n    let dist_and_segment = [];\n    let dist_tmp, shortest_segment_tmp;\n    [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\n    dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n    [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\n    dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n    dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\n    dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\n    Distance.sort(dist_and_segment);\n    return dist_and_segment[0];\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between segment and circle\r\n   * @param seg\r\n   * @param circle\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static segment2circle(seg, circle) {\n    /* Case 1 Segment and circle intersected. Return the first point and zero distance */\n    let ip = seg.intersect(circle);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])];\n    }\n\n    // No intersection between segment and circle\n\n    /* Case 2. Distance to projection of center point to line bigger than radius\r\n     * And projection point belong to segment\r\n      * Then measure again distance from projection to circle and return it */\n    let line = new Flatten.Line(seg.ps, seg.pe);\n    let [dist, shortest_segment] = Distance.point2line(circle.center, line);\n    if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\n      return Distance.point2circle(shortest_segment.end, circle);\n    }\n    /* Case 3. Otherwise closest point is one of the end points of the segment */else {\n      let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\n      let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\n      return Flatten.Utils.LT(dist_from_start, dist_from_end) ? [dist_from_start, shortest_segment_from_start] : [dist_from_end, shortest_segment_from_end];\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between segment and arc\r\n   * @param seg\r\n   * @param arc\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static segment2arc(seg, arc) {\n    /* Case 1 Segment and arc intersected. Return the first point and zero distance */\n    let ip = seg.intersect(arc);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])];\n    }\n\n    // No intersection between segment and arc\n    let line = new Flatten.Line(seg.ps, seg.pe);\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n\n    /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n     * projection point belongs to segment AND\r\n       * distance from projection point to circle belongs to arc  =>\r\n       * return this distance from projection to circle */\n    let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n    if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\n      let [dist_from_projection, shortest_segment_from_projection] = Distance.point2circle(shortest_segment_from_center.end, circle);\n      if (shortest_segment_from_projection.end.on(arc)) {\n        return [dist_from_projection, shortest_segment_from_projection];\n      }\n    }\n    /* Case 3. Otherwise closest point is one of the end points of the segment */\n    let dist_and_segment = [];\n    dist_and_segment.push(Distance.point2arc(seg.start, arc));\n    dist_and_segment.push(Distance.point2arc(seg.end, arc));\n    let dist_tmp, segment_tmp;\n    [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\n    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n    [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\n    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n    Distance.sort(dist_and_segment);\n    return dist_and_segment[0];\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between two circles\r\n   * @param circle1\r\n   * @param circle2\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static circle2circle(circle1, circle2) {\n    let ip = circle1.intersect(circle2);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])];\n    }\n\n    // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\n    if (circle1.center.equalTo(circle2.center)) {\n      let arc1 = circle1.toArc();\n      let arc2 = circle2.toArc();\n      return Distance.point2point(arc1.start, arc2.start);\n    } else {\n      // Case 2. Not concentric circles\n      let line = new Flatten.Line(circle1.center, circle2.center);\n      let ip1 = line.intersect(circle1);\n      let ip2 = line.intersect(circle2);\n      let dist_and_segment = [];\n      dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\n      dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\n      dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\n      dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\n      Distance.sort(dist_and_segment);\n      return dist_and_segment[0];\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between two circles\r\n   * @param circle\r\n   * @param line\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static circle2line(circle, line) {\n    let ip = circle.intersect(line);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])];\n    }\n    let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n    let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\n    shortest_segment = shortest_segment.reverse();\n    return [dist, shortest_segment];\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between arc and line\r\n   * @param arc\r\n   * @param line\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static arc2line(arc, line) {\n    /* Case 1 Line and arc intersected. Return the first point and zero distance */\n    let ip = line.intersect(arc);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])];\n    }\n    let circle = new Flatten.Circle(arc.center, arc.r);\n\n    /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n     * projection point belongs to segment AND\r\n       * distance from projection point to circle belongs to arc  =>\r\n       * return this distance from projection to circle */\n    let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n    if (Flatten.Utils.GE(dist_from_center, circle.r)) {\n      let [dist_from_projection, shortest_segment_from_projection] = Distance.point2circle(shortest_segment_from_center.end, circle);\n      if (shortest_segment_from_projection.end.on(arc)) {\n        return [dist_from_projection, shortest_segment_from_projection];\n      }\n    } else {\n      let dist_and_segment = [];\n      dist_and_segment.push(Distance.point2line(arc.start, line));\n      dist_and_segment.push(Distance.point2line(arc.end, line));\n      Distance.sort(dist_and_segment);\n      return dist_and_segment[0];\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between arc and circle\r\n   * @param arc\r\n   * @param circle2\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static arc2circle(arc, circle2) {\n    let ip = arc.intersect(circle2);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])];\n    }\n    let circle1 = new Flatten.Circle(arc.center, arc.r);\n    let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n    if (shortest_segment.start.on(arc)) {\n      return [dist, shortest_segment];\n    } else {\n      let dist_and_segment = [];\n      dist_and_segment.push(Distance.point2circle(arc.start, circle2));\n      dist_and_segment.push(Distance.point2circle(arc.end, circle2));\n      Distance.sort(dist_and_segment);\n      return dist_and_segment[0];\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between two arcs\r\n   * @param arc1\r\n   * @param arc2\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static arc2arc(arc1, arc2) {\n    let ip = arc1.intersect(arc2);\n    if (ip.length > 0) {\n      return [0, new Flatten.Segment(ip[0], ip[0])];\n    }\n    let circle1 = new Flatten.Circle(arc1.center, arc1.r);\n    let circle2 = new Flatten.Circle(arc2.center, arc2.r);\n    let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n    if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\n      return [dist, shortest_segment];\n    } else {\n      let dist_and_segment = [];\n      let dist_tmp, segment_tmp;\n      [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\n      if (segment_tmp.end.on(arc2)) {\n        dist_and_segment.push([dist_tmp, segment_tmp]);\n      }\n      [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\n      if (segment_tmp.end.on(arc2)) {\n        dist_and_segment.push([dist_tmp, segment_tmp]);\n      }\n      [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\n      if (segment_tmp.end.on(arc1)) {\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n      }\n      [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\n      if (segment_tmp.end.on(arc1)) {\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n      }\n      [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\n      dist_and_segment.push([dist_tmp, segment_tmp]);\n      [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\n      dist_and_segment.push([dist_tmp, segment_tmp]);\n      [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\n      dist_and_segment.push([dist_tmp, segment_tmp]);\n      [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\n      dist_and_segment.push([dist_tmp, segment_tmp]);\n      Distance.sort(dist_and_segment);\n      return dist_and_segment[0];\n    }\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between point and polygon\r\n   * @param point\r\n   * @param polygon\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static point2polygon(point, polygon) {\n    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n    for (let edge of polygon.edges) {\n      let [dist, shortest_segment] = edge.shape instanceof Flatten.Segment ? Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\n      if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n        min_dist_and_segment = [dist, shortest_segment];\n      }\n    }\n    return min_dist_and_segment;\n  }\n  static shape2polygon(shape, polygon) {\n    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n    for (let edge of polygon.edges) {\n      let [dist, shortest_segment] = shape.distanceTo(edge.shape);\n      if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n        min_dist_and_segment = [dist, shortest_segment];\n      }\n    }\n    return min_dist_and_segment;\n  }\n\n  /**\r\n   * Calculate distance and shortest segment between two polygons\r\n   * @param polygon1\r\n   * @param polygon2\r\n   * @returns {Number | Segment} - distance and shortest segment\r\n   */\n  static polygon2polygon(polygon1, polygon2) {\n    let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n    for (let edge1 of polygon1.edges) {\n      for (let edge2 of polygon2.edges) {\n        let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\n        if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n          min_dist_and_segment = [dist, shortest_segment];\n        }\n      }\n    }\n    return min_dist_and_segment;\n  }\n\n  /**\r\n   * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n   * Minimal distance by x is\r\n   *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n   *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n   *    0,                       if box1 and box2 are intersected by x\r\n   * Minimal distance by y is defined in the same way\r\n   *\r\n   * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n   *\r\n   * @param box1\r\n   * @param box2\r\n   * @returns {Number | Number} - minimal and maximal distance\r\n   */\n  static box2box_minmax(box1, box2) {\n    let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\n    let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\n    let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\n    let box = box1.merge(box2);\n    let dx = box.xmax - box.xmin;\n    let dy = box.ymax - box.ymin;\n    let maxdist = dx * dx + dy * dy;\n    return [mindist, maxdist];\n  }\n  static minmax_tree_process_level(shape, level, min_stop, tree) {\n    // Calculate minmax distance to each shape in current level\n    // Insert result into the interval tree for further processing\n    // update min_stop with maxdist, it will be the new stop distance\n    let mindist, maxdist;\n    for (let node of level) {\n      // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n      // if (Flatten.Utils.GT(mindist, min_stop))\n      //     continue;\n\n      // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\n      [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\n      if (node.item.value instanceof Flatten.Edge) {\n        tree.insert([mindist, maxdist], node.item.value.shape);\n      } else {\n        tree.insert([mindist, maxdist], node.item.value);\n      }\n      if (Flatten.Utils.LT(maxdist, min_stop)) {\n        min_stop = maxdist; // this will be the new distance estimation\n      }\n    }\n    if (level.length === 0) return min_stop;\n\n    // Calculate new level from left and right children of the current\n    let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\n    let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\n    // Merge left and right subtrees and leave only relevant subtrees\n    let new_level = [...new_level_left, ...new_level_right].filter(node => {\n      // Node subtree quick reject, node.max is a subtree box\n      let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n      return Flatten.Utils.LE(mindist, min_stop);\n    });\n    min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\n    return min_stop;\n  }\n\n  /**\r\n   * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n   * and shapes of the planar set.\r\n   * @param shape\r\n   * @param set\r\n   */\n  static minmax_tree(shape, set, min_stop) {\n    let tree = new IntervalTree();\n    let level = [set.index.root];\n    let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\n    squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\n    return tree;\n  }\n  static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\n    let min_dist_and_segment_new, stop;\n    if (node != null && !node.isNil()) {\n      [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\n      if (stop) {\n        return [min_dist_and_segment_new, stop];\n      }\n      if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\n        return [min_dist_and_segment_new, true]; // stop condition\n      }\n      let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\n      // console.log(dist)\n      if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\n        min_dist_and_segment_new = [dist, shortest_segment];\n      }\n      [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\n      return [min_dist_and_segment_new, stop];\n    }\n    return [min_dist_and_segment, false];\n  }\n\n  /**\r\n   * Calculates distance between shape and Planar Set of shapes\r\n   * @param shape\r\n   * @param {PlanarSet} set\r\n   * @param {Number} min_stop\r\n   * @returns {*}\r\n   */\n  static shape2planarSet(shape, set) {\n    let min_stop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;\n    let min_dist_and_segment = [min_stop, new Flatten.Segment()];\n    let stop = false;\n    if (set instanceof Flatten.PlanarSet) {\n      let tree = Distance.minmax_tree(shape, set, min_stop);\n      [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\n    }\n    return min_dist_and_segment;\n  }\n  static sort(dist_and_segment) {\n    dist_and_segment.sort((d1, d2) => {\n      if (Flatten.Utils.LT(d1[0], d2[0])) {\n        return -1;\n      }\n      if (Flatten.Utils.GT(d1[0], d2[0])) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  static distance(shape1, shape2) {\n    return shape1.distanceTo(shape2);\n  }\n}\nFlatten.Distance = Distance;\n\n/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\n\n/**\r\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\r\n * (where line is considered as a circle with infinite radius) into generalized circles\r\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\r\n * http://mathworld.wolfram.com/Inversion.html <br/>\r\n * Inversion also may be considered as a reflection of the point in the plane with respect\r\n * to inversion circle so that R^2 = OP * OP',\r\n * where <br/>\r\n * O - center of inversion circle <br/>\r\n * R - radius of inversion circle <br/>\r\n * P - point of plane <br/>\r\n * P' - inversion of the point P\r\n *\r\n * @param {Line | Circle} shape - shape to be transformed\r\n * @param {Circle} inversion_circle - inversion circle\r\n * @returns {Line | Circle} - result of transformation\r\n */\nfunction inverse(shape, inversion_circle) {\n  let dist, shortest_segment;\n  let dx, dy;\n  let s;\n  let v;\n  let r;\n  let d;\n  let pt;\n  if (shape instanceof Flatten.Line) {\n    [dist, shortest_segment] = inversion_circle.pc.distanceTo(shape);\n    if (EQ_0(dist)) {\n      // Line passing through inversion center, is mapping to itself\n      return shape.clone();\n    } else {\n      // Line not passing through inversion center is mapping into circle\n      r = inversion_circle.r * inversion_circle.r / (2 * dist);\n      v = new Flatten.Vector(inversion_circle.pc, shortest_segment.end);\n      v = v.multiply(r / dist);\n      return new Flatten.Circle(inversion_circle.pc.translate(v), r);\n    }\n  } else if (shape instanceof Flatten.Circle) {\n    [dist, shortest_segment] = inversion_circle.pc.distanceTo(shape.pc);\n    if (EQ(dist, shape.r)) {\n      // Circle passing through inversion center mapped into line\n      d = inversion_circle.r * inversion_circle.r / (2 * shape.r);\n      v = new Flatten.Vector(shape.pc, inversion_circle.pc);\n      v = v.normalize();\n      pt = inversion_circle.pc.translate(v.multiply(d));\n      return new Flatten.Line(pt, v);\n    } else {\n      // Circle not passing through inversion center - map into another circle */\n      /* Taken from http://mathworld.wolfram.com */\n\n      dx = shape.pc.x - inversion_circle.pc.x;\n      dy = shape.pc.y - inversion_circle.pc.y;\n      s = inversion_circle.r * inversion_circle.r / (dx * dx + dy * dy - shape.r * shape.r);\n      let pc = new Flatten.Point(inversion_circle.pc.x + s * dx, inversion_circle.pc.y + s * dy);\n      return new Flatten.Circle(pc, Math.abs(s) * shape.r);\n    }\n  }\n}\n\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\n\nFlatten.BooleanOperations = BooleanOperations;\nFlatten.Relations = Relations;\nexport default Flatten;\nexport { Arc, BOUNDARY, BooleanOperations, Box, CCW, CW, Circle, Distance, Edge, errors as Errors, Face, INSIDE, Line, Matrix, Multiline, ORIENTATION, OUTSIDE, PlanarSet, Point, Polygon, Ray, Relations, Segment, Utils, Vector, arc, box, circle, inverse, line, matrix, multiline, point, polygon, ray, ray_shoot, segment, vector };","map":{"version":3,"names":["CCW","CW","ORIENTATION","NOT_ORIENTABLE","PIx2","Math","PI","INSIDE","OUTSIDE","BOUNDARY","CONTAINS","INTERLACE","OVERLAP_SAME","OVERLAP_OPPOSITE","Constants","Object","freeze","DP_TOL","setTolerance","tolerance","getTolerance","DECIMALS","EQ_0","x","EQ","y","GT","GE","LT","LE","Utils","Errors","ILLEGAL_PARAMETERS","ReferenceError","ZERO_DIVISION","Error","UNRESOLVED_BOUNDARY_CONFLICT","INFINITE_LOOP","errors","default","Flatten","Matrix","undefined","Planar_set","Point","Vector","Line","Circle","Segment","Arc","Box","Edge","Face","Ray","Ray_shooting","Multiline","Polygon","Distance","c","defineProperty","get","set","value","LinkedList","constructor","first","last","testInfiniteLoop","edge","controlEdge","next","size","counter","toArray","start","arguments","length","end","elements","from","to","element","push","append","isEmpty","prev","insert","newElement","elementBefore","elementAfter","remove","Symbol","iterator","done","INSIDE$1","OUTSIDE$1","BOUNDARY$1","OVERLAP_SAME$1","OVERLAP_OPPOSITE$1","NOT_VERTEX","START_VERTEX","END_VERTEX","BOOLEAN_UNION","BOOLEAN_INTERSECT","BOOLEAN_SUBTRACT","unify","polygon1","polygon2","res_poly","wrk_poly","booleanOpBinary","subtract","polygon2_tmp","clone","polygon2_reversed","reverse","intersect","innerClip","clip_shapes1","face","faces","edges","map","shape","clip_shapes2","outerClip","calculateIntersections","intersections","getIntersections","sortIntersections","splitByIntersections","int_points1_sorted","int_points2_sorted","filterDuplicatedIntersections","ip_sorted1","int_point","pt","ip_sorted2","filterNotRelevantEdges","op","notIntersectedFacesRes","getNotIntersectedFaces","int_points1","notIntersectedFacesWrk","int_points2","calcInclusionForNotIntersectedFaces","initializeInclusionFlags","calculateInclusionFlags","fixBoundaryConflicts","setOverlappingFlags","removeNotRelevantChains","removeNotRelevantNotIntersectedFaces","swapLinksAndRestore","copyWrkToRes","swapLinks","removeOldFaces","restoreFaces","restore","edge1","resp","search","box","edge2","ip","addToIntPoints","int_points","id","shapes","split","len","is_vertex","arc_length","edge_before","edge_after","getSortedArray","faceMap","Map","has","faceId","int_points_sorted","slice","sort","compareFn","ip1","ip2","polygon","equalTo","newEdge","addVertex","do_squeeze","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","i","j","filter","forEach","index","poly","notIntersected","find","notIntersectedFaces","poly2","bv","bvStart","bvEnd","setInclusion","overlap","poly1","cur_face","first_int_point_in_face_id","next_int_point1","num_int_points","iterate_more","cur_int_point1","int_points_cur_pool_start","int_points_cur_pool_num","intPointsPoolCount","next_int_point_id","int_points_next_pool_num","next_int_point1_tmp","edge_from1","edge_to1","edge_tmp","new_bv","dist","segment","distanceTo","ps","int_point1","newEdge1","findEdgeByPoint","pe","int_point2","int_point2_edge_after","newEdge2","cur_int_point2","next_int_point2","edge_from2","edge_to2","setOverlap","is_res_polygon","first_int_point_in_face_num","int_point_current","int_point_next","int_points_from_pull_start","int_points_from_pull_num","next_int_point_num","int_points_to_pull_start","int_points_to_pull_num","edge_from","edge_to","removeChain","k","cur_int_point_num","int_points_pool_num","res_polygon","wrk_polygon","add","addFace","delete","other_int_points","int_point_tmp","rel","deleteFace","BooleanOperations","EQUAL","RegExp","INTERSECT","TOUCH","INSIDE$2","COVERED","DE9IM","m","Array","fill","I2I","geom","I2B","I2E","B2I","B2B","B2E","E2I","E2B","E2E","toString","e","join","equal","test","touch","inside","covered","intersectLine2Line","line1","line2","A1","B1","C1","standard","A2","B2","C2","det","detX","detY","intersectLine2Circle","line","circle","prj","pc","projectionOn","r","delta","sqrt","v_trans","norm","rotate90CCW","multiply","translate","rotate90CW","intersectLine2Box","ips","seg","toSegments","ips_tmp","intersectSegment2Line","ptInIntPoints","intersectLine2Arc","arc","ip_tmp","on","isZeroLength","leftTo","intersectSegment2Segment","seg1","seg2","not_intersect","incidentTo","new_ip","intersectSegment2Circle","shortest_segment","intersectSegment2Arc","intersectSegment2Box","intersectCircle2Circle","circle1","circle2","vec","r1","r2","abs","a","mid_pt","h","intersectCircle2Box","intersectArc2Arc","arc1","arc2","intersectArc2Circle","intersectArc2Box","intersectEdge2Segment","isSegment","intersectEdge2Arc","intersectEdge2Line","intersectEdge2Circle","intersectSegment2Polygon","intersectArc2Polygon","intersectLine2Polygon","sortPoints","intersectCircle2Polygon","intersectEdge2Edge","shape1","shape2","intersectEdge2Polygon","resp_edges","resp_edge","intersectPolygon2Polygon","intersectShape2Polygon","new_pt","some","validShapes","every","reduce","acc","merge","vertices","v","toShapes","edgeBefore","edgeFound","contains","rotate","angle","center","transform","matrix","toJSON","svg","attrs","stroke","strokeWidth","fillRule","fillOpacity","className","id_str","concat","class_str","svgStr","multiline","_len","args","_key","ray_shoot","point","ray","searchBox","xmin","ymin","xmax","ymax","i1","i2","intersection","prev_edge","prev_tangent","tangentInEnd","prev_point","cur_tangent","tangentInStart","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","relate","intersect$1","disjoint","contain","cover","relateLine2Line","relateLine2Circle","relateLine2Box","relateLine2Polygon","relateShape2Polygon","relatePolygon2Polygon","denim","ip_sorted","splitShapes","toArc","cut","boolean_intersection","boolean_difference1","boolean_difference2","inner_clip_shapes1","inner_clip_shapes2","outer_clip_shapes1","outer_clip_shapes2","Relations","b","d","tx","ty","vector","other_matrix","_len2","_key2","cos","sin","scale","sx","sy","_len3","_key3","Interval","low","high","max","less_than","other_interval","equal_to","min","output","comparable_max","interval1","interval2","comparable_less_than","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","key","left","right","parent","color","item","Number","isNaN","isNil","other_node","value_less_than","value_equal","copy_data","update_max","not_intersect_left_subtree","search_node","not_intersect_right_subtree","IntervalTree","root","nil_node","count","tree_walk","keys","res","node","values","items","insert_node","tree_insert","recalc_max","exist","tree_search","delete_node","tree_delete","interval","outputMapperFn","resp_nodes","tree_search_interval","intersect_any","found","tree_find_any_interval","visitor","callback","tree","node_current","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","tree_successor","delete_fixup","brother_node","local_minimum","node_min","local_maximum","node_max","node_successor","action","testRedBlackProperty","testBlackHeightProperty","height","heightLeft","heightRight","PlanarSet","Set","deleted","clear","hit","svgcontent","_len4","_key4","arr","name","lessThan","x_rot","y_rot","_len5","_key5","cross","dot","proj_vec","onLeftSemiPlane","dx","dy","point2line","point2circle","point2segment","point2arc","point2polygon","shape2planarSet","assign","_len6","_key6","_len7","_key7","a1","a2","slope","atan2","scalar","normalize","rpoint","invert","angleTo","norm1","norm2","n","_len8","_key8","_len9","_key9","coords","distanceToPoint","segment2circle","segment2line","segment2segment","segment2arc","shape2polygon","middle","rest","definiteIntegral","dy1","dy2","pts","_len10","_key10","vector$1","_len11","_key11","points2norm","POSITIVE_INFINITY","NEGATIVE_INFINITY","A","B","C","parallelTo","other_line","coord","distance","circle2line","arc2line","sorted_points","pt1","pt2","unit","_len12","_key12","_len13","_key13","counterclockwise","circle2circle","arc2circle","_len14","_key14","startAngle","endAngle","counterClockwise","_len15","_key15","sweep","p0","func_arcs","breakToFunctional","test_arc","chordHeight","arc2arc","func_arcs_array","angles","test_arcs","prev_arc","new_arc","tangent","scaleX","scaleY","newStart","newEnd","newCenter","newDirection","arcSE","f_arcs","area","circularSegmentDefiniteIntegral","onLeftSide","areaTrapez","areaCircularSegment","circularSegmentArea","slope1","slope2","largeArcFlag","sweepFlag","_len16","_key16","other_box","box1","box2","toPoints","width","_len17","_key17","isArc","bvMiddle","flag","sign","halfArc1","halfArc2","CircularLinkedList","setCircularLinks","_box","_orientation","_len18","_key18","segments","points2segments","shapes2face","points","flattenShapes","flattenShape","setArcLength","setOneEdgeArcLength","orientation","signedArea","sArea","isSimple","getSelfIntersections","exitOnFirst","toPolygon","_len19","_key19","intersectRay2Segment","intersectRay2Arc","_len20","_key20","argsArray","loop","el","loop1","isValid","valid","_len21","_key21","edgeFrom","edgeTo","cutPolygons","cut_edge_start","cut_edge_end","newCutPolygons","cutPoly1","cutPoly2","cutFace","edgeBefore1","edgeBefore2","face1","face2","splitToIslands","polygons","newPolygons","islandPolygon","min_dist_and_segment","min_stop","newPolygon","_len22","_key22","point2point","closest_point","dist2center","shortest_dist","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_tmp","shortest_segment_tmp","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","segment_tmp","polygon2polygon","box2box_minmax","mindist_x","mindist_y","mindist","maxdist","minmax_tree_process_level","level","new_level_left","new_level_right","new_level","minmax_tree","squared_min_stop","minmax_tree_calc_distance","min_dist_and_segment_new","stop","d1","d2","inverse","inversion_circle","s"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/@flatten-js/core/dist/main.esm.js"],"sourcesContent":["/**\r\n * Global constant CCW defines counter clockwise direction of arc\r\n * @type {boolean}\r\n */\r\nconst CCW = true;\r\n\r\n/**\r\n * Global constant CW defines clockwise direction of arc\r\n * @type {boolean}\r\n */\r\nconst CW = false;\r\n\r\n/**\r\n * Defines orientation for face of the polygon: clockwise, counter clockwise\r\n * or not orientable in the case of self-intersection\r\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\r\n */\r\nconst ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\r\n\r\nconst PIx2 = 2 * Math.PI;\r\n\r\nconst INSIDE = 1;\r\nconst OUTSIDE = 0;\r\nconst BOUNDARY = 2;\r\nconst CONTAINS = 3;\r\nconst INTERLACE = 4;\r\n\r\nconst OVERLAP_SAME = 1;\r\nconst OVERLAP_OPPOSITE = 2;\r\n\r\nvar Constants = /*#__PURE__*/Object.freeze({\r\n    CCW: CCW,\r\n    CW: CW,\r\n    ORIENTATION: ORIENTATION,\r\n    PIx2: PIx2,\r\n    INSIDE: INSIDE,\r\n    OUTSIDE: OUTSIDE,\r\n    BOUNDARY: BOUNDARY,\r\n    CONTAINS: CONTAINS,\r\n    INTERLACE: INTERLACE,\r\n    OVERLAP_SAME: OVERLAP_SAME,\r\n    OVERLAP_OPPOSITE: OVERLAP_OPPOSITE\r\n});\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n * Floating point comparison tolerance.\r\n * Default value is 0.000001 (10e-6)\r\n * @type {number}\r\n */\r\nlet DP_TOL = 0.000001;\r\n\r\n/**\r\n * Set new floating point comparison tolerance\r\n * @param {number} tolerance\r\n */\r\nfunction setTolerance(tolerance) {DP_TOL = tolerance;}\r\n\r\n/**\r\n * Get floating point comparison tolerance\r\n * @returns {number}\r\n */\r\nfunction getTolerance() {return DP_TOL;}\r\n\r\nconst DECIMALS = 3;\r\n\r\n/**\r\n * Returns *true* if value comparable to zero\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction EQ_0(x) {\r\n    return (x < DP_TOL && x > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if two values are equal up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction EQ(x, y) {\r\n    return (x - y < DP_TOL && x - y > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument greater than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction GT(x, y) {\r\n    return (x - y > DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @returns {boolean}\r\n */\r\nfunction GE(x, y) {\r\n    return (x - y > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument less than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction LT(x, y) {\r\n    return (x - y < -DP_TOL)\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction LE(x, y) {\r\n    return (x - y < DP_TOL);\r\n}\r\n\r\nvar Utils = /*#__PURE__*/Object.freeze({\r\n    setTolerance: setTolerance,\r\n    getTolerance: getTolerance,\r\n    DECIMALS: DECIMALS,\r\n    EQ_0: EQ_0,\r\n    EQ: EQ,\r\n    GT: GT,\r\n    GE: GE,\r\n    LT: LT,\r\n    LE: LE\r\n});\r\n\r\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n/**\r\n * Class of system errors\r\n */\r\nclass Errors {\r\n    /**\r\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\r\n     * @returns {ReferenceError}\r\n     */\r\n    static get ILLEGAL_PARAMETERS() {\r\n        return new ReferenceError('Illegal Parameters');\r\n    }\r\n\r\n    /**\r\n     * Throw error ZERO_DIVISION to catch situation of zero division\r\n     * @returns {Error}\r\n     */\r\n    static get ZERO_DIVISION() {\r\n        return new Error('Zero division');\r\n    }\r\n\r\n    /**\r\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\r\n     * @returns {Error}\r\n     */\r\n    static get UNRESOLVED_BOUNDARY_CONFLICT() {\r\n        return new Error('Unresolved boundary conflict in boolean operation');\r\n    }\r\n\r\n    /**\r\n     * Error to throw from LinkedList:testInfiniteLoop static method\r\n     * in case when circular loop detected in linked list\r\n     * @returns {Error}\r\n     */\r\n    static get INFINITE_LOOP() {\r\n        return new Error('Infinite loop');\r\n    }\r\n}\r\n\r\nvar errors = /*#__PURE__*/Object.freeze({\r\n    default: Errors\r\n});\r\n\r\nlet Flatten = {\r\n    Utils: Utils,\r\n    Errors: Errors,\r\n    Matrix: undefined,\r\n    Planar_set: undefined,\r\n    Point: undefined,\r\n    Vector: undefined,\r\n    Line: undefined,\r\n    Circle: undefined,\r\n    Segment: undefined,\r\n    Arc: undefined,\r\n    Box: undefined,\r\n    Edge: undefined,\r\n    Face: undefined,\r\n    Ray: undefined,\r\n    Ray_shooting: undefined,\r\n    Multiline: undefined,\r\n    Polygon: undefined,\r\n    Distance: undefined,\r\n};\r\n\r\nfor (let c in Constants) {Flatten[c] = Constants[c];}\r\n\r\nObject.defineProperty(Flatten, 'DP_TOL', {\r\n    get:function(){return getTolerance()}, \r\n    set:function(value){setTolerance(value);}\r\n});\r\n\r\n/**\r\n * Class implements bidirectional non-circular linked list. <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\r\nclass LinkedList {\r\n    constructor(first, last) {\r\n        this.first = first;\r\n        this.last = last || this.first;\r\n    }\r\n\r\n    /**\r\n     * Throw an error if circular loop detected in the linked list\r\n     * @param {LinkedListElement} first element to start iteration\r\n     * @throws {Flatten.Errors.INFINITE_LOOP}\r\n     */\r\n    static testInfiniteLoop(first) {\r\n        let edge = first;\r\n        let controlEdge = first;\r\n        do {\r\n            if (edge != first && edge === controlEdge) {\r\n                throw Flatten.Errors.INFINITE_LOOP;  // new Error(\"Infinite loop\")\r\n            }\r\n            edge = edge.next;\r\n            controlEdge = controlEdge.next.next;\r\n        } while (edge != first)\r\n    }\r\n\r\n    /**\r\n     * Return number of elements in the list\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let counter = 0;\r\n        for (let edge of this) {\r\n            counter++;\r\n        }\r\n        return counter;\r\n    }\r\n\r\n    /**\r\n     * Return array of elements from start to end,\r\n     * If start or end not defined, take first as start, last as end\r\n     * @returns {Array}\r\n     */\r\n    toArray(start=undefined, end=undefined) {\r\n        let elements = [];\r\n        let from = start || this.first;\r\n        let to = end || this.last;\r\n        let element = from;\r\n        if (element === undefined) return elements;\r\n        do {\r\n            elements.push(element);\r\n            element = element.next;\r\n        } while (element !== to.next);\r\n        return elements;\r\n    }\r\n\r\n\r\n    /**\r\n     * Append new element to the end of the list\r\n     * @param {LinkedListElement} element\r\n     * @returns {LinkedList}\r\n     */\r\n    append(element) {\r\n        if (this.isEmpty()) {\r\n            this.first = element;\r\n        } else {\r\n            element.prev = this.last;\r\n            this.last.next = element;\r\n        }\r\n\r\n        // update edge to be last\r\n        this.last = element;\r\n\r\n        // nullify non-circular links\r\n        this.last.next = undefined;\r\n        this.first.prev = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert new element to the list after elementBefore\r\n     * @param {LinkedListElement} newElement\r\n     * @param {LinkedListElement} elementBefore\r\n     * @returns {LinkedList}\r\n     */\r\n    insert(newElement, elementBefore) {\r\n        if (this.isEmpty()) {\r\n            this.first = newElement;\r\n            this.last = newElement;\r\n        }\r\n        else if (elementBefore === null || elementBefore === undefined) {\r\n            newElement.next = this.first;\r\n            this.first.prev = newElement;\r\n            this.first = newElement;\r\n        }\r\n        else {\r\n            /* set links to new element */\r\n            let elementAfter = elementBefore.next;\r\n            elementBefore.next = newElement;\r\n            if (elementAfter) elementAfter.prev = newElement;\r\n\r\n            /* set links from new element */\r\n            newElement.prev = elementBefore;\r\n            newElement.next = elementAfter;\r\n\r\n            /* extend list if new element added after the last element */\r\n            if (this.last === elementBefore)\r\n                this.last = newElement;\r\n        }\r\n        // nullify non-circular links\r\n        this.last.next = undefined;\r\n        this.first.prev = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove element from the list\r\n     * @param {LinkedListElement} element\r\n     * @returns {LinkedList}\r\n     */\r\n    remove(element) {\r\n        // special case if last edge removed\r\n        if (element === this.first && element === this.last) {\r\n            this.first = undefined;\r\n            this.last = undefined;\r\n        } else {\r\n            // update linked list\r\n            if (element.prev) element.prev.next = element.next;\r\n            if (element.next) element.next.prev = element.prev;\r\n            // update first if need\r\n            if (element === this.first) {\r\n                this.first = element.next;\r\n            }\r\n            // update last if need\r\n            if (element === this.last) {\r\n                this.last = element.prev;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return true if list is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return this.first === undefined;\r\n    }\r\n\r\n    [Symbol.iterator]() {\r\n        let value = undefined;\r\n        return {\r\n            next: () => {\r\n                value = value ? value.next : this.first;\r\n                return {value: value, done: value === undefined};\r\n            }\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 12/02/2018.\r\n */\r\n\r\nlet {INSIDE: INSIDE$1, OUTSIDE: OUTSIDE$1, BOUNDARY: BOUNDARY$1, OVERLAP_SAME: OVERLAP_SAME$1, OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1} = Flatten;\r\n\r\nconst NOT_VERTEX = 0;\r\nconst START_VERTEX = 1;\r\nconst END_VERTEX = 2;\r\n\r\nconst BOOLEAN_UNION = 1;\r\nconst BOOLEAN_INTERSECT = 2;\r\nconst BOOLEAN_SUBTRACT = 3;\r\n\r\n\r\n/**\r\n * Unify two polygons polygons and returns new polygon. <br/>\r\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction unify(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Subtract second polygon from the first and returns new polygon\r\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction subtract(polygon1, polygon2) {\r\n    let polygon2_tmp = polygon2.clone();\r\n    let polygon2_reversed = polygon2_tmp.reverse();\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Intersect two polygons and returns new polygon\r\n * Point belongs to the resultes polygon is it belongs to the first AND to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction intersect(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\r\n * The first array are shapes from the first polygon, the second array are shapes from the second\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[][]}\r\n */\r\nfunction innerClip(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\r\n\r\n    let clip_shapes1 = [];\r\n    for (let face of res_poly.faces) {\r\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n    let clip_shapes2 = [];\r\n    for (let face of wrk_poly.faces) {\r\n        clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n    return [clip_shapes1, clip_shapes2];\r\n}\r\n\r\n/**\r\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[]}\r\n */\r\nfunction outerClip(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\r\n\r\n    let clip_shapes1 = [];\r\n    for (let face of res_poly.faces) {\r\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n\r\n    return clip_shapes1;\r\n}\r\n\r\n/**\r\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\r\n * Points in the first array belong to first polygon, points from the second - to the second.\r\n * Points in each array are ordered according to the direction of the correspondent polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Point[][]}\r\n */\r\nfunction calculateIntersections(polygon1, polygon2) {\r\n    let res_poly = polygon1.clone();\r\n    let wrk_poly = polygon2.clone();\r\n\r\n    // get intersection points\r\n    let intersections = getIntersections(res_poly, wrk_poly);\r\n\r\n    // sort intersection points\r\n    sortIntersections(intersections);\r\n\r\n    // split by intersection points\r\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\r\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\r\n\r\n    // filter duplicated intersection points\r\n    filterDuplicatedIntersections(intersections);\r\n\r\n    let ip_sorted1 = intersections.int_points1_sorted.map( int_point => int_point.pt);\r\n    let ip_sorted2 = intersections.int_points2_sorted.map( int_point => int_point.pt);\r\n    return [ip_sorted1, ip_sorted2];\r\n}\r\n\r\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\r\n    // keep not intersected faces for further remove and merge\r\n    let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\r\n    let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\r\n\r\n    // calculate inclusion flag for not intersected faces\r\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\r\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\r\n\r\n    // initialize inclusion flags for edges incident to intersections\r\n    initializeInclusionFlags(intersections.int_points1);\r\n    initializeInclusionFlags(intersections.int_points2);\r\n\r\n    // calculate inclusion flags only for edges incident to intersections\r\n    calculateInclusionFlags(intersections.int_points1, wrk_poly);\r\n    calculateInclusionFlags(intersections.int_points2, res_poly);\r\n\r\n    // fix boundary conflicts\r\n    while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\r\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\r\n\r\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\r\n    setOverlappingFlags(intersections);\r\n\r\n    // remove not relevant chains between intersection points\r\n    removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\r\n    removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\r\n\r\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\r\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\r\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\r\n    removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\r\n    removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\r\n}\r\n\r\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\r\n\r\n    // add edges of wrk_poly into the edge container of res_poly\r\n    copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\r\n\r\n    // swap links from res_poly to wrk_poly and vice versa\r\n    swapLinks(res_poly, wrk_poly, intersections);\r\n\r\n    // remove old faces\r\n    removeOldFaces(res_poly, intersections.int_points1);\r\n    removeOldFaces(wrk_poly, intersections.int_points2);\r\n\r\n    // restore faces\r\n    restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\r\n    restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\r\n\r\n    // merge relevant not intersected faces from wrk_polygon to res_polygon\r\n    // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\r\n}\r\n\r\n\r\nfunction booleanOpBinary(polygon1, polygon2, op, restore)\r\n{\r\n    let res_poly = polygon1.clone();\r\n    let wrk_poly = polygon2.clone();\r\n\r\n    // get intersection points\r\n    let intersections = getIntersections(res_poly, wrk_poly);\r\n\r\n    // sort intersection points\r\n    sortIntersections(intersections);\r\n\r\n    // split by intersection points\r\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\r\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\r\n\r\n    // filter duplicated intersection points\r\n    filterDuplicatedIntersections(intersections);\r\n\r\n    // calculate inclusion and remove not relevant edges\r\n    filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\r\n\r\n    if (restore) {\r\n        swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\r\n    }\r\n\r\n    return [res_poly, wrk_poly];\r\n}\r\n\r\nfunction getIntersections(polygon1, polygon2)\r\n{\r\n    let intersections = {\r\n        int_points1: [],\r\n        int_points2: []\r\n    };\r\n\r\n    // calculate intersections\r\n    for (let edge1 of polygon1.edges) {\r\n\r\n        // request edges of polygon2 in the box of edge1\r\n        let resp = polygon2.edges.search(edge1.box);\r\n\r\n        // for each edge2 in response\r\n        for (let edge2 of resp) {\r\n\r\n            // calculate intersections between edge1 and edge2\r\n            let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n            // for each intersection point\r\n            for (let pt of ip) {\r\n                addToIntPoints(edge1, pt, intersections.int_points1);\r\n                addToIntPoints(edge2, pt, intersections.int_points2);\r\n            }\r\n        }\r\n    }\r\n    return intersections;\r\n}\r\n\r\nfunction addToIntPoints(edge, pt, int_points)\r\n{\r\n    let id = int_points.length;\r\n    let shapes = edge.shape.split(pt);\r\n\r\n    // if (shapes.length < 2) return;\r\n    if (shapes.length === 0) return;     // Point does not belong to edge ?\r\n\r\n    let len = 0;\r\n    if (shapes[0] === null) {   // point incident to edge start vertex\r\n        len = 0;\r\n    }\r\n    else if (shapes[1] === null) {   // point incident to edge end vertex\r\n        len = edge.shape.length;\r\n    }\r\n    else {                             // Edge was split into to edges\r\n        len = shapes[0].length;\r\n    }\r\n\r\n    let is_vertex = NOT_VERTEX;\r\n    if (EQ(len, 0)) {\r\n        is_vertex |= START_VERTEX;\r\n    }\r\n    if (EQ(len, edge.shape.length)) {\r\n        is_vertex |= END_VERTEX;\r\n    }\r\n    // Fix intersection point which is end point of the last edge\r\n    let arc_length = (is_vertex & END_VERTEX) && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;\r\n\r\n    int_points.push({\r\n        id: id,\r\n        pt: pt,\r\n        arc_length: arc_length,\r\n        edge_before: edge,\r\n        edge_after: undefined,\r\n        face: edge.face,\r\n        is_vertex: is_vertex\r\n    });\r\n}\r\n\r\nfunction sortIntersections(intersections)\r\n{\r\n    // if (intersections.int_points1.length === 0) return;\r\n\r\n    // augment intersections with new sorted arrays\r\n    // intersections.int_points1_sorted = intersections.int_points1.slice().sort(compareFn);\r\n    // intersections.int_points2_sorted = intersections.int_points2.slice().sort(compareFn);\r\n    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\r\n    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n}\r\n\r\nfunction getSortedArray(int_points)\r\n{\r\n    let faceMap = new Map;\r\n    let id = 0;\r\n    // Create integer id's for faces\r\n    for (let ip of int_points) {\r\n        if (!faceMap.has(ip.face)) {\r\n            faceMap.set(ip.face, id);\r\n            id++;\r\n        }\r\n    }\r\n    // Augment intersection points with face id's\r\n    for (let ip of int_points) {\r\n        ip.faceId = faceMap.get(ip.face);\r\n    }\r\n    // Clone and sort\r\n    let int_points_sorted = int_points.slice().sort(compareFn);\r\n    return int_points_sorted;\r\n}\r\n\r\nfunction compareFn(ip1, ip2)\r\n{\r\n    // compare face id's\r\n    if (ip1.faceId < ip2.faceId) {\r\n        return -1;\r\n    }\r\n    if (ip1.faceId > ip2.faceId) {\r\n        return 1;\r\n    }\r\n    // same face - compare arc_length\r\n    if (ip1.arc_length < ip2.arc_length) {\r\n        return -1;\r\n    }\r\n    if (ip1.arc_length > ip2.arc_length) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction splitByIntersections(polygon, int_points)\r\n{\r\n    if (!int_points) return;\r\n    for (let int_point of int_points) {\r\n        let edge = int_point.edge_before;\r\n\r\n        // recalculate vertex flag: it may be changed after previous split\r\n        int_point.is_vertex = NOT_VERTEX;\r\n        if (edge.shape.start.equalTo(int_point.pt)) {\r\n            int_point.is_vertex |= START_VERTEX;\r\n        }\r\n        if (edge.shape.end.equalTo(int_point.pt)) {\r\n            int_point.is_vertex |= END_VERTEX;\r\n        }\r\n\r\n        if (int_point.is_vertex & START_VERTEX) {  // nothing to split\r\n            int_point.edge_before = edge.prev;\r\n            int_point.is_vertex = END_VERTEX;\r\n            continue;\r\n        }\r\n        if (int_point.is_vertex & END_VERTEX) {    // nothing to split\r\n            continue;\r\n        }\r\n\r\n        let newEdge = polygon.addVertex(int_point.pt, edge);\r\n        int_point.edge_before = newEdge;\r\n    }\r\n\r\n    for (let int_point of int_points) {\r\n        int_point.edge_after = int_point.edge_before.next;\r\n    }\r\n}\r\n\r\nfunction filterDuplicatedIntersections(intersections)\r\n{\r\n    if (intersections.int_points1.length < 2) return;\r\n\r\n    let do_squeeze = false;\r\n\r\n    let int_point_ref1;\r\n    let int_point_ref2;\r\n    let int_point_cur1;\r\n    let int_point_cur2;\r\n    for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\r\n\r\n        if (intersections.int_points1_sorted[i].id === -1)\r\n            continue;\r\n\r\n        int_point_ref1 = intersections.int_points1_sorted[i];\r\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\r\n\r\n        for (let j=i+1; j < intersections.int_points1_sorted.length; j++) {\r\n            int_point_cur1 = intersections.int_points1_sorted[j];\r\n            if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\r\n                break;\r\n            }\r\n            if (int_point_cur1.id === -1)\r\n                continue;\r\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\r\n            if (int_point_cur2.id === -1)\r\n                continue;\r\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n                int_point_cur1.id = -1;\r\n                /* to be deleted */\r\n                int_point_cur2.id = -1;\r\n                /* to be deleted */\r\n                do_squeeze = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    int_point_ref2 = intersections.int_points2_sorted[0];\r\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n    for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\r\n        let int_point_cur2 = intersections.int_points2_sorted[i];\r\n\r\n        if (int_point_cur2.id == -1) continue;\r\n        /* already deleted */\r\n\r\n        if (int_point_ref2.id == -1 || /* can't be reference if already deleted */\r\n            !(EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\r\n            int_point_ref2 = int_point_cur2;\r\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n            continue;\r\n        }\r\n\r\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\r\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n            int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n            int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n            int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n            int_point_cur1.id = -1;\r\n            /* to be deleted */\r\n            int_point_cur2.id = -1;\r\n            /* to be deleted */\r\n            do_squeeze = true;\r\n        }\r\n    }\r\n\r\n    if (do_squeeze) {\r\n        intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\r\n        intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\r\n\r\n        // update id's\r\n        intersections.int_points1.forEach((int_point, index) => int_point.id = index);\r\n        intersections.int_points2.forEach((int_point, index) => int_point.id = index);\r\n\r\n        // re-create sorted\r\n        intersections.int_points1_sorted = [];\r\n        intersections.int_points2_sorted = [];\r\n        sortIntersections(intersections);\r\n    }\r\n}\r\n\r\nfunction getNotIntersectedFaces(poly, int_points)\r\n{\r\n    let notIntersected = [];\r\n    for (let face of poly.faces) {\r\n        if (!int_points.find((ip) => ip.face === face)) {\r\n            notIntersected.push(face);\r\n        }\r\n    }\r\n    return notIntersected;\r\n}\r\n\r\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2)\r\n{\r\n    for (let face of notIntersectedFaces) {\r\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\r\n        face.first.setInclusion(poly2);\r\n    }\r\n}\r\n\r\nfunction initializeInclusionFlags(int_points)\r\n{\r\n    for (let int_point of int_points) {\r\n        int_point.edge_before.bvStart = undefined;\r\n        int_point.edge_before.bvEnd = undefined;\r\n        int_point.edge_before.bv = undefined;\r\n        int_point.edge_before.overlap = undefined;\r\n\r\n        int_point.edge_after.bvStart = undefined;\r\n        int_point.edge_after.bvEnd = undefined;\r\n        int_point.edge_after.bv = undefined;\r\n        int_point.edge_after.overlap = undefined;\r\n    }\r\n\r\n    for (let int_point of int_points) {\r\n        int_point.edge_before.bvEnd = BOUNDARY$1;\r\n        int_point.edge_after.bvStart = BOUNDARY$1;\r\n    }\r\n}\r\n\r\nfunction calculateInclusionFlags(int_points, polygon)\r\n{\r\n    for (let int_point of int_points) {\r\n        int_point.edge_before.setInclusion(polygon);\r\n        int_point.edge_after.setInclusion(polygon);\r\n    }\r\n}\r\n\r\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections )\r\n{\r\n    let cur_face;\r\n    let first_int_point_in_face_id;\r\n    let next_int_point1;\r\n    let num_int_points = int_points1_sorted.length;\r\n    let iterate_more = false;\r\n\r\n    for (let i = 0; i < num_int_points; i++) {\r\n        let cur_int_point1 = int_points1_sorted[i];\r\n\r\n        // Find boundary chain in the polygon1\r\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\r\n            first_int_point_in_face_id = i; // cur_int_point1;\r\n            cur_face = cur_int_point1.face;\r\n        }\r\n\r\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\r\n        let int_points_cur_pool_start = i;\r\n        let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\r\n        let next_int_point_id;\r\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\r\n            int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\r\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_id = first_int_point_in_face_id;\r\n        }\r\n\r\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\r\n        // has same face both in res_poly and in wrk_poly\r\n        let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\r\n        next_int_point1 = null;\r\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\r\n            let next_int_point1_tmp = int_points1_sorted[j];\r\n            if (next_int_point1_tmp.face === cur_face &&\r\n                int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\r\n                next_int_point1 = next_int_point1_tmp;\r\n                break;\r\n            }\r\n        }\r\n        if (next_int_point1 === null)\r\n            continue;\r\n\r\n        let edge_from1 = cur_int_point1.edge_after;\r\n        let edge_to1 = next_int_point1.edge_before;\r\n\r\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\r\n        if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv != BOUNDARY$1) {\r\n            edge_from1.bv = edge_to1.bv;\r\n            continue;\r\n        }\r\n\r\n        if (edge_from1.bv != BOUNDARY$1 && edge_to1.bv === BOUNDARY$1) {\r\n            edge_to1.bv = edge_from1.bv;\r\n            continue;\r\n        }\r\n\r\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\r\n        if ( (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1) ||\r\n        (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1  || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1 ) ) {\r\n            let edge_tmp = edge_from1.next;\r\n            while (edge_tmp != edge_to1) {\r\n                edge_tmp.bvStart = undefined;\r\n                edge_tmp.bvEnd = undefined;\r\n                edge_tmp.bv = undefined;\r\n                edge_tmp.setInclusion(poly2);\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n        }\r\n\r\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\r\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\r\n        if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1) {\r\n            let edge_tmp = edge_from1.next;\r\n            let new_bv;\r\n            while (edge_tmp != edge_to1) {\r\n                if (edge_tmp.bv != BOUNDARY$1) {\r\n                    if (new_bv === undefined) {        // first not boundary edge between from and to\r\n                        new_bv = edge_tmp.bv;\r\n                    }\r\n                    else {                            // another not boundary edge between from and to\r\n                        if (edge_tmp.bv != new_bv) {  // and it has different bv - can't resolve conflict\r\n                            throw Flatten.Errors.UNRESOLVED_BOUNDARY_CONFLICT;\r\n                        }\r\n                    }\r\n                }\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n\r\n            if (new_bv != undefined) {\r\n                edge_from1.bv = new_bv;\r\n                edge_to1.bv = new_bv;\r\n            }\r\n            continue;         // all middle edges are boundary, proceed with this\r\n        }\r\n\r\n        // Case 3. One of the ends is inner, another is outer\r\n        if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1  || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1 ) {\r\n            let edge_tmp = edge_from1;\r\n            // Find missing intersection point\r\n            while (edge_tmp != edge_to1) {\r\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\r\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\r\n                    if (dist < 10*Flatten.DP_TOL) {  // it should be very close\r\n                        // let pt = edge_tmp.end;\r\n                        // add to the list of intersections of poly1\r\n                        addToIntPoints(edge_tmp, segment.ps, int_points1);\r\n\r\n                        // split edge_tmp in poly1 if need\r\n                        let int_point1 = int_points1[int_points1.length-1];\r\n                        if (int_point1.is_vertex & START_VERTEX) {        // nothing to split\r\n                            int_point1.edge_after = edge_tmp;\r\n                            int_point1.edge_before = edge_tmp.prev;\r\n                            edge_tmp.bvStart = BOUNDARY$1;\r\n                            edge_tmp.bv = undefined;\r\n                            edge_tmp.setInclusion(poly2);\r\n                        }\r\n                        else if (int_point1.is_vertex & END_VERTEX) {    // nothing to split\r\n                            int_point1.edge_after = edge_tmp.next;\r\n                            edge_tmp.bvEnd = BOUNDARY$1;\r\n                            edge_tmp.bv = undefined;\r\n                            edge_tmp.setInclusion(poly2);\r\n                        }\r\n                        else {        // split edge here\r\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\r\n                            int_point1.edge_before = newEdge1;\r\n                            int_point1.edge_after = newEdge1.next;\r\n\r\n                            newEdge1.setInclusion(poly2);\r\n\r\n                            newEdge1.next.bvStart = BOUNDARY$1;\r\n                            newEdge1.next.bvEnd = undefined;\r\n                            newEdge1.next.bv = undefined;\r\n                            newEdge1.next.setInclusion(poly2);\r\n                        }\r\n\r\n                        // add to the list of intersections of poly2\r\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\r\n                        addToIntPoints(edge2, segment.pe, int_points2);\r\n                        // split edge2 in poly2 if need\r\n                        let int_point2 = int_points2[int_points2.length-1];\r\n                        if (int_point2.is_vertex & START_VERTEX) {        // nothing to split\r\n                            int_point2.edge_after = edge2;\r\n                            int_point2.edge_before = edge2.prev;\r\n                        }\r\n                        else if (int_point2.is_vertex & END_VERTEX) {    // nothing to split\r\n                            int_point2.edge_after = edge2.next;\r\n                        }\r\n                        else {        // split edge here\r\n                            // first locate int_points that may refer to edge2 as edge.after\r\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\r\n                            let int_point2_edge_after = int_points2.find( int_point => int_point.edge_after === edge2 );\r\n\r\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\r\n                            int_point2.edge_before = newEdge2;\r\n                            int_point2.edge_after = newEdge2.next;\r\n\r\n                            if (int_point2_edge_after)\r\n                                int_point2_edge_after.edge_after = newEdge2;\r\n\r\n                            newEdge2.bvStart = undefined;\r\n                            newEdge2.bvEnd = BOUNDARY$1;\r\n                            newEdge2.bv = undefined;\r\n                            newEdge2.setInclusion(poly1);\r\n\r\n                            newEdge2.next.bvStart = BOUNDARY$1;\r\n                            newEdge2.next.bvEnd = undefined;\r\n                            newEdge2.next.bv = undefined;\r\n                            newEdge2.next.setInclusion(poly1);\r\n                        }\r\n\r\n                        sortIntersections(intersections);\r\n\r\n                        iterate_more = true;\r\n                        break;\r\n                    }\r\n                }\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n\r\n            // we changed intersections inside loop, have to exit and repair again\r\n            if (iterate_more)\r\n                break;\r\n\r\n            throw Flatten.Errors.UNRESOLVED_BOUNDARY_CONFLICT;\r\n        }\r\n    }\r\n\r\n    return iterate_more;\r\n}\r\n\r\nfunction setOverlappingFlags(intersections)\r\n{\r\n    let cur_face = undefined;\r\n    let first_int_point_in_face_id = undefined;\r\n    let next_int_point1 = undefined;\r\n    let num_int_points = intersections.int_points1.length;\r\n\r\n    for (let i = 0; i < num_int_points; i++) {\r\n        let cur_int_point1 = intersections.int_points1_sorted[i];\r\n\r\n        // Find boundary chain in the polygon1\r\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\r\n            first_int_point_in_face_id = i; // cur_int_point1;\r\n            cur_face = cur_int_point1.face;\r\n        }\r\n\r\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\r\n        let int_points_cur_pool_start = i;\r\n        let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\r\n        let next_int_point_id;\r\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\r\n            intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\r\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_id = first_int_point_in_face_id;\r\n        }\r\n\r\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\r\n        // has same face both in res_poly and in wrk_poly\r\n        let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\r\n        next_int_point1 = null;\r\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\r\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\r\n            if (next_int_point1_tmp.face === cur_face &&\r\n                intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\r\n                next_int_point1 = next_int_point1_tmp;\r\n                break;\r\n            }\r\n        }\r\n        if (next_int_point1 === null)\r\n            continue;\r\n\r\n        let edge_from1 = cur_int_point1.edge_after;\r\n        let edge_to1 = next_int_point1.edge_before;\r\n\r\n        if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))      // not a boundary chain - skip\r\n            continue;\r\n\r\n        if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\r\n            continue;\r\n\r\n        /* Find boundary chain in polygon2 between same intersection points */\r\n        let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\r\n\r\n        let edge_from2 = cur_int_point2.edge_after;\r\n        let edge_to2 = next_int_point2.edge_before;\r\n\r\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\r\n        /* check also that chain consist of one or two edges */\r\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {\r\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\r\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n\r\n            edge_from2 = cur_int_point2.edge_after;\r\n            edge_to2 = next_int_point2.edge_before;\r\n        }\r\n\r\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2))\r\n            continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\r\n\r\n        // Set overlapping flag - one-to-one case\r\n        edge_from1.setOverlap(edge_from2);\r\n    }\r\n}\r\n\r\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon)\r\n{\r\n    if (!int_points) return;\r\n    let cur_face = undefined;\r\n    let first_int_point_in_face_num = undefined;\r\n    let int_point_current;\r\n    let int_point_next;\r\n\r\n    for (let i = 0; i < int_points.length; i++) {\r\n        int_point_current = int_points[i];\r\n\r\n        if (int_point_current.face !== cur_face) {   // next face started\r\n            first_int_point_in_face_num = i;\r\n            cur_face = int_point_current.face;\r\n        }\r\n\r\n        if (cur_face.isEmpty())                // ??\r\n            continue;\r\n\r\n        // Get next int point from the same face that current\r\n\r\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\r\n        let int_points_from_pull_start = i;\r\n        let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\r\n        let next_int_point_num;\r\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\r\n            int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\r\n            next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_num = first_int_point_in_face_num;\r\n        }\r\n        int_point_next = int_points[next_int_point_num];\r\n\r\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\r\n        let int_points_to_pull_start = next_int_point_num;\r\n        let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\r\n\r\n\r\n        let edge_from = int_point_current.edge_after;\r\n        let edge_to = int_point_next.edge_before;\r\n\r\n        if ((edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION) ||\r\n            (edge_from.bv === OUTSIDE$1 && edge_to.bv === OUTSIDE$1 && op === BOOLEAN_INTERSECT) ||\r\n            ((edge_from.bv === OUTSIDE$1 || edge_to.bv === OUTSIDE$1) && op === BOOLEAN_SUBTRACT && !is_res_polygon) ||\r\n            ((edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon) ||\r\n            (edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && (edge_from.overlap & OVERLAP_SAME$1) && is_res_polygon) ||\r\n            (edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && (edge_from.overlap & OVERLAP_OPPOSITE$1))) {\r\n\r\n            polygon.removeChain(cur_face, edge_from, edge_to);\r\n\r\n            /* update all points in \"points from\" pull */\r\n            for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\r\n                int_points[k].edge_after = undefined;\r\n            }\r\n\r\n            /* update all points in \"points to\" pull */\r\n            for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\r\n                int_points[k].edge_before = undefined;\r\n            }\r\n        }\r\n\r\n        /* skip to the last point in \"points from\" group */\r\n        i += int_points_from_pull_num - 1;\r\n    }\r\n}\r\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face)\r\n{\r\n    let int_point_current;\r\n    let int_point_next;\r\n\r\n    let int_points_pool_num = 1;\r\n\r\n    if (int_points.length == 1) return 1;\r\n\r\n    int_point_current = int_points[cur_int_point_num];\r\n\r\n    for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\r\n        if (int_point_current.face != cur_face) {      /* next face started */\r\n            break;\r\n        }\r\n\r\n        int_point_next = int_points[i];\r\n\r\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\r\n            int_point_next.edge_before === int_point_current.edge_before &&\r\n            int_point_next.edge_after === int_point_current.edge_after)) {\r\n            break;         /* next point is different - break and exit */\r\n        }\r\n\r\n        int_points_pool_num++;     /* duplicated intersection point - increase counter */\r\n    }\r\n    return int_points_pool_num;\r\n}\r\n\r\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points)\r\n{\r\n    for (let face of wrk_polygon.faces) {\r\n        for (let edge of face) {\r\n            res_polygon.edges.add(edge);\r\n        }\r\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\r\n        if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\r\n            int_points.find((ip) => (ip.face === face)) === undefined) {\r\n            res_polygon.addFace(face.first, face.last);\r\n        }\r\n    }\r\n}\r\n\r\nfunction swapLinks(res_polygon, wrk_polygon, intersections)\r\n{\r\n    if (intersections.int_points1.length === 0) return;\r\n\r\n    for (let i = 0; i < intersections.int_points1.length; i++) {\r\n        let int_point1 = intersections.int_points1[i];\r\n        let int_point2 = intersections.int_points2[i];\r\n\r\n        // Simple case - find continuation on the other polygon\r\n\r\n        // Process edge from res_polygon\r\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\r\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\r\n                // Connect edges\r\n                int_point1.edge_before.next = int_point2.edge_after;\r\n                int_point2.edge_after.prev = int_point1.edge_before;\r\n\r\n                // Fill in missed links in intersection points\r\n                int_point1.edge_after = int_point2.edge_after;\r\n                int_point2.edge_before = int_point1.edge_before;\r\n            }\r\n        }\r\n        // Process edge from wrk_polygon\r\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\r\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\r\n                // Connect edges\r\n                int_point2.edge_before.next = int_point1.edge_after;\r\n                int_point1.edge_after.prev = int_point2.edge_before;\r\n\r\n                // Complete missed links\r\n                int_point2.edge_after = int_point1.edge_after;\r\n                int_point1.edge_before = int_point2.edge_before;\r\n            }\r\n        }\r\n\r\n        // Continuation not found - complex case\r\n        // Continuation will be found on the same polygon.\r\n        // It happens when intersection point is actually touching point\r\n        // Polygon1\r\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\r\n            for (let int_point of intersections.int_points1_sorted) {\r\n                if (int_point === int_point1) continue;     // skip same\r\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                    if (int_point.pt.equalTo(int_point1.pt)) {\r\n                        // Connect edges\r\n                        int_point1.edge_before.next = int_point.edge_after;\r\n                        int_point.edge_after.prev = int_point1.edge_before;\r\n\r\n                        // Complete missed links\r\n                        int_point1.edge_after = int_point.edge_after;\r\n                        int_point.edge_before = int_point1.edge_before;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Polygon2\r\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\r\n            for (let int_point of intersections.int_points2_sorted) {\r\n                if (int_point === int_point2) continue;     // skip same\r\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                    if (int_point.pt.equalTo(int_point2.pt)) {\r\n                        // Connect edges\r\n                        int_point2.edge_before.next = int_point.edge_after;\r\n                        int_point.edge_after.prev = int_point2.edge_before;\r\n\r\n                        // Complete missed links\r\n                        int_point2.edge_after = int_point.edge_after;\r\n                        int_point.edge_before = int_point2.edge_before;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Sanity check that no dead ends left\r\n}\r\n\r\nfunction removeOldFaces(polygon, int_points)\r\n{\r\n    for (let int_point of int_points) {\r\n        polygon.faces.delete(int_point.face);\r\n        int_point.face = undefined;\r\n        if (int_point.edge_before)\r\n            int_point.edge_before.face = undefined;\r\n        if (int_point.edge_after)\r\n            int_point.edge_after.face = undefined;\r\n    }\r\n}\r\n\r\nfunction restoreFaces(polygon, int_points, other_int_points)\r\n{\r\n    // For each intersection point - create new face\r\n    for (let int_point of int_points) {\r\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\r\n            continue;\r\n        if (int_point.face)            // already restored\r\n            continue;\r\n\r\n        if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\r\n            continue;\r\n\r\n        let first = int_point.edge_after;      // face start\r\n        let last = int_point.edge_before;      // face end;\r\n\r\n        LinkedList.testInfiniteLoop(first);    // check and throw error if infinite loop found\r\n\r\n        let face = polygon.addFace(first, last);\r\n\r\n        // Mark intersection points from the newly create face\r\n        // to avoid multiple creation of the same face\r\n        // Face was assigned to each edge of new face in addFace function\r\n        for (let int_point_tmp of int_points) {\r\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                int_point_tmp.face = face;\r\n            }\r\n        }\r\n        // Mark other intersection points as well\r\n        for (let int_point_tmp of other_int_points) {\r\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                int_point_tmp.face = face;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon)\r\n{\r\n    for (let face of notIntersectedFaces) {\r\n        let rel = face.first.bv;\r\n        if (op === BOOLEAN_UNION && rel === INSIDE$1 ||\r\n            op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon ||\r\n            op === BOOLEAN_SUBTRACT && rel === OUTSIDE$1 && !is_res_polygon ||\r\n            op === BOOLEAN_INTERSECT && rel === OUTSIDE$1) {\r\n\r\n            polygon.deleteFace(face);\r\n        }\r\n    }\r\n}\r\n\r\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\r\n    BOOLEAN_UNION: BOOLEAN_UNION,\r\n    BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\r\n    BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\r\n    unify: unify,\r\n    subtract: subtract,\r\n    intersect: intersect,\r\n    innerClip: innerClip,\r\n    outerClip: outerClip,\r\n    calculateIntersections: calculateIntersections,\r\n    addToIntPoints: addToIntPoints,\r\n    getSortedArray: getSortedArray,\r\n    splitByIntersections: splitByIntersections,\r\n    filterDuplicatedIntersections: filterDuplicatedIntersections,\r\n    removeNotRelevantChains: removeNotRelevantChains,\r\n    removeOldFaces: removeOldFaces,\r\n    restoreFaces: restoreFaces\r\n});\r\n\r\n/*\r\n    Dimensionally extended 9-intersected model\r\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\r\n */\r\n// const DISJOINT = RegExp('FF.FF....');\r\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\r\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\r\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\r\nconst INSIDE$2 = RegExp('T.F..F...');\r\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\r\n\r\nclass DE9IM {\r\n    /**\r\n     * Create new instance of DE9IM matrix\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Array representing 3x3 intersection matrix\r\n         * @type {Shape[]}\r\n         */\r\n        this.m = new Array(9).fill(undefined);\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2I() {\r\n        return this.m[0];\r\n    }\r\n\r\n    /**\r\n     * Set Interior To Interior intersection\r\n     * @param geom\r\n     */\r\n    set I2I(geom) {\r\n        this.m[0] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2B() {\r\n        return this.m[1];\r\n    }\r\n\r\n    /**\r\n     * Set Interior to Boundary intersection\r\n     * @param geomc\r\n     */\r\n    set I2B(geom) {\r\n        this.m[1] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2E() {\r\n        return this.m[2];\r\n    }\r\n\r\n    /**\r\n     * Set Interior to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set I2E(geom) {\r\n        this.m[2] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2I() {\r\n        return this.m[3];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Interior intersection\r\n     * @param geom\r\n     */\r\n    set B2I(geom) {\r\n        this.m[3] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2B() {\r\n        return this.m[4];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Boundary intersection\r\n     * @param geom\r\n     */\r\n    set B2B(geom) {\r\n        this.m[4] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2E() {\r\n        return this.m[5];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set B2E(geom) {\r\n        this.m[5] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2I() {\r\n        return this.m[6];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Interior intersection\r\n     * @param geom\r\n     */\r\n    set E2I(geom) {\r\n        this.m[6] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2B() {\r\n        return this.m[7];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Boundary intersection\r\n     * @param geom\r\n     */\r\n    set E2B(geom) {\r\n        this.m[7] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior to Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2E() {\r\n        return this.m[8];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set E2E(geom) {\r\n        this.m[8] = geom;\r\n    }\r\n\r\n    /**\r\n     * Return de9im matrix as string where<br/>\r\n     * - intersection is 'T'<br/>\r\n     * - not intersected is 'F'<br/>\r\n     * - not relevant is '*'<br/>\r\n     * For example, string 'FF**FF****' means 'DISJOINT'\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        return this.m.map( e => {\r\n            if (e instanceof Array && e.length > 0) {\r\n                return 'T'\r\n            }\r\n            else if (e instanceof Array && e.length === 0) {\r\n                return 'F'\r\n            }\r\n            else {\r\n                return '*'\r\n            }\r\n        }).join(\"\")\r\n    }\r\n\r\n    equal() {\r\n        return EQUAL.test(this.toString());\r\n    }\r\n\r\n    intersect() {\r\n        return INTERSECT.test(this.toString());\r\n    }\r\n\r\n    touch() {\r\n        return TOUCH.test(this.toString());\r\n    }\r\n\r\n    inside() {\r\n        return INSIDE$2.test(this.toString());\r\n    }\r\n\r\n    covered() {\r\n        return COVERED.test(this.toString());\r\n    }\r\n}\r\n\r\n/**\r\n * Intersection\r\n *\r\n * */\r\n\r\nfunction intersectLine2Line(line1, line2) {\r\n    let ip = [];\r\n\r\n    let [A1, B1, C1] = line1.standard;\r\n    let [A2, B2, C2] = line2.standard;\r\n\r\n    /* Cramer's rule */\r\n    let det = A1 * B2 - B1 * A2;\r\n    let detX = C1 * B2 - B1 * C2;\r\n    let detY = A1 * C2 - C1 * A2;\r\n\r\n    if (!Flatten.Utils.EQ_0(det)) {\r\n        let x, y;\r\n\r\n        if (B1 === 0) {        // vertical line x  = C1/A1, where A1 == +1 or -1\r\n            x = C1/A1;\r\n            y = detY / det;\r\n        }\r\n        else if (B2 === 0) {   // vertical line x = C2/A2, where A2 = +1 or -1\r\n            x = C2/A2;\r\n            y = detY / det;\r\n        }\r\n        else if (A1 === 0) {   // horizontal line y = C1/B1, where B1 = +1 or -1\r\n            x = detX / det;\r\n            y = C1/B1;\r\n        }\r\n        else if (A2 === 0) {   // horizontal line y = C2/B2, where B2 = +1 or -1\r\n            x = detX / det;\r\n            y = C2/B2;\r\n        }\r\n        else {\r\n            x = detX / det;\r\n            y = detY / det;\r\n        }\r\n\r\n        ip.push(new Flatten.Point(x, y));\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Circle(line, circle) {\r\n    let ip = [];\r\n    let prj = circle.pc.projectionOn(line);            // projection of circle center on line\r\n    let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\r\n\r\n    if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\r\n        ip.push(prj);\r\n    } else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\r\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\r\n        let v_trans, pt;\r\n\r\n        v_trans = line.norm.rotate90CCW().multiply(delta);\r\n        pt = prj.translate(v_trans);\r\n        ip.push(pt);\r\n\r\n        v_trans = line.norm.rotate90CW().multiply(delta);\r\n        pt = prj.translate(v_trans);\r\n        ip.push(pt);\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Box(line, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Line(seg, line);\r\n        for (let pt of ips_tmp) {\r\n            if (!ptInIntPoints(pt, ips)) {\r\n                ips.push(pt);\r\n            }\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectLine2Arc(line, arc) {\r\n    let ip = [];\r\n\r\n    if (intersectLine2Box(line, arc.box).length === 0) {\r\n        return ip;\r\n    }\r\n\r\n    let circle = new Flatten.Circle(arc.pc, arc.r);\r\n    let ip_tmp = intersectLine2Circle(line, circle);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectSegment2Line(seg, line) {\r\n    let ip = [];\r\n\r\n    // Boundary cases\r\n    if (seg.ps.on(line)) {\r\n        ip.push(seg.ps);\r\n    }\r\n    // If both ends lay on line, return two intersection points\r\n    if (seg.pe.on(line) && !seg.isZeroLength()) {\r\n        ip.push(seg.pe);\r\n    }\r\n\r\n    if (ip.length > 0) {\r\n        return ip;          // done, intersection found\r\n    }\r\n\r\n    // If zero-length segment and nothing found, return no intersections\r\n    if (seg.isZeroLength()) {\r\n        return ip;\r\n    }\r\n\r\n    // Not a boundary case, check if both points are on the same side and\r\n    // hence there is no intersection\r\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\r\n        !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\r\n        return ip;\r\n    }\r\n\r\n    // Calculate intersection between lines\r\n    let line1 = new Flatten.Line(seg.ps, seg.pe);\r\n    return intersectLine2Line(line1, line);\r\n}\r\n\r\nfunction intersectSegment2Segment(seg1, seg2) {\r\n    let ip = [];\r\n\r\n    // quick reject\r\n    if (seg1.box.not_intersect(seg2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case of seg1 zero length\r\n    if (seg1.isZeroLength()) {\r\n        if (seg1.ps.on(seg2)) {\r\n            ip.push(seg1.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Special case of seg2 zero length\r\n    if (seg2.isZeroLength()) {\r\n        if (seg2.ps.on(seg1)) {\r\n            ip.push(seg2.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Neither seg1 nor seg2 is zero length\r\n    let line1 = new Flatten.Line(seg1.ps, seg1.pe);\r\n    let line2 = new Flatten.Line(seg2.ps, seg2.pe);\r\n\r\n    // Check overlapping between segments in case of incidence\r\n    // If segments touching, add one point. If overlapping, add two points\r\n    if (line1.incidentTo(line2)) {\r\n        if (seg1.ps.on(seg2)) {\r\n            ip.push(seg1.ps);\r\n        }\r\n        if (seg1.pe.on(seg2)) {\r\n            ip.push(seg1.pe);\r\n        }\r\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\r\n            ip.push(seg2.ps);\r\n        }\r\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\r\n            ip.push(seg2.pe);\r\n        }\r\n    } else {                /* not incident - parallel or intersect */\r\n        // Calculate intersection between lines\r\n        let new_ip = intersectLine2Line(line1, line2);\r\n        if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\r\n            ip.push(new_ip[0]);\r\n        }\r\n\r\n        // Fix missing intersection\r\n        // const tol = 10*Flatten.DP_TOL;\r\n        // if (ip.length === 0 && new_ip.length > 0 && (new_ip[0].distanceTo(seg1)[0] < tol || new_ip[0].distanceTo(seg2)[0] < tol) ) {\r\n        //     if (seg1.start.distanceTo(seg2)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        //     else if (seg1.end.distanceTo(seg2)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        //     else if (seg2.start.distanceTo(seg1)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        //     else if (seg2.end.distanceTo(seg1)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        // }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectSegment2Circle(segment, circle) {\r\n    let ips = [];\r\n\r\n    if (segment.box.not_intersect(circle.box)) {\r\n        return ips;\r\n    }\r\n\r\n    // Special case of zero length segment\r\n    if (segment.isZeroLength()) {\r\n        let [dist, shortest_segment] = segment.ps.distanceTo(circle.pc);\r\n        if (Flatten.Utils.EQ(dist, circle.r)) {\r\n            ips.push(segment.ps);\r\n        }\r\n        return ips;\r\n    }\r\n\r\n    // Non zero-length segment\r\n    let line = new Flatten.Line(segment.ps, segment.pe);\r\n\r\n    let ips_tmp = intersectLine2Circle(line, circle);\r\n\r\n    for (let ip of ips_tmp) {\r\n        if (ip.on(segment)) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n\r\n    return ips;\r\n}\r\n\r\nfunction intersectSegment2Arc(segment, arc) {\r\n    let ip = [];\r\n\r\n    if (segment.box.not_intersect(arc.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case of zero-length segment\r\n    if (segment.isZeroLength()) {\r\n        if (segment.ps.on(arc)) {\r\n            ip.push(segment.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Non-zero length segment\r\n    let line = new Flatten.Line(segment.ps, segment.pe);\r\n    let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n    let ip_tmp = intersectLine2Circle(line, circle);\r\n\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(segment) && pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n\r\n}\r\n\r\nfunction intersectSegment2Box(segment, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Segment(seg, segment);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectCircle2Circle(circle1, circle2) {\r\n    let ip = [];\r\n\r\n    if (circle1.box.not_intersect(circle2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    let vec = new Flatten.Vector(circle1.pc, circle2.pc);\r\n\r\n    let r1 = circle1.r;\r\n    let r2 = circle2.r;\r\n\r\n    // Degenerated circle\r\n    if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\r\n        return ip;\r\n\r\n    // In case of equal circles return one leftmost point\r\n    if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\r\n        ip.push(circle1.pc.translate(-r1, 0));\r\n        return ip;\r\n    }\r\n\r\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\r\n\r\n    if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\r\n        return ip;\r\n\r\n    if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\r\n        return ip;\r\n\r\n    // Normalize vector.\r\n    vec.x /= dist;\r\n    vec.y /= dist;\r\n\r\n    let pt;\r\n\r\n    // Case of touching from outside or from inside - single intersection point\r\n    // TODO: check this specifically not sure if correct\r\n    if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\r\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\r\n        ip.push(pt);\r\n        return ip;\r\n    }\r\n\r\n    // Case of two intersection points\r\n\r\n    // Distance from first center to center of common chord:\r\n    //   a = (r1^2 - r2^2 + d^2) / 2d\r\n    // Separate for better accuracy\r\n    let a = (r1 * r1) / (2 * dist) - (r2 * r2) / (2 * dist) + dist / 2;\r\n\r\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\r\n    let h = Math.sqrt(r1 * r1 - a * a);\r\n    // let norm;\r\n\r\n    // norm = vec.rotate90CCW().multiply(h);\r\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\r\n    ip.push(pt);\r\n\r\n    // norm = vec.rotate90CW();\r\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\r\n    ip.push(pt);\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectCircle2Box(circle, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Circle(seg, circle);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectArc2Arc(arc1, arc2) {\r\n    var ip = [];\r\n\r\n    if (arc1.box.not_intersect(arc2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case: overlapping arcs\r\n    // May return up to 4 intersection points\r\n    if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\r\n        let pt;\r\n\r\n        pt = arc1.start;\r\n        if (pt.on(arc2))\r\n            ip.push(pt);\r\n\r\n        pt = arc1.end;\r\n        if (pt.on(arc2))\r\n            ip.push(pt);\r\n\r\n        pt = arc2.start;\r\n        if (pt.on(arc1)) ip.push(pt);\r\n\r\n        pt = arc2.end;\r\n        if (pt.on(arc1)) ip.push(pt);\r\n\r\n        return ip;\r\n    }\r\n\r\n    // Common case\r\n    let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\r\n    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\r\n    let ip_tmp = circle1.intersect(circle2);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc1) && pt.on(arc2)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Circle(arc, circle) {\r\n    let ip = [];\r\n\r\n    if (arc.box.not_intersect(circle.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Case when arc center incident to circle center\r\n    // Return arc's end points as 2 intersection points\r\n    if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\r\n        ip.push(arc.start);\r\n        ip.push(arc.end);\r\n        return ip;\r\n    }\r\n\r\n    // Common case\r\n    let circle1 = circle;\r\n    let circle2 = new Flatten.Circle(arc.pc, arc.r);\r\n    let ip_tmp = intersectCircle2Circle(circle1, circle2);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Box(arc, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Arc(seg, arc);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectEdge2Segment(edge, segment) {\r\n    return edge.isSegment() ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\r\n}\r\n\r\nfunction intersectEdge2Arc(edge, arc) {\r\n    return edge.isSegment() ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\r\n}\r\n\r\nfunction intersectEdge2Line(edge, line) {\r\n    return edge.isSegment() ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\r\n}\r\n\r\nfunction intersectEdge2Circle(edge, circle) {\r\n    return edge.isSegment() ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\r\n}\r\n\r\nfunction intersectSegment2Polygon(segment, polygon) {\r\n    let ip = [];\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Segment(edge, segment)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Polygon(arc, polygon) {\r\n    let ip = [];\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Arc(edge, arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Polygon(line, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Line(edge, line)) {\r\n            if (!ptInIntPoints(pt, ip)) {\r\n                ip.push(pt);\r\n            }\r\n        }\r\n    }\r\n\r\n    return line.sortPoints(ip);\r\n}\r\n\r\nfunction intersectCircle2Polygon(circle, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Circle(edge, circle)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectEdge2Edge(edge1, edge2) {\r\n    const shape1 = edge1.shape;\r\n    const shape2 = edge2.shape;\r\n    return edge1.isSegment() ?\r\n        (edge2.isSegment() ? intersectSegment2Segment(shape1, shape2) : intersectSegment2Arc(shape1, shape2)) :\r\n        (edge2.isSegment() ? intersectSegment2Arc(shape2, shape1) : intersectArc2Arc(shape1, shape2));\r\n}\r\n\r\nfunction intersectEdge2Polygon(edge, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\r\n        return ip;\r\n    }\r\n\r\n    let resp_edges = polygon.edges.search(edge.shape.box);\r\n\r\n    for (let resp_edge of resp_edges) {\r\n        for (let pt of intersectEdge2Edge(edge, resp_edge)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\r\n    let ip = [];\r\n\r\n    if (polygon1.isEmpty() || polygon2.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    if (polygon1.box.not_intersect(polygon2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge1 of polygon1.edges) {\r\n        for (let pt of intersectEdge2Polygon(edge1, polygon2)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectShape2Polygon(shape, polygon) {\r\n    if (shape instanceof Flatten.Line) {\r\n        return intersectLine2Polygon(shape, polygon);\r\n    }\r\n    else if (shape instanceof Flatten.Segment) {\r\n        return intersectSegment2Polygon(shape, polygon);\r\n    }\r\n    else if (shape instanceof Flatten.Arc) {\r\n        return intersectArc2Polygon(shape, polygon);\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction ptInIntPoints(new_pt, ip) {\r\n    return ip.some( pt => pt.equalTo(new_pt) )\r\n}\r\n\r\n/**\r\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\r\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\r\n */\r\nclass Multiline extends LinkedList {\r\n    constructor(...args) {\r\n        super();\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length == 1) {\r\n            if (args[0] instanceof Array) {\r\n                let shapes = args[0];\r\n                if (shapes.length == 0)\r\n                    return;\r\n\r\n                // TODO: more strict validation:\r\n                // there may be only one line\r\n                // only first and last may be rays\r\n                let validShapes = shapes.every((shape) => {\r\n                    return shape instanceof Flatten.Segment ||\r\n                        shape instanceof Flatten.Arc ||\r\n                        shape instanceof Flatten.Ray ||\r\n                        shape instanceof Flatten.Line\r\n                });\r\n\r\n                for (let shape of shapes) {\r\n                    let edge = new Flatten.Edge(shape);\r\n                    this.append(edge);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (Getter) Return array of edges\r\n     * @returns {Edge[]}\r\n     */\r\n    get edges() {\r\n        return [...this];\r\n    }\r\n\r\n    /**\r\n     * (Getter) Return bounding box of the multiline\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.edges.reduce( (acc,edge) => acc = acc.merge(edge.box), new Flatten.Box() );\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns array of vertices\r\n     * @returns {Point[]}\r\n     */\r\n    get vertices() {\r\n        let v = this.edges.map(edge => edge.start);\r\n        v.push(this.last.end);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of Multiline\r\n     * @returns {Multiline}\r\n     */\r\n    clone() {\r\n        return new Multiline(this.toShapes());\r\n    }\r\n\r\n    /**\r\n     * Split edge and add new vertex, return new edge inserted\r\n     * @param {Point} pt - point on edge that will be added as new vertex\r\n     * @param {Edge} edge - edge to split\r\n     * @returns {Edge}\r\n     */\r\n    addVertex(pt, edge) {\r\n        let shapes = edge.shape.split(pt);\r\n        // if (shapes.length < 2) return;\r\n\r\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\r\n           return edge.prev;\r\n\r\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\r\n           return edge;\r\n\r\n        let newEdge = new Flatten.Edge(shapes[0]);\r\n        let edgeBefore = edge.prev;\r\n\r\n        /* Insert first split edge into linked list after edgeBefore */\r\n        this.insert(newEdge, edgeBefore);     // edge.face ?\r\n\r\n        // Update edge shape with second split edge keeping links\r\n        edge.shape = shapes[1];\r\n\r\n        return newEdge;\r\n    }\r\n\r\n    /**\r\n     * Split edges of multiline with intersection points and return mutated multiline\r\n     * @param {Point[]} ip - array of points to be added as new vertices\r\n     * @returns {Multiline}\r\n     */\r\n    split(ip) {\r\n        for (let pt of ip) {\r\n            let edge = this.findEdgeByPoint(pt);\r\n            this.addVertex(pt, edge);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns edge which contains given point\r\n     * @param {Point} pt\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edgeFound;\r\n        for (let edge of this) {\r\n            if (edge.shape.contains(pt)) {\r\n                edgeFound = edge;\r\n                break;\r\n            }\r\n        }\r\n        return edgeFound;\r\n    }\r\n\r\n    /**\r\n     * Returns new multiline translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Multiline}\r\n     */\r\n    translate(vec) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.translate(vec)));\r\n    }\r\n\r\n    /**\r\n     * Return new multiline rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - rotation center, default is (0,0)\r\n     * @returns {Multiline} - new rotated polygon\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.rotate(angle, center) ));\r\n    }\r\n\r\n    /**\r\n     * Return new multiline transformed using affine transformation matrix\r\n     * Method does not support unbounded shapes\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Multiline} - new multiline\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.transform(matrix)));\r\n    }\r\n\r\n    /**\r\n     * Transform multiline into array of shapes\r\n     * @returns {Shape[]}\r\n     */\r\n    toShapes() {\r\n        return this.edges.map(edge => edge.shape.clone())\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return this.edges.map(edge => edge.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Return string to draw multiline in svg\r\n     * @param attrs  - an object with attributes for svg path element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n     * TODO: support infinite Ray and Line\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\r\n        for (let edge of this) {\r\n            svgStr += edge.svg();\r\n        }\r\n        svgStr += ` z`;\r\n        svgStr += `\" >\\n</path>`;\r\n\r\n        return svgStr;\r\n    }\r\n}\r\n\r\nFlatten.Multiline = Multiline;\r\n\r\n/**\r\n * Shortcut function to create multiline\r\n * @param args\r\n */\r\nconst multiline = (...args) => new Flatten.Multiline(...args);\r\nFlatten.multiline = multiline;\r\n\r\n/**\r\n * @module RayShoot\r\n */\r\n\r\n/**\r\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\r\n * @param {Polgon} polygon - polygon to test\r\n * @param {Point} point - point to test\r\n * @returns {Flatten.Inside|Flatten.OUTSIDE|Flatten.Boundary}\r\n */\r\nfunction ray_shoot(polygon, point) {\r\n    let contains = undefined;\r\n\r\n    // 1. Quick reject\r\n    // if (polygon.box.not_intersect(point.box)) {\r\n    //     return Flatten.OUTSIDE;\r\n    // }\r\n\r\n    let ray = new Flatten.Ray(point);\r\n    let line = new Flatten.Line(ray.pt, ray.norm);\r\n\r\n    // 2. Locate relevant edges of the polygon\r\n    const searchBox = new Flatten.Box(\r\n        ray.box.xmin-Flatten.DP_TOL, ray.box.ymin-Flatten.DP_TOL,\r\n        ray.box.xmax, ray.box.ymax+Flatten.DP_TOL\r\n    );\r\n\r\n    if (polygon.box.not_intersect(searchBox)) {\r\n        return Flatten.OUTSIDE;\r\n    }\r\n\r\n    let resp_edges = polygon.edges.search(searchBox);\r\n\r\n    if (resp_edges.length == 0) {\r\n        return Flatten.OUTSIDE;\r\n    }\r\n\r\n    // 2.5 Check if boundary\r\n    for (let edge of resp_edges) {\r\n        if (edge.shape.contains(point)) {\r\n            return Flatten.BOUNDARY;\r\n        }\r\n    }\r\n\r\n    // 3. Calculate intersections\r\n    let intersections = [];\r\n    for (let edge of resp_edges) {\r\n        for (let ip of ray.intersect(edge.shape)) {\r\n\r\n            // If intersection is equal to query point then point lays on boundary\r\n            if (ip.equalTo(point)) {\r\n                return Flatten.BOUNDARY;\r\n            }\r\n\r\n            intersections.push({\r\n                pt: ip,\r\n                edge: edge\r\n            });\r\n        }\r\n    }\r\n\r\n    // 4. Sort intersection in x-ascending order\r\n    intersections.sort((i1, i2) => {\r\n        if (LT(i1.pt.x, i2.pt.x)) {\r\n            return -1;\r\n        }\r\n        if (GT(i1.pt.x, i2.pt.x)) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    });\r\n\r\n    // 5. Count real intersections, exclude touching\r\n    let counter = 0;\r\n\r\n    for (let i = 0; i < intersections.length; i++) {\r\n        let intersection = intersections[i];\r\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\r\n            /* skip same point between same edges if already counted */\r\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\r\n                intersection.edge.prev === intersections[i - 1].edge) {\r\n                continue;\r\n            }\r\n            let prev_edge = intersection.edge.prev;\r\n            while (EQ_0(prev_edge.length)) {\r\n                prev_edge = prev_edge.prev;\r\n            }\r\n            let prev_tangent = prev_edge.shape.tangentInEnd();\r\n            let prev_point = intersection.pt.translate(prev_tangent);\r\n\r\n            let cur_tangent = intersection.edge.shape.tangentInStart();\r\n            let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n            let prev_on_the_left = prev_point.leftTo(line);\r\n            let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n            if ((prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left)) {\r\n                counter++;\r\n            }\r\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\r\n            /* skip same point between same edges if already counted */\r\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\r\n                intersection.edge.next === intersections[i - 1].edge) {\r\n                continue;\r\n            }\r\n            let next_edge = intersection.edge.next;\r\n            while (EQ_0(next_edge.length)) {\r\n                next_edge = next_edge.next;\r\n            }\r\n            let next_tangent = next_edge.shape.tangentInStart();\r\n            let next_point = intersection.pt.translate(next_tangent);\r\n\r\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\r\n            let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n            let next_on_the_left = next_point.leftTo(line);\r\n            let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n            if ((next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left)) {\r\n                counter++;\r\n            }\r\n        } else {        /* intersection point is not a coincident with a vertex */\r\n            if (intersection.edge.shape instanceof Flatten.Segment) {\r\n                counter++;\r\n            } else {\r\n                /* Check if ray does not touch the curve in the extremal (top or bottom) point */\r\n                let box = intersection.edge.shape.box;\r\n                if (!(EQ(intersection.pt.y, box.ymin) ||\r\n                    EQ(intersection.pt.y, box.ymax))) {\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 6. Odd or even?\r\n    contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\r\n\r\n    return contains;\r\n}\r\n\r\n/*\r\n    Calculate relationship between two shapes and return result in the form of\r\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\r\n */\r\n\r\n/**\r\n * Returns true if shapes are topologically equal:  their interiors intersect and\r\n * no part of the interior or boundary of one geometry intersects the exterior of the other\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction equal(shape1, shape2) {\r\n    return relate(shape1, shape2).equal();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction intersect$1(shape1, shape2) {\r\n    return relate(shape1, shape2).intersect();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction touch(shape1, shape2) {\r\n    return relate(shape1, shape2).touch();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have no points in common neither in interior nor in boundary\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction disjoint(shape1, shape2) {\r\n    return !intersect$1(shape1, shape2);\r\n}\r\n\r\n/**\r\n * Returns true shape1 lies in the interior of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction inside(shape1, shape2) {\r\n    return relate(shape1, shape2).inside();\r\n}\r\n\r\n/**\r\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction covered(shape1, shape2) {\r\n    return  relate(shape1, shape2).covered();\r\n}\r\n\r\n/**\r\n * Returns true shape1's interior contains shape2 <br/>\r\n * Same as inside(shape2, shape1)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction contain(shape1, shape2) {\r\n    return inside(shape2, shape1);\r\n}\r\n\r\n/**\r\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction cover(shape1, shape2) {\r\n    return covered(shape2, shape1);\r\n}\r\n\r\n/**\r\n * Returns relation between two shapes as intersection 3x3 matrix, where each\r\n * element contains relevant intersection as array of shapes.\r\n * If there is no intersection, element contains empty array\r\n * If intersection is irrelevant it left undefined. (For example, intersection\r\n * between two exteriors is usually irrelevant)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {DE9IM}\r\n */\r\nfunction relate(shape1, shape2) {\r\n    if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\r\n        return relateLine2Line(shape1,  shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\r\n        return relateLine2Circle(shape1, shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\r\n        return relateLine2Box(shape1, shape2);\r\n    }\r\n    else if ( shape1 instanceof Flatten.Line  && shape2 instanceof Flatten.Polygon) {\r\n        return relateLine2Polygon(shape1, shape2);\r\n    }\r\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  && shape2 instanceof Flatten.Polygon) {\r\n        return relateShape2Polygon(shape1, shape2);\r\n    }\r\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  &&\r\n        (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box) ) {\r\n        return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\r\n    }\r\n    else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\r\n        return relatePolygon2Polygon(shape1, shape2);\r\n    }\r\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) &&\r\n        (shape2 instanceof  Flatten.Circle || shape2 instanceof Flatten.Box)) {\r\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\r\n    }\r\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\r\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\r\n        return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\r\n    }\r\n}\r\n\r\nfunction relateLine2Line(line1, line2) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Line(line1, line2);\r\n    if (ip.length === 0) {       // parallel or equal ?\r\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\r\n            denim.I2I = [line1];   // equal  'T.F...F..'  - no boundary\r\n            denim.I2E = [];\r\n            denim.E2I = [];\r\n        }\r\n        else {                     // parallel - disjoint 'FFTFF*T**'\r\n            denim.I2I = [];\r\n            denim.I2E = [line1];\r\n            denim.E2I = [line2];\r\n        }\r\n    }\r\n    else {                       // intersect   'T********'\r\n        denim.I2I = ip;\r\n        denim.I2E = line1.split(ip);\r\n        denim.E2I = line2.split(ip);\r\n    }\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Circle(line,circle) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Circle(line, circle);\r\n    if (ip.length === 0) {\r\n        denim.I2I = [];\r\n        denim.I2B = [];\r\n        denim.I2E = [line];\r\n        denim.E2I = [circle];\r\n    }\r\n    else if (ip.length === 1) {\r\n        denim.I2I = [];\r\n        denim.I2B = ip;\r\n        denim.I2E = line.split(ip);\r\n\r\n        denim.E2I = [circle];\r\n    }\r\n    else {       // ip.length == 2\r\n        let multiline = new Multiline([line]);\r\n        let ip_sorted = line.sortPoints(ip);\r\n        multiline.split(ip_sorted);\r\n        let splitShapes = multiline.toShapes();\r\n\r\n        denim.I2I = [splitShapes[1]];\r\n        denim.I2B = ip_sorted;\r\n        denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n        denim.E2I = new Flatten.Polygon([circle.toArc()]).cut(multiline);\r\n    }\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Box(line, box) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Box(line, box);\r\n    if (ip.length === 0) {\r\n        denim.I2I = [];\r\n        denim.I2B = [];\r\n        denim.I2E = [line];\r\n\r\n        denim.E2I = [box];\r\n    }\r\n    else if (ip.length === 1) {\r\n        denim.I2I = [];\r\n        denim.I2B = ip;\r\n        denim.I2E = line.split(ip);\r\n\r\n        denim.E2I = [box];\r\n    }\r\n    else {                     // ip.length == 2\r\n        let multiline = new Multiline([line]);\r\n        let ip_sorted = line.sortPoints(ip);\r\n        multiline.split(ip_sorted);\r\n        let splitShapes = multiline.toShapes();\r\n\r\n        /* Are two intersection points on the same segment of the box boundary ? */\r\n        if (box.toSegments().some( segment => segment.contains(ip[0]) && segment.contains(ip[1]) )) {\r\n            denim.I2I = [];                         // case of touching\r\n            denim.I2B = [splitShapes[1]];\r\n            denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n            denim.E2I = [box];\r\n        }\r\n        else {                                       // case of intersection\r\n            denim.I2I = [splitShapes[1]];            // [segment(ip[0], ip[1])];\r\n            denim.I2B = ip_sorted;\r\n            denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n            denim.E2I = new Flatten.Polygon(box.toSegments()).cut(multiline);\r\n        }\r\n    }\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Polygon(line, polygon) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Polygon(line, polygon);\r\n    let multiline = new Multiline([line]);\r\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\r\n\r\n    multiline.split(ip_sorted);\r\n\r\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\r\n\r\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\r\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\r\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\r\n\r\n    denim.E2I = polygon.cut(multiline);\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relateShape2Polygon(shape, polygon) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectShape2Polygon(shape, polygon);\r\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\r\n\r\n    let multiline = new Multiline([shape]);\r\n    multiline.split(ip_sorted);\r\n\r\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\r\n\r\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\r\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\r\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\r\n\r\n\r\n    denim.B2I = [];\r\n    denim.B2B = [];\r\n    denim.B2E = [];\r\n    for (let pt of [shape.start, shape.end]) {\r\n        switch (ray_shoot(polygon, pt)) {\r\n            case Flatten.INSIDE:\r\n                denim.B2I.push(pt);\r\n                break;\r\n            case Flatten.BOUNDARY:\r\n                denim.B2B.push(pt);\r\n                break;\r\n            case Flatten.OUTSIDE:\r\n                denim.B2E.push(pt);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    // denim.E2I  TODO: calculate, not clear what is expected result\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relatePolygon2Polygon(polygon1, polygon2) {\r\n    let denim = new DE9IM();\r\n\r\n    let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\r\n    let boolean_intersection = intersect(polygon1, polygon2);\r\n    let boolean_difference1 = subtract(polygon1, polygon2);\r\n    let boolean_difference2 = subtract(polygon2, polygon1);\r\n    let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\r\n    let outer_clip_shapes1 = outerClip(polygon1, polygon2);\r\n    let outer_clip_shapes2 = outerClip(polygon2, polygon1);\r\n\r\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\r\n    denim.I2B = inner_clip_shapes2;\r\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\r\n\r\n    denim.B2I = inner_clip_shapes1;\r\n    denim.B2B = ip_sorted1;\r\n    denim.B2E = outer_clip_shapes1;\r\n\r\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\r\n    denim.E2B = outer_clip_shapes2;\r\n    // denim.E2E    not relevant meanwhile\r\n\r\n    return denim;\r\n}\r\n\r\nvar Relations = /*#__PURE__*/Object.freeze({\r\n    equal: equal,\r\n    intersect: intersect$1,\r\n    touch: touch,\r\n    disjoint: disjoint,\r\n    inside: inside,\r\n    covered: covered,\r\n    contain: contain,\r\n    cover: cover,\r\n    relate: relate\r\n});\r\n\r\n/**\r\n * Class representing an affine transformation 3x3 matrix:\r\n * <pre>\r\n *      [ a  c  tx\r\n * A =    b  d  ty\r\n *        0  0  1  ]\r\n * </pre\r\n * @type {Matrix}\r\n */\r\nclass Matrix {\r\n    /**\r\n     * Construct new instance of affine transformation matrix <br/>\r\n     * If parameters omitted, construct identity matrix a = 1, d = 1\r\n     * @param {number} a - position(0,0)   sx*cos(alpha)\r\n     * @param {number} b - position (0,1)  sx*sin(alpha)\r\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\r\n     * @param {number} d - position (1,1)  sy*cos(alpha)\r\n     * @param {number} tx - position (2,0) translation by x\r\n     * @param {number} ty - position (2,1) translation by y\r\n     */\r\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of matrix\r\n     * @return {Matrix}\r\n     **/\r\n    clone() {\r\n        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\r\n    };\r\n\r\n    /**\r\n     * Transform vector [x,y] using transformation matrix. <br/>\r\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\r\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\r\n     * <code>\r\n     * [x'       [ ax + by + tx\r\n     *  y'   =     cx + dy + ty\r\n     *  1]                    1 ]\r\n     * </code>\r\n     * @param {number[]} vector - array[2] of numbers\r\n     * @returns {number[]} transformation result - array[2] of numbers\r\n     */\r\n    transform(vector) {\r\n        return [\r\n            vector[0] * this.a + vector[1] * this.c + this.tx,\r\n            vector[0] * this.b + vector[1] * this.d + this.ty\r\n        ]\r\n    };\r\n\r\n    /**\r\n     * Returns result of multiplication of this matrix by other matrix\r\n     * @param {Matrix} other_matrix - matrix to multiply by\r\n     * @returns {Matrix}\r\n     */\r\n    multiply(other_matrix) {\r\n        return new Matrix(\r\n            this.a * other_matrix.a + this.c * other_matrix.b,\r\n            this.b * other_matrix.a + this.d * other_matrix.b,\r\n            this.a * other_matrix.c + this.c * other_matrix.d,\r\n            this.b * other_matrix.c + this.d * other_matrix.d,\r\n            this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,\r\n            this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty\r\n        )\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix(1,0,0,1,tx,ty)\r\n     * @param {number} tx - translation by x\r\n     * @param {number} ty - translation by y\r\n     * @returns {Matrix}\r\n     */\r\n    translate(...args) {\r\n        let tx, ty;\r\n        if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n            tx = args[0].x;\r\n            ty = args[0].y;\r\n        } else if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n            tx = args[0];\r\n            ty = args[1];\r\n        } else {\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n        return this.multiply(new Matrix(1, 0, 0, 1, tx, ty))\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix that defines rotation by given angle (in radians) around\r\n     * point (0,0) in counter clockwise direction\r\n     * @param {number} angle - angle in radians\r\n     * @returns {Matrix}\r\n     */\r\n    rotate(angle) {\r\n        let cos = Math.cos(angle);\r\n        let sin = Math.sin(angle);\r\n        return this.multiply(new Matrix(cos, sin, -sin, cos, 0, 0));\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\r\n     * @param {number} sx\r\n     * @param {number} sy\r\n     * @returns {Matrix}\r\n     */\r\n    scale(sx, sy) {\r\n        return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\r\n    };\r\n\r\n    /**\r\n     * Returns true if two matrix are equal parameter by parameter\r\n     * @param {Matrix} matrix - other matrix\r\n     * @returns {boolean} true if equal, false otherwise\r\n     */\r\n    equalTo(matrix) {\r\n        if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\r\n        if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\r\n        if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\r\n        if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\r\n        if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\r\n        if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\r\n        return true;\r\n    };\r\n}\r\nFlatten.Matrix = Matrix;\r\n/**\r\n * Function to create matrix equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst matrix = (...args) => new Flatten.Matrix(...args);\r\nFlatten.matrix = matrix;\r\n\r\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n/**\r\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\r\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\r\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\r\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\r\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\r\n * This interface is described in typescript definition file *index.d.ts*\r\n *\r\n * Axis aligned rectangle is an example of such interval.\r\n * We may look at rectangle as an interval between its low left and top right corners.\r\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\r\n * of Interval interface implementation\r\n * @type {Interval}\r\n */\r\nconst Interval = class Interval {\r\n    /**\r\n     * Accept two comparable values and creates new instance of interval\r\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\r\n     * @param low\r\n     * @param high\r\n     */\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    /**\r\n     * Clone interval\r\n     * @returns {Interval}\r\n     */\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    /**\r\n     * Propery max returns clone of this interval\r\n     * @returns {Interval}\r\n     */\r\n    get max() {\r\n        return this.clone();   // this.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval less than other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval equals to other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval intersects other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval does not intersect other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    /**\r\n     * Returns new interval merged with other interval\r\n     * @param {Interval} interval - Other interval to merge with\r\n     * @returns {Interval}\r\n     */\r\n    merge(other_interval) {\r\n        return new Interval(\r\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\r\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns how key should return\r\n     */\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    /**\r\n     * Function returns maximum between two comparable values\r\n     * @param interval1\r\n     * @param interval2\r\n     * @returns {Interval}\r\n     */\r\n    static comparable_max(interval1, interval2) {\r\n        return interval1.merge(interval2);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if first value less than second value\r\n     * @param val1\r\n     * @param val2\r\n     * @returns {boolean}\r\n     */\r\n    static comparable_less_than(val1, val2 ) {\r\n        return val1 < val2;\r\n    }\r\n};\r\n\r\n/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n// module.exports = {\r\n//     RB_TREE_COLOR_RED: 0,\r\n//     RB_TREE_COLOR_BLACK: 1\r\n// };\r\n\r\nconst RB_TREE_COLOR_RED = 0;\r\nconst RB_TREE_COLOR_BLACK = 1;\r\n\r\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nclass Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.less_than(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_less_than = this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n                this.item.value < other_node.item.value;\r\n            return this.item.key.less_than(other_node.item.key) ||\r\n                this.item.key.equal_to((other_node.item.key)) && value_less_than;\r\n        }\r\n\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     let item_less_than = this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n        //         this.item.value < other_node.item.value;\r\n        //     return this.item.key.less_than(other_node.item.key) ||\r\n        //         this.item.key.equal_to((other_node.item.key)) && item_less_than;\r\n        // }\r\n        // else {\r\n        //     return this.item.key.less_than(other_node.item.key);\r\n        // }\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.equal_to(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_equal = this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n            return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n        }\r\n\r\n        // let value_equal = true;\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n        //         this.item.value == other_node.item.value;\r\n        // }\r\n        // return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key.clone();\r\n        this.item.value = other_node.item.value && other_node.item.value.clone ? other_node.item.value.clone() : other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\r\n        return comparable_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\r\n        return comparable_less_than(search_node.item.key.high, low);\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n\r\n// const nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\r\n * @type {IntervalTree}\r\n */\r\nclass IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n        this.nil_node = new Node();\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Returns array of sorted keys in the ascending order\r\n     * @returns {Array}\r\n     */\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(\r\n            node.item.key.output ? node.item.key.output() : node.item.key\r\n        ));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Return array of values in the ascending keys order\r\n     * @returns {Array}\r\n     */\r\n    get values() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns array of items (<key,value> pairs) in the ascended keys order\r\n     * @returns {Array}\r\n     */\r\n    get items() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push({\r\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\r\n            value: node.item.value\r\n        }));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns true if tree is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return (this.root == null || this.root == this.nil_node);\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param {Interval} key - interval object or array of two numbers [low, high]\r\n     * @param {any} value - value representing any object (optional)\r\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object to be checked\r\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object\r\n     * @returns {boolean} true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param {Interval} interval - search interval, or tuple [low, high]\r\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\r\n     * @returns {Array}\r\n     */\r\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersection between given and any interval stored in the tree found\r\n     * @param {Interval} interval - search interval or tuple [low, high]\r\n     * @returns {boolean}\r\n     */\r\n    intersect_any(interval) {\r\n        let search_node = new Node(interval);\r\n        let found = this.tree_find_any_interval(this.root, search_node);\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    }\r\n\r\n    /** Value Mapper. Walk through every node and map node value to another value\r\n    * @param callback(value,key) - function to be called for each tree item\r\n    */\r\n    map(callback) {\r\n        const tree = new IntervalTree();\r\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\r\n        return tree;\r\n    }\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == this.nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != this.nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != this.nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != this.nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == this.nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    tree_find_any_interval(node, search_node) {\r\n        let found = false;\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.left, search_node);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (!found) {\r\n                found = node.intersect(search_node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.right, search_node);\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != this.nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != this.nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != this.nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != this.nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != this.nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != this.nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.toArray());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != this.nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != this.nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\r\n\r\n/**\r\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n * Set properties and methods\r\n */\r\nclass PlanarSet extends Set {\r\n    /**\r\n     * Create new instance of PlanarSet\r\n     * @param shapes - array or set of geometric objects to store in planar set\r\n     * Each object should have a <b>box</b> property\r\n     */\r\n    constructor(shapes) {\r\n        super(shapes);\r\n        this.index = new IntervalTree();\r\n        this.forEach(shape => this.index.insert(shape));\r\n    }\r\n\r\n    /**\r\n     * Add new shape to planar set and to its spatial index.<br/>\r\n     * If shape already exist, it will not be added again.\r\n     * This happens with no error, it is possible to use <i>size</i> property to check if\r\n     * a shape was actually added.<br/>\r\n     * Method returns planar set object updated and may be chained\r\n     * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n     * @returns {PlanarSet}\r\n     */\r\n    add(shape) {\r\n        let size = this.size;\r\n        super.add(shape);\r\n        // size not changed - item not added, probably trying to add same item twice\r\n        if (this.size > size) {\r\n            let node = this.index.insert(shape.box, shape);\r\n        }\r\n        return this;         // in accordance to Set.add interface\r\n    }\r\n\r\n    /**\r\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n     * @param {Shape} shape - shape to be deleted\r\n     * @returns {boolean}\r\n     */\r\n    delete(shape) {\r\n        let deleted = super.delete(shape);\r\n        if (deleted) {\r\n            this.index.remove(shape.box, shape);\r\n        }\r\n        return deleted;\r\n    }\r\n\r\n    /**\r\n     * Clear planar set\r\n     */\r\n    clear() {\r\n        super.clear();\r\n        this.index = new IntervalTree();\r\n    }\r\n\r\n    /**\r\n     * 2d range search in planar set.<br/>\r\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n     * @param {Box} box - query box\r\n     * @returns {Shapes[]}\r\n     */\r\n    search(box) {\r\n        let resp = this.index.search(box);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * Point location test. Returns array of shapes which contains given point\r\n     * @param {Point} point - query point\r\n     * @returns {Array}\r\n     */\r\n    hit(point) {\r\n        let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\r\n        let resp = this.index.search(box);\r\n        return resp.filter((shape) => point.on(shape));\r\n    }\r\n\r\n    /**\r\n     * Returns svg string to draw all shapes in planar set\r\n     * @returns {String}\r\n     */\r\n    svg() {\r\n        let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\r\n        return svgcontent;\r\n    }\r\n}\r\n\r\nFlatten.PlanarSet = PlanarSet;\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n *\r\n * Class representing a point\r\n * @type {Point}\r\n */\r\nclass Point {\r\n    /**\r\n     * Point may be constructed by two numbers, or by array of two numbers\r\n     * @param {number} x - x-coordinate (float number)\r\n     * @param {number} y - y-coordinate (float number)\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * x-coordinate (float number)\r\n         * @type {number}\r\n         */\r\n        this.x = 0;\r\n        /**\r\n         * y-coordinate (float number)\r\n         * @type {number}\r\n         */\r\n        this.y = 0;\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n            let arr = args[0];\r\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\r\n                this.x = arr[0];\r\n                this.y = arr[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\r\n            let {x, y} = args[0];\r\n            this.x = x;\r\n            this.y = y;\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2) {\r\n            if (typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n                this.x = args[0];\r\n                this.y = args[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns bounding box of a point\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(this.x, this.y, this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of point\r\n     * @returns {Point}\r\n     */\r\n    clone() {\r\n        return new Flatten.Point(this.x, this.y);\r\n    }\r\n\r\n    get vertices() {\r\n        return [this.clone()];\r\n    }\r\n\r\n    /**\r\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(pt) {\r\n        return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\r\n    }\r\n\r\n    /**\r\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\r\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    lessThan(pt) {\r\n        if (Flatten.Utils.LT(this.y, pt.y))\r\n            return true;\r\n        if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns new point rotated by given angle around given center point.\r\n     * If center point is omitted, rotates around zero point (0,0).\r\n     * Positive value of angle defines rotation in counter clockwise direction,\r\n     * negative angle defines rotation in clockwise clockwise direction\r\n     * @param {number} angle - angle in radians\r\n     * @param {Point} [center=(0,0)] center\r\n     * @returns {Point}\r\n     */\r\n    rotate(angle, center = {x: 0, y: 0}) {\r\n        var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\r\n        var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\r\n\r\n        return new Flatten.Point(x_rot, y_rot);\r\n    }\r\n\r\n    /**\r\n     * Returns new point translated by given vector.\r\n     * Translation vector may by also defined by a pair of numbers.\r\n     * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n     * @param {number|number} - Translation vector defined as pair of numbers\r\n     * @returns {Point}\r\n     */\r\n    translate(...args) {\r\n        if (args.length == 1 &&\r\n            (args[0] instanceof Flatten.Vector || !isNaN(args[0].x) && !isNaN(args[0].y))) {\r\n            return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\r\n        }\r\n\r\n        if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n            return new Flatten.Point(this.x + args[0], this.y + args[1]);\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new point transformed by affine transformation matrix m\r\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n     * @returns {Point}\r\n     */\r\n    transform(m) {\r\n        // let [x,y] = m.transform([this.x,this.y]);\r\n        return new Flatten.Point(m.transform([this.x, this.y]))\r\n    }\r\n\r\n    /**\r\n     * Returns projection point on given line\r\n     * @param {Line} line Line this point be projected on\r\n     * @returns {Point}\r\n     */\r\n    projectionOn(line) {\r\n        if (this.equalTo(line.pt))                   // this point equal to line anchor point\r\n            return this.clone();\r\n\r\n        let vec = new Flatten.Vector(this, line.pt);\r\n        if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\r\n            return line.pt.clone();\r\n\r\n        let dist = vec.dot(line.norm);             // signed distance\r\n        let proj_vec = line.norm.multiply(dist);\r\n        return this.translate(proj_vec);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n     * @param {Line} line Query line\r\n     * @returns {boolean}\r\n     */\r\n    leftTo(line) {\r\n        let vec = new Flatten.Vector(line.pt, this);\r\n        let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\r\n        return onLeftSemiPlane;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from point to shape\r\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Point) {\r\n            let dx = shape.x - this.x;\r\n            let dy = shape.y - this.y;\r\n            return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return Flatten.Distance.point2line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return Flatten.Distance.point2circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return Flatten.Distance.point2segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            // let [dist, ...rest] = Distance.point2arc(this, shape);\r\n            // return dist;\r\n            return Flatten.Distance.point2arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            // let [dist, ...rest] = Distance.point2polygon(this, shape);\r\n            // return dist;\r\n            return Flatten.Distance.point2polygon(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            return Flatten.Distance.shape2planarSet(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if point is on a shape, false otherwise\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n     * @returns {boolean}\r\n     */\r\n    on(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.equalTo(shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return shape.contains(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"point\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n     * Accept any valid attributes of svg elements as svg object\r\n     * Defaults attribues are: <br/>\r\n     * {\r\n     *    r:\"3\",\r\n     *    stroke:\"black\",\r\n     *    strokeWidth:\"1\",\r\n     *    fill:\"red\"\r\n     * }\r\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n     * @returns {String}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {r, stroke, strokeWidth, fill, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\r\n    }\r\n\r\n}\r\nFlatten.Point = Point;\r\n/**\r\n * Function to create point equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst point = (...args) => new Flatten.Point(...args);\r\nFlatten.point = point;\r\n\r\n// export {Point};\r\n\r\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n/**\r\n * Class representing a vector\r\n * @type {Vector}\r\n */\r\nclass Vector {\r\n    /**\r\n     * Vector may be constructed by two points, or by two float numbers,\r\n     * or by array of two numbers\r\n     * @param {Point} ps - start point\r\n     * @param {Point} pe - end point\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * x-coordinate of a vector (float number)\r\n         * @type {number}\r\n         */\r\n        this.x = 0;\r\n        /**\r\n         * y-coordinate of a vector (float number)\r\n         * @type {number}\r\n         */\r\n        this.y = 0;\r\n\r\n        /* return zero vector */\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n            let arr = args[0];\r\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\r\n                this.x = arr[0];\r\n                this.y = arr[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\r\n            let {x, y} = args[0];\r\n            this.x = x;\r\n            this.y = y;\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2) {\r\n            let a1 = args[0];\r\n            let a2 = args[1];\r\n\r\n            if (typeof (a1) == \"number\" && typeof (a2) == \"number\") {\r\n                this.x = a1;\r\n                this.y = a2;\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                this.x = a2.x - a1.x;\r\n                this.y = a2.y - a1.y;\r\n                return;\r\n            }\r\n\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Method clone returns new instance of Vector\r\n     * @returns {Vector}\r\n     */\r\n    clone() {\r\n        return new Flatten.Vector(this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Slope of the vector in radians from 0 to 2PI\r\n     * @returns {number}\r\n     */\r\n    get slope() {\r\n        let angle = Math.atan2(this.y, this.x);\r\n        if (angle < 0) angle = 2 * Math.PI + angle;\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Length of vector\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return Math.sqrt(this.dot(this));\r\n    }\r\n\r\n    /**\r\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\r\n     * tolerance\r\n     * @param {Vector} v\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(v) {\r\n        return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\r\n    }\r\n\r\n    /**\r\n     * Returns new vector multiplied by scalar\r\n     * @param {number} scalar\r\n     * @returns {Vector}\r\n     */\r\n    multiply(scalar) {\r\n        return (new Flatten.Vector(scalar * this.x, scalar * this.y));\r\n    }\r\n\r\n    /**\r\n     * Returns scalar product (dot product) of two vectors <br/>\r\n     * <code>dot_product = (this * v)</code>\r\n     * @param {Vector} v Other vector\r\n     * @returns {number}\r\n     */\r\n    dot(v) {\r\n        return (this.x * v.x + this.y * v.y);\r\n    }\r\n\r\n    /**\r\n     * Returns vector product (cross product) of two vectors <br/>\r\n     * <code>cross_product = (this x v)</code>\r\n     * @param {Vector} v Other vector\r\n     * @returns {number}\r\n     */\r\n    cross(v) {\r\n        return (this.x * v.y - this.y * v.x);\r\n    }\r\n\r\n    /**\r\n     * Returns unit vector.<br/>\r\n     * Throw error if given vector has zero length\r\n     * @returns {Vector}\r\n     */\r\n    normalize() {\r\n        if (!Flatten.Utils.EQ_0(this.length)) {\r\n            return (new Flatten.Vector(this.x / this.length, this.y / this.length));\r\n        }\r\n        throw Flatten.Errors.ZERO_DIVISION;\r\n    }\r\n\r\n    /**\r\n     * Returns new vector rotated by given angle,\r\n     * positive angle defines rotation in counter clockwise direction,\r\n     * negative - in clockwise direction\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector}\r\n     */\r\n    rotate(angle) {\r\n        let point = new Flatten.Point(this.x, this.y);\r\n        let rpoint = point.rotate(angle);\r\n        return new Flatten.Vector(rpoint.x, rpoint.y);\r\n    }\r\n\r\n    /**\r\n     * Returns vector rotated 90 degrees counter clockwise\r\n     * @returns {Vector}\r\n     */\r\n    rotate90CCW() {\r\n        return new Flatten.Vector(-this.y, this.x);\r\n    };\r\n\r\n    /**\r\n     * Returns vector rotated 90 degrees clockwise\r\n     * @returns {Vector}\r\n     */\r\n    rotate90CW() {\r\n        return new Flatten.Vector(this.y, -this.x);\r\n    };\r\n\r\n    /**\r\n     * Return inverted vector\r\n     * @returns {Vector}\r\n     */\r\n    invert() {\r\n        return new Flatten.Vector(-this.x, -this.y);\r\n    }\r\n\r\n    /**\r\n     * Return result of addition of other vector to this vector as a new vector\r\n     * @param {Vector} v Other vector\r\n     * @returns {Vector}\r\n     */\r\n    add(v) {\r\n        return new Flatten.Vector(this.x + v.x, this.y + v.y);\r\n    }\r\n\r\n    /**\r\n     * Return result of subtraction of other vector from current vector as a new vector\r\n     * @param {Vector} v Another vector\r\n     * @returns {Vector}\r\n     */\r\n    subtract(v) {\r\n        return new Flatten.Vector(this.x - v.x, this.y - v.y);\r\n    }\r\n\r\n    /**\r\n     * Return angle between this vector and other vector. <br/>\r\n     * Angle is measured from 0 to 2*PI in the counter clockwise direction\r\n     * from current vector to other.\r\n     * @param {Vector} v Another vector\r\n     * @returns {number}\r\n     */\r\n    angleTo(v) {\r\n        let norm1 = this.normalize();\r\n        let norm2 = v.normalize();\r\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\r\n        if (angle < 0) angle += 2 * Math.PI;\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Return vector projection of the current vector on another vector\r\n     * @param {Vector} v Another vector\r\n     * @returns {Vector}\r\n     */\r\n    projectionOn(v) {\r\n        let n = v.normalize();\r\n        let d = this.dot(n);\r\n        return n.multiply(d);\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"vector\"});\r\n    }\r\n}\r\nFlatten.Vector = Vector;\r\n\r\n/**\r\n * Function to create vector equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst vector = (...args) => new Flatten.Vector(...args);\r\nFlatten.vector = vector;\r\n\r\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n/**\r\n * Class representing a segment\r\n * @type {Segment}\r\n */\r\nclass Segment {\r\n    /**\r\n     *\r\n     * @param {Point} ps - start point\r\n     * @param {Point} pe - end point\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Start point\r\n         * @type {Point}\r\n         */\r\n        this.ps = new Flatten.Point();\r\n        /**\r\n         * End Point\r\n         * @type {Point}\r\n         */\r\n        this.pe = new Flatten.Point();\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\r\n            let coords = args[0];\r\n            this.ps = new Flatten.Point(coords[0], coords[1]);\r\n            this.pe = new Flatten.Point(coords[2], coords[3]);\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\r\n            let {ps, pe} = args[0];\r\n            this.ps = new Flatten.Point(ps.x, ps.y);\r\n            this.pe = new Flatten.Point(pe.x, pe.y);\r\n            return;\r\n        }\r\n\r\n        // second point omitted issue #84\r\n        if (args.length === 1 && args[0] instanceof Flatten.Point) {\r\n            this.ps = args[0].clone();\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\r\n            this.ps = args[0].clone();\r\n            this.pe = args[1].clone();\r\n            return;\r\n        }\r\n\r\n        if (args.length === 4) {\r\n            this.ps = new Flatten.Point(args[0], args[1]);\r\n            this.pe = new Flatten.Point(args[2], args[3]);\r\n            return;\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of segment\r\n     * @returns {Segment}\r\n     */\r\n    clone() {\r\n        return new Flatten.Segment(this.start, this.end);\r\n    }\r\n\r\n    /**\r\n     * Start point\r\n     * @returns {Point}\r\n     */\r\n    get start() {\r\n        return this.ps;\r\n    }\r\n\r\n    /**\r\n     * End point\r\n     * @returns {Point}\r\n     */\r\n    get end() {\r\n        return this.pe;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns array of start and end point\r\n     * @returns [Point,Point]\r\n     */\r\n    get vertices() {\r\n        return [this.ps.clone(), this.pe.clone()];\r\n    }\r\n\r\n    /**\r\n     * Length of a segment\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return this.start.distanceTo(this.end)[0];\r\n    }\r\n\r\n    /**\r\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n     * @returns {number}\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.start, this.end);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Bounding box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            Math.min(this.start.x, this.end.x),\r\n            Math.min(this.start.y, this.end.y),\r\n            Math.max(this.start.x, this.end.x),\r\n            Math.max(this.start.y, this.end.y)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Returns true if equals to query segment, false otherwise\r\n     * @param {Seg} seg - query segment\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(seg) {\r\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\r\n    }\r\n\r\n    /**\r\n     * Returns true if segment contains point\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between segment and other shape\r\n     * @param {Shape} shape - Shape of the one of supported types <br/>\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectSegment2Line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return  intersectSegment2Segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectSegment2Circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectSegment2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectSegment2Arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return  intersectSegment2Polygon(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from segment to shape\r\n     * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns unit vector in the direction from start to end\r\n     * @returns {Vector}\r\n     */\r\n    tangentInStart() {\r\n        let vec = new Flatten.Vector(this.start, this.end);\r\n        return vec.normalize();\r\n    }\r\n\r\n    /**\r\n     * Return unit vector in the direction from end to start\r\n     * @returns {Vector}\r\n     */\r\n    tangentInEnd() {\r\n        let vec = new Flatten.Vector(this.end, this.start);\r\n        return vec.normalize();\r\n    }\r\n\r\n    /**\r\n     * Returns new segment with swapped start and end points\r\n     * @returns {Segment}\r\n     */\r\n    reverse() {\r\n        return new Segment(this.end, this.start);\r\n    }\r\n\r\n    /**\r\n     * When point belongs to segment, return array of two segments split by given point,\r\n     * if point is inside segment. Returns clone of this segment if query point is incident\r\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n     * @param {Point} pt Query point\r\n     * @returns {Segment[]}\r\n     */\r\n    split(pt) {\r\n        if (this.start.equalTo(pt))\r\n            return [null, this.clone()];\r\n\r\n        if (this.end.equalTo(pt))\r\n            return [this.clone(), null];\r\n\r\n        return [\r\n            new Flatten.Segment(this.start, pt),\r\n            new Flatten.Segment(pt, this.end)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Return middle point of the segment\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\r\n    }\r\n\r\n    distanceToPoint(pt) {\r\n        let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\r\n        return dist;\r\n    };\r\n\r\n    definiteIntegral(ymin = 0.0) {\r\n        let dx = this.end.x - this.start.x;\r\n        let dy1 = this.start.y - ymin;\r\n        let dy2 = this.end.y - ymin;\r\n        return (dx * (dy1 + dy2) / 2);\r\n    }\r\n\r\n    /**\r\n     * Returns new segment translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Segment}\r\n     */\r\n    translate(...args) {\r\n        return new Segment(this.ps.translate(...args), this.pe.translate(...args));\r\n    }\r\n\r\n    /**\r\n     * Return new segment rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - center point, default is (0,0)\r\n     * @returns {Segment}\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        let m = new Flatten.Matrix();\r\n        m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n        return this.transform(m);\r\n    }\r\n\r\n    /**\r\n     * Return new segment transformed using affine transformation matrix\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Segment} - transformed segment\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\r\n    }\r\n\r\n    /**\r\n     * Returns true if segment start is equal to segment end up to DP_TOL\r\n     * @returns {boolean}\r\n     */\r\n    isZeroLength() {\r\n        return this.ps.equalTo(this.pe)\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\r\n     * @param {Point[]} - array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        let line = new Flatten.Line(this.start, this.end);\r\n        return line.sortPoints(pts);\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"segment\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw segment in svg\r\n     * @param {Object} attrs - an object with attributes for svg path element,\r\n     * like \"stroke\", \"strokeWidth\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\r\n\r\n    }\r\n\r\n}\r\nFlatten.Segment = Segment;\r\n/**\r\n * Shortcut method to create new segment\r\n */\r\nconst segment = (...args) => new Flatten.Segment(...args);\r\nFlatten.segment = segment;\r\n\r\n/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\r\n\r\nlet {vector: vector$1} = Flatten;\r\n\r\n/**\r\n * Class representing a line\r\n * @type {Line}\r\n */\r\nclass Line {\r\n    /**\r\n     * Line may be constructed by point and normal vector or by two points that a line passes through\r\n     * @param {Point} pt - point that a line passes through\r\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Point a line passes through\r\n         * @type {Point}\r\n         */\r\n        this.pt = new Flatten.Point();\r\n        /**\r\n         * Normal vector to a line <br/>\r\n         * Vector is normalized (length == 1)<br/>\r\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\r\n         * @type {Vector}\r\n         */\r\n        this.norm = new Flatten.Vector(0, 1);\r\n\r\n        if (args.length == 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"line\") {\r\n            let {pt, norm} = args[0];\r\n            this.pt = new Flatten.Point(pt);\r\n            this.norm = new Flatten.Vector(norm);\r\n            return;\r\n        }\r\n\r\n        if (args.length == 2) {\r\n            let a1 = args[0];\r\n            let a2 = args[1];\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                this.pt = a1;\r\n                this.norm = Line.points2norm(a1, a2);\r\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\r\n                if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\r\n                    throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                }\r\n                this.pt = a1.clone();\r\n                this.norm = a2.clone();\r\n                this.norm = this.norm.normalize();\r\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\r\n                if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\r\n                    throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                }\r\n                this.pt = a2.clone();\r\n                this.norm = a1.clone();\r\n                this.norm = this.norm.normalize();\r\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of line\r\n     * @returns {Line}\r\n     */\r\n    clone() {\r\n        return new Flatten.Line(this.pt, this.norm);\r\n    }\r\n\r\n    /* The following methods need for implementation of Edge interface\r\n    /**\r\n     * Line has no start point\r\n     * @returns {undefined}\r\n     */\r\n    get start() {return undefined;}\r\n\r\n    /**\r\n     * Line has no end point\r\n     */\r\n    get end() {return undefined;}\r\n\r\n    /**\r\n     * Return positive infinity number as length\r\n     * @returns {number}\r\n     */\r\n    get length() {return Number.POSITIVE_INFINITY;}\r\n\r\n    /**\r\n     * Returns infinite box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            Number.NEGATIVE_INFINITY,\r\n            Number.NEGATIVE_INFINITY,\r\n            Number.POSITIVE_INFINITY,\r\n            Number.POSITIVE_INFINITY\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Middle point is undefined\r\n     * @returns {undefined}\r\n     */\r\n    get middle() {return undefined}\r\n\r\n    /**\r\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n     * @returns {number} - slope of the line\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n     * @code [A, B, C] = line.standard\r\n     * @returns {number[]} - array of coefficients\r\n     */\r\n    get standard() {\r\n        let A = this.norm.x;\r\n        let B = this.norm.y;\r\n        let C = this.norm.dot(this.pt);\r\n\r\n        return [A, B, C];\r\n    }\r\n\r\n    /**\r\n     * Return true if parallel or incident to other line\r\n     * @param {Line} other_line - line to check\r\n     * @returns {boolean}\r\n     */\r\n    parallelTo(other_line) {\r\n        return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\r\n    }\r\n\r\n    /**\r\n     * Returns true if incident to other line\r\n     * @param {Line} other_line - line to check\r\n     * @returns {boolean}\r\n     */\r\n    incidentTo(other_line) {\r\n        return this.parallelTo(other_line) && this.pt.on(other_line);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to line\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        if (this.pt.equalTo(pt)) {\r\n            return true;\r\n        }\r\n        /* Line contains point if vector to point is orthogonal to the line normal vector */\r\n        let vec = new Flatten.Vector(this.pt, pt);\r\n        return Flatten.Utils.EQ_0(this.norm.dot(vec));\r\n    }\r\n\r\n    /**\r\n     * Return coordinate of the point that lays on the line in the transformed\r\n     * coordinate system where center is the projection of the point(0,0) to\r\n     * the line and axe y is collinear to the normal vector. <br/>\r\n     * This method assumes that point lays on the line and does not check it\r\n     * @param {Point} pt - point on line\r\n     * @returns {number}\r\n     */\r\n    coord(pt) {\r\n        return vector$1(pt.x, pt.y).cross(this.norm);\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points\r\n     * @param {Shape} shape - shape to intersect with\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectLine2Circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectLine2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Line(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectLine2Arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return  intersectLine2Polygon(this, shape);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n     * @returns {Number}\r\n     * @returns {Segment}\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\r\n            return [distance, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\r\n            return [distance, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Split line with array of points and return array of shapes\r\n     * Assumed that all points lay on the line\r\n     * @param {Point[]}\r\n     * @returns {Shape[]}\r\n     */\r\n    split(pt) {\r\n        if (pt instanceof Flatten.Point) {\r\n            return [new Flatten.Ray(pt, this.norm.invert()), new Flatten.Ray(pt, this.norm)]\r\n        }\r\n        else {\r\n            let multiline = new Flatten.Multiline([this]);\r\n            let sorted_points = this.sortPoints(pt);\r\n            multiline.split(sorted_points);\r\n            return multiline.toShapes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points that lay on line with respect to coordinate on a line\r\n     * The method assumes that points lay on the line and does not check this\r\n     * @param {Point[]} pts - array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        return pts.slice().sort( (pt1, pt2) => {\r\n            if (this.coord(pt1) < this.coord(pt2)) {\r\n                return -1;\r\n            }\r\n            if (this.coord(pt1) > this.coord(pt2)) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"line\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw svg segment representing line inside given box\r\n     * @param {Box} box Box representing drawing area\r\n     * @param {Object} attrs - an object with attributes of svg circle element\r\n     */\r\n    svg(box, attrs = {}) {\r\n        let ip = intersectLine2Box(this, box);\r\n        if (ip.length === 0)\r\n            return \"\";\r\n        let ps = ip[0];\r\n        let pe = ip.length == 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\r\n        if (pe === undefined) pe = ps;\r\n        let segment = new Flatten.Segment(ps, pe);\r\n        return segment.svg(attrs);\r\n    }\r\n\r\n    static points2norm(pt1, pt2) {\r\n        if (pt1.equalTo(pt2)) {\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n        let vec = new Flatten.Vector(pt1, pt2);\r\n        let unit = vec.normalize();\r\n        return unit.rotate90CCW();\r\n    }\r\n}\r\nFlatten.Line = Line;\r\n/**\r\n * Function to create line equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst line = (...args) => new Flatten.Line(...args);\r\nFlatten.line = line;\r\n\r\n/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\r\n\r\n/**\r\n * Class representing a circle\r\n * @type {Circle}\r\n */\r\nclass Circle {\r\n    /**\r\n     *\r\n     * @param {Point} pc - circle center point\r\n     * @param {number} r - circle radius\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Circle center\r\n         * @type {Point}\r\n         */\r\n        this.pc = new Flatten.Point();\r\n        /**\r\n         * Circle radius\r\n         * @type {number}\r\n         */\r\n        this.r = 1;\r\n\r\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"circle\") {\r\n            let {pc, r} = args[0];\r\n            this.pc = new Flatten.Point(pc);\r\n            this.r = r;\r\n            return;\r\n        } else {\r\n            let [pc, r] = [...args];\r\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n            if (r !== undefined) this.r = r;\r\n            return;\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of circle\r\n     * @returns {Circle}\r\n     */\r\n    clone() {\r\n        return new Flatten.Circle(this.pc.clone(), this.r);\r\n    }\r\n\r\n    /**\r\n     * Circle center\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return this.pc;\r\n    }\r\n\r\n    /**\r\n     * Circle bounding box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            this.pc.x - this.r,\r\n            this.pc.y - this.r,\r\n            this.pc.x + this.r,\r\n            this.pc.y + this.r\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Return true if circle contains shape: no point of shape lies outside of the circle\r\n     * @param {Shape} shape - test shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\r\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return this.intersect(shape).length === 0 &&\r\n                Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\r\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return this.intersect(shape).length === 0 &&\r\n                Flatten.Utils.LE(shape.r, this.r) &&\r\n                Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        /* TODO: box, polygon */\r\n    }\r\n\r\n    /**\r\n     * Transform circle to closed arc\r\n     * @param {boolean} counterclockwise\r\n     * @returns {Arc}\r\n     */\r\n    toArc(counterclockwise = true) {\r\n        return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between circle and other shape\r\n     * @param {Shape} shape Shape of the one of supported types\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectCircle2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectCircle2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Circle(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectCircle2Polygon(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from circle to shape\r\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"circle\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw circle in svg\r\n     * @param {Object} attrs - an object with attributes of svg circle element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\r\n    }\r\n\r\n}\r\nFlatten.Circle = Circle;\r\n/**\r\n * Shortcut to create new circle\r\n * @param args\r\n */\r\nconst circle = (...args) => new Flatten.Circle(...args);\r\nFlatten.circle = circle;\r\n\r\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n/**\r\n * Class representing a circular arc\r\n * @type {Arc}\r\n */\r\nclass Arc {\r\n    /**\r\n     *\r\n     * @param {Point} pc - arc center\r\n     * @param {number} r - arc radius\r\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counter clockwise\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Arc center\r\n         * @type {Point}\r\n         */\r\n        this.pc = new Flatten.Point();\r\n        /**\r\n         * Arc radius\r\n         * @type {number}\r\n         */\r\n        this.r = 1;\r\n        /**\r\n         * Arc start angle in radians\r\n         * @type {number}\r\n         */\r\n        this.startAngle = 0;\r\n        /**\r\n         * Arc end angle in radians\r\n         * @type {number}\r\n         */\r\n        this.endAngle = 2 * Math.PI;\r\n        /**\r\n         * Arc orientation\r\n         * @type {boolean}\r\n         */\r\n        this.counterClockwise = Flatten.CCW;\r\n\r\n        if (args.length == 0)\r\n            return;\r\n\r\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"arc\") {\r\n            let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\r\n            this.pc = new Flatten.Point(pc.x, pc.y);\r\n            this.r = r;\r\n            this.startAngle = startAngle;\r\n            this.endAngle = endAngle;\r\n            this.counterClockwise = counterClockwise;\r\n            return;\r\n        } else {\r\n            let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\r\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n            if (r !== undefined) this.r = r;\r\n            if (startAngle !== undefined) this.startAngle = startAngle;\r\n            if (endAngle !== undefined) this.endAngle = endAngle;\r\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\r\n            return;\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of arc\r\n     * @returns {Arc}\r\n     */\r\n    clone() {\r\n        return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n    }\r\n\r\n    /**\r\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n     * @returns {number}\r\n     */\r\n    get sweep() {\r\n        if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\r\n            return 0.0;\r\n        if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\r\n            return Flatten.PIx2;\r\n        }\r\n        let sweep;\r\n        if (this.counterClockwise) {\r\n            sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\r\n                this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\r\n        } else {\r\n            sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\r\n                this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\r\n        }\r\n\r\n        if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\r\n            sweep -= Flatten.PIx2;\r\n        }\r\n        if (Flatten.Utils.LT(sweep, 0)) {\r\n            sweep += Flatten.PIx2;\r\n        }\r\n        return sweep;\r\n    }\r\n\r\n    /**\r\n     * Get start point of arc\r\n     * @returns {Point}\r\n     */\r\n    get start() {\r\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n        return p0.rotate(this.startAngle, this.pc);\r\n    }\r\n\r\n    /**\r\n     * Get end point of arc\r\n     * @returns {Point}\r\n     */\r\n    get end() {\r\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n        return p0.rotate(this.endAngle, this.pc);\r\n    }\r\n\r\n    /**\r\n     * Get center of arc\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return this.pc.clone();\r\n    }\r\n\r\n    get vertices() {\r\n        return [this.start.clone(), this.end.clone()];\r\n    }\r\n\r\n    /**\r\n     * Get arc length\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return Math.abs(this.sweep * this.r);\r\n    }\r\n\r\n    /**\r\n     * Get bounding box of the arc\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        let func_arcs = this.breakToFunctional();\r\n        let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\r\n        box = box.merge(this.end.box);\r\n        return box;\r\n    }\r\n\r\n    /**\r\n     * Returns true if arc contains point, false otherwise\r\n     * @param {Point} pt - point to test\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        // first check if  point on circle (pc,r)\r\n        if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\r\n            return false;\r\n\r\n        // point on circle\r\n\r\n        if (pt.equalTo(this.start))\r\n            return true;\r\n\r\n        let angle = new Flatten.Vector(this.pc, pt).slope;\r\n        let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\r\n        return Flatten.Utils.LE(test_arc.length, this.length);\r\n    }\r\n\r\n    /**\r\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n     * empty array.\r\n     * @param {Point} pt Query point\r\n     * @returns {Arc[]}\r\n     */\r\n    split(pt) {\r\n        if (this.start.equalTo(pt))\r\n            return [null, this.clone()];\r\n\r\n        if (this.end.equalTo(pt))\r\n            return [this.clone(), null];\r\n\r\n        let angle = new Flatten.Vector(this.pc, pt).slope;\r\n\r\n        return [\r\n            new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\r\n            new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Return middle point of the arc\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\r\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n        return arc.end;\r\n    }\r\n\r\n    /**\r\n     * Returns chord height (\"sagitta\") of the arc\r\n     * @returns {number}\r\n     */\r\n    chordHeight() {\r\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between arc and other shape\r\n     * @param {Shape} shape Shape of the one of supported types <br/>\r\n     * @returns {Points[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Arc(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectArc2Circle(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Arc(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectArc2Box(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Arc(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectArc2Polygon(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from arc to shape\r\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n     * @returns {Arcs[]}\r\n     */\r\n    breakToFunctional() {\r\n        let func_arcs_array = [];\r\n        let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\r\n        let pts = [\r\n            this.pc.translate(this.r, 0),\r\n            this.pc.translate(0, this.r),\r\n            this.pc.translate(-this.r, 0),\r\n            this.pc.translate(0, -this.r)\r\n        ];\r\n\r\n        // If arc contains extreme point,\r\n        // create test arc started at start point and ended at this extreme point\r\n        let test_arcs = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            if (pts[i].on(this)) {\r\n                test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\r\n            }\r\n        }\r\n\r\n        if (test_arcs.length == 0) {                  // arc does contain any extreme point\r\n            func_arcs_array.push(this.clone());\r\n        } else {                                        // arc passes extreme point\r\n            // sort these arcs by length\r\n            test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\r\n\r\n            for (let i = 0; i < test_arcs.length; i++) {\r\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                let new_arc;\r\n                if (prev_arc) {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                } else {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                }\r\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                    func_arcs_array.push(new_arc.clone());\r\n                }\r\n            }\r\n\r\n            // add last sub arc\r\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n            let new_arc;\r\n            if (prev_arc) {\r\n                new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\r\n            } else {\r\n                new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n            }\r\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\r\n            if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2*Math.PI)) {\r\n                func_arcs_array.push(new_arc.clone());\r\n            }\r\n        }\r\n        return func_arcs_array;\r\n    }\r\n\r\n    /**\r\n     * Return tangent unit vector in the start point in the direction from start to end\r\n     * @returns {Vector}\r\n     */\r\n    tangentInStart() {\r\n        let vec = new Flatten.Vector(this.pc, this.start);\r\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\r\n        let tangent = vec.rotate(angle).normalize();\r\n        return tangent;\r\n    }\r\n\r\n    /**\r\n     * Return tangent unit vector in the end point in the direction from end to start\r\n     * @returns {Vector}\r\n     */\r\n    tangentInEnd() {\r\n        let vec = new Flatten.Vector(this.pc, this.end);\r\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\r\n        let tangent = vec.rotate(angle).normalize();\r\n        return tangent;\r\n    }\r\n\r\n    /**\r\n     * Returns new arc with swapped start and end angles and reversed direction\r\n     * @returns {Arc}\r\n     */\r\n    reverse() {\r\n        return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\r\n    }\r\n\r\n    /**\r\n     * Returns new arc translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Segment}\r\n     */\r\n    translate(...args) {\r\n        let arc = this.clone();\r\n        arc.pc = this.pc.translate(...args);\r\n        return arc;\r\n    }\r\n\r\n    /**\r\n     * Return new segment rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - center point, default is (0,0)\r\n     * @returns {Arc}\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        let m = new Flatten.Matrix();\r\n        m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n        return this.transform(m);\r\n    }\r\n\r\n    /**\r\n     * Return new arc scaled by scaleX, scaleY.\r\n     * @param {number} scaleX - scale value by X\r\n     * @param {number} scaleY - scale value by Y\r\n     * @returns {Arc}\r\n     */\r\n    scale(scaleX = 1, scaleY = 1) {\r\n        let m = new Flatten.Matrix();\r\n        m = m.scale(scaleX, scaleY);\r\n        return this.transform(m);\r\n    }\r\n\r\n    /**\r\n     * Return new arc transformed using affine transformation matrix <br/>\r\n     * Note 1. Non-equal scaling by x and y (abs(matrix[0]) != abs(matrix[3])) produce illegal result because\r\n     * it should create elliptic arc but this package does not support ellipses\r\n     * Note 2. Mirror transformation (matrix[0] * matrix[3] < 0) change direction of the arc to the opposite\r\n     * TODO: support non-equal scaling arc to ellipse or throw exception ?\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Arc}\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        let newStart = this.start.transform(matrix);\r\n        let newEnd = this.end.transform(matrix);\r\n        let newCenter = this.pc.transform(matrix);\r\n        let newDirection = this.counterClockwise;\r\n        if (matrix.a * matrix.d < 0) {\r\n          newDirection = !newDirection;\r\n        }\r\n        let arc = Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\r\n        return arc;\r\n    }\r\n\r\n    static arcSE(center, start, end, counterClockwise) {\r\n        let {vector} = Flatten;\r\n        let startAngle = vector(center, start).slope;\r\n        let endAngle = vector(center, end).slope;\r\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n            endAngle += 2 * Math.PI;\r\n            counterClockwise = true;\r\n        }\r\n        let r = vector(center, start).length;\r\n\r\n        return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\r\n    }\r\n\r\n    definiteIntegral(ymin = 0) {\r\n        let f_arcs = this.breakToFunctional();\r\n        let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\r\n        return area;\r\n    }\r\n\r\n    circularSegmentDefiniteIntegral(ymin) {\r\n        let line = new Flatten.Line(this.start, this.end);\r\n        let onLeftSide = this.pc.leftTo(line);\r\n        let segment = new Flatten.Segment(this.start, this.end);\r\n        let areaTrapez = segment.definiteIntegral(ymin);\r\n        let areaCircularSegment = this.circularSegmentArea();\r\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\r\n        return area;\r\n    }\r\n\r\n    circularSegmentArea() {\r\n        return (0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep)))\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\r\n     * @param {Point[]} array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        let {vector} = Flatten;\r\n        return pts.slice().sort( (pt1, pt2) => {\r\n            let slope1 = vector(this.pc, pt1).slope;\r\n            let slope2 = vector(this.pc, pt2).slope;\r\n            if (slope1 < slope2) {\r\n                return -1;\r\n            }\r\n            if (slope1 > slope2) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"arc\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw arc in svg\r\n     * @param {Object} attrs - an object with attributes of svg path element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\r\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\r\n        let {stroke, strokeWidth, fill, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\r\n            let circle = new Flatten.Circle(this.pc, this.r);\r\n            return circle.svg(attrs);\r\n        } else {\r\n            return `\\n<path d=\"M${this.start.x},${this.start.y}\r\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\r\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\r\n        }\r\n    }\r\n\r\n}\r\nFlatten.Arc = Arc;\r\n/**\r\n * Function to create arc equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst arc = (...args) => new Flatten.Arc(...args);\r\nFlatten.arc = arc;\r\n\r\n/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\r\n/**\r\n * Class Box represent bounding box of the shape\r\n * @type {Box}\r\n */\r\nclass Box {\r\n    /**\r\n     *\r\n     * @param {number} xmin - minimal x coordinate\r\n     * @param {number} ymin - minimal y coordinate\r\n     * @param {number} xmax - maximal x coordinate\r\n     * @param {number} ymax - maximal y coordinate\r\n     */\r\n    constructor(xmin = undefined, ymin = undefined, xmax = undefined, ymax = undefined) {\r\n        /**\r\n         * Minimal x coordinate\r\n         * @type {number}\r\n         */\r\n        this.xmin = xmin;\r\n        /**\r\n         * Minimal y coordinate\r\n         * @type {number}\r\n         */\r\n        this.ymin = ymin;\r\n        /**\r\n         * Maximal x coordinate\r\n         * @type {number}\r\n         */\r\n        this.xmax = xmax;\r\n        /**\r\n         * Maximal y coordinate\r\n         * @type {number}\r\n         */\r\n        this.ymax = ymax;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of box\r\n     * @returns {Box}\r\n     */\r\n    clone() {\r\n        return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\r\n    }\r\n\r\n    /**\r\n     * Property low need for interval tree interface\r\n     * @returns {Point}\r\n     */\r\n    get low() {\r\n        return new Flatten.Point(this.xmin, this.ymin);\r\n    }\r\n\r\n    /**\r\n     * Property high need for interval tree interface\r\n     * @returns {Point}\r\n     */\r\n    get high() {\r\n        return new Flatten.Point(this.xmax, this.ymax);\r\n    }\r\n\r\n    /**\r\n     * Property max returns the box itself !\r\n     * @returns {Box}\r\n     */\r\n    get max() {\r\n        return this.clone();\r\n    }\r\n\r\n    /**\r\n     * Return center of the box\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\r\n    }\r\n\r\n    /**\r\n     * Return property box like all other shapes\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if not intersected with other box\r\n     * @param {Box} other_box - other box to test\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_box) {\r\n        return (\r\n            this.xmax < other_box.xmin ||\r\n            this.xmin > other_box.xmax ||\r\n            this.ymax < other_box.ymin ||\r\n            this.ymin > other_box.ymax\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersected with other box\r\n     * @param {Box} other_box - Query box\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_box) {\r\n        return !this.not_intersect(other_box);\r\n    }\r\n\r\n    /**\r\n     * Returns new box merged with other box\r\n     * @param {Box} other_box - Other box to merge with\r\n     * @returns {Box}\r\n     */\r\n    merge(other_box) {\r\n        return new Box(\r\n            this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\r\n            this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\r\n            this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\r\n            this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines predicate \"less than\" between two boxes. Need for interval index\r\n     * @param {Box} other_box - other box\r\n     * @returns {boolean} - true if this box less than other box, false otherwise\r\n     */\r\n    less_than(other_box) {\r\n        if (this.low.lessThan(other_box.low))\r\n            return true;\r\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this box is equal to other box, false otherwise\r\n     * @param {Box} other_box - query box\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_box) {\r\n        return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\r\n    }\r\n\r\n    output() {\r\n        return this.clone();\r\n    }\r\n\r\n    static comparable_max(box1, box2) {\r\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\r\n        return box1.merge(box2);\r\n    }\r\n\r\n    static comparable_less_than(pt1, pt2) {\r\n        return pt1.lessThan(pt2);\r\n    }\r\n\r\n    /**\r\n     * Set new values to the box object\r\n     * @param {number} xmin - miminal x coordinate\r\n     * @param {number} ymin - minimal y coordinate\r\n     * @param {number} xmax - maximal x coordinate\r\n     * @param {number} ymax - maximal y coordinate\r\n     */\r\n    set(xmin, ymin, xmax, ymax) {\r\n        this.xmin = xmin;\r\n        this.ymin = ymin;\r\n        this.xmax = xmax;\r\n        this.ymax = ymax;\r\n    }\r\n\r\n    /**\r\n     * Transform box into array of points from low left corner in counter clockwise\r\n     * @returns {Point[]}\r\n     */\r\n    toPoints() {\r\n        return [\r\n            new Flatten.Point(this.xmin, this.ymin),\r\n            new Flatten.Point(this.xmax, this.ymin),\r\n            new Flatten.Point(this.xmax, this.ymax),\r\n            new Flatten.Point(this.xmin, this.ymax)\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Transform box into array of segments from low left corner in counter clockwise\r\n     * @returns {Segment[]}\r\n     */\r\n    toSegments() {\r\n        let pts = this.toPoints();\r\n        return [\r\n            new Flatten.Segment(pts[0], pts[1]),\r\n            new Flatten.Segment(pts[1], pts[2]),\r\n            new Flatten.Segment(pts[2], pts[3]),\r\n            new Flatten.Segment(pts[3], pts[0])\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Return string to draw circle in svg\r\n     * @param {Object} attrs - an object with attributes of svg rectangle element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n        let width = this.xmax - this.xmin;\r\n        let height = this.ymax - this.ymin;\r\n\r\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\r\n    };\r\n}\r\nFlatten.Box = Box;\r\n/**\r\n * Shortcut to create new circle\r\n * @param args\r\n * @returns {Box}\r\n */\r\nconst box = (...args) => new Flatten.Box(...args);\r\nFlatten.box = box;\r\n\r\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n/**\r\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n * Each edge contains references to the next and previous edges in the face of the polygon.\r\n *\r\n * @type {Edge}\r\n */\r\nclass Edge {\r\n    /**\r\n     * Construct new instance of edge\r\n     * @param {Shape} shape Shape of type Segment or Arc\r\n     */\r\n    constructor(shape) {\r\n        /**\r\n         * Shape of the edge: Segment or Arc\r\n         * @type {Segment|Arc}\r\n         */\r\n        this.shape = shape;\r\n        /**\r\n         * Pointer to the next edge in the face\r\n         * @type {Edge}\r\n         */\r\n        this.next = undefined;\r\n        /**\r\n         * Pointer to the previous edge in the face\r\n         * @type {Edge}\r\n         */\r\n        this.prev = undefined;\r\n        /**\r\n         * Pointer to the face containing this edge\r\n         * @type {Face}\r\n         */\r\n        this.face = undefined;\r\n        /**\r\n         * \"Arc distance\" from the face start\r\n         * @type {number}\r\n         */\r\n        this.arc_length = 0;\r\n        /**\r\n         * Start inclusion flag (inside/outside/boundary)\r\n         * @type {*}\r\n         */\r\n        this.bvStart = undefined;\r\n        /**\r\n         * End inclusion flag (inside/outside/boundary)\r\n         * @type {*}\r\n         */\r\n        this.bvEnd = undefined;\r\n        /**\r\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n         * @type {*}\r\n         */\r\n        this.bv = undefined;\r\n        /**\r\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n         * @type {*}\r\n         */\r\n        this.overlap = undefined;\r\n    }\r\n\r\n    /**\r\n     * Get edge start point\r\n     */\r\n    get start() {\r\n        return this.shape.start;\r\n    }\r\n\r\n    /**\r\n     * Get edge end point\r\n     */\r\n    get end() {\r\n        return this.shape.end;\r\n    }\r\n\r\n    /**\r\n     * Get edge length\r\n     */\r\n    get length() {\r\n        return this.shape.length;\r\n    }\r\n\r\n    /**\r\n     * Get bounding box of the edge\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.shape.box;\r\n    }\r\n\r\n    isSegment() {\r\n        return this.shape instanceof Flatten.Segment;\r\n    }\r\n\r\n    isArc() {\r\n        return this.shape instanceof Flatten.Arc;\r\n    }\r\n\r\n    /**\r\n     * Get middle point of the edge\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        return this.shape.middle();\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to the edge, false otherwise\r\n     * @param {Point} pt - test point\r\n     */\r\n    contains(pt) {\r\n        return this.shape.contains(pt);\r\n    }\r\n\r\n    /**\r\n     * Set inclusion flag of the edge with respect to another polygon\r\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n     * @param polygon\r\n     */\r\n    setInclusion(polygon) {\r\n        if (this.bv !== undefined) return this.bv;\r\n\r\n        if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\r\n            this.bv = Flatten.OUTSIDE;\r\n            return this.bv;\r\n        }\r\n\r\n        if (this.bvStart === undefined) {\r\n            this.bvStart = ray_shoot(polygon, this.start);\r\n        }\r\n        if (this.bvEnd === undefined) {\r\n            this.bvEnd = ray_shoot(polygon, this.end);\r\n        }\r\n        /* At least one end outside - the whole edge outside */\r\n        if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\r\n            this.bv = Flatten.OUTSIDE;\r\n        }\r\n        /* At least one end inside - the whole edge inside */\r\n        else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\r\n            this.bv = Flatten.INSIDE;\r\n        }\r\n        /* Both are boundary - check the middle point */\r\n        else {\r\n            let bvMiddle = ray_shoot(polygon, this.middle());\r\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\r\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\r\n            this.bv = bvMiddle;\r\n        }\r\n        return this.bv;\r\n    }\r\n\r\n    /**\r\n     * Set overlapping between two coincident boundary edges\r\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n     * @param edge\r\n     */\r\n    setOverlap(edge) {\r\n        let flag = undefined;\r\n        let shape1 = this.shape;\r\n        let shape2 = edge.shape;\r\n\r\n        if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\r\n                shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\r\n                shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\r\n            shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        }\r\n\r\n        /* Do not update overlap flag if already set on previous chain */\r\n        if (this.overlap === undefined) this.overlap = flag;\r\n        if (edge.overlap === undefined) edge.overlap = flag;\r\n    }\r\n\r\n    svg() {\r\n        if (this.shape instanceof Flatten.Segment) {\r\n            return ` L${this.shape.end.x},${this.shape.end.y}`;\r\n        } else if (this.shape instanceof Flatten.Arc) {\r\n            let arc = this.shape;\r\n            let largeArcFlag;\r\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\r\n\r\n            // Draw full circe arc as special case: split it into two half-circles\r\n            if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\r\n                let sign = arc.counterClockwise ? 1 : -1;\r\n                let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\r\n                let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\r\n\r\n                largeArcFlag = \"0\";\r\n\r\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\r\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\r\n            } else {\r\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\r\n\r\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    toJSON() {\r\n        return this.shape.toJSON();\r\n    }\r\n}\r\nFlatten.Edge = Edge;\r\n\r\n/**\r\n * Class implements circular bidirectional linked list <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\r\nclass CircularLinkedList extends LinkedList {\r\n    constructor(first, last) {\r\n        super(first, last);\r\n        this.setCircularLinks();\r\n    }\r\n\r\n    setCircularLinks() {\r\n        if (this.isEmpty()) return;\r\n        this.last.next = this.first;\r\n        this.first.prev = this.last;\r\n    }\r\n\r\n    [Symbol.iterator]() {\r\n        let element = undefined;\r\n        return {\r\n            next: () => {\r\n                let value = element ? element : this.first;\r\n                let done = this.first ? (element ? element === this.first : false) : true;\r\n                element = value ? value.next : undefined;\r\n                return {value: value, done: done};\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Append new element to the end of the list\r\n     * @param {LinkedListElement} element - new element to be appended\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    append(element) {\r\n        super.append(element);\r\n        this.setCircularLinks();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert new element to the list after elementBefore\r\n     * @param {LinkedListElement} newElement - new element to be inserted\r\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    insert(newElement, elementBefore) {\r\n        super.insert(newElement, elementBefore);\r\n        this.setCircularLinks();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove element from the list\r\n     * @param {LinkedListElement} element - element to be removed from the list\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    remove(element) {\r\n        super.remove(element);\r\n        // this.setCircularLinks();\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n/**\r\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\r\n * Face object cannot be instantiated with a constructor.\r\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n * <br/>\r\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n * Container of edges is a property of the polygon object. <br/>\r\n *\r\n * @example\r\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n * for (let edge of face) {\r\n *      console.log(edge.shape.length)     // do something\r\n * }\r\n *\r\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n * let edge = face.first;\r\n * do {\r\n *   console.log(edge.shape.length);   // do something\r\n *   edge = edge.next;\r\n * } while (edge != face.first)\r\n */\r\nclass Face extends CircularLinkedList {\r\n    constructor(polygon, ...args) {\r\n        super();            // construct empty list of edges\r\n        /**\r\n         * Reference to the first edge in face\r\n         */\r\n        // this.first;\r\n        /**\r\n         * Reference to the last edge in face\r\n         */\r\n        // this.last;\r\n\r\n        this._box = undefined;  // new Box();\r\n        this._orientation = undefined;\r\n\r\n        if (args.length == 0) {\r\n            return;\r\n        }\r\n\r\n        /* If passed an array it supposed to be:\r\n         1) array of shapes that performs close loop or\r\n         2) array of points that performs set of vertices\r\n         */\r\n        if (args.length == 1) {\r\n            if (args[0] instanceof Array) {\r\n                // let argsArray = args[0];\r\n                let shapes = args[0];  // argsArray[0];\r\n                if (shapes.length == 0)\r\n                    return;\r\n\r\n                /* array of Flatten.Points */\r\n                if (shapes.every((shape) => {return shape instanceof Flatten.Point})) {\r\n                    let segments = Face.points2segments(shapes);\r\n                    this.shapes2face(polygon.edges, segments);\r\n                }\r\n                /* array of points as pairs of numbers */\r\n                else if (shapes.every((shape) => {return shape instanceof Array && shape.length === 2})) {\r\n                    let points = shapes.map((shape) => new Flatten.Point(shape[0],shape[1]));\r\n                    let segments = Face.points2segments(points);\r\n                    this.shapes2face(polygon.edges, segments);\r\n                }\r\n                /* array of segments ot arcs */\r\n                else if (shapes.every((shape) => {\r\n                    return (shape instanceof Flatten.Segment || shape instanceof Flatten.Arc)\r\n                })) {\r\n                    this.shapes2face(polygon.edges, shapes);\r\n                }\r\n                // this is from JSON.parse object\r\n                else if (shapes.every((shape) => {\r\n                    return (shape.name === \"segment\" || shape.name === \"arc\")\r\n                })) {\r\n                    let flattenShapes = [];\r\n                    for (let shape of shapes) {\r\n                        let flattenShape;\r\n                        if (shape.name === \"segment\") {\r\n                            flattenShape = new Flatten.Segment(shape);\r\n                        } else {\r\n                            flattenShape = new Flatten.Arc(shape);\r\n                        }\r\n                        flattenShapes.push(flattenShape);\r\n                    }\r\n                    this.shapes2face(polygon.edges, flattenShapes);\r\n                }\r\n            }\r\n            /* Create new face and copy edges into polygon.edges set */\r\n            else if (args[0] instanceof Face) {\r\n                let face = args[0];\r\n                this.first = face.first;\r\n                this.last = face.last;\r\n                for (let edge of face) {\r\n                    polygon.edges.add(edge);\r\n                }\r\n            }\r\n            /* Instantiate face from a circle in CCW orientation */\r\n            else if (args[0] instanceof Flatten.Circle) {\r\n                this.shapes2face(polygon.edges, [args[0].toArc(Flatten.CCW)]);\r\n            }\r\n            /* Instantiate face from a box in CCW orientation */\r\n            else if (args[0] instanceof Flatten.Box) {\r\n                let box = args[0];\r\n                this.shapes2face(polygon.edges, [\r\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))\r\n                ]);\r\n            }\r\n        }\r\n        /* If passed two edges, consider them as start and end of the face loop */\r\n        /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\r\n        /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\r\n        if (args.length == 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\r\n            this.first = args[0];                          // first edge in face or undefined\r\n            this.last = args[1];                           // last edge in face or undefined\r\n            this.last.next = this.first;\r\n            this.first.prev = this.last;\r\n\r\n            // set arc length\r\n            this.setArcLength();\r\n\r\n            // this.box = this.getBox();\r\n            // this.orientation = this.getOrientation();      // face direction cw or ccw\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return array of edges from first to last\r\n     * @returns {Array}\r\n     */\r\n    get edges() {\r\n        return this.toArray();\r\n    }\r\n\r\n    /**\r\n     * Return array of shapes which comprise face\r\n     * @returns {Array}\r\n     */\r\n    get shapes() {\r\n        return this.edges.map(edge => edge.shape.clone());\r\n    }\r\n\r\n    /**\r\n     * Return bounding box of the face\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        if (this._box === undefined) {\r\n            let box = new Flatten.Box();\r\n            for (let edge of this) {\r\n                box = box.merge(edge.box);\r\n            }\r\n            this._box = box;\r\n        }\r\n        return this._box;\r\n    }\r\n\r\n    static points2segments(points) {\r\n        let segments = [];\r\n        for (let i = 0; i < points.length; i++) {\r\n            // skip zero length segment\r\n            if (points[i].equalTo(points[(i + 1) % points.length]))\r\n                continue;\r\n            segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\r\n        }\r\n        return segments;\r\n    }\r\n\r\n    shapes2face(edges, shapes) {\r\n        for (let shape of shapes) {\r\n            let edge = new Flatten.Edge(shape);\r\n            this.append(edge);\r\n            // this.box = this.box.merge(shape.box);\r\n            edges.add(edge);\r\n        }\r\n        // this.orientation = this.getOrientation();              // face direction cw or ccw\r\n    }\r\n\r\n    /**\r\n     * Append edge after the last edge of the face (and before the first edge). <br/>\r\n     * @param {Edge} edge - Edge to be appended to the linked list\r\n     * @returns {Face}\r\n     */\r\n    append(edge) {\r\n        super.append(edge);\r\n        // set arc length\r\n        this.setOneEdgeArcLength(edge);\r\n        edge.face = this;\r\n        // edges.add(edge);      // Add new edges into edges container\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n     * @param {Edge} newEdge - Edge to be inserted into linked list\r\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n     * @returns {Face}\r\n     */\r\n    insert(newEdge, edgeBefore) {\r\n        super.insert(newEdge, edgeBefore);\r\n        // set arc length\r\n        this.setOneEdgeArcLength(newEdge);\r\n        newEdge.face = this;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove the given edge from the linked list of the face <br/>\r\n     * @param {Edge} edge - Edge to be removed\r\n     * @returns {Face}\r\n     */\r\n    remove(edge) {\r\n        super.remove(edge);\r\n        // Recalculate arc length\r\n        this.setArcLength();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverse orientation of the face: first edge become last and vice a verse,\r\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\r\n     * clockwise, it becomes counter clockwise and vice versa\r\n     */\r\n    reverse() {\r\n        // collect edges in revert order with reverted shapes\r\n        let edges = [];\r\n        let edge_tmp = this.last;\r\n        do {\r\n            // reverse shape\r\n            edge_tmp.shape = edge_tmp.shape.reverse();\r\n            edges.push(edge_tmp);\r\n            edge_tmp = edge_tmp.prev;\r\n        } while (edge_tmp !== this.last);\r\n\r\n        // restore linked list\r\n        this.first = undefined;\r\n        this.last = undefined;\r\n        for (let edge of edges) {\r\n            if (this.first === undefined) {\r\n                edge.prev = edge;\r\n                edge.next = edge;\r\n                this.first = edge;\r\n                this.last = edge;\r\n            } else {\r\n                // append to end\r\n                edge.prev = this.last;\r\n                this.last.next = edge;\r\n\r\n                // update edge to be last\r\n                this.last = edge;\r\n\r\n                // restore circular links\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n            }\r\n            // set arc length\r\n            this.setOneEdgeArcLength(edge);\r\n        }\r\n\r\n        // Recalculate orientation, if set\r\n        if (this._orientation !== undefined) {\r\n            this._orientation = undefined;\r\n            this._orientation = this.orientation();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Set arc_length property for each of the edges in the face.\r\n     * Arc_length of the edge it the arc length from the first edge of the face\r\n     */\r\n    setArcLength() {\r\n        for (let edge of this) {\r\n            this.setOneEdgeArcLength(edge);\r\n            edge.face = this;\r\n        }\r\n    }\r\n\r\n    setOneEdgeArcLength(edge) {\r\n        if (edge === this.first) {\r\n            edge.arc_length = 0.0;\r\n        } else {\r\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the absolute value of the area of the face\r\n     * @returns {number}\r\n     */\r\n    area() {\r\n        return Math.abs(this.signedArea());\r\n    }\r\n\r\n    /**\r\n     * Returns signed area of the simple face.\r\n     * Face is simple if it has no self intersections that change its orientation.\r\n     * Then the area will be positive if the orientation of the face is clockwise,\r\n     * and negative if orientation is counterclockwise.\r\n     * It may be zero if polygon is degenerated.\r\n     * @returns {number}\r\n     */\r\n    signedArea() {\r\n        let sArea = 0;\r\n        let ymin = this.box.ymin;\r\n        for (let edge of this) {\r\n            sArea += edge.shape.definiteIntegral(ymin);\r\n        }\r\n        return sArea;\r\n    }\r\n\r\n    /**\r\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n     * and the sign of the integral will be defined by the direction of the curve.\r\n     * When the integral (\"signed area\") will be negative, direction is counter clockwise,\r\n     * when positive - clockwise and when it is zero, polygon is not orientable.\r\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n     * @returns {number}\r\n     */\r\n    orientation() {\r\n        if (this._orientation === undefined) {\r\n            let area = this.signedArea();\r\n            if (Flatten.Utils.EQ_0(area)) {\r\n                this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\r\n            } else if (Flatten.Utils.LT(area, 0)) {\r\n                this._orientation = Flatten.ORIENTATION.CCW;\r\n            } else {\r\n                this._orientation = Flatten.ORIENTATION.CW;\r\n            }\r\n        }\r\n        return this._orientation;\r\n    }\r\n\r\n    /**\r\n     * Returns true if face of the polygon is simple (no self-intersection points found)\r\n     * NOTE: this method is incomplete because it does not exclude touching points.\r\n     * Self intersection test should check if polygon change orientation in the test point.\r\n     * @param {Edges} edges - reference to polygon.edges to provide search index\r\n     * @returns {boolean}\r\n     */\r\n    isSimple(edges) {\r\n        let ip = Face.getSelfIntersections(this, edges, true);\r\n        return ip.length == 0;\r\n    }\r\n\r\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\r\n        let int_points = [];\r\n\r\n        // calculate intersections\r\n        for (let edge1 of face) {\r\n\r\n            // request edges of polygon in the box of edge1\r\n            let resp = edges.search(edge1.box);\r\n\r\n            // for each edge2 in response\r\n            for (let edge2 of resp) {\r\n\r\n                // Skip itself\r\n                if (edge1 === edge2)\r\n                    continue;\r\n\r\n                // Skip is edge2 belongs to another face\r\n                if (edge2.face !== face)\r\n                    continue;\r\n\r\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\r\n                if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\r\n                    (edge1.next === edge2 || edge1.prev === edge2))\r\n                    continue;\r\n\r\n                // calculate intersections between edge1 and edge2\r\n                let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                // for each intersection point\r\n                for (let pt of ip) {\r\n\r\n                    // skip start-end connections\r\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\r\n                        continue;\r\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\r\n                        continue;\r\n\r\n                    int_points.push(pt);\r\n\r\n                    if (exitOnFirst)\r\n                        break;\r\n                }\r\n\r\n                if (int_points.length > 0 && exitOnFirst)\r\n                    break;\r\n            }\r\n\r\n            if (int_points.length > 0 && exitOnFirst)\r\n                break;\r\n\r\n        }\r\n        return int_points;\r\n    }\r\n\r\n    /**\r\n     * Returns edge which contains given point\r\n     * @param {Point} pt - test point\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edgeFound;\r\n        for (let edge of this) {\r\n            if (edge.shape.contains(pt)) {\r\n                edgeFound = edge;\r\n                break;\r\n            }\r\n        }\r\n        return edgeFound;\r\n    }\r\n\r\n    /**\r\n     * Returns new polygon created from one face\r\n     * @returns {Polygon}\r\n     */\r\n    toPolygon() {\r\n        return new Flatten.Polygon(this.shapes);\r\n    }\r\n\r\n    toJSON() {\r\n        return this.edges.map(edge => edge.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\r\n     * @returns {string}\r\n     */\r\n    svg() {\r\n        let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\r\n        for (let edge of this) {\r\n            svgStr += edge.svg();\r\n        }\r\n        svgStr += ` z`;\r\n        return svgStr;\r\n    }\r\n\r\n}\r\nFlatten.Face = Face;\r\n\r\n/**\r\n * Class representing a ray (a half-infinite line).\r\n * @type {Ray}\r\n */\r\nclass Ray {\r\n    /**\r\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\r\n     * on a ray fit an equation: <br />\r\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\r\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\r\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\r\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\r\n     * @param {Point} pt - start point\r\n     * @param {Vector} norm - normal vector\r\n     */\r\n    constructor(...args) {\r\n        this.pt = new Flatten.Point();\r\n        this.norm = new Flatten.Vector(0,1);\r\n\r\n        if (args.length == 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length >= 1 && args[0] instanceof Flatten.Point) {\r\n            this.pt = args[0].clone();\r\n        }\r\n\r\n        if (args.length === 1) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2 && args[1] instanceof Flatten.Vector) {\r\n            this.norm = args[1].clone();\r\n            return;\r\n        }\r\n\r\n        // if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n        //     this.pt = new Flatten.Point(args[0], args[1]);\r\n        //     return;\r\n        // }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of ray\r\n     * @returns {Ray}\r\n     */\r\n    clone() {\r\n        return new Ray(this.pt, this.norm);\r\n    }\r\n\r\n    /**\r\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\r\n     * @returns {number} - slope of the line\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Returns half-infinite bounding box of the ray\r\n     * @returns {Box} - bounding box\r\n     */\r\n    get box() {\r\n        let slope = this.slope;\r\n        return new Flatten.Box(\r\n            slope > Math.PI/2 && slope < 3*Math.PI/2 ? Number.NEGATIVE_INFINITY : this.pt.x,\r\n            slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,\r\n            slope >= Math.PI/2 && slope <= 3*Math.PI/2 ? this.pt.x : Number.POSITIVE_INFINITY,\r\n            slope >= Math.PI && slope <= 2*Math.PI || slope == 0 ? this.pt.y : Number.POSITIVE_INFINITY\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Return ray start point\r\n     * @returns {Point} - ray start point\r\n     */\r\n    get start() {\r\n        return this.pt;\r\n    }\r\n\r\n    /**\r\n     * Ray has no end point?\r\n     * @returns {undefined}\r\n     */\r\n    get end() {return undefined;}\r\n\r\n    /**\r\n     * Return positive infinity number as length\r\n     * @returns {number}\r\n     */\r\n    get length() {return Number.POSITIVE_INFINITY;}\r\n\r\n    /**\r\n     * Returns true if point belongs to ray\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        if (this.pt.equalTo(pt)) {\r\n            return true;\r\n        }\r\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\r\n            and cross product from vector to point is positive */\r\n        let vec = new Flatten.Vector(this.pt, pt);\r\n        return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm),0);\r\n    }\r\n\r\n    /**\r\n     * Split ray with point and return array of segment and new ray\r\n     * @param {Point} pt\r\n     * @returns [Segment,Ray]\r\n     */\r\n    split(pt) {\r\n        if (!this.contains(pt))\r\n            return [];\r\n\r\n        if (this.pt.equalTo(pt)) {\r\n            return [this]\r\n        }\r\n\r\n        return [\r\n            new Flatten.Segment(this.pt, pt),\r\n            new Flatten.Ray(pt, this.norm)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between ray and segment or arc\r\n     * @param {Segment|Arc} - Shape to intersect with ray\r\n     * @returns {Array} array of intersection points\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Segment) {\r\n            return this.intersectRay2Segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return this.intersectRay2Arc(this, shape);\r\n        }\r\n    }\r\n\r\n    intersectRay2Segment(ray, segment) {\r\n        let ip = [];\r\n\r\n        // if (ray.box.not_intersect(segment.box)) {\r\n        //     return ip;\r\n        // }\r\n\r\n        let line = new Flatten.Line(ray.start, ray.norm);\r\n        let ip_tmp = line.intersect(segment);\r\n\r\n        for (let pt of ip_tmp) {\r\n            // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n            if (ray.contains(pt)) {\r\n                ip.push(pt);\r\n            }\r\n        }\r\n\r\n        /* If there were two intersection points between line and ray,\r\n        and now there is exactly one left, it means ray starts between these points\r\n        and there is another intersection point - start of the ray */\r\n        if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\r\n            ip.push(ray.start);\r\n        }\r\n\r\n        return ip;\r\n    }\r\n\r\n    intersectRay2Arc(ray, arc) {\r\n        let ip = [];\r\n\r\n        // if (ray.box.not_intersect(arc.box)) {\r\n        //     return ip;\r\n        // }\r\n\r\n        let line = new Flatten.Line(ray.start, ray.norm);\r\n        let ip_tmp = line.intersect(arc);\r\n\r\n        for (let pt of ip_tmp) {\r\n            // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n            if (ray.contains(pt)) {\r\n                ip.push(pt);\r\n            }\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    /**\r\n     * Return string to draw svg segment representing ray inside given box\r\n     * @param {Box} box Box representing drawing area\r\n     * @param {Object} attrs - an object with attributes of svg segment element\r\n     */\r\n    svg(box, attrs = {}) {\r\n        let line = new Flatten.Line(this.pt, this.norm);\r\n        let ip = intersectLine2Box(line, box);\r\n        ip = ip.filter( pt => this.contains(pt) );\r\n        if (ip.length === 0 || ip.length === 2)\r\n            return \"\";\r\n        let segment = new Flatten.Segment(this.pt, ip[0]);\r\n        return segment.svg(attrs);\r\n    }\r\n\r\n}\r\nFlatten.Ray = Ray;\r\n\r\nconst ray = (...args) => new Flatten.Ray(...args);\r\nFlatten.ray = ray;\r\n\r\n/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\r\n\r\n/**\r\n * Class representing a polygon.<br/>\r\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n * @type {Polygon}\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\r\n     * Constructor accepts as argument array that define loop of shapes\r\n     * or array of arrays in case of multi polygon <br/>\r\n     * Loop may be defined in different ways: <br/>\r\n     * - array of shapes of type Segment or Arc <br/>\r\n     * - array of points (Flatten.Point) <br/>\r\n     * - array of numeric pairs which represent points <br/>\r\n     * - box or circle object <br/>\r\n     * Alternatively, it is possible to use polygon.addFace method\r\n     * @param {args} - array of shapes or array of arrays\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Container of faces (closed loops), may be empty\r\n         * @type {PlanarSet}\r\n         */\r\n        this.faces = new Flatten.PlanarSet();\r\n        /**\r\n         * Container of edges\r\n         * @type {PlanarSet}\r\n         */\r\n        this.edges = new Flatten.PlanarSet();\r\n\r\n        /* It may be array of something that may represent one loop (face) or\r\n         array of arrays that represent multiple loops\r\n         */\r\n        let args = [...arguments];\r\n        if (args.length === 1 &&\r\n            ((args[0] instanceof Array && args[0].length > 0) ||\r\n                args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\r\n            let argsArray = args[0];\r\n            if (args[0] instanceof Array && args[0].every((loop) => {return loop instanceof Array})) {\r\n                if  (argsArray.every( el => {return el instanceof Array && el.length === 2 && typeof(el[0]) === \"number\" && typeof(el[1]) === \"number\"} )) {\r\n                    this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon as array of pairs of numbers\r\n                }\r\n                else {\r\n                    for (let loop of argsArray) {   // multi-loop polygon\r\n                        /* Check extra level of nesting for GeoJSON-style multi polygons */\r\n                        if (loop instanceof Array && loop[0] instanceof Array &&\r\n                            loop[0].every( el => {return el instanceof Array && el.length === 2 && typeof(el[0]) === \"number\" && typeof(el[1]) === \"number\"} )) {\r\n                            for (let loop1 of loop) {\r\n                                this.faces.add(new Flatten.Face(this, loop1));\r\n                            }\r\n                        }\r\n                        else {\r\n                            this.faces.add(new Flatten.Face(this, loop));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns bounding box of the polygon\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns array of vertices\r\n     * @returns {Array}\r\n     */\r\n    get vertices() {\r\n        return [...this.edges].map(edge => edge.start);\r\n    }\r\n\r\n    /**\r\n     * Create new cloned instance of the polygon\r\n     * @returns {Polygon}\r\n     */\r\n    clone() {\r\n        let polygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            polygon.addFace(face.shapes);\r\n        }\r\n        return polygon;\r\n    }\r\n\r\n    /**\r\n     * Return true is polygon has no edges\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return this.edges.size === 0;\r\n    }\r\n\r\n    /**\r\n     * Return true if polygon is valid for boolean operations\r\n     * Polygon is valid if <br/>\r\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n     * @returns {boolean}\r\n     */\r\n    isValid() {\r\n        let valid = true;\r\n        // 1. Polygon is invalid if at least one face is not simple\r\n        for (let face of this.faces) {\r\n            if (!face.isSimple(this.edges)) {\r\n                valid = false;\r\n                break;\r\n            }\r\n        }\r\n        // 2. TODO: check if no island inside island and no hole inside hole\r\n        // 3. TODO: check the there is no intersection between faces\r\n        return valid;\r\n    }\r\n\r\n    /**\r\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n     * @returns {number}\r\n     */\r\n    area() {\r\n        let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\r\n        return Math.abs(signedArea);\r\n    }\r\n\r\n    /**\r\n     * Add new face to polygon. Returns added face\r\n     * @param {Points[]|Segments[]|Arcs[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\r\n     * 1) array of points that describe closed path (edges are segments) <br/>\r\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\r\n     * 3) circle - will be added as counterclockwise arc <br/>\r\n     * 4) box - will be added as counterclockwise rectangle <br/>\r\n     * You can chain method face.reverse() is you need to change direction of the creates face\r\n     * @returns {Face}\r\n     */\r\n    addFace(...args) {\r\n        let face = new Flatten.Face(this, ...args);\r\n        this.faces.add(face);\r\n        return face;\r\n    }\r\n\r\n    /**\r\n     * Delete existing face from polygon\r\n     * @param {Face} face Face to be deleted\r\n     * @returns {boolean}\r\n     */\r\n    deleteFace(face) {\r\n        for (let edge of face) {\r\n            let deleted = this.edges.delete(edge);\r\n        }\r\n        let deleted = this.faces.delete(face);\r\n        return deleted;\r\n    }\r\n\r\n    /**\r\n     * Delete chain of edges from the face.\r\n     * @param {Face} face Face to remove chain\r\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n     * @param {Edge} edgeTo End of the chain of edges to be removed\r\n     */\r\n    removeChain(face, edgeFrom, edgeTo) {\r\n        // Special case: all edges removed\r\n        if (edgeTo.next === edgeFrom) {\r\n            this.deleteFace(face);\r\n            return;\r\n        }\r\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\r\n            face.remove(edge);\r\n            this.edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n            if (face.isEmpty()) {\r\n                this.deleteFace(face);    // delete from PlanarSet of faces and update index\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n     * When edge is split, new edge created from the start of the edge to the new vertex\r\n     * and inserted before current edge.\r\n     * Current edge is trimmed and updated.\r\n     * Method returns new edge added. If no edge added, it returns edge before vertex\r\n     * @param {Point} pt Point to be added as a new vertex\r\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n     * @returns {Edge}\r\n     */\r\n    addVertex(pt, edge) {\r\n        let shapes = edge.shape.split(pt);\r\n        // if (shapes.length < 2) return;\r\n\r\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\r\n            return edge.prev;\r\n\r\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\r\n            return edge;\r\n\r\n        let newEdge = new Flatten.Edge(shapes[0]);\r\n        let edgeBefore = edge.prev;\r\n\r\n        /* Insert first split edge into linked list after edgeBefore */\r\n        edge.face.insert(newEdge, edgeBefore);\r\n\r\n        // Remove old edge from edges container and 2d index\r\n        this.edges.delete(edge);\r\n\r\n        // Insert new edge to the edges container and 2d index\r\n        this.edges.add(newEdge);\r\n\r\n        // Update edge shape with second split edge keeping links\r\n        edge.shape = shapes[1];\r\n\r\n        // Add updated edge to the edges container and 2d index\r\n        this.edges.add(edge);\r\n\r\n        return newEdge;\r\n    }\r\n\r\n    /**\r\n     * Cut polygon with multiline and return array of new polygons\r\n     * Multiline should be constructed from a line with intersection point, see notebook:\r\n     * https://next.observablehq.com/@alexbol99/cut-polygon-with-line\r\n     * @param {Multiline} multiline\r\n     * @returns {Polygon[]}\r\n     */\r\n    cut(multiline) {\r\n        let cutPolygons = [this.clone()];\r\n        for (let edge of multiline) {\r\n            if (edge.setInclusion(this) !== Flatten.INSIDE)\r\n                continue;\r\n\r\n            let cut_edge_start = edge.shape.start;\r\n            let cut_edge_end = edge.shape.end;\r\n\r\n            let newCutPolygons = [];\r\n            for (let polygon of cutPolygons) {\r\n                if (polygon.findEdgeByPoint(cut_edge_start) === undefined) {\r\n                    newCutPolygons.push(polygon);\r\n                }\r\n                else {\r\n                    let [cutPoly1, cutPoly2] = polygon.cutFace(cut_edge_start, cut_edge_end);\r\n                    newCutPolygons.push(cutPoly1, cutPoly2);\r\n                }\r\n            }\r\n            cutPolygons = newCutPolygons;\r\n        }\r\n        return cutPolygons;\r\n    }\r\n\r\n    /**\r\n     * Cut face of polygon with a segment between two points and create two new polygons\r\n     * Supposed that a segments between points does not intersect any other edge\r\n     * @param {Point} pt1\r\n     * @param {Point} pt2\r\n     * @returns {Polygon[]}\r\n     */\r\n    cutFace(pt1, pt2) {\r\n        let edge1 = this.findEdgeByPoint(pt1);\r\n        let edge2 = this.findEdgeByPoint(pt2);\r\n        if (edge1.face != edge2.face) return;\r\n\r\n        // Cut face into two and create new polygon with two faces\r\n        let edgeBefore1 = this.addVertex(pt1, edge1);\r\n        edge2 = this.findEdgeByPoint(pt2);\r\n        let edgeBefore2 = this.addVertex(pt2, edge2);\r\n\r\n        let face = edgeBefore1.face;\r\n        let newEdge1 = new Flatten.Edge(\r\n            new Flatten.Segment(edgeBefore1.end, edgeBefore2.end)\r\n        );\r\n        let newEdge2 = new Flatten.Edge(\r\n            new Flatten.Segment(edgeBefore2.end, edgeBefore1.end)\r\n        );\r\n\r\n        // Swap links\r\n        edgeBefore1.next.prev = newEdge2;\r\n        newEdge2.next = edgeBefore1.next;\r\n\r\n        edgeBefore1.next = newEdge1;\r\n        newEdge1.prev = edgeBefore1;\r\n\r\n        edgeBefore2.next.prev = newEdge1;\r\n        newEdge1.next = edgeBefore2.next;\r\n\r\n        edgeBefore2.next = newEdge2;\r\n        newEdge2.prev = edgeBefore2;\r\n\r\n        // Insert new edge to the edges container and 2d index\r\n        this.edges.add(newEdge1);\r\n        this.edges.add(newEdge2);\r\n\r\n        // Add two new faces\r\n        let face1 = this.addFace(newEdge1, edgeBefore1);\r\n        let face2 = this.addFace(newEdge2, edgeBefore2);\r\n\r\n        // Remove old face\r\n        this.faces.delete(face);\r\n\r\n        return [face1.toPolygon(), face2.toPolygon()];\r\n    }\r\n\r\n    /**\r\n     * Returns the first founded edge of polygon that contains given point\r\n     * @param {Point} pt\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edge;\r\n        for (let face of this.faces) {\r\n            edge = face.findEdgeByPoint(pt);\r\n            if (edge != undefined)\r\n                break;\r\n        }\r\n        return edge;\r\n    }\r\n\r\n    /**\r\n     * Split polygon into array of polygons, where each polygon is an island with all\r\n     * hole that it contains\r\n     * @returns {Flatten.Polygon[]}\r\n     */\r\n    splitToIslands() {\r\n        let polygons = this.toArray();      // split into array of one-loop polygons\r\n        /* Sort polygons by area in descending order */\r\n        polygons.sort( (polygon1, polygon2) => polygon2.area() - polygon1.area() );\r\n        /* define orientation of the island by orientation of the first polygon in array */\r\n        let orientation = [...polygons[0].faces][0].orientation();\r\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */\r\n        let newPolygons = polygons.filter( polygon => [...polygon.faces][0].orientation() === orientation);\r\n        for (let polygon of polygons) {\r\n            let face = [...polygon.faces][0];\r\n            if (face.orientation() === orientation) continue;  // skip same orientation\r\n            /* Proceed with opposite orientation */\r\n            /* Look if any of island polygons contains tested polygon as a hole */\r\n            for (let islandPolygon of newPolygons) {\r\n                if (face.shapes.every(shape => islandPolygon.contains(shape))) {\r\n                    islandPolygon.addFace(face.shapes);      // add polygon as a hole in islandPolygon\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // TODO: assert if not all polygons added into output\r\n        return newPolygons;\r\n    }\r\n\r\n    /**\r\n     * Reverse orientation of all faces to opposite\r\n     * @returns {Polygon}\r\n     */\r\n    reverse() {\r\n        for (let face of this.faces) {\r\n            face.reverse();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\r\n     * false otherwise\r\n     * @param {Shape} shape - test shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let rel = ray_shoot(this, shape);\r\n            return rel === Flatten.INSIDE || rel === Flatten.BOUNDARY;\r\n        }\r\n        else {\r\n            return cover(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n     * @returns {Number | Segment}\r\n     */\r\n    distanceTo(shape) {\r\n        // let {Distance} = Flatten;\r\n\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle ||\r\n            shape instanceof Flatten.Line ||\r\n            shape instanceof Flatten.Segment ||\r\n            shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        /* this method is bit faster */\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n            let dist, shortest_segment;\r\n\r\n            for (let edge of this.edges) {\r\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\r\n                let min_stop = min_dist_and_segment[0];\r\n                [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\r\n                if (Flatten.Utils.LT(dist, min_stop)) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return array of intersection points between polygon and other shape\r\n     * @param shape Shape of the one of supported types <br/>\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectCircle2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectPolygon2Polygon(shape, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns new polygon translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Polygon}\r\n     */\r\n    translate(vec) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map( shape => shape.translate(vec)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * Return new polygon rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - rotation center, default is (0,0)\r\n     * @returns {Polygon} - new rotated polygon\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map( shape => shape.rotate(angle, center)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * Return new polygon transformed using affine transformation matrix\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Polygon} - new polygon\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map( shape => shape.transform(matrix)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return [...this.faces].map(face => face.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Transform all faces into array of polygons\r\n     * @returns {Flatten.Polygon[]}\r\n     */\r\n    toArray() {\r\n        return [...this.faces].map(face => face.toPolygon());\r\n    }\r\n\r\n    /**\r\n     * Return string to draw polygon in svg\r\n     * @param attrs  - an object with attributes for svg path element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n        // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n        for (let face of this.faces) {\r\n            svgStr += face.svg();\r\n        }\r\n        svgStr += `\" >\\n</path>`;\r\n        return svgStr;\r\n    }\r\n}\r\n\r\nFlatten.Polygon = Polygon;\r\n\r\n/**\r\n * Shortcut method to create new polygon\r\n */\r\nconst polygon = (...args) => new Flatten.Polygon(...args);\r\nFlatten.polygon = polygon;\r\n\r\nclass Distance {\r\n    /**\r\n     * Calculate distance and shortest segment between points\r\n     * @param pt1\r\n     * @param pt2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2point(pt1, pt2) {\r\n        return pt1.distanceTo(pt2);\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and line\r\n     * @param pt\r\n     * @param line\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2line(pt, line) {\r\n        let closest_point = pt.projectionOn(line);\r\n        let vec = new Flatten.Vector(pt, closest_point);\r\n        return [vec.length, new Flatten.Segment(pt, closest_point)];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and circle\r\n     * @param pt\r\n     * @param circle\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2circle(pt, circle) {\r\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\r\n        if (Flatten.Utils.EQ_0(dist2center)) {\r\n            return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\r\n        } else {\r\n            let dist = Math.abs(dist2center - circle.r);\r\n            let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\r\n            let closest_point = circle.pc.translate(v);\r\n            return [dist, new Flatten.Segment(pt, closest_point)];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and segment\r\n     * @param pt\r\n     * @param segment\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2segment(pt, segment) {\r\n        /* Degenerated case of zero-length segment */\r\n        if (segment.start.equalTo(segment.end)) {\r\n            return Distance.point2point(pt, segment.start);\r\n        }\r\n\r\n        let v_seg = new Flatten.Vector(segment.start, segment.end);\r\n        let v_ps2pt = new Flatten.Vector(segment.start, pt);\r\n        let v_pe2pt = new Flatten.Vector(segment.end, pt);\r\n        let start_sp = v_seg.dot(v_ps2pt);\r\n        /* dot product v_seg * v_ps2pt */\r\n        let end_sp = -v_seg.dot(v_pe2pt);\r\n        /* minus dot product v_seg * v_pe2pt */\r\n\r\n        let dist;\r\n        let closest_point;\r\n        if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\r\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\r\n            /* unit vector ||v_unit|| = 1 */\r\n            dist = Math.abs(v_unit.cross(v_ps2pt));\r\n            /* dist = abs(v_unit x v_ps2pt) */\r\n            closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\r\n            return [dist, new Flatten.Segment(pt, closest_point)];\r\n        } else if (start_sp < 0) {                             /* point is out of scope closer to ps */\r\n            return pt.distanceTo(segment.start);\r\n        } else {                                               /* point is out of scope closer to pe */\r\n            return pt.distanceTo(segment.end);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and arc\r\n     * @param pt\r\n     * @param arc\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2arc(pt, arc) {\r\n        let circle = new Flatten.Circle(arc.pc, arc.r);\r\n        let dist_and_segment = [];\r\n        let dist, shortest_segment;\r\n        [dist, shortest_segment] = Distance.point2circle(pt, circle);\r\n        if (shortest_segment.end.on(arc)) {\r\n            dist_and_segment.push(Distance.point2circle(pt, circle));\r\n        }\r\n        dist_and_segment.push(Distance.point2point(pt, arc.start));\r\n        dist_and_segment.push(Distance.point2point(pt, arc.end));\r\n\r\n        Distance.sort(dist_and_segment);\r\n\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and line\r\n     * @param seg\r\n     * @param line\r\n     * @returns {Number | Segment}\r\n     */\r\n    static segment2line(seg, line) {\r\n        let ip = seg.intersect(line);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\r\n        }\r\n        let dist_and_segment = [];\r\n        dist_and_segment.push(Distance.point2line(seg.start, line));\r\n        dist_and_segment.push(Distance.point2line(seg.end, line));\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two segments\r\n     * @param seg1\r\n     * @param seg2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static segment2segment(seg1, seg2) {\r\n        let ip = intersectSegment2Segment(seg1, seg2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\r\n        }\r\n\r\n        // Seg1 and seg2 not intersected\r\n        let dist_and_segment = [];\r\n        let dist_tmp, shortest_segment_tmp;\r\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\r\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\r\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\r\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\r\n        dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\r\n        dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and circle\r\n     * @param seg\r\n     * @param circle\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static segment2circle(seg, circle) {\r\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */\r\n        let ip = seg.intersect(circle);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // No intersection between segment and circle\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius\r\n         * And projection point belong to segment\r\n          * Then measure again distance from projection to circle and return it */\r\n        let line = new Flatten.Line(seg.ps, seg.pe);\r\n        let [dist, shortest_segment] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\r\n            return Distance.point2circle(shortest_segment.end, circle);\r\n        }\r\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n        else {\r\n            let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\r\n            let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\r\n            return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\r\n                [dist_from_start, shortest_segment_from_start] :\r\n                [dist_from_end, shortest_segment_from_end];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and arc\r\n     * @param seg\r\n     * @param arc\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static segment2arc(seg, arc) {\r\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */\r\n        let ip = seg.intersect(arc);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // No intersection between segment and arc\r\n        let line = new Flatten.Line(seg.ps, seg.pe);\r\n        let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n         * projection point belongs to segment AND\r\n           * distance from projection point to circle belongs to arc  =>\r\n           * return this distance from projection to circle */\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\r\n            let [dist_from_projection, shortest_segment_from_projection] =\r\n                Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            if (shortest_segment_from_projection.end.on(arc)) {\r\n                return [dist_from_projection, shortest_segment_from_projection];\r\n            }\r\n        }\r\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n        let dist_and_segment = [];\r\n        dist_and_segment.push(Distance.point2arc(seg.start, arc));\r\n        dist_and_segment.push(Distance.point2arc(seg.end, arc));\r\n\r\n        let dist_tmp, segment_tmp;\r\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\r\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\r\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two circles\r\n     * @param circle1\r\n     * @param circle2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static circle2circle(circle1, circle2) {\r\n        let ip = circle1.intersect(circle2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\r\n        if (circle1.center.equalTo(circle2.center)) {\r\n            let arc1 = circle1.toArc();\r\n            let arc2 = circle2.toArc();\r\n            return Distance.point2point(arc1.start, arc2.start);\r\n        } else {\r\n            // Case 2. Not concentric circles\r\n            let line = new Flatten.Line(circle1.center, circle2.center);\r\n            let ip1 = line.intersect(circle1);\r\n            let ip2 = line.intersect(circle2);\r\n\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\r\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\r\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\r\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two circles\r\n     * @param circle\r\n     * @param line\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static circle2line(circle, line) {\r\n        let ip = circle.intersect(line);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\r\n        shortest_segment = shortest_segment.reverse();\r\n        return [dist, shortest_segment];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between arc and line\r\n     * @param arc\r\n     * @param line\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static arc2line(arc, line) {\r\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */\r\n        let ip = line.intersect(arc);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle = new Flatten.Circle(arc.center, arc.r);\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n         * projection point belongs to segment AND\r\n           * distance from projection point to circle belongs to arc  =>\r\n           * return this distance from projection to circle */\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist_from_center, circle.r)) {\r\n            let [dist_from_projection, shortest_segment_from_projection] =\r\n                Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            if (shortest_segment_from_projection.end.on(arc)) {\r\n                return [dist_from_projection, shortest_segment_from_projection];\r\n            }\r\n        } else {\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2line(arc.start, line));\r\n            dist_and_segment.push(Distance.point2line(arc.end, line));\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between arc and circle\r\n     * @param arc\r\n     * @param circle2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static arc2circle(arc, circle2) {\r\n        let ip = arc.intersect(circle2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle1 = new Flatten.Circle(arc.center, arc.r);\r\n\r\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n        if (shortest_segment.start.on(arc)) {\r\n            return [dist, shortest_segment];\r\n        } else {\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2circle(arc.start, circle2));\r\n            dist_and_segment.push(Distance.point2circle(arc.end, circle2));\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two arcs\r\n     * @param arc1\r\n     * @param arc2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static arc2arc(arc1, arc2) {\r\n        let ip = arc1.intersect(arc2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle1 = new Flatten.Circle(arc1.center, arc1.r);\r\n        let circle2 = new Flatten.Circle(arc2.center, arc2.r);\r\n\r\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\r\n            return [dist, shortest_segment];\r\n        } else {\r\n            let dist_and_segment = [];\r\n\r\n            let dist_tmp, segment_tmp;\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\r\n            if (segment_tmp.end.on(arc2)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\r\n            if (segment_tmp.end.on(arc2)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\r\n            if (segment_tmp.end.on(arc1)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\r\n            if (segment_tmp.end.on(arc1)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and polygon\r\n     * @param point\r\n     * @param polygon\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2polygon(point, polygon) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge of polygon.edges) {\r\n            let [dist, shortest_segment] = (edge.shape instanceof Flatten.Segment) ?\r\n                Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                min_dist_and_segment = [dist, shortest_segment];\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    static shape2polygon(shape, polygon) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge of polygon.edges) {\r\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                min_dist_and_segment = [dist, shortest_segment];\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two polygons\r\n     * @param polygon1\r\n     * @param polygon2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static polygon2polygon(polygon1, polygon2) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge1 of polygon1.edges) {\r\n            for (let edge2 of polygon2.edges) {\r\n                let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    /**\r\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n     * Minimal distance by x is\r\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n     *    0,                       if box1 and box2 are intersected by x\r\n     * Minimal distance by y is defined in the same way\r\n     *\r\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n     *\r\n     * @param box1\r\n     * @param box2\r\n     * @returns {Number | Number} - minimal and maximal distance\r\n     */\r\n    static box2box_minmax(box1, box2) {\r\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\r\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\r\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\r\n\r\n        let box = box1.merge(box2);\r\n        let dx = box.xmax - box.xmin;\r\n        let dy = box.ymax - box.ymin;\r\n        let maxdist = dx * dx + dy * dy;\r\n\r\n        return [mindist, maxdist];\r\n    }\r\n\r\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\r\n        // Calculate minmax distance to each shape in current level\r\n        // Insert result into the interval tree for further processing\r\n        // update min_stop with maxdist, it will be the new stop distance\r\n        let mindist, maxdist;\r\n        for (let node of level) {\r\n\r\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n            // if (Flatten.Utils.GT(mindist, min_stop))\r\n            //     continue;\r\n\r\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\r\n            [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\r\n            if (node.item.value instanceof Flatten.Edge) {\r\n                tree.insert([mindist, maxdist], node.item.value.shape);\r\n            } else {\r\n                tree.insert([mindist, maxdist], node.item.value);\r\n            }\r\n            if (Flatten.Utils.LT(maxdist, min_stop)) {\r\n                min_stop = maxdist;                       // this will be the new distance estimation\r\n            }\r\n        }\r\n\r\n        if (level.length === 0)\r\n            return min_stop;\r\n\r\n        // Calculate new level from left and right children of the current\r\n        let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\r\n        let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\r\n        // Merge left and right subtrees and leave only relevant subtrees\r\n        let new_level = [...new_level_left, ...new_level_right].filter(node => {\r\n            // Node subtree quick reject, node.max is a subtree box\r\n            let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n            return (Flatten.Utils.LE(mindist, min_stop));\r\n        });\r\n\r\n        min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\r\n        return min_stop;\r\n    }\r\n\r\n    /**\r\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n     * and shapes of the planar set.\r\n     * @param shape\r\n     * @param set\r\n     */\r\n    static minmax_tree(shape, set, min_stop) {\r\n        let tree = new IntervalTree();\r\n        let level = [set.index.root];\r\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\r\n        squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\r\n        return tree;\r\n    }\r\n\r\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\r\n        let min_dist_and_segment_new, stop;\r\n        if (node != null && !node.isNil()) {\r\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\r\n\r\n            if (stop) {\r\n                return [min_dist_and_segment_new, stop];\r\n            }\r\n\r\n            if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\r\n                return [min_dist_and_segment_new, true];   // stop condition\r\n            }\r\n\r\n            let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\r\n            // console.log(dist)\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\r\n                min_dist_and_segment_new = [dist, shortest_segment];\r\n            }\r\n\r\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\r\n\r\n            return [min_dist_and_segment_new, stop];\r\n        }\r\n\r\n        return [min_dist_and_segment, false];\r\n    }\r\n\r\n    /**\r\n     * Calculates distance between shape and Planar Set of shapes\r\n     * @param shape\r\n     * @param {PlanarSet} set\r\n     * @param {Number} min_stop\r\n     * @returns {*}\r\n     */\r\n    static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\r\n        let min_dist_and_segment = [min_stop, new Flatten.Segment()];\r\n        let stop = false;\r\n        if (set instanceof Flatten.PlanarSet) {\r\n            let tree = Distance.minmax_tree(shape, set, min_stop);\r\n            [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    static sort(dist_and_segment) {\r\n        dist_and_segment.sort((d1, d2) => {\r\n            if (Flatten.Utils.LT(d1[0], d2[0])) {\r\n                return -1;\r\n            }\r\n            if (Flatten.Utils.GT(d1[0], d2[0])) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    static distance(shape1, shape2) {\r\n        return shape1.distanceTo(shape2);\r\n    }\r\n}\r\n\r\nFlatten.Distance = Distance;\r\n\r\n/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\r\n/**\r\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\r\n * (where line is considered as a circle with infinite radius) into generalized circles\r\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\r\n * http://mathworld.wolfram.com/Inversion.html <br/>\r\n * Inversion also may be considered as a reflection of the point in the plane with respect\r\n * to inversion circle so that R^2 = OP * OP',\r\n * where <br/>\r\n * O - center of inversion circle <br/>\r\n * R - radius of inversion circle <br/>\r\n * P - point of plane <br/>\r\n * P' - inversion of the point P\r\n *\r\n * @param {Line | Circle} shape - shape to be transformed\r\n * @param {Circle} inversion_circle - inversion circle\r\n * @returns {Line | Circle} - result of transformation\r\n */\r\nfunction inverse(shape, inversion_circle) {\r\n    let dist, shortest_segment;\r\n    let dx, dy;\r\n    let s;\r\n    let v;\r\n    let r;\r\n    let d;\r\n    let pt;\r\n\r\n    if (shape instanceof Flatten.Line) {\r\n        [dist, shortest_segment] = inversion_circle.pc.distanceTo(shape);\r\n        if (EQ_0(dist)) {            // Line passing through inversion center, is mapping to itself\r\n            return shape.clone();\r\n        } else {                           // Line not passing through inversion center is mapping into circle\r\n            r = inversion_circle.r * inversion_circle.r / (2 * dist);\r\n            v = new Flatten.Vector(inversion_circle.pc, shortest_segment.end);\r\n            v = v.multiply(r / dist);\r\n            return new Flatten.Circle(inversion_circle.pc.translate(v), r);\r\n        }\r\n    } else if (shape instanceof Flatten.Circle) {\r\n        [dist, shortest_segment] = inversion_circle.pc.distanceTo(shape.pc);\r\n        if (EQ(dist, shape.r)) {     // Circle passing through inversion center mapped into line\r\n            d = inversion_circle.r * inversion_circle.r / (2 * shape.r);\r\n            v = new Flatten.Vector(shape.pc, inversion_circle.pc);\r\n            v = v.normalize();\r\n            pt = inversion_circle.pc.translate(v.multiply(d));\r\n            return new Flatten.Line(pt, v);\r\n        } else {                           // Circle not passing through inversion center - map into another circle */\r\n            /* Taken from http://mathworld.wolfram.com */\r\n\r\n            dx = shape.pc.x - inversion_circle.pc.x;\r\n            dy = shape.pc.y - inversion_circle.pc.y;\r\n\r\n            s = inversion_circle.r * inversion_circle.r / (dx * dx + dy * dy - shape.r * shape.r);\r\n\r\n            let pc = new Flatten.Point(inversion_circle.pc.x + s * dx, inversion_circle.pc.y + s * dy);\r\n\r\n            return new Flatten.Circle(pc, Math.abs(s) * shape.r);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\nFlatten.BooleanOperations = BooleanOperations;\r\nFlatten.Relations = Relations;\r\n\r\nexport default Flatten;\r\nexport { Arc, BOUNDARY, BooleanOperations, Box, CCW, CW, Circle, Distance, Edge, errors as Errors, Face, INSIDE, Line, Matrix, Multiline, ORIENTATION, OUTSIDE, PlanarSet, Point, Polygon, Ray, Relations, Segment, Utils, Vector, arc, box, circle, inverse, line, matrix, multiline, point, polygon, ray, ray_shoot, segment, vector };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}