{"ast":null,"code":"/* eslint-disable class-methods-use-this */\nimport React from 'react';\nimport hexToRgba from 'hex-to-rgba';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { defaultColor, formatTimestamp, translate } from '../../constants';\nimport { getWavesurfers, setPlayingState, setVideoValid, setLineRole, parseSegments, setErrorMsg, appendSegment, updateSegment, deleteSegment, updateLineRole, updateVideoInfo, setLoading } from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { formatTimeCallback, primaryLabelInterval, secondaryLabelInterval, timeInterval } from '../utils/TimelineUtil';\nnotification.config({\n  top: 60\n});\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\nclass WavesurferComp extends React.Component {\n  constructor() {\n    super();\n    this.setCurrentZoom = newZoom => {\n      if (newZoom) {\n        this.current.zoom = newZoom;\n      }\n      const {\n        zoom,\n        videoIndex,\n        wavesurfer\n      } = this.current;\n      if (wavesurfer) {\n        const duration = this.wavesurfers[videoIndex].getDuration();\n        const cursorTime = this.getCursorTime();\n        const currentTime = wavesurfer.getCurrentTime();\n        const {\n          offsetWidth\n        } = wavesurfer.container;\n        const {\n          offsetLeft\n        } = wavesurfer.cursor.cursor;\n        const totalWidth = offsetWidth * zoom;\n        const pxPerSec = totalWidth / duration;\n        wavesurfer.zoom(pxPerSec);\n        this.setCurrentScroll(cursorTime < 0 ? currentTime : cursorTime, cursorTime < 0 ? offsetWidth / 2 : offsetLeft, false);\n      }\n    };\n    this.handleKeyDown = e => {\n      if (!e.key) return;\n      if (window.disableLongAudioHotKeys) return;\n      if (isInput()) return;\n      if (isAnnotationReadonly(this.props.toolMode)) return;\n      if (e.altKey && this.props.segmentOverlap) {\n        this.altKeyDown = true;\n        if (this.hoveredRegion) {\n          this.hoveredRegion.drag = false;\n          this.hoveredRegion.resize = false;\n        }\n      }\n      switch (e.key.toLowerCase()) {\n        case 'backspace':\n        case 'delete':\n          this.deleteCurrentSegment();\n          break;\n        case 'z':\n          if (e.ctrlKey) {\n            this.recallHistory('undo');\n          }\n          break;\n        case 'y':\n          if (e.ctrlKey) {\n            this.recallHistory('redo');\n          }\n          break;\n        default:\n      }\n    };\n    this.handleKeyUp = e => {\n      if (!e.altKey) {\n        this.altKeyDown = false;\n        Object.values(this.current.wavesurfer.regions.list).forEach(region => {\n          region.drag = true;\n          region.resize = true;\n        });\n      }\n    };\n    this.handleRegionUpdate = region => {\n      const {\n        disableSegment,\n        annotateDisabled\n      } = this.props;\n      if (disableSegment || annotateDisabled) {\n        if (region) region.remove();\n        return;\n      }\n      if (!this.props.segmentOverlap) {\n        const overlappedRegions = Object.values(this.current.wavesurfer.regions.list).filter(r => !(r.end <= region.start || r.start >= region.end) && r !== region);\n        if (overlappedRegions.length > 0) {\n          // has overlapping\n          const minStart = Math.min(...overlappedRegions.map(r => r.start));\n          const maxEnd = Math.max(...overlappedRegions.map(r => r.end));\n          if (this.updatingRegionStart === region.start) {\n            // drag end handler\n            if (region.end > minStart) {\n              region.update({\n                end: minStart\n              });\n            }\n          } else if (this.updatingRegionEnd === region.end) {\n            // drag start handler\n            if (region.start < maxEnd) {\n              region.update({\n                start: maxEnd\n              });\n            }\n          } else if (region.start < this.updatingRegionStart) {\n            // move left\n            region.update({\n              start: maxEnd,\n              end: region.end - region.start + maxEnd\n            });\n          } else if (region.start > this.updatingRegionStart) {\n            // move right\n            region.update({\n              start: region.start - region.end + minStart,\n              end: minStart\n            });\n          }\n        }\n      }\n      this.updatingRegionStart = region.start;\n      this.updatingRegionEnd = region.end;\n      this.updateRegionElement(region);\n    };\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null,\n      // Minimap container\n      waveform: null,\n      // Waveform container\n      timeline: null,\n      // Timeline container\n      audioContainer: null,\n      // Cursor container\n      videoContainer: null // Video container\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      undoList: null,\n      redoList: null,\n      segmentSelected: null\n    };\n    this.updatingRegionStart = null;\n    this.updatingRegionEnd = null;\n    this.altKeyDown = false;\n    this.hoveredRegion = null;\n    this.state = {\n      cursorTime: 0 // seconds\n    };\n  }\n  get currentSegments() {\n    return this.props.results[this.current.videoIndex];\n  }\n  componentDidMount() {\n    this.props.getWavesurfers({\n      wavesurfers: this\n    });\n    this.timer = setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const {\n        wavesurfer\n      } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n    window.addEventListener('resize', this.setCurrentZoom);\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n  }\n  shouldComponentUpdate(nextProps) {\n    const currSeg = this.props.results[this.props.currentVideo][this.props.currentSegment];\n    const nextSeg = nextProps.results[nextProps.currentVideo][nextProps.currentSegment];\n    // return !isEqual(currSeg, nextSeg);\n    return (currSeg === null || currSeg === void 0 ? void 0 : currSeg.id) !== (nextSeg === null || nextSeg === void 0 ? void 0 : nextSeg.id) || nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n  componentDidUpdate() {\n    if (this.props.isLoadedAlaw) {\n      this.initWaveSurfer();\n    } else {\n      this.setCurrentSegment(this.props.currentSegment);\n    }\n  }\n  componentWillUnmount() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n    window.removeEventListener('resize', this.setCurrentZoom);\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach(c => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) {\n      this.initWaveSurfer();\n    }\n  }\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) {\n      this.initWaveSurfer();\n    }\n  }\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n  getSegmentIndexById(id) {\n    return this.currentSegments.findIndex(seg => seg.id === id);\n  }\n  getRegionById(id) {\n    return Object.values(this.current.wavesurfer.regions.list).find(r => r.data.id === id);\n  }\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [RegionsPlugin.create(), CursorPlugin.create({\n            width: '1px',\n            height: '10px',\n            container: this.container.audioContainer[i],\n            color: defaultColor.defaultGreen,\n            showTime: true,\n            opacity: 1,\n            customShowTimeStyle: {\n              color: defaultColor.defaultGreen,\n              fontSize: '14px',\n              paddingLeft: '5px',\n              position: 'absolute',\n              bottom: '3px'\n            },\n            formatTimeCallback: sec => {\n              this.setState({\n                cursorTime: sec\n              });\n              return formatTimestamp(sec);\n            }\n          }), TimelinePlugin.create({\n            container: this.container.timeline[i],\n            primaryFontColor: defaultColor.defaultWhite,\n            secondaryFontColor: defaultColor.defaultWhite,\n            primaryColor: defaultColor.defaultWhite,\n            secondaryColor: defaultColor.defaultWhite,\n            fontSize: '10',\n            notchPercentHeight: 30,\n            timeInterval,\n            primaryLabelInterval,\n            secondaryLabelInterval,\n            formatTimeCallback\n          }), MinimapPlugin.create({\n            container: this.container.minimap[i]\n          })]\n        });\n        urls[i] = this.container.videoContainer[i];\n        this.wavesurfers[i].on('ready', () => {\n          this.props.setLoading(false);\n          this.wavesurfers[i].pause();\n          if (!isAnnotationReadonly(this.props.toolMode)) {\n            this.wavesurfers[i].enableDragSelection({\n              color: hexToRgba(this.props.ontology.get('none'), defaultColor.defaultAlpha)\n            });\n          }\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            this.props.setErrorMsg({\n              errorMsg: e.toString()\n            });\n            return;\n          }\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (i === 0) {\n            this.setNewVideo();\n          }\n          this.wavesurfers[i].on('play', () => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', () => this.handlePlayPause());\n          this.wavesurfers[i].on('region-updated', region => this.handleRegionUpdate(region));\n          this.wavesurfers[i].on('region-update-end', region => this.handleRegionEdit(region));\n          this.wavesurfers[i].on('region-out', region => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', region => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (_, e) => e.preventDefault());\n          this.wavesurfers[i].on('region-mouseenter', region => {\n            this.hoveredRegion = region;\n            if (this.altKeyDown) {\n              this.hoveredRegion.drag = false;\n              this.hoveredRegion.resize = false;\n            }\n          });\n          this.wavesurfers[i].on('region-mouseleave', () => {\n            this.hoveredRegion = null;\n          });\n          this.props.setVideoValid({\n            index: i\n          });\n          this.props.updateVideoInfo({\n            index: i,\n            duration: this.wavesurfers[i].getDuration()\n          });\n        });\n        this.wavesurfers[i].on('error', () => {\n          notification.error({\n            message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}`\n          });\n          console.log('error', urls[i].src);\n          this.wavesurfers[i].destroy();\n        });\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n  initRegion(videoIndex, segments) {\n    // setup initial regions\n    const wavesurfer = this.wavesurfers[videoIndex];\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      const {\n        role\n      } = segment.content[0];\n      const region = wavesurfer.addRegion({\n        start: segment.start,\n        end: segment.end,\n        color: hexToRgba(this.props.ontology.get(role), defaultColor.defaultAlpha)\n      });\n      region.data = {\n        id: segment.id\n      };\n      this.updateRegionElement(region);\n    }\n  }\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n  parseSegments(videoIndex) {\n    const {\n      results,\n      ontology,\n      lineConfig,\n      segmentConfig,\n      keyAttribute,\n      minSegmentLength\n    } = this.props;\n    const segments = results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map(value => value.name);\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map(value => value.name);\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start & end\n      if (segment.start === null || segment.start === undefined || segment.end === null || segment.end === undefined) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        // eslint-disable-next-line no-console\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end || segment.end - segment.start < minSegmentLength) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      if (!segment.attributes) segment.attributes = {};\n      Object.keys(segment.attributes).forEach(key => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = line.attributes || {};\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach(key => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n    }\n    segments.sort((a, b) => a.start - b.start);\n    if (!this.props.segmentOverlap) {\n      for (let i = 0; i < segments.length - 1; i += 1) {\n        const currSeg = segments[i];\n        const nextSeg = segments[i + 1];\n        if (currSeg.end > nextSeg.start) {\n          currSeg.end = nextSeg.start;\n        }\n      }\n    }\n    this.props.parseSegments({\n      videoIndex,\n      segments\n    });\n    return segments;\n  }\n  playVideo() {\n    this.current.wavesurfer.play();\n  }\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n  setCurrentSpeed(speed) {\n    this.current.wavesurfer.setPlaybackRate(speed);\n  }\n  setPlayMode() {\n    // mode\n  }\n  setNewVideo() {\n    const {\n      videoIndex\n    } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      // eslint-disable-next-line no-console\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n  setCurrentVideo(newVideoIndex) {\n    const {\n      videoIndex\n    } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n  setCurrentScroll(destTime = 0, offsetLeft = 0, boundaryCheck) {\n    const {\n      wavesurfer\n    } = this.current;\n    const {\n      scrollLeft\n    } = wavesurfer.container.lastChild;\n    const {\n      offsetWidth\n    } = wavesurfer.container;\n    const {\n      minPxPerSec\n    } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) {\n      wavesurfer.drawer.recenter(scrollTime / duration);\n    } else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) {\n        wavesurfer.drawer.recenter(scrollTime / duration);\n      }\n    }\n  }\n  setCurrentSegment(currentSegment, start) {\n    const segment = this.currentSegments[currentSegment];\n    if (!segment) {\n      Object.values(this.current.wavesurfer.regions.list).forEach(r => r.element.classList.remove('selected'));\n      this.current.segmentSelected = null;\n      return;\n    }\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      if (region !== this.current.segmentSelected) {\n        Object.values(this.current.wavesurfer.regions.list).forEach(r => r.element.classList.remove('selected'));\n        region.element.classList.add('selected');\n        this.current.segmentSelected = region;\n      }\n      const s = start || region.start;\n      this.seekCurrentAudio(s);\n      this.setCurrentScroll(s, 0, true);\n    }\n    if (this.props.currentPlayMode !== 'overallLoop') {\n      this.current.wavesurfer.play();\n    }\n  }\n  setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole) {\n    if (videoIndex === this.current.videoIndex) {\n      const segments = this.props.results[videoIndex];\n      const segment = segments[segmentIndex];\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        region.update({\n          color: hexToRgba(this.props.ontology.get(role), defaultColor.defaultAlpha)\n        });\n      }\n      this.addHistory('role', {\n        segmentIndex,\n        lineIndex,\n        prevRole,\n        nextRole: role\n      });\n    }\n  }\n  setSegmentStartEnd(videoIndex, segmentIndex, start, end) {\n    if (videoIndex === this.current.videoIndex) {\n      const segments = this.props.results[videoIndex];\n      const segment = segments[segmentIndex];\n      const prevSegment = cloneDeep(segment);\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        region.update({\n          start,\n          end\n        });\n      }\n      this.addHistory('segment', {\n        segmentIndex,\n        prevSegment,\n        nextSegment: cloneDeep(segment),\n        region\n      });\n    }\n  }\n  seekCurrentAudio(currentTime = 0) {\n    const {\n      wavesurfer\n    } = this.current;\n    const duration = wavesurfer.getDuration();\n    wavesurfer.backend.seekTo(Math.min(Math.max(currentTime, 0), duration));\n  }\n  deleteCurrentSegment() {\n    const {\n      currentSegment\n    } = this.props;\n    const segment = this.currentSegments[currentSegment];\n    if (segment) {\n      const region = this.getRegionById(segment.id);\n      this.addHistory('segment', {\n        segmentIndex: currentSegment,\n        prevSegment: cloneDeep(segment),\n        region\n      });\n      if (region) {\n        region.remove();\n      }\n      this.props.deleteSegment({\n        segmentIndex: currentSegment\n      });\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      const currentSegmentIndex = this.currentSegments.findIndex(seg => seg.start <= currentTime && seg.end >= currentTime);\n      this.props.setCurrentSegment({\n        index: currentSegmentIndex,\n        start: currentTime\n      });\n      this.current.segmentSelected = null;\n    }\n  }\n  handlePlayPause() {\n    this.props.setPlayingState({\n      isPlaying: this.current.wavesurfer.isPlaying()\n    });\n  }\n  handleRegionEdit(region) {\n    const {\n      disableSegment,\n      annotateDisabled\n    } = this.props;\n    if (disableSegment || annotateDisabled) {\n      if (region) region.remove();\n      return;\n    }\n    this.updatingRegionStart = null;\n    this.updatingRegionEn = null;\n    const {\n      id\n    } = region.data;\n    const duration = this.current.wavesurfer.getDuration();\n    region.start = Math.max(region.start, 0);\n    region.end = Math.min(region.end, duration);\n    const {\n      minSegmentLength,\n      segmentConfig,\n      lineConfig\n    } = this.props;\n    if (!id) {\n      // create region\n      if (region.end - region.start < minSegmentLength) {\n        region.remove();\n        return;\n      }\n      const currentLen = this.currentSegments.length;\n      const segment = createSegment(region.start, region.end, segmentConfig, lineConfig);\n      // eslint-disable-next-line no-param-reassign\n      region.data.id = segment.id;\n      region.play();\n      this.props.appendSegment({\n        segment\n      });\n      this.addHistory('segment', {\n        segmentIndex: currentLen,\n        nextSegment: cloneDeep(segment),\n        region\n      });\n    } else {\n      // update region\n      const segmentIndex = this.getSegmentIndexById(id);\n      if (segmentIndex >= 0) {\n        const segment = this.currentSegments[segmentIndex];\n        const prevSegment = cloneDeep(segment);\n        let {\n          start,\n          end\n        } = region;\n        if (end - start < minSegmentLength) {\n          const draggingStart = end === segment.end;\n          const draggingEnd = start === segment.start;\n          if (draggingStart) {\n            start = end - minSegmentLength;\n          } else if (draggingEnd) {\n            end = start + minSegmentLength;\n          }\n        }\n        region.update({\n          start,\n          end\n        });\n        segment.start = start;\n        segment.end = end;\n        this.props.updateSegment({\n          segment\n        });\n        this.addHistory('segment', {\n          segmentIndex,\n          prevSegment,\n          nextSegment: cloneDeep(segment),\n          region\n        });\n      }\n    }\n  }\n  handleRegionOut(region) {\n    const segment = this.currentSegments[this.props.currentSegment];\n    if (!segment) {\n      return;\n    }\n    const currentRegion = this.getRegionById(segment.id);\n    if (currentRegion === region) {\n      if (this.props.currentPlayMode === 'overallLoop') {\n        this.props.setCurrentSegment({\n          index: -1\n        });\n      } else if (this.props.currentPlayMode === 'regionLoop') {\n        this.seekCurrentAudio(region.start);\n        this.setCurrentScroll(region.start, 0, true);\n      } else if (this.props.currentPlayMode === 'regionPlay') {\n        this.current.wavesurfer.pause();\n        this.seekCurrentAudio(region.end);\n      }\n    }\n  }\n  handleRegionIn(region) {\n    if (this.props.currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentIndexById(region.data.id);\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      if (segmentIndex !== this.props.currentSegment && segmentIndex >= 0) {\n        this.props.setCurrentSegment({\n          index: segmentIndex,\n          start: currentTime\n        });\n      }\n    }\n  }\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const segmentIndex = this.getSegmentIndexById(region.data.id);\n    if (segmentIndex >= 0) {\n      const cursorTime = this.getCursorTime();\n      const start = cursorTime > 0 && (e.altKey || e.ctrlKey) || this.props.currentPlayMode === 'overallLoop' ? cursorTime : null;\n      this.props.setCurrentSegment({\n        index: segmentIndex,\n        start\n      });\n    }\n  }\n  addHistory(type, data) {\n    // update redo list each time\n    this.current.redoList = [];\n    this.current.undoList.push({\n      type,\n      data\n    });\n    if (this.current.undoList.length > 50) {\n      this.current.undoList.shift();\n    }\n  }\n  recallHistory(action) {\n    const {\n      undoList,\n      redoList\n    } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) {\n      return;\n    }\n    this.props.setCurrentSegment({\n      index: -1\n    });\n    const recallItem = recallList.pop();\n    const {\n      type,\n      data\n    } = recallItem;\n    switch (type) {\n      case 'segment':\n        {\n          const {\n            segmentIndex,\n            prevSegment,\n            nextSegment,\n            region\n          } = data;\n          const currSegment = action === 'undo' ? prevSegment : nextSegment;\n          const otherSegment = action === 'undo' ? nextSegment : prevSegment;\n          if (currSegment && otherSegment) {\n            this.props.updateSegment({\n              segment: currSegment\n            });\n            const currentRegion = this.getRegionById(currSegment.id);\n            currentRegion.update({\n              start: currSegment.start,\n              end: currSegment.end\n            });\n          } else if (region && currSegment && !otherSegment) {\n            this.props.appendSegment({\n              segmentIndex,\n              segment: currSegment\n            });\n            const currentRegion = this.current.wavesurfer.regions.add(region);\n            this.updateRegionElement(currentRegion);\n          } else if (region && !currSegment && otherSegment) {\n            this.props.deleteSegment({\n              segmentIndex\n            });\n            const currentRegion = this.getRegionById(otherSegment.id);\n            currentRegion.remove();\n          }\n          break;\n        }\n      case 'role':\n        {\n          const {\n            segmentIndex,\n            lineIndex,\n            prevRole,\n            nextRole\n          } = data;\n          const currRole = action === 'undo' ? prevRole : nextRole;\n          this.props.updateLineRole({\n            segmentIndex,\n            lineIndex,\n            role: currRole\n          });\n          const region = this.getRegionById(this.currentSegments[segmentIndex].id);\n          if (region) {\n            region.update({\n              color: hexToRgba(this.props.ontology.get(currRole), defaultColor.defaultAlpha)\n            });\n          }\n          break;\n        }\n      default:\n        break;\n    }\n    (action === 'undo' ? redoList : undoList).push(recallItem);\n  }\n  updateRegionElement(region) {\n    const {\n      element,\n      start,\n      end\n    } = region;\n    element.classList.add('dragged-region');\n    if (this.props.spaceLine > 0) {\n      const offset = this.props.spaceLine / (end - start);\n      let startLine = element.querySelector('.space-line.space-line-start');\n      let endLine = element.querySelector('.space-line.space-line-end');\n      if (offset < 0.5) {\n        if (!startLine) {\n          startLine = document.createElement('div');\n          startLine.className = 'space-line space-line-start';\n          element.appendChild(startLine);\n        }\n        if (!endLine) {\n          endLine = document.createElement('div');\n          endLine.className = 'space-line space-line-end';\n          element.appendChild(endLine);\n        }\n        startLine.style.left = `${offset * 100}%`;\n        endLine.style.right = `${offset * 100}%`;\n      } else {\n        if (startLine) {\n          startLine.remove();\n        }\n        if (endLine) {\n          endLine.remove();\n        }\n      }\n    }\n  }\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const {\n          zoom,\n          wavesurfer\n        } = this.current;\n        if (!cursorHelper) {\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer.cursor.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const {\n          offsetWidth\n        } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = totalWidth / duration * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n  render() {\n    return null;\n  }\n}\nconst mapStateToProps = state => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  segmentOverlap: state.segmentOverlap,\n  keyAttribute: state.keyAttribute,\n  disableSegment: state.disableSegment,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw\n});\nconst mapDispatchToProps = {\n  getWavesurfers,\n  setPlayingState,\n  setVideoValid,\n  setLineRole,\n  parseSegments,\n  setErrorMsg,\n  appendSegment,\n  updateSegment,\n  deleteSegment,\n  updateLineRole,\n  updateVideoInfo,\n  setLoading\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(WavesurferComp);","map":{"version":3,"names":["React","hexToRgba","WaveSurfer","TimelinePlugin","RegionsPlugin","CursorPlugin","MinimapPlugin","connect","v4","uuid","cloneDeep","notification","defaultColor","formatTimestamp","translate","getWavesurfers","setPlayingState","setVideoValid","setLineRole","parseSegments","setErrorMsg","appendSegment","updateSegment","deleteSegment","updateLineRole","updateVideoInfo","setLoading","createLine","createSegment","isInput","isAnnotationReadonly","formatTimeCallback","primaryLabelInterval","secondaryLabelInterval","timeInterval","config","top","ANCHOR_MOVEMENT_STEP","WavesurferComp","Component","constructor","setCurrentZoom","newZoom","current","zoom","videoIndex","wavesurfer","duration","wavesurfers","getDuration","cursorTime","getCursorTime","currentTime","getCurrentTime","offsetWidth","container","offsetLeft","cursor","totalWidth","pxPerSec","setCurrentScroll","handleKeyDown","e","key","window","disableLongAudioHotKeys","props","toolMode","altKey","segmentOverlap","altKeyDown","hoveredRegion","drag","resize","toLowerCase","deleteCurrentSegment","ctrlKey","recallHistory","handleKeyUp","Object","values","regions","list","forEach","region","handleRegionUpdate","disableSegment","annotateDisabled","remove","overlappedRegions","filter","r","end","start","length","minStart","Math","min","map","maxEnd","max","updatingRegionStart","update","updatingRegionEnd","updateRegionElement","undoList","redoList","minimap","waveform","timeline","audioContainer","videoContainer","segmentSelected","state","currentSegments","results","componentDidMount","timer","setInterval","isPlaying","timestamp","innerText","addEventListener","shouldComponentUpdate","nextProps","currSeg","currentVideo","currentSegment","nextSeg","id","isLoadedAlaw","componentDidUpdate","initWaveSurfer","setCurrentSegment","componentWillUnmount","clearInterval","removeEventListener","Array","isArray","c","updateMeasurement","getAudioContainer","getVideoContainer","getSegmentIndexById","findIndex","seg","getRegionById","find","data","size","videos","urls","i","loaded","create","autoCenter","backend","normalize","loopSelection","scrollParent","backgroundColor","defaultGray","waveColor","darkGray","progressColor","cursorColor","defaultRed","pixelRatio","maxCanvasWidth","plugins","width","height","color","defaultGreen","showTime","opacity","customShowTimeStyle","fontSize","paddingLeft","position","bottom","sec","setState","primaryFontColor","defaultWhite","secondaryFontColor","primaryColor","secondaryColor","notchPercentHeight","on","pause","enableDragSelection","ontology","get","defaultAlpha","segments","errorMsg","toString","initRegion","initMiniMap","setNewVideo","handlePlayPause","handleRegionEdit","handleRegionOut","handleRegionIn","handleRegionClick","_","preventDefault","index","error","message","console","log","src","destroy","load","segmentIndex","segment","role","content","addRegion","wave","getElementsByTagName","document","createElement","className","appendChild","lineConfig","segmentConfig","keyAttribute","minSegmentLength","segmentConfigValidKeys","fields","value","name","push","lineConfigValidKeys","ontologyValidKeys","startNum","Number","isNaN","Error","JSON","stringify","endNum","undefined","splice","attributes","keys","indexOf","line","arr","sort","a","b","playVideo","play","pauseVideo","forwardVideo","skipForward","backwardVideo","skipBackward","setCurrentSpeed","speed","setPlaybackRate","setPlayMode","isDestroyed","setCurrentVideo","newVideoIndex","destTime","boundaryCheck","scrollLeft","lastChild","minPxPerSec","params","scrollTime","drawer","recenter","rightBoundaryTime","leftBoundaryTime","element","classList","add","s","seekCurrentAudio","currentPlayMode","setLineColor","lineIndex","prevRole","addHistory","nextRole","setSegmentStartEnd","prevSegment","nextSegment","seekTo","currentSegmentIndex","updatingRegionEn","currentLen","draggingStart","draggingEnd","currentRegion","stopPropagation","type","shift","action","recallList","recallItem","pop","currSegment","otherSegment","currRole","spaceLine","offset","startLine","querySelector","endLine","style","left","right","cursorHelper","getElementsByClassName","selectedMeasurement","render","mapStateToProps","mapDispatchToProps"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/WavesurferComp/DragWavesurferComp.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\nimport React from 'react';\nimport hexToRgba from 'hex-to-rgba';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { defaultColor, formatTimestamp, translate } from '../../constants';\nimport {\n  getWavesurfers,\n  setPlayingState,\n  setVideoValid,\n  setLineRole,\n  parseSegments,\n  setErrorMsg,\n  appendSegment,\n  updateSegment,\n  deleteSegment,\n  updateLineRole,\n  updateVideoInfo,\n  setLoading,\n} from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { formatTimeCallback, primaryLabelInterval, secondaryLabelInterval, timeInterval } from '../utils/TimelineUtil';\n\nnotification.config({ top: 60 });\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\n\nclass WavesurferComp extends React.Component {\n  constructor() {\n    super();\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null, // Minimap container\n      waveform: null, // Waveform container\n      timeline: null, // Timeline container\n      audioContainer: null, // Cursor container\n      videoContainer: null, // Video container\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      undoList: null,\n      redoList: null,\n      segmentSelected: null,\n    };\n    this.updatingRegionStart = null;\n    this.updatingRegionEnd = null;\n    this.altKeyDown = false;\n    this.hoveredRegion = null;\n    this.state = {\n      cursorTime: 0, // seconds\n    };\n  }\n\n  get currentSegments() {\n    return this.props.results[this.current.videoIndex];\n  }\n\n  componentDidMount() {\n    this.props.getWavesurfers({ wavesurfers: this });\n    this.timer = setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const { wavesurfer } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n    window.addEventListener('resize', this.setCurrentZoom);\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n  }\n\n  shouldComponentUpdate(nextProps) {\n    const currSeg = this.props.results[this.props.currentVideo][this.props.currentSegment];\n    const nextSeg = nextProps.results[nextProps.currentVideo][nextProps.currentSegment];\n    // return !isEqual(currSeg, nextSeg);\n    return currSeg?.id !== nextSeg?.id || nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n\n  componentDidUpdate() {\n    if (this.props.isLoadedAlaw) {\n      this.initWaveSurfer();\n    } else {\n      this.setCurrentSegment(this.props.currentSegment);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n    window.removeEventListener('resize', this.setCurrentZoom);\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach((c) => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) {\n      this.initWaveSurfer();\n    }\n  }\n\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) {\n      this.initWaveSurfer();\n    }\n  }\n\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n\n  getSegmentIndexById(id) {\n    return this.currentSegments.findIndex((seg) => seg.id === id);\n  }\n\n  getRegionById(id) {\n    return Object.values(this.current.wavesurfer.regions.list).find((r) => r.data.id === id);\n  }\n\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [\n            RegionsPlugin.create(),\n            CursorPlugin.create({\n              width: '1px',\n              height: '10px',\n              container: this.container.audioContainer[i],\n              color: defaultColor.defaultGreen,\n              showTime: true,\n              opacity: 1,\n              customShowTimeStyle: {\n                color: defaultColor.defaultGreen,\n                fontSize: '14px',\n                paddingLeft: '5px',\n                position: 'absolute',\n                bottom: '3px',\n              },\n              formatTimeCallback: (sec) => {\n                this.setState({ cursorTime: sec });\n                return formatTimestamp(sec);\n              },\n            }),\n            TimelinePlugin.create({\n              container: this.container.timeline[i],\n              primaryFontColor: defaultColor.defaultWhite,\n              secondaryFontColor: defaultColor.defaultWhite,\n              primaryColor: defaultColor.defaultWhite,\n              secondaryColor: defaultColor.defaultWhite,\n              fontSize: '10',\n              notchPercentHeight: 30,\n              timeInterval,\n              primaryLabelInterval,\n              secondaryLabelInterval,\n              formatTimeCallback,\n            }),\n            MinimapPlugin.create({\n              container: this.container.minimap[i],\n            }),\n          ],\n        });\n        urls[i] = this.container.videoContainer[i];\n\n        this.wavesurfers[i].on('ready', () => {\n          this.props.setLoading(false);\n          this.wavesurfers[i].pause();\n          if (!isAnnotationReadonly(this.props.toolMode)) {\n            this.wavesurfers[i].enableDragSelection({\n              color: hexToRgba(this.props.ontology.get('none'), defaultColor.defaultAlpha),\n            });\n          }\n\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            this.props.setErrorMsg({ errorMsg: e.toString() });\n            return;\n          }\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (i === 0) {\n            this.setNewVideo();\n          }\n          this.wavesurfers[i].on('play', () => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', () => this.handlePlayPause());\n          this.wavesurfers[i].on('region-updated', (region) => this.handleRegionUpdate(region));\n          this.wavesurfers[i].on('region-update-end', (region) => this.handleRegionEdit(region));\n          this.wavesurfers[i].on('region-out', (region) => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', (region) => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (_, e) => e.preventDefault());\n          this.wavesurfers[i].on('region-mouseenter', (region) => {\n            this.hoveredRegion = region;\n            if (this.altKeyDown) {\n              this.hoveredRegion.drag = false;\n              this.hoveredRegion.resize = false;\n            }\n          });\n          this.wavesurfers[i].on('region-mouseleave', () => {\n            this.hoveredRegion = null;\n          });\n          this.props.setVideoValid({ index: i });\n          this.props.updateVideoInfo({ index: i, duration: this.wavesurfers[i].getDuration() });\n        });\n        this.wavesurfers[i].on('error', () => {\n          notification.error({ message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}` });\n          console.log('error', urls[i].src);\n          this.wavesurfers[i].destroy();\n        });\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n\n  initRegion(videoIndex, segments) {\n    // setup initial regions\n    const wavesurfer = this.wavesurfers[videoIndex];\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      const { role } = segment.content[0];\n      const region = wavesurfer.addRegion({\n        start: segment.start,\n        end: segment.end,\n        color: hexToRgba(this.props.ontology.get(role), defaultColor.defaultAlpha),\n      });\n      region.data = { id: segment.id };\n      this.updateRegionElement(region);\n    }\n  }\n\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n\n  parseSegments(videoIndex) {\n    const { results, ontology, lineConfig, segmentConfig, keyAttribute, minSegmentLength } = this.props;\n    const segments = results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map((value) => value.name);\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map((value) => value.name);\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start & end\n      if (segment.start === null || segment.start === undefined || segment.end === null || segment.end === undefined) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        // eslint-disable-next-line no-console\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end || segment.end - segment.start < minSegmentLength) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      if (!segment.attributes) segment.attributes = {};\n      Object.keys(segment.attributes).forEach((key) => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = line.attributes || {};\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach((key) => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n    }\n    segments.sort((a, b) => a.start - b.start);\n    if (!this.props.segmentOverlap) {\n      for (let i = 0; i < segments.length - 1; i += 1) {\n        const currSeg = segments[i];\n        const nextSeg = segments[i + 1];\n        if (currSeg.end > nextSeg.start) {\n          currSeg.end = nextSeg.start;\n        }\n      }\n    }\n    this.props.parseSegments({\n      videoIndex,\n      segments,\n    });\n    return segments;\n  }\n\n  playVideo() {\n    this.current.wavesurfer.play();\n  }\n\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n\n  setCurrentSpeed(speed) {\n    this.current.wavesurfer.setPlaybackRate(speed);\n  }\n\n  setPlayMode() {\n    // mode\n  }\n\n  setNewVideo() {\n    const { videoIndex } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      // eslint-disable-next-line no-console\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n\n  setCurrentVideo(newVideoIndex) {\n    const { videoIndex } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n\n  setCurrentZoom = (newZoom) => {\n    if (newZoom) {\n      this.current.zoom = newZoom;\n    }\n    const { zoom, videoIndex, wavesurfer } = this.current;\n    if (wavesurfer) {\n      const duration = this.wavesurfers[videoIndex].getDuration();\n      const cursorTime = this.getCursorTime();\n      const currentTime = wavesurfer.getCurrentTime();\n      const { offsetWidth } = wavesurfer.container;\n      const { offsetLeft } = wavesurfer.cursor.cursor;\n      const totalWidth = offsetWidth * zoom;\n      const pxPerSec = totalWidth / duration;\n      wavesurfer.zoom(pxPerSec);\n      this.setCurrentScroll(\n        cursorTime < 0 ? currentTime : cursorTime,\n        cursorTime < 0 ? offsetWidth / 2 : offsetLeft,\n        false,\n      );\n    }\n  };\n\n  setCurrentScroll(destTime = 0, offsetLeft = 0, boundaryCheck) {\n    const { wavesurfer } = this.current;\n    const { scrollLeft } = wavesurfer.container.lastChild;\n    const { offsetWidth } = wavesurfer.container;\n    const { minPxPerSec } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) {\n      wavesurfer.drawer.recenter(scrollTime / duration);\n    } else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) {\n        wavesurfer.drawer.recenter(scrollTime / duration);\n      }\n    }\n  }\n\n  setCurrentSegment(currentSegment, start) {\n    const segment = this.currentSegments[currentSegment];\n    if (!segment) {\n      Object.values(this.current.wavesurfer.regions.list).forEach((r) => r.element.classList.remove('selected'));\n      this.current.segmentSelected = null;\n      return;\n    }\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      if (region !== this.current.segmentSelected) {\n        Object.values(this.current.wavesurfer.regions.list).forEach((r) => r.element.classList.remove('selected'));\n        region.element.classList.add('selected');\n        this.current.segmentSelected = region;\n      }\n      const s = start || region.start;\n      this.seekCurrentAudio(s);\n      this.setCurrentScroll(s, 0, true);\n    }\n    if (this.props.currentPlayMode !== 'overallLoop') {\n      this.current.wavesurfer.play();\n    }\n  }\n\n  setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole) {\n    if (videoIndex === this.current.videoIndex) {\n      const segments = this.props.results[videoIndex];\n      const segment = segments[segmentIndex];\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        region.update({\n          color: hexToRgba(this.props.ontology.get(role), defaultColor.defaultAlpha),\n        });\n      }\n      this.addHistory('role', {\n        segmentIndex,\n        lineIndex,\n        prevRole,\n        nextRole: role,\n      });\n    }\n  }\n\n  setSegmentStartEnd(videoIndex, segmentIndex, start, end) {\n    if (videoIndex === this.current.videoIndex) {\n      const segments = this.props.results[videoIndex];\n      const segment = segments[segmentIndex];\n      const prevSegment = cloneDeep(segment);\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        region.update({ start, end });\n      }\n      this.addHistory('segment', {\n        segmentIndex,\n        prevSegment,\n        nextSegment: cloneDeep(segment),\n        region,\n      });\n    }\n  }\n\n  seekCurrentAudio(currentTime = 0) {\n    const { wavesurfer } = this.current;\n    const duration = wavesurfer.getDuration();\n    wavesurfer.backend.seekTo(Math.min(Math.max(currentTime, 0), duration));\n  }\n\n  deleteCurrentSegment() {\n    const { currentSegment } = this.props;\n    const segment = this.currentSegments[currentSegment];\n    if (segment) {\n      const region = this.getRegionById(segment.id);\n      this.addHistory('segment', {\n        segmentIndex: currentSegment,\n        prevSegment: cloneDeep(segment),\n        region,\n      });\n      if (region) {\n        region.remove();\n      }\n      this.props.deleteSegment({ segmentIndex: currentSegment });\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      const currentSegmentIndex = this.currentSegments.findIndex((seg) => seg.start <= currentTime && seg.end >= currentTime);\n      this.props.setCurrentSegment({ index: currentSegmentIndex, start: currentTime });\n      this.current.segmentSelected = null;\n    }\n  }\n\n  handleKeyDown = (e) => {\n    if (!e.key) return;\n    if (window.disableLongAudioHotKeys) return;\n    if (isInput()) return;\n    if (isAnnotationReadonly(this.props.toolMode)) return;\n    if (e.altKey && this.props.segmentOverlap) {\n      this.altKeyDown = true;\n      if (this.hoveredRegion) {\n        this.hoveredRegion.drag = false;\n        this.hoveredRegion.resize = false;\n      }\n    }\n    switch (e.key.toLowerCase()) {\n      case 'backspace':\n      case 'delete':\n        this.deleteCurrentSegment();\n        break;\n      case 'z':\n        if (e.ctrlKey) {\n          this.recallHistory('undo');\n        }\n        break;\n      case 'y':\n        if (e.ctrlKey) {\n          this.recallHistory('redo');\n        }\n        break;\n      default:\n    }\n  };\n\n  handleKeyUp = (e) => {\n    if (!e.altKey) {\n      this.altKeyDown = false;\n      Object.values(this.current.wavesurfer.regions.list).forEach((region) => {\n        region.drag = true;\n        region.resize = true;\n      });\n    }\n  };\n\n  handlePlayPause() {\n    this.props.setPlayingState({\n      isPlaying: this.current.wavesurfer.isPlaying(),\n    });\n  }\n\n  handleRegionUpdate = (region) => {\n    const { disableSegment, annotateDisabled } = this.props;\n    if (disableSegment || annotateDisabled) {\n      if (region) region.remove();\n      return;\n    }\n    if (!this.props.segmentOverlap) {\n      const overlappedRegions = Object.values(this.current.wavesurfer.regions.list).filter((r) => !(r.end <= region.start || r.start >= region.end) && r !== region);\n      if (overlappedRegions.length > 0) {\n        // has overlapping\n        const minStart = Math.min(...overlappedRegions.map((r) => r.start));\n        const maxEnd = Math.max(...overlappedRegions.map((r) => r.end));\n        if (this.updatingRegionStart === region.start) {\n          // drag end handler\n          if (region.end > minStart) {\n            region.update({ end: minStart });\n          }\n        } else if (this.updatingRegionEnd === region.end) {\n          // drag start handler\n          if (region.start < maxEnd) {\n            region.update({ start: maxEnd });\n          }\n        } else if (region.start < this.updatingRegionStart) {\n          // move left\n          region.update({ start: maxEnd, end: region.end - region.start + maxEnd });\n        } else if (region.start > this.updatingRegionStart) {\n          // move right\n          region.update({ start: region.start - region.end + minStart, end: minStart });\n        }\n      }\n    }\n    this.updatingRegionStart = region.start;\n    this.updatingRegionEnd = region.end;\n    this.updateRegionElement(region);\n  };\n\n  handleRegionEdit(region) {\n    const { disableSegment, annotateDisabled } = this.props;\n    if (disableSegment || annotateDisabled) {\n      if (region) region.remove();\n      return;\n    }\n    this.updatingRegionStart = null;\n    this.updatingRegionEn = null;\n\n    const { id } = region.data;\n    const duration = this.current.wavesurfer.getDuration();\n    region.start = Math.max(region.start, 0);\n    region.end = Math.min(region.end, duration);\n    const { minSegmentLength, segmentConfig, lineConfig } = this.props;\n    if (!id) {\n      // create region\n      if (region.end - region.start < minSegmentLength) {\n        region.remove();\n        return;\n      }\n      const currentLen = this.currentSegments.length;\n      const segment = createSegment(region.start, region.end, segmentConfig, lineConfig);\n      // eslint-disable-next-line no-param-reassign\n      region.data.id = segment.id;\n      region.play();\n      this.props.appendSegment({ segment });\n      this.addHistory('segment', {\n        segmentIndex: currentLen,\n        nextSegment: cloneDeep(segment),\n        region,\n      });\n    } else {\n      // update region\n      const segmentIndex = this.getSegmentIndexById(id);\n      if (segmentIndex >= 0) {\n        const segment = this.currentSegments[segmentIndex];\n        const prevSegment = cloneDeep(segment);\n        let { start, end } = region;\n        if (end - start < minSegmentLength) {\n          const draggingStart = end === segment.end;\n          const draggingEnd = start === segment.start;\n          if (draggingStart) {\n            start = end - minSegmentLength;\n          } else if (draggingEnd) {\n            end = start + minSegmentLength;\n          }\n        }\n        region.update({ start, end });\n        segment.start = start;\n        segment.end = end;\n        this.props.updateSegment({ segment });\n        this.addHistory('segment', {\n          segmentIndex,\n          prevSegment,\n          nextSegment: cloneDeep(segment),\n          region,\n        });\n      }\n    }\n  }\n\n  handleRegionOut(region) {\n    const segment = this.currentSegments[this.props.currentSegment];\n    if (!segment) {\n      return;\n    }\n    const currentRegion = this.getRegionById(segment.id);\n    if (currentRegion === region) {\n      if (this.props.currentPlayMode === 'overallLoop') {\n        this.props.setCurrentSegment({ index: -1 });\n      } else if (this.props.currentPlayMode === 'regionLoop') {\n        this.seekCurrentAudio(region.start);\n        this.setCurrentScroll(region.start, 0, true);\n      } else if (this.props.currentPlayMode === 'regionPlay') {\n        this.current.wavesurfer.pause();\n        this.seekCurrentAudio(region.end);\n      }\n    }\n  }\n\n  handleRegionIn(region) {\n    if (this.props.currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentIndexById(region.data.id);\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      if (segmentIndex !== this.props.currentSegment && segmentIndex >= 0) {\n        this.props.setCurrentSegment({ index: segmentIndex, start: currentTime });\n      }\n    }\n  }\n\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const segmentIndex = this.getSegmentIndexById(region.data.id);\n    if (segmentIndex >= 0) {\n      const cursorTime = this.getCursorTime();\n      const start = ((cursorTime > 0 && (e.altKey || e.ctrlKey)) || this.props.currentPlayMode === 'overallLoop') ? cursorTime : null;\n      this.props.setCurrentSegment({ index: segmentIndex, start });\n    }\n  }\n\n  addHistory(type, data) {\n    // update redo list each time\n    this.current.redoList = [];\n    this.current.undoList.push({ type, data });\n    if (this.current.undoList.length > 50) {\n      this.current.undoList.shift();\n    }\n  }\n\n  recallHistory(action) {\n    const { undoList, redoList } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) {\n      return;\n    }\n\n    this.props.setCurrentSegment({ index: -1 });\n    const recallItem = recallList.pop();\n    const { type, data } = recallItem;\n    switch (type) {\n      case 'segment': {\n        const { segmentIndex, prevSegment, nextSegment, region } = data;\n        const currSegment = action === 'undo' ? prevSegment : nextSegment;\n        const otherSegment = action === 'undo' ? nextSegment : prevSegment;\n        if (currSegment && otherSegment) {\n          this.props.updateSegment({ segment: currSegment });\n          const currentRegion = this.getRegionById(currSegment.id);\n          currentRegion.update({ start: currSegment.start, end: currSegment.end });\n        } else if (region && currSegment && !otherSegment) {\n          this.props.appendSegment({ segmentIndex, segment: currSegment });\n          const currentRegion = this.current.wavesurfer.regions.add(region);\n          this.updateRegionElement(currentRegion);\n        } else if (region && !currSegment && otherSegment) {\n          this.props.deleteSegment({ segmentIndex });\n          const currentRegion = this.getRegionById(otherSegment.id);\n          currentRegion.remove();\n        }\n        break;\n      }\n      case 'role': {\n        const { segmentIndex, lineIndex, prevRole, nextRole } = data;\n        const currRole = action === 'undo' ? prevRole : nextRole;\n        this.props.updateLineRole({ segmentIndex, lineIndex, role: currRole });\n        const region = this.getRegionById(this.currentSegments[segmentIndex].id);\n        if (region) {\n          region.update({\n            color: hexToRgba(this.props.ontology.get(currRole), defaultColor.defaultAlpha),\n          });\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    (action === 'undo' ? redoList : undoList).push(recallItem);\n  }\n\n  updateRegionElement(region) {\n    const { element, start, end } = region;\n    element.classList.add('dragged-region');\n    if (this.props.spaceLine > 0) {\n      const offset = this.props.spaceLine / (end - start);\n      let startLine = element.querySelector('.space-line.space-line-start');\n      let endLine = element.querySelector('.space-line.space-line-end');\n      if (offset < 0.5) {\n        if (!startLine) {\n          startLine = document.createElement('div');\n          startLine.className = 'space-line space-line-start';\n          element.appendChild(startLine);\n        }\n        if (!endLine) {\n          endLine = document.createElement('div');\n          endLine.className = 'space-line space-line-end';\n          element.appendChild(endLine);\n        }\n        startLine.style.left = `${offset * 100}%`;\n        endLine.style.right = `${offset * 100}%`;\n      } else {\n        if (startLine) {\n          startLine.remove();\n        }\n        if (endLine) {\n          endLine.remove();\n        }\n      }\n    }\n  }\n\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const { zoom, wavesurfer } = this.current;\n        if (!cursorHelper) {\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer.cursor.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const { offsetWidth } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = (totalWidth / duration) * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n\n  render() { return null; }\n}\n\nconst mapStateToProps = (state) => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  segmentOverlap: state.segmentOverlap,\n  keyAttribute: state.keyAttribute,\n  disableSegment: state.disableSegment,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw,\n});\nconst mapDispatchToProps = {\n  getWavesurfers,\n  setPlayingState,\n  setVideoValid,\n  setLineRole,\n  parseSegments,\n  setErrorMsg,\n  appendSegment,\n  updateSegment,\n  deleteSegment,\n  updateLineRole,\n  updateVideoInfo,\n  setLoading,\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(WavesurferComp);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}