{"ast":null,"code":"/** @module utils */\n\n/** Test if two intervals overlap */\nfunction doIntervalsOverlap(interval1, interval2) {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const overlapAmount = Math.max(0, Math.min(end1, end2) - Math.max(start1, start2));\n  return overlapAmount > 0;\n}\n\n/** Test for near equivalence in float values.  From here http://realtimecollisiondetection.net/blog/?p=89 */\nfunction isClose(a, b, relTol = 1e-14, abs_tol = 0.0) {\n  return Math.abs(a - b) <= Math.max(relTol * Math.max(Math.abs(a), Math.abs(b)), abs_tol);\n}\n\n/** Pass to sort, when sorting a list of entries to sort entries by start time */\nfunction sortCompareEntriesByTime(x, y) {\n  return x[0] - y[0];\n}\n\n/**\n * Builds a balanced binary tree from an entry list for quickly finding things at certain times\n * @param {Array} entryList - can consist of intervals or points in time\n * @return {Object} The root node of the tree. Each node has a left and right branch;\n *  nodes in the left branch occur in time before the start time in parent nodes\n *  nodes in the right branch occur in time after the stop time in parent nodes\n */\nfunction entryListToTree(entryList) {\n  entryList.sort(sortCompareEntriesByTime);\n  const rootNode = recEntryListToTree(entryList);\n  return rootNode;\n}\n\n/** Helper function that recursively builds a balanced binary tree */\nfunction recEntryListToTree(entryList) {\n  let currentNode = null;\n  if (entryList.length > 0) {\n    const halfIndex = Math.floor(entryList.length / 2);\n    const entry = entryList[halfIndex];\n    currentNode = {\n      entry: entry,\n      left: null,\n      right: null\n    };\n    currentNode.left = recEntryListToTree(entryList.slice(0, halfIndex));\n    currentNode.right = recEntryListToTree(entryList.slice(halfIndex + 1, entryList.length + 1));\n  }\n  return currentNode;\n}\n\n/**\n * Returns the interval in an IntervalTier that contains the given time\n * @param {number} time\n * @param {Object} rootNode - a tree built from entryListToTree()\n * @return {Array} The matched interval.  Of the form [start, stop, label].\n */\nfunction findIntervalAtTime(time, rootNode) {\n  let currNode = rootNode;\n  let matchNode = null;\n  while (currNode !== null) {\n    if (currNode.entry[0] <= time && currNode.entry[1] >= time) {\n      matchNode = currNode;\n      break;\n    } else if (currNode.entry[0] > time) {\n      currNode = currNode.left;\n    } else {\n      currNode = currNode.right;\n    }\n  }\n  return matchNode ? matchNode.entry : null;\n}\n\n/**\n * Returns the point in a PointTier that occurs at a specific time\n * @param {number} time\n * @param {Object} rootNode - a tree built from entryListToTree()\n * @param {boolean} [findClosest=false] - If true, return the entryList point that is closest to this time, even if its not an exact match.\n *  If false, only return exact matches.\n * @return {Array} The matched point.  Of the form [time, label].\n */\nfunction findPointAtTime(time, rootNode, findClosest = false) {\n  let currNode = rootNode;\n  let matchNode = null;\n  let closestNode = rootNode;\n  while (currNode !== null) {\n    const newDiff = Math.abs(currNode.entry[0] - time);\n    const oldDiff = Math.abs(closestNode.entry[0] - time);\n    if (newDiff <= oldDiff) {\n      // In the case two values are equidistant from the target time\n      // choose the earlier of the  values\n      if (newDiff !== oldDiff || currNode.entry[0] < closestNode.entry[0]) {\n        closestNode = currNode;\n      }\n    }\n    if (currNode.entry[0] === time) {\n      matchNode = currNode;\n      break;\n    } else if (currNode.entry[0] > time) {\n      currNode = currNode.left;\n    } else {\n      currNode = currNode.right;\n    }\n  }\n  if (findClosest === true && matchNode === null) {\n    matchNode = closestNode;\n  }\n  return matchNode ? matchNode.entry : null;\n}\nexport { doIntervalsOverlap, isClose, sortCompareEntriesByTime, entryListToTree, findIntervalAtTime, findPointAtTime };","map":{"version":3,"names":["doIntervalsOverlap","interval1","interval2","start1","end1","start2","end2","overlapAmount","Math","max","min","isClose","a","b","relTol","abs_tol","abs","sortCompareEntriesByTime","x","y","entryListToTree","entryList","sort","rootNode","recEntryListToTree","currentNode","length","halfIndex","floor","entry","left","right","slice","findIntervalAtTime","time","currNode","matchNode","findPointAtTime","findClosest","closestNode","newDiff","oldDiff"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/praatio/lib/utils.js"],"sourcesContent":["/** @module utils */\n\n/** Test if two intervals overlap */\nfunction doIntervalsOverlap (interval1, interval2) {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\n  const overlapAmount = Math.max(0, Math.min(end1, end2) - Math.max(start1, start2));\n  return overlapAmount > 0;\n}\n\n/** Test for near equivalence in float values.  From here http://realtimecollisiondetection.net/blog/?p=89 */\nfunction isClose (a, b, relTol = 1e-14, abs_tol = 0.0) {\n  return Math.abs(a - b) <= Math.max(relTol * Math.max(Math.abs(a), Math.abs(b)), abs_tol)\n}\n\n/** Pass to sort, when sorting a list of entries to sort entries by start time */\nfunction sortCompareEntriesByTime (x, y) {\n  return x[0] - y[0];\n}\n\n/**\n * Builds a balanced binary tree from an entry list for quickly finding things at certain times\n * @param {Array} entryList - can consist of intervals or points in time\n * @return {Object} The root node of the tree. Each node has a left and right branch;\n *  nodes in the left branch occur in time before the start time in parent nodes\n *  nodes in the right branch occur in time after the stop time in parent nodes\n */\nfunction entryListToTree (entryList) {\n  entryList.sort(sortCompareEntriesByTime);\n  const rootNode = recEntryListToTree(entryList);\n  return rootNode;\n}\n\n/** Helper function that recursively builds a balanced binary tree */\nfunction recEntryListToTree (entryList) {\n  let currentNode = null;\n  if (entryList.length > 0) {\n    const halfIndex = Math.floor(entryList.length / 2);\n    const entry = entryList[halfIndex];\n    currentNode = { entry: entry, left: null, right: null };\n    currentNode.left = recEntryListToTree(entryList.slice(0, halfIndex));\n    currentNode.right = recEntryListToTree(entryList.slice(halfIndex + 1, entryList.length + 1));\n  }\n  return currentNode;\n}\n\n/**\n * Returns the interval in an IntervalTier that contains the given time\n * @param {number} time\n * @param {Object} rootNode - a tree built from entryListToTree()\n * @return {Array} The matched interval.  Of the form [start, stop, label].\n */\nfunction findIntervalAtTime (time, rootNode) {\n  let currNode = rootNode;\n  let matchNode = null;\n  while (currNode !== null) {\n    if (currNode.entry[0] <= time && currNode.entry[1] >= time) {\n      matchNode = currNode;\n      break;\n    }\n    else if (currNode.entry[0] > time) {\n      currNode = currNode.left;\n    }\n    else {\n      currNode = currNode.right;\n    }\n  }\n\n  return matchNode ? matchNode.entry : null;\n}\n\n/**\n * Returns the point in a PointTier that occurs at a specific time\n * @param {number} time\n * @param {Object} rootNode - a tree built from entryListToTree()\n * @param {boolean} [findClosest=false] - If true, return the entryList point that is closest to this time, even if its not an exact match.\n *  If false, only return exact matches.\n * @return {Array} The matched point.  Of the form [time, label].\n */\nfunction findPointAtTime (time, rootNode, findClosest = false) {\n  let currNode = rootNode;\n  let matchNode = null;\n  let closestNode = rootNode;\n  while (currNode !== null) {\n    const newDiff = Math.abs(currNode.entry[0] - time);\n    const oldDiff = Math.abs(closestNode.entry[0] - time);\n    if (newDiff <= oldDiff) {\n      // In the case two values are equidistant from the target time\n      // choose the earlier of the  values\n      if (newDiff !== oldDiff || currNode.entry[0] < closestNode.entry[0]) {\n        closestNode = currNode;\n      }\n    }\n    if (currNode.entry[0] === time) {\n      matchNode = currNode;\n      break;\n    }\n    else if (currNode.entry[0] > time) {\n      currNode = currNode.left;\n    }\n    else {\n      currNode = currNode.right;\n    }\n  }\n\n  if (findClosest === true && matchNode === null) {\n    matchNode = closestNode;\n  }\n\n  return matchNode ? matchNode.entry : null;\n}\n\nexport { doIntervalsOverlap, isClose, sortCompareEntriesByTime, entryListToTree, findIntervalAtTime, findPointAtTime };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}