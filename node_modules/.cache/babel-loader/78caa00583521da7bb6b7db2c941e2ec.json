{"ast":null,"code":"import { substr } from 'fbjs/lib/UnicodeUtils';\nimport { isArabic, getConfigByKeys } from './helper';\nimport TagInfoMap from './TagInfoMap';\nimport { isQATag } from '../store/tag_mode';\nimport { TAG_HEIGHT, CONNECTION_DIR, DEFAULT_COLOR, FONT_SIZE, FONT_COLOR } from '../store/constant';\nconst genLabelsMap = labelsConfig => {\n  const labelsMap = {};\n  labelsConfig.forEach(item => {\n    labelsMap[item.text] = {\n      bgColor: item.color,\n      displayName: item.displayName || item.text\n    };\n  });\n  return labelsMap;\n};\nconst isContain = (item, resultItem) => item.start >= resultItem.start && item.end <= resultItem.end;\nconst isContained = (item, resultItem) => item.start <= resultItem.start && item.end >= resultItem.end;\nexport function genDisplayLabels(labels = [], labelsConfig = []) {\n  const result = [];\n  const labelsMap = genLabelsMap(labelsConfig);\n  labels.forEach(label => {\n    let existed = false;\n    const {\n      value,\n      text,\n      type\n    } = label;\n    const newLabel = {\n      ...label,\n      displayName: labelsMap[value].displayName,\n      realText: text,\n      text: value,\n      bgColor: labelsMap[value].bgColor,\n      fontColor: isQATag(type) ? '#000000' : FONT_COLOR,\n      children: []\n    };\n    result.forEach((resultLabel, resultLabelIndex) => {\n      if (isContain(newLabel, resultLabel)) {\n        result[resultLabelIndex].children = [...resultLabel.children, newLabel];\n        existed = true;\n      } else if (isContained(newLabel, resultLabel)) {\n        const newResultLabel = {\n          ...newLabel,\n          children: [...resultLabel.children]\n        };\n        delete result[resultLabelIndex].children;\n        newResultLabel.children.push(resultLabel);\n        result[resultLabelIndex] = {\n          ...newResultLabel\n        };\n        existed = true;\n      }\n    });\n    if (!existed) {\n      result.push(newLabel);\n    }\n  });\n  return result;\n}\nexport function renderTagMap(tagMap, spanMap) {\n  const {\n    labels,\n    insertions,\n    connections\n  } = tagMap;\n  Object.entries(labels).forEach(([id, label]) => {\n    const span = spanMap.get(label.head);\n    label.top += (span === null || span === void 0 ? void 0 : span.offsetTop) || 0;\n    label.left += label.isArabic ? (span === null || span === void 0 ? void 0 : span.offsetWidth) || 0 : 0;\n  });\n  Object.entries(insertions).forEach(([id, insertion]) => {\n    const span = spanMap.get(insertion.head);\n    insertion.top += (span === null || span === void 0 ? void 0 : span.offsetTop) || 0 + 7;\n  });\n  Object.entries(connections).forEach(([id, connection]) => {\n    const span = spanMap.get(connection.head);\n    connection.top += (span === null || span === void 0 ? void 0 : span.offsetTop) || 0;\n    connection.path = getPath(connection.from, connection.to, connection);\n  });\n}\nconst tagWidthCache = {};\nconst calcWidth = text => {\n  if (tagWidthCache[text]) {\n    return tagWidthCache[text];\n  }\n  const div = document.createElement('div');\n  div.style.cssText = 'position:absolute;visibility:hidden;width:auto;height:auto';\n  div.style.fontSize = '12px';\n  let width = 80;\n  try {\n    document.body.appendChild(div);\n    div.innerText = text;\n    width = div.offsetWidth;\n    document.body.removeChild(div);\n  } catch (e) {\n    //\n  }\n  const adjustedWidth = width + 12;\n  tagWidthCache[text] = adjustedWidth;\n  return adjustedWidth;\n};\nexport function genTagMap(results, configMap, spanMap, occupyMap, text) {\n  const {\n    labels,\n    insertions,\n    connections\n  } = results;\n  const tagMap = new TagInfoMap();\n  labels.forEach(label => {\n    const arabic = isArabic(substr(text, label.start, label.end - label.start));\n    const span = spanMap.get(label.start);\n    if (span) {\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = {\n        top: -TAG_HEIGHT,\n        left: span.offsetLeft,\n        text: label.value\n      };\n      // position occupied\n      while (occupyList.filter(item => item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text)).length > 0) {\n        occupy.top -= TAG_HEIGHT;\n      }\n      occupyList.push(occupy);\n      const configInfo = getConfigByKeys(configMap, label.keys);\n      tagMap.setItem(label.id, {\n        head: label.start,\n        top: occupy.top,\n        left: occupy.left,\n        text: label.value,\n        displayName: label.displayName || configInfo.displayName || label.value,\n        bgColor: isQATag(label.type) ? '#ffffff' : configInfo.color,\n        fontColor: isQATag(label.type) ? '#000000' : FONT_COLOR,\n        id: label.id,\n        type: label.type,\n        isArabic: arabic,\n        isReview: label.isReview\n      });\n    }\n  });\n  insertions.forEach(insertion => {\n    const span = spanMap.get(insertion.at);\n    if (span) {\n      var _getConfigByKeys;\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = {\n        top: FONT_SIZE,\n        left: span.offsetLeft,\n        text: insertion.value\n      };\n      // position occupied\n      while (occupyList.filter(item => item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text)).length > 0) occupy.top += TAG_HEIGHT;\n      occupyList.push(occupy);\n      const configInfo = getConfigByKeys(configMap, insertion.keys);\n      tagMap.setItem(insertion.id, {\n        head: insertion.at,\n        top: occupy.top,\n        left: occupy.left,\n        text: insertion.value,\n        displayName: insertion.displayName || configInfo.displayName || insertion.value,\n        id: insertion.id,\n        type: insertion.type,\n        bgColor: (_getConfigByKeys = getConfigByKeys(configMap, insertion.keys)) === null || _getConfigByKeys === void 0 ? void 0 : _getConfigByKeys.color,\n        fontColor: isQATag(insertion.type) ? '#000000' : FONT_COLOR,\n        isReview: insertion.isReview\n      });\n    }\n  });\n  try {\n    connections.forEach((connection, index) => {\n      const from = tagMap.getItem(connection.fromId, connection.fromType);\n      const to = tagMap.getItem(connection.toId, connection.toType);\n      if (!from || !to) {\n        throw new Error('BreakException');\n      }\n      const span = spanMap.get(Math.min(from.head, to.head));\n      if (span) {\n        const occupyList = occupyMap.get(span.offsetTop);\n        let top = Math.min(from.top, to.top) - 2 * TAG_HEIGHT; // occupyList.map((item) => item.top).sort((a, b) => (a - b)).shift() - TAG_HEIGHT;\n        if (top > -TAG_HEIGHT) top = -2 * TAG_HEIGHT;\n        const occupy = {\n          top,\n          /* left: (from.left + to.left) / 2, */left: Math.min(from.left, to.left),\n          right: Math.max(to.left, from.left),\n          text: connection.value\n        };\n        while (occupyList.filter(item => item.top === occupy.top && (item.right && item.right - item.left > TAG_HEIGHT * 2 ? !(occupy.left >= item.right || occupy.right <= item.left) : occupy.left <= item.left + calcWidth(item.text) && occupy.right >= item.left - calcWidth(item.text))).length > 0) occupy.top -= 2 * TAG_HEIGHT;\n        occupyList.push(occupy);\n        const configInfo = getConfigByKeys(configMap, connection.keys);\n        tagMap.setItem(connection.id, {\n          head: Math.min(from.head, to.head),\n          from,\n          to,\n          dir: from.left <= to.left ? CONNECTION_DIR.LEFT : CONNECTION_DIR.RIGHT,\n          top: occupy.top,\n          left: (from.left + to.left) / 2,\n          text: connection.value,\n          displayName: connection.displayName || configInfo.displayName || connection.value,\n          id: connection.id,\n          type: connection.type,\n          bgColor: DEFAULT_COLOR,\n          fontColor: isQATag(connection.type) ? '#000000' : FONT_COLOR,\n          isReview: connection.isReview\n        });\n      }\n    });\n  } catch (error) {\n    if (error.message !== 'BreakException') throw error;\n  }\n  return tagMap;\n}\nexport function genTagMap1(results, configMap, spanMap, occupyMap, text) {\n  const {\n    labels,\n    insertions,\n    connections\n  } = results;\n  const tagMap = new TagInfoMap();\n  labels.forEach(label => {\n    const arabic = isArabic(substr(text, label.start, label.end - label.start));\n    const span = spanMap.get(label.start);\n    if (span) {\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = {\n        top: -TAG_HEIGHT,\n        left: span.offsetLeft,\n        text: label.value\n      };\n      // position occupied\n      while (occupyList.filter(item => item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text)).length > 0) {\n        occupy.top -= TAG_HEIGHT;\n      }\n      occupyList.push(occupy);\n      const configInfo = configMap.get(label.value);\n      tagMap.setItem(label.id, {\n        head: label.start,\n        top: occupy.top,\n        left: occupy.left,\n        text: label.value,\n        displayName: label.displayName || configInfo.displayName || label.value,\n        bgColor: isQATag(label.id) ? '#ffffff' : configInfo.color,\n        fontColor: isQATag(label.id) ? '#000000' : FONT_COLOR,\n        id: label.id,\n        isArabic: arabic,\n        isReview: label.isReview\n      });\n    }\n  });\n  insertions.forEach(insertion => {\n    const span = spanMap.get(insertion.at);\n    if (span) {\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = {\n        top: FONT_SIZE,\n        left: span.offsetLeft,\n        text: insertion.value\n      };\n      // position occupied\n      while (occupyList.filter(item => item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text)).length > 0) occupy.top += TAG_HEIGHT;\n      occupyList.push(occupy);\n      const configInfo = configMap.get(insertion.value);\n      tagMap.setItem(insertion.id, {\n        head: insertion.at,\n        top: occupy.top,\n        left: occupy.left,\n        text: insertion.value,\n        displayName: insertion.displayName || configInfo.displayName || insertion.value,\n        id: insertion.id,\n        bgColor: configMap.get(insertion.value).color,\n        fontColor: isQATag(insertion.id) ? '#000000' : FONT_COLOR,\n        isReview: insertion.isReview\n      });\n    }\n  });\n  try {\n    connections.forEach(connection => {\n      const from = tagMap.getItem(connection.fromId, connection.fromType);\n      const to = tagMap.getItem(connection.toId, connection.toType);\n      if (!from || !to) {\n        throw new Error('BreakException');\n      }\n      const span = spanMap.get(Math.min(from.head, to.head));\n      if (span) {\n        const occupyList = occupyMap.get(span.offsetTop);\n        let top = Math.min(from.top, to.top) - 2 * TAG_HEIGHT; // occupyList.map((item) => item.top).sort((a, b) => (a - b)).shift() - TAG_HEIGHT;\n        if (top > -TAG_HEIGHT) top = -2 * TAG_HEIGHT;\n        const occupy = {\n          top,\n          /* left: (from.left + to.left) / 2, */left: Math.min(from.left, to.left),\n          right: Math.max(to.left, from.left),\n          text: connection.value\n        };\n        while (occupyList.filter(item => item.top === occupy.top && (item.right && item.right - item.left > TAG_HEIGHT * 2 ? !(occupy.left >= item.right || occupy.right <= item.left) : occupy.left <= item.left + calcWidth(item.text) && occupy.right >= item.left - calcWidth(item.text))).length > 0) occupy.top -= 2 * TAG_HEIGHT;\n        occupyList.push(occupy);\n        const configInfo = configMap.get(connection.value);\n        tagMap.setItem(connection.id, {\n          head: Math.min(from.head, to.head),\n          from,\n          to,\n          dir: from.left <= to.left ? CONNECTION_DIR.LEFT : CONNECTION_DIR.RIGHT,\n          top: occupy.top,\n          left: (from.left + to.left) / 2,\n          text: connection.value,\n          displayName: connection.displayName || configInfo.displayName || connection.value,\n          id: connection.id,\n          bgColor: DEFAULT_COLOR,\n          fontColor: isQATag(connection.id) ? '#000000' : FONT_COLOR,\n          isReview: connection.isReview\n        });\n      }\n    });\n  } catch (error) {\n    if (error.message !== 'BreakException') throw error;\n  }\n  return tagMap;\n}\nconst getPath = (from, to, middle) => {\n  if (from.left < middle.left - 50) return `M ${from.left} ${from.top} Q ${from.left} ${middle.top + TAG_HEIGHT / 2}, ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} Q ${to.left} ${middle.top + TAG_HEIGHT / 2}, ${to.left} ${to.top}`;\n  if (from.left > middle.left + 50) return `M ${from.left} ${from.top} Q ${from.left} ${middle.top + TAG_HEIGHT / 2}, ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} Q ${to.left} ${middle.top + TAG_HEIGHT / 2}, ${to.left} ${to.top}`;\n  if (from.left < to.left) return `M ${from.left} ${from.top} Q ${middle.left - 50} ${from.top}, ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} Q ${middle.left + 50} ${to.top}, ${to.left} ${to.top}`;\n  return `M ${from.left} ${from.top} Q ${middle.left + 50} ${from.top}, ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} Q ${middle.left - 50} ${to.top}, ${to.left} ${to.top}`;\n};","map":{"version":3,"names":["substr","isArabic","getConfigByKeys","TagInfoMap","isQATag","TAG_HEIGHT","CONNECTION_DIR","DEFAULT_COLOR","FONT_SIZE","FONT_COLOR","genLabelsMap","labelsConfig","labelsMap","forEach","item","text","bgColor","color","displayName","isContain","resultItem","start","end","isContained","genDisplayLabels","labels","result","label","existed","value","type","newLabel","realText","fontColor","children","resultLabel","resultLabelIndex","newResultLabel","push","renderTagMap","tagMap","spanMap","insertions","connections","Object","entries","id","span","get","head","top","offsetTop","left","offsetWidth","insertion","connection","path","getPath","from","to","tagWidthCache","calcWidth","div","document","createElement","style","cssText","fontSize","width","body","appendChild","innerText","removeChild","e","adjustedWidth","genTagMap","results","configMap","occupyMap","arabic","occupyList","occupy","offsetLeft","filter","Math","abs","length","configInfo","keys","setItem","isReview","at","_getConfigByKeys","index","getItem","fromId","fromType","toId","toType","Error","min","right","max","dir","LEFT","RIGHT","error","message","genTagMap1","middle"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/utils/tagMapUtil.js"],"sourcesContent":["import { substr } from 'fbjs/lib/UnicodeUtils';\nimport { isArabic, getConfigByKeys } from './helper';\nimport TagInfoMap from './TagInfoMap';\nimport { isQATag } from '../store/tag_mode';\nimport { TAG_HEIGHT, CONNECTION_DIR, DEFAULT_COLOR, FONT_SIZE, FONT_COLOR } from '../store/constant';\n\nconst genLabelsMap = (labelsConfig) => {\n  const labelsMap = {};\n  labelsConfig.forEach((item) => {\n    labelsMap[item.text] = { bgColor: item.color, displayName: item.displayName || item.text };\n  });\n  return labelsMap;\n};\n\nconst isContain = (item, resultItem) => (item.start >= resultItem.start) && (item.end <= resultItem.end);\n\nconst isContained = (item, resultItem) => (item.start <= resultItem.start) && (item.end >= resultItem.end);\n\nexport function genDisplayLabels(labels = [], labelsConfig = []) {\n  const result = [];\n  const labelsMap = genLabelsMap(labelsConfig);\n  labels.forEach((label) => {\n    let existed = false;\n    const { value, text, type } = label;\n    const newLabel = { ...label, displayName: labelsMap[value].displayName, realText: text, text: value, bgColor: labelsMap[value].bgColor, fontColor: isQATag(type) ? '#000000' : FONT_COLOR, children: [] };\n\n    result.forEach((resultLabel, resultLabelIndex) => {\n      if (isContain(newLabel, resultLabel)) {\n        result[resultLabelIndex].children = [...resultLabel.children, newLabel];\n        existed = true;\n      } else if (isContained(newLabel, resultLabel)) {\n        const newResultLabel = { ...newLabel, children: [...resultLabel.children] };\n        delete result[resultLabelIndex].children;\n        newResultLabel.children.push(resultLabel);\n        result[resultLabelIndex] = { ...newResultLabel };\n        existed = true;\n      }\n    });\n    if (!existed) {\n      result.push(newLabel);\n    }\n  });\n  return result;\n}\n\nexport function renderTagMap(tagMap, spanMap) {\n  const { labels, insertions, connections } = tagMap;\n  Object.entries(labels).forEach(([id, label]) => {\n    const span = spanMap.get(label.head);\n    label.top += span?.offsetTop || 0;\n    label.left += label.isArabic ? span?.offsetWidth || 0 : 0;\n  });\n  Object.entries(insertions).forEach(([id, insertion]) => {\n    const span = spanMap.get(insertion.head);\n    insertion.top += span?.offsetTop || 0 + 7;\n  });\n  Object.entries(connections).forEach(([id, connection]) => {\n    const span = spanMap.get(connection.head);\n    connection.top += span?.offsetTop || 0;\n    connection.path = getPath(connection.from, connection.to, connection);\n  });\n}\n\nconst tagWidthCache = {};\n\nconst calcWidth = (text) => {\n  if (tagWidthCache[text]) {\n    return tagWidthCache[text];\n  }\n  const div = document.createElement('div');\n  div.style.cssText = 'position:absolute;visibility:hidden;width:auto;height:auto';\n  div.style.fontSize = '12px';\n  let width = 80;\n  try {\n    document.body.appendChild(div);\n    div.innerText = text;\n    width = div.offsetWidth;\n    document.body.removeChild(div);\n  } catch (e) {\n    //\n  }\n  const adjustedWidth = width + 12;\n  tagWidthCache[text] = adjustedWidth;\n  return adjustedWidth;\n};\n\nexport function genTagMap(results, configMap, spanMap, occupyMap, text) {\n  const { labels, insertions, connections } = results;\n  const tagMap = new TagInfoMap();\n\n  labels.forEach((label) => {\n    const arabic = isArabic(substr(text, label.start, label.end - label.start));\n    const span = spanMap.get(label.start);\n    if (span) {\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = { top: -TAG_HEIGHT, left: span.offsetLeft, text: label.value };\n      // position occupied\n      while (occupyList.filter((item) => (item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text))).length > 0) {\n        occupy.top -= TAG_HEIGHT;\n      }\n      occupyList.push(occupy);\n      const configInfo = getConfigByKeys(configMap, label.keys);\n      tagMap.setItem(label.id, {\n        head: label.start,\n        top: occupy.top,\n        left: occupy.left,\n        text: label.value,\n        displayName: label.displayName || configInfo.displayName || label.value,\n        bgColor: isQATag(label.type) ? '#ffffff' : configInfo.color,\n        fontColor: isQATag(label.type) ? '#000000' : FONT_COLOR,\n        id: label.id,\n        type: label.type,\n        isArabic: arabic,\n        isReview: label.isReview,\n      });\n    }\n  });\n  insertions.forEach((insertion) => {\n    const span = spanMap.get(insertion.at);\n    if (span) {\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = { top: FONT_SIZE, left: span.offsetLeft, text: insertion.value };\n      // position occupied\n      while (occupyList.filter((item) => (item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text))).length > 0) occupy.top += TAG_HEIGHT;\n      occupyList.push(occupy);\n      const configInfo = getConfigByKeys(configMap, insertion.keys);\n      tagMap.setItem(insertion.id, {\n        head: insertion.at,\n        top: occupy.top,\n        left: occupy.left,\n        text: insertion.value,\n        displayName: insertion.displayName || configInfo.displayName || insertion.value,\n        id: insertion.id,\n        type: insertion.type,\n        bgColor: getConfigByKeys(configMap, insertion.keys)?.color,\n        fontColor: isQATag(insertion.type) ? '#000000' : FONT_COLOR,\n        isReview: insertion.isReview,\n      });\n    }\n  });\n  try {\n    connections.forEach((connection, index) => {\n      const from = tagMap.getItem(connection.fromId, connection.fromType);\n      const to = tagMap.getItem(connection.toId, connection.toType);\n      if (!from || !to) {\n        throw new Error('BreakException');\n      }\n      const span = spanMap.get(Math.min(from.head, to.head));\n      if (span) {\n        const occupyList = occupyMap.get(span.offsetTop);\n        let top = Math.min(from.top, to.top) - 2 * TAG_HEIGHT; // occupyList.map((item) => item.top).sort((a, b) => (a - b)).shift() - TAG_HEIGHT;\n        if (top > -TAG_HEIGHT) top = -2 * TAG_HEIGHT;\n        const occupy = { top, /* left: (from.left + to.left) / 2, */ left: Math.min(from.left, to.left), right: Math.max(to.left, from.left), text: connection.value };\n        while (occupyList.filter((item) => (\n          item.top === occupy.top &&\n          (\n            (item.right && item.right - item.left > TAG_HEIGHT * 2) ?\n              !(occupy.left >= item.right || occupy.right <= item.left) :\n              occupy.left <= item.left + calcWidth(item.text) && occupy.right >= item.left - calcWidth(item.text)\n          )\n        )).length > 0) occupy.top -= 2 * TAG_HEIGHT;\n        occupyList.push(occupy);\n        const configInfo = getConfigByKeys(configMap, connection.keys);\n        tagMap.setItem(connection.id, {\n          head: Math.min(from.head, to.head),\n          from,\n          to,\n          dir: from.left <= to.left ? CONNECTION_DIR.LEFT : CONNECTION_DIR.RIGHT,\n          top: occupy.top,\n          left: (from.left + to.left) / 2,\n          text: connection.value,\n          displayName: connection.displayName || configInfo.displayName || connection.value,\n          id: connection.id,\n          type: connection.type,\n          bgColor: DEFAULT_COLOR,\n          fontColor: isQATag(connection.type) ? '#000000' : FONT_COLOR,\n          isReview: connection.isReview,\n        });\n      }\n    });\n  } catch (error) {\n    if (error.message !== 'BreakException') throw error;\n  }\n  return tagMap;\n}\nexport function genTagMap1(results, configMap, spanMap, occupyMap, text) {\n  const { labels, insertions, connections } = results;\n  const tagMap = new TagInfoMap();\n\n  labels.forEach((label) => {\n    const arabic = isArabic(substr(text, label.start, label.end - label.start));\n    const span = spanMap.get(label.start);\n    if (span) {\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = { top: -TAG_HEIGHT, left: span.offsetLeft, text: label.value };\n      // position occupied\n      while (occupyList.filter((item) => (item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text))).length > 0) {\n        occupy.top -= TAG_HEIGHT;\n      }\n      occupyList.push(occupy);\n      const configInfo = configMap.get(label.value);\n      tagMap.setItem(label.id, {\n        head: label.start,\n        top: occupy.top,\n        left: occupy.left,\n        text: label.value,\n        displayName: label.displayName || configInfo.displayName || label.value,\n        bgColor: isQATag(label.id) ? '#ffffff' : configInfo.color,\n        fontColor: isQATag(label.id) ? '#000000' : FONT_COLOR,\n        id: label.id,\n        isArabic: arabic,\n        isReview: label.isReview,\n      });\n    }\n  });\n  insertions.forEach((insertion) => {\n    const span = spanMap.get(insertion.at);\n    if (span) {\n      const occupyList = occupyMap.get(span.offsetTop);\n      const occupy = { top: FONT_SIZE, left: span.offsetLeft, text: insertion.value };\n      // position occupied\n      while (occupyList.filter((item) => (item.top === occupy.top && Math.abs(occupy.left - item.left) < calcWidth(item.text))).length > 0) occupy.top += TAG_HEIGHT;\n      occupyList.push(occupy);\n      const configInfo = configMap.get(insertion.value);\n      tagMap.setItem(insertion.id, {\n        head: insertion.at,\n        top: occupy.top,\n        left: occupy.left,\n        text: insertion.value,\n        displayName: insertion.displayName || configInfo.displayName || insertion.value,\n        id: insertion.id,\n        bgColor: configMap.get(insertion.value).color,\n        fontColor: isQATag(insertion.id) ? '#000000' : FONT_COLOR,\n        isReview: insertion.isReview,\n      });\n    }\n  });\n  try {\n    connections.forEach((connection) => {\n      const from = tagMap.getItem(connection.fromId, connection.fromType);\n      const to = tagMap.getItem(connection.toId, connection.toType);\n      if (!from || !to) {\n        throw new Error('BreakException');\n      }\n      const span = spanMap.get(Math.min(from.head, to.head));\n      if (span) {\n        const occupyList = occupyMap.get(span.offsetTop);\n        let top = Math.min(from.top, to.top) - 2 * TAG_HEIGHT; // occupyList.map((item) => item.top).sort((a, b) => (a - b)).shift() - TAG_HEIGHT;\n        if (top > -TAG_HEIGHT) top = -2 * TAG_HEIGHT;\n        const occupy = { top, /* left: (from.left + to.left) / 2, */ left: Math.min(from.left, to.left), right: Math.max(to.left, from.left), text: connection.value };\n        while (occupyList.filter((item) => (\n          item.top === occupy.top &&\n          (\n            (item.right && item.right - item.left > TAG_HEIGHT * 2) ?\n              !(occupy.left >= item.right || occupy.right <= item.left) :\n              occupy.left <= item.left + calcWidth(item.text) && occupy.right >= item.left - calcWidth(item.text)\n          )\n        )).length > 0) occupy.top -= 2 * TAG_HEIGHT;\n        occupyList.push(occupy);\n        const configInfo = configMap.get(connection.value);\n        tagMap.setItem(connection.id, {\n          head: Math.min(from.head, to.head),\n          from,\n          to,\n          dir: from.left <= to.left ? CONNECTION_DIR.LEFT : CONNECTION_DIR.RIGHT,\n          top: occupy.top,\n          left: (from.left + to.left) / 2,\n          text: connection.value,\n          displayName: connection.displayName || configInfo.displayName || connection.value,\n          id: connection.id,\n          bgColor: DEFAULT_COLOR,\n          fontColor: isQATag(connection.id) ? '#000000' : FONT_COLOR,\n          isReview: connection.isReview,\n        });\n      }\n    });\n  } catch (error) {\n    if (error.message !== 'BreakException') throw error;\n  }\n  return tagMap;\n}\n\nconst getPath = (from, to, middle) => {\n  if (from.left < middle.left - 50) return `M ${from.left} ${from.top} Q ${from.left} ${middle.top + TAG_HEIGHT / 2}, ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} Q ${to.left} ${middle.top + TAG_HEIGHT / 2}, ${to.left} ${to.top}`;\n  if (from.left > middle.left + 50) return `M ${from.left} ${from.top} Q ${from.left} ${middle.top + TAG_HEIGHT / 2}, ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} Q ${to.left} ${middle.top + TAG_HEIGHT / 2}, ${to.left} ${to.top}`;\n  if (from.left < to.left) return `M ${from.left} ${from.top} Q ${middle.left - 50} ${from.top}, ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} Q ${middle.left + 50} ${to.top}, ${to.left} ${to.top}`;\n  return `M ${from.left} ${from.top} Q ${middle.left + 50} ${from.top}, ${middle.left + 50} ${middle.top + TAG_HEIGHT / 2} L ${middle.left - 50} ${middle.top + TAG_HEIGHT / 2} Q ${middle.left - 50} ${to.top}, ${to.left} ${to.top}`;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}