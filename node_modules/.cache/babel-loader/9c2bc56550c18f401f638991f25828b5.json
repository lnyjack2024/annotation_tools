{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { Base64 } from 'js-base64';\nimport Flatten from '@flatten-js/core';\nimport { utils as formUtils } from '@appen/easy-form';\nimport { FieldControlType } from '@appen/easy-form/es/types';\nimport { Tool } from './types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_CATEGORY_ITEM } from './constants';\nimport { fetchResultByUrl } from '../../utils';\nimport { computeRotatedPosition } from '../../utils/math';\nimport { ShapeType } from '../common/shapes/types';\nimport { precise } from '../common/shapes/utils';\n\n/**\n * parse frames\n * @param frames\n */\nexport function parseFrames(frames) {\n  if (typeof frames === 'string') {\n    return frames.split(',').map(f => f.trim());\n  }\n  return [...frames];\n}\n\n/**\n * parse frames config from cameras\n * @param cameras\n */\nfunction parseFramesFromCamera(cameras) {\n  if (Array.isArray(cameras) && cameras.length > 0 && cameras.every(c => c && c.camera && (typeof c.frames === 'string' || Array.isArray(c.frames)))) {\n    const allCameras = cameras.map(c => ({\n      camera: c.camera,\n      frames: parseFrames(c.frames),\n      calibrations: c.calibrations\n    }));\n    const maxFrameCount = Math.max(...allCameras.map(c => c.frames.length));\n    allCameras.forEach(c => {\n      if (c.frames.length < maxFrameCount) {\n        c.frames = c.frames.concat(Array.from({\n          length: maxFrameCount - c.frames.length\n        }).map(() => ''));\n      }\n    });\n    return allCameras;\n  }\n  return null;\n}\n\n/**\n * parse frames config from frames\n * @param frames\n */\nfunction parseFramesFromFrames(frames) {\n  if (typeof frames === 'string' && frames || Array.isArray(frames)) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      frames: parseFrames(frames)\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames from payload\n * @param payload\n */\nexport async function parseFramesByPaylod({\n  cameras,\n  frames,\n  base_url\n}) {\n  const parseFromCamera = parseFramesFromCamera(cameras);\n  if (parseFromCamera !== null) {\n    return parseFromCamera;\n  }\n  const parseFromFrames = parseFramesFromFrames(frames);\n  if (parseFromFrames !== null) {\n    return parseFromFrames;\n  }\n  if (base_url) {\n    try {\n      const res = await fetchResultByUrl(base_url);\n      if (res) {\n        const parseFromCameraResult = parseFramesFromCamera(res.cameras);\n        if (parseFromCameraResult !== null) {\n          return parseFromCameraResult;\n        }\n        const parseFromFramesResult = parseFramesFromFrames(res.frames);\n        if (parseFromFramesResult !== null) {\n          return parseFromFramesResult;\n        }\n      }\n    } catch (e) {\n      // fetch error\n    }\n  }\n  return [{\n    camera: DEFAULT_CAMERA_NAME,\n    frames: []\n  }];\n}\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result) {\n  const instances = [];\n  if (result && result.instances && Array.isArray(result.instances)) {\n    result.instances.forEach(instance => {\n      if (instance.frames) {\n        // legacy data\n        const defaultCamera = {\n          camera: DEFAULT_CAMERA_NAME,\n          frames: instance.frames\n        };\n        const defaultItem = {\n          id: uuidv4(),\n          name: DEFAULT_CATEGORY_ITEM,\n          number: 1,\n          cameras: [defaultCamera]\n        };\n        const newInstance = {\n          id: instance.id,\n          category: instance.category,\n          number: instance.number,\n          children: [defaultItem]\n        };\n        instances.push(newInstance);\n        // TODO: fix string points attribute for rectangle\n      } else {\n        instances.push(instance);\n      }\n\n      // TODO: check duplicated numbers & fix\n    });\n  }\n  return instances;\n}\n\n/**\n * format frames as string\n * @param frames\n */\nexport function formatFrames(frames) {\n  if (frames.length === 1) {\n    return frames[0] + 1;\n  }\n  const ranges = [];\n  if (frames.length > 1) {\n    let currMin = frames[0];\n    let currMax = frames[0];\n    let i = 1;\n    while (i < frames.length) {\n      if (frames[i] - frames[i - 1] > 1) {\n        currMax = frames[i - 1];\n        ranges.push([currMin, currMax]);\n        currMin = frames[i];\n        currMax = frames[i];\n      }\n      i += 1;\n    }\n    currMax = frames[frames.length - 1];\n    ranges.push([currMin, currMax]);\n  }\n  return ranges.reduce((acc, curr) => `${acc ? `${acc}, ` : ''}${curr[0] === curr[1] ? curr[0] + 1 : `${curr[0] + 1}-${curr[1] + 1}`}`, '');\n}\n\n/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */\nexport function predictShapeData(currentFrame, frames, bounds) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame);\n    }\n  }\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const {\n        shapeType,\n        shape\n      } = frames[prevKeyFrameIndexes[0]];\n      return {\n        shapeType,\n        shape\n      };\n    }\n  }\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const {\n      shapeType,\n      shape\n    } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return {\n        shapeType,\n        shape\n      };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const {\n      shapeType,\n      shape\n    } = frames[prevKeyFrameIndexes[0]];\n    return {\n      shapeType,\n      shape\n    };\n  }\n  return null;\n}\n\n/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getLastKeyFrames(count, currentFrame, frames) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map(f => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getNextKeyFrames(count, currentFrame, frames) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map(f => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */\nexport function getShapeFromFrames(frames, startFrame, endFrame, baseFrame, currentFrame) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape\n  };\n  if (Object.values(frames).filter(f => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some(f => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE:\n      {\n        const shape = calculate(startShape, endShape, baseShape, frameScale);\n        const {\n          x: startX,\n          width: startW,\n          center: startCenter\n        } = startShape;\n        const {\n          x: endX,\n          width: endW,\n          center: endCenter\n        } = endShape;\n        const {\n          x: baseX,\n          width: baseW,\n          center: baseCenter\n        } = baseShape;\n        let center;\n        if (startCenter !== undefined && endCenter !== undefined && baseCenter !== undefined) {\n          const startCenterScale = (startCenter - startX) / startW;\n          const endCenterScale = (endCenter - endX) / endW;\n          const baseCenterScale = (baseCenter - baseX) / baseW;\n          const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n          center = precise(Math.min(Math.max(centerScale * shape.width + shape.x, shape.x), shape.x + shape.width));\n        }\n        const right = precise(shape.x + shape.width);\n        const bottom = precise(shape.y + shape.height);\n        const points = [{\n          x: shape.x,\n          y: shape.y\n        }, {\n          x: right,\n          y: shape.y\n        }, {\n          x: right,\n          y: bottom\n        }, {\n          x: shape.x,\n          y: bottom\n        }];\n        if (shape.rotation) {\n          points.forEach(p => {\n            const point = computeRotatedPosition({\n              x: shape.x + shape.width / 2,\n              y: shape.y + shape.height / 2\n            }, p, shape.rotation);\n            p.x = precise(point.x);\n            p.y = precise(point.y);\n          });\n        }\n        shape.points = points;\n        shapeInfo.shape = {\n          ...shape,\n          center\n        };\n        break;\n      }\n    case ShapeType.ELLIPSE:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale);\n        break;\n      }\n    case ShapeType.CIRCLE:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale);\n        break;\n      }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID:\n      {\n        const {\n          front: startFront,\n          back: startBack\n        } = startShape;\n        const {\n          front: endFront,\n          back: endBack\n        } = endShape;\n        const {\n          front: baseFront,\n          back: baseBack\n        } = baseShape;\n        const front = calculate(startFront, endFront, baseFront, frameScale);\n        const back = calculate(startBack, endBack, baseBack, frameScale);\n        shapeInfo.shape = {\n          front,\n          back\n        };\n        break;\n      }\n    case ShapeType.LSHAPE:\n      {\n        const {\n          front: startFront,\n          sidePoints: startSidePoints,\n          center: startCenter\n        } = startShape;\n        const {\n          front: endFront,\n          sidePoints: endSidePoints,\n          center: endCenter\n        } = endShape;\n        const {\n          front: baseFront,\n          sidePoints: baseSidePoints,\n          center: baseCenter\n        } = baseShape;\n        const front = calculate(startFront, endFront, baseFront, frameScale);\n        const sidePoints = startSidePoints.map((_, index) => calculate(startSidePoints[index], endSidePoints[index], baseSidePoints[index], frameScale));\n        const startCenterScale = (startCenter - startFront.x) / startFront.width;\n        const endCenterScale = (endCenter - endFront.x) / endFront.width;\n        const baseCenterScale = (baseCenter - baseFront.x) / baseFront.width;\n        const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n        const center = precise(Math.min(Math.max(centerScale * front.width + front.x, front.x), front.x + front.width));\n        shapeInfo.shape = {\n          front,\n          sidePoints,\n          center\n        };\n        break;\n      }\n    case ShapeType.DOT:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale);\n        break;\n      }\n    default:\n  }\n  return shapeInfo;\n}\n\n/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */\nfunction calculate(start, end, base, scale) {\n  const calculatedObject = {};\n  Object.keys(base).forEach(key => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = precise(base[key] + (end[key] - start[key]) * scale);\n    }\n  });\n  return calculatedObject;\n}\n\n/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */\nexport function checkShapeInBounds(shape, shapeType, bounds) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n    case ShapeType.ARROW:\n      {\n        const points = shape.points;\n        const allX = points.map(p => p.x);\n        const allY = points.map(p => p.y);\n        const left = Math.min(...allX);\n        const right = Math.max(...allX);\n        const top = Math.min(...allY);\n        const bottom = Math.max(...allY);\n        return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n      }\n    case ShapeType.ELLIPSE:\n      {\n        const {\n          x,\n          y,\n          halfWidth,\n          halfHeight\n        } = shape;\n        return x - halfWidth >= bounds.left && y - halfHeight >= bounds.top && x + halfWidth <= bounds.right && y + halfHeight <= bounds.bottom;\n      }\n    case ShapeType.CIRCLE:\n      {\n        const {\n          x,\n          y,\n          radius\n        } = shape;\n        return x - radius >= bounds.left && y - radius >= bounds.top && x + radius <= bounds.right && y + radius <= bounds.bottom;\n      }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID:\n      {\n        const {\n          front,\n          back\n        } = shape;\n        return front.x >= bounds.left && front.y >= bounds.top && front.x + front.width <= bounds.right && front.y + front.height <= bounds.bottom && back.x >= bounds.left && back.y >= bounds.top && back.x + back.width <= bounds.right && back.y + back.height <= bounds.bottom;\n      }\n    case ShapeType.LSHAPE:\n      {\n        const {\n          front,\n          sidePoints\n        } = shape;\n        return front.x >= bounds.left && front.y >= bounds.top && front.x + front.width <= bounds.right && front.y + front.height <= bounds.bottom && sidePoints.every(p => p.x >= bounds.left && p.x <= bounds.right && p.y >= bounds.top && p.y <= bounds.bottom);\n      }\n    case ShapeType.DOT:\n      {\n        const {\n          x,\n          y\n        } = shape;\n        return x <= bounds.right && y <= bounds.bottom && x >= bounds.left && y >= bounds.top;\n      }\n    case ShapeType.GRID:\n      {\n        const {\n          cols,\n          rows\n        } = shape;\n        const allX = cols.map(c => c.x);\n        const allY = rows.map(r => r.y);\n        const left = Math.min(...allX);\n        const right = Math.max(...allX);\n        const top = Math.min(...allY);\n        const bottom = Math.max(...allY);\n        return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n      }\n    default:\n  }\n  return true;\n}\n\n/**\n * get snapshot image data url by shape data\n * @param imageUrl\n * @param shape\n */\nexport function getSnapshot(imageUrl, shape) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n    image.onload = reject;\n    image.onerror = reject;\n    const shapeData = shape;\n    if (Array.isArray(shapeData.points)) {\n      // polygon, or rotatable rectangle\n      const points = shapeData.points;\n      const allX = points.map(({\n        x\n      }) => x);\n      const allY = points.map(({\n        y\n      }) => y);\n      const minX = Math.min(...allX);\n      const maxX = Math.max(...allX);\n      const minY = Math.min(...allY);\n      const maxY = Math.max(...allY);\n      canvas.width = maxX - minX;\n      canvas.height = maxY - minY;\n      image.onload = () => {\n        if (ctx) {\n          points.forEach((p, i) => {\n            if (i === 0) {\n              ctx.moveTo(p.x - minX, p.y - minY);\n            } else {\n              ctx.lineTo(p.x - minX, p.y - minY);\n            }\n          });\n          ctx.lineTo(points[0].x - minX, points[0].y - minY);\n          ctx.clip();\n          ctx.drawImage(image, minX, minY, maxX - minX, maxY - minY, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    } else if (shapeData.x !== undefined && shapeData.y !== undefined && shapeData.width !== undefined && shapeData.height !== undefined) {\n      // legacy rectangle data (no points)\n      canvas.width = shapeData.width;\n      canvas.height = shapeData.height;\n      image.onload = () => {\n        if (ctx) {\n          ctx.drawImage(image, shapeData.x, shapeData.y, shapeData.width, shapeData.height, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    }\n    image.src = imageUrl;\n  });\n}\n\n/**\n * parse hotkeys config\n * @param hotkeysConfig\n */\nexport function parseHotkeysConfig(hotkeysConfig) {\n  const supportedAffectedTypes = ['point'];\n  const supportedTypes = ['overwrite', 'upsert'];\n  const supportedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n  const hotkeyMap = {};\n  if (hotkeysConfig && typeof hotkeysConfig === 'object') {\n    Object.keys(hotkeysConfig).forEach(affected => {\n      if (supportedAffectedTypes.includes(affected)) {\n        const items = hotkeysConfig[affected];\n        if (Array.isArray(items)) {\n          items.forEach(item => {\n            if (item && item.key && supportedKeys.includes(item.key)) {\n              const {\n                key,\n                type,\n                color,\n                attributes\n              } = item;\n              const hotkeyItem = {\n                key,\n                affected,\n                type,\n                color,\n                attributes\n              };\n              if (!supportedTypes.includes(type)) {\n                // eslint-disable-next-line prefer-destructuring\n                hotkeyItem.type = supportedTypes[0];\n              }\n              if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n                hotkeyItem.attributes = {};\n              }\n              if (!hotkeyMap[key]) {\n                hotkeyMap[key] = [];\n              }\n              hotkeyMap[key].push(hotkeyItem);\n            }\n          });\n        }\n      }\n    });\n  }\n  return hotkeyMap;\n}\n\n/**\n * check if the text string contains RTL language character\n * @param text\n */\nexport function containsRTLLanguage(text = '') {\n  // https://en.wikipedia.org/wiki/Arabic_script_in_Unicode\n  return Array.from(text).some(c => {\n    const code = c.codePointAt(0);\n    return code !== undefined && (code >= 0x0600 && code <= 0x06ff || code >= 0x0750 && code <= 0x077f || code >= 0x08a0 && code <= 0x08ff || code >= 0xfb50 && code <= 0xfdff || code >= 0xfe70 && code <= 0xfeff || code >= 0x10e60 && code <= 0x10e7f || code >= 0x1ec70 && code <= 0x1ecbf || code >= 0x1ed00 && code <= 0x1ed4f || code >= 0x1ee00 && code <= 0x1eeff);\n  });\n}\n\n/**\n * get shape type by tool name\n * @param tool\n */\nexport function getShapeTypeByTool(tool) {\n  switch (tool) {\n    case Tool.RECTANGLE:\n    case Tool.CENTERLINE_RECTANGLE:\n    case Tool.FOUR_DOTS_RECTANGLE:\n    case Tool.OCR:\n      return ShapeType.RECTANGLE;\n    case Tool.ELLIPSE:\n      return ShapeType.ELLIPSE;\n    case Tool.CIRCLE:\n      return ShapeType.CIRCLE;\n    case Tool.POLYGON:\n    case Tool.OCR_POLYGON:\n    case Tool.RECOGNITION:\n    case Tool.FORMULA_POLYGON:\n      return ShapeType.POLYGON;\n    case Tool.CUBOID:\n      return ShapeType.CUBOID;\n    case Tool.LSHAPE:\n      return ShapeType.LSHAPE;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    case Tool.GRID:\n      return ShapeType.GRID;\n    case Tool.ARROW:\n      return ShapeType.ARROW;\n    case Tool.TWO_SIDES_CUBOID:\n      return ShapeType.TWO_SIDES_CUBOID;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * get tool type from frame data\n * @param shape\n */\nexport function getToolTypeFromFrameData(shape) {\n  switch (shape.shapeType) {\n    case ShapeType.CUBOID:\n      return Tool.CUBOID;\n    case ShapeType.ELLIPSE:\n      return Tool.ELLIPSE;\n    case ShapeType.CIRCLE:\n      return Tool.CIRCLE;\n    case ShapeType.LSHAPE:\n      return Tool.LSHAPE;\n    case ShapeType.POLYGON:\n      if (shape.isOCR) {\n        return Tool.OCR_POLYGON;\n      }\n      if (shape.isFormula) {\n        return Tool.FORMULA_POLYGON;\n      }\n      return Tool.POLYGON;\n    case ShapeType.RECTANGLE:\n      if (shape.isOCR) {\n        return Tool.OCR;\n      }\n      if (shape.shape.center) {\n        return Tool.CENTERLINE_RECTANGLE;\n      }\n      return Tool.RECTANGLE;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    case ShapeType.GRID:\n      return Tool.GRID;\n    case ShapeType.ARROW:\n      return Tool.ARROW;\n    case ShapeType.TWO_SIDES_CUBOID:\n      return Tool.TWO_SIDES_CUBOID;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * parse label config\n * @param labelConfigStr\n */\nexport function parseLabelConfig(labelConfigStr) {\n  if (labelConfigStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(labelConfigStr));\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\n/**\n * parse tool styles\n * @param item\n */\nexport function parseToolStyles(config) {\n  const styles = {};\n  if (typeof config.fill_color === 'string') {\n    styles.fillColor = config.fill_color;\n  }\n  if (typeof config.point_color === 'string') {\n    styles.pointColor = config.point_color;\n  }\n  if (typeof config.point_type === 'string') {\n    styles.pointType = config.point_type;\n  }\n  if (typeof config.edge_color === 'string') {\n    styles.edgeColor = config.edge_color;\n  }\n  if (typeof config.edge_type === 'string') {\n    styles.edgeType = config.edge_type;\n  }\n  if (typeof config.edge_bold === 'boolean') {\n    styles.edgeBold = config.edge_bold;\n  } else if (typeof config.edge_bold === 'string') {\n    styles.edgeBold = config.edge_bold === 'true';\n  }\n  if (Array.isArray(config.points_color) && config.points_color.length > 0) {\n    styles.pointsColor = [...config.points_color];\n  }\n  if (Array.isArray(config.points_type) && config.points_type.length > 0) {\n    styles.pointsType = [...config.points_type];\n  }\n  if (Array.isArray(config.edges_color) && config.edges_color.length > 0) {\n    styles.edgesColor = [...config.edges_color];\n  }\n  if (Array.isArray(config.edges_type) && config.edges_type.length > 0) {\n    styles.edgesType = [...config.edges_type];\n  }\n  if (Array.isArray(config.edges_bold) && config.edges_bold.length > 0) {\n    styles.edgesBold = config.edges_bold.map(i => i === true || i === 'true');\n  }\n  return styles;\n}\n\n/**\n  * parse tool config\n  * @param tool\n  * @param config\n  */\nexport function parseToolConfig(tool, config) {\n  if (tool === Tool.RECTANGLE) {\n    // parse for rectangle\n    const cfg = {};\n    const {\n      tolerance = {}\n    } = config || {};\n    if (typeof tolerance.width === 'number' && tolerance.width >= 0 && typeof tolerance.height === 'number' && tolerance.height >= 0) {\n      cfg.tolerance = {\n        width: tolerance.width,\n        height: tolerance.height\n      };\n      if (typeof tolerance.min === 'number' && tolerance.min >= 0) {\n        cfg.tolerance.min = tolerance.min;\n      }\n    }\n    return {\n      config: cfg\n    };\n  }\n  return {};\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields, values) {\n  return fields.map(field => ({\n    ...field,\n    ...(values && values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config) {\n  const map = {};\n  ((config === null || config === void 0 ? void 0 : config.fields) || []).forEach(field => {\n    const {\n      name,\n      label,\n      type,\n      valueType,\n      options = []\n    } = field;\n    const newField = {\n      name,\n      type,\n      label\n    };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * Get the latest form property\n * @param config form config\n * @param values from values\n */\nexport const triggerForm = (config, values = {}) => {\n  const {\n    fields: configFields,\n    conditions = [],\n    effects = [],\n    rules = []\n  } = config;\n  const fields = (configFields || []).map(field => ({\n    ...field,\n    ...(values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n  const parsedValue = formUtils.parseFormFields(fields);\n  // trigger rule effects\n  const {\n    updatedValues: triggerValues,\n    updatedFields\n  } = rules.reduce((acc, curr) => formUtils.ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects), {\n    updatedFields: parsedValue.fields,\n    updatedValues: parsedValue.initialValues\n  });\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter(f => f.visible === false).forEach(f => {\n    delete updatedValues[f.name];\n  });\n  return {\n    updatedValues,\n    updatedFields\n  };\n};\n\n/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUpperShape(targetShape, shapes) {\n  let upperShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order > targetShape.order) {\n      // upper\n      if (!upperShape) {\n        upperShape = shape;\n      } else if (upperShape.order > shape.order) {\n        upperShape = shape;\n      }\n    }\n  }\n  return upperShape;\n}\n\n/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUnderShape(targetShape, shapes) {\n  let underShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order < targetShape.order) {\n      // under\n      if (!underShape) {\n        underShape = shape;\n      } else if (underShape.order < shape.order) {\n        underShape = shape;\n      }\n    }\n  }\n  return underShape;\n}\n\n/**\n * calculate shape area\n * @param shapeType\n * @param shapeData\n */\nexport function calcShapeArea(shapeType, shapeData) {\n  let area = NaN;\n  switch (shapeType) {\n    case ShapeType.POLYGON:\n      {\n        const {\n          points\n        } = shapeData;\n        const polygon = new Flatten.Polygon();\n        polygon.addFace(points.map(p => new Flatten.Point(p.x, p.y)));\n        area = polygon.faces.values().next().value.area();\n        break;\n      }\n    case ShapeType.RECTANGLE:\n      {\n        const {\n          width,\n          height\n        } = shapeData;\n        area = width * height;\n        break;\n      }\n    case ShapeType.ELLIPSE:\n      {\n        const {\n          halfWidth,\n          halfHeight\n        } = shapeData;\n        area = Math.PI * halfWidth * halfHeight;\n        break;\n      }\n    case ShapeType.CIRCLE:\n      {\n        const {\n          radius\n        } = shapeData;\n        area = Math.PI * radius ** 2;\n        break;\n      }\n    default:\n  }\n  return area;\n}\n\n/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */\nexport function preciseShapeByType(shapeType, shapeData) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n      {\n        const {\n          rotation\n        } = shapeData;\n        preciseData(shapeData);\n        if (rotation !== undefined) {\n          shapeData.rotation = rotation;\n        }\n        break;\n      }\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n    case ShapeType.ARROW:\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID:\n    case ShapeType.LSHAPE:\n    case ShapeType.DOT:\n    case ShapeType.ELLIPSE:\n    case ShapeType.CIRCLE:\n    case ShapeType.GRID:\n      preciseData(shapeData);\n      break;\n    default:\n  }\n}\n\n/**\n * precise data\n * @param data\n */\nexport function preciseData(data) {\n  if (Array.isArray(data)) {\n    // array\n    data.forEach((item, i) => {\n      if (typeof item === 'number') {\n        data[i] = precise(item);\n      } else {\n        preciseData(item);\n      }\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    // object\n    const allKeys = Object.keys(data);\n    allKeys.forEach(key => {\n      const keyData = data[key];\n      if (typeof keyData === 'number') {\n        data[key] = precise(keyData);\n      } else {\n        preciseData(keyData);\n      }\n    });\n  }\n}\n\n/**\n * check attributes pass condition\n * @param attributes\n * @param condition\n */\nexport function isAttributesPassCondition(attributes, condition) {\n  if (!attributes || !condition) {\n    return false;\n  }\n  return Object.keys(condition).every(key => {\n    var _ref;\n    return (Array.isArray(condition[key]) ? condition[key].sort() : condition[key]).toString() === ((_ref = Array.isArray(attributes[key]) ? attributes[key].sort() : attributes[key]) === null || _ref === void 0 ? void 0 : _ref.toString());\n  });\n}\nexport function getMatrixByRotation(rotation, width, height) {\n  // TODO: current only support 0, 90°, 180°, -90°\n  if (rotation === Math.PI / 2) {\n    return [[0, -1, height], [1, 0, 0], [0, 0, 1]];\n  }\n  if (rotation === Math.PI) {\n    return [[-1, 0, width], [0, -1, height], [0, 0, 1]];\n  }\n  if (rotation === -Math.PI / 2) {\n    return [[0, 1, 0], [-1, 0, width], [0, 0, 1]];\n  }\n  return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n}\nexport function calcPositionByMatrix(position, matrix) {\n  const {\n    x,\n    y\n  } = position;\n  const [l1, l2] = matrix;\n  return {\n    x: l1[0] * x + l1[1] * y + l1[2],\n    y: l2[0] * x + l2[1] * y + l2[2]\n  };\n}","map":{"version":3,"names":["v4","uuidv4","Base64","Flatten","utils","formUtils","FieldControlType","Tool","DEFAULT_CAMERA_NAME","DEFAULT_CATEGORY_ITEM","fetchResultByUrl","computeRotatedPosition","ShapeType","precise","parseFrames","frames","split","map","f","trim","parseFramesFromCamera","cameras","Array","isArray","length","every","c","camera","allCameras","calibrations","maxFrameCount","Math","max","forEach","concat","from","parseFramesFromFrames","defaultCamera","parseFramesByPaylod","base_url","parseFromCamera","parseFromFrames","res","parseFromCameraResult","parseFromFramesResult","e","loadInstancesFromResult","result","instances","instance","defaultItem","id","name","number","newInstance","category","children","push","formatFrames","ranges","currMin","currMax","i","reduce","acc","curr","predictShapeData","currentFrame","bounds","prevKeyFrameIndexes","getLastKeyFrames","nextKeyFrameIndexes","getNextKeyFrames","startFrame","endFrame","shapeType","getShapeFromFrames","shape","checkShapeInBounds","count","keyFrameIndexes","minFrame","min","Object","values","frameIndex","isKeyFrame","maxFrame","baseFrame","frameShapeType","shapeInfo","filter","some","startShape","endShape","baseShape","frameScale","RECTANGLE","calculate","x","startX","width","startW","center","startCenter","endX","endW","endCenter","baseX","baseW","baseCenter","undefined","startCenterScale","endCenterScale","baseCenterScale","centerScale","right","bottom","y","height","points","rotation","p","point","ELLIPSE","CIRCLE","CUBOID","TWO_SIDES_CUBOID","front","startFront","back","startBack","endFront","endBack","baseFront","baseBack","LSHAPE","sidePoints","startSidePoints","endSidePoints","baseSidePoints","_","index","DOT","start","end","base","scale","calculatedObject","keys","key","POLYGON","LINE","ARROW","allX","allY","left","top","halfWidth","halfHeight","radius","GRID","cols","rows","r","getSnapshot","imageUrl","Promise","resolve","reject","canvas","document","createElement","ctx","getContext","image","Image","crossOrigin","onload","onerror","shapeData","minX","maxX","minY","maxY","moveTo","lineTo","clip","drawImage","toDataURL","src","parseHotkeysConfig","hotkeysConfig","supportedAffectedTypes","supportedTypes","supportedKeys","hotkeyMap","affected","includes","items","item","type","color","attributes","hotkeyItem","containsRTLLanguage","text","code","codePointAt","getShapeTypeByTool","tool","CENTERLINE_RECTANGLE","FOUR_DOTS_RECTANGLE","OCR","OCR_POLYGON","RECOGNITION","FORMULA_POLYGON","getToolTypeFromFrameData","isOCR","isFormula","parseLabelConfig","labelConfigStr","labelConfig","JSON","parse","decode","parseToolStyles","config","styles","fill_color","fillColor","point_color","pointColor","point_type","pointType","edge_color","edgeColor","edge_type","edgeType","edge_bold","edgeBold","points_color","pointsColor","points_type","pointsType","edges_color","edgesColor","edges_type","edgesType","edges_bold","edgesBold","parseToolConfig","cfg","tolerance","setInitialValues","fields","field","defaultValue","parseFields","label","valueType","options","newField","RADIO","SELECT","CHECKBOX","parseOptions","triggerForm","configFields","conditions","effects","rules","parsedValue","parseFormFields","updatedValues","triggerValues","updatedFields","ruleTrigger","initialValues","visible","getUpperShape","targetShape","shapes","upperShape","order","getUnderShape","underShape","calcShapeArea","area","NaN","polygon","Polygon","addFace","Point","faces","next","value","PI","preciseShapeByType","preciseData","data","allKeys","keyData","isAttributesPassCondition","condition","_ref","sort","toString","getMatrixByRotation","calcPositionByMatrix","position","matrix","l1","l2"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/utils.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { Base64 } from 'js-base64';\nimport Flatten from '@flatten-js/core';\nimport { utils as formUtils } from '@appen/easy-form';\nimport { Field, FieldControlType, FormConfig } from '@appen/easy-form/es/types';\nimport { Instance, InstanceItem, CameraData, FrameData, HotkeyItem, Tool, LabelConfig, FieldConfig, Styles, ToolStyles, PureMatrix3, ToolConfig, RectangleConfig } from './types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_CATEGORY_ITEM } from './constants';\nimport { fetchResultByUrl } from '../../utils';\nimport { computeRotatedPosition } from '../../utils/math';\nimport { ShapeData, ShapeType } from '../common/shapes/types';\nimport type Shape from '../common/shapes/Shape';\nimport { RectangleData } from '../common/shapes/Rectangle';\nimport { EllipseData } from '../common/shapes/Ellipse';\nimport { CircleData } from '../common/shapes/Circle';\nimport { CuboidData } from '../common/shapes/Cuboid';\nimport { LShapeData } from '../common/shapes/LShape';\nimport { DotData } from '../common/shapes/Dot';\nimport { PolygonData } from '../common/shapes/Polygon';\nimport { LineData } from '../common/shapes/Line';\nimport { GridData } from '../common/shapes/Grid';\nimport { precise } from '../common/shapes/utils';\n\n/**\n * parse frames\n * @param frames\n */\nexport function parseFrames(frames: string | string[]) {\n  if (typeof frames === 'string') {\n    return frames.split(',').map((f) => f.trim());\n  }\n  return [...frames];\n}\n\n/**\n * parse frames config from cameras\n * @param cameras\n */\nfunction parseFramesFromCamera(cameras: unknown) {\n  if (Array.isArray(cameras) && cameras.length > 0\n    && cameras.every((c) => c && c.camera && (typeof c.frames === 'string' || Array.isArray(c.frames)))) {\n    const allCameras = cameras.map((c) => ({\n      camera: c.camera,\n      frames: parseFrames(c.frames),\n      calibrations: c.calibrations,\n    }));\n    const maxFrameCount = Math.max(...allCameras.map((c) => c.frames.length));\n    allCameras.forEach((c) => {\n      if (c.frames.length < maxFrameCount) {\n        c.frames = c.frames.concat(Array.from({ length: maxFrameCount - c.frames.length }).map(() => ''));\n      }\n    });\n    return allCameras;\n  }\n  return null;\n}\n\n/**\n * parse frames config from frames\n * @param frames\n */\nfunction parseFramesFromFrames(frames: unknown) {\n  if ((typeof frames === 'string' && frames) || Array.isArray(frames)) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      frames: parseFrames(frames),\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames from payload\n * @param payload\n */\nexport async function parseFramesByPaylod({ cameras, frames, base_url }: {\n  cameras?: {\n    camera: string;\n    frames: string | string[];\n  }[];\n  frames?: string | string[];\n  base_url?: string;\n}): Promise<{ camera: string; frames: string[]; calibrations?: unknown }[]> {\n  const parseFromCamera = parseFramesFromCamera(cameras);\n  if (parseFromCamera !== null) {\n    return parseFromCamera;\n  }\n  const parseFromFrames = parseFramesFromFrames(frames);\n  if (parseFromFrames !== null) {\n    return parseFromFrames;\n  }\n\n  if (base_url) {\n    try {\n      const res: any = await fetchResultByUrl(base_url);\n      if (res) {\n        const parseFromCameraResult = parseFramesFromCamera(res.cameras);\n        if (parseFromCameraResult !== null) {\n          return parseFromCameraResult;\n        }\n        const parseFromFramesResult = parseFramesFromFrames(res.frames);\n        if (parseFromFramesResult !== null) {\n          return parseFromFramesResult;\n        }\n      }\n    } catch (e) {\n      // fetch error\n    }\n  }\n  return [{\n    camera: DEFAULT_CAMERA_NAME,\n    frames: [],\n  }];\n}\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result: any) {\n  const instances: Instance[] = [];\n\n  if (result && result.instances && Array.isArray(result.instances)) {\n    result.instances.forEach((instance: any) => {\n      if (instance.frames) {\n        // legacy data\n        const defaultCamera: CameraData = {\n          camera: DEFAULT_CAMERA_NAME,\n          frames: instance.frames,\n        };\n        const defaultItem: InstanceItem = {\n          id: uuidv4(),\n          name: DEFAULT_CATEGORY_ITEM,\n          number: 1,\n          cameras: [defaultCamera],\n        };\n        const newInstance: Instance = {\n          id: instance.id,\n          category: instance.category,\n          number: instance.number,\n          children: [defaultItem],\n        };\n        instances.push(newInstance);\n        // TODO: fix string points attribute for rectangle\n      } else {\n        instances.push(instance);\n      }\n\n      // TODO: check duplicated numbers & fix\n    });\n  }\n\n  return instances;\n}\n\n/**\n * format frames as string\n * @param frames\n */\nexport function formatFrames(frames: number[]) {\n  if (frames.length === 1) {\n    return frames[0] + 1;\n  }\n\n  const ranges = [];\n  if (frames.length > 1) {\n    let currMin = frames[0];\n    let currMax = frames[0];\n    let i = 1;\n    while (i < frames.length) {\n      if (frames[i] - frames[i - 1] > 1) {\n        currMax = frames[i - 1];\n        ranges.push([currMin, currMax]);\n        currMin = frames[i];\n        currMax = frames[i];\n      }\n      i += 1;\n    }\n    currMax = frames[frames.length - 1];\n    ranges.push([currMin, currMax]);\n  }\n\n  return ranges.reduce((acc, curr) => `${acc ? `${acc}, ` : ''}${curr[0] === curr[1] ? (curr[0] + 1) : `${curr[0] + 1}-${curr[1] + 1}`}`, '');\n}\n\n/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */\nexport function predictShapeData(\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n  bounds?: { top: number; right: number; bottom: number; left: number },\n) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame);\n    }\n  }\n\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n      return { shapeType, shape };\n    }\n  }\n\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const { shapeType, shape } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return { shapeType, shape };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n    return { shapeType, shape };\n  }\n\n  return null;\n}\n\n/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getLastKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map((f) => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getNextKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map((f) => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */\nexport function getShapeFromFrames(\n  frames: {[frameIndex: number]: FrameData},\n  startFrame: number,\n  endFrame: number,\n  baseFrame: number,\n  currentFrame: number,\n) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape,\n  };\n\n  if (Object.values(frames).filter((f) => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some((f) => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE: {\n      const shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as RectangleData;\n      const { x: startX, width: startW, center: startCenter } = startShape as RectangleData;\n      const { x: endX, width: endW, center: endCenter } = endShape as RectangleData;\n      const { x: baseX, width: baseW, center: baseCenter } = baseShape as RectangleData;\n      let center;\n      if (startCenter !== undefined && endCenter !== undefined && baseCenter !== undefined) {\n        const startCenterScale = (startCenter - startX) / startW;\n        const endCenterScale = (endCenter - endX) / endW;\n        const baseCenterScale = (baseCenter - baseX) / baseW;\n        const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n        center = precise(Math.min(Math.max(centerScale * shape.width + shape.x, shape.x), shape.x + shape.width));\n      }\n      const right = precise(shape.x + shape.width);\n      const bottom = precise(shape.y + shape.height);\n      const points = [\n        { x: shape.x, y: shape.y },\n        { x: right, y: shape.y },\n        { x: right, y: bottom },\n        { x: shape.x, y: bottom },\n      ];\n      if (shape.rotation) {\n        points.forEach((p) => {\n          const point = computeRotatedPosition({ x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }, p, shape.rotation as number);\n          p.x = precise(point.x);\n          p.y = precise(point.y);\n        });\n      }\n\n      shape.points = points;\n      shapeInfo.shape = { ...shape, center };\n      break;\n    }\n    case ShapeType.ELLIPSE: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as EllipseData;\n      break;\n    }\n    case ShapeType.CIRCLE: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as CircleData;\n      break;\n    }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID: {\n      const { front: startFront, back: startBack } = startShape as CuboidData;\n      const { front: endFront, back: endBack } = endShape as CuboidData;\n      const { front: baseFront, back: baseBack } = baseShape as CuboidData;\n      const front = calculate(\n        startFront as unknown as { [key: string]: number; },\n        endFront as unknown as { [key: string]: number; },\n        baseFront as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as CuboidData['front'];\n      const back = calculate(\n        startBack as unknown as { [key: string]: number; },\n        endBack as unknown as { [key: string]: number; },\n        baseBack as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as CuboidData['back'];\n      shapeInfo.shape = { front, back };\n      break;\n    }\n    case ShapeType.LSHAPE: {\n      const { front: startFront, sidePoints: startSidePoints, center: startCenter } = startShape as LShapeData;\n      const { front: endFront, sidePoints: endSidePoints, center: endCenter } = endShape as LShapeData;\n      const { front: baseFront, sidePoints: baseSidePoints, center: baseCenter } = baseShape as LShapeData;\n      const front = calculate(\n        startFront as unknown as { [key: string]: number; },\n        endFront as unknown as { [key: string]: number; },\n        baseFront as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as LShapeData['front'];\n      const sidePoints = startSidePoints.map((_, index) => calculate(\n        startSidePoints[index] as unknown as { [key: string]: number; },\n        endSidePoints[index] as unknown as { [key: string]: number; },\n        baseSidePoints[index] as unknown as { [key: string]: number; },\n        frameScale,\n      )) as unknown as LShapeData['sidePoints'];\n      const startCenterScale = (startCenter - startFront.x) / startFront.width;\n      const endCenterScale = (endCenter - endFront.x) / endFront.width;\n      const baseCenterScale = (baseCenter - baseFront.x) / baseFront.width;\n      const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n      const center = precise(Math.min(Math.max(centerScale * front.width + front.x, front.x), front.x + front.width));\n      shapeInfo.shape = { front, sidePoints, center };\n      break;\n    }\n    case ShapeType.DOT: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as EllipseData;\n      break;\n    }\n    default:\n  }\n\n  return shapeInfo;\n}\n\n/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */\nfunction calculate(\n  start: {[key: string]: number},\n  end: {[key: string]: number},\n  base: {[key: string]: number},\n  scale: number,\n) {\n  const calculatedObject: {[key: string]: number} = {};\n  Object.keys(base).forEach((key) => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = precise(base[key] + (end[key] - start[key]) * scale);\n    }\n  });\n  return calculatedObject;\n}\n\n/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */\nexport function checkShapeInBounds(\n  shape: ShapeData,\n  shapeType: ShapeType,\n  bounds: { top: number; right: number; bottom: number; left: number },\n) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n    case ShapeType.ARROW: {\n      const points = (shape as RectangleData | PolygonData | LineData).points as { x: number; y: number }[];\n      const allX = points.map((p) => p.x);\n      const allY = points.map((p) => p.y);\n      const left = Math.min(...allX);\n      const right = Math.max(...allX);\n      const top = Math.min(...allY);\n      const bottom = Math.max(...allY);\n      return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n    }\n    case ShapeType.ELLIPSE: {\n      const { x, y, halfWidth, halfHeight } = shape as EllipseData;\n      return x - halfWidth >= bounds.left && y - halfHeight >= bounds.top && x + halfWidth <= bounds.right && y + halfHeight <= bounds.bottom;\n    }\n    case ShapeType.CIRCLE: {\n      const { x, y, radius } = shape as CircleData;\n      return x - radius >= bounds.left && y - radius >= bounds.top && x + radius <= bounds.right && y + radius <= bounds.bottom;\n    }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID: {\n      const { front, back } = shape as CuboidData;\n      return (\n        front.x >= bounds.left && front.y >= bounds.top && front.x + front.width <= bounds.right && front.y + front.height <= bounds.bottom\n      ) && (\n        back.x >= bounds.left && back.y >= bounds.top && back.x + back.width <= bounds.right && back.y + back.height <= bounds.bottom\n      );\n    }\n    case ShapeType.LSHAPE: {\n      const { front, sidePoints } = shape as LShapeData;\n      return (\n        front.x >= bounds.left && front.y >= bounds.top && front.x + front.width <= bounds.right && front.y + front.height <= bounds.bottom\n      ) && (\n        sidePoints.every((p) => (p.x >= bounds.left && p.x <= bounds.right && p.y >= bounds.top && p.y <= bounds.bottom))\n      );\n    }\n    case ShapeType.DOT: {\n      const { x, y } = shape as DotData;\n      return x <= bounds.right && y <= bounds.bottom && x >= bounds.left && y >= bounds.top;\n    }\n    case ShapeType.GRID: {\n      const { cols, rows } = shape as GridData;\n      const allX = cols.map((c) => c.x);\n      const allY = rows.map((r) => r.y);\n      const left = Math.min(...allX);\n      const right = Math.max(...allX);\n      const top = Math.min(...allY);\n      const bottom = Math.max(...allY);\n      return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n    }\n    default:\n  }\n  return true;\n}\n\n/**\n * get snapshot image data url by shape data\n * @param imageUrl\n * @param shape\n */\nexport function getSnapshot(imageUrl: string, shape: ShapeData) {\n  return new Promise<string>((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n    image.onload = reject;\n    image.onerror = reject;\n\n    const shapeData = shape as any;\n    if (Array.isArray(shapeData.points)) {\n      // polygon, or rotatable rectangle\n      const points = shapeData.points as { x: number; y: number }[];\n      const allX = points.map(({ x }) => x);\n      const allY = points.map(({ y }) => y);\n      const minX = Math.min(...allX);\n      const maxX = Math.max(...allX);\n      const minY = Math.min(...allY);\n      const maxY = Math.max(...allY);\n      canvas.width = maxX - minX;\n      canvas.height = maxY - minY;\n      image.onload = () => {\n        if (ctx) {\n          points.forEach((p, i) => {\n            if (i === 0) {\n              ctx.moveTo(p.x - minX, p.y - minY);\n            } else {\n              ctx.lineTo(p.x - minX, p.y - minY);\n            }\n          });\n          ctx.lineTo(points[0].x - minX, points[0].y - minY);\n          ctx.clip();\n          ctx.drawImage(image, minX, minY, maxX - minX, maxY - minY, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    } else if (shapeData.x !== undefined && shapeData.y !== undefined && shapeData.width !== undefined && shapeData.height !== undefined) {\n      // legacy rectangle data (no points)\n      canvas.width = shapeData.width;\n      canvas.height = shapeData.height;\n      image.onload = () => {\n        if (ctx) {\n          ctx.drawImage(image, shapeData.x, shapeData.y, shapeData.width, shapeData.height, 0, 0, canvas.width, canvas.height);\n          resolve(canvas.toDataURL());\n        } else {\n          reject();\n        }\n      };\n    }\n\n    image.src = imageUrl;\n  });\n}\n\n/**\n * parse hotkeys config\n * @param hotkeysConfig\n */\nexport function parseHotkeysConfig(hotkeysConfig: any) {\n  const supportedAffectedTypes = ['point'];\n  const supportedTypes = ['overwrite', 'upsert'];\n  const supportedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\n  const hotkeyMap: {[key: string]: HotkeyItem[]} = {};\n  if (hotkeysConfig && typeof hotkeysConfig === 'object') {\n    Object.keys(hotkeysConfig).forEach((affected) => {\n      if (supportedAffectedTypes.includes(affected)) {\n        const items = hotkeysConfig[affected];\n        if (Array.isArray(items)) {\n          items.forEach((item) => {\n            if (item && item.key && supportedKeys.includes(item.key)) {\n              const { key, type, color, attributes } = item;\n              const hotkeyItem: HotkeyItem = {\n                key,\n                affected,\n                type,\n                color,\n                attributes,\n              };\n\n              if (!supportedTypes.includes(type)) {\n                // eslint-disable-next-line prefer-destructuring\n                hotkeyItem.type = supportedTypes[0];\n              }\n\n              if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n                hotkeyItem.attributes = {};\n              }\n\n              if (!hotkeyMap[key]) {\n                hotkeyMap[key] = [];\n              }\n              hotkeyMap[key].push(hotkeyItem);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  return hotkeyMap;\n}\n\n/**\n * check if the text string contains RTL language character\n * @param text\n */\nexport function containsRTLLanguage(text = '') {\n  // https://en.wikipedia.org/wiki/Arabic_script_in_Unicode\n  return Array.from(text).some((c) => {\n    const code = c.codePointAt(0);\n    return code !== undefined && (\n      (code >= 0x0600 && code <= 0x06ff) ||\n      (code >= 0x0750 && code <= 0x077f) ||\n      (code >= 0x08a0 && code <= 0x08ff) ||\n      (code >= 0xfb50 && code <= 0xfdff) ||\n      (code >= 0xfe70 && code <= 0xfeff) ||\n      (code >= 0x10e60 && code <= 0x10e7f) ||\n      (code >= 0x1ec70 && code <= 0x1ecbf) ||\n      (code >= 0x1ed00 && code <= 0x1ed4f) ||\n      (code >= 0x1ee00 && code <= 0x1eeff)\n    );\n  });\n}\n\n/**\n * get shape type by tool name\n * @param tool\n */\nexport function getShapeTypeByTool(tool: Tool): ShapeType | undefined {\n  switch (tool) {\n    case Tool.RECTANGLE:\n    case Tool.CENTERLINE_RECTANGLE:\n    case Tool.FOUR_DOTS_RECTANGLE:\n    case Tool.OCR:\n      return ShapeType.RECTANGLE;\n    case Tool.ELLIPSE:\n      return ShapeType.ELLIPSE;\n    case Tool.CIRCLE:\n      return ShapeType.CIRCLE;\n    case Tool.POLYGON:\n    case Tool.OCR_POLYGON:\n    case Tool.RECOGNITION:\n    case Tool.FORMULA_POLYGON:\n      return ShapeType.POLYGON;\n    case Tool.CUBOID:\n      return ShapeType.CUBOID;\n    case Tool.LSHAPE:\n      return ShapeType.LSHAPE;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    case Tool.GRID:\n      return ShapeType.GRID;\n    case Tool.ARROW:\n      return ShapeType.ARROW;\n    case Tool.TWO_SIDES_CUBOID:\n      return ShapeType.TWO_SIDES_CUBOID;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * get tool type from frame data\n * @param shape\n */\nexport function getToolTypeFromFrameData(shape: FrameData) {\n  switch (shape.shapeType) {\n    case ShapeType.CUBOID:\n      return Tool.CUBOID;\n    case ShapeType.ELLIPSE:\n      return Tool.ELLIPSE;\n    case ShapeType.CIRCLE:\n      return Tool.CIRCLE;\n    case ShapeType.LSHAPE:\n      return Tool.LSHAPE;\n    case ShapeType.POLYGON:\n      if (shape.isOCR) {\n        return Tool.OCR_POLYGON;\n      }\n      if (shape.isFormula) {\n        return Tool.FORMULA_POLYGON;\n      }\n      return Tool.POLYGON;\n    case ShapeType.RECTANGLE:\n      if (shape.isOCR) {\n        return Tool.OCR;\n      }\n      if ((shape.shape as RectangleData).center) {\n        return Tool.CENTERLINE_RECTANGLE;\n      }\n      return Tool.RECTANGLE;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    case ShapeType.GRID:\n      return Tool.GRID;\n    case ShapeType.ARROW:\n      return Tool.ARROW;\n    case ShapeType.TWO_SIDES_CUBOID:\n      return Tool.TWO_SIDES_CUBOID;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * parse label config\n * @param labelConfigStr\n */\nexport function parseLabelConfig(labelConfigStr?: string) {\n  if (labelConfigStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(labelConfigStr));\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\n/**\n * parse tool styles\n * @param item\n */\nexport function parseToolStyles(config: Styles) {\n  const styles: ToolStyles = {};\n  if (typeof config.fill_color === 'string') {\n    styles.fillColor = config.fill_color;\n  }\n  if (typeof config.point_color === 'string') {\n    styles.pointColor = config.point_color;\n  }\n  if (typeof config.point_type === 'string') {\n    styles.pointType = config.point_type;\n  }\n  if (typeof config.edge_color === 'string') {\n    styles.edgeColor = config.edge_color;\n  }\n  if (typeof config.edge_type === 'string') {\n    styles.edgeType = config.edge_type;\n  }\n  if (typeof config.edge_bold === 'boolean') {\n    styles.edgeBold = config.edge_bold;\n  } else if (typeof config.edge_bold === 'string') {\n    styles.edgeBold = config.edge_bold === 'true';\n  }\n  if (Array.isArray(config.points_color) && config.points_color.length > 0) {\n    styles.pointsColor = [...config.points_color];\n  }\n  if (Array.isArray(config.points_type) && config.points_type.length > 0) {\n    styles.pointsType = [...config.points_type];\n  }\n  if (Array.isArray(config.edges_color) && config.edges_color.length > 0) {\n    styles.edgesColor = [...config.edges_color];\n  }\n  if (Array.isArray(config.edges_type) && config.edges_type.length > 0) {\n    styles.edgesType = [...config.edges_type];\n  }\n  if (Array.isArray(config.edges_bold) && config.edges_bold.length > 0) {\n    styles.edgesBold = (config.edges_bold as (boolean | string)[]).map((i) => i === true || i === 'true');\n  }\n  return styles;\n}\n\n/**\n  * parse tool config\n  * @param tool\n  * @param config\n  */\nexport function parseToolConfig(tool: Tool, config: any): { config?: ToolConfig } {\n  if (tool === Tool.RECTANGLE) {\n    // parse for rectangle\n    const cfg: RectangleConfig = {};\n    const { tolerance = {} } = config || {};\n    if (\n      typeof tolerance.width === 'number' && tolerance.width >= 0 &&\n      typeof tolerance.height === 'number' && tolerance.height >= 0\n    ) {\n      cfg.tolerance = {\n        width: tolerance.width,\n        height: tolerance.height,\n      };\n      if (typeof tolerance.min === 'number' && tolerance.min >= 0) {\n        cfg.tolerance.min = tolerance.min;\n      }\n    }\n    return {\n      config: cfg,\n    };\n  }\n  return {};\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields: Field[], values: any) {\n  return fields.map((field) => ({\n    ...field,\n    ...values && values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config?: LabelConfig) {\n  const map: { [fieldName: string]: FieldConfig } = {};\n  (config?.fields || []).forEach((field) => {\n    const { name, label, type, valueType, options = [] } = field;\n    const newField: FieldConfig = { name, type, label };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * Get the latest form property\n * @param config form config\n * @param values from values\n */\nexport const triggerForm = (config: FormConfig, values:{[key: string]: any} = {}) => {\n  const { fields: configFields, conditions = [], effects = [], rules = [] } = config;\n  const fields = (configFields || []).map((field) => ({\n    ...field,\n    ...values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n\n  const parsedValue = formUtils.parseFormFields(fields);\n  // trigger rule effects\n  const { updatedValues: triggerValues, updatedFields } = rules.reduce(\n    (acc, curr) => formUtils.ruleTrigger(\n      curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects,\n    ),\n    { updatedFields: parsedValue.fields, updatedValues: parsedValue.initialValues },\n  );\n\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter((f) => f.visible === false).forEach((f) => {\n    delete updatedValues[f.name];\n  });\n  return {\n    updatedValues,\n    updatedFields,\n  };\n};\n\n/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUpperShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let upperShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order > targetShape.order) { // upper\n      if (!upperShape) {\n        upperShape = shape;\n      } else if (upperShape.order > shape.order) {\n        upperShape = shape;\n      }\n    }\n  }\n  return upperShape;\n}\n\n/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUnderShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let underShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order < targetShape.order) { // under\n      if (!underShape) {\n        underShape = shape;\n      } else if (underShape.order < shape.order) {\n        underShape = shape;\n      }\n    }\n  }\n  return underShape;\n}\n\n/**\n * calculate shape area\n * @param shapeType\n * @param shapeData\n */\nexport function calcShapeArea(shapeType: ShapeType, shapeData: ShapeData) {\n  let area = NaN;\n  switch (shapeType) {\n    case ShapeType.POLYGON: {\n      const { points } = shapeData as PolygonData;\n      const polygon = new Flatten.Polygon();\n      polygon.addFace(points.map((p) => new Flatten.Point(p.x, p.y)));\n      area = polygon.faces.values().next().value.area();\n      break;\n    }\n    case ShapeType.RECTANGLE: {\n      const { width, height } = shapeData as RectangleData;\n      area = width * height;\n      break;\n    }\n    case ShapeType.ELLIPSE: {\n      const { halfWidth, halfHeight } = shapeData as EllipseData;\n      area = Math.PI * halfWidth * halfHeight;\n      break;\n    }\n    case ShapeType.CIRCLE: {\n      const { radius } = shapeData as CircleData;\n      area = Math.PI * radius ** 2;\n      break;\n    }\n    default:\n  }\n  return area;\n}\n\n/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */\nexport function preciseShapeByType(shapeType: ShapeType, shapeData: ShapeData) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE: {\n      const { rotation } = shapeData as RectangleData;\n      preciseData(shapeData);\n      if (rotation !== undefined) {\n        (shapeData as RectangleData).rotation = rotation;\n      }\n      break;\n    }\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n    case ShapeType.ARROW:\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID:\n    case ShapeType.LSHAPE:\n    case ShapeType.DOT:\n    case ShapeType.ELLIPSE:\n    case ShapeType.CIRCLE:\n    case ShapeType.GRID:\n      preciseData(shapeData);\n      break;\n    default:\n  }\n}\n\n/**\n * precise data\n * @param data\n */\nexport function preciseData(data: any) {\n  if (Array.isArray(data)) {\n    // array\n    data.forEach((item, i) => {\n      if (typeof item === 'number') {\n        data[i] = precise(item);\n      } else {\n        preciseData(item);\n      }\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    // object\n    const allKeys = Object.keys(data);\n    allKeys.forEach((key) => {\n      const keyData = data[key];\n      if (typeof keyData === 'number') {\n        data[key] = precise(keyData);\n      } else {\n        preciseData(keyData);\n      }\n    });\n  }\n}\n\n/**\n * check attributes pass condition\n * @param attributes\n * @param condition\n */\nexport function isAttributesPassCondition(attributes: any, condition: any) {\n  if (!attributes || !condition) {\n    return false;\n  }\n  return Object.keys(condition).every((key) => (\n    Array.isArray(condition[key]) ? condition[key].sort() : condition[key]).toString()\n    ===\n    (Array.isArray(attributes[key]) ? attributes[key].sort() : attributes[key])?.toString());\n}\n\nexport function getMatrixByRotation(rotation: number, width: number, height: number): PureMatrix3 {\n  // TODO: current only support 0, 90°, 180°, -90°\n  if (rotation === Math.PI / 2) {\n    return [\n      [0, -1, height],\n      [1, 0, 0],\n      [0, 0, 1],\n    ];\n  }\n  if (rotation === Math.PI) {\n    return [\n      [-1, 0, width],\n      [0, -1, height],\n      [0, 0, 1],\n    ];\n  }\n  if (rotation === -Math.PI / 2) {\n    return [\n      [0, 1, 0],\n      [-1, 0, width],\n      [0, 0, 1],\n    ];\n  }\n  return [\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n  ];\n}\n\nexport function calcPositionByMatrix(position: { x: number, y: number }, matrix: PureMatrix3) {\n  const { x, y } = position;\n  const [l1, l2] = matrix;\n  return {\n    x: l1[0] * x + l1[1] * y + l1[2],\n    y: l2[0] * x + l2[1] * y + l2[2],\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}