{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/VideoAnnotationApp.jsx\";\n/* eslint-disable no-return-await */\n/* eslint-disable react/forbid-prop-types */\n/* eslint-disable class-methods-use-this */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { cloneDeep, isEqual } from 'lodash';\nimport { message, notification, Modal } from 'antd';\nimport LayoutWrapper from '../../common/layout/LayoutWrapper';\nimport { initPayloadState, setCurrentSegment, setErrorMsg, setWordTimestamps, setVideoLoaded, setLoadReviewEnabled, setResults } from '../redux/action';\nimport TaskNavigation from './TaskNavigation/TaskNavigation';\nimport AudioComp from './AudioComp/AudioComp';\nimport VideoComp from './VideoComp/VideoComp';\nimport SegmentNavigation from './SegmentNavigation/SegmentNavigation';\nimport SegmentAbstract from './SegmentAbstract/SegmentAbstract';\nimport SegmentDetail from './SegmentDetail/SegmentDetail';\nimport Validation from './Validation/Validation';\nimport GlobalAttributes from './GlobalAttributes/GlobalAttributes';\nimport './VideoAnnotationApp.scss';\nimport { isReviewEditable, isPreview, isAnnotationReadonly } from '../../../utils/tool-mode';\nimport { translate, validateForm, ValidDurationMode, SegmentMode } from '../constants';\nimport { fetchResultByUrl, getFileExtension, getWords } from '../../../utils';\nimport { verifyCurrentForm, isInput } from '../redux/reducer/segmentController';\nimport { initPayload, handleLawToWav } from '../redux/reducer/connectController';\nimport AutoSaver from '../../common/AutoSaver';\nnotification.config({\n  top: 60\n});\nclass VideoAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.loadAlaws = async audios => {\n      let loadAlaw = false;\n      const videos = cloneDeep(audios);\n      for (let i = 0; i < videos.length; i += 1) {\n        const {\n          url\n        } = videos[i];\n        const tail = getFileExtension(url);\n        if (tail === 'alaw' || tail === 'ulaw') {\n          loadAlaw = true;\n          // eslint-disable-next-line no-await-in-loop\n          videos[i].url = await handleLawToWav(url, tail, i);\n          videos[i].loaded = true;\n        }\n      }\n      if (loadAlaw) {\n        this.props.setVideoLoaded({\n          videos\n        });\n      }\n    };\n    this.onSave = async () => {\n      if (isPreview(this.props.toolMode)) {\n        return;\n      }\n      try {\n        if (!isAnnotationReadonly(this.props.toolMode)) {\n          await this.saveResult();\n        }\n        if (isReviewEditable(this.props.toolMode)) {\n          await this.saveReviews();\n        }\n        notification.success({\n          message: translate('saveSuccess')\n        });\n      } catch (e) {\n        notification.error({\n          message: (e === null || e === void 0 ? void 0 : e.message) || translate('saveFailure')\n        });\n      }\n    };\n    this.setCurrentSegment = data => {\n      const {\n        index\n      } = data;\n      this.props.setCurrentSegment(data);\n      if (this.props.results[0][index]) {\n        if (this.segmentAbstract.listRef) {\n          this.segmentAbstract.listRef.scrollToRow(index);\n        }\n        if (this.segmentNavigation.gridRef) {\n          this.segmentNavigation.gridRef.scrollToCell({\n            rowIndex: Math.floor(index / this.segmentNavigation.gridRef.props.columnCount)\n          });\n        }\n      }\n    };\n    this.segmentIsValid = (attributes, content, invalidOptions) => {\n      let isValid = true;\n      if (this.props.validDuration === ValidDurationMode.translations) {\n        const index = content.findIndex(c => c.text && c.text.trim() !== '');\n        if (index < 0) {\n          isValid = false;\n        }\n      } else {\n        const keyAttributeValue = attributes[this.props.keyAttribute.name];\n        if (keyAttributeValue && invalidOptions.includes(keyAttributeValue)) {\n          isValid = false;\n        }\n      }\n      return isValid;\n    };\n    this.getTimeStatistics = annotationResults => {\n      const objects = {\n        summary: [],\n        duration: 0,\n        // file duration\n        validDuration: 0,\n        annotationDuration: 0,\n        // annotation duration\n        approvedValidDuration: 0,\n        rejectedValidDuration: 0,\n        annotationWordCount: 0,\n        annotatedCount: 0,\n        validAnnotatedCount: 0,\n        incrementDuration: 0\n      };\n      const reviews = this.extractReviews();\n      const {\n        videos,\n        lastResults: reviewResults\n      } = this.props;\n      const lastAnnotationResults = cloneDeep(reviewResults);\n      for (let m = 0; m < videos.length; m += 1) {\n        const {\n          duration,\n          attributes\n        } = videos[m];\n        objects.duration += duration * 1000;\n        const isValidField = this.props.globalConfig.fields.find(f => f.name === 'is_valid');\n        if (isValidField) {\n          const invalid = (attributes === null || attributes === void 0 ? void 0 : attributes.is_valid) === 'invalid';\n          if (objects.validAudios === undefined) {\n            objects.validAudios = [];\n            objects.invalidAudios = [];\n          }\n          if (invalid) {\n            objects.invalidAudios.push(m);\n          } else {\n            objects.validAudios.push(m);\n          }\n        }\n      }\n      const invalidOptions = this.props.keyAttribute.options.filter(o => o.isValid === false).map(o => o.value);\n      for (let i = 0; i < videos.length; i += 1) {\n        const results = annotationResults[i];\n        const review = reviews[i];\n        const {\n          duration\n        } = videos[i];\n        for (let j = 0; j < results.length; j += 1) {\n          const {\n            attributes,\n            id,\n            start,\n            end,\n            content\n          } = results[j];\n          if (start >= duration) break;\n          const time = (end - start) * 1000;\n          const isValid = this.segmentIsValid(attributes, content, invalidOptions);\n\n          // changed segment\n          const lastResults = lastAnnotationResults[i];\n          const equal = isEqual(results[j], lastResults[id]);\n          const incrementDuration = isValid && !equal ? time : 0;\n          delete lastResults[id];\n          objects.incrementDuration += incrementDuration;\n          for (let index = 0; index < content.length; index += 1) {\n            const {\n              text\n            } = content[index];\n            const words = getWords(text, []);\n            objects.annotationWordCount += words.length;\n          }\n          objects.annotatedCount += 1;\n          objects.annotationDuration += time;\n          // valid time statistic\n          if (isValid) {\n            var _review$id, _review$id2;\n            objects.validDuration += time;\n            objects.validAnnotatedCount += 1;\n            if ((review === null || review === void 0 ? void 0 : (_review$id = review[id]) === null || _review$id === void 0 ? void 0 : _review$id.qaChecked) === true) {\n              objects.approvedValidDuration += time;\n            } else if ((review === null || review === void 0 ? void 0 : (_review$id2 = review[id]) === null || _review$id2 === void 0 ? void 0 : _review$id2.qaChecked) === false) {\n              objects.rejectedValidDuration += time;\n            }\n          }\n        }\n      }\n\n      // removed segment\n      for (let m = 0; m < lastAnnotationResults.length; m += 1) {\n        const keys = Object.keys(lastAnnotationResults[m]);\n        for (let n = 0; n < keys.length; n += 1) {\n          const {\n            start,\n            end,\n            content = [],\n            attributes = {}\n          } = lastAnnotationResults[m][keys[n]];\n          const isValid = this.segmentIsValid(attributes, content, invalidOptions);\n          if (isValid) {\n            objects.incrementDuration += (end - start) * 1000;\n          }\n        }\n      }\n      return {\n        ...objects,\n        duration: Number(objects.duration.toFixed(2)),\n        validDuration: Number(objects.validDuration.toFixed(2)),\n        annotationDuration: Number(objects.annotationDuration.toFixed(2)),\n        approvedValidDuration: Number(objects.approvedValidDuration.toFixed(2)),\n        rejectedValidDuration: Number(objects.rejectedValidDuration.toFixed(2)),\n        incrementDuration: Number(objects.incrementDuration.toFixed(2))\n      };\n    };\n    this.clearAll = () => {\n      var _this$audioRef, _this$audioRef$curren;\n      (_this$audioRef = this.audioRef) === null || _this$audioRef === void 0 ? void 0 : (_this$audioRef$curren = _this$audioRef.current) === null || _this$audioRef$curren === void 0 ? void 0 : _this$audioRef$curren.clearAll();\n    };\n    /**\n     * load latest data of advance job\n     */\n    this.loadAdvanceJobData = e => {\n      var _e$result;\n      const {\n        results\n      } = this.props;\n      const reviews = this.extractReviews();\n      const newResults = ((_e$result = e.result) === null || _e$result === void 0 ? void 0 : _e$result.results) || results;\n      this.appendReviews(newResults, e.reviews || reviews);\n      this.props.setResults({\n        results: newResults\n      });\n      if (e.result) {\n        var _this$audioRef2, _this$audioRef2$curre;\n        (_this$audioRef2 = this.audioRef) === null || _this$audioRef2 === void 0 ? void 0 : (_this$audioRef2$curre = _this$audioRef2.current) === null || _this$audioRef2$curre === void 0 ? void 0 : _this$audioRef2$curre.renderSegments();\n      }\n    };\n    this.state = {\n      ready: false\n    };\n    window.disableLongAudioHotKeys = true;\n    this.validator = React.createRef();\n    this.audioRef = React.createRef();\n    this.saverRef = React.createRef();\n  }\n  componentDidMount() {\n    // initialize the annotations and reviews\n    this.props.jobProxy.loadResult().then(async result => {\n      // TODO: review the implementation of the init function\n\n      // handle old and new result format, old - array, new object with results and auditId\n      let annotationResult = [];\n      if (Array.isArray(result)) {\n        annotationResult = result;\n      } else if (result && result.results) {\n        annotationResult = result.results;\n        if (result.auditId) {\n          this.props.jobProxy.setAuditId(result.auditId);\n        }\n      }\n      const reviews = (await this.props.jobProxy.loadReviews()) || {};\n      this.appendReviews(annotationResult, reviews);\n      try {\n        if (!this.props.payload.audio) {\n          this.props.setErrorMsg({\n            errorMsg: translate('AUDIO_SOURCE_ERROR')\n          });\n          return;\n        }\n        const payload = await initPayload(this.props.state, {\n          ...this.props.payload,\n          review_from: annotationResult,\n          result\n        });\n        this.props.initPayloadState(payload);\n        await this.initWordTimestamps();\n        this.setState({\n          ready: true\n        });\n        this.props.renderComplete();\n        window.disableLongAudioHotKeys = false;\n        this.loadAlaws(payload.videos);\n        this.props.setLoadReviewEnabled(this.props.jobProxy.loadReviewEnabled);\n      } catch (e) {\n        console.log('Error', e);\n        this.props.setErrorMsg({\n          errorMsg: e === null || e === void 0 ? void 0 : e.toString()\n        });\n      }\n    }).catch(() => {\n      this.props.setErrorMsg({\n        errorMsg: translate('ANNOTATION_DATA_LOAD_ERROR')\n      });\n    }).then(() => {\n      // check temp saved data\n      if (this.props.jobProxy.savedDataLoadError) {\n        Modal.confirm({\n          title: translate('TEMP_SAVED_LOAD_ERROR'),\n          okText: translate('TEMP_SAVED_LOAD_ERROR_OK'),\n          cancelText: translate('TEMP_SAVED_LOAD_ERROR_CANCEL'),\n          autoFocusButton: null,\n          onOk: () => {\n            var _this$saverRef$curren;\n            // set temp saved to true to disable leave check\n            (_this$saverRef$curren = this.saverRef.current) === null || _this$saverRef$curren === void 0 ? void 0 : _this$saverRef$curren.setTempSaved(true);\n            window.location.reload();\n          },\n          onCancel: () => {\n            // set to false to enable result save\n            this.props.jobProxy.savedDataLoadError = false;\n          }\n        });\n      }\n    });\n    window.addEventListener('keydown', async e => {\n      if (window.disableLongAudioHotKeys) return;\n      if (isInput()) return;\n      if (e.keyCode === 83) {\n        // s\n        if (e.altKey || e.metaKey) return;\n        if (e.ctrlKey) {\n          e.preventDefault();\n          this.onSave();\n        }\n      }\n    });\n  }\n  componentWillUnmount() {}\n  async initWordTimestamps() {\n    const wordTimestamps = await Promise.all(this.props.wordTimestampUrls.map(async url => await this.parseWords(url)));\n    this.props.setWordTimestamps({\n      wordTimestamps\n    });\n  }\n  async parseWords(wordUrl) {\n    if (wordUrl) {\n      try {\n        const ret = await fetchResultByUrl(wordUrl);\n        ret.words.sort((a, b) => a < b ? -1 : 1);\n        return ret;\n      } catch (e) {\n        console.log(`failed to load word from ${wordUrl}`, e);\n      }\n    }\n    return [];\n  }\n  appendReviews(result, reviews) {\n    if (!result) return;\n    result.forEach((videoSegments, videoIdx) => {\n      const videoReviews = reviews[videoIdx] || {};\n      videoSegments.forEach(segment => {\n        if (Object.keys(reviews).length > 0) {\n          delete segment.qaChecked;\n          delete segment.qaComment;\n          delete segment.qaReason;\n          delete segment.qaWorkerName;\n        }\n        const segmentReview = videoReviews[segment.id];\n        if (segmentReview) {\n          segment.qaChecked = segmentReview.qaChecked;\n          segment.qaComment = segmentReview.qaComment;\n          segment.qaReason = segmentReview.qaReason;\n          segment.qaWorkerName = segmentReview.qaWorkerName;\n        }\n      });\n    });\n  }\n  isLineCountMatched(source, target) {\n    if (typeof source === 'string' && source.length > 0) {\n      return target && source.split(/\\r\\n|\\r|\\n/).length === target.split(/\\r\\n|\\r|\\n/).length;\n    }\n    return true;\n  }\n  async saveResult(isSubmit = false) {\n    if (!this.state.ready) {\n      throw new Error(`${translate('TOOL_NOT_INITIALIZED')}`);\n    }\n    const invalidOptions = this.props.keyAttribute.options.filter(o => o.isValid === false).map(o => o.value);\n    const annotationResults = cloneDeep(this.props.results);\n    const annotationVideos = cloneDeep(this.props.videos);\n    let validAudios;\n    let invalidAudios;\n    for (let i = 0; i < annotationVideos.length; i += 1) {\n      const video = annotationVideos[i];\n      delete video.originAttributes;\n      delete video.defaultAttributes;\n      video.url = video.source || video.url;\n      delete video.source;\n      if (isSubmit && video.duration === undefined) {\n        throw new Error(`${translate('AUDIO_NOT_COMPLETE')} No: ${i + 1} `);\n      }\n    }\n    if (isSubmit && this.props.globalConfig && Array.isArray(this.props.globalConfig.fields) && this.props.globalConfig.fields.length > 0) {\n      annotationResults.forEach((_, index) => {\n        const {\n          attributes\n        } = annotationVideos[index];\n        // global attributes check\n        if (!attributes || !validateForm(this.props.globalConfig, attributes)) {\n          throw new Error(translate('GLOBAL_ATTR_MISS'));\n        }\n        // remove invalid audio results\n        const invalid = (attributes || {}).is_valid === 'invalid';\n        if (!this.props.invalidAnnotatable && invalid) {\n          annotationResults[index] = [];\n        }\n        const isValidField = this.props.globalConfig.fields.find(f => f.name === 'is_valid');\n        if (isValidField) {\n          if (validAudios === undefined) {\n            validAudios = [];\n            invalidAudios = [];\n          }\n          if (invalid) {\n            invalidAudios.push(index);\n          } else {\n            validAudios.push(index);\n          }\n        }\n      });\n    }\n    const isContinuous = this.props.segmentMode === SegmentMode.continuous;\n    const minLen = Math.min(this.props.minSegmentLength, 0);\n    for (let currentVideo = 0; currentVideo < annotationResults.length; currentVideo += 1) {\n      const video = annotationVideos[currentVideo];\n      const audio = annotationResults[currentVideo].filter(s => s.start < video.duration);\n      const segmentsMap = {};\n      let prevEnd = 0;\n      for (let n = 0; n < audio.length; n += 1) {\n        const {\n          qaChecked,\n          qaComment,\n          qaReason,\n          qaWorkerName,\n          ...oldsSegment\n        } = audio[n];\n        let segment = oldsSegment;\n        if (segment.end - segment.start <= minLen) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        if (this.props.lineConfig || this.props.segmentConfig) {\n          // required field check\n          if (isSubmit) {\n            const varifyRes = verifyCurrentForm({\n              ...this.props,\n              currentVideo,\n              currentSegment: n\n            });\n            if (varifyRes.result === true) {\n              const {\n                qaChecked: qaCh,\n                qaComment: qaCo,\n                qaReason: qaRe,\n                qaWorkerName: qaWname,\n                ...newSegment\n              } = varifyRes.data;\n              segment = {\n                ...segment,\n                ...newSegment\n              };\n            } else {\n              throw new Error(varifyRes.error);\n            }\n          }\n\n          // set segment valid\n          if (this.props.validDuration === ValidDurationMode.translations) {\n            const index = segment.content.findIndex(c => c.text && c.text.trim() !== '');\n            if (index >= 0) {\n              segment.isValid = true;\n            } else {\n              segment.isValid = false;\n            }\n          } else {\n            const keyAttributeValue = segment.attributes[this.props.keyAttribute.name];\n            if (keyAttributeValue && invalidOptions.includes(keyAttributeValue)) {\n              segment.isValid = false;\n            } else {\n              segment.isValid = true;\n            }\n          }\n        }\n        if (isContinuous && segment.start !== prevEnd) {\n          segment.start = prevEnd;\n        }\n        if (isContinuous && n === audio.length - 1) {\n          segment.end = video.duration;\n        }\n        prevEnd = segment.end;\n        if (Array.isArray(segment.content)) {\n          segment.content.forEach((l, i) => {\n            var _l$text;\n            l.text = (_l$text = l.text) === null || _l$text === void 0 ? void 0 : _l$text.trim();\n            if (isSubmit) {\n              if (this.props.client === 'hw-translation') {\n                if (!this.isLineCountMatched(segment.attributes.source, l.text)) {\n                  const err = `${translate('DATA_ERROR_LINE_COUNT_MISMATCH')}. Segment: ${n + 1}`;\n                  notification.error({\n                    message: err\n                  });\n                  throw new Error(err);\n                }\n              }\n            }\n          });\n        }\n        segmentsMap[segment.id] = segment;\n      }\n      annotationResults[currentVideo] = Object.values(segmentsMap);\n    }\n\n    // custom validation\n    if (isSubmit && this.props.submitCheck && this.validator.current) {\n      const {\n        hasCustomError,\n        blockSubmitErrors\n      } = await this.validator.current.handleValidate();\n      if (hasCustomError) {\n        throw new Error(translate('VALIDATION_CUSTOM_ERROR'));\n      }\n      const errorVideos = [];\n      blockSubmitErrors.forEach((errors, index) => {\n        if (errors.length > 0) {\n          errorVideos.push(index);\n        }\n      });\n      if (errorVideos.length > 0) {\n        throw new Error(`${translate('VALIDATION_SUBMIT_FAIL')}${errorVideos.map(i => i + 1).join(', ')}`);\n      }\n    }\n    const statData = this.getTimeStatistics(annotationResults);\n    const statistics = await this.props.jobProxy.saveResultStat(statData);\n    return this.props.jobProxy.saveResult({\n      results: annotationResults,\n      audios: annotationVideos,\n      keyAttribute: this.props.keyAttribute,\n      auditId: this.props.jobProxy.auditFileId,\n      statistics,\n      templateConfig: this.props.jobProxy.templateConfig,\n      ...(validAudios && {\n        validAudios,\n        invalidAudios\n      })\n    }, isSubmit);\n  }\n  saveReviews(isSubmit = false) {\n    const reviews = this.extractReviews();\n    return this.props.jobProxy.saveReviews(reviews, isSubmit);\n  }\n  extractReviews() {\n    return this.props.results.map((audio, m) => {\n      const segmentReviews = {};\n      audio.forEach((segment, n) => {\n        segmentReviews[segment.id] = {\n          qaChecked: segment.qaChecked,\n          qaComment: segment.qaComment,\n          qaReason: segment.qaReason,\n          qaWorkerName: segment.qaWorkerName,\n          label: `audio${m}-${n}`\n        };\n      });\n      return segmentReviews;\n    });\n  }\n  render() {\n    const {\n      currentVideo,\n      videos,\n      errorMsg,\n      audioErrorMsg\n    } = this.props;\n    if (errorMsg) {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: \"error-message\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 518,\n          columnNumber: 9\n        }\n      }, errorMsg);\n    }\n    return /*#__PURE__*/React.createElement(LayoutWrapper, {\n      className: \"video-annotation-container\",\n      loading: this.props.loading,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 523,\n        columnNumber: 7\n      }\n    }, videos.length && this.state.ready ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(AutoSaver, {\n      ref: this.saverRef,\n      data: this.props.results,\n      save: () => this.onSave(),\n      onSaved: () => message.success(translate('AUTO_SAVE_SUCCESS')),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 526,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(TaskNavigation, {\n      setCurrentSegment: this.setCurrentSegment,\n      clearAll: this.clearAll,\n      onSave: this.onSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 532,\n        columnNumber: 13\n      }\n    }), (audioErrorMsg === null || audioErrorMsg === void 0 ? void 0 : audioErrorMsg[currentVideo]) ? /*#__PURE__*/React.createElement(\"div\", {\n      className: \"error-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 538,\n        columnNumber: 15\n      }\n    }, audioErrorMsg === null || audioErrorMsg === void 0 ? void 0 : audioErrorMsg[currentVideo]) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(AudioComp, {\n      ref: this.audioRef,\n      setCurrentSegment: this.setCurrentSegment,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 543,\n        columnNumber: 17\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"right-component-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 547,\n        columnNumber: 17\n      }\n    }, /*#__PURE__*/React.createElement(VideoComp, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 548,\n        columnNumber: 19\n      }\n    }), /*#__PURE__*/React.createElement(SegmentNavigation, {\n      setCurrentSegment: this.setCurrentSegment,\n      ref: r => {\n        this.segmentNavigation = r;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 549,\n        columnNumber: 19\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"left-component-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 554,\n        columnNumber: 17\n      }\n    }, /*#__PURE__*/React.createElement(GlobalAttributes, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 555,\n        columnNumber: 19\n      }\n    }), /*#__PURE__*/React.createElement(SegmentAbstract, {\n      setCurrentSegment: this.setCurrentSegment\n      // eslint-disable-next-line no-return-assign\n      ,\n      ref: r => this.segmentAbstract = r,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 556,\n        columnNumber: 19\n      }\n    })), /*#__PURE__*/React.createElement(SegmentDetail, {\n      setCurrentSegment: this.setCurrentSegment,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 562,\n        columnNumber: 17\n      }\n    }), /*#__PURE__*/React.createElement(Validation, {\n      ref: this.validator,\n      jobProxy: this.props.jobProxy,\n      saveResult: () => this.saveResult(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 563,\n        columnNumber: 17\n      }\n    }))) : null);\n  }\n}\nVideoAnnotationApp.propTypes = {\n  initPayloadState: PropTypes.func.isRequired,\n  renderComplete: PropTypes.func,\n  jobProxy: PropTypes.object\n};\nconst mapStateToProps = state => ({\n  videos: state.videos,\n  currentVideo: state.currentVideo,\n  results: state.results,\n  lastResults: state.lastResults,\n  segmentMode: state.segmentMode,\n  toolMode: state.toolMode,\n  errorMsg: state.errorMsg,\n  audioErrorMsg: state.audioErrorMsg,\n  currentSegment: state.currentSegment,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  keyAttribute: state.keyAttribute,\n  client: state.client,\n  wordTimestampUrls: state.wordTimestampUrls,\n  submitCheck: state.submitCheck,\n  invalidAnnotatable: state.invalidAnnotatable,\n  globalConfig: state.globalConfig,\n  loading: state.loading,\n  validDuration: state.validDuration,\n  minSegmentLength: state.minSegmentLength,\n  state\n});\nconst mapDispatchToProps = {\n  initPayloadState,\n  setCurrentSegment,\n  setErrorMsg,\n  setWordTimestamps,\n  setVideoLoaded,\n  setLoadReviewEnabled,\n  setResults\n};\nexport default connect(mapStateToProps, mapDispatchToProps, null, {\n  forwardRef: true\n})(VideoAnnotationApp);","map":{"version":3,"names":["React","PropTypes","connect","cloneDeep","isEqual","message","notification","Modal","LayoutWrapper","initPayloadState","setCurrentSegment","setErrorMsg","setWordTimestamps","setVideoLoaded","setLoadReviewEnabled","setResults","TaskNavigation","AudioComp","VideoComp","SegmentNavigation","SegmentAbstract","SegmentDetail","Validation","GlobalAttributes","isReviewEditable","isPreview","isAnnotationReadonly","translate","validateForm","ValidDurationMode","SegmentMode","fetchResultByUrl","getFileExtension","getWords","verifyCurrentForm","isInput","initPayload","handleLawToWav","AutoSaver","config","top","VideoAnnotationApp","Component","constructor","props","loadAlaws","audios","loadAlaw","videos","i","length","url","tail","loaded","onSave","toolMode","saveResult","saveReviews","success","e","error","data","index","results","segmentAbstract","listRef","scrollToRow","segmentNavigation","gridRef","scrollToCell","rowIndex","Math","floor","columnCount","segmentIsValid","attributes","content","invalidOptions","isValid","validDuration","translations","findIndex","c","text","trim","keyAttributeValue","keyAttribute","name","includes","getTimeStatistics","annotationResults","objects","summary","duration","annotationDuration","approvedValidDuration","rejectedValidDuration","annotationWordCount","annotatedCount","validAnnotatedCount","incrementDuration","reviews","extractReviews","lastResults","reviewResults","lastAnnotationResults","m","isValidField","globalConfig","fields","find","f","invalid","is_valid","validAudios","undefined","invalidAudios","push","options","filter","o","map","value","review","j","id","start","end","time","equal","words","_review$id","_review$id2","qaChecked","keys","Object","n","Number","toFixed","clearAll","_this$audioRef","_this$audioRef$curren","audioRef","current","loadAdvanceJobData","_e$result","newResults","result","appendReviews","_this$audioRef2","_this$audioRef2$curre","renderSegments","state","ready","window","disableLongAudioHotKeys","validator","createRef","saverRef","componentDidMount","jobProxy","loadResult","then","annotationResult","Array","isArray","auditId","setAuditId","loadReviews","payload","audio","errorMsg","review_from","initWordTimestamps","setState","renderComplete","loadReviewEnabled","console","log","toString","catch","savedDataLoadError","confirm","title","okText","cancelText","autoFocusButton","onOk","_this$saverRef$curren","setTempSaved","location","reload","onCancel","addEventListener","keyCode","altKey","metaKey","ctrlKey","preventDefault","componentWillUnmount","wordTimestamps","Promise","all","wordTimestampUrls","parseWords","wordUrl","ret","sort","a","b","forEach","videoSegments","videoIdx","videoReviews","segment","qaComment","qaReason","qaWorkerName","segmentReview","isLineCountMatched","source","target","split","isSubmit","Error","annotationVideos","video","originAttributes","defaultAttributes","_","invalidAnnotatable","isContinuous","segmentMode","continuous","minLen","min","minSegmentLength","currentVideo","s","segmentsMap","prevEnd","oldsSegment","lineConfig","segmentConfig","varifyRes","currentSegment","qaCh","qaCo","qaRe","qaWname","newSegment","l","_l$text","client","err","values","submitCheck","hasCustomError","blockSubmitErrors","handleValidate","errorVideos","errors","join","statData","statistics","saveResultStat","auditFileId","templateConfig","segmentReviews","label","render","audioErrorMsg","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","loading","Fragment","ref","save","onSaved","r","propTypes","func","isRequired","object","mapStateToProps","mapDispatchToProps","forwardRef"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/VideoAnnotationApp.jsx"],"sourcesContent":["/* eslint-disable no-return-await */\n/* eslint-disable react/forbid-prop-types */\n/* eslint-disable class-methods-use-this */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { cloneDeep, isEqual } from 'lodash';\nimport { message, notification, Modal } from 'antd';\nimport LayoutWrapper from '../../common/layout/LayoutWrapper';\nimport { initPayloadState, setCurrentSegment, setErrorMsg, setWordTimestamps, setVideoLoaded, setLoadReviewEnabled, setResults } from '../redux/action';\nimport TaskNavigation from './TaskNavigation/TaskNavigation';\nimport AudioComp from './AudioComp/AudioComp';\nimport VideoComp from './VideoComp/VideoComp';\nimport SegmentNavigation from './SegmentNavigation/SegmentNavigation';\nimport SegmentAbstract from './SegmentAbstract/SegmentAbstract';\nimport SegmentDetail from './SegmentDetail/SegmentDetail';\nimport Validation from './Validation/Validation';\nimport GlobalAttributes from './GlobalAttributes/GlobalAttributes';\nimport './VideoAnnotationApp.scss';\nimport { isReviewEditable, isPreview, isAnnotationReadonly } from '../../../utils/tool-mode';\nimport { translate, validateForm, ValidDurationMode, SegmentMode } from '../constants';\nimport { fetchResultByUrl, getFileExtension, getWords } from '../../../utils';\nimport { verifyCurrentForm, isInput } from '../redux/reducer/segmentController';\nimport { initPayload, handleLawToWav } from '../redux/reducer/connectController';\nimport AutoSaver from '../../common/AutoSaver';\n\nnotification.config({ top: 60 });\n\nclass VideoAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      ready: false,\n    };\n    window.disableLongAudioHotKeys = true;\n\n    this.validator = React.createRef();\n    this.audioRef = React.createRef();\n    this.saverRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // initialize the annotations and reviews\n    this.props.jobProxy.loadResult().then(async (result) => {\n      // TODO: review the implementation of the init function\n\n      // handle old and new result format, old - array, new object with results and auditId\n      let annotationResult = [];\n      if (Array.isArray(result)) {\n        annotationResult = result;\n      } else if (result && result.results) {\n        annotationResult = result.results;\n        if (result.auditId) {\n          this.props.jobProxy.setAuditId(result.auditId);\n        }\n      }\n      const reviews = await this.props.jobProxy.loadReviews() || {};\n      this.appendReviews(annotationResult, reviews);\n      try {\n        if (!this.props.payload.audio) {\n          this.props.setErrorMsg({ errorMsg: translate('AUDIO_SOURCE_ERROR') });\n          return;\n        }\n        const payload = await initPayload(this.props.state, { ...this.props.payload, review_from: annotationResult, result });\n        this.props.initPayloadState(payload);\n        await this.initWordTimestamps();\n        this.setState({ ready: true });\n        this.props.renderComplete();\n        window.disableLongAudioHotKeys = false;\n        this.loadAlaws(payload.videos);\n        this.props.setLoadReviewEnabled(this.props.jobProxy.loadReviewEnabled);\n      } catch (e) {\n        console.log('Error', e);\n        this.props.setErrorMsg({ errorMsg: e?.toString() });\n      }\n    }).catch(() => {\n      this.props.setErrorMsg({ errorMsg: translate('ANNOTATION_DATA_LOAD_ERROR') });\n    }).then(() => {\n      // check temp saved data\n      if (this.props.jobProxy.savedDataLoadError) {\n        Modal.confirm({\n          title: translate('TEMP_SAVED_LOAD_ERROR'),\n          okText: translate('TEMP_SAVED_LOAD_ERROR_OK'),\n          cancelText: translate('TEMP_SAVED_LOAD_ERROR_CANCEL'),\n          autoFocusButton: null,\n          onOk: () => {\n            // set temp saved to true to disable leave check\n            this.saverRef.current?.setTempSaved(true);\n            window.location.reload();\n          },\n          onCancel: () => {\n            // set to false to enable result save\n            this.props.jobProxy.savedDataLoadError = false;\n          },\n        });\n      }\n    });\n\n    window.addEventListener('keydown', async (e) => {\n      if (window.disableLongAudioHotKeys) return;\n      if (isInput()) return;\n      if (e.keyCode === 83) { // s\n        if (e.altKey || e.metaKey) return;\n        if (e.ctrlKey) {\n          e.preventDefault();\n          this.onSave();\n        }\n      }\n    });\n  }\n\n  componentWillUnmount() {\n\n  }\n\n  loadAlaws = async (audios) => {\n    let loadAlaw = false;\n    const videos = cloneDeep(audios);\n    for (let i = 0; i < videos.length; i += 1) {\n      const { url } = videos[i];\n      const tail = getFileExtension(url);\n      if (tail === 'alaw' || tail === 'ulaw') {\n        loadAlaw = true;\n        // eslint-disable-next-line no-await-in-loop\n        videos[i].url = await handleLawToWav(url, tail, i);\n        videos[i].loaded = true;\n      }\n    }\n    if (loadAlaw) {\n      this.props.setVideoLoaded({ videos });\n    }\n  };\n\n  async initWordTimestamps() {\n    const wordTimestamps = await Promise.all(this.props.wordTimestampUrls.map(async (url) => await this.parseWords(url)));\n    this.props.setWordTimestamps({ wordTimestamps });\n  }\n\n  async parseWords(wordUrl) {\n    if (wordUrl) {\n      try {\n        const ret = await fetchResultByUrl(wordUrl);\n        ret.words.sort((a, b) => (a < b ? -1 : 1));\n        return ret;\n      } catch (e) {\n        console.log(`failed to load word from ${wordUrl}`, e);\n      }\n    }\n    return [];\n  };\n\n  onSave = async () => {\n    if (isPreview(this.props.toolMode)) {\n      return;\n    }\n    try {\n      if (!isAnnotationReadonly(this.props.toolMode)) {\n        await this.saveResult();\n      }\n      if (isReviewEditable(this.props.toolMode)) {\n        await this.saveReviews();\n      }\n      notification.success({ message: translate('saveSuccess') });\n    } catch (e) {\n      notification.error({ message: e?.message || translate('saveFailure') });\n    }\n  };\n\n  appendReviews(result, reviews) {\n    if (!result) return;\n    result.forEach((videoSegments, videoIdx) => {\n      const videoReviews = reviews[videoIdx] || {};\n      videoSegments.forEach((segment) => {\n        if (Object.keys(reviews).length > 0) {\n          delete segment.qaChecked;\n          delete segment.qaComment;\n          delete segment.qaReason;\n          delete segment.qaWorkerName;\n        }\n        const segmentReview = videoReviews[segment.id];\n        if (segmentReview) {\n          segment.qaChecked = segmentReview.qaChecked;\n          segment.qaComment = segmentReview.qaComment;\n          segment.qaReason = segmentReview.qaReason;\n          segment.qaWorkerName = segmentReview.qaWorkerName;\n        }\n      });\n    });\n  }\n\n  isLineCountMatched(source, target) {\n    if (typeof source === 'string' && source.length > 0) {\n      return target && source.split(/\\r\\n|\\r|\\n/).length === target.split(/\\r\\n|\\r|\\n/).length;\n    }\n    return true;\n  }\n\n  async saveResult(isSubmit = false) {\n    if (!this.state.ready) {\n      throw new Error(`${translate('TOOL_NOT_INITIALIZED')}`);\n    }\n    const invalidOptions = this.props.keyAttribute.options.filter((o) => o.isValid === false).map((o) => o.value);\n    const annotationResults = cloneDeep(this.props.results);\n    const annotationVideos = cloneDeep(this.props.videos);\n    let validAudios;\n    let invalidAudios;\n    for (let i = 0; i < annotationVideos.length; i += 1) {\n      const video = annotationVideos[i];\n      delete video.originAttributes;\n      delete video.defaultAttributes;\n      video.url = video.source || video.url;\n      delete video.source;\n      if (isSubmit && video.duration === undefined) {\n        throw new Error(`${translate('AUDIO_NOT_COMPLETE')} No: ${i + 1} `);\n      }\n    }\n    if (isSubmit && this.props.globalConfig && Array.isArray(this.props.globalConfig.fields) && this.props.globalConfig.fields.length > 0) {\n      annotationResults.forEach((_, index) => {\n        const { attributes } = annotationVideos[index];\n        // global attributes check\n        if (!attributes || !validateForm(this.props.globalConfig, attributes)) {\n          throw new Error(translate('GLOBAL_ATTR_MISS'));\n        }\n        // remove invalid audio results\n        const invalid = (attributes || {}).is_valid === 'invalid';\n        if (!this.props.invalidAnnotatable && invalid) {\n          annotationResults[index] = [];\n        }\n        const isValidField = this.props.globalConfig.fields.find((f) => f.name === 'is_valid');\n        if (isValidField) {\n          if (validAudios === undefined) {\n            validAudios = [];\n            invalidAudios = [];\n          }\n          if (invalid) {\n            invalidAudios.push(index);\n          } else {\n            validAudios.push(index);\n          }\n        }\n      });\n    }\n    const isContinuous = this.props.segmentMode === SegmentMode.continuous;\n    const minLen = Math.min(this.props.minSegmentLength, 0);\n    for (let currentVideo = 0; currentVideo < annotationResults.length; currentVideo += 1) {\n      const video = annotationVideos[currentVideo];\n      const audio = annotationResults[currentVideo].filter((s) => s.start < video.duration);\n      const segmentsMap = {};\n      let prevEnd = 0;\n      for (let n = 0; n < audio.length; n += 1) {\n        const { qaChecked, qaComment, qaReason, qaWorkerName, ...oldsSegment } = audio[n];\n        let segment = oldsSegment;\n        if (segment.end - segment.start <= minLen) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        if (this.props.lineConfig || this.props.segmentConfig) {\n          // required field check\n          if (isSubmit) {\n            const varifyRes = verifyCurrentForm({\n              ...this.props,\n              currentVideo,\n              currentSegment: n\n            });\n            if (varifyRes.result === true) {\n              const { qaChecked: qaCh, qaComment: qaCo, qaReason: qaRe, qaWorkerName: qaWname, ...newSegment } = varifyRes.data;\n              segment = {\n                ...segment,\n                ...newSegment,\n              };\n            } else {\n              throw new Error(varifyRes.error);\n            }\n          }\n\n          // set segment valid\n          if (this.props.validDuration === ValidDurationMode.translations) {\n            const index = segment.content.findIndex((c) => c.text && c.text.trim() !== '');\n            if (index >= 0) {\n              segment.isValid = true;\n            } else {\n              segment.isValid = false;\n            }\n          } else {\n            const keyAttributeValue = segment.attributes[this.props.keyAttribute.name];\n            if (keyAttributeValue && invalidOptions.includes(keyAttributeValue)) {\n              segment.isValid = false;\n            } else {\n              segment.isValid = true;\n            }\n          }\n        }\n        if (isContinuous && segment.start !== prevEnd) {\n          segment.start = prevEnd;\n        }\n        if (isContinuous && n === audio.length - 1) {\n          segment.end = video.duration;\n        }\n\n        prevEnd = segment.end;\n        if (Array.isArray(segment.content)) {\n          segment.content.forEach((l, i) => {\n            l.text = l.text?.trim();\n            if (isSubmit) {\n              if (this.props.client === 'hw-translation') {\n                if (!this.isLineCountMatched(segment.attributes.source, l.text)) {\n                  const err = `${translate('DATA_ERROR_LINE_COUNT_MISMATCH')}. Segment: ${n + 1}`;\n                  notification.error({ message: err });\n                  throw new Error(err);\n                }\n              }\n            }\n          });\n        }\n        segmentsMap[segment.id] = segment;\n      }\n      annotationResults[currentVideo] = Object.values(segmentsMap);\n    }\n\n    // custom validation\n    if (isSubmit && this.props.submitCheck && this.validator.current) {\n      const { hasCustomError, blockSubmitErrors } = await this.validator.current.handleValidate();\n      if (hasCustomError) {\n        throw new Error(translate('VALIDATION_CUSTOM_ERROR'));\n      }\n      const errorVideos = [];\n      blockSubmitErrors.forEach((errors, index) => {\n        if (errors.length > 0) {\n          errorVideos.push(index);\n        }\n      });\n      if (errorVideos.length > 0) {\n        throw new Error(`${translate('VALIDATION_SUBMIT_FAIL')}${errorVideos.map((i) => i + 1).join(', ')}`);\n      }\n    }\n\n    const statData = this.getTimeStatistics(annotationResults);\n    const statistics = await this.props.jobProxy.saveResultStat(statData);\n    return this.props.jobProxy.saveResult({\n      results: annotationResults,\n      audios: annotationVideos,\n      keyAttribute: this.props.keyAttribute,\n      auditId: this.props.jobProxy.auditFileId,\n      statistics,\n      templateConfig: this.props.jobProxy.templateConfig,\n      ...validAudios && {\n        validAudios,\n        invalidAudios,\n      },\n    }, isSubmit);\n  }\n\n  saveReviews(isSubmit = false) {\n    const reviews = this.extractReviews();\n    return this.props.jobProxy.saveReviews(reviews, isSubmit);\n  }\n\n  extractReviews() {\n    return this.props.results.map((audio, m) => {\n      const segmentReviews = {};\n      audio.forEach((segment, n) => {\n        segmentReviews[segment.id] = {\n          qaChecked: segment.qaChecked,\n          qaComment: segment.qaComment,\n          qaReason: segment.qaReason,\n          qaWorkerName: segment.qaWorkerName,\n          label: `audio${m}-${n}`\n        };\n      });\n      return segmentReviews;\n    });\n  }\n\n  setCurrentSegment = (data) => {\n    const { index } = data;\n    this.props.setCurrentSegment(data);\n    if (this.props.results[0][index]) {\n      if (this.segmentAbstract.listRef) {\n        this.segmentAbstract.listRef.scrollToRow(index);\n      }\n      if (this.segmentNavigation.gridRef) {\n        this.segmentNavigation.gridRef.scrollToCell({ rowIndex: Math.floor(index / this.segmentNavigation.gridRef.props.columnCount) });\n      }\n    }\n  };\n\n  segmentIsValid = (attributes, content, invalidOptions) => {\n    let isValid = true;\n    if (this.props.validDuration === ValidDurationMode.translations) {\n      const index = content.findIndex((c) => c.text && c.text.trim() !== '');\n      if (index < 0) {\n        isValid = false;\n      }\n    } else {\n      const keyAttributeValue = attributes[this.props.keyAttribute.name];\n      if (keyAttributeValue && invalidOptions.includes(keyAttributeValue)) {\n        isValid = false;\n      }\n    }\n    return isValid;\n  };\n\n  getTimeStatistics = (annotationResults) => {\n    const objects = {\n      summary: [],\n      duration: 0, // file duration\n      validDuration: 0,\n      annotationDuration: 0, // annotation duration\n      approvedValidDuration: 0,\n      rejectedValidDuration: 0,\n      annotationWordCount: 0,\n      annotatedCount: 0,\n      validAnnotatedCount: 0,\n      incrementDuration: 0,\n    };\n    const reviews = this.extractReviews();\n    const { videos, lastResults: reviewResults } = this.props;\n    const lastAnnotationResults = cloneDeep(reviewResults);\n\n    for (let m = 0; m < videos.length; m += 1) {\n      const { duration, attributes } = videos[m];\n      objects.duration += duration * 1000;\n      const isValidField = this.props.globalConfig.fields.find((f) => f.name === 'is_valid');\n      if (isValidField) {\n        const invalid = attributes?.is_valid === 'invalid';\n        if (objects.validAudios === undefined) {\n          objects.validAudios = [];\n          objects.invalidAudios = [];\n        }\n        if (invalid) {\n          objects.invalidAudios.push(m);\n        } else {\n          objects.validAudios.push(m);\n        }\n      }\n    }\n    const invalidOptions = this.props.keyAttribute.options.filter((o) => o.isValid === false).map((o) => o.value);\n    for (let i = 0; i < videos.length; i += 1) {\n      const results = annotationResults[i];\n      const review = reviews[i];\n      const { duration } = videos[i];\n      for (let j = 0; j < results.length; j += 1) {\n        const { attributes, id, start, end, content } = results[j];\n        if (start >= duration) break;\n        const time = (end - start) * 1000;\n        const isValid = this.segmentIsValid(attributes, content, invalidOptions);\n\n        // changed segment\n        const lastResults = lastAnnotationResults[i];\n        const equal = isEqual(results[j], lastResults[id]);\n        const incrementDuration = (isValid && !equal) ? time : 0;\n        delete lastResults[id];\n        objects.incrementDuration += incrementDuration;\n        for (let index = 0; index < content.length; index += 1) {\n          const { text } = content[index];\n          const words = getWords(text, []);\n          objects.annotationWordCount += words.length;\n        }\n        objects.annotatedCount += 1;\n        objects.annotationDuration += time;\n        // valid time statistic\n        if (isValid) {\n          objects.validDuration += time;\n          objects.validAnnotatedCount += 1;\n          if (review?.[id]?.qaChecked === true) {\n            objects.approvedValidDuration += time;\n          } else if (review?.[id]?.qaChecked === false) {\n            objects.rejectedValidDuration += time;\n          }\n        }\n      }\n    }\n\n    // removed segment\n    for (let m = 0; m < lastAnnotationResults.length; m += 1) {\n      const keys = Object.keys(lastAnnotationResults[m]);\n      for (let n = 0; n < keys.length; n += 1) {\n        const { start, end, content = [], attributes = {} } = lastAnnotationResults[m][keys[n]];\n        const isValid = this.segmentIsValid(attributes, content, invalidOptions);\n        if (isValid) {\n          objects.incrementDuration += (end - start) * 1000;\n        }\n      }\n    }\n    return {\n      ...objects,\n      duration: Number(objects.duration.toFixed(2)),\n      validDuration: Number(objects.validDuration.toFixed(2)),\n      annotationDuration: Number(objects.annotationDuration.toFixed(2)),\n      approvedValidDuration: Number(objects.approvedValidDuration.toFixed(2)),\n      rejectedValidDuration: Number(objects.rejectedValidDuration.toFixed(2)),\n      incrementDuration: Number(objects.incrementDuration.toFixed(2)),\n    };\n  };\n\n  clearAll = () => {\n    this.audioRef?.current?.clearAll();\n  };\n\n  /**\n   * load latest data of advance job\n   */\n  loadAdvanceJobData = (e) => {\n    const { results } = this.props;\n    const reviews = this.extractReviews();\n    const newResults = e.result?.results || results;\n    this.appendReviews(newResults, e.reviews || reviews);\n    this.props.setResults({ results: newResults });\n    if (e.result) {\n      this.audioRef?.current?.renderSegments();\n    }\n  };\n\n  render() {\n    const { currentVideo, videos, errorMsg, audioErrorMsg } = this.props;\n    if (errorMsg) {\n      return (\n        <div className=\"error-message\">{errorMsg}</div>\n      );\n    }\n\n    return (\n      <LayoutWrapper className=\"video-annotation-container\" loading={this.props.loading}>\n        {(videos.length && this.state.ready) ? (\n          <>\n            <AutoSaver\n              ref={this.saverRef}\n              data={this.props.results}\n              save={() => this.onSave()}\n              onSaved={() => message.success(translate('AUTO_SAVE_SUCCESS'))}\n            />\n            <TaskNavigation\n              setCurrentSegment={this.setCurrentSegment}\n              clearAll={this.clearAll}\n              onSave={this.onSave}\n            />\n            { audioErrorMsg?.[currentVideo] ? (\n              <div className=\"error-container\">\n                {audioErrorMsg?.[currentVideo]}\n              </div>\n            ) : (\n              <>\n                <AudioComp\n                  ref={this.audioRef}\n                  setCurrentSegment={this.setCurrentSegment}\n                />\n                <div className=\"right-component-wrapper\">\n                  <VideoComp />\n                  <SegmentNavigation\n                    setCurrentSegment={this.setCurrentSegment}\n                    ref={(r) => { this.segmentNavigation = r; }}\n                  />\n                </div>\n                <div className=\"left-component-wrapper\">\n                  <GlobalAttributes />\n                  <SegmentAbstract\n                    setCurrentSegment={this.setCurrentSegment}\n                    // eslint-disable-next-line no-return-assign\n                    ref={(r) => this.segmentAbstract = r}\n                  />\n                </div>\n                <SegmentDetail setCurrentSegment={this.setCurrentSegment} />\n                <Validation\n                  ref={this.validator}\n                  jobProxy={this.props.jobProxy}\n                  saveResult={() => this.saveResult()}\n                />\n              </>\n            )}\n          </>\n        ) : null}\n      </LayoutWrapper>\n    );\n  }\n}\n\nVideoAnnotationApp.propTypes = {\n  initPayloadState: PropTypes.func.isRequired,\n  renderComplete: PropTypes.func,\n  jobProxy: PropTypes.object,\n};\n\nconst mapStateToProps = (state) => ({\n  videos: state.videos,\n  currentVideo: state.currentVideo,\n  results: state.results,\n  lastResults: state.lastResults,\n  segmentMode: state.segmentMode,\n  toolMode: state.toolMode,\n  errorMsg: state.errorMsg,\n  audioErrorMsg: state.audioErrorMsg,\n  currentSegment: state.currentSegment,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  keyAttribute: state.keyAttribute,\n  client: state.client,\n  wordTimestampUrls: state.wordTimestampUrls,\n  submitCheck: state.submitCheck,\n  invalidAnnotatable: state.invalidAnnotatable,\n  globalConfig: state.globalConfig,\n  loading: state.loading,\n  validDuration: state.validDuration,\n  minSegmentLength: state.minSegmentLength,\n  state,\n});\nconst mapDispatchToProps = {\n  initPayloadState,\n  setCurrentSegment,\n  setErrorMsg,\n  setWordTimestamps,\n  setVideoLoaded,\n  setLoadReviewEnabled,\n  setResults,\n};\nexport default connect(mapStateToProps, mapDispatchToProps, null, { forwardRef: true })(VideoAnnotationApp);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}