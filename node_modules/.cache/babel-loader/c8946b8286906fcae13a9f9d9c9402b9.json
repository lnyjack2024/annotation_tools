{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport pinyin from 'pinyin-match';\nimport { cloneDeep } from 'lodash';\nimport { FieldControlType, FieldValueType, ConditionType, FieldOperatorType, AggregationOperatorType, OptionType } from '../types';\nexport var isContained = function isContained(value, options) {\n  if (Array.isArray(value)) {\n    for (var index = 0; index < value.length; index += 1) {\n      var valueItem = value[index];\n      if (!isContained(valueItem, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return !!options.find(function (i) {\n    return i.value === value;\n  });\n};\n/**\n * options contained value for nested structures\n * @param values\n * @param options\n */\n\nexport function isContainedForNested(values, options) {\n  if (values === void 0) {\n    values = [];\n  }\n  var result = values.reduce(function (preVal, currVal) {\n    var _preVal$options;\n    if (!preVal.isContained || !preVal.options || preVal.options.length < 1) {\n      return preVal;\n    }\n    var option = (_preVal$options = preVal.options) == null ? void 0 : _preVal$options.find(function (o) {\n      return o.value === currVal;\n    });\n    if (option) {\n      // eslint-disable-next-line no-param-reassign\n      preVal.isContained = true;\n      if (option.children && option.children.length > 0) {\n        // eslint-disable-next-line no-param-reassign\n        preVal.options = option.children;\n      }\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      preVal.isContained = false;\n    }\n    return preVal;\n  }, {\n    options: options,\n    isContained: true\n  });\n  return result.isContained;\n}\nexport function checkValueIsContained(defaultValue, field) {\n  switch (field.type) {\n    case FieldControlType.CASCADER:\n      return Array.isArray(defaultValue) && isContainedForNested(defaultValue, field.options || []);\n    case FieldControlType.CHECKBOX:\n    case FieldControlType.RADIO:\n    case FieldControlType.SELECT:\n      return isContained(defaultValue, field.options || []);\n    default:\n      return true;\n  }\n}\n/**\n * get supported valueType array by field control type\n * @param type field control type\n */\n\nexport function getSupportedValueTypesByControlType(type) {\n  if (type === FieldControlType.SWITCH) {\n    return [FieldValueType.BOOLEAN];\n  }\n  if (type === FieldControlType.TEXTAREA) {\n    return [FieldValueType.STRING];\n  }\n  return [FieldValueType.STRING, FieldValueType.NUMBER];\n}\n/**\n * parse field value by field value type\n * @param value field value\n * @param type field value type\n */\n\nexport function praseValueByValueType(value, type) {\n  var _val;\n  var val = value;\n  if (typeof val === 'string' && val.startsWith('[') && val.endsWith(']')) {\n    // try to parse as an array string, such as [1,2] or [\"A\", \"B\"]\n    try {\n      val = JSON.parse(val);\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log(\"Parse as array string failed. Value is: \" + value);\n    }\n  } // continue\n\n  if (typeof val === 'object' && Array.isArray(val)) {\n    // if default value is an array\n    return val.map(function (v) {\n      return praseValueByValueType(v, type);\n    });\n  }\n  if (type === FieldValueType.BOOLEAN) {\n    if (typeof val === 'boolean') return val;\n    if (typeof val === 'string') return val === 'true';\n    if (typeof val === 'number') return !!val;\n    return false;\n  }\n  if (type === FieldValueType.NUMBER) {\n    var num = parseFloat(val);\n    return Number.isNaN(num) ? undefined : num;\n  }\n  return (_val = val) == null ? void 0 : _val.toString();\n}\n/**\n * parse field option item's value and label\n * parse the option value to right value type if necessary\n * @param options initial field options\n * @param type field value type\n */\n\nexport function parseOptions(options, type) {\n  if (options === void 0) {\n    options = [];\n  }\n  return options.map(function (option) {\n    var value;\n    var label;\n    var group;\n    var disabled;\n    var desc;\n    var referenceUrl;\n    var children;\n    if (typeof option === 'string' || typeof option === 'number' || typeof option === 'boolean') {\n      value = praseValueByValueType(option, type);\n      label = option == null ? void 0 : option.toString();\n    } else {\n      var _ref;\n      value = praseValueByValueType(option.value, type);\n      label = (_ref = option.label || option.value) == null ? void 0 : _ref.toString();\n      if (option.group) {\n        group = option.group.toString();\n      }\n      disabled = option.disabled;\n      desc = option.desc;\n      referenceUrl = option.referenceUrl;\n      children = option.children;\n      if (children && children.length > 0) {\n        children = parseOptions(children, type);\n      }\n    }\n    disabled = disabled === true || disabled === 'true';\n    return {\n      value: value,\n      label: label,\n      group: group,\n      disabled: disabled,\n      desc: desc,\n      referenceUrl: referenceUrl,\n      children: children\n    };\n  });\n}\n/**\n * parse fields including field validation, value parse, option value parse...\n * @param initialFields\n */\n\nexport function parseFormFields(initialFields) {\n  var fields = [];\n  var initialValues = {};\n  initialFields.forEach(function (field) {\n    if (field.name !== undefined && field.type !== undefined && Object.values(FieldControlType).includes(field.type)) {\n      var supportedValueTypes = getSupportedValueTypesByControlType(field.type);\n      var valueType = supportedValueTypes[0];\n      if (field.valueType !== undefined && supportedValueTypes.includes(field.valueType)) {\n        // if valueType provided and is right\n        valueType = field.valueType;\n      } else if (field.valueType === undefined) {\n        // if valueType not provided, try to get valueType form defaultValue or options\n        var item;\n        if (field.options !== undefined && field.options.length > 0) {\n          item = typeof field.options[0] === 'object' ? field.options[0].value : field.options[0];\n        } else if (field.defaultValue !== undefined) {\n          item = field.defaultValue;\n        }\n        if (item !== undefined) {\n          var optionValueType = typeof item;\n          if (supportedValueTypes.includes(optionValueType)) {\n            valueType = optionValueType;\n          }\n        }\n      }\n      var newField = {\n        name: field.name,\n        label: field.label || field.name,\n        type: field.type,\n        valueType: valueType,\n        visible: field.visible !== undefined ? !!field.visible : true,\n        required: field.required !== undefined ? !!field.required : false,\n        mode: field.mode,\n        clickStopPropagation: field == null ? void 0 : field.clickStopPropagation,\n        // FIXME: if field is readonly with required and empty defaultValue\n        readonly: field.readonly !== undefined ? !!field.readonly : false,\n        isRTL: field.isRTL,\n        optionType: field.optionType || OptionType.DEFAULT,\n        validator: field.validator\n      };\n      if (field.options !== undefined && Array.isArray(field.options) && field.options.length > 0) {\n        newField.options = parseOptions(field.options, valueType);\n        newField.optionSearchable = field.optionSearchable !== undefined ? !!field.optionSearchable : false;\n        newField.optionFoldable = field.optionFoldable !== undefined ? !!field.optionFoldable : false;\n      }\n      var defaultValue = praseValueByValueType(field.defaultValue, valueType);\n      if (defaultValue !== undefined) {\n        var isContain = checkValueIsContained(defaultValue, newField);\n        if (isContain) {\n          newField.defaultValue = defaultValue;\n          initialValues[field.name] = defaultValue;\n        }\n      }\n      fields.push(newField);\n    }\n  });\n  return {\n    fields: fields,\n    initialValues: initialValues\n  };\n}\n/**\n * get all related fields from condition\n * @param condition the condition should be parsed\n * @param conditions all conditions\n */\n\nexport function getFieldsFromCondition(condition, allConditions) {\n  var fields = [];\n  if (condition.type === ConditionType.AGGREGATION && condition.conditions !== undefined && Array.isArray(condition.conditions) && condition.conditions.length > 0) {\n    fields = condition.conditions.reduce(function (acc, cid) {\n      var currCondition = allConditions.find(function (c) {\n        return c.id === cid;\n      });\n      return acc.concat(currCondition ? getFieldsFromCondition(currCondition, allConditions) : []);\n    }, []);\n  } else if (condition.type === ConditionType.FIELD && condition.field !== undefined) {\n    fields.push(condition.field);\n  }\n  return fields;\n}\n/**\n * compare value and condition value and check is pass the condition\n * @param value origin value, user input\n * @param conditionValue condition defined value\n * @param operator field condtion operator\n */\n\nexport function isValuePassCondition(checkValue, conditionValue, operator) {\n  var cValue = conditionValue;\n  if (typeof conditionValue !== 'string') {\n    cValue = conditionValue.toString();\n  } else if (operator !== FieldOperatorType.START && operator !== FieldOperatorType.END) {\n    cValue = conditionValue.split(',').sort().toString();\n  }\n  var value = checkValue;\n  if (Array.isArray(checkValue) && operator !== FieldOperatorType.START && operator !== FieldOperatorType.END) {\n    value = cloneDeep(checkValue).sort();\n  }\n  switch (operator) {\n    case FieldOperatorType.EQUAL:\n      return value.toString() === cValue;\n    case FieldOperatorType.NOT_EQUAL:\n      return value.toString() !== cValue;\n    case FieldOperatorType.GREATER:\n      {\n        var conditionNum = parseFloat(cValue);\n        return Number.isNaN(conditionNum) ? false : value > conditionNum;\n      }\n    case FieldOperatorType.GREATER_EQUAL:\n      {\n        var _conditionNum = parseFloat(cValue);\n        return Number.isNaN(_conditionNum) ? false : value >= _conditionNum;\n      }\n    case FieldOperatorType.LESS:\n      {\n        var _conditionNum2 = parseFloat(cValue);\n        return Number.isNaN(_conditionNum2) ? false : value < _conditionNum2;\n      }\n    case FieldOperatorType.LESS_EQUAL:\n      {\n        var _conditionNum3 = parseFloat(cValue);\n        return Number.isNaN(_conditionNum3) ? false : value <= _conditionNum3;\n      }\n    case FieldOperatorType.CONTAINS:\n      if (typeof value === 'object' && Array.isArray(value)) {\n        return value.some(function (v) {\n          return v.toString() === cValue;\n        });\n      }\n      return value.toString().includes(cValue);\n    case FieldOperatorType.START:\n      if (typeof value === 'object' && Array.isArray(value)) {\n        var _value$;\n        return ((_value$ = value[0]) == null ? void 0 : _value$.toString()) === cValue;\n      }\n      return value.toString().startsWith(cValue);\n    case FieldOperatorType.END:\n      if (typeof value === 'object' && Array.isArray(value)) {\n        var _value;\n        return ((_value = value[value.length - 1]) == null ? void 0 : _value.toString()) === cValue;\n      }\n      return value.toString().endsWith(cValue);\n    default:\n      return false;\n  }\n}\n/**\n * check whether values pass the condition\n * @param condition check condition\n * @param allConditions all conditions, used to find any nest condition\n * @param allValues all values, used to check the field value in any condition\n */\n\nexport function checkCondition(condition, allConditions, allValues) {\n  if (condition.type === ConditionType.AGGREGATION && condition.conditions !== undefined && Array.isArray(condition.conditions) && condition.conditions.length > 0) {\n    var passRes = condition.conditions.map(function (cid) {\n      var currCondition = allConditions.find(function (c) {\n        return c.id === cid;\n      });\n      return currCondition ? checkCondition(currCondition, allConditions, allValues) : false;\n    });\n    var operator = condition.operator;\n    if (operator === AggregationOperatorType.AND) {\n      return passRes.every(function (i) {\n        return i;\n      });\n    }\n    if (operator === AggregationOperatorType.OR) {\n      return passRes.some(function (i) {\n        return i;\n      });\n    }\n  } else if (condition.type === ConditionType.FIELD && condition.field !== undefined && allValues[condition.field] !== undefined) {\n    return isValuePassCondition(allValues[condition.field], condition.value, condition.operator);\n  }\n  return false;\n}\n/**\n * calc col span value for options based on the container\n * @param containerWidth\n * @param avgOptionLength\n */\n\nexport function getColSpanForOptions(containerWidth, options) {\n  // eslint-disable-next-line no-control-regex\n  var optionLengths = options.map(function (o) {\n    return (o.label || o.value).toString().replace(/[^\\x00-\\xff]/g, '01').length;\n  });\n  optionLengths.sort(function (a, b) {\n    return a - b;\n  });\n  var avgLength = optionLengths[Math.floor(optionLengths.length * 0.75)]; // use 75% length\n\n  var colSpans = [1, 2, 3, 4, 6, 8, 12, 24];\n  var cols = containerWidth / ((avgLength + 12) / 2 * 14);\n  if (options.length < cols) {\n    cols = options.length;\n  }\n  var span = colSpans[0];\n  for (var i = 1; i < colSpans.length; i += 1) {\n    if (colSpans[i] > cols) {\n      span = colSpans[colSpans.length - i];\n      break;\n    }\n  }\n  return span;\n}\n/**\n * check if the target pass the filter rule\n * @param target target string\n * @param filter filter key\n */\n\nexport function textFilter(target, filter) {\n  if (target === void 0) {\n    target = '';\n  }\n  if (filter === void 0) {\n    filter = '';\n  }\n  if (!filter) {\n    // no filter key\n    return true;\n  }\n  if (pinyin.match(target, filter) !== false) {\n    // match chinese character\n    return true;\n  }\n  var splits = target.split(' ').map(function (i) {\n    return i[0].toUpperCase();\n  }).join('');\n  if (splits.indexOf(filter.toUpperCase()) >= 0) {\n    // match english initials\n    return true;\n  }\n  return target.toUpperCase().indexOf(filter.toUpperCase()) >= 0;\n}\n/**\n * trigger a rule\n * @param rule\n * @param allFields all fields\n * @param allValues all values\n * @param initialFields initial fields for default value\n * @param conditions all conditions\n * @param effects all effects\n * @returns { updatedFields, updatedValues } all updated fields and values\n */\n\nexport function ruleTrigger(rule, allFields, allValues, initialFields, conditions, effects) {\n  var ruleCondition = conditions.find(function (c) {\n    return c.id === rule.condition;\n  });\n  var ruleEffects = effects.filter(function (e) {\n    return rule.effects.includes(e.id);\n  });\n  var updatedFields = [].concat(allFields);\n  var updatedValues = _extends({}, allValues);\n  if (ruleCondition) {\n    // check if the values pass the condition\n    var passed = checkCondition(ruleCondition, conditions, allValues);\n    ruleEffects.forEach(function (effect) {\n      var index = updatedFields.findIndex(function (f) {\n        return f.name === effect.field;\n      });\n      if (index >= 0 && effect.attribute !== undefined) {\n        if (effect.attribute === 'value') {\n          // if passed, use effect's value\n          if (passed) {\n            var fieldValue = effect.value;\n            var fieldParsedValue = praseValueByValueType(fieldValue, updatedFields[index].valueType);\n            if (fieldParsedValue) {\n              updatedValues[updatedFields[index].name] = fieldParsedValue;\n            }\n          }\n        } else {\n          // visible, required, readonly\n          // if passed, use effect's value, otherwise, use initial setting\n          var bool = effect.value.toString() === 'true';\n          if (!passed) {\n            bool = initialFields[index][effect.attribute] !== undefined ? !!initialFields[index][effect.attribute] : effect.attribute === 'visible';\n          }\n          updatedFields[index][effect.attribute] = bool;\n          if (bool && effect.attribute === 'visible') {\n            updatedValues[updatedFields[index].name] = bool ? praseValueByValueType(initialFields[index].defaultValue, updatedFields[index].valueType) : undefined;\n          }\n        }\n      }\n    });\n  }\n  return {\n    updatedFields: updatedFields,\n    updatedValues: updatedValues\n  };\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function validate(config, values, checkExtra) {\n  if (checkExtra === void 0) {\n    checkExtra = {\n      check: false\n    };\n  }\n  var configFields = config.fields,\n    _config$conditions = config.conditions,\n    conditions = _config$conditions === void 0 ? [] : _config$conditions,\n    _config$effects = config.effects,\n    effects = _config$effects === void 0 ? [] : _config$effects,\n    _config$rules = config.rules,\n    rules = _config$rules === void 0 ? [] : _config$rules;\n  var fields = (configFields || []).map(function (field) {\n    return _extends({}, field, values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    });\n  });\n  var parsedValue = parseFormFields(fields); // trigger rule effects\n\n  var _rules$reduce = rules.reduce(function (acc, curr) {\n      return ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects);\n    }, {\n      updatedFields: parsedValue.fields,\n      updatedValues: parsedValue.initialValues\n    }),\n    updatedFields = _rules$reduce.updatedFields;\n  var displayFields = updatedFields.filter(function (i) {\n    return i.visible;\n  });\n  for (var i = 0; i < displayFields.length; i += 1) {\n    var field = displayFields[i];\n    var value = values[field.name];\n    if (field.required && (value === undefined || value === null || value === '')) {\n      return false;\n    }\n    if (field.validator) {\n      var result = field.validator(value);\n      if (result === false || (result == null ? void 0 : result.pass) === false) {\n        return false;\n      }\n    }\n  }\n  if (checkExtra.check) {\n    var ignoreFieldsSet = new Set(checkExtra.ignoreFields || []);\n    if (Object.keys(values).filter(function (field) {\n      return !ignoreFieldsSet.has(field);\n    }).some(function (field) {\n      return !displayFields.find(function (i) {\n        return i.name === field;\n      });\n    })) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function parseDisplayValues(formConfig, values, reservedFields) {\n  var configFields = formConfig.fields,\n    _formConfig$condition = formConfig.conditions,\n    conditions = _formConfig$condition === void 0 ? [] : _formConfig$condition,\n    _formConfig$effects = formConfig.effects,\n    effects = _formConfig$effects === void 0 ? [] : _formConfig$effects,\n    _formConfig$rules = formConfig.rules,\n    rules = _formConfig$rules === void 0 ? [] : _formConfig$rules;\n  var fieldsWithValue = (configFields || []).map(function (field) {\n    return _extends({}, field, values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    });\n  });\n  var parsedValue = parseFormFields(fieldsWithValue); // trigger rule effects\n\n  var _rules$reduce2 = rules.reduce(function (acc, curr) {\n      return ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fieldsWithValue, conditions, effects);\n    }, {\n      updatedFields: parsedValue.fields,\n      updatedValues: parsedValue.initialValues\n    }),\n    fields = _rules$reduce2.updatedFields;\n  var displayValues = {};\n  reservedFields == null ? void 0 : reservedFields.forEach(function (key) {\n    displayValues[key] = values[key];\n  });\n  fields.filter(function (i) {\n    return i.visible;\n  }).forEach(function (_ref2) {\n    var name = _ref2.name;\n    displayValues[name] = values[name];\n  });\n  return displayValues;\n}\nexport default {\n  getSupportedValueTypesByControlType: getSupportedValueTypesByControlType,\n  praseValueByValueType: praseValueByValueType,\n  parseOptions: parseOptions,\n  parseFormFields: parseFormFields,\n  getFieldsFromCondition: getFieldsFromCondition,\n  isValuePassCondition: isValuePassCondition,\n  checkCondition: checkCondition,\n  getColSpanForOptions: getColSpanForOptions,\n  textFilter: textFilter,\n  ruleTrigger: ruleTrigger,\n  validate: validate,\n  parseDisplayValues: parseDisplayValues\n};","map":{"version":3,"sources":["../../src/utils/index.ts"],"names":["pinyin","cloneDeep","FieldControlType","FieldValueType","ConditionType","FieldOperatorType","AggregationOperatorType","OptionType","isContained","value","options","Array","isArray","index","length","valueItem","find","i","isContainedForNested","values","result","reduce","preVal","currVal","option","o","children","checkValueIsContained","defaultValue","field","type","CASCADER","CHECKBOX","RADIO","SELECT","getSupportedValueTypesByControlType","SWITCH","BOOLEAN","TEXTAREA","STRING","NUMBER","praseValueByValueType","val","startsWith","endsWith","JSON","parse","e","console","log","map","v","num","parseFloat","Number","isNaN","undefined","toString","parseOptions","label","group","disabled","desc","referenceUrl","parseFormFields","initialFields","fields","initialValues","forEach","name","Object","includes","supportedValueTypes","valueType","item","optionValueType","newField","visible","required","mode","clickStopPropagation","readonly","isRTL","optionType","DEFAULT","validator","optionSearchable","optionFoldable","isContain","push","getFieldsFromCondition","condition","allConditions","AGGREGATION","conditions","acc","cid","currCondition","c","id","concat","FIELD","isValuePassCondition","checkValue","conditionValue","operator","cValue","START","END","split","sort","EQUAL","NOT_EQUAL","GREATER","conditionNum","GREATER_EQUAL","LESS","LESS_EQUAL","CONTAINS","some","checkCondition","allValues","passRes","AND","every","OR","getColSpanForOptions","containerWidth","optionLengths","replace","a","b","avgLength","Math","floor","colSpans","cols","span","textFilter","target","filter","match","splits","toUpperCase","join","indexOf","ruleTrigger","rule","allFields","effects","ruleCondition","ruleEffects","updatedFields","updatedValues","passed","effect","findIndex","f","attribute","fieldValue","fieldParsedValue","bool","validate","config","checkExtra","check","configFields","rules","parsedValue","curr","displayFields","pass","ignoreFieldsSet","Set","ignoreFields","keys","has","parseDisplayValues","formConfig","reservedFields","fieldsWithValue","displayValues","key"],"mappings":"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","sourcesContent":["import pinyin from 'pinyin-match';\nimport { cloneDeep } from 'lodash';\nimport {\n  Field,\n  FieldValue,\n  FieldControlType,\n  FieldValueType,\n  FieldOption,\n  InFieldOption,\n  Condition,\n  ConditionType,\n  FieldOperatorType,\n  AggregationOperatorType,\n  OptionType,\n  FormConfig,\n  Rule,\n  Effect,\n} from '../types';\n\nexport const isContained = (value: any | any[], options: FieldOption[]) => {\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const valueItem = value[index];\n      if (!isContained(valueItem, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return !!options.find((i) => i.value === value);\n};\n\n/**\n * options contained value for nested structures\n * @param values\n * @param options\n */\nexport function isContainedForNested(values: FieldValue[] = [], options: FieldOption[]): boolean {\n  const result = values.reduce((preVal: { options: FieldOption[]; isContained: boolean}, currVal: FieldValue) => {\n    if (!preVal.isContained || !preVal.options || preVal.options.length < 1) {\n      return preVal;\n    }\n    const option = preVal.options?.find((o) => o.value === currVal);\n    if (option) {\n      // eslint-disable-next-line no-param-reassign\n      preVal.isContained = true;\n      if (option.children && option.children.length > 0) {\n        // eslint-disable-next-line no-param-reassign\n        preVal.options = option.children;\n      }\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      preVal.isContained = false;\n    }\n    return preVal;\n  }, { options, isContained: true });\n  return result.isContained;\n}\n\nexport function checkValueIsContained(defaultValue: FieldValue | FieldValue[], field: Field) {\n  switch (field.type) {\n    case FieldControlType.CASCADER:\n      return Array.isArray(defaultValue) && isContainedForNested(defaultValue, field.options || []);\n    case FieldControlType.CHECKBOX:\n    case FieldControlType.RADIO:\n    case FieldControlType.SELECT:\n      return isContained(defaultValue, field.options || []);\n    default:\n      return true;\n  }\n}\n\n/**\n * get supported valueType array by field control type\n * @param type field control type\n */\nexport function getSupportedValueTypesByControlType(type: FieldControlType): FieldValueType[] {\n  if (type === FieldControlType.SWITCH) {\n    return [FieldValueType.BOOLEAN];\n  }\n\n  if (type === FieldControlType.TEXTAREA) {\n    return [FieldValueType.STRING];\n  }\n\n  return [FieldValueType.STRING, FieldValueType.NUMBER];\n}\n\n/**\n * parse field value by field value type\n * @param value field value\n * @param type field value type\n */\nexport function praseValueByValueType(\n  value: undefined | FieldValue | FieldValue[],\n  type: FieldValueType,\n): undefined | FieldValue | FieldValue[] {\n  let val = value;\n  if (typeof val === 'string' && val.startsWith('[') && val.endsWith(']')) {\n    // try to parse as an array string, such as [1,2] or [\"A\", \"B\"]\n    try {\n      val = JSON.parse(val);\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log(`Parse as array string failed. Value is: ${value}`);\n    }\n  }\n\n  // continue\n  if (typeof val === 'object' && Array.isArray(val)) {\n    // if default value is an array\n    return val.map((v) => praseValueByValueType(v, type) as FieldValue);\n  }\n\n  if (type === FieldValueType.BOOLEAN) {\n    if (typeof val === 'boolean') return val;\n    if (typeof val === 'string') return val === 'true';\n    if (typeof val === 'number') return !!val;\n    return false;\n  }\n\n  if (type === FieldValueType.NUMBER) {\n    const num = parseFloat(val as string);\n    return Number.isNaN(num) ? undefined : num;\n  }\n\n  return val?.toString();\n}\n\n/**\n * parse field option item's value and label\n * parse the option value to right value type if necessary\n * @param options initial field options\n * @param type field value type\n */\nexport function parseOptions(\n  options: (FieldValue | InFieldOption)[] = [],\n  type: FieldValueType,\n): FieldOption[] {\n  return options.map((option) => {\n    let value;\n    let label;\n    let group;\n    let disabled;\n    let desc;\n    let referenceUrl;\n    let children;\n\n    if (typeof option === 'string' || typeof option === 'number' || typeof option === 'boolean') {\n      value = praseValueByValueType(option, type);\n      label = option?.toString();\n    } else {\n      value = praseValueByValueType(option.value, type);\n      label = (option.label || option.value)?.toString();\n      if (option.group) {\n        group = option.group.toString();\n      }\n      ({ disabled, desc, referenceUrl, children } = option);\n      if (children && children.length > 0) {\n        children = parseOptions(children, type);\n      }\n    }\n    disabled = disabled === true || disabled === 'true';\n\n    return { value, label, group, disabled, desc, referenceUrl, children } as FieldOption;\n  });\n}\n\n/**\n * parse fields including field validation, value parse, option value parse...\n * @param initialFields\n */\nexport function parseFormFields(\n  initialFields: Field[],\n): { fields: Field[]; initialValues: { [key: string]: FieldValue | FieldValue[] } } {\n  const fields: Field[] = [];\n  const initialValues: { [key: string]: FieldValue | FieldValue[] } = {};\n\n  initialFields.forEach((field) => {\n    if (\n      field.name !== undefined &&\n      field.type !== undefined &&\n      Object.values(FieldControlType).includes(field.type)\n    ) {\n      const supportedValueTypes = getSupportedValueTypesByControlType(field.type);\n      let valueType = supportedValueTypes[0];\n      if (field.valueType !== undefined && supportedValueTypes.includes(field.valueType)) {\n        // if valueType provided and is right\n        ({ valueType } = field);\n      } else if (field.valueType === undefined) {\n        // if valueType not provided, try to get valueType form defaultValue or options\n        let item;\n        if (field.options !== undefined && field.options.length > 0) {\n          item = typeof field.options[0] === 'object' ? field.options[0].value : field.options[0];\n        } else if (field.defaultValue !== undefined) {\n          item = field.defaultValue;\n        }\n\n        if (item !== undefined) {\n          const optionValueType = typeof item as FieldValueType;\n          if (supportedValueTypes.includes(optionValueType)) {\n            valueType = optionValueType;\n          }\n        }\n      }\n      const newField: Field = {\n        name: field.name,\n        label: field.label || field.name,\n        type: field.type,\n        valueType,\n        visible: field.visible !== undefined ? !!field.visible : true,\n        required: field.required !== undefined ? !!field.required : false,\n        mode: field.mode,\n        clickStopPropagation: field?.clickStopPropagation,\n        // FIXME: if field is readonly with required and empty defaultValue\n        readonly: field.readonly !== undefined ? !!field.readonly : false,\n        isRTL: field.isRTL,\n        optionType: field.optionType || OptionType.DEFAULT,\n        validator: field.validator,\n      };\n\n      if (field.options !== undefined && Array.isArray(field.options) && field.options.length > 0) {\n        newField.options = parseOptions(field.options, valueType);\n        newField.optionSearchable = field.optionSearchable !== undefined ? !!field.optionSearchable : false;\n        newField.optionFoldable = field.optionFoldable !== undefined ? !!field.optionFoldable : false;\n      }\n\n      const defaultValue = praseValueByValueType(field.defaultValue, valueType);\n      if (defaultValue !== undefined) {\n        const isContain = checkValueIsContained(defaultValue, newField);\n        if (isContain) {\n          newField.defaultValue = defaultValue;\n          initialValues[field.name] = defaultValue;\n        }\n      }\n\n      fields.push(newField);\n    }\n  });\n\n  return { fields, initialValues };\n}\n\n/**\n * get all related fields from condition\n * @param condition the condition should be parsed\n * @param conditions all conditions\n */\nexport function getFieldsFromCondition(condition: Condition, allConditions: Condition[]): string[] {\n  let fields: string[] = [];\n  if (\n    condition.type === ConditionType.AGGREGATION &&\n    condition.conditions !== undefined &&\n    Array.isArray(condition.conditions) &&\n    condition.conditions.length > 0\n  ) {\n    fields = condition.conditions.reduce((acc, cid) => {\n      const currCondition = allConditions.find((c) => c.id === cid);\n      return acc.concat(currCondition ? getFieldsFromCondition(currCondition, allConditions) : []);\n    }, [] as string[]);\n  } else if (\n    condition.type === ConditionType.FIELD &&\n    condition.field !== undefined\n  ) {\n    fields.push(condition.field);\n  }\n  return fields;\n}\n\n/**\n * compare value and condition value and check is pass the condition\n * @param value origin value, user input\n * @param conditionValue condition defined value\n * @param operator field condtion operator\n */\nexport function isValuePassCondition(\n  checkValue: FieldValue | FieldValue[],\n  conditionValue: string,\n  operator: FieldOperatorType,\n): boolean {\n  let cValue = conditionValue;\n  if (typeof conditionValue !== 'string') {\n    cValue = (conditionValue as (number | boolean | object)).toString();\n  } else if (operator !== FieldOperatorType.START && operator !== FieldOperatorType.END) {\n    cValue = conditionValue.split(',').sort().toString();\n  }\n  let value = checkValue;\n  if (\n    Array.isArray(checkValue) &&\n    operator !== FieldOperatorType.START &&\n    operator !== FieldOperatorType.END\n  ) {\n    value = cloneDeep(checkValue).sort();\n  }\n  switch (operator) {\n    case FieldOperatorType.EQUAL:\n      return value.toString() === cValue;\n\n    case FieldOperatorType.NOT_EQUAL:\n      return value.toString() !== cValue;\n\n    case FieldOperatorType.GREATER: {\n      const conditionNum = parseFloat(cValue);\n      return Number.isNaN(conditionNum) ? false : value > conditionNum;\n    }\n\n    case FieldOperatorType.GREATER_EQUAL: {\n      const conditionNum = parseFloat(cValue);\n      return Number.isNaN(conditionNum) ? false : value >= conditionNum;\n    }\n\n    case FieldOperatorType.LESS: {\n      const conditionNum = parseFloat(cValue);\n      return Number.isNaN(conditionNum) ? false : value < conditionNum;\n    }\n\n    case FieldOperatorType.LESS_EQUAL: {\n      const conditionNum = parseFloat(cValue);\n      return Number.isNaN(conditionNum) ? false : value <= conditionNum;\n    }\n\n    case FieldOperatorType.CONTAINS:\n      if (typeof value === 'object' && Array.isArray(value)) {\n        return value.some((v) => v.toString() === cValue);\n      }\n      return value.toString().includes(cValue);\n\n    case FieldOperatorType.START:\n      if (typeof value === 'object' && Array.isArray(value)) {\n        return value[0]?.toString() === cValue;\n      }\n      return value.toString().startsWith(cValue);\n\n    case FieldOperatorType.END:\n      if (typeof value === 'object' && Array.isArray(value)) {\n        return value[value.length - 1]?.toString() === cValue;\n      }\n      return value.toString().endsWith(cValue);\n\n    default:\n      return false;\n  }\n}\n\n/**\n * check whether values pass the condition\n * @param condition check condition\n * @param allConditions all conditions, used to find any nest condition\n * @param allValues all values, used to check the field value in any condition\n */\nexport function checkCondition(\n  condition: Condition,\n  allConditions: Condition[],\n  allValues: { [key: string]: FieldValue | FieldValue[] },\n): boolean {\n  if (\n    condition.type === ConditionType.AGGREGATION &&\n    condition.conditions !== undefined &&\n    Array.isArray(condition.conditions) &&\n    condition.conditions.length > 0\n  ) {\n    const passRes: boolean[] = condition.conditions.map((cid) => {\n      const currCondition = allConditions.find((c) => c.id === cid);\n      return currCondition ? checkCondition(currCondition, allConditions, allValues) : false;\n    });\n    const operator = condition.operator as AggregationOperatorType;\n    if (operator === AggregationOperatorType.AND) {\n      return passRes.every((i) => i);\n    }\n    if (operator === AggregationOperatorType.OR) {\n      return passRes.some((i) => i);\n    }\n  } else if (\n    condition.type === ConditionType.FIELD &&\n    condition.field !== undefined &&\n    allValues[condition.field] !== undefined\n  ) {\n    return isValuePassCondition(\n      allValues[condition.field],\n      condition.value as string,\n      condition.operator as FieldOperatorType,\n    );\n  }\n  return false;\n}\n\n/**\n * calc col span value for options based on the container\n * @param containerWidth\n * @param avgOptionLength\n */\nexport function getColSpanForOptions(containerWidth: number, options: FieldOption[]) {\n  // eslint-disable-next-line no-control-regex\n  const optionLengths = options.map((o) => (o.label || o.value).toString().replace(/[^\\x00-\\xff]/g, '01').length);\n  optionLengths.sort((a, b) => a - b);\n  const avgLength = optionLengths[Math.floor(optionLengths.length * 0.75)]; // use 75% length\n\n  const colSpans = [1, 2, 3, 4, 6, 8, 12, 24];\n  let cols = containerWidth / (((avgLength + 12) / 2) * 14);\n  if (options.length < cols) {\n    cols = options.length;\n  }\n\n  let span = colSpans[0];\n  for (let i = 1; i < colSpans.length; i += 1) {\n    if (colSpans[i] > cols) {\n      span = colSpans[colSpans.length - i];\n      break;\n    }\n  }\n  return span;\n}\n\n/**\n * check if the target pass the filter rule\n * @param target target string\n * @param filter filter key\n */\nexport function textFilter(target = '', filter = '') {\n  if (!filter) {\n    // no filter key\n    return true;\n  }\n  if (pinyin.match(target, filter) !== false) {\n    // match chinese character\n    return true;\n  }\n  const splits = target.split(' ').map((i) => i[0].toUpperCase()).join('');\n  if (splits.indexOf(filter.toUpperCase()) >= 0) {\n    // match english initials\n    return true;\n  }\n  return target.toUpperCase().indexOf(filter.toUpperCase()) >= 0;\n}\n\n/**\n * trigger a rule\n * @param rule\n * @param allFields all fields\n * @param allValues all values\n * @param initialFields initial fields for default value\n * @param conditions all conditions\n * @param effects all effects\n * @returns { updatedFields, updatedValues } all updated fields and values\n */\nexport function ruleTrigger(\n  rule: Rule,\n  allFields: Field[],\n  allValues: { [key: string]: FieldValue | FieldValue[] },\n  initialFields: Field[],\n  conditions?: Condition[],\n  effects?: Effect[],\n) {\n  const ruleCondition = conditions.find((c) => c.id === rule.condition);\n  const ruleEffects = effects.filter((e) => rule.effects.includes(e.id));\n\n  const updatedFields = [...allFields];\n  const updatedValues = { ...allValues };\n\n  if (ruleCondition) {\n    // check if the values pass the condition\n    const passed = checkCondition(ruleCondition, conditions, allValues);\n\n    ruleEffects.forEach((effect) => {\n      const index = updatedFields.findIndex((f) => f.name === effect.field);\n      if (index >= 0 && effect.attribute !== undefined) {\n        if (effect.attribute === 'value') {\n          // if passed, use effect's value\n          if (passed) {\n            const fieldValue = effect.value;\n            const fieldParsedValue = praseValueByValueType(\n              fieldValue,\n              updatedFields[index].valueType,\n            );\n            if (fieldParsedValue) {\n              updatedValues[updatedFields[index].name] = fieldParsedValue;\n            }\n          }\n        } else {\n          // visible, required, readonly\n          // if passed, use effect's value, otherwise, use initial setting\n          let bool = effect.value.toString() === 'true';\n          if (!passed) {\n            bool = initialFields[index][effect.attribute] !== undefined ? !!initialFields[index][effect.attribute] : effect.attribute === 'visible';\n          }\n          updatedFields[index][effect.attribute] = bool;\n          if (bool && effect.attribute === 'visible') {\n            updatedValues[updatedFields[index].name] = bool\n              ? praseValueByValueType(\n                initialFields[index].defaultValue, updatedFields[index].valueType,\n              )\n              : undefined;\n          }\n        }\n      }\n    });\n  }\n\n  return { updatedFields, updatedValues };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function validate(config: FormConfig, values: any, checkExtra: {\n  check: boolean;\n  ignoreFields?: string[];\n} = {\n  check: false,\n}): boolean {\n  const { fields: configFields, conditions = [], effects = [], rules = [] } = config;\n  const fields = (configFields || []).map((field) => ({\n    ...field,\n    ...values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n\n  const parsedValue = parseFormFields(fields);\n  // trigger rule effects\n  const { updatedFields } = rules.reduce(\n    (acc, curr) => ruleTrigger(\n      curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects,\n    ),\n    { updatedFields: parsedValue.fields, updatedValues: parsedValue.initialValues },\n  );\n\n  const displayFields = updatedFields.filter((i) => i.visible);\n\n  for (let i = 0; i < displayFields.length; i += 1) {\n    const field = displayFields[i];\n    const value = values[field.name];\n    if (field.required && (value === undefined || value === null || value === '')) {\n      return false;\n    }\n    if (field.validator) {\n      const result = field.validator(value);\n      if (result === false || ((result as { pass: boolean })?.pass === false)) {\n        return false;\n      }\n    }\n  }\n  if (checkExtra.check) {\n    const ignoreFieldsSet = new Set(checkExtra.ignoreFields || []);\n    if (\n      Object.keys(values)\n        .filter((field) => !ignoreFieldsSet.has(field))\n        .some((field) => !displayFields.find((i) => i.name === field))\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function parseDisplayValues(\n  formConfig: FormConfig,\n  values: any,\n  reservedFields?: string[],\n) {\n  const { fields: configFields, conditions = [], effects = [], rules = [] } = formConfig;\n  const fieldsWithValue = (configFields || []).map((field) => ({\n    ...field,\n    ...values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n\n  const parsedValue = parseFormFields(fieldsWithValue);\n  // trigger rule effects\n  const { updatedFields: fields } = rules.reduce(\n    (acc, curr) => ruleTrigger(\n      curr, acc.updatedFields, acc.updatedValues, fieldsWithValue, conditions, effects,\n    ),\n    { updatedFields: parsedValue.fields, updatedValues: parsedValue.initialValues },\n  );\n\n  const displayValues: { [key: string]: any } = {};\n  reservedFields?.forEach((key) => {\n    displayValues[key] = values[key];\n  });\n\n  fields.filter((i) => i.visible).forEach(({ name }) => {\n    displayValues[name] = values[name];\n  });\n\n  return displayValues;\n}\n\nexport default {\n  getSupportedValueTypesByControlType,\n  praseValueByValueType,\n  parseOptions,\n  parseFormFields,\n  getFieldsFromCondition,\n  isValuePassCondition,\n  checkCondition,\n  getColSpanForOptions,\n  textFilter,\n  ruleTrigger,\n  validate,\n  parseDisplayValues,\n};\n"]},"metadata":{},"sourceType":"module"}