{"ast":null,"code":"import Paper from 'paper';\nimport screenfull from 'screenfull';\nimport { v4 as uuid } from 'uuid';\nimport { message } from 'antd';\nimport { SHAPE_TYPE } from '../components/Canvas';\nimport { CategoryPathShape, LandmarkEditType, ReviewResult, HandleType } from '../types';\nimport { isInput } from '../../../utils';\nimport formatMessage from '../locales';\nimport rootStore from '../store/RootStore';\nexport default class Tool extends Paper.Tool {\n  constructor(editor) {\n    super();\n    this.editor = void 0;\n    this.downPoint = null;\n    this.downCenter = null;\n    this.mouseDown = false;\n    this.dragging = false;\n    this.lastClick = -1;\n    this.movingPaths = [];\n    this.movingShapes = [];\n    this.dragType = '';\n    this.movingSegments = [];\n    this.movingHandles = undefined;\n    this.affectedCategories = [];\n    this.selectPath = null;\n    this.minArea = 3;\n    this.isRightButton = event => event.event.which === 3 || event.modifiers.space;\n    this.isCtrlKey = event => event.event.ctrlKey;\n    this.onMouseDown = event => {\n      if (this.isRightButton(event)) {\n        this.downPoint = Paper.view.projectToView(event.point);\n        this.downCenter = Paper.view.center;\n        return;\n      }\n      if (this.editor) {\n        this.mouseDown = true;\n        const currentClick = Date.now();\n        const interval = currentClick - this.lastClick;\n        this.lastClick = currentClick;\n        if (interval < 300) {\n          var _this$editor$warningB;\n          // db click\n          if ((_this$editor$warningB = this.editor.warningBtn) === null || _this$editor$warningB === void 0 ? void 0 : _this$editor$warningB.item) {\n            const {\n              instanceId,\n              groupName,\n              shapeIds,\n              id\n            } = this.editor.warningBtn.item.data || {};\n            if (instanceId && groupName && shapeIds !== undefined) {\n              rootStore.review.setSelectedReview({\n                frameIndex: this.editor.props.currentFrame,\n                instanceId,\n                groupName,\n                shapeIds,\n                result: ReviewResult.REJECT\n              });\n            } else if (id) {\n              const review = rootStore.review.missingReviews.find(r => r.id === id);\n              rootStore.review.setSelectedMissingReview(review, true);\n            }\n          }\n          return;\n        }\n        if (rootStore.review.isEnabled && !rootStore.review.drawMode && rootStore.review.selectedMissingReview && rootStore.review.selectedMissingReview.data === undefined) {\n          // create missing dot when mouse up\n          return;\n        }\n        const {\n          type: hitsType\n        } = this.editor.hits || {};\n        if (!this.isCtrlKey(event) && this.editor.hits && this.editor.hits.item.data.type !== SHAPE_TYPE.KEYPOINT_BOX) {\n          const {\n            instanceId: selectedInstanceId,\n            groupName: selectedGroupName,\n            index,\n            id\n          } = this.editor.hits.item.data;\n          // move start\n          if (this.editor.selectedPoints.length > 0 && this.editor.isShapeInSelectedShapes(selectedInstanceId, selectedGroupName, index)) {\n            // multi points\n            this.movingShapes = this.editor.selectedPoints;\n          } else if (this.editor.selectedRectangles.length > 0 && this.editor.isShapeInSelectedShapes(selectedInstanceId, selectedGroupName, id)) {\n            // multi rectangles\n            this.movingShapes = this.editor.selectedRectangles;\n          } else if (Object.values(HandleType).includes(hitsType)) {\n            const {\n              currentFrame\n            } = this.editor.props;\n            const {\n              handleIn,\n              handleOut,\n              index: segIndex,\n              path: {\n                data: {\n                  instanceId,\n                  groupName,\n                  pointCategory: category,\n                  id: pathId,\n                  points\n                }\n              }\n            } = this.editor.hits.segment;\n            const pointIndex = points[segIndex];\n            this.movingHandles = {\n              actual: hitsType === HandleType.HANDLE_IN ? handleIn : handleOut,\n              opposite: hitsType === HandleType.HANDLE_IN ? handleOut : handleIn,\n              type: hitsType,\n              pointIndex,\n              pathId,\n              instanceId,\n              groupName,\n              category,\n              frameIndex: currentFrame\n            };\n          } else if (this.editor.hits.item) {\n            const {\n              type: hitItemType\n            } = this.editor.hits.item.data;\n            if ((hitItemType === SHAPE_TYPE.RECTANGLE_PATH || hitItemType === SHAPE_TYPE.RECTANGLE || hitItemType === SHAPE_TYPE.RECTANGLE_POINT) && this.editor.hits.item.parent) {\n              // rectangle-control\n              this.movingShapes = [this.editor.hits.item.parent];\n              if (hitItemType === SHAPE_TYPE.RECTANGLE_PATH) {\n                switch (this.editor.hits.item.data.controlIndex) {\n                  case 0:\n                    this.dragType = 'top';\n                    break;\n                  case 1:\n                    this.dragType = 'right';\n                    break;\n                  case 2:\n                    this.dragType = 'bottom';\n                    break;\n                  case 3:\n                    this.dragType = 'left';\n                    break;\n                  default:\n                    break;\n                }\n              } else if (hitItemType === SHAPE_TYPE.RECTANGLE_POINT) {\n                switch (this.editor.hits.item.data.controlIndex) {\n                  case 0:\n                    this.dragType = 'tl';\n                    break;\n                  case 1:\n                    this.dragType = 'tr';\n                    break;\n                  case 2:\n                    this.dragType = 'br';\n                    break;\n                  case 3:\n                    this.dragType = 'bl';\n                    break;\n                  default:\n                    break;\n                }\n              } else {\n                this.dragType = 'center';\n              }\n            } else if (hitItemType === SHAPE_TYPE.KEYPOINT) {\n              // single point\n              this.movingShapes = [this.editor.hits.item];\n            }\n          }\n          this.affectedCategories = [];\n          this.movingSegments = [];\n          if (this.movingShapes.length === 1) {\n            const {\n              instanceId,\n              category,\n              groupName,\n              index: pointIndex,\n              type,\n              id: shapeId\n            } = this.movingShapes[0].data;\n            if (type === SHAPE_TYPE.KEYPOINT) {\n              var _this$editor;\n              (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.props.setSelectedShape(pointIndex, {\n                instanceId,\n                category,\n                groupName,\n                shapeType: LandmarkEditType.KEYPOINT\n              });\n            } else if (type === SHAPE_TYPE.RECTANGLE_GROUP) {\n              var _this$editor2;\n              const {\n                bounds: {\n                  topLeft,\n                  topRight,\n                  bottomRight,\n                  bottomLeft\n                }\n              } = this.movingShapes[0].children[0];\n              this.selectPath = new Paper.Path();\n              this.selectPath.data.id = shapeId;\n              this.selectPath.add(topLeft);\n              this.selectPath.add(topRight);\n              this.selectPath.add(bottomRight);\n              this.selectPath.add(bottomLeft);\n              this.selectPath.closed = true;\n              (_this$editor2 = this.editor) === null || _this$editor2 === void 0 ? void 0 : _this$editor2.props.setSelectedShape(shapeId, {\n                instanceId,\n                category,\n                groupName,\n                shapeType: LandmarkEditType.RECTANGLE\n              });\n            }\n          }\n          if (!rootStore.review.drawMode) {\n            this.movingShapes = [];\n            this.selectPath = null;\n          }\n        } else {\n          // select start\n          this.editor.setMultiShapesUnselected();\n          const localPoint = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n          if (this.editor.activeTool === CategoryPathShape.CIRCLE || this.editor.activeTool === CategoryPathShape.RECTANGLE && !this.editor.canAddShape()) {\n            this.selectPath = new Paper.Path({\n              segments: [localPoint],\n              strokeColor: 'red',\n              strokeWidth: 2,\n              strokeScaling: false\n            });\n          } else if (this.editor.activeTool === CategoryPathShape.RECTANGLE && this.editor.canAddShape() && this.editor.canvasContainer.current) {\n            var _this$editor3;\n            const {\n              instanceId,\n              category,\n              groupName\n            } = this.editor.props.selectedShapeInfo;\n            const id = uuid();\n            this.selectPath = new Paper.Path();\n            this.selectPath.data.id = id;\n            this.selectPath.add(localPoint);\n            this.selectPath.add(localPoint);\n            this.selectPath.add(localPoint);\n            this.selectPath.add(localPoint);\n            this.selectPath.closed = true;\n            this.editor.addRectangle(this.selectPath, (_this$editor3 = this.editor) === null || _this$editor3 === void 0 ? void 0 : _this$editor3.props.selectedShapeInfo);\n            const rectangleBox = this.editor.getShapeByKey(instanceId, groupName, id);\n            this.editor.props.setSelectedShape(id, {\n              instanceId,\n              category,\n              groupName,\n              shapeType: LandmarkEditType.RECTANGLE\n            });\n            this.movingShapes.push(rectangleBox);\n            this.dragType = 'br';\n            this.dragging = true;\n          }\n        }\n      }\n    };\n    this.onMouseDrag = event => {\n      var _this$editor4, _this$editor4$warning, _this$editor4$warning2, _this$editor5, _this$editor6, _this$editor7, _this$editor7$warning;\n      if (this.isRightButton(event)) {\n        if (!this.downPoint || !this.downCenter) {\n          this.downPoint = Paper.view.projectToView(event.point);\n          this.downCenter = Paper.view.center;\n        }\n        const rotation = Math.round(Paper.view.rotation);\n        const targetPoint = Paper.view.projectToView(event.point).rotate(-rotation, this.downPoint);\n        const deltaPixel = targetPoint.subtract(this.downPoint);\n        const candidateCenter = this.downCenter.subtract(deltaPixel.divide(Paper.view.zoom));\n        Paper.view.center = candidateCenter;\n        return;\n      }\n      if (rootStore.review.isEnabled && !rootStore.review.drawMode && ((_this$editor4 = this.editor) === null || _this$editor4 === void 0 ? void 0 : (_this$editor4$warning = _this$editor4.warningBtn) === null || _this$editor4$warning === void 0 ? void 0 : (_this$editor4$warning2 = _this$editor4$warning.item.data) === null || _this$editor4$warning2 === void 0 ? void 0 : _this$editor4$warning2.id)) {\n        // move missing review\n        if (this.editor) {\n          const point = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n          this.editor.warningBtn.item.parent.position.set(point);\n        }\n        return;\n      }\n      if (((_this$editor5 = this.editor) === null || _this$editor5 === void 0 ? void 0 : _this$editor5.props.isReview) || ((_this$editor6 = this.editor) === null || _this$editor6 === void 0 ? void 0 : _this$editor6.props.readonly) || ((_this$editor7 = this.editor) === null || _this$editor7 === void 0 ? void 0 : (_this$editor7$warning = _this$editor7.warningBtn) === null || _this$editor7$warning === void 0 ? void 0 : _this$editor7$warning.item)) return;\n      let resize = false;\n      if (this.editor) {\n        const localPoint = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n        const localLastPoint = this.editor.getPointInImage(Paper.view.projectToView(event.lastPoint));\n        const offsetX = localPoint.x - localLastPoint.x;\n        const offsetY = localPoint.y - localLastPoint.y;\n        if (Math.abs(offsetX) > 0 || Math.abs(offsetY) > 0) {\n          this.dragging = true;\n        }\n        if (this.movingShapes.length > 0) {\n          // moving\n          /* eslint-disable no-param-reassign */\n          this.movingShapes.forEach(movingShape => {\n            const {\n              frameIndex,\n              instanceId,\n              category,\n              groupName,\n              pointCategory: categoryName,\n              index,\n              type,\n              displayColor\n            } = movingShape.data;\n            if (type === SHAPE_TYPE.RECTANGLE_GROUP && this.selectPath) {\n              var _this$editor8;\n              resize = true;\n              switch (this.dragType) {\n                case 'tl':\n                  this.selectPath.segments[0].point.x += offsetX;\n                  this.selectPath.segments[0].point.y += offsetY;\n                  this.selectPath.segments[1].point.y += offsetY;\n                  this.selectPath.segments[3].point.x += offsetX;\n                  break;\n                case 'tr':\n                  this.selectPath.segments[1].point.x += offsetX;\n                  this.selectPath.segments[1].point.y += offsetY;\n                  this.selectPath.segments[0].point.y += offsetY;\n                  this.selectPath.segments[2].point.x += offsetX;\n                  break;\n                case 'br':\n                  this.selectPath.segments[2].point.x += offsetX;\n                  this.selectPath.segments[2].point.y += offsetY;\n                  this.selectPath.segments[3].point.y += offsetY;\n                  this.selectPath.segments[1].point.x += offsetX;\n                  break;\n                case 'bl':\n                  this.selectPath.segments[3].point.x += offsetX;\n                  this.selectPath.segments[3].point.y += offsetY;\n                  this.selectPath.segments[2].point.y += offsetY;\n                  this.selectPath.segments[0].point.x += offsetX;\n                  break;\n                case 'top':\n                  this.selectPath.segments[0].point.y += offsetY;\n                  this.selectPath.segments[1].point.y += offsetY;\n                  break;\n                case 'right':\n                  this.selectPath.segments[1].point.x += offsetX;\n                  this.selectPath.segments[2].point.x += offsetX;\n                  break;\n                case 'bottom':\n                  this.selectPath.segments[2].point.y += offsetY;\n                  this.selectPath.segments[3].point.y += offsetY;\n                  break;\n                case 'left':\n                  this.selectPath.segments[3].point.x += offsetX;\n                  this.selectPath.segments[0].point.x += offsetX;\n                  break;\n                case 'center':\n                  this.selectPath.segments[0].point.x += offsetX;\n                  this.selectPath.segments[0].point.y += offsetY;\n                  this.selectPath.segments[1].point.x += offsetX;\n                  this.selectPath.segments[1].point.y += offsetY;\n                  this.selectPath.segments[2].point.x += offsetX;\n                  this.selectPath.segments[2].point.y += offsetY;\n                  this.selectPath.segments[3].point.x += offsetX;\n                  this.selectPath.segments[3].point.y += offsetY;\n                  break;\n                default:\n                  break;\n              }\n              const shapeInfo = {\n                instanceId,\n                category,\n                groupName,\n                shapeType: LandmarkEditType.RECTANGLE,\n                displayColor\n              };\n              (_this$editor8 = this.editor) === null || _this$editor8 === void 0 ? void 0 : _this$editor8.addRectangle(this.selectPath, shapeInfo, false);\n            } else if (type === SHAPE_TYPE.KEYPOINT) {\n              var _this$editor9, _this$editor10;\n              const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${categoryName}`;\n              if (((_this$editor9 = this.editor) === null || _this$editor9 === void 0 ? void 0 : _this$editor9.props.categoryPathShapes[categoryKey]) === CategoryPathShape.CIRCLE) {\n                const path = this.editor.getPathByCategory(instanceId, groupName, categoryName);\n                if (path && path.data.isCircle) {\n                  const pointCategory = this.editor.props.categories.find(c => c.name === categoryName);\n                  if (pointCategory) {\n                    if (this.affectedCategories.findIndex(affected => affected.instanceId === instanceId && affected.groupName === groupName && affected.pointCategory === categoryName) < 0) {\n                      this.affectedCategories.push({\n                        instanceId,\n                        category,\n                        groupName,\n                        pointCategory: categoryName\n                      });\n                    }\n                    const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n                    const pIndex1 = sortedKeys[0];\n                    const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n                    if (index !== pIndex1 && index !== pIndex2) {\n                      return;\n                    }\n                  }\n                }\n              }\n              (_this$editor10 = this.editor) === null || _this$editor10 === void 0 ? void 0 : _this$editor10.updatePath(movingShape, {\n                x: movingShape.position.x + offsetX,\n                y: movingShape.position.y + offsetY\n              });\n              movingShape.position.x += offsetX;\n              movingShape.position.y += offsetY;\n            }\n          });\n          this.movingSegments.forEach(movingSegment => {\n            movingSegment.point.x += offsetX;\n            movingSegment.point.y += offsetY;\n          });\n          this.affectedCategories.forEach(({\n            instanceId,\n            category,\n            groupName,\n            pointCategory\n          }) => {\n            var _this$editor11;\n            const container = {\n              instanceId,\n              category,\n              groupName\n            };\n            (_this$editor11 = this.editor) === null || _this$editor11 === void 0 ? void 0 : _this$editor11.updateCirclePath(pointCategory, true, container);\n          });\n          /* eslint-enable no-param-reassign */\n        } else if (this.movingHandles) {\n          // moving handle point\n          this.movingHandles.actual.x += offsetX;\n          this.movingHandles.actual.y += offsetY;\n          this.movingHandles.opposite.x = -this.movingHandles.actual.x;\n          this.movingHandles.opposite.y = -this.movingHandles.actual.y;\n        } else if (this.selectPath) {\n          // draw select path\n          if (this.editor.activeTool === CategoryPathShape.CIRCLE || this.editor.activeTool === CategoryPathShape.RECTANGLE && !this.editor.canAddShape()) {\n            this.selectPath.add(localPoint);\n          } else if (this.editor.activeTool === CategoryPathShape.RECTANGLE && !resize) {\n            var _this$editor12;\n            this.selectPath.segments[1].point.x += offsetX;\n            this.selectPath.segments[2].point.x += offsetX;\n            this.selectPath.segments[2].point.y += offsetY;\n            this.selectPath.segments[3].point.y += offsetY;\n            this.editor.addRectangle(this.selectPath, (_this$editor12 = this.editor) === null || _this$editor12 === void 0 ? void 0 : _this$editor12.props.selectedShapeInfo, false);\n          }\n        }\n      }\n    };\n    this.onMouseUp = event => {\n      var _this$editor14, _this$editor14$warnin, _this$editor26;\n      if (this.isRightButton(event)) {\n        var _this$editor13;\n        (_this$editor13 = this.editor) === null || _this$editor13 === void 0 ? void 0 : _this$editor13.drag(Paper.view.center);\n        this.downPoint = null;\n        this.downCenter = null;\n        return;\n      }\n      this.mouseDown = false;\n      if (rootStore.review.isEnabled && !rootStore.review.drawMode && rootStore.review.selectedMissingReview && rootStore.review.selectedMissingReview.data === undefined) {\n        // create missing dot when mouse up\n        if (this.editor) {\n          const point = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n          rootStore.review.finishMissingReview(point);\n        }\n        return;\n      }\n      if ((_this$editor14 = this.editor) === null || _this$editor14 === void 0 ? void 0 : (_this$editor14$warnin = _this$editor14.warningBtn) === null || _this$editor14$warnin === void 0 ? void 0 : _this$editor14$warnin.item) {\n        const {\n          data,\n          position\n        } = this.editor.warningBtn.item;\n        if (data === null || data === void 0 ? void 0 : data.id) {\n          // finish move missing review\n          const review = rootStore.review.missingReviews.find(r => r.id === data.id);\n          if (review) {\n            rootStore.review.updateMissingReview({\n              ...review,\n              data: {\n                position: {\n                  x: position.x,\n                  y: position.y\n                }\n              }\n            });\n            rootStore.review.setSelectedMissingReview(review);\n          }\n        }\n        return;\n      }\n      if (!this.isCtrlKey(event) && this.movingShapes.length > 0) {\n        var _this$editor22;\n        // move ends\n        if (this.dragging && this.editor) {\n          if (this.editor.activeTool === CategoryPathShape.CIRCLE) {\n            var _this$editor17;\n            const otherPoints = [];\n            this.affectedCategories.forEach(({\n              instanceId,\n              category,\n              groupName,\n              pointCategory\n            }) => {\n              var _this$editor15;\n              const container = {\n                instanceId,\n                category,\n                groupName\n              };\n              const updatedShapes = (_this$editor15 = this.editor) === null || _this$editor15 === void 0 ? void 0 : _this$editor15.updateCirclePath(pointCategory, true, container);\n              if (updatedShapes) {\n                updatedShapes.forEach(({\n                  shape,\n                  index\n                }) => {\n                  if (index !== undefined && shape) {\n                    var _this$editor16;\n                    otherPoints.push({\n                      frameIndex: ((_this$editor16 = this.editor) === null || _this$editor16 === void 0 ? void 0 : _this$editor16.props.selectedShapeStatus.frameIndex) || 0,\n                      instanceId,\n                      category,\n                      groupName,\n                      index,\n                      shapeType: LandmarkEditType.KEYPOINT,\n                      shape\n                    });\n                  }\n                });\n              }\n            });\n            (_this$editor17 = this.editor) === null || _this$editor17 === void 0 ? void 0 : _this$editor17.updatePointsPosition([...this.movingShapes.map(movingPoint => {\n              const {\n                frameIndex,\n                instanceId,\n                category,\n                groupName,\n                index\n              } = movingPoint.data;\n              return {\n                frameIndex,\n                instanceId,\n                category,\n                groupName,\n                index,\n                shapeType: LandmarkEditType.KEYPOINT,\n                shape: {\n                  position: {\n                    x: movingPoint.position.x,\n                    y: movingPoint.position.y\n                  }\n                }\n              };\n            }), ...otherPoints]);\n          } else if (this.editor.activeTool === CategoryPathShape.RECTANGLE) {\n            var _this$editor18;\n            (_this$editor18 = this.editor) === null || _this$editor18 === void 0 ? void 0 : _this$editor18.updateRectanglePosition([...this.movingShapes.filter(movingRectangle => {\n              const {\n                bounds: {\n                  width,\n                  height\n                }\n              } = movingRectangle.children[0];\n              if (width < this.minArea || height < this.minArea) {\n                var _this$editor19;\n                (_this$editor19 = this.editor) === null || _this$editor19 === void 0 ? void 0 : _this$editor19.deleteSelectedRectangle();\n                message.warning(formatMessage('MIN_SIZE_ALERT'));\n                return false;\n              }\n              return true;\n            }).map(movingRectangle => {\n              var _this$editor20, _this$editor21;\n              const {\n                instanceId,\n                category,\n                groupName,\n                id,\n                displayColor\n              } = movingRectangle.data;\n              const {\n                bounds: {\n                  x,\n                  y,\n                  width,\n                  height\n                }\n              } = movingRectangle.children[0];\n              const groupInfo = {\n                frameIndex: ((_this$editor20 = this.editor) === null || _this$editor20 === void 0 ? void 0 : _this$editor20.props.selectedShapeStatus.frameIndex) || 0,\n                instanceId,\n                category,\n                groupName\n              };\n              const rectInfo = {\n                x,\n                y,\n                width,\n                height,\n                displayColor: displayColor || '#5cdef0'\n              };\n              (_this$editor21 = this.editor) === null || _this$editor21 === void 0 ? void 0 : _this$editor21.drawRectangle(rectInfo, groupInfo, id);\n              return {\n                ...groupInfo,\n                id,\n                shapeType: LandmarkEditType.RECTANGLE,\n                shape: {\n                  ...rectInfo,\n                  id,\n                  visible: true // default is visible when point added\n                }\n              };\n            })]);\n          }\n        }\n        if (this.selectPath) {\n          this.selectPath.remove();\n          this.selectPath = null;\n        }\n        this.movingShapes = [];\n        this.movingSegments = [];\n        this.affectedCategories = [];\n        (_this$editor22 = this.editor) === null || _this$editor22 === void 0 ? void 0 : _this$editor22.drawWarnings();\n      } else if (this.movingHandles) {\n        // handle move ends\n        this.movingHandles = undefined;\n      } else if (this.dragging && this.selectPath) {\n        var _this$editor23;\n        // select ends\n        if ((_this$editor23 = this.editor) === null || _this$editor23 === void 0 ? void 0 : _this$editor23.mainLayer) {\n          var _this$editor24, _this$editor25;\n          const center = this.editor.mainLayer.localToGlobal(this.selectPath.bounds.center);\n          const hits = this.editor.mainLayer.hitTestAll(center, {\n            fill: true,\n            segments: true,\n            tolerance: this.selectPath.bounds.topLeft.getDistance(this.selectPath.bounds.bottomRight) / 2\n          });\n          const selectedPoints = new Set();\n          const selectedRectangles = new Set();\n          let selectedGroup;\n          const isOneGroup = (instanceId, groupName) => {\n            if (!selectedGroup) {\n              selectedGroup = `${instanceId}_${groupName}`;\n              return true;\n            }\n            return `${instanceId}_${groupName}` === selectedGroup;\n          };\n          hits.forEach(seg => {\n            if (this.selectPath.contains(seg.item.bounds.center)) {\n              if (seg.item.data.type === SHAPE_TYPE.KEYPOINT) {\n                if (isOneGroup(seg.item.data.instanceId, seg.item.data.groupName)) {\n                  selectedPoints.add(seg.item);\n                }\n              } else if (seg.item.data.type === SHAPE_TYPE.RECTANGLE || seg.item.data.type === SHAPE_TYPE.RECTANGLE_POINT || seg.item.data.type === SHAPE_TYPE.RECTANGLE_PATH) {\n                if (isOneGroup(seg.item.parent.data.instanceId, seg.item.parent.data.groupName)) {\n                  selectedRectangles.add(seg.item.parent);\n                }\n              }\n            }\n          });\n\n          // selected\n          if (selectedPoints.size) (_this$editor24 = this.editor) === null || _this$editor24 === void 0 ? void 0 : _this$editor24.setMultiShapesSelected(Array.from(selectedPoints), CategoryPathShape.CIRCLE);\n          if (selectedRectangles.size) (_this$editor25 = this.editor) === null || _this$editor25 === void 0 ? void 0 : _this$editor25.setMultiShapesSelected(Array.from(selectedRectangles), CategoryPathShape.RECTANGLE);\n        }\n        this.selectPath.remove();\n        this.selectPath = null;\n      } else if (((_this$editor26 = this.editor) === null || _this$editor26 === void 0 ? void 0 : _this$editor26.canAddShape()) && this.editor.activeTool === CategoryPathShape.CIRCLE) {\n        // add point\n        const point = Paper.view.projectToView(event.point);\n        // if (this.editor?.isPointInImage(point)) {\n        this.editor.addKeypoint(point);\n        // }\n      } else if (this.editor && rootStore.review.drawMode) {\n        // clear selection and move next\n        this.editor.props.setNextEmptyShape();\n      }\n      this.dragging = false;\n    };\n    this.handleQa = result => {\n      var _this$editor27;\n      if ((_this$editor27 = this.editor) === null || _this$editor27 === void 0 ? void 0 : _this$editor27.props.selectedShapeStatus) {\n        var _this$editor28, _this$editor30;\n        const {\n          instanceId,\n          groupName,\n          frameIndex,\n          id\n        } = this.editor.props.selectedShapeStatus;\n        let shapeIds = [];\n        if (id !== undefined) {\n          shapeIds = [id];\n        } else if (((_this$editor28 = this.editor) === null || _this$editor28 === void 0 ? void 0 : _this$editor28.selectedPoints.length) > 0) {\n          var _this$editor29;\n          shapeIds = (_this$editor29 = this.editor) === null || _this$editor29 === void 0 ? void 0 : _this$editor29.selectedPoints.map(point => point.data.index);\n        } else if (((_this$editor30 = this.editor) === null || _this$editor30 === void 0 ? void 0 : _this$editor30.selectedRectangles.length) > 0) {\n          var _this$editor31;\n          shapeIds = (_this$editor31 = this.editor) === null || _this$editor31 === void 0 ? void 0 : _this$editor31.selectedRectangles.map(shape => shape.data.id);\n        }\n        if (shapeIds.length) {\n          shapeIds.sort((a, b) => a - b);\n          if (result !== ReviewResult.REJECT && !rootStore.review.selectedReview) {\n            rootStore.review.setReview({\n              result\n            }, {\n              frameIndex,\n              instanceId,\n              groupName,\n              shapeIds,\n              result\n            });\n          } else {\n            rootStore.review.setSelectedReview({\n              frameIndex,\n              instanceId,\n              groupName,\n              shapeIds,\n              result\n            });\n          }\n          if ((result === ReviewResult.SUSPEND || result === ReviewResult.APPROVE) && !rootStore.review.selectedReview) {\n            message.success(formatMessage(`QC_SET_${result.toLocaleUpperCase()}`));\n          }\n        }\n      }\n    };\n    this.onKeyDown = ({\n      event\n    }) => {\n      var _this$editor32, _this$editor34, _this$editor35, _this$editor36;\n      if (isInput()) return;\n      const key = event.key.toLowerCase();\n      if (((_this$editor32 = this.editor) === null || _this$editor32 === void 0 ? void 0 : _this$editor32.props.isReview) && key !== 'v') return;\n      // Judgment modifier keyboard\n      if (event.altKey || event.shiftKey) {\n        return;\n      }\n      if (rootStore.review.drawMode) {\n        this.drawOnKeyDown(event, key);\n      } else if (rootStore.review.isEnabled) {\n        this.QaOnKeyDown(event, key);\n      }\n      switch (key) {\n        case ' ':\n          event.preventDefault();\n          if (rootStore.review.isEnabled) {\n            var _this$editor33;\n            (_this$editor33 = this.editor) === null || _this$editor33 === void 0 ? void 0 : _this$editor33.props.handleChangeDrawMode(!rootStore.review.drawMode);\n          }\n          break;\n        case 'f':\n          event.preventDefault();\n          if (screenfull.isEnabled) {\n            screenfull.toggle();\n          }\n          break;\n        // case 'g':\n        //   event.preventDefault();\n        //   if (this.editor && this.editor.gridLayer) {\n        //     this.editor.gridLayer.visible = !rootStore.setting.isGridVisible;\n        //   }\n        //   rootStore.setting.setGridVisible(!rootStore.setting.isGridVisible);\n        //   break;\n        case 's':\n          event.preventDefault();\n          (_this$editor34 = this.editor) === null || _this$editor34 === void 0 ? void 0 : _this$editor34.props.onSave();\n          break;\n        case 'z':\n          event.preventDefault();\n          if (event.ctrlKey) (_this$editor35 = this.editor) === null || _this$editor35 === void 0 ? void 0 : _this$editor35.props.handleUndo();\n          break;\n        case 'y':\n          event.preventDefault();\n          if (event.ctrlKey) (_this$editor36 = this.editor) === null || _this$editor36 === void 0 ? void 0 : _this$editor36.props.handleRedo();\n          break;\n        case 'v':\n          if (!rootStore.review.selectedReview) {\n            event.preventDefault();\n            if (event.ctrlKey) {\n              var _this$editor37;\n              (_this$editor37 = this.editor) === null || _this$editor37 === void 0 ? void 0 : _this$editor37.props.setReview();\n            }\n          }\n          break;\n        default:\n      }\n    };\n    this.QaOnKeyDown = (event, key) => {\n      var _this$editor38;\n      if ((_this$editor38 = this.editor) === null || _this$editor38 === void 0 ? void 0 : _this$editor38.props.readonly) return;\n      switch (key) {\n        case '2':\n          event.preventDefault();\n          this.handleQa(ReviewResult.REJECT);\n          break;\n        case '1':\n          event.preventDefault();\n          this.handleQa(ReviewResult.APPROVE);\n          break;\n        case '3':\n          event.preventDefault();\n          this.handleQa(ReviewResult.SUSPEND);\n          break;\n        default:\n      }\n    };\n    this.drawOnKeyDown = (event, key) => {\n      var _this$editor39, _this$editor40, _this$editor41, _this$editor42, _this$editor43;\n      if ((_this$editor39 = this.editor) === null || _this$editor39 === void 0 ? void 0 : _this$editor39.props.readonly) return;\n      switch (key) {\n        case 'delete':\n        case 'backspace':\n          event.preventDefault();\n          (_this$editor40 = this.editor) === null || _this$editor40 === void 0 ? void 0 : _this$editor40.deleteSelectedPoints();\n          (_this$editor41 = this.editor) === null || _this$editor41 === void 0 ? void 0 : _this$editor41.deleteSelectedRectangle();\n          break;\n        // case 'a':\n        //   event.preventDefault();\n        //   this.editor?.autoAdjust();\n        //   break;\n        // case 'c':\n        //   event.preventDefault();\n        //   this.editor?.switchSmoothMode();\n        //   break;\n        case 'o':\n          event.preventDefault();\n          (_this$editor42 = this.editor) === null || _this$editor42 === void 0 ? void 0 : _this$editor42.props.editShapeForm();\n          break;\n        case 'p':\n          event.preventDefault();\n          (_this$editor43 = this.editor) === null || _this$editor43 === void 0 ? void 0 : _this$editor43.props.editGroupForm();\n          break;\n        // case 'r':\n        //   event.preventDefault();\n        //   this.editor?.setCategoryAsCircle();\n        //   break;\n        // case 'v':\n        //   event.preventDefault();\n        //   this.editor?.toggleSelectedPointVisibility();\n        //   break;\n        default:\n      }\n    };\n    this.editor = editor;\n  }\n}\n;","map":{"version":3,"names":["Paper","screenfull","v4","uuid","message","SHAPE_TYPE","CategoryPathShape","LandmarkEditType","ReviewResult","HandleType","isInput","formatMessage","rootStore","Tool","constructor","editor","downPoint","downCenter","mouseDown","dragging","lastClick","movingPaths","movingShapes","dragType","movingSegments","movingHandles","undefined","affectedCategories","selectPath","minArea","isRightButton","event","which","modifiers","space","isCtrlKey","ctrlKey","onMouseDown","view","projectToView","point","center","currentClick","Date","now","interval","_this$editor$warningB","warningBtn","item","instanceId","groupName","shapeIds","id","data","review","setSelectedReview","frameIndex","props","currentFrame","result","REJECT","missingReviews","find","r","setSelectedMissingReview","isEnabled","drawMode","selectedMissingReview","type","hitsType","hits","KEYPOINT_BOX","selectedInstanceId","selectedGroupName","index","selectedPoints","length","isShapeInSelectedShapes","selectedRectangles","Object","values","includes","handleIn","handleOut","segIndex","path","pointCategory","category","pathId","points","segment","pointIndex","actual","HANDLE_IN","opposite","hitItemType","RECTANGLE_PATH","RECTANGLE","RECTANGLE_POINT","parent","controlIndex","KEYPOINT","shapeId","_this$editor","setSelectedShape","shapeType","RECTANGLE_GROUP","_this$editor2","bounds","topLeft","topRight","bottomRight","bottomLeft","children","Path","add","closed","setMultiShapesUnselected","localPoint","getPointInImage","activeTool","CIRCLE","canAddShape","segments","strokeColor","strokeWidth","strokeScaling","canvasContainer","current","_this$editor3","selectedShapeInfo","addRectangle","rectangleBox","getShapeByKey","push","onMouseDrag","_this$editor4","_this$editor4$warning","_this$editor4$warning2","_this$editor5","_this$editor6","_this$editor7","_this$editor7$warning","rotation","Math","round","targetPoint","rotate","deltaPixel","subtract","candidateCenter","divide","zoom","position","set","isReview","readonly","resize","localLastPoint","lastPoint","offsetX","x","offsetY","y","abs","forEach","movingShape","categoryName","displayColor","_this$editor8","shapeInfo","_this$editor9","_this$editor10","categoryKey","categoryPathShapes","getPathByCategory","isCircle","categories","c","name","findIndex","affected","sortedKeys","keys","sort","a","b","pIndex1","pIndex2","ceil","updatePath","movingSegment","_this$editor11","container","updateCirclePath","_this$editor12","onMouseUp","_this$editor14","_this$editor14$warnin","_this$editor26","_this$editor13","drag","finishMissingReview","updateMissingReview","_this$editor22","_this$editor17","otherPoints","_this$editor15","updatedShapes","shape","_this$editor16","selectedShapeStatus","updatePointsPosition","map","movingPoint","_this$editor18","updateRectanglePosition","filter","movingRectangle","width","height","_this$editor19","deleteSelectedRectangle","warning","_this$editor20","_this$editor21","groupInfo","rectInfo","drawRectangle","visible","remove","drawWarnings","_this$editor23","mainLayer","_this$editor24","_this$editor25","localToGlobal","hitTestAll","fill","tolerance","getDistance","Set","selectedGroup","isOneGroup","seg","contains","size","setMultiShapesSelected","Array","from","addKeypoint","setNextEmptyShape","handleQa","_this$editor27","_this$editor28","_this$editor30","_this$editor29","_this$editor31","selectedReview","setReview","SUSPEND","APPROVE","success","toLocaleUpperCase","onKeyDown","_this$editor32","_this$editor34","_this$editor35","_this$editor36","key","toLowerCase","altKey","shiftKey","drawOnKeyDown","QaOnKeyDown","preventDefault","_this$editor33","handleChangeDrawMode","toggle","onSave","handleUndo","handleRedo","_this$editor37","_this$editor38","_this$editor39","_this$editor40","_this$editor41","_this$editor42","_this$editor43","deleteSelectedPoints","editShapeForm","editGroupForm"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/tools/Tool.ts"],"sourcesContent":["import Paper from 'paper';\nimport screenfull from 'screenfull';\nimport { v4 as uuid } from 'uuid';\nimport { message } from 'antd';\nimport Canvas, { SHAPE_TYPE } from '../components/Canvas';\nimport { CategoryPathShape, GroupInfo, LandmarkEditType, UpdatedShape, ReviewResult, HandleType, Group } from '../types';\nimport { isInput } from '../../../utils';\nimport formatMessage from '../locales';\nimport rootStore from '../store/RootStore';\n\nexport interface ToolEventExtend extends paper.ToolEvent {\n  event: MouseEvent;\n  mouseDown: boolean;\n}\n\nexport interface ToolProps extends paper.Tool {\n  mouseDown: boolean;\n}\n\nexport interface MoveHandles extends Group {\n  actual: paper.Point;\n  opposite: paper.Point;\n  type: HandleType;\n  pointIndex: number;\n  pathId: string;\n  frameIndex: number;\n}\n\nexport default class Tool extends Paper.Tool {\n  editor: Canvas | undefined;\n\n  downPoint: paper.Point | null = null;\n\n  downCenter: paper.Point | null = null;\n\n  mouseDown = false;\n\n  dragging = false;\n\n  lastClick = -1;\n\n  movingPaths: paper.Path[] = [];\n\n  movingShapes: paper.Item[] = [];\n\n  dragType = '';\n\n  movingSegments: paper.Segment[] = [];\n\n  movingHandles: MoveHandles | undefined = undefined;\n\n  affectedCategories: { instanceId: string, category: string, groupName: string, pointCategory: string }[] = [];\n\n  selectPath: paper.Path | null = null;\n\n  minArea = 3;\n\n  constructor(editor: Canvas) {\n    super();\n    this.editor = editor;\n  }\n\n  isRightButton = (event: ToolEventExtend) => event.event.which === 3 || event.modifiers.space;\n\n  isCtrlKey = (event: ToolEventExtend) => event.event.ctrlKey;\n\n  onMouseDown = (event: ToolEventExtend) => {\n    if (this.isRightButton(event)) {\n      this.downPoint = Paper.view.projectToView(event.point);\n      this.downCenter = Paper.view.center;\n      return;\n    }\n    if (this.editor) {\n      this.mouseDown = true;\n      const currentClick = Date.now();\n      const interval = currentClick - this.lastClick;\n      this.lastClick = currentClick;\n      if (interval < 300) {\n        // db click\n        if (this.editor.warningBtn?.item) {\n          const { instanceId, groupName, shapeIds, id } = this.editor.warningBtn.item.data || {};\n          if (instanceId && groupName && shapeIds !== undefined) {\n            rootStore.review.setSelectedReview({ frameIndex: this.editor.props.currentFrame, instanceId, groupName, shapeIds, result: ReviewResult.REJECT });\n          } else if (id) {\n            const review = rootStore.review.missingReviews.find((r) => r.id === id);\n            rootStore.review.setSelectedMissingReview(review, true);\n          }\n        }\n        return;\n      }\n      if (rootStore.review.isEnabled && !rootStore.review.drawMode && rootStore.review.selectedMissingReview && rootStore.review.selectedMissingReview.data === undefined) {\n        // create missing dot when mouse up\n        return;\n      }\n      const { type: hitsType } = this.editor.hits || {};\n      if (!this.isCtrlKey(event) && this.editor.hits && this.editor.hits.item.data.type !== SHAPE_TYPE.KEYPOINT_BOX) {\n        const { instanceId: selectedInstanceId, groupName: selectedGroupName, index, id } = this.editor.hits.item.data;\n        // move start\n        if (this.editor.selectedPoints.length > 0 && this.editor.isShapeInSelectedShapes(selectedInstanceId, selectedGroupName, index)) {\n          // multi points\n          this.movingShapes = this.editor.selectedPoints;\n        } else if (this.editor.selectedRectangles.length > 0 && this.editor.isShapeInSelectedShapes(selectedInstanceId, selectedGroupName, id)) {\n          // multi rectangles\n          this.movingShapes = this.editor.selectedRectangles;\n        } else if (Object.values(HandleType).includes(hitsType as HandleType)) {\n          const { currentFrame } = this.editor.props;\n          const { handleIn, handleOut, index: segIndex, path: { data: { instanceId, groupName, pointCategory: category, id: pathId, points } } } = this.editor.hits.segment;\n          const pointIndex = points[segIndex];\n          this.movingHandles = {\n            actual: hitsType === HandleType.HANDLE_IN ? handleIn : handleOut,\n            opposite: hitsType === HandleType.HANDLE_IN ? handleOut : handleIn,\n            type: hitsType as HandleType,\n            pointIndex,\n            pathId,\n            instanceId,\n            groupName,\n            category,\n            frameIndex: currentFrame\n          };\n        } else if (this.editor.hits.item) {\n          const { type: hitItemType } = this.editor.hits.item.data;\n          if (\n            (\n              hitItemType === SHAPE_TYPE.RECTANGLE_PATH ||\n              hitItemType === SHAPE_TYPE.RECTANGLE ||\n              hitItemType === SHAPE_TYPE.RECTANGLE_POINT\n            ) &&\n            this.editor.hits.item.parent\n          ) {\n            // rectangle-control\n            this.movingShapes = [this.editor.hits.item.parent];\n            if (hitItemType === SHAPE_TYPE.RECTANGLE_PATH) {\n              switch (this.editor.hits.item.data.controlIndex) {\n                case 0:\n                  this.dragType = 'top';\n                  break;\n                case 1:\n                  this.dragType = 'right';\n                  break;\n                case 2:\n                  this.dragType = 'bottom';\n                  break;\n                case 3:\n                  this.dragType = 'left';\n                  break;\n                default:\n                  break;\n              }\n            } else if (hitItemType === SHAPE_TYPE.RECTANGLE_POINT) {\n              switch (this.editor.hits.item.data.controlIndex) {\n                case 0:\n                  this.dragType = 'tl';\n                  break;\n                case 1:\n                  this.dragType = 'tr';\n                  break;\n                case 2:\n                  this.dragType = 'br';\n                  break;\n                case 3:\n                  this.dragType = 'bl';\n                  break;\n                default:\n                  break;\n              }\n            } else {\n              this.dragType = 'center';\n            }\n          } else if (hitItemType === SHAPE_TYPE.KEYPOINT) {\n            // single point\n            this.movingShapes = [this.editor.hits.item];\n          }\n        }\n        this.affectedCategories = [];\n        this.movingSegments = [];\n        if (this.movingShapes.length === 1) {\n          const { instanceId, category, groupName, index: pointIndex, type, id: shapeId } = this.movingShapes[0].data;\n          if (type === SHAPE_TYPE.KEYPOINT) {\n            this.editor?.props.setSelectedShape(pointIndex, { instanceId, category, groupName, shapeType: LandmarkEditType.KEYPOINT });\n          } else if (type === SHAPE_TYPE.RECTANGLE_GROUP) {\n            const { bounds: { topLeft, topRight, bottomRight, bottomLeft } } = this.movingShapes[0].children[0];\n            this.selectPath = new Paper.Path();\n            this.selectPath.data.id = shapeId;\n            this.selectPath.add(topLeft);\n            this.selectPath.add(topRight);\n            this.selectPath.add(bottomRight);\n            this.selectPath.add(bottomLeft);\n            this.selectPath.closed = true;\n            this.editor?.props.setSelectedShape(shapeId, { instanceId, category, groupName, shapeType: LandmarkEditType.RECTANGLE });\n          }\n        }\n\n        if (!rootStore.review.drawMode) {\n          this.movingShapes = [];\n          this.selectPath = null;\n        }\n      } else {\n        // select start\n        this.editor.setMultiShapesUnselected();\n        const localPoint = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n        if (this.editor.activeTool === CategoryPathShape.CIRCLE || (this.editor.activeTool === CategoryPathShape.RECTANGLE && !this.editor.canAddShape())) {\n          this.selectPath = new Paper.Path({\n            segments: [localPoint],\n            strokeColor: 'red',\n            strokeWidth: 2,\n            strokeScaling: false,\n          });\n        } else if (\n          this.editor.activeTool === CategoryPathShape.RECTANGLE &&\n          this.editor.canAddShape() &&\n          this.editor.canvasContainer.current\n        ) {\n          const { instanceId, category, groupName } = this.editor.props.selectedShapeInfo as GroupInfo;\n          const id = uuid();\n          this.selectPath = new Paper.Path();\n          this.selectPath.data.id = id;\n          this.selectPath.add(localPoint);\n          this.selectPath.add(localPoint);\n          this.selectPath.add(localPoint);\n          this.selectPath.add(localPoint);\n          this.selectPath.closed = true;\n          this.editor.addRectangle(this.selectPath, this.editor?.props.selectedShapeInfo as GroupInfo);\n          const rectangleBox = this.editor.getShapeByKey(instanceId, groupName, id);\n          this.editor.props.setSelectedShape(id, { instanceId, category, groupName, shapeType: LandmarkEditType.RECTANGLE });\n          this.movingShapes.push(rectangleBox);\n          this.dragType = 'br';\n          this.dragging = true;\n        }\n      }\n    }\n  };\n\n  onMouseDrag = (event: ToolEventExtend) => {\n    if (this.isRightButton(event)) {\n      if (!this.downPoint || !this.downCenter) {\n        this.downPoint = Paper.view.projectToView(event.point);\n        this.downCenter = Paper.view.center;\n      }\n\n      const rotation = Math.round(Paper.view.rotation);\n      const targetPoint = Paper.view.projectToView(event.point).rotate(-rotation, this.downPoint);\n      const deltaPixel = targetPoint.subtract(this.downPoint);\n      const candidateCenter = this.downCenter.subtract(deltaPixel.divide(Paper.view.zoom));\n      Paper.view.center = candidateCenter;\n      return;\n    }\n    if (rootStore.review.isEnabled && !rootStore.review.drawMode && this.editor?.warningBtn?.item.data?.id) {\n      // move missing review\n      if (this.editor) {\n        const point = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n        this.editor.warningBtn.item.parent.position.set(point);\n      }\n      return;\n    }\n    if (this.editor?.props.isReview || this.editor?.props.readonly || this.editor?.warningBtn?.item) return;\n    let resize = false;\n    if (this.editor) {\n      const localPoint = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n      const localLastPoint = this.editor.getPointInImage(Paper.view.projectToView(event.lastPoint));\n      const offsetX = localPoint.x - localLastPoint.x;\n      const offsetY = localPoint.y - localLastPoint.y;\n      if (Math.abs(offsetX) > 0 || Math.abs(offsetY) > 0) {\n        this.dragging = true;\n      }\n\n      if (this.movingShapes.length > 0) {\n        // moving\n        /* eslint-disable no-param-reassign */\n        this.movingShapes.forEach((movingShape) => {\n          const { frameIndex, instanceId, category, groupName, pointCategory: categoryName, index, type, displayColor } = movingShape.data;\n          if (type === SHAPE_TYPE.RECTANGLE_GROUP && this.selectPath) {\n            resize = true;\n            switch (this.dragType) {\n              case 'tl':\n                this.selectPath.segments[0].point.x += offsetX;\n                this.selectPath.segments[0].point.y += offsetY;\n                this.selectPath.segments[1].point.y += offsetY;\n                this.selectPath.segments[3].point.x += offsetX;\n                break;\n              case 'tr':\n                this.selectPath.segments[1].point.x += offsetX;\n                this.selectPath.segments[1].point.y += offsetY;\n                this.selectPath.segments[0].point.y += offsetY;\n                this.selectPath.segments[2].point.x += offsetX;\n                break;\n              case 'br':\n                this.selectPath.segments[2].point.x += offsetX;\n                this.selectPath.segments[2].point.y += offsetY;\n                this.selectPath.segments[3].point.y += offsetY;\n                this.selectPath.segments[1].point.x += offsetX;\n                break;\n              case 'bl':\n                this.selectPath.segments[3].point.x += offsetX;\n                this.selectPath.segments[3].point.y += offsetY;\n                this.selectPath.segments[2].point.y += offsetY;\n                this.selectPath.segments[0].point.x += offsetX;\n                break;\n              case 'top':\n                this.selectPath.segments[0].point.y += offsetY;\n                this.selectPath.segments[1].point.y += offsetY;\n                break;\n              case 'right':\n                this.selectPath.segments[1].point.x += offsetX;\n                this.selectPath.segments[2].point.x += offsetX;\n                break;\n              case 'bottom':\n                this.selectPath.segments[2].point.y += offsetY;\n                this.selectPath.segments[3].point.y += offsetY;\n                break;\n              case 'left':\n                this.selectPath.segments[3].point.x += offsetX;\n                this.selectPath.segments[0].point.x += offsetX;\n                break;\n              case 'center':\n                this.selectPath.segments[0].point.x += offsetX;\n                this.selectPath.segments[0].point.y += offsetY;\n                this.selectPath.segments[1].point.x += offsetX;\n                this.selectPath.segments[1].point.y += offsetY;\n                this.selectPath.segments[2].point.x += offsetX;\n                this.selectPath.segments[2].point.y += offsetY;\n                this.selectPath.segments[3].point.x += offsetX;\n                this.selectPath.segments[3].point.y += offsetY;\n                break;\n              default:\n                break;\n            }\n            const shapeInfo: GroupInfo = {\n              instanceId,\n              category,\n              groupName,\n              shapeType: LandmarkEditType.RECTANGLE,\n              displayColor,\n            };\n            this.editor?.addRectangle(this.selectPath, shapeInfo, false);\n          } else if (type === SHAPE_TYPE.KEYPOINT) {\n            const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${categoryName}`;\n            if (this.editor?.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n              const path = this.editor.getPathByCategory(instanceId, groupName, categoryName);\n              if (path && path.data.isCircle) {\n                const pointCategory = this.editor.props.categories.find((c) => c.name === categoryName);\n                if (pointCategory) {\n                  if (\n                    this.affectedCategories.findIndex((affected) => affected.instanceId === instanceId && affected.groupName === groupName && affected.pointCategory === categoryName) < 0) {\n                    this.affectedCategories.push({\n                      instanceId,\n                      category,\n                      groupName,\n                      pointCategory: categoryName\n                    });\n                  }\n                  const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n                  const pIndex1 = sortedKeys[0];\n                  const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n                  if (index !== pIndex1 && index !== pIndex2) {\n                    return;\n                  }\n                }\n              }\n            }\n            this.editor?.updatePath(movingShape as paper.Shape, { x: movingShape.position.x + offsetX, y: movingShape.position.y + offsetY });\n            movingShape.position.x += offsetX;\n            movingShape.position.y += offsetY;\n          }\n        });\n        this.movingSegments.forEach((movingSegment) => {\n          movingSegment.point.x += offsetX;\n          movingSegment.point.y += offsetY;\n        });\n        this.affectedCategories.forEach(({ instanceId, category, groupName, pointCategory }) => {\n          const container = { instanceId, category, groupName };\n          this.editor?.updateCirclePath(pointCategory, true, container);\n        });\n        /* eslint-enable no-param-reassign */\n      } else if (this.movingHandles) {\n        // moving handle point\n        this.movingHandles.actual.x += offsetX;\n        this.movingHandles.actual.y += offsetY;\n        this.movingHandles.opposite.x = -this.movingHandles.actual.x;\n        this.movingHandles.opposite.y = -this.movingHandles.actual.y;\n      } else if (this.selectPath) {\n        // draw select path\n        if (this.editor.activeTool === CategoryPathShape.CIRCLE || (this.editor.activeTool === CategoryPathShape.RECTANGLE && !this.editor.canAddShape())) {\n          this.selectPath.add(localPoint);\n        } else if (this.editor.activeTool === CategoryPathShape.RECTANGLE && !resize) {\n          this.selectPath.segments[1].point.x += offsetX;\n          this.selectPath.segments[2].point.x += offsetX;\n          this.selectPath.segments[2].point.y += offsetY;\n          this.selectPath.segments[3].point.y += offsetY;\n          this.editor.addRectangle(this.selectPath, this.editor?.props.selectedShapeInfo as GroupInfo, false);\n        }\n      }\n    }\n  };\n\n  onMouseUp = (event: ToolEventExtend) => {\n    if (this.isRightButton(event)) {\n      this.editor?.drag(Paper.view.center);\n      this.downPoint = null;\n      this.downCenter = null;\n      return;\n    }\n    this.mouseDown = false;\n    if (rootStore.review.isEnabled && !rootStore.review.drawMode && rootStore.review.selectedMissingReview && rootStore.review.selectedMissingReview.data === undefined) {\n      // create missing dot when mouse up\n      if (this.editor) {\n        const point = this.editor.getPointInImage(Paper.view.projectToView(event.point));\n        rootStore.review.finishMissingReview(point);\n      }\n      return;\n    }\n    if (this.editor?.warningBtn?.item) {\n      const { data, position } = this.editor.warningBtn.item;\n      if (data?.id) {\n        // finish move missing review\n        const review = rootStore.review.missingReviews.find((r) => r.id === data.id);\n        if (review) {\n          rootStore.review.updateMissingReview({\n            ...review,\n            data: {\n              position: { x: position.x, y: position.y },\n            },\n          });\n          rootStore.review.setSelectedMissingReview(review);\n        }\n      }\n      return;\n    }\n    if (!this.isCtrlKey(event) && this.movingShapes.length > 0) {\n      // move ends\n      if (this.dragging && this.editor) {\n        if (this.editor.activeTool === CategoryPathShape.CIRCLE) {\n          const otherPoints: UpdatedShape[] = [];\n          this.affectedCategories.forEach(({ instanceId, category, groupName, pointCategory }) => {\n            const container = { instanceId, category, groupName };\n            const updatedShapes = this.editor?.updateCirclePath(pointCategory, true, container);\n            if (updatedShapes) {\n              updatedShapes.forEach(({ shape, index }) => {\n                if (index !== undefined && shape) {\n                  otherPoints.push({\n                    frameIndex: this.editor?.props.selectedShapeStatus.frameIndex || 0,\n                    instanceId,\n                    category,\n                    groupName,\n                    index,\n                    shapeType: LandmarkEditType.KEYPOINT,\n                    shape\n                  });\n                }\n              });\n            }\n          });\n          this.editor?.updatePointsPosition([...this.movingShapes.map((movingPoint) => {\n            const { frameIndex, instanceId, category, groupName, index } = movingPoint.data;\n            return {\n              frameIndex,\n              instanceId,\n              category,\n              groupName,\n              index,\n              shapeType: LandmarkEditType.KEYPOINT,\n              shape: { position: { x: movingPoint.position.x, y: movingPoint.position.y } }\n            };\n          }), ...otherPoints]);\n        } else if (this.editor.activeTool === CategoryPathShape.RECTANGLE) {\n          this.editor?.updateRectanglePosition([...this.movingShapes.filter((movingRectangle) => {\n            const { bounds: { width, height } } = movingRectangle.children[0];\n            if (width < this.minArea || height < this.minArea) {\n              this.editor?.deleteSelectedRectangle();\n              message.warning(formatMessage('MIN_SIZE_ALERT'));\n              return false;\n            }\n            return true;\n          }).map((movingRectangle) => {\n            const { instanceId, category, groupName, id, displayColor } = movingRectangle.data;\n            const { bounds: { x, y, width, height } } = movingRectangle.children[0];\n            const groupInfo = { frameIndex: this.editor?.props.selectedShapeStatus.frameIndex || 0, instanceId, category, groupName };\n            const rectInfo = {\n              x,\n              y,\n              width,\n              height,\n              displayColor: displayColor || '#5cdef0',\n            };\n            this.editor?.drawRectangle(rectInfo, groupInfo, id);\n            return {\n              ...groupInfo,\n              id,\n              shapeType: LandmarkEditType.RECTANGLE,\n              shape: {\n                ...rectInfo,\n                id,\n                visible: true, // default is visible when point added\n              },\n            };\n          })]);\n        }\n      }\n      if (this.selectPath) {\n        this.selectPath.remove();\n        this.selectPath = null;\n      }\n      this.movingShapes = [];\n      this.movingSegments = [];\n      this.affectedCategories = [];\n      this.editor?.drawWarnings();\n    } else if (this.movingHandles) {\n      // handle move ends\n      this.movingHandles = undefined;\n    } else if (this.dragging && this.selectPath) {\n      // select ends\n      if (this.editor?.mainLayer) {\n        const center = this.editor.mainLayer.localToGlobal(this.selectPath.bounds.center);\n        const hits = this.editor.mainLayer.hitTestAll(center, {\n          fill: true,\n          segments: true,\n          tolerance: this.selectPath.bounds.topLeft.getDistance(this.selectPath.bounds.bottomRight) / 2,\n        });\n\n        const selectedPoints: Set<paper.Shape> = new Set();\n        const selectedRectangles: Set<paper.Group> = new Set();\n        let selectedGroup: string | undefined;\n        const isOneGroup = (instanceId: string, groupName: string) => {\n          if (!selectedGroup) {\n            selectedGroup = `${instanceId}_${groupName}`;\n            return true;\n          }\n          return `${instanceId}_${groupName}` === selectedGroup;\n        };\n        hits.forEach((seg) => {\n          if (this.selectPath!.contains(seg.item.bounds.center)) {\n            if (seg.item.data.type === SHAPE_TYPE.KEYPOINT) {\n              if (isOneGroup(seg.item.data.instanceId, seg.item.data.groupName)) {\n                selectedPoints.add(seg.item as paper.Shape);\n              }\n            } else if (\n              seg.item.data.type === SHAPE_TYPE.RECTANGLE ||\n              seg.item.data.type === SHAPE_TYPE.RECTANGLE_POINT ||\n              seg.item.data.type === SHAPE_TYPE.RECTANGLE_PATH\n            ) {\n              if (isOneGroup(seg.item.parent.data.instanceId, seg.item.parent.data.groupName)) {\n                selectedRectangles.add(seg.item.parent as paper.Group);\n              }\n            }\n          }\n        });\n\n        // selected\n        if (selectedPoints.size) this.editor?.setMultiShapesSelected(Array.from(selectedPoints), CategoryPathShape.CIRCLE);\n        if (selectedRectangles.size) this.editor?.setMultiShapesSelected(Array.from(selectedRectangles), CategoryPathShape.RECTANGLE);\n      }\n      this.selectPath.remove();\n      this.selectPath = null;\n    } else if (this.editor?.canAddShape() && this.editor.activeTool === CategoryPathShape.CIRCLE) {\n      // add point\n      const point = Paper.view.projectToView(event.point);\n      // if (this.editor?.isPointInImage(point)) {\n      this.editor.addKeypoint(point);\n      // }\n    } else if (this.editor && rootStore.review.drawMode) {\n      // clear selection and move next\n      this.editor.props.setNextEmptyShape();\n    }\n    this.dragging = false;\n  };\n\n  handleQa = (result: ReviewResult) => {\n    if (this.editor?.props.selectedShapeStatus) {\n      const { instanceId, groupName, frameIndex, id } = this.editor.props.selectedShapeStatus;\n      let shapeIds = [];\n      if (id !== undefined) {\n        shapeIds = [id];\n      } else if (this.editor?.selectedPoints.length > 0) {\n        shapeIds = this.editor?.selectedPoints.map((point) => point.data.index);\n      } else if (this.editor?.selectedRectangles.length > 0) {\n        shapeIds = this.editor?.selectedRectangles.map((shape) => shape.data.id);\n      }\n      if (shapeIds.length) {\n        shapeIds.sort((a, b) => a - b);\n        if (result !== ReviewResult.REJECT && !rootStore.review.selectedReview) {\n          rootStore.review.setReview(\n            { result },\n            {\n              frameIndex,\n              instanceId,\n              groupName,\n              shapeIds,\n              result\n            }\n          );\n        } else {\n          rootStore.review.setSelectedReview({\n            frameIndex,\n            instanceId,\n            groupName,\n            shapeIds,\n            result\n          });\n        }\n        if ((result === ReviewResult.SUSPEND || result === ReviewResult.APPROVE) && !rootStore.review.selectedReview) {\n          message.success(formatMessage(`QC_SET_${result.toLocaleUpperCase()}`));\n        }\n      }\n    }\n  };\n\n  onKeyDown = ({ event }: { event: KeyboardEvent }) => {\n    if (isInput()) return;\n    const key = event.key.toLowerCase();\n    if (this.editor?.props.isReview && key !== 'v') return;\n    // Judgment modifier keyboard\n    if (event.altKey || event.shiftKey) {\n      return;\n    }\n\n    if (rootStore.review.drawMode) {\n      this.drawOnKeyDown(event, key);\n    } else if (rootStore.review.isEnabled) {\n      this.QaOnKeyDown(event, key);\n    }\n\n    switch (key) {\n      case ' ':\n        event.preventDefault();\n        if (rootStore.review.isEnabled) {\n          this.editor?.props.handleChangeDrawMode(!rootStore.review.drawMode);\n        }\n        break;\n      case 'f':\n        event.preventDefault();\n        if (screenfull.isEnabled) {\n          screenfull.toggle();\n        }\n        break;\n      // case 'g':\n      //   event.preventDefault();\n      //   if (this.editor && this.editor.gridLayer) {\n      //     this.editor.gridLayer.visible = !rootStore.setting.isGridVisible;\n      //   }\n      //   rootStore.setting.setGridVisible(!rootStore.setting.isGridVisible);\n      //   break;\n      case 's':\n        event.preventDefault();\n        this.editor?.props.onSave();\n        break;\n      case 'z':\n        event.preventDefault();\n        if (event.ctrlKey) this.editor?.props.handleUndo();\n        break;\n      case 'y':\n        event.preventDefault();\n        if (event.ctrlKey) this.editor?.props.handleRedo();\n        break;\n      case 'v':\n        if (!rootStore.review.selectedReview) {\n          event.preventDefault();\n          if (event.ctrlKey) {\n            this.editor?.props.setReview();\n          }\n        }\n        break;\n      default:\n    }\n  };\n\n  QaOnKeyDown = (event: KeyboardEvent, key: string) => {\n    if (this.editor?.props.readonly) return;\n    switch (key) {\n      case '2':\n        event.preventDefault();\n        this.handleQa(ReviewResult.REJECT);\n        break;\n      case '1':\n        event.preventDefault();\n        this.handleQa(ReviewResult.APPROVE);\n        break;\n      case '3':\n        event.preventDefault();\n        this.handleQa(ReviewResult.SUSPEND);\n        break;\n      default:\n    }\n  };\n\n  drawOnKeyDown = (event: KeyboardEvent, key: string) => {\n    if (this.editor?.props.readonly) return;\n    switch (key) {\n      case 'delete':\n      case 'backspace':\n        event.preventDefault();\n        this.editor?.deleteSelectedPoints();\n        this.editor?.deleteSelectedRectangle();\n        break;\n      // case 'a':\n      //   event.preventDefault();\n      //   this.editor?.autoAdjust();\n      //   break;\n      // case 'c':\n      //   event.preventDefault();\n      //   this.editor?.switchSmoothMode();\n      //   break;\n      case 'o':\n        event.preventDefault();\n        this.editor?.props.editShapeForm();\n        break;\n      case 'p':\n        event.preventDefault();\n        this.editor?.props.editGroupForm();\n        break;\n      // case 'r':\n      //   event.preventDefault();\n      //   this.editor?.setCategoryAsCircle();\n      //   break;\n      // case 'v':\n      //   event.preventDefault();\n      //   this.editor?.toggleSelectedPointVisibility();\n      //   break;\n      default:\n    }\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}