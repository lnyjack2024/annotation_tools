{"ast":null,"code":"import Worker from './calculate.worker';\nimport { CalculateType, ProjectModel } from './types';\n\n/**\n * 3D X (m)\n * →\n */\nconst PROJECT_X = [-10, 10];\n\n/**\n * 3D Y (m)\n * ↗\n */\nconst PROJECT_Y = [0, 30];\n\n/**\n * 3D Z (m)\n * ↑\n */\nconst PROJECT_Z = 0;\n\n/**\n * step (cm) for 3D points generation, per 2cm one point\n */\nconst PROJECT_STEP = 2;\n\n/**\n * calc the projected point\n * @param point\n * @param baseCameraPoints\n * @param toCameraPoints\n * @param toCameraSize\n */\nfunction getProjectedPoint(point, baseCameraPoints, toCameraPoints, toCameraSize) {\n  if (baseCameraPoints && toCameraSize) {\n    // can project\n    const [x, y] = point;\n    const {\n      width,\n      height\n    } = toCameraSize;\n    let index = 0;\n    let min;\n    for (let i = 0; i < baseCameraPoints.length; i += 1) {\n      const [u, v] = baseCameraPoints[i];\n      const d = (u - x) ** 2 + (v - y) ** 2;\n      if (min === undefined || min > d) {\n        min = d;\n        index = i;\n      }\n    }\n    if (toCameraPoints) {\n      const [toU, toV] = toCameraPoints[index];\n      if (toU >= 0 && toU <= width && toV >= 0 && toV <= height) {\n        return [toU, toV];\n      }\n      return undefined;\n    }\n\n    // simply map to camera points\n    const [startX, endX] = PROJECT_X;\n    const [startY, endY] = PROJECT_Y;\n    const xCount = (endX - startX) * 100 / PROJECT_STEP;\n    const yCount = (endY - startY) * 100 / PROJECT_STEP;\n    const ox = index % xCount;\n    const oy = Math.floor(index / xCount);\n    const cx = toCameraSize.width / xCount * ox;\n    const cy = toCameraSize.height / yCount * oy;\n    return [cx, cy];\n  }\n  return undefined;\n}\nexport default class VehicleHelper {\n  constructor() {\n    /**\n     * calculator\n     */\n    this.calculator = new Worker();\n    /**\n     * vehicle points (project base 3D points)\n     */\n    this.vehiclePoints = [];\n    /**\n     * calibration data (reference to CamerasMapping)\n     */\n    this.calibrations = {};\n    /**\n     * camera size\n     */\n    this.cameraSizes = {};\n    /**\n     * vehicle points -> camera points\n     */\n    this.cachedCameraPoints = {};\n    /**\n     * frames finish camera points calculation\n     */\n    this.frameCacheStatus = {};\n    /**\n     * frame count with calibrations\n     */\n    this.frameCount = 0;\n    this.initCalculator();\n    this.initVehiclePoints();\n  }\n\n  /**\n   * init calculator worker\n   */\n  initCalculator() {\n    this.calculator.addEventListener('message', e => {\n      const {\n        type,\n        data\n      } = e.data;\n      switch (type) {\n        case CalculateType.VEHICLE_TO_CAMERA_FINISH:\n          {\n            const {\n              frameIndex,\n              cameraPoints\n            } = data;\n            this.cachedCameraPoints[frameIndex] = {\n              ...this.cachedCameraPoints[frameIndex],\n              ...cameraPoints\n            };\n            this.frameCacheStatus[frameIndex] = false;\n            const nextFrame = frameIndex + 1;\n            if (nextFrame < this.frameCount && this.frameCacheStatus[nextFrame] === undefined) {\n              this.cacheCameraPoints(nextFrame);\n            }\n            break;\n          }\n        default:\n      }\n    });\n  }\n\n  /**\n   * init vechicle points\n   */\n  initVehiclePoints() {\n    this.vehiclePoints = [];\n    const [startX, endX] = PROJECT_X;\n    const [startY, endY] = PROJECT_Y;\n    const cmStartX = startX * 100;\n    const cmEndX = endX * 100;\n    const cmStartY = startY * 100;\n    const cmEndY = endY * 100;\n    for (let i = cmEndY; i > cmStartY; i -= PROJECT_STEP) {\n      for (let j = cmStartX; j < cmEndX; j += PROJECT_STEP) {\n        this.vehiclePoints.push([j / 100, i / 100, PROJECT_Z / 100]);\n      }\n    }\n  }\n\n  /**\n   * set calibration for camera\n   * @param camera\n   * @param calibrations\n   */\n  setCalibrations(camera, calibrations) {\n    this.calibrations[camera] = calibrations;\n\n    // update max frame count\n    if (Array.isArray(calibrations) && calibrations.length > this.frameCount) {\n      this.frameCount = calibrations.length;\n    }\n  }\n\n  /**\n   * set camera size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  setCameraSize(camera, frameIndex, width, height) {\n    if (!this.cameraSizes[camera]) {\n      this.cameraSizes[camera] = {};\n    }\n    this.cameraSizes[camera][frameIndex] = {\n      width,\n      height\n    };\n  }\n\n  /**\n   * set frame index\n   * @param frameIndex\n   */\n  setFrame(frameIndex) {\n    if (this.frameCacheStatus[frameIndex] === undefined) {\n      this.cacheCameraPoints(frameIndex);\n    }\n  }\n\n  /**\n   * is camera points cached\n   * @param frameIndex\n   */\n  isCameraPointsCached(frameIndex) {\n    return this.frameCacheStatus[frameIndex] === false;\n  }\n\n  /**\n   * cache camera points\n   * @param frameIndex\n   */\n  cacheCameraPoints(frameIndex) {\n    this.cachedCameraPoints[frameIndex] = {};\n    this.frameCacheStatus[frameIndex] = true;\n    const cameraCalibrations = {};\n    const allCameras = Object.keys(this.calibrations);\n    for (let i = 0; i < allCameras.length; i += 1) {\n      const camera = allCameras[i];\n      const calibs = this.calibrations[camera];\n      if (Array.isArray(calibs)) {\n        const calib = calibs[frameIndex];\n        if (calib && calib.model !== ProjectModel.DEFAULT) {\n          cameraCalibrations[camera] = calib;\n        }\n      } else if (calibs && calibs.model !== ProjectModel.DEFAULT) {\n        var _this$cachedCameraPoi;\n        // calibration is the same in all frames\n        const cachedCameraPoints = (_this$cachedCameraPoi = this.cachedCameraPoints[0]) === null || _this$cachedCameraPoi === void 0 ? void 0 : _this$cachedCameraPoi[camera];\n        if (cachedCameraPoints) {\n          // use cached camera points\n          this.cachedCameraPoints[frameIndex][camera] = cachedCameraPoints;\n        } else {\n          // not cached, should calculate\n          cameraCalibrations[camera] = calibs;\n        }\n      }\n    }\n    this.calculator.postMessage({\n      type: CalculateType.VEHICLE_TO_CAMERA,\n      data: {\n        frameIndex,\n        cameraCalibrations,\n        vehiclePoints: this.vehiclePoints\n      }\n    });\n  }\n\n  /**\n   * project point from base camera to camera\n   * @param point\n   * @param frameIndex\n   * @param baseCamera\n   * @param toCamera\n   */\n  async projectPoint(point, frameIndex, baseCamera, toCamera) {\n    return new Promise(resolve => {\n      if (!this.isCameraPointsCached(frameIndex)) {\n        // listener to calculation finish\n        const listener = e => {\n          const {\n            type,\n            data\n          } = e.data;\n          if (type === CalculateType.VEHICLE_TO_CAMERA_FINISH && data.frameIndex === frameIndex) {\n            var _this$cachedCameraPoi2, _this$cachedCameraPoi3, _this$cameraSizes$toC;\n            this.calculator.removeEventListener('message', listener);\n            const projectedPoint = getProjectedPoint(point, (_this$cachedCameraPoi2 = this.cachedCameraPoints[frameIndex]) === null || _this$cachedCameraPoi2 === void 0 ? void 0 : _this$cachedCameraPoi2[baseCamera], (_this$cachedCameraPoi3 = this.cachedCameraPoints[frameIndex]) === null || _this$cachedCameraPoi3 === void 0 ? void 0 : _this$cachedCameraPoi3[toCamera], (_this$cameraSizes$toC = this.cameraSizes[toCamera]) === null || _this$cameraSizes$toC === void 0 ? void 0 : _this$cameraSizes$toC[frameIndex]);\n            resolve(projectedPoint);\n          }\n        };\n        this.calculator.addEventListener('message', listener);\n      } else {\n        var _this$cachedCameraPoi4, _this$cachedCameraPoi5, _this$cameraSizes$toC2;\n        const projectedPoint = getProjectedPoint(point, (_this$cachedCameraPoi4 = this.cachedCameraPoints[frameIndex]) === null || _this$cachedCameraPoi4 === void 0 ? void 0 : _this$cachedCameraPoi4[baseCamera], (_this$cachedCameraPoi5 = this.cachedCameraPoints[frameIndex]) === null || _this$cachedCameraPoi5 === void 0 ? void 0 : _this$cachedCameraPoi5[toCamera], (_this$cameraSizes$toC2 = this.cameraSizes[toCamera]) === null || _this$cameraSizes$toC2 === void 0 ? void 0 : _this$cameraSizes$toC2[frameIndex]);\n        resolve(projectedPoint);\n      }\n    });\n  }\n}","map":{"version":3,"names":["Worker","CalculateType","ProjectModel","PROJECT_X","PROJECT_Y","PROJECT_Z","PROJECT_STEP","getProjectedPoint","point","baseCameraPoints","toCameraPoints","toCameraSize","x","y","width","height","index","min","i","length","u","v","d","undefined","toU","toV","startX","endX","startY","endY","xCount","yCount","ox","oy","Math","floor","cx","cy","VehicleHelper","constructor","calculator","vehiclePoints","calibrations","cameraSizes","cachedCameraPoints","frameCacheStatus","frameCount","initCalculator","initVehiclePoints","addEventListener","e","type","data","VEHICLE_TO_CAMERA_FINISH","frameIndex","cameraPoints","nextFrame","cacheCameraPoints","cmStartX","cmEndX","cmStartY","cmEndY","j","push","setCalibrations","camera","Array","isArray","setCameraSize","setFrame","isCameraPointsCached","cameraCalibrations","allCameras","Object","keys","calibs","calib","model","DEFAULT","_this$cachedCameraPoi","postMessage","VEHICLE_TO_CAMERA","projectPoint","baseCamera","toCamera","Promise","resolve","listener","_this$cachedCameraPoi2","_this$cachedCameraPoi3","_this$cameraSizes$toC","removeEventListener","projectedPoint","_this$cachedCameraPoi4","_this$cachedCameraPoi5","_this$cameraSizes$toC2"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/cameras-mapping/VehicleHelper.ts"],"sourcesContent":["import Worker from './calculate.worker';\nimport { CalculateType, Calibration, CameraCalibrations, CameraSize, CameraSizeByFrame, Point2D, Point3D, ProjectModel } from './types';\n\n/**\n * 3D X (m)\n * →\n */\nconst PROJECT_X = [-10, 10];\n\n/**\n * 3D Y (m)\n * ↗\n */\nconst PROJECT_Y = [0, 30];\n\n/**\n * 3D Z (m)\n * ↑\n */\nconst PROJECT_Z = 0;\n\n/**\n * step (cm) for 3D points generation, per 2cm one point\n */\nconst PROJECT_STEP = 2;\n\n/**\n * calc the projected point\n * @param point\n * @param baseCameraPoints\n * @param toCameraPoints\n * @param toCameraSize\n */\nfunction getProjectedPoint(\n  point: Point2D,\n  baseCameraPoints?: Point2D[],\n  toCameraPoints?: Point2D[],\n  toCameraSize?: CameraSize,\n): Point2D | undefined {\n  if (baseCameraPoints && toCameraSize) {\n    // can project\n    const [x, y] = point;\n    const { width, height } = toCameraSize;\n\n    let index = 0;\n    let min: number | undefined;\n    for (let i = 0; i < baseCameraPoints.length; i += 1) {\n      const [u, v] = baseCameraPoints[i];\n      const d = (u - x) ** 2 + (v - y) ** 2;\n      if (min === undefined || min > d) {\n        min = d;\n        index = i;\n      }\n    }\n\n    if (toCameraPoints) {\n      const [toU, toV] = toCameraPoints[index];\n      if (toU >= 0 && toU <= width && toV >= 0 && toV <= height) {\n        return [toU, toV];\n      }\n      return undefined;\n    }\n\n    // simply map to camera points\n    const [startX, endX] = PROJECT_X;\n    const [startY, endY] = PROJECT_Y;\n    const xCount = ((endX - startX) * 100) / PROJECT_STEP;\n    const yCount = ((endY - startY) * 100) / PROJECT_STEP;\n    const ox = index % xCount;\n    const oy = Math.floor(index / xCount);\n    const cx = (toCameraSize.width / xCount) * ox;\n    const cy = (toCameraSize.height / yCount) * oy;\n    return [cx, cy];\n  }\n  return undefined;\n}\n\nexport default class VehicleHelper {\n  /**\n   * calculator\n   */\n  calculator = new Worker();\n\n  /**\n   * vehicle points (project base 3D points)\n   */\n  vehiclePoints: Point3D[] = [];\n\n  /**\n   * calibration data (reference to CamerasMapping)\n   */\n  calibrations: Record<string, CameraCalibrations> = {};\n\n  /**\n   * camera size\n   */\n  cameraSizes: Record<string, CameraSizeByFrame> = {};\n\n  /**\n   * vehicle points -> camera points\n   */\n  cachedCameraPoints: {\n    [frameIndex: number]: {\n      [camera: string]: Point2D[];\n    }\n  } = {};\n\n  /**\n   * frames finish camera points calculation\n   */\n  frameCacheStatus: Record<number, boolean> = {};\n\n  /**\n   * frame count with calibrations\n   */\n  frameCount = 0;\n\n  constructor() {\n    this.initCalculator();\n    this.initVehiclePoints();\n  }\n\n  /**\n   * init calculator worker\n   */\n  initCalculator() {\n    this.calculator.addEventListener('message', (e: MessageEvent) => {\n      const { type, data } = e.data;\n      switch (type) {\n        case CalculateType.VEHICLE_TO_CAMERA_FINISH: {\n          const { frameIndex, cameraPoints } = data;\n          this.cachedCameraPoints[frameIndex] = {\n            ...this.cachedCameraPoints[frameIndex],\n            ...cameraPoints,\n          };\n          this.frameCacheStatus[frameIndex] = false;\n\n          const nextFrame = frameIndex + 1;\n          if (nextFrame < this.frameCount && this.frameCacheStatus[nextFrame] === undefined) {\n            this.cacheCameraPoints(nextFrame);\n          }\n          break;\n        }\n        default:\n      }\n    });\n  }\n\n  /**\n   * init vechicle points\n   */\n  initVehiclePoints() {\n    this.vehiclePoints = [];\n    const [startX, endX] = PROJECT_X;\n    const [startY, endY] = PROJECT_Y;\n    const cmStartX = startX * 100;\n    const cmEndX = endX * 100;\n    const cmStartY = startY * 100;\n    const cmEndY = endY * 100;\n    for (let i = cmEndY; i > cmStartY; i -= PROJECT_STEP) {\n      for (let j = cmStartX; j < cmEndX; j += PROJECT_STEP) {\n        this.vehiclePoints.push([j / 100, i / 100, PROJECT_Z / 100]);\n      }\n    }\n  }\n\n  /**\n   * set calibration for camera\n   * @param camera\n   * @param calibrations\n   */\n  setCalibrations(camera: string, calibrations: CameraCalibrations) {\n    this.calibrations[camera] = calibrations;\n\n    // update max frame count\n    if (Array.isArray(calibrations) && calibrations.length > this.frameCount) {\n      this.frameCount = calibrations.length;\n    }\n  }\n\n  /**\n   * set camera size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  setCameraSize(camera: string, frameIndex: number, width: number, height: number) {\n    if (!this.cameraSizes[camera]) {\n      this.cameraSizes[camera] = {};\n    }\n    this.cameraSizes[camera][frameIndex] = { width, height };\n  }\n\n  /**\n   * set frame index\n   * @param frameIndex\n   */\n  setFrame(frameIndex: number) {\n    if (this.frameCacheStatus[frameIndex] === undefined) {\n      this.cacheCameraPoints(frameIndex);\n    }\n  }\n\n  /**\n   * is camera points cached\n   * @param frameIndex\n   */\n  isCameraPointsCached(frameIndex: number) {\n    return this.frameCacheStatus[frameIndex] === false;\n  }\n\n  /**\n   * cache camera points\n   * @param frameIndex\n   */\n  cacheCameraPoints(frameIndex: number) {\n    this.cachedCameraPoints[frameIndex] = {};\n    this.frameCacheStatus[frameIndex] = true;\n\n    const cameraCalibrations: Record<string, Calibration> = {};\n    const allCameras = Object.keys(this.calibrations);\n    for (let i = 0; i < allCameras.length; i += 1) {\n      const camera = allCameras[i];\n      const calibs = this.calibrations[camera];\n      if (Array.isArray(calibs)) {\n        const calib = calibs[frameIndex];\n        if (calib && calib.model !== ProjectModel.DEFAULT) {\n          cameraCalibrations[camera] = calib;\n        }\n      } else if (calibs && calibs.model !== ProjectModel.DEFAULT) {\n        // calibration is the same in all frames\n        const cachedCameraPoints = this.cachedCameraPoints[0]?.[camera];\n        if (cachedCameraPoints) {\n          // use cached camera points\n          this.cachedCameraPoints[frameIndex][camera] = cachedCameraPoints;\n        } else {\n          // not cached, should calculate\n          cameraCalibrations[camera] = calibs;\n        }\n      }\n    }\n\n    this.calculator.postMessage({\n      type: CalculateType.VEHICLE_TO_CAMERA,\n      data: {\n        frameIndex,\n        cameraCalibrations,\n        vehiclePoints: this.vehiclePoints,\n      },\n    });\n  }\n\n  /**\n   * project point from base camera to camera\n   * @param point\n   * @param frameIndex\n   * @param baseCamera\n   * @param toCamera\n   */\n  async projectPoint(point: Point2D, frameIndex: number, baseCamera: string, toCamera: string): Promise<Point2D | undefined> {\n    return new Promise((resolve) => {\n      if (!this.isCameraPointsCached(frameIndex)) {\n        // listener to calculation finish\n        const listener = (e: MessageEvent) => {\n          const { type, data } = e.data;\n          if (type === CalculateType.VEHICLE_TO_CAMERA_FINISH && data.frameIndex === frameIndex) {\n            this.calculator!.removeEventListener('message', listener);\n            const projectedPoint = getProjectedPoint(\n              point,\n              this.cachedCameraPoints[frameIndex]?.[baseCamera],\n              this.cachedCameraPoints[frameIndex]?.[toCamera],\n              this.cameraSizes[toCamera]?.[frameIndex],\n            );\n            resolve(projectedPoint);\n          }\n        };\n        this.calculator!.addEventListener('message', listener);\n      } else {\n        const projectedPoint = getProjectedPoint(\n          point,\n          this.cachedCameraPoints[frameIndex]?.[baseCamera],\n          this.cachedCameraPoints[frameIndex]?.[toCamera],\n          this.cameraSizes[toCamera]?.[frameIndex],\n        );\n        resolve(projectedPoint);\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}