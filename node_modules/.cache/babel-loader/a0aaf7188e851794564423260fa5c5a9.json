{"ast":null,"code":"import { Container, Point } from 'pixi.js';\nimport { ShapeType } from './types';\nimport ShapeGraphics from './ShapeGraphics';\nexport default class Layer extends Container {\n  constructor(...args) {\n    super(...args);\n    /**\n     * point snapped to shape vertexes or edges\n     */\n    this.snappingPoint = null;\n  }\n  /**\n   * set snapping point\n   * @param point\n   */\n  setSnappingPoint(point) {\n    this.snappingPoint = point;\n  }\n\n  /**\n   * snap to rectangles\n   */\n  snapToRectangle(point, tolerance) {\n    let {\n      x,\n      y\n    } = point;\n    let horizontal;\n    let vertical;\n    let horizontalSize;\n    let verticalSize;\n    const findNearestRect = children => {\n      for (let i = 0; i < children.length; i += 1) {\n        const child = children[i];\n        if (child.visible) {\n          if (child instanceof ShapeGraphics) {\n            if (child.shape.finished && !child.shape.resizing && !child.shape.dragging && child.shape.shapeType === ShapeType.RECTANGLE && child.shape.rotation % (Math.PI / 2) === 0) {\n              const {\n                left,\n                top,\n                right,\n                bottom\n              } = child.shape.shapeBounds;\n              const leftSize = Math.abs(left - x);\n              const rightSize = Math.abs(right - x);\n              const topSize = Math.abs(top - y);\n              const bottomSize = Math.abs(bottom - y);\n              if ((!verticalSize || leftSize < verticalSize) && leftSize < tolerance) {\n                vertical = left;\n                verticalSize = leftSize;\n              }\n              if ((!verticalSize || rightSize < verticalSize) && rightSize < tolerance) {\n                vertical = right;\n                verticalSize = rightSize;\n              }\n              if ((!horizontalSize || topSize < horizontalSize) && topSize < tolerance) {\n                horizontal = top;\n                horizontalSize = topSize;\n              }\n              if ((!horizontalSize || bottomSize < horizontalSize) && bottomSize < tolerance) {\n                horizontal = bottom;\n                horizontalSize = bottomSize;\n              }\n            }\n          } else if (child instanceof Container) {\n            findNearestRect(child.children);\n          }\n        }\n      }\n    };\n    findNearestRect(this.children);\n    if (horizontal !== undefined) {\n      y = horizontal;\n    }\n    if (vertical !== undefined) {\n      x = vertical;\n    }\n    return new Point(x, y);\n  }\n}","map":{"version":3,"names":["Container","Point","ShapeType","ShapeGraphics","Layer","constructor","args","snappingPoint","setSnappingPoint","point","snapToRectangle","tolerance","x","y","horizontal","vertical","horizontalSize","verticalSize","findNearestRect","children","i","length","child","visible","shape","finished","resizing","dragging","shapeType","RECTANGLE","rotation","Math","PI","left","top","right","bottom","shapeBounds","leftSize","abs","rightSize","topSize","bottomSize","undefined"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/Layer.ts"],"sourcesContent":["import { Container, Point, DisplayObject } from 'pixi.js';\nimport { ShapeType } from './types';\nimport ShapeGraphics from './ShapeGraphics';\n\nexport default class Layer extends Container {\n  /**\n   * point snapped to shape vertexes or edges\n   */\n  snappingPoint: Point | null = null;\n\n  /**\n   * set snapping point\n   * @param point\n   */\n  setSnappingPoint(point: Point | null) {\n    this.snappingPoint = point;\n  }\n\n  /**\n   * snap to rectangles\n   */\n  snapToRectangle(point: Point, tolerance: number) {\n    let { x, y } = point;\n\n    let horizontal: number | undefined;\n    let vertical: number | undefined;\n    let horizontalSize: number | undefined;\n    let verticalSize: number | undefined;\n    const findNearestRect = (children: DisplayObject[]) => {\n      for (let i = 0; i < children.length; i += 1) {\n        const child = children[i];\n        if (child.visible) {\n          if (child instanceof ShapeGraphics) {\n            if (child.shape.finished && !child.shape.resizing && !child.shape.dragging\n              && child.shape.shapeType === ShapeType.RECTANGLE && child.shape.rotation % (Math.PI / 2) === 0) {\n              const { left, top, right, bottom } = child.shape.shapeBounds;\n              const leftSize = Math.abs(left - x);\n              const rightSize = Math.abs(right - x);\n              const topSize = Math.abs(top - y);\n              const bottomSize = Math.abs(bottom - y);\n              if ((!verticalSize || leftSize < verticalSize) && leftSize < tolerance) {\n                vertical = left;\n                verticalSize = leftSize;\n              }\n              if ((!verticalSize || rightSize < verticalSize) && rightSize < tolerance) {\n                vertical = right;\n                verticalSize = rightSize;\n              }\n              if ((!horizontalSize || topSize < horizontalSize) && topSize < tolerance) {\n                horizontal = top;\n                horizontalSize = topSize;\n              }\n              if ((!horizontalSize || bottomSize < horizontalSize) && bottomSize < tolerance) {\n                horizontal = bottom;\n                horizontalSize = bottomSize;\n              }\n            }\n          } else if (child instanceof Container) {\n            findNearestRect(child.children);\n          }\n        }\n      }\n    };\n    findNearestRect(this.children);\n\n    if (horizontal !== undefined) {\n      y = horizontal;\n    }\n    if (vertical !== undefined) {\n      x = vertical;\n    }\n    return new Point(x, y);\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,KAAK,QAAuB,SAAS;AACzD,SAASC,SAAS,QAAQ,SAAS;AACnC,OAAOC,aAAa,MAAM,iBAAiB;AAE3C,eAAe,MAAMC,KAAK,SAASJ,SAAS,CAAC;EAAAK,YAAA,GAAAC,IAAA;IAAA,SAAAA,IAAA;IAC3C;AACF;AACA;IAFE,KAGAC,aAAa,GAAiB,IAAI;EAAA;EAElC;AACF;AACA;AACA;EACEC,gBAAgBA,CAACC,KAAmB,EAAE;IACpC,IAAI,CAACF,aAAa,GAAGE,KAAK;EAC5B;;EAEA;AACF;AACA;EACEC,eAAeA,CAACD,KAAY,EAAEE,SAAiB,EAAE;IAC/C,IAAI;MAAEC,CAAC;MAAEC;IAAE,CAAC,GAAGJ,KAAK;IAEpB,IAAIK,UAA8B;IAClC,IAAIC,QAA4B;IAChC,IAAIC,cAAkC;IACtC,IAAIC,YAAgC;IACpC,MAAMC,eAAe,GAAIC,QAAyB,IAAK;MACrD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACE,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;QAC3C,MAAME,KAAK,GAAGH,QAAQ,CAACC,CAAC,CAAC;QACzB,IAAIE,KAAK,CAACC,OAAO,EAAE;UACjB,IAAID,KAAK,YAAYnB,aAAa,EAAE;YAClC,IAAImB,KAAK,CAACE,KAAK,CAACC,QAAQ,IAAI,CAACH,KAAK,CAACE,KAAK,CAACE,QAAQ,IAAI,CAACJ,KAAK,CAACE,KAAK,CAACG,QAAQ,IACrEL,KAAK,CAACE,KAAK,CAACI,SAAS,KAAK1B,SAAS,CAAC2B,SAAS,IAAIP,KAAK,CAACE,KAAK,CAACM,QAAQ,IAAIC,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;cAChG,MAAM;gBAAEC,IAAI;gBAAEC,GAAG;gBAAEC,KAAK;gBAAEC;cAAO,CAAC,GAAGd,KAAK,CAACE,KAAK,CAACa,WAAW;cAC5D,MAAMC,QAAQ,GAAGP,IAAI,CAACQ,GAAG,CAACN,IAAI,GAAGrB,CAAC,CAAC;cACnC,MAAM4B,SAAS,GAAGT,IAAI,CAACQ,GAAG,CAACJ,KAAK,GAAGvB,CAAC,CAAC;cACrC,MAAM6B,OAAO,GAAGV,IAAI,CAACQ,GAAG,CAACL,GAAG,GAAGrB,CAAC,CAAC;cACjC,MAAM6B,UAAU,GAAGX,IAAI,CAACQ,GAAG,CAACH,MAAM,GAAGvB,CAAC,CAAC;cACvC,IAAI,CAAC,CAACI,YAAY,IAAIqB,QAAQ,GAAGrB,YAAY,KAAKqB,QAAQ,GAAG3B,SAAS,EAAE;gBACtEI,QAAQ,GAAGkB,IAAI;gBACfhB,YAAY,GAAGqB,QAAQ;cACzB;cACA,IAAI,CAAC,CAACrB,YAAY,IAAIuB,SAAS,GAAGvB,YAAY,KAAKuB,SAAS,GAAG7B,SAAS,EAAE;gBACxEI,QAAQ,GAAGoB,KAAK;gBAChBlB,YAAY,GAAGuB,SAAS;cAC1B;cACA,IAAI,CAAC,CAACxB,cAAc,IAAIyB,OAAO,GAAGzB,cAAc,KAAKyB,OAAO,GAAG9B,SAAS,EAAE;gBACxEG,UAAU,GAAGoB,GAAG;gBAChBlB,cAAc,GAAGyB,OAAO;cAC1B;cACA,IAAI,CAAC,CAACzB,cAAc,IAAI0B,UAAU,GAAG1B,cAAc,KAAK0B,UAAU,GAAG/B,SAAS,EAAE;gBAC9EG,UAAU,GAAGsB,MAAM;gBACnBpB,cAAc,GAAG0B,UAAU;cAC7B;YACF;UACF,CAAC,MAAM,IAAIpB,KAAK,YAAYtB,SAAS,EAAE;YACrCkB,eAAe,CAACI,KAAK,CAACH,QAAQ,CAAC;UACjC;QACF;MACF;IACF,CAAC;IACDD,eAAe,CAAC,IAAI,CAACC,QAAQ,CAAC;IAE9B,IAAIL,UAAU,KAAK6B,SAAS,EAAE;MAC5B9B,CAAC,GAAGC,UAAU;IAChB;IACA,IAAIC,QAAQ,KAAK4B,SAAS,EAAE;MAC1B/B,CAAC,GAAGG,QAAQ;IACd;IACA,OAAO,IAAId,KAAK,CAACW,CAAC,EAAEC,CAAC,CAAC;EACxB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module"}