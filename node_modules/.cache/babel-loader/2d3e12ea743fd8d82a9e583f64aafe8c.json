{"ast":null,"code":"import{makeObservable,observable,action}from'mobx';import{message}from'antd';import i18n from'../locales';import{getUnderShape,getUpperShape}from'../utils';import{ReviewMode}from'../types';import{CAMERA_VIEW_LABELS}from'../constants';import ShapeFactory from'../../common/shapes/ShapeFactory';import{ShapeType}from'../../common/shapes/types';import{EventAction,BorderStyle}from'../../common/shapes/Shape';import Polygon from'../../common/shapes/Polygon';import Line from'../../common/shapes/Line';import Label from'../../common/shapes/label/Label';/**\n * store for shapes in current camera & current frame\n * @class\n */export default class ShapeStore{/**\n   * is drawing shape\n   * @getter\n   */get isDrawing(){return this.drawingShape!==null;}constructor(rootStore){var _this=this;/**\n   * root store\n   */this.rootStore=void 0;/**\n   * app\n   */this.app=void 0;/**\n   * current layer\n   */this.currentLayer=void 0;/**\n   * shapes in current frame\n   */this.shapes={};/**\n   * currently drawing shape\n   */this.drawingShape=null;/**\n   * currently selected shapes\n   */this.selectedShapes=[];/**\n   * currently selected shape vertex index for polygon & line\n   */this.selectedPointIndex=-1;/**\n   * predicted shapes\n   */this.predictedShapes={};/**\n   * hovered shape id\n   */this.hoveredShapeId='';/**\n   * waiting merge polygon\n   */this.pendingMergePolygon='';/**\n   * is deleting\n   */this.deleting=false;/**\n   * shape display config\n   */this.config={fill:true,alpha:20,showVertex:false,showVertexOrder:false};/**\n   * default config from payload\n   */this.defaultConfig=this.config;/**\n   * clear shapes\n   */this.clearShapes=()=>{Object.values(this.shapes).forEach(_ref=>{let{shape}=_ref;shape.destroy();});this.shapes={};this.drawingShape=null;this.selectedShapes=[];this.clearPredictedShapes();this.selectedPointIndex=-1;};/**\n   * clear predicted shapes\n   */this.clearPredictedShapes=()=>{Object.values(this.predictedShapes).forEach(_ref2=>{let{shape}=_ref2;shape.destroy();});this.predictedShapes={};};/**\n   * is predicted shape\n   * @param s\n   */this.isPredictedShape=s=>Object.values(this.predictedShapes).findIndex(_ref3=>{let{shape}=_ref3;return shape===s;})>=0;/**\n   * get shape by instance item\n   * @param instanceItem\n   */this.getShapeByInstanceItem=function(instanceItem){let camera=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_this.rootStore.frame.currentCamera;const shapeItem=Object.values(_this.shapes).find(i=>i.camera===camera&&i.instanceItem===instanceItem);if(shapeItem){return shapeItem.shape;}return undefined;};/**\n   * get shapes by instance items\n   * @param instanceItems\n   * @param camera\n   */this.getShapesByInstanceItems=function(instanceItems){let camera=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_this.rootStore.frame.currentCamera;const shapeItems=Object.values(_this.shapes).filter(i=>i.camera===camera&&instanceItems.indexOf(i.instanceItem)>=0);return shapeItems.map(i=>i.shape);};/**\n   * get shapes for one camera\n   * @param camera\n   */this.getShapesForCamera=camera=>Object.values(this.shapes).filter(s=>s.camera===camera);/**\n   * update shapes interactive\n   * @param interactive\n   * @param ignoreIds\n   */this.updateShapesInteractive=(interactive,ignoreIds)=>{Object.values(this.shapes).forEach(_ref4=>{let{shape}=_ref4;if(ignoreIds&&ignoreIds.includes(shape.uid)){return;}shape.interactive=interactive;if(interactive&&this.selectedShapes.indexOf(shape)>=0){shape.selected=true;}});};/**\n   * redraw shapes label\n   */this.redrawShapesLabel=()=>{Object.values(this.shapes).forEach(_ref5=>{let{shape}=_ref5;shape.drawShapeLabel();});Object.values(this.predictedShapes).forEach(_ref6=>{let{shape}=_ref6;shape.drawShapeLabel();});};/**\n   * setup shapes for current frame\n   */this.setupShapes=()=>{this.clearShapes();const{cameraViews,currentFrame,cameraNames,getImageBoundsForCamera}=this.rootStore.frame;const allShapeOrders={};const noOrderShapes={};cameraNames.forEach(cameraName=>{allShapeOrders[cameraName]=new Set();noOrderShapes[cameraName]=[];});const startOrder=0;Object.values(this.rootStore.instance.instances).forEach(instance=>{Object.values(instance.items).forEach(item=>{Object.values(item.cameras).forEach(_ref7=>{let{camera}=_ref7;const{frames}=item.cameras[camera];const cameraView=cameraViews[camera];if(frames[currentFrame]&&cameraView&&!cameraView.imageLoadError){const shape=this.createShape(cameraView.shapesLayer,getImageBoundsForCamera(camera),item.categoryItemRef.displayColor,instance.category,item.name,frames[currentFrame].shapeType,frames[currentFrame].shape,frames[currentFrame].order,item.label,camera);if(shape.destroyed){// delete instance item\nthis.rootStore.instance.deleteInstanceItemByFrame(item,currentFrame,camera);return;}if(this.rootStore.readonly){shape.editable=false;}this.addShapeListeners(shape);this.shapes[shape.uid]={shape,camera,instanceItem:item};const{order}=frames[currentFrame];if(typeof order==='number'&&order>=startOrder&&!allShapeOrders[camera].has(order)){// update next shape order\nshape.order=order;}else{// add to temp array\nnoOrderShapes[camera].push({frameData:frames[currentFrame],shape});}}});});});Object.keys(noOrderShapes).forEach(cameraName=>{noOrderShapes[cameraName].forEach(_ref8=>{let{frameData,shape}=_ref8;// new order\nshape.order=this.rootStore.frame.getNextShapeOrder(currentFrame,cameraName);frameData.order=shape.order;});});};/**\n   * select shapes\n   * @param shapes\n   */this.selectShapes=shapes=>{if(this.selectedPointIndex>=0){// has point selected\nif(this.selectedShapes.length===1&&shapes.length===1&&this.selectedShapes[0]===shapes[0]){// same shape, do not unselect\nreturn;}this.selectedPointIndex=-1;}this.selectedShapes.forEach(shape=>{if(shapes.indexOf(shape)<0){// not selected any more\nshape.selected=false;}});this.selectedShapes=[...shapes];this.selectedShapes.forEach(shape=>{shape.selected=true;});};/**\n   * select shape by instance item\n   * @param instanceItem\n   */this.selectShapeByInstanceItem=instanceItem=>{const instanceItems=Array.isArray(instanceItem)?instanceItem:[...(instanceItem?[instanceItem]:[])];const shapes=this.getShapesByInstanceItems(instanceItems);this.selectShapes(shapes);const instancesSet=new Set(instanceItems.map(i=>i.instance));this.updateShapesInInstance(Array.from(instancesSet));this.predict();};/**\n   * click to unselect shape\n   */this.unselectShape=()=>{if(this.rootStore.config.addMode){return;}this.selectedShapes.forEach(shape=>{shape.selected=false;});this.selectedShapes=[];this.rootStore.instance.selectInstance(null);};/**\n   * update shape border color\n   * @param instance\n   */this.updateShapesInInstance=instance=>{const instances=Array.isArray(instance)?instance:[...(instance?[instance]:[])];Object.values(this.shapes).forEach(_ref9=>{let{shape,instanceItem}=_ref9;if(instances.indexOf(instanceItem.instance)>=0){shape.borderColor=0xFFFF00;if(shape.shapeType===ShapeType.DOT){shape.color=0xFFFF00;}}else{shape.borderColor=shape.originColors.borderColor;if(shape.shapeType===ShapeType.DOT){shape.color=shape.originColors.color;}}});};/**\n   * click to draw a shape\n   * @param point\n   * @param shapeContainer\n   * @param imageBounds\n   * @param finishCallback\n   */this.addShape=(point,shapeContainer,imageBounds,finishCallback)=>{if(this.rootStore.initialized&&this.rootStore.config.addMode&&!this.drawingShape){this.drawingShape=this.createShape(shapeContainer||this.currentLayer,imageBounds||this.rootStore.frame.imageBounds,this.rootStore.ontology.selectedCategoryItem.displayColor,this.rootStore.ontology.selectedCategory.className,this.rootStore.ontology.selectedCategoryItem.name);// add listeners\nthis.drawingShape.on(EventAction.FINISHED,(shape,otherShapeData)=>{// remove listeners after creating\nshape.off(EventAction.FINISHED);shape.off(EventAction.REMOVED);this.drawingShape=null;this.rootStore.config.setAddMode(false);// add shape to instance item\nthis.addShapeToCurrentInstanceItem(shape,otherShapeData);// finish creating\n// if (finishCallback) {\n//   finishCallback();\n// }\n});this.drawingShape.on(EventAction.REMOVED,()=>{this.drawingShape=null;});// start create\nthis.drawingShape.create(point);return this.drawingShape;}return null;};/**\n   * add shape to current instance item\n   * @param shape\n   */this.addShapeToCurrentInstanceItem=(shape,otherShapeData)=>{const{currentCamera,currentFrame}=this.rootStore.frame;const instanceItem=this.rootStore.instance.getCurrentInstanceItem();const data=shape.getData();const prevBasicInfo=instanceItem.instance.getBasicInfo();const{prevState:prevStateItem,currState:currStateItem}=instanceItem.addShape(currentCamera,currentFrame,true,shape.shapeType,data,shape.order);const basicInfo=instanceItem.instance.getBasicInfo();const attributes=instanceItem.cameras[currentCamera].frames[currentFrame].attributes;const instanceState={[prevBasicInfo.id]:{prev:{...prevBasicInfo,children:prevStateItem?[prevStateItem]:[]},curr:{...basicInfo,children:currStateItem?[currStateItem]:[]}}};if(otherShapeData){otherShapeData.forEach(shapeData=>{const otherInstanceItem=this.rootStore.instance.getCurrentInstanceItem();const prevInfo=otherInstanceItem.instance.getBasicInfo();if(otherInstanceItem.instance!==instanceItem.instance){otherInstanceItem.instance.setAttributes(instanceItem.instance.attributes);}const{prevState,currState}=otherInstanceItem.updateShape(currentCamera,currentFrame,true,shape.shapeType,shapeData,this.rootStore.frame.getNextShapeOrder(),attributes);this.setupShape(otherInstanceItem);const currInfo=otherInstanceItem.instance.getBasicInfo();if(!instanceState[currInfo.id]){instanceState[currInfo.id]={prev:{...prevInfo,children:[]},curr:{...currInfo,children:[]}};}const state=instanceState[currInfo.id];if(prevState){state.prev.children.push(prevState);}if(currState){state.curr.children.push(currState);}});}this.rootStore.undo.push({instances:Object.values(instanceState).map(i=>i.prev).filter(i=>i.children.length>0)},{instances:Object.values(instanceState).map(i=>i.curr)});// update shape instance\nshape.label=instanceItem.label;this.addShapeListeners(shape);this.shapes[shape.uid]={shape,camera:currentCamera,instanceItem};// select\nthis.rootStore.instance.selectInstanceItem(instanceItem);this.rootStore.instance.autoOpenAttributesModal();};/**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */this.addShapeToInstanceItem=function(instanceItem){let camera=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_this.rootStore.frame.currentCamera;const{currentCamera,currentFrame,cameraViews,getImageBoundsForCamera}=_this.rootStore.frame;const currentCameraView=cameraViews[camera];const imageBounds=getImageBoundsForCamera(camera);if(currentCameraView===null||currentCameraView===void 0?void 0:currentCameraView.imageLoadError){return;}const cameraData=instanceItem.cameras[camera];if(cameraData===null||cameraData===void 0?void 0:cameraData.frames[currentFrame]){return;}let shapeInfo;const predictedItem=Object.values(_this.predictedShapes).find(i=>i.instanceItem===instanceItem);if(camera===currentCamera&&predictedItem){// predicted shape in current camera exists, use it\nconst{shape}=predictedItem;shapeInfo={shapeType:shape.shapeType,shape:shape.getData()};// remove predicted shape\nshape.destroy();delete _this.predictedShapes[shape.uid];}else{shapeInfo=instanceItem.predictShape(camera,currentFrame,imageBounds,true);}if(shapeInfo){// add to model\n_this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem,currentFrame,shapeInfo.shapeType,shapeInfo.shape,_this.rootStore.frame.getNextShapeOrder(currentFrame,camera),camera);// create shape\n_this.setupShape(instanceItem,camera,currentCameraView.shapesLayer,imageBounds);// select\n_this.rootStore.instance.selectInstanceItem(instanceItem);_this.rootStore.instance.autoOpenAttributesModal();}};/**\n   * setup shape in current camera & current frame\n   * @param instanceItem\n   * @param shapeContainer\n   * @param imageBounds\n   */this.setupShape=function(instanceItem){let camera=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_this.rootStore.frame.currentCamera;let shapeContainer=arguments.length>2?arguments[2]:undefined;let imageBounds=arguments.length>3?arguments[3]:undefined;const{cameraViews,currentFrame}=_this.rootStore.frame;const cameraData=instanceItem.cameras[camera];if(cameraData){const frameData=cameraData.frames[currentFrame];if(frameData){var _cameraViews$camera;// remove shape if already exists\nconst existingShape=_this.getShapeByInstanceItem(instanceItem,camera);const existingShapeId=existingShape===null||existingShape===void 0?void 0:existingShape.uid;if(existingShape){_this.deleteShape(existingShape);}// add shape\nif(!((_cameraViews$camera=cameraViews[camera])===null||_cameraViews$camera===void 0?void 0:_cameraViews$camera.imageLoadError)){let order;if(frameData.order!==undefined){order=frameData.order;}else{order=_this.rootStore.frame.getNextShapeOrder();}const shape=_this.createShape(shapeContainer||cameraViews[camera].shapesLayer,imageBounds||_this.rootStore.frame.getImageBoundsForCamera(camera),instanceItem.categoryItemRef.displayColor,instanceItem.instance.category,instanceItem.name,frameData.shapeType,frameData.shape,order,instanceItem.label,camera);if(shape.destroyed){// delete instance item\n_this.rootStore.instance.deleteInstanceItemByFrame(instanceItem,currentFrame,camera);return;}_this.addShapeListeners(shape);_this.shapes[shape.uid]={shape,camera,instanceItem};if(_this.pendingMergePolygon===existingShapeId){_this.pendingMergePolygon=shape.uid;}}}}};/**\n   * predict in current camera & current frame\n   */this.predict=()=>{this.clearPredictedShapes();const{isMultiSelected,selectedInstances,selectedInstanceItems}=this.rootStore.instance;if(isMultiSelected){return;}if(selectedInstances.length===1){const{currentCamera,currentFrame,currentCameraView,imageBounds}=this.rootStore.frame;if(currentCameraView===null||currentCameraView===void 0?void 0:currentCameraView.imageLoadError){return;}const selectedInstance=selectedInstances[0];Object.values(selectedInstance.items).forEach(item=>{const shapeInfo=item.predictShape(currentCamera,currentFrame,imageBounds);if(shapeInfo){// create predict shape\nconst predictedShape=this.createShape(this.currentLayer,imageBounds,item.categoryItemRef.displayColor,selectedInstance.category,item.name,shapeInfo.shapeType,shapeInfo.shape,9999,// predicted shape always on the top\nitem.label);predictedShape.borderStyle=BorderStyle.DASHED;predictedShape.borderColor=0xFFFF00;if(predictedShape.shapeType===ShapeType.DOT){predictedShape.color=0xFFFF00;}predictedShape.editable=this.rootStore.config.reviewMode===ReviewMode.LABELING;if(selectedInstanceItems.indexOf(item)>=0){predictedShape.selected=true;}// add listeners\nthis.addShapeListeners(predictedShape);this.predictedShapes[predictedShape.uid]={shape:predictedShape,instanceItem:item};}});}};/**\n   * delete selected shape point or instance\n   */this.delete=()=>{if(this.selectedShapes.length>0){this.deleting=true;this.selectedPointIndex=-1;const pointsDeletedShapes=[];this.selectedShapes.forEach(shape=>{const deleted=shape.deleteSelectedPoints();if(deleted){pointsDeletedShapes.push(shape);}});const{currentFrame}=this.rootStore.frame;if(pointsDeletedShapes.length>0){// has points deleted shapes\nconst instanceItems=[];pointsDeletedShapes.forEach(shape=>{const shapeItem=this.shapes[shape.uid];if(shapeItem){instanceItems.push({instanceItem:shapeItem.instanceItem,frameIndex:currentFrame,shapeType:shape.shapeType,shape:shape.destroyed?undefined:shape.getData()});}});this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);}else{// should delete shapes\nconst instanceItems=[];this.selectedShapes.forEach(shape=>{const shapeItem=this.shapes[shape.uid];if(shapeItem){const{instanceItem}=shapeItem;instanceItems.push({instanceItem,frames:[currentFrame]});}});this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);this.predict();}}this.deleting=false;};/**\n   * delete shape instance\n   * @param shape\n   */this.deleteShape=shape=>{const index=this.selectedShapes.indexOf(shape);if(index>=0){this.selectedShapes.splice(index,1);}shape.destroy();delete this.shapes[shape.uid];};/**\n   * delete shape by instance item\n   * @param instanceItem\n   */this.deleteShapeByInstanceItem=instanceItem=>{const shape=this.getShapeByInstanceItem(instanceItem);if(shape){this.deleteShape(shape);}};/**\n   * set points user data for shape\n   * @param shape\n   * @param pointIndex\n   * @param userData\n   */this.setPointUserData=(shape,pointIndex,userData)=>{if(shape instanceof Polygon||shape instanceof Line){const pointsData=[{index:pointIndex,userData}];shape.setPointsUserData(pointsData);}};/**\n   * move selected shape to front\n   * @param toTop\n   */this.moveFront=function(){let toTop=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(_this.selectedShapes.length===1){const selectedShape=_this.selectedShapes[0];if(toTop){_this.moveToTop(_this.shapes[selectedShape.uid].instanceItem);return;}const intersections=_this.getIntersectionsForShape(selectedShape);if(intersections.length>0){const upperShape=getUpperShape(selectedShape,intersections);if(upperShape){_this.exchangeShapeOrder(selectedShape,upperShape);message.success(i18n.translate('ORDER_FRONT_SUCCESS'));}else{message.warning(i18n.translate('ORDER_FRONT_MOST'));}}else{message.warning(i18n.translate('ORDER_NO_INTERSECT'));}}};/**\n   * move selected shape to back\n   * @param toBottom\n   */this.moveBack=function(){let toBottom=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(_this.selectedShapes.length===1){const selectedShape=_this.selectedShapes[0];if(toBottom){_this.moveToBottom(_this.shapes[selectedShape.uid].instanceItem);return;}const intersections=_this.getIntersectionsForShape(selectedShape);if(intersections.length>0){const underShape=getUnderShape(selectedShape,intersections);if(underShape){_this.exchangeShapeOrder(selectedShape,underShape);message.success(i18n.translate('ORDER_BACK_SUCCESS'));}else{message.warning(i18n.translate('ORDER_BACK_MOST'));}}else{message.warning(i18n.translate('ORDER_NO_INTERSECT'));}}};this.merge=()=>{if(this.rootStore.readonly||this.rootStore.config.isAnyModalOpened||this.isDrawing||this.selectedShapes.length!==1){return;}const selectedShape=this.selectedShapes[0];const{shapeType}=selectedShape;if(shapeType===ShapeType.POLYGON){// merge polygon\nconst shapes=this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i=>i.shape);const intersectPolygonIds=selectedShape.findIntersectPolygons(shapes);if(intersectPolygonIds.length===1){this.mergePolygons(selectedShape.uid,intersectPolygonIds[0]);}else if(intersectPolygonIds.length===0){message.warn(i18n.translate('MERGE_NO_INTERSECT'));}else{this.pendingMergePolygon=selectedShape.uid;message.info(i18n.translate('MERGE_SELECT_NEXT'));}}};this.subtractPolygon=()=>{if(this.rootStore.readonly||this.rootStore.config.isAnyModalOpened||this.isDrawing||this.selectedShapes.length!==1||this.selectedShapes[0].shapeType!==ShapeType.POLYGON){return;}const selectedPolygon=this.selectedShapes[0];const shapes=this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i=>i.shape);const intersectPolygons=selectedPolygon.findIntersectPolygons(shapes,true).map(i=>this.shapes[i].shape);const subtractedData=selectedPolygon.subtract(intersectPolygons);if(subtractedData&&subtractedData.length>0){this.updatePolygons(subtractedData[0][0],subtractedData.slice(1).map(d=>d[0]));message.success(i18n.translate('SUBTRACT_SUCCESS'));}else{message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));}};this.updateConfig=_ref10=>{let{fill,alpha,showVertex,showVertexOrder}=_ref10;if(fill!==undefined){this.config.fill=fill;this.updateShapesFill(fill);}if(alpha!==undefined){this.config.alpha=alpha;this.updateShapesAlpha(alpha/100);}if(showVertex!==undefined){this.config.showVertex=showVertex;this.updateShowVertex(showVertex);}if(showVertexOrder!==undefined){this.config.showVertexOrder=showVertexOrder;this.updateShowVertexOrder(showVertexOrder);}};this.updateShapesFill=fill=>{Object.values(this.shapes).forEach(_ref11=>{let{shape}=_ref11;shape.alpha=fill?this.config.alpha/100:0;});Object.values(this.predictedShapes).forEach(_ref12=>{let{shape}=_ref12;shape.alpha=fill?this.config.alpha/100:0;});};this.updateShapesAlpha=alpha=>{if(this.config.fill){if(this.drawingShape){this.drawingShape.alpha=alpha;}Object.values(this.shapes).forEach(_ref13=>{let{shape}=_ref13;shape.alpha=alpha;});Object.values(this.predictedShapes).forEach(_ref14=>{let{shape}=_ref14;shape.alpha=alpha;});}};this.updateShowVertex=showVertex=>{if(this.drawingShape){this.drawingShape.showVertex=showVertex;}Object.values(this.shapes).forEach(_ref15=>{let{shape}=_ref15;shape.showVertex=showVertex;});Object.values(this.predictedShapes).forEach(_ref16=>{let{shape}=_ref16;shape.showVertex=showVertex;});};this.updateShowVertexOrder=showVertexOrder=>{if(this.drawingShape){this.drawingShape.showVertexOrder=showVertexOrder;}Object.values(this.shapes).forEach(_ref17=>{let{shape}=_ref17;shape.showVertexOrder=showVertexOrder;});Object.values(this.predictedShapes).forEach(_ref18=>{let{shape}=_ref18;shape.showVertexOrder=showVertexOrder;});};this.resetConfig=()=>{this.updateConfig({...this.defaultConfig});};makeObservable(this,{shapes:observable,selectedShapes:observable,selectedPointIndex:observable,config:observable,init:action,clearShapes:action,setupShapes:action,selectShapes:action,unselectShape:action,addShape:action,setupShape:action,deleteShape:action,updateConfig:action});this.rootStore=rootStore;}/**\n   * init from paylod\n   * @param payload\n   */init(payload){this.config.fill=payload.is_fill!=='false'&&payload.is_fill!==false;if(payload.fill_opacity!==undefined&&payload.fill_opacity!==''){const alpha=Number(payload.fill_opacity);if(!Number.isNaN(alpha)&&alpha>=0&&alpha<=1){this.config.alpha=alpha*100;}}this.config.showVertex=payload.show_vertex==='true'||payload.show_vertex===true;this.config.showVertexOrder=payload.show_vertex_order==='true'||payload.show_vertex_order===true;this.defaultConfig={...this.config};// save default settings\nthis.app=payload.app;}/**\n   * update shapes editable\n   * @param editable\n   */updateShapesEditable(editable){Object.values(this.shapes).forEach(_ref19=>{let{shape}=_ref19;shape.editable=editable;});Object.values(this.predictedShapes).forEach(_ref20=>{let{shape}=_ref20;shape.editable=editable;});}/**\n   * create shape label dom\n   */createShapeLabel(){let camera=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.rootStore.frame.currentCamera;const shapeLabelsContainer=document.getElementById(\"\".concat(CAMERA_VIEW_LABELS,\"-\").concat(camera));if(shapeLabelsContainer){const shapeLabel=new Label({className:'shape-label',transPosition:p=>{const cameraView=this.rootStore.frame.cameraViews[camera];if(cameraView){return cameraView.toLocal(p);}return p;}});shapeLabel.addToContainer(shapeLabelsContainer);return shapeLabel;}return undefined;}/**\n   * create shape instance\n   * @param shapeContainer\n   * @param imageBounds\n   * @param hexColor\n   * @param categoryName\n   * @param categoryItemName\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param label\n   */createShape(shapeContainer,imageBounds,hexColor,categoryName,categoryItemName,shapeType,shapeData,order,label,camera){var _this$rootStore$frame;const{rotatable}=this.rootStore.config;const{currentShapeType}=this.rootStore.ontology;const useCurrent=shapeType===undefined;const color=parseInt(hexColor.substr(1),16);const type=shapeType||currentShapeType;const shape=ShapeFactory.getShape(type,{app:this.app,container:shapeContainer,color,alpha:this.config.fill?this.config.alpha/100:0,showVertex:this.config.showVertex,showVertexOrder:this.config.showVertexOrder,label,...shapeData,...((type===ShapeType.RECTANGLE||type===ShapeType.POLYGON)&&{rotatable}),labelDom:this.createShapeLabel(camera),scale:(_this$rootStore$frame=this.rootStore.frame.cameraViews[camera||this.rootStore.frame.currentCamera])===null||_this$rootStore$frame===void 0?void 0:_this$rootStore$frame.viewScale});// destroyed, not need to proceed\nif(shape===null||shape===void 0?void 0:shape.destroyed){return shape;}// update order, prefer to use given order\nif(order!==undefined){shape.order=order;}else if(useCurrent){shape.order=this.rootStore.frame.getNextShapeOrder();}// set default rotation for rectangle\nif(shapeData&&type===ShapeType.RECTANGLE){shape.rotation=shapeData.rotation||0;}return shape;}/**\n   * add shape listeners\n   * @param shape\n   */addShapeListeners(shape){shape.on(EventAction.SELECTED,(s,p)=>{if(!this.isPredictedShape(s)){if(this.selectedShapes.length===1&&s.uid!==this.selectedShapes[0].uid){if(this.pendingMergePolygon){this.mergePolygons(this.pendingMergePolygon,shape.uid);this.pendingMergePolygon='';return;}}if(this.selectedShapes.indexOf(s)<0){this.selectShapes([s]);this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);}}else{// clear selected shape status\nthis.selectedShapes.forEach(ss=>{ss.selected=false;});this.selectedShapes=[];// clear predicted shape selected status\nObject.values(this.predictedShapes).forEach(predictedShape=>{if(predictedShape.shape!==s){predictedShape.shape.selected=false;}});this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);}if(this.rootStore.review.addMode){this.rootStore.review.addReview(p);}});shape.on(EventAction.CHANGED,(s,data)=>{if(this.isPredictedShape(s)){this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);}else{const{instanceItem}=this.shapes[s.uid];const{currentFrame}=this.rootStore.frame;if(!this.deleting){this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem,currentFrame,s.shapeType,data);}}});shape.on(EventAction.REMOVED,s=>{if(!this.deleting){const{instanceItem}=this.shapes[s.uid];if(instanceItem){this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem,[this.rootStore.frame.currentFrame]);}}});shape.on(EventAction.POINTER_OVER,s=>{if(!this.isPredictedShape(s)){this.hoveredShapeId=s.uid;}});shape.on(EventAction.POINTER_OUT,s=>{if(!this.isPredictedShape(s)){this.hoveredShapeId='';}});shape.on(EventAction.VERTEX_SELECTED,(s,index)=>{if(this.isPredictedShape(s)){return;}this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);if(this.selectedShapes.length===1&&this.selectedShapes[0]===s){this.selectedPointIndex=index;}else{this.selectedPointIndex=-1;}});}/**\n   * fit shapes to canvas for selected instances\n   */fitShapes(){const{currentCamera,cameraNames,cameraViews}=this.rootStore.frame;const{selectedInstanceItems,selectedInstances}=this.rootStore.instance;const cameraShapes=selectedInstanceItems.length>0?[{camera:currentCamera,shapes:this.getShapesByInstanceItems(selectedInstanceItems)}]:cameraNames.map(camera=>({camera,shapes:Object.values(this.shapes).filter(s=>s.camera===camera&&selectedInstances.indexOf(s.instanceItem.instance)>=0).map(s=>s.shape)}));cameraShapes.forEach(_ref21=>{let{camera,shapes}=_ref21;const cameraView=cameraViews[camera];if(shapes.length>0&&cameraView){let{left,top,right,bottom}=shapes[0].instance.getLocalBounds();for(let i=1;i<shapes.length;i+=1){const bbox=shapes[i].instance.getLocalBounds();left=Math.min(bbox.left,left);top=Math.min(bbox.top,top);right=Math.max(bbox.right,right);bottom=Math.max(bbox.bottom,bottom);}cameraView.fitShapeToView({left,top,right,bottom},0.5);}});}/**\n   * get intersections for shape\n   * @param shape\n   */getIntersectionsForShape(shape){const shapes=this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i=>i.shape).filter(s=>s.visible&&s.finished);const intersections=shape.findIntersections(shapes);return intersections;}/**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */exchangeShapeOrder(shapeA,shapeB){const{currentCamera,currentFrame}=this.rootStore.frame;const orderA=shapeA.order;const orderB=shapeB.order;const{instanceItem:instanceItemA}=this.shapes[shapeA.uid];const{instanceItem:instanceItemB}=this.shapes[shapeB.uid];const instanceInfoA=instanceItemA.instance.getBasicInfo();const instanceInfoB=instanceItemB.instance.getBasicInfo();// save state\nconst prevInstances=[];if(instanceItemA.instance.id===instanceItemB.instance.id){// same instance\nprevInstances.push({...instanceInfoA,children:[instanceItemA.toJSON(),instanceItemB.toJSON()]});}else{prevInstances.push({...instanceInfoA,children:[instanceItemA.toJSON()]});prevInstances.push({...instanceInfoB,children:[instanceItemB.toJSON()]});}const storeId=this.rootStore.undo.preserve({instances:prevInstances});// update a\ninstanceItemA.cameras[currentCamera].frames[currentFrame].order=orderB;shapeA.order=orderB;// update b\ninstanceItemB.cameras[currentCamera].frames[currentFrame].order=orderA;shapeB.order=orderA;const currInstances=[];if(instanceItemA.instance.id===instanceItemB.instance.id){// same instance\ncurrInstances.push({...instanceInfoA,children:[instanceItemA.toJSON(),instanceItemB.toJSON()]});}else{currInstances.push({...instanceInfoA,children:[instanceItemA.toJSON()]});currInstances.push({...instanceInfoB,children:[instanceItemB.toJSON()]});}this.rootStore.undo.save(storeId,{instances:currInstances});}/**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */moveToTop(instanceItem){const{currentCamera,currentFrame,getNextShapeOrder}=this.rootStore.frame;const cameraData=instanceItem.cameras[currentCamera];const frameData=cameraData===null||cameraData===void 0?void 0:cameraData.frames[currentFrame];if(!frameData){return;}const cameraShapes=this.getShapesForCamera(currentCamera);const maxOrder=Math.max(...cameraShapes.map(s=>s.shape.order));if(maxOrder===frameData.order){message.warning(i18n.translate('ORDER_FRONT_MOST'));return;}const instanceInfo=instanceItem.instance.getBasicInfo();const instanceItemInfo=instanceItem.getBasicInfo();// preserve state\nconst storeId=this.rootStore.undo.preserve({instances:[{...instanceInfo,children:[{...instanceItemInfo,cameras:[cameraData.toJSON()]}]}]});// update order\nconst order=getNextShapeOrder();frameData.order=order;const shape=this.getShapeByInstanceItem(instanceItem,currentCamera);if(shape){shape.order=order;}// save state\nthis.rootStore.undo.save(storeId,{instances:[{...instanceInfo,children:[{...instanceItemInfo,cameras:[cameraData.toJSON()]}]}]});message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));}/**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */moveToBottom(instanceItem){const{currentCamera,currentFrame,updateNextShapeOrder}=this.rootStore.frame;const cameraData=instanceItem.cameras[currentCamera];const frameData=cameraData===null||cameraData===void 0?void 0:cameraData.frames[currentFrame];if(!frameData){return;}const cameraShapes=this.getShapesForCamera(currentCamera);const minOrder=Math.min(...cameraShapes.map(s=>s.shape.order));if(minOrder===frameData.order){message.warning(i18n.translate('ORDER_BACK_MOST'));return;}const instanceInfo=instanceItem.instance.getBasicInfo();const instanceItemInfo=instanceItem.getBasicInfo();// prev instance state map\nconst prevInstanceMap={[instanceInfo.id]:{...instanceInfo,children:[{...instanceItemInfo,cameras:[cameraData.toJSON()]}]}};// update selected shape order\nconst startOrder=0;frameData.order=startOrder;const shape=this.getShapeByInstanceItem(instanceItem,currentCamera);if(shape){shape.order=startOrder;}// current instance state map\nconst currInstanceMap={[instanceInfo.id]:{...instanceInfo,children:[{...instanceItemInfo,cameras:[cameraData.toJSON()]}]}};if(minOrder<=startOrder){// show move all camera shapes upper\nfor(let i=0;i<cameraShapes.length;i+=1){const{shape:s,instanceItem:sInstanceItem}=cameraShapes[i];if(sInstanceItem.id!==instanceItem.id){// not selected shape\nconst sInstanceInfo=sInstanceItem.instance.getBasicInfo();const sInstanceItemInfo=sInstanceItem.getBasicInfo();const sCameraData=sInstanceItem.cameras[currentCamera];if(!prevInstanceMap[sInstanceInfo.id]){prevInstanceMap[sInstanceInfo.id]={...sInstanceInfo,children:[]};}prevInstanceMap[sInstanceInfo.id].children.push({...sInstanceItemInfo,cameras:[sCameraData.toJSON()]});// update not selected shape's order\nconst order=s.order+1;sCameraData.frames[currentFrame].order=order;s.order=order;updateNextShapeOrder(order,currentFrame,currentCamera);if(!currInstanceMap[sInstanceInfo.id]){currInstanceMap[sInstanceInfo.id]={...sInstanceInfo,children:[]};}currInstanceMap[sInstanceInfo.id].children.push({...sInstanceItemInfo,cameras:[sCameraData.toJSON()]});}}}// save state\nthis.rootStore.undo.push({instances:Object.values(prevInstanceMap)},{instances:Object.values(currInstanceMap)});message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));}mergePolygons(polygonId1,polygonId2){const{shape:polygon1,instanceItem:instance1}=this.shapes[polygonId1];const{shape:polygon2,instanceItem:instance2}=this.shapes[polygonId2];const mergedData=polygon1.merge(polygon2);if(mergedData.length===1){const{currentCamera,currentFrame}=this.rootStore.frame;const{prevState,currState}=this.rootStore.instance.deleteInstanceItemByFrame(instance2,currentFrame);const{prevState:prevStateItem,currState:currStateItem}=instance1.updateShape(currentCamera,currentFrame,true,ShapeType.POLYGON,mergedData[0],this.rootStore.frame.getNextShapeOrder());this.setupShape(instance1);this.selectShapeByInstanceItem(instance1);const basicInfo=instance1.instance.getBasicInfo();this.rootStore.undo.push({instances:[...prevState.instances,...(prevStateItem?[{...basicInfo,children:[prevStateItem]}]:[])]},{instances:[...currState.instances,...(currStateItem?[{...basicInfo,children:[currStateItem]}]:[])]});message.success(i18n.translate('MERGE_SUCCESS'));}else{message.warn(i18n.translate('MERGE_WITH_HOLE'));}}updatePolygons(currPolygonData,otherPolygonData){this.updateShapes(currPolygonData,otherPolygonData,ShapeType.POLYGON);}updateShapes(currShapeData,otherShapeData){let shapeType=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ShapeType.POLYGON;const selectedShape=this.selectedShapes[0];const{instanceItem:selectedInstanceItem}=this.shapes[selectedShape.uid];const{currentCamera,currentFrame}=this.rootStore.frame;const attributes=selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;const prevBasicInfo=selectedInstanceItem.instance.getBasicInfo();const{prevState:prevStateItem,currState:currStateItem}=selectedInstanceItem.updateShape(currentCamera,currentFrame,true,shapeType,currShapeData,this.rootStore.frame.getNextShapeOrder(),attributes);const basicInfo=selectedInstanceItem.instance.getBasicInfo();const instanceState={[basicInfo.id]:{prev:{...prevBasicInfo,children:prevStateItem?[prevStateItem]:[]},curr:{...basicInfo,children:currStateItem?[currStateItem]:[]}}};this.setupShape(selectedInstanceItem);for(let i=0;i<otherShapeData.length;i+=1){const instanceItem=this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category,selectedInstanceItem.name);const prevInfo=instanceItem.instance.getBasicInfo();if(instanceItem.instance!==selectedInstanceItem.instance){var _selectedInstanceItem,_selectedInstanceItem2;instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);const dynamicAttributesCurrentFrame=(_selectedInstanceItem=selectedInstanceItem.instance.dynamicAttributes)===null||_selectedInstanceItem===void 0?void 0:(_selectedInstanceItem2=_selectedInstanceItem[currentCamera])===null||_selectedInstanceItem2===void 0?void 0:_selectedInstanceItem2[currentFrame];if(dynamicAttributesCurrentFrame&&instanceItem.instance.categoryRef.labelConfigDynamic){instanceItem.instance.setDynamicAttributesByCamera(currentCamera,[dynamicAttributesCurrentFrame]);}}const{prevState,currState}=instanceItem.updateShape(currentCamera,currentFrame,true,shapeType,otherShapeData[i],this.rootStore.frame.getNextShapeOrder(),attributes);this.setupShape(instanceItem);const currInfo=instanceItem.instance.getBasicInfo();if(!instanceState[currInfo.id]){instanceState[currInfo.id]={prev:{...prevInfo,children:[]},curr:{...currInfo,children:[]}};}const state=instanceState[currInfo.id];if(prevState){state.prev.children.push(prevState);}if(currState){state.curr.children.push(currState);}}this.selectShapeByInstanceItem(selectedInstanceItem);this.rootStore.undo.push({instances:Object.values(instanceState).map(i=>i.prev).filter(i=>i.children.length>0)},{instances:Object.values(instanceState).map(i=>i.curr)});}}","map":{"version":3,"names":["makeObservable","observable","action","message","i18n","getUnderShape","getUpperShape","ReviewMode","CAMERA_VIEW_LABELS","ShapeFactory","ShapeType","EventAction","BorderStyle","Polygon","Line","Label","ShapeStore","isDrawing","drawingShape","constructor","rootStore","_this","app","currentLayer","shapes","selectedShapes","selectedPointIndex","predictedShapes","hoveredShapeId","pendingMergePolygon","deleting","config","fill","alpha","showVertex","showVertexOrder","defaultConfig","clearShapes","Object","values","forEach","_ref","shape","destroy","clearPredictedShapes","_ref2","isPredictedShape","s","findIndex","_ref3","getShapeByInstanceItem","instanceItem","camera","arguments","length","undefined","frame","currentCamera","shapeItem","find","i","getShapesByInstanceItems","instanceItems","shapeItems","filter","indexOf","map","getShapesForCamera","updateShapesInteractive","interactive","ignoreIds","_ref4","includes","uid","selected","redrawShapesLabel","_ref5","drawShapeLabel","_ref6","setupShapes","cameraViews","currentFrame","cameraNames","getImageBoundsForCamera","allShapeOrders","noOrderShapes","cameraName","Set","startOrder","instance","instances","items","item","cameras","_ref7","frames","cameraView","imageLoadError","createShape","shapesLayer","categoryItemRef","displayColor","category","name","shapeType","order","label","destroyed","deleteInstanceItemByFrame","readonly","editable","addShapeListeners","has","push","frameData","keys","_ref8","getNextShapeOrder","selectShapes","selectShapeByInstanceItem","Array","isArray","instancesSet","updateShapesInInstance","from","predict","unselectShape","addMode","selectInstance","_ref9","borderColor","DOT","color","originColors","addShape","point","shapeContainer","imageBounds","finishCallback","initialized","ontology","selectedCategoryItem","selectedCategory","className","on","FINISHED","otherShapeData","off","REMOVED","setAddMode","addShapeToCurrentInstanceItem","create","getCurrentInstanceItem","data","getData","prevBasicInfo","getBasicInfo","prevState","prevStateItem","currState","currStateItem","basicInfo","attributes","instanceState","id","prev","children","curr","shapeData","otherInstanceItem","prevInfo","setAttributes","updateShape","setupShape","currInfo","state","undo","selectInstanceItem","autoOpenAttributesModal","addShapeToInstanceItem","currentCameraView","cameraData","shapeInfo","predictedItem","predictShape","updateFrameShapeForInstanceItem","_cameraViews$camera","existingShape","existingShapeId","deleteShape","isMultiSelected","selectedInstances","selectedInstanceItems","selectedInstance","predictedShape","borderStyle","DASHED","reviewMode","LABELING","delete","pointsDeletedShapes","deleted","deleteSelectedPoints","frameIndex","updateFrameShapeForInstanceItems","deleteFramesFromInstanceItems","index","splice","deleteShapeByInstanceItem","setPointUserData","pointIndex","userData","pointsData","setPointsUserData","moveFront","toTop","selectedShape","moveToTop","intersections","getIntersectionsForShape","upperShape","exchangeShapeOrder","success","translate","warning","moveBack","toBottom","moveToBottom","underShape","merge","isAnyModalOpened","POLYGON","intersectPolygonIds","findIntersectPolygons","mergePolygons","warn","info","subtractPolygon","selectedPolygon","intersectPolygons","subtractedData","subtract","updatePolygons","slice","d","updateConfig","_ref10","updateShapesFill","updateShapesAlpha","updateShowVertex","updateShowVertexOrder","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","resetConfig","init","payload","is_fill","fill_opacity","Number","isNaN","show_vertex","show_vertex_order","updateShapesEditable","_ref19","_ref20","createShapeLabel","shapeLabelsContainer","document","getElementById","concat","shapeLabel","transPosition","p","toLocal","addToContainer","hexColor","categoryName","categoryItemName","_this$rootStore$frame","rotatable","currentShapeType","useCurrent","parseInt","substr","type","getShape","container","RECTANGLE","labelDom","scale","viewScale","rotation","SELECTED","ss","updateSelectedInstanceItem","review","addReview","CHANGED","deleteFramesFromInstanceItem","POINTER_OVER","POINTER_OUT","VERTEX_SELECTED","fitShapes","cameraShapes","_ref21","left","top","right","bottom","getLocalBounds","bbox","Math","min","max","fitShapeToView","visible","finished","findIntersections","shapeA","shapeB","orderA","orderB","instanceItemA","instanceItemB","instanceInfoA","instanceInfoB","prevInstances","toJSON","storeId","preserve","currInstances","save","maxOrder","instanceInfo","instanceItemInfo","updateNextShapeOrder","minOrder","prevInstanceMap","currInstanceMap","sInstanceItem","sInstanceInfo","sInstanceItemInfo","sCameraData","polygonId1","polygonId2","polygon1","instance1","polygon2","instance2","mergedData","currPolygonData","otherPolygonData","updateShapes","currShapeData","selectedInstanceItem","_selectedInstanceItem","_selectedInstanceItem2","dynamicAttributesCurrentFrame","dynamicAttributes","categoryRef","labelConfigDynamic","setDynamicAttributesByCamera"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/ShapeStore.ts"],"sourcesContent":["import { Application, Container, Point } from 'pixi.js';\nimport { makeObservable, observable, action } from 'mobx';\nimport { message } from 'antd';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport FrameData from '../model/FrameData';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape } from '../utils';\nimport { Payload, Instance as IInstance, ReviewMode } from '../types';\nimport { CAMERA_VIEW_LABELS } from '../constants';\nimport ShapeFactory from '../../common/shapes/ShapeFactory';\nimport { ShapeType, ShapeData } from '../../common/shapes/types';\nimport Shape, { EventAction, BorderStyle } from '../../common/shapes/Shape';\nimport { RectangleData } from '../../common/shapes/Rectangle';\nimport Polygon, { PolygonData } from '../../common/shapes/Polygon';\nimport Line from '../../common/shapes/Line';\nimport Label from '../../common/shapes/label/Label';\n\n/**\n * store for shapes in current camera & current frame\n * @class\n */\nexport default class ShapeStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * app\n   */\n  app?: Application;\n\n  /**\n   * current layer\n   */\n  currentLayer?: Container;\n\n  /**\n   * shapes in current frame\n   */\n  shapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      camera: string;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * currently drawing shape\n   */\n  drawingShape: Shape<ShapeData> | null = null;\n\n  /**\n   * currently selected shapes\n   */\n  selectedShapes: Shape<ShapeData>[] = [];\n\n  /**\n   * currently selected shape vertex index for polygon & line\n   */\n  selectedPointIndex = -1;\n\n  /**\n   * predicted shapes\n   */\n  predictedShapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * hovered shape id\n   */\n  hoveredShapeId = '';\n\n  /**\n   * waiting merge polygon\n   */\n  pendingMergePolygon = '';\n\n  /**\n   * is deleting\n   */\n  deleting = false;\n\n  /**\n   * shape display config\n   */\n  config = {\n    fill: true,\n    alpha: 20,\n    showVertex: false,\n    showVertexOrder: false,\n  };\n\n  /**\n   * default config from payload\n   */\n  defaultConfig = this.config;\n\n  /**\n   * is drawing shape\n   * @getter\n   */\n  get isDrawing() {\n    return this.drawingShape !== null;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeObservable(this, {\n      shapes: observable,\n      selectedShapes: observable,\n      selectedPointIndex: observable,\n      config: observable,\n      init: action,\n      clearShapes: action,\n      setupShapes: action,\n      selectShapes: action,\n      unselectShape: action,\n      addShape: action,\n      setupShape: action,\n      deleteShape: action,\n      updateConfig: action,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload: Payload) {\n    this.config.fill = payload.is_fill !== 'false' && payload.is_fill !== false;\n    if (payload.fill_opacity !== undefined && payload.fill_opacity !== '') {\n      const alpha = Number(payload.fill_opacity);\n      if (!Number.isNaN(alpha) && alpha >= 0 && alpha <= 1) {\n        this.config.alpha = alpha * 100;\n      }\n    }\n    this.config.showVertex = payload.show_vertex === 'true' || payload.show_vertex === true;\n    this.config.showVertexOrder = payload.show_vertex_order === 'true' || payload.show_vertex_order === true;\n    this.defaultConfig = { ...this.config }; // save default settings\n\n    this.app = payload.app;\n  }\n\n  /**\n   * clear shapes\n   */\n  clearShapes = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.shapes = {};\n    this.drawingShape = null;\n    this.selectedShapes = [];\n    this.clearPredictedShapes();\n    this.selectedPointIndex = -1;\n  };\n\n  /**\n   * clear predicted shapes\n   */\n  clearPredictedShapes = () => {\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.predictedShapes = {};\n  };\n\n  /**\n   * is predicted shape\n   * @param s\n   */\n  isPredictedShape = (s: Shape<ShapeData>) => Object.values(this.predictedShapes).findIndex(({ shape }) => shape === s) >= 0;\n\n  /**\n   * get shape by instance item\n   * @param instanceItem\n   */\n  getShapeByInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const shapeItem = Object.values(this.shapes).find((i) => i.camera === camera && i.instanceItem === instanceItem);\n    if (shapeItem) {\n      return shapeItem.shape;\n    }\n    return undefined;\n  };\n\n  /**\n   * get shapes by instance items\n   * @param instanceItems\n   * @param camera\n   */\n  getShapesByInstanceItems = (instanceItems: InstanceItem[], camera = this.rootStore.frame.currentCamera) => {\n    const shapeItems = Object.values(this.shapes).filter((i) => i.camera === camera && instanceItems.indexOf(i.instanceItem) >= 0);\n    return shapeItems.map((i) => i.shape);\n  };\n\n  /**\n   * get shapes for one camera\n   * @param camera\n   */\n  getShapesForCamera = (camera: string) => Object.values(this.shapes).filter((s) => s.camera === camera);\n\n  /**\n   * update shapes interactive\n   * @param interactive\n   * @param ignoreIds\n   */\n  updateShapesInteractive = (interactive: boolean, ignoreIds?: string[]) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (ignoreIds && ignoreIds.includes(shape.uid)) {\n        return;\n      }\n      shape.interactive = interactive;\n      if (interactive && this.selectedShapes.indexOf(shape) >= 0) {\n        shape.selected = true;\n      }\n    });\n  };\n\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable: boolean) {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.editable = editable;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.editable = editable;\n    });\n  }\n\n  /**\n   * redraw shapes label\n   */\n  redrawShapesLabel = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n  };\n\n  /**\n   * setup shapes for current frame\n   */\n  setupShapes = () => {\n    this.clearShapes();\n    const { cameraViews, currentFrame, cameraNames, getImageBoundsForCamera } = this.rootStore.frame;\n    const allShapeOrders: {\n      [camera: string]: Set<number>;\n    } = {};\n    const noOrderShapes: {\n      [camera: string]: { frameData: FrameData, shape: Shape<ShapeData> }[];\n    } = {};\n    cameraNames.forEach((cameraName) => {\n      allShapeOrders[cameraName] = new Set();\n      noOrderShapes[cameraName] = [];\n    });\n    const startOrder = 0;\n    Object.values(this.rootStore.instance.instances).forEach((instance) => {\n      Object.values(instance.items).forEach((item) => {\n        Object.values(item.cameras).forEach(({ camera }) => {\n          const { frames } = item.cameras[camera];\n          const cameraView = cameraViews[camera];\n          if (frames[currentFrame] && cameraView && !cameraView.imageLoadError) {\n            const shape = this.createShape(\n              cameraView.shapesLayer,\n              getImageBoundsForCamera(camera),\n              item.categoryItemRef.displayColor,\n              instance.category,\n              item.name,\n              frames[currentFrame].shapeType,\n              frames[currentFrame].shape,\n              frames[currentFrame].order,\n              item.label,\n              camera,\n            );\n            if (shape.destroyed) {\n              // delete instance item\n              this.rootStore.instance.deleteInstanceItemByFrame(item, currentFrame, camera);\n              return;\n            }\n            if (this.rootStore.readonly) {\n              shape.editable = false;\n            }\n            this.addShapeListeners(shape);\n            this.shapes[shape.uid] = {\n              shape,\n              camera,\n              instanceItem: item,\n            };\n\n            const { order } = frames[currentFrame];\n            if (typeof order === 'number' && order >= startOrder && !allShapeOrders[camera].has(order)) {\n              // update next shape order\n              shape.order = order;\n            } else {\n              // add to temp array\n              noOrderShapes[camera].push({ frameData: frames[currentFrame], shape });\n            }\n          }\n        });\n      });\n    });\n    Object.keys(noOrderShapes).forEach((cameraName) => {\n      noOrderShapes[cameraName].forEach(({ frameData, shape }) => {\n        // new order\n        shape.order = this.rootStore.frame.getNextShapeOrder(currentFrame, cameraName);\n        frameData.order = shape.order;\n      });\n    });\n  };\n\n  /**\n   * create shape label dom\n   */\n  createShapeLabel(camera = this.rootStore.frame.currentCamera) {\n    const shapeLabelsContainer = document.getElementById(`${CAMERA_VIEW_LABELS}-${camera}`);\n    if (shapeLabelsContainer) {\n      const shapeLabel = new Label({\n        className: 'shape-label',\n        transPosition: (p) => {\n          const cameraView = this.rootStore.frame.cameraViews[camera];\n          if (cameraView) {\n            return cameraView.toLocal(p);\n          }\n          return p;\n        },\n      });\n      shapeLabel.addToContainer(shapeLabelsContainer);\n      return shapeLabel;\n    }\n    return undefined;\n  }\n\n  /**\n   * create shape instance\n   * @param shapeContainer\n   * @param imageBounds\n   * @param hexColor\n   * @param categoryName\n   * @param categoryItemName\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param label\n   */\n  createShape(\n    shapeContainer: Container,\n    imageBounds: { left: number; top: number; right: number; bottom: number; },\n    hexColor: string,\n    categoryName: string,\n    categoryItemName: string,\n    shapeType?: ShapeType,\n    shapeData?: ShapeData,\n    order?: number,\n    label?: string,\n    camera?: string,\n  ) {\n    const { rotatable } = this.rootStore.config;\n    const { currentShapeType } = this.rootStore.ontology;\n    const useCurrent = shapeType === undefined;\n    const color = parseInt(hexColor.substr(1), 16);\n    const type = shapeType || currentShapeType;\n    const shape = ShapeFactory.getShape(type, {\n      app: this.app!,\n      container: shapeContainer,\n      color,\n      alpha: this.config.fill ? this.config.alpha / 100 : 0,\n      showVertex: this.config.showVertex,\n      showVertexOrder: this.config.showVertexOrder,\n      label,\n      ...shapeData,\n      ...(type === ShapeType.RECTANGLE || type === ShapeType.POLYGON) && {\n        rotatable,\n      },\n      labelDom: this.createShapeLabel(camera),\n      scale: this.rootStore.frame.cameraViews[camera || this.rootStore.frame.currentCamera]?.viewScale,\n    });\n    // destroyed, not need to proceed\n    if (shape?.destroyed) {\n      return shape;\n    }\n    // update order, prefer to use given order\n    if (order !== undefined) {\n      shape!.order = order;\n    } else if (useCurrent) {\n      shape!.order = this.rootStore.frame.getNextShapeOrder();\n    }\n    // set default rotation for rectangle\n    if (shapeData && type === ShapeType.RECTANGLE) {\n      shape!.rotation = (shapeData as RectangleData).rotation || 0;\n    }\n    return shape!;\n  }\n\n  /**\n   * add shape listeners\n   * @param shape\n   */\n  addShapeListeners(shape: Shape<ShapeData>) {\n    shape.on(EventAction.SELECTED, (s, p) => {\n      if (!this.isPredictedShape(s)) {\n        if (this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n          if (this.pendingMergePolygon) {\n            this.mergePolygons(this.pendingMergePolygon, shape.uid);\n            this.pendingMergePolygon = '';\n            return;\n          }\n        }\n        if (this.selectedShapes.indexOf(s) < 0) {\n          this.selectShapes([s]);\n          this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n        }\n      } else {\n        // clear selected shape status\n        this.selectedShapes.forEach((ss) => {\n          ss.selected = false;\n        });\n        this.selectedShapes = [];\n        // clear predicted shape selected status\n        Object.values(this.predictedShapes).forEach((predictedShape) => {\n          if (predictedShape.shape !== s) {\n            predictedShape.shape.selected = false;\n          }\n        });\n        this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      }\n      if (this.rootStore.review.addMode) {\n        this.rootStore.review.addReview(p);\n      }\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      if (this.isPredictedShape(s)) {\n        this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      } else {\n        const { instanceItem } = this.shapes[s.uid];\n        const { currentFrame } = this.rootStore.frame;\n        if (!this.deleting) {\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, s.shapeType, data);\n        }\n      }\n    });\n    shape.on(EventAction.REMOVED, (s) => {\n      if (!this.deleting) {\n        const { instanceItem } = this.shapes[s.uid];\n        if (instanceItem) {\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n        }\n      }\n    });\n    shape.on(EventAction.POINTER_OVER, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = s.uid;\n      }\n    });\n    shape.on(EventAction.POINTER_OUT, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = '';\n      }\n    });\n    shape.on(EventAction.VERTEX_SELECTED, (s, index) => {\n      if (this.isPredictedShape(s)) {\n        return;\n      }\n      this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n      if (this.selectedShapes.length === 1 && this.selectedShapes[0] === s) {\n        this.selectedPointIndex = index;\n      } else {\n        this.selectedPointIndex = -1;\n      }\n    });\n  }\n\n  /**\n   * select shapes\n   * @param shapes\n   */\n  selectShapes = (shapes: Shape<ShapeData>[]) => {\n    if (this.selectedPointIndex >= 0) {\n      // has point selected\n      if (this.selectedShapes.length === 1 && shapes.length === 1 && this.selectedShapes[0] === shapes[0]) {\n        // same shape, do not unselect\n        return;\n      }\n      this.selectedPointIndex = -1;\n    }\n    this.selectedShapes.forEach((shape) => {\n      if (shapes.indexOf(shape) < 0) { // not selected any more\n        shape.selected = false;\n      }\n    });\n    this.selectedShapes = [...shapes];\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = true;\n    });\n  };\n\n  /**\n   * select shape by instance item\n   * @param instanceItem\n   */\n  selectShapeByInstanceItem = (instanceItem: InstanceItem | InstanceItem[] | null) => {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...instanceItem ? [instanceItem] : []];\n    const shapes = this.getShapesByInstanceItems(instanceItems);\n    this.selectShapes(shapes);\n    const instancesSet = new Set(instanceItems.map((i) => i.instance));\n    this.updateShapesInInstance(Array.from(instancesSet));\n    this.predict();\n  };\n\n  /**\n   * fit shapes to canvas for selected instances\n   */\n  fitShapes() {\n    const { currentCamera, cameraNames, cameraViews } = this.rootStore.frame;\n    const { selectedInstanceItems, selectedInstances } = this.rootStore.instance;\n\n    const cameraShapes = selectedInstanceItems.length > 0\n      ? [{ camera: currentCamera, shapes: this.getShapesByInstanceItems(selectedInstanceItems) }]\n      : cameraNames.map((camera) => ({\n        camera,\n        shapes: Object.values(this.shapes).filter((s) => s.camera === camera && selectedInstances.indexOf(s.instanceItem.instance) >= 0).map((s) => s.shape),\n      }));\n    cameraShapes.forEach(({ camera, shapes }) => {\n      const cameraView = cameraViews[camera];\n      if (shapes.length > 0 && cameraView) {\n        let { left, top, right, bottom } = shapes[0].instance.getLocalBounds();\n        for (let i = 1; i < shapes.length; i += 1) {\n          const bbox = shapes[i].instance.getLocalBounds();\n          left = Math.min(bbox.left, left);\n          top = Math.min(bbox.top, top);\n          right = Math.max(bbox.right, right);\n          bottom = Math.max(bbox.bottom, bottom);\n        }\n        cameraView.fitShapeToView({ left, top, right, bottom }, 0.5);\n      }\n    });\n  }\n\n  /**\n   * click to unselect shape\n   */\n  unselectShape = () => {\n    if (\n      this.rootStore.config.addMode\n    ) {\n      return;\n    }\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = false;\n    });\n    this.selectedShapes = [];\n    this.rootStore.instance.selectInstance(null);\n  };\n\n  /**\n   * update shape border color\n   * @param instance\n   */\n  updateShapesInInstance = (instance?: Instance | Instance[] | null) => {\n    const instances = Array.isArray(instance) ? instance : [...instance ? [instance] : []];\n    Object.values(this.shapes).forEach(({ shape, instanceItem }) => {\n      if (instances.indexOf(instanceItem.instance) >= 0) {\n        shape.borderColor = 0xFFFF00;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = 0xFFFF00;\n        }\n      } else {\n        shape.borderColor = shape.originColors.borderColor;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = shape.originColors.color;\n        }\n      }\n    });\n  };\n\n  /**\n   * click to draw a shape\n   * @param point\n   * @param shapeContainer\n   * @param imageBounds\n   * @param finishCallback\n   */\n  addShape = (\n    point?: Point,\n    shapeContainer?: Container,\n    imageBounds?: { left: number; top: number; right: number; bottom: number },\n    finishCallback?: () => void,\n  ) => {\n    if (this.rootStore.initialized && this.rootStore.config.addMode && !this.drawingShape) {\n      this.drawingShape = this.createShape(\n        shapeContainer || this.currentLayer!,\n        imageBounds || this.rootStore.frame.imageBounds,\n        this.rootStore.ontology.selectedCategoryItem.displayColor,\n        this.rootStore.ontology.selectedCategory.className,\n        this.rootStore.ontology.selectedCategoryItem.name,\n      );\n\n      // add listeners\n      this.drawingShape.on(EventAction.FINISHED, (shape, otherShapeData) => {\n        // remove listeners after creating\n        shape.off(EventAction.FINISHED);\n        shape.off(EventAction.REMOVED);\n\n        this.drawingShape = null;\n        this.rootStore.config.setAddMode(false);\n        // add shape to instance item\n        this.addShapeToCurrentInstanceItem(shape, otherShapeData);\n\n        // finish creating\n        // if (finishCallback) {\n        //   finishCallback();\n        // }\n      });\n      this.drawingShape.on(EventAction.REMOVED, () => {\n        this.drawingShape = null;\n      });\n      // start create\n      this.drawingShape.create(point);\n      return this.drawingShape;\n    }\n    return null;\n  };\n\n  /**\n   * add shape to current instance item\n   * @param shape\n   */\n  addShapeToCurrentInstanceItem = (shape: Shape<ShapeData>, otherShapeData?: ShapeData[]) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const instanceItem = this.rootStore.instance.getCurrentInstanceItem();\n    const data = shape.getData();\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    const { prevState: prevStateItem, currState: currStateItem } = instanceItem.addShape(\n      currentCamera,\n      currentFrame,\n      true,\n      shape.shapeType,\n      data,\n      shape.order,\n    );\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    const attributes = instanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [prevBasicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevStateItem ? [prevStateItem] : [] },\n        curr: { ...basicInfo, children: currStateItem ? [currStateItem] : [] }\n      }\n    };\n\n    if (otherShapeData) {\n      otherShapeData.forEach((shapeData) => {\n        const otherInstanceItem = this.rootStore.instance.getCurrentInstanceItem();\n\n        const prevInfo = otherInstanceItem.instance.getBasicInfo();\n        if (otherInstanceItem.instance !== instanceItem.instance) {\n          otherInstanceItem.instance.setAttributes(instanceItem.instance.attributes);\n        }\n\n        const { prevState, currState } = otherInstanceItem.updateShape(\n          currentCamera,\n          currentFrame,\n          true,\n          shape.shapeType,\n          shapeData,\n          this.rootStore.frame.getNextShapeOrder(),\n          attributes,\n        );\n        this.setupShape(otherInstanceItem);\n        const currInfo = otherInstanceItem.instance.getBasicInfo();\n        if (!instanceState[currInfo.id]) {\n          instanceState[currInfo.id] = {\n            prev: { ...prevInfo, children: [] },\n            curr: { ...currInfo, children: [] }\n          };\n        }\n        const state = instanceState[currInfo.id];\n        if (prevState) {\n          state.prev.children.push(prevState);\n        }\n        if (currState) {\n          state.curr.children.push(currState);\n        }\n      });\n    }\n\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev).filter((i) => i.children.length > 0),\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr),\n    });\n\n    // update shape instance\n    shape.label = instanceItem.label;\n    this.addShapeListeners(shape);\n    this.shapes[shape.uid] = { shape, camera: currentCamera, instanceItem };\n\n    // select\n    this.rootStore.instance.selectInstanceItem(instanceItem);\n    this.rootStore.instance.autoOpenAttributesModal();\n  };\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const { currentCamera, currentFrame, cameraViews, getImageBoundsForCamera } = this.rootStore.frame;\n    const currentCameraView = cameraViews[camera];\n    const imageBounds = getImageBoundsForCamera(camera);\n    if (currentCameraView?.imageLoadError) {\n      return;\n    }\n\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData?.frames[currentFrame]) {\n      return;\n    }\n\n    let shapeInfo;\n    const predictedItem = Object.values(this.predictedShapes).find((i) => i.instanceItem === instanceItem);\n    if (camera === currentCamera && predictedItem) {\n      // predicted shape in current camera exists, use it\n      const { shape } = predictedItem;\n      shapeInfo = {\n        shapeType: shape.shapeType,\n        shape: shape.getData(),\n      };\n      // remove predicted shape\n      shape.destroy();\n      delete this.predictedShapes[shape.uid];\n    } else {\n      shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n    }\n\n    if (shapeInfo) {\n      // add to model\n      this.rootStore.instance.updateFrameShapeForInstanceItem(\n        instanceItem,\n        currentFrame,\n        shapeInfo.shapeType,\n        shapeInfo.shape,\n        this.rootStore.frame.getNextShapeOrder(currentFrame, camera),\n        camera,\n      );\n      // create shape\n      this.setupShape(instanceItem, camera, currentCameraView.shapesLayer, imageBounds);\n      // select\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  };\n\n  /**\n   * setup shape in current camera & current frame\n   * @param instanceItem\n   * @param shapeContainer\n   * @param imageBounds\n   */\n  setupShape = (\n    instanceItem: InstanceItem,\n    camera = this.rootStore.frame.currentCamera,\n    shapeContainer?: Container,\n    imageBounds?: { left: number; top: number; right: number; bottom: number; },\n  ) => {\n    const { cameraViews, currentFrame } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        // remove shape if already exists\n        const existingShape = this.getShapeByInstanceItem(instanceItem, camera);\n        const existingShapeId = existingShape?.uid;\n        if (existingShape) {\n          this.deleteShape(existingShape);\n        }\n        // add shape\n        if (!cameraViews[camera]?.imageLoadError) {\n          let order;\n          if (frameData.order !== undefined) {\n            order = frameData.order;\n          } else {\n            order = this.rootStore.frame.getNextShapeOrder();\n          }\n          const shape = this.createShape(\n            shapeContainer || cameraViews[camera].shapesLayer,\n            imageBounds || this.rootStore.frame.getImageBoundsForCamera(camera),\n            instanceItem.categoryItemRef.displayColor,\n            instanceItem.instance.category,\n            instanceItem.name,\n            frameData.shapeType,\n            frameData.shape,\n            order,\n            instanceItem.label,\n            camera,\n          );\n          if (shape.destroyed) {\n            // delete instance item\n            this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame, camera);\n            return;\n          }\n          this.addShapeListeners(shape);\n          this.shapes[shape.uid] = { shape, camera, instanceItem };\n          if (this.pendingMergePolygon === existingShapeId) {\n            this.pendingMergePolygon = shape.uid;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * predict in current camera & current frame\n   */\n  predict = () => {\n    this.clearPredictedShapes();\n\n    const { isMultiSelected, selectedInstances, selectedInstanceItems } = this.rootStore.instance;\n    if (isMultiSelected) {\n      return;\n    }\n\n    if (selectedInstances.length === 1) {\n      const { currentCamera, currentFrame, currentCameraView, imageBounds } = this.rootStore.frame;\n      if (currentCameraView?.imageLoadError) {\n        return;\n      }\n\n      const selectedInstance = selectedInstances[0];\n      Object.values(selectedInstance.items).forEach((item) => {\n        const shapeInfo = item.predictShape(currentCamera, currentFrame, imageBounds);\n        if (shapeInfo) {\n          // create predict shape\n          const predictedShape = this.createShape(\n            this.currentLayer!,\n            imageBounds,\n            item.categoryItemRef.displayColor,\n            selectedInstance.category,\n            item.name,\n            shapeInfo.shapeType,\n            shapeInfo.shape,\n            9999, // predicted shape always on the top\n            item.label,\n          );\n          predictedShape.borderStyle = BorderStyle.DASHED;\n          predictedShape.borderColor = 0xFFFF00;\n          if (predictedShape.shapeType === ShapeType.DOT) {\n            predictedShape.color = 0xFFFF00;\n          }\n          predictedShape.editable = this.rootStore.config.reviewMode === ReviewMode.LABELING;\n          if (selectedInstanceItems.indexOf(item) >= 0) {\n            predictedShape.selected = true;\n          }\n          // add listeners\n          this.addShapeListeners(predictedShape);\n\n          this.predictedShapes[predictedShape.uid] = {\n            shape: predictedShape,\n            instanceItem: item,\n          };\n        }\n      });\n    }\n  };\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete = () => {\n    if (this.selectedShapes.length > 0) {\n      this.deleting = true;\n      this.selectedPointIndex = -1;\n\n      const pointsDeletedShapes: Shape<ShapeData>[] = [];\n      this.selectedShapes.forEach((shape) => {\n        const deleted = shape.deleteSelectedPoints();\n        if (deleted) {\n          pointsDeletedShapes.push(shape);\n        }\n      });\n\n      const { currentFrame } = this.rootStore.frame;\n      if (pointsDeletedShapes.length > 0) {\n        // has points deleted shapes\n        const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape?: ShapeData }[] = [];\n        pointsDeletedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            instanceItems.push({\n              instanceItem: shapeItem.instanceItem,\n              frameIndex: currentFrame,\n              shapeType: shape.shapeType,\n              shape: shape.destroyed ? undefined : shape.getData(),\n            });\n          }\n        });\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      } else {\n        // should delete shapes\n        const instanceItems: { instanceItem: InstanceItem, frames: number[] }[] = [];\n        this.selectedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            const { instanceItem } = shapeItem;\n            instanceItems.push({ instanceItem, frames: [currentFrame] });\n          }\n        });\n        this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);\n        this.predict();\n      }\n    }\n    this.deleting = false;\n  };\n\n  /**\n   * delete shape instance\n   * @param shape\n   */\n  deleteShape = (shape: Shape<ShapeData>) => {\n    const index = this.selectedShapes.indexOf(shape);\n    if (index >= 0) {\n      this.selectedShapes.splice(index, 1);\n    }\n    shape.destroy();\n    delete this.shapes[shape.uid];\n  };\n\n  /**\n   * delete shape by instance item\n   * @param instanceItem\n   */\n  deleteShapeByInstanceItem = (instanceItem: InstanceItem) => {\n    const shape = this.getShapeByInstanceItem(instanceItem);\n    if (shape) {\n      this.deleteShape(shape);\n    }\n  };\n\n  /**\n   * set points user data for shape\n   * @param shape\n   * @param pointIndex\n   * @param userData\n   */\n  setPointUserData = (shape: Shape<ShapeData>, pointIndex: number, userData: any) => {\n    if (shape instanceof Polygon || shape instanceof Line) {\n      const pointsData = [{ index: pointIndex, userData }];\n      shape.setPointsUserData(pointsData);\n    }\n  };\n\n  /**\n   * get intersections for shape\n   * @param shape\n   */\n  getIntersectionsForShape(shape: Shape<ShapeData>) {\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape).filter((s) => s.visible && s.finished);\n    const intersections = shape.findIntersections(shapes);\n    return intersections;\n  }\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA: Shape<ShapeData>, shapeB: Shape<ShapeData>) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const { instanceItem: instanceItemA } = this.shapes[shapeA.uid];\n    const { instanceItem: instanceItemB } = this.shapes[shapeB.uid];\n    const instanceInfoA = instanceItemA.instance.getBasicInfo();\n    const instanceInfoB = instanceItemB.instance.getBasicInfo();\n\n    // save state\n    const prevInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      prevInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    const storeId = this.rootStore.undo.preserve({ instances: prevInstances });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    shapeA.order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    shapeB.order = orderA;\n\n    const currInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      currInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    this.rootStore.undo.save(storeId, { instances: currInstances });\n  }\n\n  /**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */\n  moveToTop(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, getNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const maxOrder = Math.max(...cameraShapes.map((s) => s.shape.order));\n    if (maxOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_FRONT_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n    // preserve state\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n    // update order\n    const order = getNextShapeOrder();\n    frameData.order = order;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = order;\n    }\n    // save state\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n\n    message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));\n  }\n\n  /**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */\n  moveToBottom(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, updateNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const minOrder = Math.min(...cameraShapes.map((s) => s.shape.order));\n    if (minOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_BACK_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n\n    // prev instance state map\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n    // update selected shape order\n    const startOrder = 0;\n    frameData.order = startOrder;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = startOrder;\n    }\n    // current instance state map\n    const currInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n\n    if (minOrder <= startOrder) {\n      // show move all camera shapes upper\n      for (let i = 0; i < cameraShapes.length; i += 1) {\n        const { shape: s, instanceItem: sInstanceItem } = cameraShapes[i];\n        if (sInstanceItem.id !== instanceItem.id) {\n          // not selected shape\n          const sInstanceInfo = sInstanceItem.instance.getBasicInfo();\n          const sInstanceItemInfo = sInstanceItem.getBasicInfo();\n          const sCameraData = sInstanceItem.cameras[currentCamera];\n          if (!prevInstanceMap[sInstanceInfo.id]) {\n            prevInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          prevInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n          // update not selected shape's order\n          const order = s.order + 1;\n          sCameraData.frames[currentFrame].order = order;\n          s.order = order;\n          updateNextShapeOrder(order, currentFrame, currentCamera);\n          if (!currInstanceMap[sInstanceInfo.id]) {\n            currInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          currInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n        }\n      }\n    }\n\n    // save state\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n    });\n\n    message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));\n  }\n\n  /**\n   * move selected shape to front\n   * @param toTop\n   */\n  moveFront = (toTop = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (toTop) {\n        this.moveToTop(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const upperShape = getUpperShape(selectedShape, intersections);\n        if (upperShape) {\n          this.exchangeShapeOrder(selectedShape, upperShape);\n          message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_FRONT_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  /**\n   * move selected shape to back\n   * @param toBottom\n   */\n  moveBack = (toBottom = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (toBottom) {\n        this.moveToBottom(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const underShape = getUnderShape(selectedShape, intersections);\n        if (underShape) {\n          this.exchangeShapeOrder(selectedShape, underShape);\n          message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_BACK_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  merge = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1\n    ) {\n      return;\n    }\n\n    const selectedShape = this.selectedShapes[0];\n    const { shapeType } = selectedShape;\n    if (shapeType === ShapeType.POLYGON) {\n      // merge polygon\n      const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape);\n      const intersectPolygonIds = (selectedShape as Polygon).findIntersectPolygons(shapes);\n      if (intersectPolygonIds.length === 1) {\n        this.mergePolygons(selectedShape.uid, intersectPolygonIds[0]);\n      } else if (intersectPolygonIds.length === 0) {\n        message.warn(i18n.translate('MERGE_NO_INTERSECT'));\n      } else {\n        this.pendingMergePolygon = selectedShape.uid;\n        message.info(i18n.translate('MERGE_SELECT_NEXT'));\n      }\n    }\n  };\n\n  mergePolygons(polygonId1: string, polygonId2: string) {\n    const { shape: polygon1, instanceItem: instance1 } = this.shapes[polygonId1];\n    const { shape: polygon2, instanceItem: instance2 } = this.shapes[polygonId2];\n    const mergedData = (polygon1 as Polygon).merge(polygon2 as Polygon);\n    if (mergedData.length === 1) {\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const { prevState, currState } = this.rootStore.instance.deleteInstanceItemByFrame(instance2, currentFrame);\n\n      const { prevState: prevStateItem, currState: currStateItem } = instance1.updateShape(\n        currentCamera,\n        currentFrame,\n        true,\n        ShapeType.POLYGON,\n        mergedData[0],\n        this.rootStore.frame.getNextShapeOrder(),\n      );\n\n      this.setupShape(instance1);\n      this.selectShapeByInstanceItem(instance1);\n      const basicInfo = instance1.instance.getBasicInfo();\n\n      this.rootStore.undo.push({\n        instances: [\n          ...prevState.instances,\n          ...prevStateItem ? [{ ...basicInfo, children: [prevStateItem] }] : [],\n        ],\n      }, {\n        instances: [\n          ...currState.instances,\n          ...currStateItem ? [{ ...basicInfo, children: [currStateItem] }] : [],\n        ],\n      });\n\n      message.success(i18n.translate('MERGE_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('MERGE_WITH_HOLE'));\n    }\n  }\n\n  subtractPolygon = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1 ||\n      this.selectedShapes[0].shapeType !== ShapeType.POLYGON\n    ) {\n      return;\n    }\n\n    const selectedPolygon = this.selectedShapes[0] as Polygon;\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape);\n    const intersectPolygons = selectedPolygon.findIntersectPolygons(shapes, true).map((i) => this.shapes[i].shape);\n    const subtractedData = selectedPolygon.subtract(intersectPolygons);\n\n    if (subtractedData && subtractedData.length > 0) {\n      this.updatePolygons(subtractedData[0][0], subtractedData.slice(1).map((d) => d[0]));\n      message.success(i18n.translate('SUBTRACT_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));\n    }\n  };\n\n  updatePolygons(currPolygonData: PolygonData, otherPolygonData: PolygonData[]) {\n    this.updateShapes(currPolygonData, otherPolygonData, ShapeType.POLYGON);\n  }\n\n  updateShapes(currShapeData: ShapeData, otherShapeData: ShapeData[], shapeType = ShapeType.POLYGON) {\n    const selectedShape = this.selectedShapes[0];\n    const { instanceItem: selectedInstanceItem } = this.shapes[selectedShape.uid];\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const attributes = selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n\n    const prevBasicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const { prevState: prevStateItem, currState: currStateItem } = selectedInstanceItem.updateShape(\n      currentCamera,\n      currentFrame,\n      true,\n      shapeType,\n      currShapeData,\n      this.rootStore.frame.getNextShapeOrder(),\n      attributes,\n    );\n\n    const basicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [basicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevStateItem ? [prevStateItem] : [] },\n        curr: { ...basicInfo, children: currStateItem ? [currStateItem] : [] }\n      }\n    };\n\n    this.setupShape(selectedInstanceItem);\n\n    for (let i = 0; i < otherShapeData.length; i += 1) {\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category, selectedInstanceItem.name);\n\n      const prevInfo = instanceItem.instance.getBasicInfo();\n      if (instanceItem.instance !== selectedInstanceItem.instance) {\n        instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);\n        const dynamicAttributesCurrentFrame = selectedInstanceItem.instance.dynamicAttributes?.[currentCamera]?.[currentFrame];\n        if (dynamicAttributesCurrentFrame && instanceItem.instance.categoryRef.labelConfigDynamic) {\n          instanceItem.instance.setDynamicAttributesByCamera(currentCamera, [dynamicAttributesCurrentFrame]);\n        }\n      }\n\n      const { prevState, currState } = instanceItem.updateShape(\n        currentCamera,\n        currentFrame,\n        true,\n        shapeType,\n        otherShapeData[i],\n        this.rootStore.frame.getNextShapeOrder(),\n        attributes,\n      );\n      this.setupShape(instanceItem);\n      const currInfo = instanceItem.instance.getBasicInfo();\n      if (!instanceState[currInfo.id]) {\n        instanceState[currInfo.id] = {\n          prev: { ...prevInfo, children: [] },\n          curr: { ...currInfo, children: [] }\n        };\n      }\n      const state = instanceState[currInfo.id];\n      if (prevState) {\n        state.prev.children.push(prevState);\n      }\n      if (currState) {\n        state.curr.children.push(currState);\n      }\n    }\n    this.selectShapeByInstanceItem(selectedInstanceItem);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev).filter((i) => i.children.length > 0)\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr)\n    });\n  }\n\n  updateConfig = ({ fill, alpha, showVertex, showVertexOrder }: {\n    fill?: boolean,\n    alpha?: number,\n    showVertex?: boolean,\n    showVertexOrder?: boolean,\n  }) => {\n    if (fill !== undefined) {\n      this.config.fill = fill;\n      this.updateShapesFill(fill);\n    }\n    if (alpha !== undefined) {\n      this.config.alpha = alpha;\n      this.updateShapesAlpha(alpha / 100);\n    }\n    if (showVertex !== undefined) {\n      this.config.showVertex = showVertex;\n      this.updateShowVertex(showVertex);\n    }\n    if (showVertexOrder !== undefined) {\n      this.config.showVertexOrder = showVertexOrder;\n      this.updateShowVertexOrder(showVertexOrder);\n    }\n  };\n\n  updateShapesFill = (fill: boolean) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.alpha = fill ? this.config.alpha / 100 : 0;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.alpha = fill ? this.config.alpha / 100 : 0;\n    });\n  };\n\n  updateShapesAlpha = (alpha: number) => {\n    if (this.config.fill) {\n      if (this.drawingShape) {\n        this.drawingShape.alpha = alpha;\n      }\n      Object.values(this.shapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n      Object.values(this.predictedShapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n    }\n  };\n\n  updateShowVertex = (showVertex: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertex = showVertex;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n  };\n\n  updateShowVertexOrder = (showVertexOrder: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertexOrder = showVertexOrder;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n  };\n\n  resetConfig = () => {\n    this.updateConfig({ ...this.defaultConfig });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}