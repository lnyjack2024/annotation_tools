{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport { getNextKeyFrames, preciseShapeByType } from '../utils';\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map = {};\n    Object.values(this.instances).forEach(instance => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({\n      className\n    }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.number - b.number);\n      }\n    });\n    return map;\n  }\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    const {\n      categories\n    } = this.rootStore.ontology;\n    return Object.values(this.instances).sort((a, b) => {\n      const instanceAFirstFrame = Number(Object.keys(a.frameStatus)[0]);\n      const instanceBFirstFrame = Number(Object.keys(b.frameStatus)[0]);\n      if (instanceAFirstFrame > instanceBFirstFrame) {\n        return 1;\n      }\n      if (instanceAFirstFrame < instanceBFirstFrame) {\n        return -1;\n      }\n      const instanceACategoryIndex = categories.findIndex(c => c.className === a.category);\n      const instanceBCategoryIndex = categories.findIndex(c => c.className === b.category);\n      if (instanceACategoryIndex > instanceBCategoryIndex) {\n        return 1;\n      }\n      if (instanceACategoryIndex < instanceBCategoryIndex) {\n        return -1;\n      }\n      return a.number > b.number ? 1 : -1;\n    });\n  }\n\n  /**\n   * multiple instance item selected\n   * @getter\n   */\n  get isMultiSelected() {\n    return this.selectedInstances.length > 1 || this.selectedInstanceItems.length > 1;\n  }\n\n  /**\n   * single instance item selected\n   */\n  get isSingleSelected() {\n    return this.selectedInstances.length === 1 && this.selectedInstanceItems.length === 1;\n  }\n\n  /**\n   * does selected instance has label config to set attributes\n   * @getter\n   */\n  get selectedInstanceAttributesEnabled() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return false;\n    }\n    const selectedInstance = this.selectedInstances[0];\n    const selectedInstanceItem = this.selectedInstanceItems.length === 1 ? this.selectedInstanceItems[0] : undefined;\n    return this.isAttributesEnabled(selectedInstance, selectedInstanceItem);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * all instances\n     */\n    this.instances = {};\n    /**\n     * selected instances\n     */\n    this.selectedInstances = [];\n    /**\n     * selected instance items\n     */\n    this.selectedInstanceItems = [];\n    /**\n     * delete frames from instance item\n     * @param instanceItem\n     * @param frames\n     * @param camera\n     */\n    this.deleteFramesFromInstanceItem = (instanceItem, frames, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      if (camera === currentCamera && frames.includes(currentFrame)) {\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      }\n      const {\n        prevState,\n        currState\n      } = instanceItem.remove(camera, frames);\n      const basicInfo = instanceItem.instance.getBasicInfo();\n      this.rootStore.undo.push({\n        instances: prevState ? [{\n          ...prevBasicInfo,\n          children: [prevState]\n        }] : []\n      }, {\n        instances: currState ? [{\n          ...basicInfo,\n          children: [currState]\n        }] : []\n      });\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instanceItem.instance.isEmpty) {\n        this.deleteInstance(instanceItem.instance);\n      }\n    };\n    /**\n     * delete frames from instance items\n     * @param instanceItems\n     */\n    this.deleteFramesFromInstanceItems = instanceItems => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const prevInstanceMap = {};\n      const currInstanceMap = {};\n      for (let i = 0; i < instanceItems.length; i += 1) {\n        const {\n          instanceItem,\n          frames,\n          camera = currentCamera\n        } = instanceItems[i];\n        const {\n          instance\n        } = instanceItem;\n        const {\n          id: instanceId\n        } = instance;\n        if (camera === currentCamera && frames.includes(currentFrame)) {\n          // remove shape\n          this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        }\n        const prevInstanceBasicInfo = instance.getBasicInfo();\n        const {\n          prevState,\n          currState\n        } = instanceItem.remove(camera, frames);\n        if (prevState) {\n          if (!prevInstanceMap[instanceId]) {\n            prevInstanceMap[instanceId] = {\n              ...prevInstanceBasicInfo,\n              children: []\n            };\n          }\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instance.isEmpty) {\n          this.deleteInstance(instance);\n        }\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap)\n      }, {\n        instances: Object.values(currInstanceMap)\n      });\n    };\n    this.deleteInstanceItemByFrame = (instanceItem, frame, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const prevInstanceBasicInfo = instanceItem.instance.getBasicInfo();\n      if (camera === currentCamera && frame === currentFrame) {\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      }\n      const {\n        prevState,\n        currState\n      } = instanceItem.remove(camera, [frame]);\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instanceItem.instance.isEmpty) {\n        this.deleteInstance(instanceItem.instance);\n      }\n      return {\n        prevState: {\n          instances: prevState ? [{\n            ...prevInstanceBasicInfo,\n            children: [prevState]\n          }] : []\n        },\n        currState: {\n          instances: currState ? [{\n            ...instanceItem.instance.getBasicInfo(),\n            children: [currState]\n          }] : []\n        }\n      };\n    };\n    /**\n     * delete frames from instance item by type\n     * @param instanceItem\n     * @param type\n     * @param camera\n     */\n    this.deleteFramesFromInstanceItemByType = (instanceItem, type = 'current', camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentFrame\n      } = this.rootStore.frame;\n      switch (type) {\n        case 'current':\n          this.deleteFramesFromInstanceItem(instanceItem, [currentFrame]);\n          break;\n        case 'key':\n          {\n            const nextKeyFrames = getNextKeyFrames(1, currentFrame, instanceItem.cameras[camera].frames);\n            const nextKeyFrame = nextKeyFrames[0];\n            if (nextKeyFrame) {\n              this.deleteFramesFromInstanceItem(instanceItem, Array.from({\n                length: nextKeyFrame - currentFrame\n              }).map((_, index) => currentFrame + index));\n            }\n            break;\n          }\n        case 'following':\n          {\n            const allFrames = Object.keys(instanceItem.cameras[camera].frames).map(f => parseInt(f, 10));\n            const index = allFrames.indexOf(currentFrame);\n            this.deleteFramesFromInstanceItem(instanceItem, allFrames.slice(index, allFrames.length));\n            break;\n          }\n        case 'all':\n          {\n            const allFrames = Object.keys(instanceItem.cameras[camera].frames).map(f => parseInt(f, 10));\n            this.deleteFramesFromInstanceItem(instanceItem, allFrames);\n            break;\n          }\n        default:\n      }\n    };\n    makeAutoObservable(this, {\n      rootStore: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(instances) {\n    const {\n      getCategory\n    } = this.rootStore.ontology;\n    const {\n      cameraNames,\n      updateNextShapeOrder\n    } = this.rootStore.frame;\n    const categoryNumbers = {};\n    const numberDuplicatedInstances = [];\n    instances.forEach(instance => {\n      const category = getCategory(instance.category);\n      if (category) {\n        instance.children.forEach(instanceItem => {\n          const categoryItem = category.children.find(c => c.name === instanceItem.name);\n          if (categoryItem) {\n            instanceItem.cameras.forEach(cameraData => {\n              if (cameraNames.includes(cameraData.camera)) {\n                cameraData.frames.forEach(frameData => {\n                  // fix shape data precision\n                  preciseShapeByType(frameData.shapeType, frameData.shape);\n                  // update next shape order\n                  if (typeof frameData.order === 'number' && frameData.order >= 0) {\n                    updateNextShapeOrder(frameData.order, frameData.frameIndex, cameraData.camera);\n                  }\n                });\n              } else {\n                cameraData.frames = [];\n              }\n            });\n            instanceItem.cameras = instanceItem.cameras.filter(c => c.frames.length > 0); // remove invalid camera data\n          } else {\n            instanceItem.cameras = [];\n          }\n        });\n        instance.children = instance.children.filter(i => i.cameras.length > 0); // remove invalid instance item data\n        if (instance.children.length > 0) {\n          if (!categoryNumbers[category.className]) {\n            categoryNumbers[category.className] = [];\n          }\n          const checkNumbers = categoryNumbers[category.className];\n          if (this.rootStore.annotatable && checkNumbers.indexOf(instance.number) >= 0) {\n            // number already exists, fix number later\n            numberDuplicatedInstances.push(instance);\n          } else {\n            categoryNumbers[category.className].push(instance.number);\n            this.createInstanceFromData(instance);\n          }\n        }\n      }\n    });\n    numberDuplicatedInstances.forEach(instance => {\n      const number = this.rootStore.instance.getNextInstanceNumber(instance.category);\n      instance.number = number;\n      this.createInstanceFromData(instance);\n    });\n  }\n\n  /**\n   * create instance from structured instance data\n   * @param instance\n   */\n  createInstanceFromData(instance) {\n    const category = this.rootStore.ontology.getCategory(instance.category);\n    if (category) {\n      const newInstance = new Instance({\n        id: instance.id,\n        categoryRef: category,\n        number: instance.number,\n        attributes: instance.attributes,\n        dynamicAttributes: instance.dynamicAttributes,\n        items: instance.children,\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder\n      });\n      this.instances[newInstance.id] = newInstance;\n    }\n  }\n\n  /**\n   * is instance dynamic attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceDynamicAttributesEnabled(instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfigDynamic;\n  }\n\n  /**\n   * is instance item attributes enabled\n   * @param instanceItem\n   */\n  isInstanceItemAttributesEnabled(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        if (instanceItem.categoryItemRef.labelConfig) {\n          // instance item has label config setting\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * is instance & instance item attributes enabled\n   * @param instance\n   * @param instanceItem\n   */\n  isAttributesEnabled(instance, instanceItem) {\n    const instanceDynamicAttributesEnabled = this.isInstanceDynamicAttributesEnabled(instance);\n    if (instanceDynamicAttributesEnabled) {\n      return true;\n    }\n    if (instanceItem) {\n      return this.isInstanceItemAttributesEnabled(instanceItem);\n    }\n    return Object.values(instance.items).some(item => this.isInstanceItemAttributesEnabled(item));\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * get next instance number\n   * @param categoryName\n   */\n  getNextInstanceNumber(categoryName) {\n    const categoryInstanceNumbers = (this.categoryInstancesMap[categoryName] || []).map(i => i.number);\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * get next instance item number\n   * @param instanceId\n   * @param categoryItemName\n   * @param camera\n   */\n  getNextInstanceItemNumber(instanceId, categoryItemName, camera = this.rootStore.frame.currentCamera) {\n    const instance = this.instances[instanceId];\n    const items = Object.values(instance.items).filter(i => i.name === categoryItemName);\n    const itemsInCamera = items.filter(i => {\n      const cameraData = i.cameras[camera];\n      return cameraData && !cameraData.isEmpty;\n    });\n    const itemNumbers = itemsInCamera.map(i => i.number);\n    return Math.max(...itemNumbers, 0) + 1;\n  }\n\n  /**\n   * update selected instance\n   * @param instance\n   */\n  updateSelectedInstance(instance) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances.forEach(i => {\n      if (instances.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstances = [...instances];\n    this.selectedInstances.forEach(i => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * update selected instance item\n   * @param instanceItem\n   */\n  updateSelectedInstanceItem(instanceItem) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems.forEach(i => {\n      if (instanceItems.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstanceItems = [...instanceItems];\n    this.selectedInstanceItems.forEach(i => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * select instance\n   * @param instance\n   * @param autoFocus\n   */\n  selectInstance(instance, autoFocus = false) {\n    const instances = Array.isArray(instance) ? instance : [...(instance ? [instance] : [])];\n    this.updateSelectedInstance(instances);\n    if (instances.length > 0) {\n      // select category if needed\n      const allCategories = instances.map(i => i.category);\n      if (allCategories.indexOf(this.rootStore.ontology.selectedCategoryName) < 0) {\n        this.rootStore.ontology.selectCategory(allCategories[0]);\n      }\n\n      // filter selected instance item\n      const instanceItems = this.selectedInstanceItems.filter(i => instances.indexOf(i.instance) >= 0);\n\n      // if the instance is single, default select first instance item\n      if (this.rootStore.frame.isSingleCamera) {\n        instances.forEach(i => {\n          if (i.isSingle && Object.keys(i.items).length > 0) {\n            const item = Object.values(i.items)[0];\n            if (instanceItems.indexOf(item) < 0) {\n              instanceItems.push(item);\n            }\n          }\n        });\n      }\n      this.updateSelectedInstanceItem(instanceItems);\n    } else {\n      this.updateSelectedInstanceItem([]);\n    }\n\n    // update shape selection\n    this.rootStore.shape.selectShapeByInstanceItem(this.selectedInstanceItems);\n    this.rootStore.shape.updateShapesInInstance(instances);\n    if (autoFocus) {\n      this.rootStore.shape.fitShapes();\n    }\n  }\n\n  /**\n   * select instance item\n   * @param instanceItem\n   * @param autoFocus\n   */\n  selectInstanceItem(instanceItem, autoFocus = false) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...(instanceItem ? [instanceItem] : [])];\n    this.updateSelectedInstanceItem(instanceItems);\n    const instanceSet = new Set(instanceItems.map(i => i.instance));\n    const instances = Array.from(instanceSet);\n    this.selectInstance(instances, autoFocus);\n  }\n\n  /**\n   * get current editing instance item\n   */\n  getCurrentInstanceItem(currentCategoryName = this.rootStore.ontology.selectedCategoryName, currentCategoryItemName = this.rootStore.ontology.selectedCategoryItemName) {\n    const selectedInstance = this.selectedInstances.find(i => i.category === currentCategoryName) || this.selectedInstances[0];\n    if (selectedInstance && selectedInstance.category === currentCategoryName) {\n      const selectedInstanceItems = this.selectedInstanceItems.filter(i => i.instance === selectedInstance);\n      const selectedInstanceItem = selectedInstanceItems.find(i => i.name === currentCategoryItemName) || selectedInstanceItems[0];\n      if (selectedInstanceItem && selectedInstanceItem.name === currentCategoryItemName) {\n        // has selected instance item\n        const {\n          currentCamera,\n          currentFrame\n        } = this.rootStore.frame;\n        const {\n          frames\n        } = selectedInstanceItem.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          // not exist in current frame\n          return selectedInstanceItem;\n        }\n      }\n      const category = this.rootStore.ontology.getCategoryItem(currentCategoryName, currentCategoryItemName);\n      if (category) {\n        const {\n          currentCamera\n        } = this.rootStore.frame;\n        const {\n          name,\n          count\n        } = category;\n        // find items exist in current camera\n        const items = selectedInstance.getItemsByName(name).filter(i => {\n          const cameraData = i.cameras[currentCamera];\n          return cameraData && !cameraData.isEmpty;\n        });\n        if (count !== undefined && items.length < count) {\n          return this.createInstanceItem(selectedInstance, currentCategoryItemName);\n        }\n      }\n    }\n\n    // return a new instance\n    const instance = this.createInstance(currentCategoryName);\n    return this.createInstanceItem(instance, currentCategoryItemName);\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  createInstance(categoryName = this.rootStore.ontology.selectedCategory.className) {\n    const category = this.rootStore.ontology.getCategory(categoryName);\n    if (category) {\n      const instance = new Instance({\n        categoryRef: category,\n        number: this.getNextInstanceNumber(categoryName),\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder\n      });\n      this.instances[instance.id] = instance;\n      return instance;\n    }\n    return undefined;\n  }\n\n  /**\n   * create instance item\n   * @param instance\n   * @param categoryItem\n   */\n  createInstanceItem(instance, categoryItem = this.rootStore.ontology.selectedCategoryItem.name) {\n    const number = this.getNextInstanceItemNumber(instance.id, categoryItem);\n    const existItem = instance.getItem(categoryItem, number);\n    if (existItem) {\n      return existItem;\n    }\n    // create\n    const {\n      children = []\n    } = instance.categoryRef;\n    const item = children.find(c => c.name === categoryItem);\n    const instanceItem = new InstanceItem({\n      instance,\n      categoryItemRef: item || children[0],\n      number\n    });\n    instance.items[instanceItem.id] = instanceItem;\n    return instanceItem;\n  }\n\n  /**\n   * delete instance\n   * @param instance\n   */\n  deleteInstance(instance) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances = this.selectedInstances.filter(i => instances.indexOf(i) < 0);\n    this.selectedInstanceItems = this.selectedInstanceItems.filter(i => instances.indexOf(i.instance) < 0);\n    instances.forEach(i => {\n      i.destroy();\n      delete this.instances[i.id];\n    });\n  }\n\n  /**\n   * delete instance item\n   * @param instanceItem\n   */\n  deleteInstanceItem(instanceItem) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems = this.selectedInstanceItems.filter(i => instanceItems.indexOf(i) < 0);\n    instanceItems.forEach(({\n      id,\n      instance\n    }) => {\n      instance.removeItem(id);\n    });\n  }\n  /**\n   * update frame shape info for instance item\n   * @param instanceItem\n   * @param frameIndex\n   * @param shapeType\n   * @param shape\n   * @param order\n   * @param camera\n   */\n  updateFrameShapeForInstanceItem(instanceItem, frameIndex, shapeType, shape, order, camera = this.rootStore.frame.currentCamera) {\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    const {\n      prevState,\n      currState\n    } = instanceItem.updateShape(camera, frameIndex, true, shapeType, shape, order);\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    const instanceState = {\n      [basicInfo.id]: {\n        prev: {\n          ...prevBasicInfo,\n          children: prevState ? [prevState] : []\n        },\n        curr: {\n          ...basicInfo,\n          children: currState ? [currState] : []\n        }\n      }\n    };\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map(i => i.prev)\n    }, {\n      instances: Object.values(instanceState).map(i => i.curr)\n    });\n  }\n\n  /**\n   * update frame shape info for instance items list\n   * @param instanceItems\n   */\n  updateFrameShapeForInstanceItems(instanceItems) {\n    const prevInstanceMap = {};\n    const currInstanceMap = {};\n    // const { currentCamera, currentFrame } = this.rootStore.frame;\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const {\n        instanceItem,\n        frameIndex,\n        shapeType,\n        shape,\n        order,\n        camera = this.rootStore.frame.currentCamera\n      } = instanceItems[i];\n      let state;\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      if (shape) {\n        // update\n        state = instanceItem.updateShape(camera, frameIndex, true, shapeType, shape, order);\n      } else {\n        // delete\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        state = instanceItem.remove(camera, [frameIndex]);\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instanceItem.instance.isEmpty) {\n          this.deleteInstance(instanceItem.instance);\n        }\n      }\n      if (state) {\n        const {\n          prevState,\n          currState\n        } = state;\n        const {\n          instance\n        } = instanceItem;\n        const {\n          id: instanceId\n        } = instance;\n        if (prevState) {\n          if (!prevInstanceMap[instanceId]) {\n            prevInstanceMap[instanceId] = {\n              ...prevBasicInfo,\n              children: []\n            };\n          }\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap)\n    }, {\n      instances: Object.values(currInstanceMap)\n    });\n  }\n\n  /**\n   * open attributes modal automatically for selected instance\n   */\n  autoOpenAttributesModal() {\n    var _selectedInstance$dyn, _selectedInstance$dyn2;\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return;\n    }\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const shouldOpen = instanceItem => {\n      var _instanceItem$cameras;\n      const frameData = (_instanceItem$cameras = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras === void 0 ? void 0 : _instanceItem$cameras.frames[currentFrame];\n      if (instanceItem.categoryItemRef.labelConfig && !(frameData === null || frameData === void 0 ? void 0 : frameData.attributes)) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n      return false;\n    };\n    if (this.selectedInstanceItems.length === 1) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const open = shouldOpen(selectedInstanceItem);\n      if (open) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return;\n      }\n    }\n    const selectedInstance = this.selectedInstances[0];\n    const {\n      labelConfigDynamic\n    } = selectedInstance.categoryRef;\n    if (labelConfigDynamic && (!selectedInstance.dynamicAttributes || !((_selectedInstance$dyn = selectedInstance.dynamicAttributes[currentCamera]) === null || _selectedInstance$dyn === void 0 ? void 0 : (_selectedInstance$dyn2 = _selectedInstance$dyn[currentFrame]) === null || _selectedInstance$dyn2 === void 0 ? void 0 : _selectedInstance$dyn2.attributes))) {\n      this.rootStore.config.setAttributesModalVisible(true);\n      return true;\n    }\n    if (this.selectedInstanceItems.length <= 0 && Object.values(selectedInstance.items).some(i => shouldOpen(i))) {\n      // no instance item selected\n      this.rootStore.config.setAttributesModalVisible(true);\n    }\n  }\n\n  /**\n   * get instances json data (for save)\n   */\n  instancesJSON() {\n    return Object.values(this.instances).map(instance => instance.toJSON());\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  getCurrentDynamicAttributesByInstance(instance) {\n    var _instance$dynamicAttr, _instance$dynamicAttr2;\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const {\n      attributes = {}\n    } = ((_instance$dynamicAttr = instance.dynamicAttributes) === null || _instance$dynamicAttr === void 0 ? void 0 : (_instance$dynamicAttr2 = _instance$dynamicAttr[currentCamera]) === null || _instance$dynamicAttr2 === void 0 ? void 0 : _instance$dynamicAttr2[currentFrame]) || {};\n    return attributes;\n  }\n}","map":{"version":3,"names":["makeAutoObservable","Instance","InstanceItem","getNextKeyFrames","preciseShapeByType","InstanceStore","categoryInstancesMap","map","Object","values","instances","forEach","instance","category","push","rootStore","ontology","categories","className","sort","a","b","number","allInstances","instanceAFirstFrame","Number","keys","frameStatus","instanceBFirstFrame","instanceACategoryIndex","findIndex","c","instanceBCategoryIndex","isMultiSelected","selectedInstances","length","selectedInstanceItems","isSingleSelected","selectedInstanceAttributesEnabled","selectedInstance","selectedInstanceItem","undefined","isAttributesEnabled","constructor","deleteFramesFromInstanceItem","instanceItem","frames","camera","frame","currentCamera","currentFrame","prevBasicInfo","getBasicInfo","includes","shape","deleteShapeByInstanceItem","prevState","currState","remove","basicInfo","undo","children","isEmpty","deleteInstanceItem","deleteInstance","deleteFramesFromInstanceItems","instanceItems","prevInstanceMap","currInstanceMap","i","id","instanceId","prevInstanceBasicInfo","deleteInstanceItemByFrame","deleteFramesFromInstanceItemByType","type","nextKeyFrames","cameras","nextKeyFrame","Array","from","_","index","allFrames","f","parseInt","indexOf","slice","autoBind","init","getCategory","cameraNames","updateNextShapeOrder","categoryNumbers","numberDuplicatedInstances","categoryItem","find","name","cameraData","frameData","shapeType","order","frameIndex","filter","checkNumbers","annotatable","createInstanceFromData","getNextInstanceNumber","newInstance","categoryRef","attributes","dynamicAttributes","items","getNextShapeOrder","isInstanceDynamicAttributesEnabled","labelConfigDynamic","isInstanceItemAttributesEnabled","categoryItemRef","labelConfig","instanceDynamicAttributesEnabled","some","item","getInstanceById","categoryName","categoryInstanceNumbers","Math","max","getNextInstanceItemNumber","categoryItemName","itemsInCamera","itemNumbers","updateSelectedInstance","isArray","setSelected","updateSelectedInstanceItem","selectInstance","autoFocus","allCategories","selectedCategoryName","selectCategory","isSingleCamera","isSingle","selectShapeByInstanceItem","updateShapesInInstance","fitShapes","selectInstanceItem","instanceSet","Set","getCurrentInstanceItem","currentCategoryName","currentCategoryItemName","selectedCategoryItemName","getCategoryItem","count","getItemsByName","createInstanceItem","createInstance","selectedCategory","selectedCategoryItem","existItem","getItem","destroy","removeItem","updateFrameShapeForInstanceItem","updateShape","instanceState","prev","curr","updateFrameShapeForInstanceItems","state","autoOpenAttributesModal","_selectedInstance$dyn","_selectedInstance$dyn2","shouldOpen","_instanceItem$cameras","config","setAttributesModalVisible","open","instancesJSON","toJSON","getCurrentDynamicAttributesByInstance","_instance$dynamicAttr","_instance$dynamicAttr2"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/InstanceStore.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport { getNextKeyFrames, preciseShapeByType } from '../utils';\nimport { Instance as IInstance } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * all instances\n   */\n  instances: { [instanceId: string]: Instance } = {};\n\n  /**\n   * selected instances\n   */\n  selectedInstances: Instance[] = [];\n\n  /**\n   * selected instance items\n   */\n  selectedInstanceItems: InstanceItem[] = [];\n\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map: { [categoryName: string]: Instance[] } = {};\n    Object.values(this.instances).forEach((instance) => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({ className }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.number - b.number);\n      }\n    });\n    return map;\n  };\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    const { categories } = this.rootStore.ontology;\n    return Object.values(this.instances)\n      .sort((a, b) => {\n        const instanceAFirstFrame = Number(Object.keys(a.frameStatus)[0]);\n        const instanceBFirstFrame = Number(Object.keys(b.frameStatus)[0]);\n        if (instanceAFirstFrame > instanceBFirstFrame) {\n          return 1;\n        }\n        if (instanceAFirstFrame < instanceBFirstFrame) {\n          return -1;\n        }\n        const instanceACategoryIndex = categories.findIndex((c) => c.className === a.category);\n        const instanceBCategoryIndex = categories.findIndex((c) => c.className === b.category);\n        if (instanceACategoryIndex > instanceBCategoryIndex) {\n          return 1;\n        }\n        if (instanceACategoryIndex < instanceBCategoryIndex) {\n          return -1;\n        }\n        return a.number > b.number ? 1 : -1;\n      });\n  }\n\n  /**\n   * multiple instance item selected\n   * @getter\n   */\n  get isMultiSelected() {\n    return this.selectedInstances.length > 1 || this.selectedInstanceItems.length > 1;\n  }\n\n  /**\n   * single instance item selected\n   */\n  get isSingleSelected() {\n    return this.selectedInstances.length === 1 && this.selectedInstanceItems.length === 1;\n  }\n\n  /**\n   * does selected instance has label config to set attributes\n   * @getter\n   */\n  get selectedInstanceAttributesEnabled() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return false;\n    }\n\n    const selectedInstance = this.selectedInstances[0];\n    const selectedInstanceItem = this.selectedInstanceItems.length === 1 ? this.selectedInstanceItems[0] : undefined;\n    return this.isAttributesEnabled(selectedInstance, selectedInstanceItem);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(instances: IInstance[]) {\n    const { getCategory } = this.rootStore.ontology;\n    const { cameraNames, updateNextShapeOrder } = this.rootStore.frame;\n    const categoryNumbers: { [category: string]: number[] } = {};\n    const numberDuplicatedInstances: IInstance[] = [];\n    instances.forEach((instance) => {\n      const category = getCategory(instance.category);\n      if (category) {\n        instance.children.forEach((instanceItem) => {\n          const categoryItem = category.children.find((c) => c.name === instanceItem.name);\n          if (categoryItem) {\n            instanceItem.cameras.forEach((cameraData) => {\n              if (cameraNames.includes(cameraData.camera)) {\n                cameraData.frames.forEach((frameData) => {\n                  // fix shape data precision\n                  preciseShapeByType(frameData.shapeType, frameData.shape);\n                  // update next shape order\n                  if (typeof frameData.order === 'number' && frameData.order >= 0) {\n                    updateNextShapeOrder(frameData.order, frameData.frameIndex, cameraData.camera);\n                  }\n                });\n              } else {\n                cameraData.frames = [];\n              }\n            });\n            instanceItem.cameras = instanceItem.cameras.filter((c) => c.frames.length > 0); // remove invalid camera data\n          } else {\n            instanceItem.cameras = [];\n          }\n        });\n        instance.children = instance.children.filter((i) => i.cameras.length > 0); // remove invalid instance item data\n        if (instance.children.length > 0) {\n          if (!categoryNumbers[category.className]) {\n            categoryNumbers[category.className] = [];\n          }\n          const checkNumbers = categoryNumbers[category.className];\n          if (this.rootStore.annotatable && checkNumbers.indexOf(instance.number) >= 0) {\n            // number already exists, fix number later\n            numberDuplicatedInstances.push(instance);\n          } else {\n            categoryNumbers[category.className].push(instance.number);\n            this.createInstanceFromData(instance);\n          }\n        }\n      }\n    });\n    numberDuplicatedInstances.forEach((instance) => {\n      const number = this.rootStore.instance.getNextInstanceNumber(instance.category);\n      instance.number = number;\n      this.createInstanceFromData(instance);\n    });\n  }\n\n  /**\n   * create instance from structured instance data\n   * @param instance\n   */\n  createInstanceFromData(instance: IInstance) {\n    const category = this.rootStore.ontology.getCategory(instance.category);\n    if (category) {\n      const newInstance = new Instance({\n        id: instance.id,\n        categoryRef: category,\n        number: instance.number,\n        attributes: instance.attributes,\n        dynamicAttributes: instance.dynamicAttributes,\n        items: instance.children,\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder,\n      });\n      this.instances[newInstance.id] = newInstance;\n    }\n  }\n\n  /**\n   * is instance dynamic attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceDynamicAttributesEnabled(instance: Instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfigDynamic;\n  }\n\n  /**\n   * is instance item attributes enabled\n   * @param instanceItem\n   */\n  isInstanceItemAttributesEnabled(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        if (instanceItem.categoryItemRef.labelConfig) {\n          // instance item has label config setting\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * is instance & instance item attributes enabled\n   * @param instance\n   * @param instanceItem\n   */\n  isAttributesEnabled(instance: Instance, instanceItem?: InstanceItem) {\n    const instanceDynamicAttributesEnabled = this.isInstanceDynamicAttributesEnabled(instance);\n    if (instanceDynamicAttributesEnabled) {\n      return true;\n    }\n    if (instanceItem) {\n      return this.isInstanceItemAttributesEnabled(instanceItem);\n    }\n    return Object.values(instance.items).some((item) => this.isInstanceItemAttributesEnabled(item));\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId: string) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * get next instance number\n   * @param categoryName\n   */\n  getNextInstanceNumber(categoryName: string) {\n    const categoryInstanceNumbers = (this.categoryInstancesMap[categoryName] || []).map((i) => i.number);\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * get next instance item number\n   * @param instanceId\n   * @param categoryItemName\n   * @param camera\n   */\n  getNextInstanceItemNumber(instanceId: string, categoryItemName: string, camera = this.rootStore.frame.currentCamera) {\n    const instance = this.instances[instanceId];\n    const items = Object.values(instance.items).filter((i) => i.name === categoryItemName);\n    const itemsInCamera = items.filter((i) => {\n      const cameraData = i.cameras[camera];\n      return cameraData && !cameraData.isEmpty;\n    });\n    const itemNumbers = itemsInCamera.map((i) => i.number);\n    return Math.max(...itemNumbers, 0) + 1;\n  }\n\n  /**\n   * update selected instance\n   * @param instance\n   */\n  updateSelectedInstance(instance: Instance | Instance[]) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances.forEach((i) => {\n      if (instances.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstances = [...instances];\n    this.selectedInstances.forEach((i) => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * update selected instance item\n   * @param instanceItem\n   */\n  updateSelectedInstanceItem(instanceItem: InstanceItem | InstanceItem[]) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems.forEach((i) => {\n      if (instanceItems.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstanceItems = [...instanceItems];\n    this.selectedInstanceItems.forEach((i) => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * select instance\n   * @param instance\n   * @param autoFocus\n   */\n  selectInstance(instance?: Instance | Instance[] | null, autoFocus = false) {\n    const instances = Array.isArray(instance) ? instance : [...instance ? [instance] : []];\n    this.updateSelectedInstance(instances);\n\n    if (instances.length > 0) {\n      // select category if needed\n      const allCategories = instances.map((i) => i.category);\n      if (allCategories.indexOf(this.rootStore.ontology.selectedCategoryName) < 0) {\n        this.rootStore.ontology.selectCategory(allCategories[0]);\n      }\n\n      // filter selected instance item\n      const instanceItems: InstanceItem[] = this.selectedInstanceItems.filter((i) => instances.indexOf(i.instance) >= 0);\n\n      // if the instance is single, default select first instance item\n      if (this.rootStore.frame.isSingleCamera) {\n        instances.forEach((i) => {\n          if (i.isSingle && Object.keys(i.items).length > 0) {\n            const item = Object.values(i.items)[0];\n            if (instanceItems.indexOf(item) < 0) {\n              instanceItems.push(item);\n            }\n          }\n        });\n      }\n      this.updateSelectedInstanceItem(instanceItems);\n    } else {\n      this.updateSelectedInstanceItem([]);\n    }\n\n    // update shape selection\n    this.rootStore.shape.selectShapeByInstanceItem(this.selectedInstanceItems);\n    this.rootStore.shape.updateShapesInInstance(instances);\n    if (autoFocus) {\n      this.rootStore.shape.fitShapes();\n    }\n  }\n\n  /**\n   * select instance item\n   * @param instanceItem\n   * @param autoFocus\n   */\n  selectInstanceItem(instanceItem?: InstanceItem | InstanceItem[] | null, autoFocus = false) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...instanceItem ? [instanceItem] : []];\n    this.updateSelectedInstanceItem(instanceItems);\n    const instanceSet = new Set(instanceItems.map((i) => i.instance));\n    const instances = Array.from(instanceSet);\n    this.selectInstance(instances, autoFocus);\n  }\n\n  /**\n   * get current editing instance item\n   */\n  getCurrentInstanceItem(\n    currentCategoryName = this.rootStore.ontology.selectedCategoryName,\n    currentCategoryItemName = this.rootStore.ontology.selectedCategoryItemName\n  ) {\n    const selectedInstance = this.selectedInstances.find((i) => i.category === currentCategoryName) || this.selectedInstances[0];\n    if (selectedInstance && selectedInstance.category === currentCategoryName) {\n      const selectedInstanceItems = this.selectedInstanceItems.filter((i) => i.instance === selectedInstance);\n      const selectedInstanceItem = selectedInstanceItems.find((i) => i.name === currentCategoryItemName) || selectedInstanceItems[0];\n      if (selectedInstanceItem && selectedInstanceItem.name === currentCategoryItemName) {\n        // has selected instance item\n        const { currentCamera, currentFrame } = this.rootStore.frame;\n        const { frames } = selectedInstanceItem.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          // not exist in current frame\n          return selectedInstanceItem;\n        }\n      }\n\n      const category = this.rootStore.ontology.getCategoryItem(currentCategoryName, currentCategoryItemName);\n      if (category) {\n        const { currentCamera } = this.rootStore.frame;\n        const { name, count } = category;\n        // find items exist in current camera\n        const items = selectedInstance.getItemsByName(name).filter((i) => {\n          const cameraData = i.cameras[currentCamera];\n          return cameraData && !cameraData.isEmpty;\n        });\n        if (count !== undefined && items.length < count) {\n          return this.createInstanceItem(selectedInstance, currentCategoryItemName);\n        }\n      }\n    }\n\n    // return a new instance\n    const instance = this.createInstance(currentCategoryName);\n    return this.createInstanceItem(instance!, currentCategoryItemName);\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  createInstance(categoryName = this.rootStore.ontology.selectedCategory.className) {\n    const category = this.rootStore.ontology.getCategory(categoryName);\n    if (category) {\n      const instance = new Instance({\n        categoryRef: category,\n        number: this.getNextInstanceNumber(categoryName),\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder,\n      });\n      this.instances[instance.id] = instance;\n      return instance;\n    }\n    return undefined;\n  }\n\n  /**\n   * create instance item\n   * @param instance\n   * @param categoryItem\n   */\n  createInstanceItem(instance: Instance, categoryItem = this.rootStore.ontology.selectedCategoryItem.name) {\n    const number = this.getNextInstanceItemNumber(instance.id, categoryItem);\n    const existItem = instance.getItem(categoryItem, number);\n    if (existItem) {\n      return existItem;\n    }\n    // create\n    const { children = [] } = instance.categoryRef;\n    const item = children.find((c) => c.name === categoryItem);\n    const instanceItem = new InstanceItem({\n      instance,\n      categoryItemRef: item || children[0],\n      number,\n    });\n    instance.items[instanceItem.id] = instanceItem;\n    return instanceItem;\n  }\n\n  /**\n   * delete instance\n   * @param instance\n   */\n  deleteInstance(instance: Instance | Instance[]) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances = this.selectedInstances.filter((i) => instances.indexOf(i) < 0);\n    this.selectedInstanceItems = this.selectedInstanceItems.filter((i) => instances.indexOf(i.instance) < 0);\n    instances.forEach((i) => {\n      i.destroy();\n      delete this.instances[i.id];\n    });\n  }\n\n  /**\n   * delete instance item\n   * @param instanceItem\n   */\n  deleteInstanceItem(instanceItem: InstanceItem | InstanceItem[]) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems = this.selectedInstanceItems.filter((i) => instanceItems.indexOf(i) < 0);\n    instanceItems.forEach(({ id, instance }) => {\n      instance.removeItem(id);\n    });\n  }\n\n  /**\n   * delete frames from instance item\n   * @param instanceItem\n   * @param frames\n   * @param camera\n   */\n  deleteFramesFromInstanceItem = (\n    instanceItem: InstanceItem,\n    frames: number[],\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    if (camera === currentCamera && frames.includes(currentFrame)) {\n      // remove shape\n      this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n    }\n\n    const { prevState, currState } = instanceItem.remove(camera, frames);\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    this.rootStore.undo.push({\n      instances: prevState ? [{ ...prevBasicInfo, children: [prevState] }] : [],\n    }, {\n      instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n    });\n\n    if (instanceItem.isEmpty) {\n      this.deleteInstanceItem(instanceItem);\n    }\n    if (instanceItem.instance.isEmpty) {\n      this.deleteInstance(instanceItem.instance);\n    }\n  };\n\n  /**\n   * delete frames from instance items\n   * @param instanceItems\n   */\n  deleteFramesFromInstanceItems = (instanceItems: { instanceItem: InstanceItem, frames: number[], camera?: string }[]) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const { instanceItem, frames, camera = currentCamera } = instanceItems[i];\n      const { instance } = instanceItem;\n      const { id: instanceId } = instance;\n\n      if (camera === currentCamera && frames.includes(currentFrame)) {\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      }\n      const prevInstanceBasicInfo = instance.getBasicInfo();\n      const { prevState, currState } = instanceItem.remove(camera, frames);\n      if (prevState) {\n        if (!prevInstanceMap[instanceId]) {\n          prevInstanceMap[instanceId] = {\n            ...prevInstanceBasicInfo,\n            children: [],\n          };\n        }\n        prevInstanceMap[instanceId].children.push(prevState);\n      }\n      if (currState) {\n        if (!currInstanceMap[instanceId]) {\n          currInstanceMap[instanceId] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        currInstanceMap[instanceId].children.push(currState);\n      }\n\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instance.isEmpty) {\n        this.deleteInstance(instance);\n      }\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n    });\n  };\n\n  deleteInstanceItemByFrame = (\n    instanceItem: InstanceItem,\n    frame: number,\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const prevInstanceBasicInfo = instanceItem.instance.getBasicInfo();\n    if (camera === currentCamera && frame === currentFrame) {\n      // remove shape\n      this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n    }\n\n    const { prevState, currState } = instanceItem.remove(camera, [frame]);\n\n    if (instanceItem.isEmpty) {\n      this.deleteInstanceItem(instanceItem);\n    }\n    if (instanceItem.instance.isEmpty) {\n      this.deleteInstance(instanceItem.instance);\n    }\n\n    return {\n      prevState: {\n        instances: prevState ? [{ ...prevInstanceBasicInfo, children: [prevState] }] : [],\n      },\n      currState: {\n        instances: currState ? [{ ...instanceItem.instance.getBasicInfo(), children: [currState] }] : [],\n      },\n    };\n  };\n\n  /**\n   * delete frames from instance item by type\n   * @param instanceItem\n   * @param type\n   * @param camera\n   */\n  deleteFramesFromInstanceItemByType = (\n    instanceItem: InstanceItem,\n    type: 'current' | 'key' | 'following' | 'all' = 'current',\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentFrame } = this.rootStore.frame;\n    switch (type) {\n      case 'current':\n        this.deleteFramesFromInstanceItem(instanceItem, [currentFrame]);\n        break;\n      case 'key': {\n        const nextKeyFrames = getNextKeyFrames(1, currentFrame, instanceItem.cameras[camera].frames);\n        const nextKeyFrame = nextKeyFrames[0];\n        if (nextKeyFrame) {\n          this.deleteFramesFromInstanceItem(\n            instanceItem,\n            Array.from({ length: nextKeyFrame - currentFrame }).map((_, index) => currentFrame + index),\n          );\n        }\n        break;\n      }\n      case 'following': {\n        const allFrames = Object.keys(instanceItem.cameras[camera].frames).map((f) => parseInt(f, 10));\n        const index = allFrames.indexOf(currentFrame);\n        this.deleteFramesFromInstanceItem(\n          instanceItem,\n          allFrames.slice(index, allFrames.length),\n        );\n        break;\n      }\n      case 'all': {\n        const allFrames = Object.keys(instanceItem.cameras[camera].frames).map((f) => parseInt(f, 10));\n        this.deleteFramesFromInstanceItem(\n          instanceItem,\n          allFrames,\n        );\n        break;\n      }\n      default:\n    }\n  };\n\n  /**\n   * update frame shape info for instance item\n   * @param instanceItem\n   * @param frameIndex\n   * @param shapeType\n   * @param shape\n   * @param order\n   * @param camera\n   */\n  updateFrameShapeForInstanceItem(instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData, order?: number, camera = this.rootStore.frame.currentCamera) {\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    const { prevState, currState } = instanceItem.updateShape(\n      camera,\n      frameIndex,\n      true,\n      shapeType,\n      shape,\n      order,\n    );\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [basicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevState ? [prevState] : [] },\n        curr: { ...basicInfo, children: currState ? [currState] : [] },\n      }\n    };\n\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev),\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr),\n    });\n  }\n\n  /**\n   * update frame shape info for instance items list\n   * @param instanceItems\n   */\n  updateFrameShapeForInstanceItems(instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape?: ShapeData, order?: number, camera?: string }[]) {\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n    // const { currentCamera, currentFrame } = this.rootStore.frame;\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const { instanceItem, frameIndex, shapeType, shape, order, camera = this.rootStore.frame.currentCamera } = instanceItems[i];\n      let state;\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      if (shape) {\n        // update\n        state = instanceItem.updateShape(\n          camera,\n          frameIndex,\n          true,\n          shapeType,\n          shape,\n          order,\n        );\n      } else {\n        // delete\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n\n        state = instanceItem.remove(camera, [frameIndex]);\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instanceItem.instance.isEmpty) {\n          this.deleteInstance(instanceItem.instance);\n        }\n      }\n\n      if (state) {\n        const { prevState, currState } = state;\n        const { instance } = instanceItem;\n        const { id: instanceId } = instance;\n        if (prevState) {\n          if (!prevInstanceMap[instanceId]) {\n            prevInstanceMap[instanceId] = {\n              ...prevBasicInfo,\n              children: [],\n            };\n          }\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: [],\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n    });\n  }\n\n  /**\n   * open attributes modal automatically for selected instance\n   */\n  autoOpenAttributesModal() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return;\n    }\n\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const shouldOpen = (instanceItem: InstanceItem) => {\n      const frameData = instanceItem.cameras[currentCamera]?.frames[currentFrame];\n\n      if (\n        instanceItem.categoryItemRef.labelConfig &&\n        !frameData?.attributes\n      ) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n\n      return false;\n    };\n\n    if (this.selectedInstanceItems.length === 1) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const open = shouldOpen(selectedInstanceItem);\n      if (open) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return;\n      }\n    }\n\n    const selectedInstance = this.selectedInstances[0];\n    const { labelConfigDynamic } = selectedInstance.categoryRef;\n    if (labelConfigDynamic && (!selectedInstance.dynamicAttributes || !selectedInstance.dynamicAttributes[currentCamera]?.[currentFrame]?.attributes)) {\n      this.rootStore.config.setAttributesModalVisible(true);\n      return true;\n    }\n\n    if (this.selectedInstanceItems.length <= 0 && Object.values(selectedInstance.items).some((i) => shouldOpen(i))) {\n      // no instance item selected\n      this.rootStore.config.setAttributesModalVisible(true);\n    }\n  }\n\n  /**\n   * get instances json data (for save)\n   */\n  instancesJSON(): IInstance[] {\n    return Object.values(this.instances).map((instance) => instance.toJSON());\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  getCurrentDynamicAttributesByInstance(instance: Instance) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const { attributes = {} } = instance.dynamicAttributes?.[currentCamera]?.[currentFrame] || {};\n    return attributes;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}