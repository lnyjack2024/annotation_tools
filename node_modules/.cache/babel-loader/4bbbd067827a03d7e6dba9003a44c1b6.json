{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport Observer from '../../../utils/observer';\nimport { setStyle, fittingString, drawRoundedRect } from '../../../utils';\nimport Cursor from '../../../../common/Cursor';\nimport { colors, SelectBorder, SegmentMode, OverlapMode } from '../types';\nlet fillOpacity = 0.2;\nconst fontSize = 12;\nconst missingColor = '#ffffff';\nconst separationColor = '#ADAFB5';\nexport default class RegionPlugin extends Observer {\n  constructor({\n    container,\n    deviation,\n    disabled: _disabled,\n    segmentMode,\n    segmentOverlap\n  }) {\n    super();\n    this.name = 'region';\n    /**\n     * wave instance\n     */\n    this.wave = void 0;\n    /**\n    * timeline container\n    */\n    this.container = void 0;\n    /**\n     * drawer\n     */\n    this.drawer = void 0;\n    /**\n    * window pixel ratio\n    */\n    this.pixelRatio = 1;\n    this.deviation = 0;\n    this.canvas = null;\n    this.ctx = null;\n    this.resizeAbled = false;\n    this.selectedId = void 0;\n    this.currentRegionBoundary = [0, 0];\n    this.selectedChannelIndex = -1;\n    this.dragRegion = void 0;\n    this.auditionId = void 0;\n    this.dragTime = void 0;\n    this.regions = {};\n    this.renderRegions = {};\n    this.hoverRegion = void 0;\n    this.resizeBorder = void 0;\n    this.disabled = false;\n    this.unit = 0;\n    this.isClickRegion = false;\n    this.mouse = {\n      x: 0,\n      y: 0\n    };\n    this.warnings = {};\n    this.missRegions = {};\n    this.segmentMode = SegmentMode.INDIVIDUAL;\n    this.segmentOverlap = OverlapMode.OVERLAP;\n    this.adjoinRegion = void 0;\n    this.isOverlap = false;\n    this.setDisabled = disabled => {\n      this.disabled = disabled;\n      if (this.auditionId) {\n        this.setAuditionId();\n      } else {\n        this.setRenderRegions();\n      }\n    };\n    this._onReady = () => {\n      this.addCanvas();\n      this.initRegion();\n    };\n    /**\n     * @returns {void}\n     */\n    this._onRedraw = () => {\n      this.render();\n    };\n    this.initRegion = () => {\n      if (this.wave) {\n        this.wave.on('mousedown', this.onMousedown);\n        this.wave.on('mousemove', this.onMousemove);\n        this.wave.on('mouseup', this.onMouseUp);\n        this.wave.on('mouseleave', this.onMouseLeave);\n        this.wave.on('split', this.splitSegment);\n        if (Object.keys(this.renderRegions).length > 0) {\n          this.render();\n        }\n      }\n    };\n    this.onMousedown = (channelIndex, mouse) => {\n      var _this$wave;\n      this.selectedChannelIndex = channelIndex;\n      this.mouse = mouse;\n      if ((_this$wave = this.wave) === null || _this$wave === void 0 ? void 0 : _this$wave.drawer) {\n        this.setCurrentBoundary(channelIndex);\n        this.createRegion(channelIndex);\n      }\n    };\n    this.setCurrentBoundary = channelIndex => {\n      var _this$wave2;\n      if ((_this$wave2 = this.wave) === null || _this$wave2 === void 0 ? void 0 : _this$wave2.drawer) {\n        const {\n          cursorTime\n        } = this.wave.drawer;\n        let sizeRange = [0, this.wave.getDuration()];\n        const regions = this.disabled ? this.renderRegions : this.regions;\n        if (this.segmentMode === SegmentMode.INDIVIDUAL) {\n          let channelRegions = [];\n          if (this.segmentOverlap === OverlapMode.DISABLED_CHANNEL_OVERLAP) {\n            channelRegions = Object.values(regions).filter(region => {\n              var _this$hoverRegion;\n              return region.channelIndex === channelIndex && region.id !== ((_this$hoverRegion = this.hoverRegion) === null || _this$hoverRegion === void 0 ? void 0 : _this$hoverRegion.id);\n            });\n          } else if (this.segmentOverlap === OverlapMode.DISABLED_OVERALL_OVERLAP) {\n            channelRegions = Object.values(regions).filter(region => {\n              var _this$hoverRegion2;\n              return region.id !== ((_this$hoverRegion2 = this.hoverRegion) === null || _this$hoverRegion2 === void 0 ? void 0 : _this$hoverRegion2.id);\n            });\n          }\n          channelRegions.forEach(region => {\n            const left = region.end;\n            const right = region.start;\n            if (left < cursorTime && left > sizeRange[0]) {\n              sizeRange[0] = left;\n            }\n            if (right > cursorTime && right < sizeRange[1]) {\n              sizeRange[1] = right;\n            }\n          });\n        }\n        if (this.segmentMode === SegmentMode.CONTINUOUS && this.hoverRegion && this.resizeBorder) {\n          this.adjoinRegion = this.getAdjoinRegion(this.hoverRegion.id, this.resizeBorder === SelectBorder.LEFT ? 'prev' : 'next');\n          if (this.adjoinRegion) {\n            sizeRange = [Math.min(this.hoverRegion.start, this.adjoinRegion.start), Math.max(this.hoverRegion.end, this.adjoinRegion.end)];\n          }\n        }\n        this.currentRegionBoundary = sizeRange;\n      }\n    };\n    this.getAdjoinRegion = (id, type) => {\n      const currentRegion = this.regions[id];\n      return Object.values(this.regions).find(r => r.channelIndex === (currentRegion === null || currentRegion === void 0 ? void 0 : currentRegion.channelIndex) && (type === 'prev' ? r.end === currentRegion.start : r.start === currentRegion.end));\n    };\n    this.createRegion = _channelIndex => {\n      var _this$wave3;\n      if ((_this$wave3 = this.wave) === null || _this$wave3 === void 0 ? void 0 : _this$wave3.drawer) {\n        const {\n          cursorTime,\n          channels\n        } = this.wave.drawer;\n        if (this.hoverRegion) {\n          const {\n            id,\n            channelIndex,\n            audition\n          } = this.hoverRegion;\n          const warning = this.warnings[id];\n          if (!this.disabled && !(warning === null || warning === void 0 ? void 0 : warning.isMissing) || this.disabled && audition) {\n            this.dragRegion = cloneDeep(this.hoverRegion);\n            this.selectedChannelIndex = channelIndex;\n            if (this.resizeBorder) {\n              this.resizeAbled = true;\n            } else if (this.segmentMode === SegmentMode.INDIVIDUAL) {\n              this.dragTime = cursorTime;\n            }\n          }\n        } else {\n          var _channels$_channelInd;\n          if (this.segmentOverlap === OverlapMode.DISABLED_OVERALL_OVERLAP) {\n            const region = Object.values(this.disabled ? this.renderRegions : this.regions).find(r => r.start < cursorTime && r.end > cursorTime);\n            if (region) {\n              this.isOverlap = true;\n              return;\n            }\n          }\n          this.resizeAbled = true;\n          this.resizeBorder = SelectBorder.RIGHT;\n          this.dragRegion = {\n            id: uuidv4(),\n            channelIndex: _channelIndex,\n            start: cursorTime,\n            end: cursorTime,\n            color: ((_channels$_channelInd = channels[_channelIndex]) === null || _channels$_channelInd === void 0 ? void 0 : _channels$_channelInd.color) || colors[_channelIndex] || '#A1A1A1'\n          };\n          this.setHoverRegion(this.dragRegion);\n          // create audition when disabled\n          if (this.disabled) {\n            this.dragRegion.audition = true;\n            this.setAuditionId(this.dragRegion.id);\n          }\n        }\n      }\n    };\n    this.splitSegment = cursorTime => {\n      var _this$wave4;\n      if (((_this$wave4 = this.wave) === null || _this$wave4 === void 0 ? void 0 : _this$wave4.drawer) && this.segmentMode === SegmentMode.CONTINUOUS && !this.disabled && this.hoverRegion && !this.hoverRegion.audition) {\n        const {\n          id,\n          start,\n          end,\n          channelIndex,\n          color\n        } = this.hoverRegion;\n        if (start < cursorTime && end > cursorTime) {\n          const newRegionId = uuidv4();\n          const regions = {\n            [id]: {\n              ...this.hoverRegion,\n              end: cursorTime\n            },\n            [newRegionId]: {\n              id: newRegionId,\n              channelIndex,\n              start: cursorTime,\n              end,\n              color\n            }\n          };\n          this.wave.fireEvent('update_regions', regions);\n          this.updateRegions(regions);\n        }\n      }\n    };\n    this.setHoverRegion = region => {\n      this.hoverRegion = region;\n      this.render();\n    };\n    this.onMousemove = ({\n      cursorTime,\n      channelIndex: _channelIndex\n    }) => {\n      if (this.dragRegion) {\n        if (this.resizeAbled) {\n          this.resizeRegion(cursorTime);\n        }\n        if (this.dragTime !== undefined) {\n          this.moveRegion(cursorTime);\n        }\n      } else {\n        let hoverRegion;\n        let resizeBorder;\n        const regions = this.disabled ? this.renderRegions : this.regions;\n        Object.keys(regions).forEach(id => {\n          const {\n            start,\n            end,\n            channelIndex\n          } = regions[id];\n          if (channelIndex === _channelIndex) {\n            const nearLeft = Math.abs((cursorTime - start) * this.unit) <= 3;\n            const nearRight = Math.abs((cursorTime - end) * this.unit) <= 3;\n            if (cursorTime >= start && cursorTime <= end) {\n              hoverRegion = regions[id];\n              if ((nearLeft || nearRight) && (id === this.selectedId || this.segmentMode === SegmentMode.CONTINUOUS)) {\n                if (!(this.segmentMode === SegmentMode.CONTINUOUS && (start === 0 && nearLeft || end === this.wave.getDuration() && nearRight))) {\n                  resizeBorder = nearLeft ? SelectBorder.LEFT : SelectBorder.RIGHT;\n                }\n              }\n            }\n          }\n        });\n        this.setHoverRegion(hoverRegion);\n        this.resizeBorder = resizeBorder;\n        this.setCursor();\n      }\n    };\n    this.setCursor = () => {\n      let cursor = Cursor.DEFAULT;\n      if (this.hoverRegion) {\n        if (this.hoverRegion.audition && this.disabled || !this.hoverRegion.audition && !this.disabled) {\n          if (this.segmentMode === SegmentMode.INDIVIDUAL) cursor = Cursor.MOVE;\n          if (this.resizeBorder) cursor = Cursor.COL_RESIZE;\n        }\n        if (this.isOverlap) {\n          var _this$wave5;\n          this.isOverlap = false;\n          (_this$wave5 = this.wave) === null || _this$wave5 === void 0 ? void 0 : _this$wave5.fireEvent('overlap_warning');\n        }\n      }\n      setStyle(this.container, {\n        cursor\n      });\n    };\n    this.getSelectedRegion = () => {\n      const {\n        dragRegion\n      } = this;\n      if (dragRegion) {\n        return this.renderRegions[dragRegion.id];\n      }\n      return undefined;\n    };\n    this.resizeRegion = _cursorTime => {\n      if (this.dragRegion && this.resizeAbled) {\n        let cursorTime = _cursorTime;\n        const {\n          id,\n          start,\n          end\n        } = this.dragRegion;\n        const regions = {};\n        const selectedRegion = cloneDeep(this.renderRegions[id] || this.dragRegion);\n        regions[id] = selectedRegion;\n        const [boundaryStart, boundaryEnd] = this.currentRegionBoundary;\n        if (this.segmentOverlap === OverlapMode.DISABLED_CHANNEL_OVERLAP || this.segmentOverlap === OverlapMode.DISABLED_OVERALL_OVERLAP) {\n          if (cursorTime < boundaryStart) {\n            cursorTime = boundaryStart;\n          } else if (cursorTime > boundaryEnd) {\n            cursorTime = boundaryEnd;\n          }\n        }\n        let newStart;\n        let newEnd;\n        if (this.resizeBorder === SelectBorder.LEFT) {\n          if (cursorTime < end) {\n            newStart = cursorTime;\n          } else {\n            newStart = end;\n            newEnd = cursorTime;\n          }\n        } else if (this.resizeBorder === SelectBorder.RIGHT) {\n          if (cursorTime >= start) {\n            newEnd = cursorTime;\n          } else {\n            newStart = cursorTime;\n            newEnd = start;\n          }\n        }\n        // fit\n        if (newStart !== undefined) {\n          if (newStart - boundaryStart <= 2 / this.unit) {\n            newStart = boundaryStart;\n          }\n          selectedRegion.start = newStart;\n        }\n        if (newEnd !== undefined) {\n          if (boundaryEnd - newEnd <= 2 / this.unit) {\n            newEnd = boundaryEnd;\n          }\n          selectedRegion.end = newEnd;\n        }\n        if (this.adjoinRegion && this.segmentMode === SegmentMode.CONTINUOUS) {\n          const adjoinRegion = cloneDeep(this.renderRegions[this.adjoinRegion.id]);\n          regions[adjoinRegion.id] = adjoinRegion;\n          if (this.resizeBorder === SelectBorder.LEFT && newStart !== undefined) {\n            adjoinRegion.end = newStart;\n          } else if (this.resizeBorder === SelectBorder.RIGHT && newEnd !== undefined) {\n            adjoinRegion.start = newEnd;\n          }\n          this.adjoinRegion = {\n            ...adjoinRegion\n          };\n        }\n        this.updateRegions(regions);\n      }\n    };\n    this.moveRegion = cursorTime => {\n      if (this.dragRegion && this.dragTime !== undefined) {\n        const {\n          id,\n          start,\n          end\n        } = this.dragRegion;\n        const duration = end - start;\n        const selectedRegion = cloneDeep(this.dragRegion);\n        const moveDuration = cursorTime - this.dragTime;\n        let newStart = start + moveDuration;\n        let newEnd = end + moveDuration;\n        // fit\n        if (newStart - this.currentRegionBoundary[0] <= 2 / this.unit) {\n          newStart = this.currentRegionBoundary[0];\n          newEnd = newStart + duration;\n        }\n        if (this.currentRegionBoundary[1] - newEnd <= 2 / this.unit) {\n          newEnd = this.currentRegionBoundary[1];\n          newStart = newEnd - duration;\n        }\n        if (newStart >= this.currentRegionBoundary[0] && newStart <= this.currentRegionBoundary[1] && newEnd >= this.currentRegionBoundary[0] && newEnd <= this.currentRegionBoundary[1]) {\n          selectedRegion.start = newStart;\n          selectedRegion.end = newEnd;\n          this.updateRegions({\n            [id]: selectedRegion\n          });\n        }\n      }\n    };\n    this.onMouseUp = (e, cursorTime, channelIndex) => {\n      const currentRegion = this.hoverRegion || this.renderRegions[this.selectedId || ''];\n      this.isClickRegion = false;\n      if (currentRegion) {\n        var _this$wave6;\n        this.isClickRegion = true;\n        const regions = {};\n        const update = r => {\n          let region;\n          const duration = r.end - r.start;\n          if (duration < Math.max(2 * this.deviation, 0.1)) {\n            region = undefined;\n          } else {\n            region = cloneDeep(r);\n          }\n          if (r.audition) this.setAuditionId(r.id);\n          return region;\n        };\n        const updateRegion = update(currentRegion);\n        if (this.segmentMode === SegmentMode.CONTINUOUS && this.adjoinRegion) {\n          const adjoinRegion = update(this.adjoinRegion);\n          if (!updateRegion && adjoinRegion) {\n            adjoinRegion.start = Math.min(currentRegion.start, this.adjoinRegion.start);\n            adjoinRegion.end = Math.max(currentRegion.end, this.adjoinRegion.end);\n          } else if (updateRegion && !adjoinRegion) {\n            updateRegion.start = Math.min(currentRegion.start, this.adjoinRegion.start);\n            updateRegion.end = Math.max(currentRegion.end, this.adjoinRegion.end);\n          }\n          regions[this.adjoinRegion.id] = adjoinRegion;\n        }\n        regions[currentRegion.id] = updateRegion;\n        (_this$wave6 = this.wave) === null || _this$wave6 === void 0 ? void 0 : _this$wave6.fireEvent('update_regions', regions);\n        this.updateRegions(regions);\n      }\n      const clickRegion = (currentRegion === null || currentRegion === void 0 ? void 0 : currentRegion.start) !== (currentRegion === null || currentRegion === void 0 ? void 0 : currentRegion.end) ? currentRegion : undefined;\n      if (this.dragTime || this.resizeAbled || !this.dragTime && !this.resizeAbled) {\n        var _this$wave7;\n        (_this$wave7 = this.wave) === null || _this$wave7 === void 0 ? void 0 : _this$wave7.fireEvent('click_region', e, clickRegion ? cloneDeep(clickRegion) : undefined, channelIndex);\n      }\n      this.onMouseLeave('up');\n    };\n    this.onMouseLeave = type => {\n      if (type !== 'up') {\n        this.setHoverRegion();\n      }\n      this.dragRegion = undefined;\n      this.resizeAbled = false;\n      this.resizeBorder = undefined;\n      this.dragTime = undefined;\n      this.isOverlap = false;\n      this.adjoinRegion = undefined;\n    };\n    this.setSelected = id => {\n      this.selectedId = id;\n      if (this.auditionId && this.auditionId !== id) {\n        this.setAuditionId();\n      } else {\n        this.setRenderRegions();\n      }\n    };\n    this.setAuditionId = id => {\n      if (id === this.auditionId) return;\n      const region = this.regions[this.auditionId || ''];\n      if (this.auditionId && region) {\n        var _this$wave8;\n        this.updateRegions({\n          [this.auditionId]: undefined\n        });\n        (_this$wave8 = this.wave) === null || _this$wave8 === void 0 ? void 0 : _this$wave8.fireEvent('remove_audition');\n      }\n      this.auditionId = id;\n    };\n    this.updateRegions = regions => {\n      Object.keys(regions).forEach(id => {\n        const region = regions[id];\n        if (region) {\n          var _this$hoverRegion3;\n          if (this.missRegions[region.id]) {\n            this.missRegions[region.id] = {\n              ...region\n            };\n          } else {\n            this.regions[id] = region;\n          }\n          if (((_this$hoverRegion3 = this.hoverRegion) === null || _this$hoverRegion3 === void 0 ? void 0 : _this$hoverRegion3.id) === id) {\n            this.setHoverRegion({\n              ...region\n            });\n          }\n        } else {\n          delete this.regions[id];\n        }\n      });\n      this.setRenderRegions();\n    };\n    this.setRegions = regions => {\n      const newRegions = cloneDeep(this.regions);\n      Object.keys(regions).forEach(id => {\n        const region = regions[id];\n        if (region) {\n          newRegions[id] = {\n            ...region,\n            color: region.color || colors[region.channelIndex] || '#A1A1A1'\n          };\n        } else {\n          delete newRegions[id];\n        }\n      });\n      this.regions = newRegions;\n      this.setRenderRegions();\n    };\n    this.setWarnings = list => {\n      const warnings = {};\n      list.forEach(warning => {\n        warnings[warning.id] = warning;\n      });\n      this.warnings = warnings;\n      this.setMissRegions();\n    };\n    this.setMissRegions = () => {\n      const missRegions = {};\n      Object.values(this.warnings).forEach(({\n        isMissing,\n        id,\n        channelIndex,\n        start,\n        end\n      }) => {\n        if (isMissing) {\n          var _channels;\n          missRegions[id] = {\n            id,\n            channelIndex: channelIndex,\n            start: start,\n            end: end,\n            color: ((_channels = this.wave.drawer.channels[channelIndex]) === null || _channels === void 0 ? void 0 : _channels.color) || colors[channelIndex] || '#A1A1A1',\n            audition: true\n          };\n        }\n      });\n      this.missRegions = missRegions;\n      if (this.auditionId) {\n        this.setAuditionId();\n      }\n      this.setRenderRegions();\n    };\n    this.setRenderRegions = () => {\n      // audition\n      const renderRegions = cloneDeep(this.regions);\n      this.renderRegions = {\n        ...renderRegions,\n        ...this.missRegions\n      };\n      this.render();\n    };\n    this.render = () => {\n      var _this$wave9;\n      if (!((_this$wave9 = this.wave) === null || _this$wave9 === void 0 ? void 0 : _this$wave9.isPlaying())) {\n        this.renderCanvas();\n      }\n    };\n    this.renderCanvas = () => {\n      var _this$wave0;\n      this.resizeCanvas();\n      if (this.ctx && ((_this$wave0 = this.wave) === null || _this$wave0 === void 0 ? void 0 : _this$wave0.drawer)) {\n        const {\n          displayRange,\n          drawer: {\n            waveHeight,\n            height\n          }\n        } = this.wave;\n        const duration = this.wave.getDuration();\n        const startTime = duration * displayRange.start;\n        const endTime = duration * displayRange.end;\n        const canvasWidth = this.wave.width;\n        this.unit = canvasWidth / (endTime - startTime);\n        // selected region or channel\n        if (this.selectedId) {\n          const region = this.renderRegions[this.selectedId];\n          const drawIndex = this.wave.drawer.drawIndex[region === null || region === void 0 ? void 0 : region.channelIndex];\n          if (drawIndex !== undefined) {\n            this.ctx.lineWidth = 2 * this.pixelRatio;\n            const x = (region.start - startTime) * this.unit;\n            const y = drawIndex * waveHeight;\n            const width = (region.end - region.start) * this.unit;\n            this.ctx.strokeStyle = region.audition ? missingColor : region.color;\n            this.ctx.strokeRect((x + 1) * this.pixelRatio, (y + 1) * this.pixelRatio, (width - 2) * this.pixelRatio, (waveHeight - 2) * this.pixelRatio);\n            this.ctx.fillStyle = 'rgba(0,0,0,0.1)';\n            this.ctx.fillRect(x * this.pixelRatio, 0, width * this.pixelRatio, height * this.pixelRatio);\n            this.ctx.fillRect(0, y * this.pixelRatio, canvasWidth * this.pixelRatio, waveHeight * this.pixelRatio);\n          }\n        } else if (this.selectedChannelIndex !== undefined) {\n          var _this$wave1, _this$wave1$drawer;\n          const drawIndex = (_this$wave1 = this.wave) === null || _this$wave1 === void 0 ? void 0 : (_this$wave1$drawer = _this$wave1.drawer) === null || _this$wave1$drawer === void 0 ? void 0 : _this$wave1$drawer.drawIndex[this.selectedChannelIndex];\n          if (drawIndex !== undefined && drawIndex >= 0) {\n            this.ctx.beginPath();\n            this.ctx.fillStyle = 'rgba(0,0,0,0.1)';\n            this.ctx.fillRect(0, drawIndex * waveHeight * this.pixelRatio, canvasWidth * this.pixelRatio, waveHeight * this.pixelRatio);\n            this.ctx.closePath();\n          }\n        }\n        this.ctx.lineWidth = 1 * this.pixelRatio;\n        Object.keys(this.renderRegions).forEach(id => {\n          var _this$wave10, _this$wave10$drawer;\n          const {\n            start,\n            end,\n            channelIndex,\n            text,\n            color,\n            audition\n          } = this.renderRegions[id];\n          const drawIndex = (_this$wave10 = this.wave) === null || _this$wave10 === void 0 ? void 0 : (_this$wave10$drawer = _this$wave10.drawer) === null || _this$wave10$drawer === void 0 ? void 0 : _this$wave10$drawer.drawIndex[channelIndex];\n          if (drawIndex !== undefined && drawIndex >= 0) {\n            const x = (start - startTime) * this.unit;\n            const y = drawIndex * waveHeight;\n            const width = (end - start) * this.unit;\n            const line1 = (start + this.deviation - startTime) * this.unit;\n            const line2 = (end - this.deviation - startTime) * this.unit;\n            this.ctx.beginPath();\n            this.ctx.strokeStyle = color;\n            // is missing region\n            this.ctx.fillStyle = audition ? hexToRgba(missingColor, fillOpacity) : hexToRgba(color, fillOpacity);\n            this.ctx.fillRect(x * this.pixelRatio, y * this.pixelRatio, width * this.pixelRatio, waveHeight * this.pixelRatio);\n            if (this.deviation > 0) {\n              this.ctx.beginPath();\n              this.ctx.moveTo(line1 * this.pixelRatio, (y + waveHeight * 0.25) * this.pixelRatio);\n              this.ctx.lineTo(line1 * this.pixelRatio, (y + waveHeight * 0.75) * this.pixelRatio);\n              this.ctx.moveTo(line2 * this.pixelRatio, (y + waveHeight * 0.25) * this.pixelRatio);\n              this.ctx.lineTo(line2 * this.pixelRatio, (y + waveHeight * 0.75) * this.pixelRatio);\n              this.ctx.closePath();\n              this.ctx.stroke();\n            }\n            if (this.segmentMode === SegmentMode.CONTINUOUS && id !== this.selectedId && end !== duration) {\n              this.ctx.beginPath();\n              this.ctx.strokeStyle = separationColor;\n              this.ctx.moveTo((x + width) * this.pixelRatio, y * this.pixelRatio);\n              this.ctx.lineTo((x + width) * this.pixelRatio, (y + waveHeight) * this.pixelRatio);\n              this.ctx.closePath();\n              this.ctx.stroke();\n            }\n            this.ctx.font = `${fontSize * this.pixelRatio}px sans-serif`;\n            this.ctx.textAlign = 'center';\n            // translation\n            if (text) {\n              var _this$hoverRegion4;\n              const str = fittingString(this.ctx, text, width * this.pixelRatio);\n              this.ctx.beginPath();\n              this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';\n              this.ctx.fillText(str, (x + width / 2) * this.pixelRatio, (y + waveHeight - 12) * this.pixelRatio);\n              if (str !== text && id === ((_this$hoverRegion4 = this.hoverRegion) === null || _this$hoverRegion4 === void 0 ? void 0 : _this$hoverRegion4.id)) {\n                this.showPopLabel(x + width / 2, y, text, waveHeight);\n              }\n              this.ctx.stroke();\n            }\n            // rejected\n            if (this.warnings[id]) {\n              this.ctx.fillStyle = '#DC4624';\n              this.ctx.beginPath();\n              this.ctx.arc((x + width - 14) * this.pixelRatio, (y + 14) * this.pixelRatio, 8 * this.pixelRatio, 0, 2 * Math.PI);\n              this.ctx.closePath();\n              this.ctx.fill();\n              this.ctx.beginPath();\n              this.ctx.fillStyle = '#363B44';\n              this.ctx.fillText('Ã—', (x + width - 14) * this.pixelRatio, (y + 17) * this.pixelRatio);\n              this.ctx.stroke();\n            }\n            this.ctx.closePath();\n          }\n        });\n      }\n    };\n    this.showPopLabel = (centerX, centerY, label, waveHeight) => {\n      if (this.ctx) {\n        let y = centerY - fontSize * 2.5;\n        y = y < 0 ? waveHeight + fontSize / 2 : y;\n        const labelWidth = this.ctx.measureText(label).width + fontSize * this.pixelRatio;\n        this.ctx.fillStyle = 'rgba(0,0,0,0.8)';\n        this.ctx.strokeStyle = 'rgba(0,0,0,0)';\n        drawRoundedRect({\n          x: centerX * this.pixelRatio - labelWidth / 2,\n          y: y * this.pixelRatio,\n          width: labelWidth,\n          height: fontSize * 2 * this.pixelRatio\n        }, fontSize / 2, this.ctx);\n        this.ctx.beginPath();\n        if (y > centerY) {\n          this.ctx.moveTo((centerX - fontSize / 2) * this.pixelRatio, y * this.pixelRatio);\n          this.ctx.lineTo(centerX * this.pixelRatio, (y - fontSize / 2) * this.pixelRatio);\n          this.ctx.lineTo((centerX + fontSize / 2) * this.pixelRatio, y * this.pixelRatio);\n        } else {\n          this.ctx.moveTo((centerX - fontSize / 2) * this.pixelRatio, (centerY - fontSize / 2) * this.pixelRatio);\n          this.ctx.lineTo(centerX * this.pixelRatio, centerY * this.pixelRatio);\n          this.ctx.lineTo((centerX + fontSize / 2) * this.pixelRatio, (centerY - fontSize / 2) * this.pixelRatio);\n        }\n        this.ctx.closePath();\n        this.ctx.fill();\n        this.ctx.fillStyle = 'rgb(255, 255, 255)';\n        this.ctx.fillText(label, centerX * this.pixelRatio, (y + 1.35 * fontSize) * this.pixelRatio);\n      }\n    };\n    this.container = typeof container === 'string' ? document.querySelector(container) : container;\n    if (!this.container) {\n      throw new Error('No container for wave region');\n    }\n    if (deviation) {\n      this.deviation = deviation;\n    }\n    this.segmentMode = Object.values(SegmentMode).includes(segmentMode) ? segmentMode : SegmentMode.INDIVIDUAL;\n    this.segmentOverlap = Object.values(OverlapMode).includes(segmentOverlap) ? segmentOverlap : OverlapMode.OVERLAP;\n    if (this.segmentMode === SegmentMode.CONTINUOUS) {\n      fillOpacity = 0.1;\n    }\n    this.setDisabled(_disabled);\n  }\n  init(wave) {\n    const ws = wave;\n    this.wave = ws;\n    this.drawer = ws.drawer;\n    this.pixelRatio = ws.params.pixelRatio;\n    ws.on('draw', this._onRedraw);\n    // Check if ws is ready\n    if (this.wave.isReady) {\n      this._onReady();\n    } else {\n      this.wave.once('ready', this._onReady);\n    }\n  }\n  /**\n   * Add new region canvas\n   *\n   */\n  addCanvas() {\n    var _this$wave11;\n    const canvas = this.container.appendChild(document.createElement('canvas'));\n    canvas.style.display = 'block';\n    canvas.className = 'wave-region';\n    let tiedupHeight = 0;\n    if (((_this$wave11 = this.wave) === null || _this$wave11 === void 0 ? void 0 : _this$wave11.initialisedPluginList.timeline) === true) {\n      tiedupHeight += this.wave.plugins.timeline.height;\n    }\n    setStyle(canvas, {\n      display: 'block',\n      position: 'absolute',\n      top: `${tiedupHeight}px`,\n      left: 0,\n      height: `calc(100% - ${tiedupHeight}px)`,\n      width: '100%',\n      pointerEvents: 'none'\n    });\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n  }\n  resizeCanvas() {\n    if (this.canvas && this.wave) {\n      var _this$wave$drawer;\n      const canvasWidth = this.wave.width;\n      const canvasHeight = ((_this$wave$drawer = this.wave.drawer) === null || _this$wave$drawer === void 0 ? void 0 : _this$wave$drawer.height) || this.wave.height;\n      // set dimensions and style\n      this.canvas.width = canvasWidth * this.pixelRatio;\n      // on certain pixel ratios the canvas appears cut off at the bottom,\n      // therefore leave 1px extra\n      this.canvas.height = canvasHeight * this.pixelRatio;\n    }\n  }\n  destroy() {\n    if (this.wave) {\n      this.wave.un('draw', this._onRedraw);\n      this.wave.un('ready', this._onReady);\n      this.wave.un('mousedown', this.onMousedown);\n      this.wave.un('mousemove', this.onMousemove);\n      this.wave.un('mouseup', this.onMouseUp);\n      this.wave.un('mouseleave', this.onMouseLeave);\n    }\n    if (this.container && this.canvas) {\n      this.container.removeChild(this.canvas);\n    }\n  }\n}\n;","map":{"version":3,"names":["v4","uuidv4","cloneDeep","hexToRgba","Observer","setStyle","fittingString","drawRoundedRect","Cursor","colors","SelectBorder","SegmentMode","OverlapMode","fillOpacity","fontSize","missingColor","separationColor","RegionPlugin","constructor","container","deviation","disabled","segmentMode","segmentOverlap","name","wave","drawer","pixelRatio","canvas","ctx","resizeAbled","selectedId","currentRegionBoundary","selectedChannelIndex","dragRegion","auditionId","dragTime","regions","renderRegions","hoverRegion","resizeBorder","unit","isClickRegion","mouse","x","y","warnings","missRegions","INDIVIDUAL","OVERLAP","adjoinRegion","isOverlap","setDisabled","setAuditionId","setRenderRegions","_onReady","addCanvas","initRegion","_onRedraw","render","on","onMousedown","onMousemove","onMouseUp","onMouseLeave","splitSegment","Object","keys","length","channelIndex","_this$wave","setCurrentBoundary","createRegion","_this$wave2","cursorTime","sizeRange","getDuration","channelRegions","DISABLED_CHANNEL_OVERLAP","values","filter","region","_this$hoverRegion","id","DISABLED_OVERALL_OVERLAP","_this$hoverRegion2","forEach","left","end","right","start","CONTINUOUS","getAdjoinRegion","LEFT","Math","min","max","type","currentRegion","find","r","_channelIndex","_this$wave3","channels","audition","warning","isMissing","_channels$_channelInd","RIGHT","color","setHoverRegion","_this$wave4","newRegionId","fireEvent","updateRegions","resizeRegion","undefined","moveRegion","nearLeft","abs","nearRight","setCursor","cursor","DEFAULT","MOVE","COL_RESIZE","_this$wave5","getSelectedRegion","_cursorTime","selectedRegion","boundaryStart","boundaryEnd","newStart","newEnd","duration","moveDuration","e","_this$wave6","update","updateRegion","clickRegion","_this$wave7","setSelected","_this$wave8","_this$hoverRegion3","setRegions","newRegions","setWarnings","list","setMissRegions","_channels","_this$wave9","isPlaying","renderCanvas","_this$wave0","resizeCanvas","displayRange","waveHeight","height","startTime","endTime","canvasWidth","width","drawIndex","lineWidth","strokeStyle","strokeRect","fillStyle","fillRect","_this$wave1","_this$wave1$drawer","beginPath","closePath","_this$wave10","_this$wave10$drawer","text","line1","line2","moveTo","lineTo","stroke","font","textAlign","_this$hoverRegion4","str","fillText","showPopLabel","arc","PI","fill","centerX","centerY","label","labelWidth","measureText","document","querySelector","Error","includes","init","ws","params","isReady","once","_this$wave11","appendChild","createElement","style","display","className","tiedupHeight","initialisedPluginList","timeline","plugins","position","top","pointerEvents","getContext","_this$wave$drawer","canvasHeight","destroy","un","removeChild"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/components/Wave/Region/index.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport Wave from '../index';\nimport WaveDrawer from '../waveDrawer';\nimport Observer from '../../../utils/observer';\nimport TimelinePlugin from '../Timeline';\nimport { setStyle, fittingString, drawRoundedRect } from '../../../utils';\nimport Cursor from '../../../../common/Cursor';\nimport { colors, Region, SelectBorder, SegmentMode, OverlapMode } from '../types';\n\nlet fillOpacity = 0.2;\nconst fontSize = 12;\nconst missingColor = '#ffffff';\nconst separationColor = '#ADAFB5';\n\nexport interface RegionOptions {\n  container: string | HTMLElement;\n  disabled: boolean;\n  segmentMode: SegmentMode;\n  segmentOverlap: OverlapMode;\n  deviation?: number;\n}\n\nexport interface RegionWarning {\n  id: string;\n  message?: string;\n  comment?: string;\n  channelIndex?: number;\n  isMissing?: boolean;\n  start?: number;\n  end?: number;\n}\n\nexport default class RegionPlugin extends Observer {\n  name = 'region';\n\n  /**\n   * wave instance\n   */\n  wave?: Wave;\n\n  /**\n  * timeline container\n  */\n  container: HTMLElement;\n\n  /**\n   * drawer\n   */\n  drawer?: WaveDrawer;\n\n  /**\n  * window pixel ratio\n  */\n  pixelRatio = 1;\n\n  deviation = 0;\n\n  canvas: HTMLCanvasElement | null = null;\n\n  ctx: CanvasRenderingContext2D | null = null;\n\n  resizeAbled = false;\n\n  selectedId: string | undefined;\n\n  currentRegionBoundary = [0, 0];\n\n  selectedChannelIndex = -1;\n\n  dragRegion: Region | undefined;\n\n  auditionId?: string;\n\n  dragTime: number | undefined;\n\n  regions: {[key: string]: Region} = {};\n\n  renderRegions: {[key: string]: Region} = {};\n\n  hoverRegion: Region | undefined;\n\n  resizeBorder?: SelectBorder;\n\n  disabled = false;\n\n  unit = 0;\n\n  isClickRegion = false;\n\n  mouse = { x: 0, y: 0 };\n\n  warnings: {[id: string]: RegionWarning} = {};\n\n  missRegions: {[id: string]: Region} = {};\n\n  segmentMode = SegmentMode.INDIVIDUAL;\n\n  segmentOverlap = OverlapMode.OVERLAP;\n\n  adjoinRegion?: Region;\n\n  isOverlap = false;\n\n  constructor({ container, deviation, disabled, segmentMode, segmentOverlap }: RegionOptions) {\n    super();\n\n    this.container = typeof container === 'string'\n      ? document.querySelector(container) as HTMLElement\n      : container;\n\n    if (!this.container) {\n      throw new Error('No container for wave region');\n    }\n    if (deviation) {\n      this.deviation = deviation;\n    }\n\n    this.segmentMode = Object.values(SegmentMode).includes(segmentMode) ? segmentMode : SegmentMode.INDIVIDUAL;\n    this.segmentOverlap = Object.values(OverlapMode).includes(segmentOverlap) ? segmentOverlap : OverlapMode.OVERLAP;\n    if (this.segmentMode === SegmentMode.CONTINUOUS) {\n      fillOpacity = 0.1;\n    }\n    this.setDisabled(disabled);\n  }\n\n  setDisabled = (disabled: boolean) => {\n    this.disabled = disabled;\n    if (this.auditionId) {\n      this.setAuditionId();\n    } else {\n      this.setRenderRegions();\n    }\n  };\n\n  init(wave: Wave) {\n    const ws = wave;\n    this.wave = ws;\n    this.drawer = ws.drawer;\n    this.pixelRatio = ws.params.pixelRatio;\n    ws.on('draw', this._onRedraw);\n    // Check if ws is ready\n    if (this.wave.isReady) {\n      this._onReady();\n    } else {\n      this.wave.once('ready', this._onReady);\n    }\n  }\n\n  _onReady = () => {\n    this.addCanvas();\n    this.initRegion();\n  };\n\n  /**\n   * @returns {void}\n   */\n  _onRedraw = () => {\n    this.render();\n  };\n\n  /**\n   * Add new region canvas\n   *\n   */\n  addCanvas() {\n    const canvas = this.container.appendChild(\n      document.createElement('canvas')\n    );\n    canvas.style.display = 'block';\n    canvas.className = 'wave-region';\n    let tiedupHeight = 0;\n    if (this.wave?.initialisedPluginList.timeline === true) {\n      tiedupHeight += (this.wave.plugins.timeline as TimelinePlugin).height;\n    }\n    setStyle(canvas, {\n      display: 'block',\n      position: 'absolute',\n      top: `${tiedupHeight}px`,\n      left: 0,\n      height: `calc(100% - ${tiedupHeight}px)`,\n      width: '100%',\n      pointerEvents: 'none',\n    });\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n  }\n\n  initRegion = () => {\n    if (this.wave) {\n      this.wave.on('mousedown', this.onMousedown);\n      this.wave.on('mousemove', this.onMousemove);\n      this.wave.on('mouseup', this.onMouseUp);\n      this.wave.on('mouseleave', this.onMouseLeave);\n      this.wave.on('split', this.splitSegment);\n      if (Object.keys(this.renderRegions).length > 0) {\n        this.render();\n      }\n    }\n  };\n\n  onMousedown = (channelIndex: number, mouse: { x: number, y: number }) => {\n    this.selectedChannelIndex = channelIndex;\n    this.mouse = mouse;\n    if (this.wave?.drawer) {\n      this.setCurrentBoundary(channelIndex);\n      this.createRegion(channelIndex);\n    }\n  };\n\n  setCurrentBoundary = (channelIndex: number) => {\n    if (this.wave?.drawer) {\n      const { cursorTime } = this.wave.drawer;\n      let sizeRange = [0, this.wave.getDuration()];\n      const regions = this.disabled ? this.renderRegions : this.regions;\n      if (this.segmentMode === SegmentMode.INDIVIDUAL) {\n        let channelRegions: Region[] = [];\n        if (this.segmentOverlap === OverlapMode.DISABLED_CHANNEL_OVERLAP) {\n          channelRegions = Object.values(regions).filter((region) => region.channelIndex === channelIndex && region.id !== this.hoverRegion?.id);\n        } else if (this.segmentOverlap === OverlapMode.DISABLED_OVERALL_OVERLAP) {\n          channelRegions = Object.values(regions).filter((region) => region.id !== this.hoverRegion?.id);\n        }\n        channelRegions.forEach((region) => {\n          const left = region.end;\n          const right = region.start;\n          if (left < cursorTime && left > sizeRange[0]) {\n            sizeRange[0] = left;\n          }\n          if (right > cursorTime && right < sizeRange[1]) {\n            sizeRange[1] = right;\n          }\n        });\n      }\n      if (this.segmentMode === SegmentMode.CONTINUOUS && this.hoverRegion && this.resizeBorder) {\n        this.adjoinRegion = this.getAdjoinRegion(this.hoverRegion.id, this.resizeBorder === SelectBorder.LEFT ? 'prev' : 'next');\n        if (this.adjoinRegion) {\n          sizeRange = [Math.min(this.hoverRegion.start, this.adjoinRegion.start), Math.max(this.hoverRegion.end, this.adjoinRegion.end)];\n        }\n      }\n      this.currentRegionBoundary = sizeRange;\n    }\n  };\n\n  getAdjoinRegion = (id: string, type: 'prev' | 'next') => {\n    const currentRegion = this.regions[id];\n    return Object.values(this.regions).find((r) => r.channelIndex === currentRegion?.channelIndex &&\n            (type === 'prev' ? r.end === currentRegion.start : r.start === currentRegion.end));\n  };\n\n  createRegion = (_channelIndex: number) => {\n    if (this.wave?.drawer) {\n      const { cursorTime, channels } = this.wave.drawer;\n      if (this.hoverRegion) {\n        const { id, channelIndex, audition } = this.hoverRegion;\n        const warning = this.warnings[id];\n        if ((!this.disabled && !warning?.isMissing) || (this.disabled && audition)) {\n          this.dragRegion = cloneDeep(this.hoverRegion);\n          this.selectedChannelIndex = channelIndex;\n          if (this.resizeBorder) {\n            this.resizeAbled = true;\n          } else if (this.segmentMode === SegmentMode.INDIVIDUAL) {\n            this.dragTime = cursorTime;\n          }\n        }\n      } else {\n        if (this.segmentOverlap === OverlapMode.DISABLED_OVERALL_OVERLAP) {\n          const region = Object.values(this.disabled ? this.renderRegions : this.regions).find((r) => r.start < cursorTime && r.end > cursorTime);\n          if (region) {\n            this.isOverlap = true;\n            return;\n          }\n        }\n        this.resizeAbled = true;\n        this.resizeBorder = SelectBorder.RIGHT;\n        this.dragRegion = {\n          id: uuidv4(),\n          channelIndex: _channelIndex,\n          start: cursorTime,\n          end: cursorTime,\n          color: channels[_channelIndex]?.color || colors[_channelIndex] || '#A1A1A1',\n        };\n        this.setHoverRegion(this.dragRegion);\n        // create audition when disabled\n        if (this.disabled) {\n          this.dragRegion.audition = true;\n          this.setAuditionId(this.dragRegion.id);\n        }\n      }\n    }\n  };\n\n  splitSegment = (cursorTime: number) => {\n    if (\n      this.wave?.drawer &&\n      this.segmentMode === SegmentMode.CONTINUOUS &&\n      !this.disabled &&\n      this.hoverRegion &&\n      !this.hoverRegion.audition\n    ) {\n      const { id, start, end, channelIndex, color } = this.hoverRegion;\n      if (start < cursorTime && end > cursorTime) {\n        const newRegionId = uuidv4();\n        const regions: {[id: string] : Region | undefined} = {\n          [id]: {\n            ...this.hoverRegion,\n            end: cursorTime,\n          },\n          [newRegionId]: {\n            id: newRegionId,\n            channelIndex,\n            start: cursorTime,\n            end,\n            color,\n          }\n        };\n        this.wave.fireEvent('update_regions', regions);\n        this.updateRegions(regions);\n      }\n    }\n  };\n\n  setHoverRegion = (region?: Region) => {\n    this.hoverRegion = region;\n    this.render();\n  };\n\n  onMousemove = ({ cursorTime, channelIndex: _channelIndex }: {\n    cursorTime: number;\n    mouse: {x: number; y: number},\n    channelIndex: number\n  }) => {\n    if (this.dragRegion) {\n      if (this.resizeAbled) {\n        this.resizeRegion(cursorTime);\n      }\n      if (this.dragTime !== undefined) {\n        this.moveRegion(cursorTime);\n      }\n    } else {\n      let hoverRegion: Region | undefined;\n      let resizeBorder: SelectBorder | undefined;\n      const regions = this.disabled ? this.renderRegions : this.regions;\n      Object.keys(regions).forEach((id) => {\n        const { start, end, channelIndex } = regions[id];\n        if (channelIndex === _channelIndex) {\n          const nearLeft = Math.abs((cursorTime - start) * this.unit) <= 3;\n          const nearRight = Math.abs((cursorTime - end) * this.unit) <= 3;\n          if (cursorTime >= start && cursorTime <= end) {\n            hoverRegion = regions[id];\n            if (\n              (nearLeft || nearRight) &&\n              (id === this.selectedId || this.segmentMode === SegmentMode.CONTINUOUS)\n            ) {\n              if (\n                !(\n                  this.segmentMode === SegmentMode.CONTINUOUS &&\n                  (\n                    (start === 0 && nearLeft) ||\n                    (end === this.wave!.getDuration() && nearRight)\n                  )\n                )\n              ) {\n                resizeBorder = nearLeft ? SelectBorder.LEFT : SelectBorder.RIGHT;\n              }\n            }\n          }\n        }\n      });\n      this.setHoverRegion(hoverRegion);\n      this.resizeBorder = resizeBorder;\n      this.setCursor();\n    }\n  };\n\n  setCursor = () => {\n    let cursor = Cursor.DEFAULT;\n    if (this.hoverRegion) {\n      if ((this.hoverRegion.audition && this.disabled) || (!this.hoverRegion.audition && !this.disabled)) {\n        if (this.segmentMode === SegmentMode.INDIVIDUAL) cursor = Cursor.MOVE;\n        if (this.resizeBorder) cursor = Cursor.COL_RESIZE;\n      }\n\n      if (this.isOverlap) {\n        this.isOverlap = false;\n        this.wave?.fireEvent('overlap_warning');\n      }\n    }\n    setStyle(this.container, { cursor });\n  };\n\n  getSelectedRegion = () => {\n    const { dragRegion } = this;\n    if (dragRegion) {\n      return this.renderRegions[dragRegion.id];\n    }\n    return undefined;\n  };\n\n  resizeRegion = (_cursorTime: number) => {\n    if (this.dragRegion && this.resizeAbled) {\n      let cursorTime = _cursorTime;\n      const { id, start, end } = this.dragRegion;\n      const regions: {[id: string]: Region | undefined} = {};\n      const selectedRegion = cloneDeep(this.renderRegions[id] || this.dragRegion);\n      regions[id] = selectedRegion;\n      const [boundaryStart, boundaryEnd] = this.currentRegionBoundary;\n      if (\n        this.segmentOverlap === OverlapMode.DISABLED_CHANNEL_OVERLAP ||\n        this.segmentOverlap === OverlapMode.DISABLED_OVERALL_OVERLAP\n      ) {\n        if (cursorTime < boundaryStart) {\n          cursorTime = boundaryStart;\n        } else if (cursorTime > boundaryEnd) {\n          cursorTime = boundaryEnd;\n        }\n      }\n\n      let newStart: undefined | number;\n      let newEnd: undefined | number;\n      if (this.resizeBorder === SelectBorder.LEFT) {\n        if (cursorTime < end) {\n          newStart = cursorTime;\n        } else {\n          newStart = end;\n          newEnd = cursorTime;\n        }\n      } else if (this.resizeBorder === SelectBorder.RIGHT) {\n        if (cursorTime >= start) {\n          newEnd = cursorTime;\n        } else {\n          newStart = cursorTime;\n          newEnd = start;\n        }\n      }\n      // fit\n      if (newStart !== undefined) {\n        if (newStart - boundaryStart <= 2 / this.unit) {\n          newStart = boundaryStart;\n        }\n        selectedRegion.start = newStart;\n      }\n      if (newEnd !== undefined) {\n        if (boundaryEnd - newEnd <= 2 / this.unit) {\n          newEnd = boundaryEnd;\n        }\n        selectedRegion.end = newEnd;\n      }\n\n      if (this.adjoinRegion && this.segmentMode === SegmentMode.CONTINUOUS) {\n        const adjoinRegion = cloneDeep(this.renderRegions[this.adjoinRegion.id]);\n        regions[adjoinRegion.id] = adjoinRegion;\n        if (this.resizeBorder === SelectBorder.LEFT && newStart !== undefined) {\n          adjoinRegion.end = newStart;\n        } else if (this.resizeBorder === SelectBorder.RIGHT && newEnd !== undefined) {\n          adjoinRegion.start = newEnd;\n        }\n        this.adjoinRegion = { ...adjoinRegion };\n      }\n      this.updateRegions(regions);\n    }\n  };\n\n  moveRegion = (cursorTime: number) => {\n    if (this.dragRegion && this.dragTime !== undefined) {\n      const { id, start, end } = this.dragRegion;\n      const duration = end - start;\n      const selectedRegion = cloneDeep(this.dragRegion);\n      const moveDuration = cursorTime - this.dragTime;\n      let newStart = start + moveDuration;\n      let newEnd = end + moveDuration;\n      // fit\n      if (newStart - this.currentRegionBoundary[0] <= 2 / this.unit) {\n        newStart = this.currentRegionBoundary[0];\n        newEnd = newStart + duration;\n      }\n      if (this.currentRegionBoundary[1] - newEnd <= 2 / this.unit) {\n        newEnd = this.currentRegionBoundary[1];\n        newStart = newEnd - duration;\n      }\n      if (\n        newStart >= this.currentRegionBoundary[0] &&\n        newStart <= this.currentRegionBoundary[1] &&\n        newEnd >= this.currentRegionBoundary[0] &&\n        newEnd <= this.currentRegionBoundary[1]\n      ) {\n        selectedRegion.start = newStart;\n        selectedRegion.end = newEnd;\n        this.updateRegions({ [id]: selectedRegion });\n      }\n    }\n  };\n\n  onMouseUp = (e: MouseEvent, cursorTime: number, channelIndex: number) => {\n    const currentRegion = this.hoverRegion || this.renderRegions[this.selectedId || ''];\n    this.isClickRegion = false;\n    if (currentRegion) {\n      this.isClickRegion = true;\n      const regions: { [id: string]: Region | undefined } = {};\n      const update = (r: Region) => {\n        let region: Region | undefined;\n        const duration = r.end - r.start;\n        if (duration < Math.max(2 * this.deviation, 0.1)) {\n          region = undefined;\n        } else {\n          region = cloneDeep(r);\n        }\n        if (r.audition) this.setAuditionId(r.id);\n        return region;\n      };\n      const updateRegion = update(currentRegion);\n      if (this.segmentMode === SegmentMode.CONTINUOUS && this.adjoinRegion) {\n        const adjoinRegion = update(this.adjoinRegion);\n        if (!updateRegion && adjoinRegion) {\n          adjoinRegion.start = Math.min(currentRegion.start, this.adjoinRegion.start);\n          adjoinRegion.end = Math.max(currentRegion.end, this.adjoinRegion.end);\n        } else if (updateRegion && !adjoinRegion) {\n          updateRegion.start = Math.min(currentRegion.start, this.adjoinRegion.start);\n          updateRegion.end = Math.max(currentRegion.end, this.adjoinRegion.end);\n        }\n        regions[this.adjoinRegion.id] = adjoinRegion;\n      }\n      regions[currentRegion.id] = updateRegion;\n      this.wave?.fireEvent('update_regions', regions);\n      this.updateRegions(regions);\n    }\n\n    const clickRegion = currentRegion?.start !== currentRegion?.end ? currentRegion : undefined;\n    if (this.dragTime || this.resizeAbled || (!this.dragTime && !this.resizeAbled)) {\n      this.wave?.fireEvent('click_region', e, clickRegion ? cloneDeep(clickRegion) : undefined, channelIndex);\n    }\n    this.onMouseLeave('up');\n  };\n\n  onMouseLeave = (type?: string) => {\n    if (type !== 'up') {\n      this.setHoverRegion();\n    }\n    this.dragRegion = undefined;\n    this.resizeAbled = false;\n    this.resizeBorder = undefined;\n    this.dragTime = undefined;\n    this.isOverlap = false;\n    this.adjoinRegion = undefined;\n  };\n\n  setSelected = (id?: string) => {\n    this.selectedId = id;\n    if (this.auditionId && this.auditionId !== id) {\n      this.setAuditionId();\n    } else {\n      this.setRenderRegions();\n    }\n  };\n\n  setAuditionId = (id?: string) => {\n    if (id === this.auditionId) return;\n    const region = this.regions[this.auditionId || ''];\n    if (this.auditionId && region) {\n      this.updateRegions({ [this.auditionId]: undefined });\n      this.wave?.fireEvent('remove_audition');\n    }\n    this.auditionId = id;\n  };\n\n  resizeCanvas() {\n    if (this.canvas && this.wave) {\n      const canvasWidth = this.wave.width;\n      const canvasHeight = this.wave.drawer?.height || this.wave.height;\n      // set dimensions and style\n      this.canvas.width = canvasWidth * this.pixelRatio;\n      // on certain pixel ratios the canvas appears cut off at the bottom,\n      // therefore leave 1px extra\n      this.canvas.height = canvasHeight * this.pixelRatio;\n    }\n  }\n\n  updateRegions = (regions: { [id: string] : Region | undefined }) => {\n    Object.keys(regions).forEach((id) => {\n      const region = regions[id];\n      if (region) {\n        if (this.missRegions[region.id]) {\n          this.missRegions[region.id] = { ...region };\n        } else {\n          this.regions[id] = region;\n        }\n        if (this.hoverRegion?.id === id) {\n          this.setHoverRegion({ ...region });\n        }\n      } else {\n        delete this.regions[id];\n      }\n    });\n    this.setRenderRegions();\n  };\n\n  setRegions = (regions: {[id:string]: Region | null}) => {\n    const newRegions = cloneDeep(this.regions);\n    Object.keys(regions).forEach((id) => {\n      const region = regions[id];\n      if (region) {\n        newRegions[id] = {\n          ...region,\n          color: region.color || colors[region.channelIndex] || '#A1A1A1',\n        };\n      } else {\n        delete newRegions[id];\n      }\n    });\n    this.regions = newRegions;\n    this.setRenderRegions();\n  };\n\n  setWarnings = (list: RegionWarning[]) => {\n    const warnings: {[id: string]: RegionWarning} = {};\n    list.forEach((warning) => {\n      warnings[warning.id] = warning;\n    });\n    this.warnings = warnings;\n    this.setMissRegions();\n  };\n\n  setMissRegions = () => {\n    const missRegions: { [key: string]: Region } = {};\n    Object.values(this.warnings).forEach(({ isMissing, id, channelIndex, start, end }) => {\n      if (isMissing) {\n        missRegions[id] = {\n          id,\n          channelIndex: channelIndex!,\n          start: start!,\n          end: end!,\n          color: this.wave!.drawer!.channels[channelIndex!]?.color || colors[channelIndex!] || '#A1A1A1',\n          audition: true,\n        };\n      }\n    });\n    this.missRegions = missRegions;\n    if (this.auditionId) {\n      this.setAuditionId();\n    }\n    this.setRenderRegions();\n  };\n\n  setRenderRegions = () => {\n    // audition\n    const renderRegions = cloneDeep(this.regions);\n    this.renderRegions = {\n      ...renderRegions,\n      ...this.missRegions,\n    };\n    this.render();\n  };\n\n  render = () => {\n    if (!this.wave?.isPlaying()) {\n      this.renderCanvas();\n    }\n  };\n\n  renderCanvas = () => {\n    this.resizeCanvas();\n    if (this.ctx && this.wave?.drawer) {\n      const { displayRange, drawer: { waveHeight, height } } = this.wave;\n      const duration = this.wave.getDuration();\n      const startTime = duration * displayRange.start;\n      const endTime = duration * displayRange.end;\n      const canvasWidth = this.wave.width;\n      this.unit = canvasWidth / (endTime - startTime);\n      // selected region or channel\n      if (this.selectedId) {\n        const region = this.renderRegions[this.selectedId];\n        const drawIndex = this.wave.drawer.drawIndex[region?.channelIndex];\n        if (drawIndex !== undefined) {\n          this.ctx.lineWidth = 2 * this.pixelRatio;\n          const x = (region.start - startTime) * this.unit;\n          const y = drawIndex * waveHeight;\n          const width = (region.end - region.start) * this.unit;\n          this.ctx!.strokeStyle = region.audition ? missingColor : region.color;\n          this.ctx!.strokeRect((x + 1) * this.pixelRatio, (y + 1) * this.pixelRatio, (width - 2) * this.pixelRatio, (waveHeight - 2) * this.pixelRatio);\n          this.ctx!.fillStyle = 'rgba(0,0,0,0.1)';\n          this.ctx!.fillRect(x * this.pixelRatio, 0, width * this.pixelRatio, height * this.pixelRatio);\n          this.ctx!.fillRect(0, y * this.pixelRatio, canvasWidth * this.pixelRatio, waveHeight * this.pixelRatio);\n        }\n      } else if (this.selectedChannelIndex !== undefined) {\n        const drawIndex = this.wave?.drawer?.drawIndex[this.selectedChannelIndex];\n        if (drawIndex !== undefined && drawIndex >= 0) {\n          this.ctx!.beginPath();\n          this.ctx!.fillStyle = 'rgba(0,0,0,0.1)';\n          this.ctx!.fillRect(0, (drawIndex * waveHeight) * this.pixelRatio, canvasWidth * this.pixelRatio, waveHeight * this.pixelRatio);\n          this.ctx!.closePath();\n        }\n      }\n      this.ctx.lineWidth = 1 * this.pixelRatio;\n      Object.keys(this.renderRegions).forEach((id) => {\n        const { start, end, channelIndex, text, color, audition } = this.renderRegions[id];\n        const drawIndex = this.wave?.drawer?.drawIndex[channelIndex];\n        if (drawIndex !== undefined && drawIndex >= 0) {\n          const x = (start - startTime) * this.unit;\n          const y = drawIndex * waveHeight;\n          const width = (end - start) * this.unit;\n          const line1 = (start + this.deviation - startTime) * this.unit;\n          const line2 = (end - this.deviation - startTime) * this.unit;\n          this.ctx!.beginPath();\n          this.ctx!.strokeStyle = color;\n          // is missing region\n          this.ctx!.fillStyle = audition ? hexToRgba(missingColor, fillOpacity) : hexToRgba(color, fillOpacity);\n          this.ctx!.fillRect(x * this.pixelRatio, y * this.pixelRatio, width * this.pixelRatio, waveHeight * this.pixelRatio);\n          if (this.deviation > 0) {\n            this.ctx!.beginPath();\n            this.ctx!.moveTo(line1 * this.pixelRatio, (y + waveHeight * 0.25) * this.pixelRatio);\n            this.ctx!.lineTo(line1 * this.pixelRatio, (y + waveHeight * 0.75) * this.pixelRatio);\n            this.ctx!.moveTo(line2 * this.pixelRatio, (y + waveHeight * 0.25) * this.pixelRatio);\n            this.ctx!.lineTo(line2 * this.pixelRatio, (y + waveHeight * 0.75) * this.pixelRatio);\n            this.ctx!.closePath();\n            this.ctx!.stroke();\n          }\n          if (\n            this.segmentMode === SegmentMode.CONTINUOUS &&\n            id !== this.selectedId &&\n            end !== duration\n          ) {\n            this.ctx!.beginPath();\n            this.ctx!.strokeStyle = separationColor;\n            this.ctx!.moveTo((x + width) * this.pixelRatio, y * this.pixelRatio);\n            this.ctx!.lineTo((x + width) * this.pixelRatio, (y + waveHeight) * this.pixelRatio);\n            this.ctx!.closePath();\n            this.ctx!.stroke();\n          }\n          this.ctx!.font = `${fontSize * this.pixelRatio}px sans-serif`;\n          this.ctx!.textAlign = 'center';\n          // translation\n          if (text) {\n            const str = fittingString(this.ctx!, text, width * this.pixelRatio);\n            this.ctx!.beginPath();\n            this.ctx!.fillStyle = 'rgba(255, 255, 255, 0.6)';\n            this.ctx!.fillText(str, (x + width / 2) * this.pixelRatio, (y + waveHeight - 12) * this.pixelRatio);\n            if (str !== text && id === this.hoverRegion?.id) {\n              this.showPopLabel(x + width / 2, y, text, waveHeight);\n            }\n            this.ctx!.stroke();\n          }\n          // rejected\n          if (this.warnings[id]) {\n            this.ctx!.fillStyle = '#DC4624';\n            this.ctx!.beginPath();\n            this.ctx!.arc((x + width - 14) * this.pixelRatio, (y + 14) * this.pixelRatio, 8 * this.pixelRatio, 0, 2 * Math.PI);\n            this.ctx!.closePath();\n            this.ctx!.fill();\n            this.ctx!.beginPath();\n            this.ctx!.fillStyle = '#363B44';\n            this.ctx!.fillText('Ã—', (x + width - 14) * this.pixelRatio, (y + 17) * this.pixelRatio);\n            this.ctx!.stroke();\n          }\n          this.ctx!.closePath();\n        }\n      });\n    }\n  };\n\n  showPopLabel = (centerX: number, centerY: number, label: string, waveHeight: number) => {\n    if (this.ctx) {\n      let y = centerY - fontSize * 2.5;\n      y = y < 0 ? waveHeight + fontSize / 2 : y;\n      const labelWidth = this.ctx.measureText(label).width + fontSize * this.pixelRatio;\n      this.ctx.fillStyle = 'rgba(0,0,0,0.8)';\n      this.ctx.strokeStyle = 'rgba(0,0,0,0)';\n      drawRoundedRect(\n        { x: centerX * this.pixelRatio - labelWidth / 2, y: y * this.pixelRatio, width: labelWidth, height: fontSize * 2 * this.pixelRatio },\n        fontSize / 2,\n        this.ctx\n      );\n      this.ctx.beginPath();\n      if (y > centerY) {\n        this.ctx.moveTo((centerX - fontSize / 2) * this.pixelRatio, y * this.pixelRatio);\n        this.ctx.lineTo(centerX * this.pixelRatio, (y - fontSize / 2) * this.pixelRatio);\n        this.ctx.lineTo((centerX + fontSize / 2) * this.pixelRatio, y * this.pixelRatio);\n      } else {\n        this.ctx.moveTo((centerX - fontSize / 2) * this.pixelRatio, (centerY - fontSize / 2) * this.pixelRatio);\n        this.ctx.lineTo(centerX * this.pixelRatio, centerY * this.pixelRatio);\n        this.ctx.lineTo((centerX + fontSize / 2) * this.pixelRatio, (centerY - fontSize / 2) * this.pixelRatio);\n      }\n      this.ctx.closePath();\n      this.ctx.fill();\n      this.ctx.fillStyle = 'rgb(255, 255, 255)';\n      this.ctx.fillText(label, centerX * this.pixelRatio, (y + 1.35 * fontSize) * this.pixelRatio);\n    }\n  };\n\n  destroy() {\n    if (this.wave) {\n      this.wave.un('draw', this._onRedraw);\n      this.wave.un('ready', this._onReady);\n      this.wave.un('mousedown', this.onMousedown);\n      this.wave.un('mousemove', this.onMousemove);\n      this.wave.un('mouseup', this.onMouseUp);\n      this.wave.un('mouseleave', this.onMouseLeave);\n    }\n    if (this.container && this.canvas) {\n      this.container.removeChild(this.canvas);\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}