{"ast":null,"code":"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Point } from 'pixi.js';\nimport { makeObservable, observable, action } from 'mobx';\nimport { message } from 'antd';\nimport { debounce, isEqual } from 'lodash';\nimport { inv } from 'mathjs';\nimport { deflate, inflate } from 'pako';\nimport simplify from 'simplify-js';\nimport randomColor from 'randomcolor';\n// import { APIForwardType } from 'src/libs/JobProxy';\nimport InspectLabel from '../components/attributes/InspectLabel';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape, parseFields, calcShapeArea, isAttributesPassCondition, isPDFUrl, isVideoUrl } from '../utils';\nimport { Tool, ViewMode, LabelItem, ReviewMode, CameraLayout, CVModel, PolygonCreateMethod, PixelToolMode, ShapeFocusMode, PredictiveMode, SoloMode, ContinuousModeType } from '../types';\nimport { CAMERA_VIEW_LABELS } from '../constants';\nimport ShapeFactory from '../../common/shapes/ShapeFactory';\nimport { ShapeType } from '../../common/shapes/types';\nimport { EventAction, BorderStyle, ShapeRotateMode, ShapeRotateHandleMode } from '../../common/shapes/Shape';\nimport Rectangle, { RectType } from '../../common/shapes/Rectangle';\nimport Polygon, { PolygonType } from '../../common/shapes/Polygon';\nimport QuadPrism from '../../common/shapes/QuadPrism';\nimport OrientedQuadPrism from '../../common/shapes/OrientedQuadPrism';\nimport Line, { HoverMode, LineType } from '../../common/shapes/Line';\nimport Curve from '../../common/shapes/Curve';\nimport Dot from '../../common/shapes/Dot';\nimport Keypoints from '../../common/shapes/Keypoints';\nimport Pixel, { PixelEventAction } from '../../common/shapes/Pixel';\nimport Label from '../../common/shapes/label/Label';\nimport MultiShapesResizer, { ResizeAction, calcBoundsByShapes } from '../../common/shapes/resizers/MultiShapesResizer';\nimport Cursor from '../../common/Cursor';\nimport { getFieldDisplayLabel } from '../../../utils/form';\nimport { computeRotatedPosition, precise } from '../../../utils/math';\nimport { getMatrixByRotation, calcPositionByMatrix } from '../../../utils/matrix';\nimport Recognizer from '../../../model/Recognizer';\nimport cache, { CacheKey } from '../utils-storage';\nimport tracker, { TrackEventName } from '../../../utils/tracker';\nimport createLabelPrefix from '../shapes/LabelPrefix';\nimport { APIForwardType } from '../../../libs/JobProxy';\nimport PixelsData from '../../../utils/pixels';\nimport { fillMask, resolveMask, rotateMask } from '../utils-predict';\nconst shapeTypesSupportProject = [ShapeType.LINE, ShapeType.POLYGON];\n/**\n * store for shapes in current camera & current frame\n * @class\n */\nexport default class ShapeStore {\n  /**\n   * is drawing shape\n   * @getter\n   */\n  get isDrawing() {\n    return this.drawingShape !== null;\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * app\n     */\n    this.app = void 0;\n    /**\n     * current layer\n     */\n    this.currentLayer = void 0;\n    /**\n     * shapes in current frame\n     */\n    this.shapes = {};\n    /**\n     * cache current frame (used in callbacks to avoid frame changes but shapes not update issues)\n     */\n    this.shapesFrame = 0;\n    /**\n     * the end point of the previous line segment in different camera and frame\n     */\n    this.previousLineEndPoint = null;\n    /**\n     * Whether to use the last point of the previous graph of the same type as the starting point（current only line）\n     */\n    this.lineContinuous = false;\n    /**\n     * all visible shape ids\n     */\n    this.visibleShapeIds = [];\n    /**\n     * currently drawing shape\n     */\n    this.drawingShape = null;\n    /**\n     * recognizer\n     */\n    this.recognizer = null;\n    /**\n     * if recognition prepared, start to do recognition\n     */\n    this.recognitionStart = false;\n    /**\n     * currently selected shapes\n     */\n    this.selectedShapes = [];\n    /**\n     * currently selected shape vertex index for polygon & line\n     */\n    this.selectedPointIndex = -1;\n    /**\n     * shapes resizer\n     */\n    this.shapesResizer = void 0;\n    /**\n     * predicted shapes\n     */\n    this.predictedShapes = {};\n    /**\n     * projected shapes\n     */\n    this.projectedShapes = {};\n    /**\n     * hovered shape id\n     */\n    this.hoveredShapeId = '';\n    /**\n     * waiting merge polygon\n     */\n    this.pendingMergePolygon = '';\n    /**\n     * waiting merge line\n     */\n    this.pendingMergeLine = null;\n    /**\n     * waiting merge pixel\n     */\n    this.pendingMergePixel = null;\n    /**\n     * shape id in cut mode\n     */\n    this.cuttingShape = '';\n    /**\n     * shape id in split mode\n     */\n    this.splittingShape = '';\n    /**\n     * shape id in appending mode\n     */\n    this.appendingShape = '';\n    /**\n     * shape id in updating mode\n     */\n    this.updatingShape = '';\n    /**\n     * is deleting\n     */\n    this.deleting = false;\n    /**\n     * is points moving\n     */\n    this.pointsMoving = false;\n    /**\n     * is shapes moving\n     */\n    this.shapesMoving = false;\n    /**\n     * is shape projecting\n     */\n    this.projecting = false;\n    /**\n     * when shapes visibility change\n     */\n    this.shapesRefreshCounter = 0;\n    /**\n     * shape display config\n     */\n    this.config = {\n      fill: true,\n      alpha: 20,\n      borderAlpha: 100,\n      borderWidth: 1,\n      dotRadius: 5,\n      showSideLength: false,\n      showDirection: false,\n      showVertex: false,\n      showVertexOrder: false,\n      vertexSize: 4,\n      vertexStart: 1\n    };\n    /**\n     * default config from payload\n     */\n    this.defaultConfig = this.config;\n    /**\n     * show discrete points for curve edges\n     */\n    this.showCurveDiscretePoints = false;\n    /**\n     * side ratio\n     * ---- FIXME: customized for specific project\n     * ---- PID: A5764\n     */\n    this.showSideRatio = false;\n    /**\n     * creating shape's display color when display_color is random\n     * @private {string}\n     */\n    this.creatingShapeColor = '';\n    /**\n     * cache predict info from API\n     */\n    this.cachedPredictInfo = void 0;\n    /**\n     * clear shapes\n     */\n    this.clearShapes = () => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.destroy();\n      });\n      this.shapes = {};\n      this.shapesFrame = this.rootStore.frame.currentFrame;\n      this.drawingShape = null;\n      this.selectedShapes = [];\n      this.clearPredictedShapes();\n      this.clearProjectedShapes();\n      this.selectedPointIndex = -1;\n    };\n    /**\n     * clear predicted shapes\n     */\n    this.clearPredictedShapes = () => {\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.destroy();\n      });\n      this.predictedShapes = {};\n    };\n    /**\n     * clear projected shapes\n     */\n    this.clearProjectedShapes = () => {\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.destroy();\n        });\n      });\n      this.projectedShapes = {};\n    };\n    /**\n     * is predicted shape\n     * @param s\n     */\n    this.isPredictedShape = s => Object.values(this.predictedShapes).findIndex(({\n      shape\n    }) => shape === s) >= 0;\n    /**\n     * get shape by instance item\n     * @param instanceItem\n     */\n    this.getShapeByInstanceItem = (instanceItem, camera = this.rootStore.frame.currentCamera) => {\n      const shapeItem = Object.values(this.shapes).find(i => i.camera === camera && i.instanceItem === instanceItem);\n      if (shapeItem) {\n        return shapeItem.shape;\n      }\n      return undefined;\n    };\n    /**\n     * get shapes by instance items\n     * @param instanceItems\n     * @param camera\n     */\n    this.getShapesByInstanceItems = (instanceItems, camera = this.rootStore.frame.currentCamera) => {\n      const shapeItems = Object.values(this.shapes).filter(i => i.camera === camera && instanceItems.indexOf(i.instanceItem) >= 0);\n      return shapeItems.map(i => i.shape);\n    };\n    /**\n     * get shapes for one camera\n     * @param camera\n     * @param onlyKeepEditable\n     */\n    this.getShapesForCamera = (camera, onlyKeepEditable = false) => Object.values(this.shapes).filter(s => s.camera === camera && (!onlyKeepEditable || s.shape.editable));\n    /**\n     * get shapes in layer for one camera\n     * @param camera\n     * @param layer\n     */\n    this.getShapesForCameraByLayer = (camera, layer = this.rootStore.config.activeLayerIndex) => {\n      const {\n        currentFrame\n      } = this.rootStore.frame;\n      const allShapes = Object.values(this.shapes);\n      const layerShapes = [];\n      for (let i = 0; i < allShapes.length; i += 1) {\n        const shape = allShapes[i];\n        if (shape.camera === camera) {\n          var _shape$instanceItem$c;\n          const {\n            layer: shapeLayer\n          } = ((_shape$instanceItem$c = shape.instanceItem.cameras[camera]) === null || _shape$instanceItem$c === void 0 ? void 0 : _shape$instanceItem$c.frames[currentFrame]) || {};\n          if (shapeLayer === layer) {\n            layerShapes.push(shape);\n          }\n        }\n      }\n      return layerShapes;\n    };\n    /**\n     * update shapes interactive\n     * @param interactive\n     * @param ignoreIds\n     */\n    this.updateShapesInteractive = (interactive, ignoreIds) => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (ignoreIds && ignoreIds.includes(shape.uid)) {\n          return;\n        }\n        shape.interactive = interactive;\n        if (interactive && this.selectedShapes.indexOf(shape) >= 0) {\n          shape.selected = true;\n        }\n      });\n    };\n    /**\n     * update shapes user data mode\n     * @param userDataMode\n     */\n    this.updateShapesUserDataMode = userDataMode => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.userDataMode = userDataMode;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.userDataMode = userDataMode;\n      });\n    };\n    /**\n     * update shapes rotate mode\n     * @param shapeRotateMode\n     */\n    this.updateShapesRotateMode = shapeRotateMode => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.rotateMode = shapeRotateMode;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.rotateMode = shapeRotateMode;\n      });\n    };\n    /**\n     * update rotate handle mode when shape rotate mode is handle\n     * @param shapeRotateHandleMode\n     */\n    this.updateShapesRotateHandleMode = shapeRotateHandleMode => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.rotateHandleMode = shapeRotateHandleMode;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.rotateHandleMode = shapeRotateHandleMode;\n      });\n    };\n    /**\n     * update shapes show auxiliary lines\n     * @param showAuxiliaryLines\n     */\n    this.updateShapesShowAuxiliaryLines = showAuxiliaryLines => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Rectangle) {\n          shape.showAuxiliaryLines = showAuxiliaryLines;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Rectangle) {\n          shape.showAuxiliaryLines = showAuxiliaryLines;\n        }\n      });\n    };\n    /**\n     * update pixel shapes show bounds\n     * @param showPixelShapeBounds\n     */\n    this.updatePixelShapesShowBounds = showPixelShapeBounds => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Pixel) {\n          shape.showShapeBounds = showPixelShapeBounds;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Pixel) {\n          shape.showShapeBounds = showPixelShapeBounds;\n        }\n      });\n    };\n    /**\n     * update shapes double click finish (only for pixel shape)\n     * @param dblclickFinish\n     */\n    this.updateShapesDoubleClickFinish = dblclickFinish => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape.shapeType === ShapeType.PIXEL) {\n          shape.dblclickFinish = dblclickFinish;\n        }\n      });\n    };\n    /**\n     * update rectangle shapes auto snap tolerance\n     * @param tolerance\n     */\n    this.updateRectangleShapesAutoSnapTolerance = tolerance => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Rectangle) {\n          shape.autoSnapTolerance = tolerance;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Rectangle) {\n          shape.autoSnapTolerance = tolerance;\n        }\n      });\n    };\n    /**\n     * redraw shapes label\n     */\n    this.redrawShapesLabel = () => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.drawShapeLabel();\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.drawShapeLabel();\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.drawShapeLabel();\n        });\n      });\n    };\n    /**\n     * setup shapes for current frame\n     */\n    this.setupShapes = () => {\n      this.clearShapes();\n      const {\n        cameraViews,\n        currentCamera,\n        currentFrameByCamera,\n        cameraNames,\n        getImageBoundsForCamera\n      } = this.rootStore.frame;\n      const layersCount = this.rootStore.config.layers.length || 1;\n      const allShapeOrders = {};\n      const noOrderShapes = {};\n      cameraNames.forEach(cameraName => {\n        allShapeOrders[cameraName] = [];\n        noOrderShapes[cameraName] = [];\n        for (let i = 0; i < layersCount; i += 1) {\n          allShapeOrders[cameraName][i] = new Set();\n          noOrderShapes[cameraName][i] = [];\n        }\n      });\n      const startOrder = this.rootStore.segmentation.enabled ? 1 : 0;\n      Object.values(this.rootStore.instance.instances).forEach(instance => {\n        Object.values(instance.items).forEach(item => {\n          Object.values(item.cameras).forEach(({\n            camera\n          }) => {\n            const {\n              frames\n            } = item.cameras[camera];\n            const cameraView = cameraViews[camera];\n            const cameraFrame = currentFrameByCamera[camera];\n            if (frames[cameraFrame] && cameraView && !cameraView.imageLoadError) {\n              const frameData = frames[cameraFrame];\n              const {\n                layer\n              } = frameData;\n              const shape = this.createShape(cameraView.getShapesLayerByIndex(layer), getImageBoundsForCamera(camera, cameraFrame), item.colorConfig.color, instance.category, item.name, item, frames[cameraFrame].shapeType, frames[cameraFrame].shape, frames[cameraFrame].order, item.label, camera);\n              item.setShapeColorConifg({\n                fillColor: shape.fillColor,\n                edgeColor: shape.borderColor,\n                pointColor: shape.vertexColor,\n                color: item.colorConfig.color\n              });\n              if (shape.destroyed) {\n                // delete instance item\n                this.rootStore.instance.deleteInstanceItemByFrame(item, cameraFrame, camera);\n                return;\n              }\n              if (shape.area < this.rootStore.config.minArea && shape.shapeType !== ShapeType.PIXEL && this.rootStore.annotatable) {\n                // delete instance item & shape when is small\n                this.deleteShape(shape);\n                this.rootStore.instance.deleteInstanceItemByFrame(item, cameraFrame, camera);\n                return;\n              }\n              if (this.rootStore.readonly || frameData.locked) {\n                shape.editable = false;\n              }\n              if (this.rootStore.config.measureMode) {\n                shape.interactive = false;\n              }\n              if (frameData.isPreAnnotation) {\n                var _shape$labelDom;\n                (_shape$labelDom = shape.labelDom) === null || _shape$labelDom === void 0 ? void 0 : _shape$labelDom.setPrefix(createLabelPrefix());\n              }\n              this.setShapeStyles(shape, item);\n              this.addShapeListeners(shape);\n              this.shapes[shape.uid] = {\n                shape,\n                camera,\n                instanceItem: item\n              };\n              if (camera === currentCamera && shape.shapeType === ShapeType.PIXEL) {\n                this.rootStore.segmentation.update(item, layer, shape);\n              }\n              const {\n                shape: savedShapeData,\n                order\n              } = frameData;\n              const currShapeData = shape.getData();\n              if (!isEqual(savedShapeData, currShapeData) && this.rootStore.annotatable) {\n                // shape data changed, update\n                frameData.shape = currShapeData;\n              }\n              if (currShapeData.area !== undefined && frameData.shape.area === undefined) {\n                // add shape area\n                frameData.shape.area = currShapeData.area;\n              }\n              if (shape.shapeType === ShapeType.PIXEL) {\n                // only 0 is valid order for pixel shape\n                shape.order = 0;\n                frameData.order = shape.order;\n              } else if (typeof order === 'number' && order >= startOrder && !allShapeOrders[camera][layer].has(order)) {\n                // update next shape order\n                shape.order = order;\n                allShapeOrders[camera][layer].add(order);\n              } else {\n                // add to temp array\n                noOrderShapes[camera][layer].push({\n                  frameData,\n                  shape\n                });\n              }\n            }\n          });\n        });\n      });\n      Object.keys(noOrderShapes).forEach(cameraName => {\n        noOrderShapes[cameraName].forEach((cameraShapes, layerIndex) => {\n          cameraShapes.forEach(({\n            frameData,\n            shape\n          }) => {\n            // new order\n            shape.order = this.rootStore.frame.getNextShapeOrder(layerIndex, frameData.frameIndex, cameraName);\n            frameData.order = shape.order;\n          });\n        });\n      });\n      this.projectShapes();\n    };\n    /**\n     * format point label\n     * @param data\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.formatPointLabel = (data, categoryName, categoryItemName) => {\n      const pointLabelConfig = this.rootStore.ontology.getPointLabelConfigFromCategoryItem(categoryName, categoryItemName);\n      const fieldsMap = parseFields(pointLabelConfig);\n      const labels = [];\n      const {\n        pointLabelItems\n      } = this.rootStore.config;\n      Object.keys(data).forEach(key => {\n        const label = [];\n        const field = fieldsMap[key];\n        const fieldValue = data[key];\n        if (pointLabelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n          label.push((field === null || field === void 0 ? void 0 : field.label) || (field === null || field === void 0 ? void 0 : field.name) || `${key}`);\n        }\n        if (pointLabelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n          const displayValue = getFieldDisplayLabel(fieldValue, field);\n          label.push(displayValue);\n        }\n        if (label.length > 0) {\n          labels.push(label);\n        }\n      });\n      return labels.map(l => l.join(': ')).join('; ');\n    };\n    /**\n     * get point style\n     * @param pointIndex\n     * @param data\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.getPointStyle = (pointIndex, data, shape, categoryName, categoryItemName) => {\n      let pointColor;\n      let pointType;\n      // by point attributes\n      if (data) {\n        const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n        const {\n          pointLabelConfig,\n          pointLabelConfigGroups\n        } = categoryItem || {};\n        if (pointLabelConfig && pointLabelConfigGroups) {\n          // from point label config settings\n          pointLabelConfigGroups.some(g => {\n            const {\n              attributes,\n              ...styles\n            } = g;\n            if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n              // match group attributes\n              if (pointColor === undefined) {\n                const color = styles.pointColor;\n                if (color) {\n                  pointColor = parseInt(color.substr(1), 16);\n                }\n              }\n              if (pointType === undefined) {\n                const type = styles.pointType;\n                if (type) {\n                  pointType = type;\n                }\n              }\n            }\n            return pointColor !== undefined && pointType !== undefined;\n          });\n        } else if (pointColor === undefined) {\n          // from hotkeys config\n          const dataKeyLen = Object.keys(data).length;\n          Object.values(this.rootStore.config.hotkeyMap).some(items => items.some(({\n            affected,\n            type,\n            color,\n            shape: pointShape,\n            attributes\n          }) => {\n            if (affected === 'point' && (color !== undefined || pointShape !== undefined)) {\n              const attrKeys = Object.keys(attributes);\n              if (isAttributesPassCondition(data, attributes) && (type !== 'overwrite' || attrKeys.length === dataKeyLen)) {\n                if (color !== undefined) {\n                  pointColor = parseInt(color.substr(1), 16);\n                }\n                if (pointShape !== undefined) {\n                  pointType = pointShape;\n                }\n                return true;\n              }\n            }\n            return false;\n          }));\n        }\n      }\n\n      // by point index\n      const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n      if (styles) {\n        // has style config\n        if (pointColor === undefined) {\n          // color not affected by attributes, use point index settings\n          const color = (styles.pointsColor || [])[pointIndex];\n          if (color) {\n            pointColor = parseInt(color.substr(1), 16);\n          }\n        }\n        if (pointType === undefined) {\n          // type not affected by attributes, use point index settings\n          const type = (styles.pointsType || [])[pointIndex];\n          if (type) {\n            pointType = type;\n          }\n        }\n      }\n      return {\n        color: pointColor,\n        type: pointType\n      };\n    };\n    /**\n     * get edge style\n     * @param startPointIndex\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.getEdgeStyle = (startPointIndex, data, shape, categoryName, categoryItemName) => {\n      let edgeColor;\n      let edgeType;\n      let edgeBold;\n\n      // by point labelConfig\n      if (data) {\n        const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n        const {\n          pointLabelConfig,\n          pointLabelConfigGroups\n        } = categoryItem || {};\n        if (pointLabelConfig && pointLabelConfigGroups) {\n          // from point label config settings\n          pointLabelConfigGroups.some(g => {\n            const {\n              attributes,\n              ...styles\n            } = g;\n            if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n              // match group attributes\n              if (edgeColor === undefined) {\n                const color = styles.edgeColor;\n                if (color) {\n                  edgeColor = parseInt(color.substr(1), 16);\n                }\n              }\n              if (edgeType === undefined) {\n                const type = styles.edgeType;\n                if (type) {\n                  edgeType = type;\n                }\n              }\n              if (edgeBold === undefined) {\n                const bold = styles.edgeBold;\n                if (bold !== undefined) {\n                  edgeBold = bold;\n                }\n              }\n            }\n            return edgeColor !== undefined && edgeType !== undefined && edgeBold !== undefined;\n          });\n        }\n      }\n      if (edgeColor === undefined || edgeType === undefined || edgeBold === undefined) {\n        // by point index\n        const styles = this.rootStore.ontology.getToolEdgesStylesByCategoryItem(categoryName, categoryItemName);\n        if (styles) {\n          // has style config\n          if (edgeColor === undefined) {\n            // color not affected by attributes, use point index settings\n            const color = (styles.edgesColor || [])[startPointIndex];\n            if (color) {\n              edgeColor = parseInt(color.substr(1), 16);\n            }\n          }\n          if (edgeType === undefined) {\n            // type not affected by attributes, use point index settings\n            const type = (styles.edgesType || [])[startPointIndex];\n            if (type) {\n              edgeType = type;\n            }\n          }\n          if (edgeBold === undefined) {\n            // bold not affected by attributes, use point index settings\n            const bold = (styles.edgesBold || [])[startPointIndex];\n            if (bold !== undefined) {\n              edgeBold = bold;\n            }\n          }\n        }\n      }\n      return {\n        color: edgeColor,\n        type: edgeType,\n        bold: edgeBold\n      };\n    };\n    /**\n     * get shape style (for fill color & dot style & color)\n     * @param data\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.getShapeStyle = (data, categoryName, categoryItemName, instanceItem) => {\n      let dotColor;\n      let dotType;\n      let fillColor;\n      let borderColor;\n      let borderType;\n      let borderBold;\n      let vertexColor;\n      let vertexType;\n      const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n      if (data) {\n        const {\n          labelConfig,\n          labelConfigGroups\n        } = categoryItem || {};\n        if (labelConfig && labelConfigGroups) {\n          // has label config settings\n          labelConfigGroups.some(g => {\n            const {\n              attributes,\n              ...styles\n            } = g;\n            if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n              // match group attributes\n              if (dotColor === undefined) {\n                const color = styles.pointColor;\n                if (color) {\n                  dotColor = parseInt(color.substr(1), 16);\n                }\n              }\n              if (dotType === undefined) {\n                const type = styles.pointType;\n                if (type) {\n                  dotType = type;\n                }\n              }\n              if (fillColor === undefined && styles.fillColor) {\n                fillColor = parseInt(styles.fillColor.substr(1), 16);\n              }\n              if (borderColor === undefined && styles.edgeColor) {\n                borderColor = parseInt(styles.edgeColor.substr(1), 16);\n              }\n              if (borderType === undefined && styles.edgeType) {\n                borderType = styles.edgeType;\n              }\n              if (borderBold === undefined && styles.edgeBold !== undefined) {\n                borderBold = styles.edgeBold;\n              }\n              if (vertexColor === undefined && styles.pointColor) {\n                vertexColor = parseInt(styles.pointColor.substr(1), 16);\n              }\n              if (vertexType === undefined && styles.pointType) {\n                vertexType = styles.pointType;\n              }\n            }\n            return dotColor !== undefined && dotType !== undefined && fillColor !== undefined && borderColor !== undefined && borderType !== undefined && borderBold !== undefined && vertexColor !== undefined && vertexType !== undefined;\n          });\n        }\n      }\n      const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n      if (styles) {\n        if (dotColor === undefined) {\n          // color not affected by attributes, use shape settings\n          const color = styles.pointColor;\n          if (color && color !== 'random') {\n            dotColor = parseInt(color.substr(1), 16);\n          }\n        }\n        if (dotType === undefined) {\n          // type not affected by attributes, use shape settings\n          const type = styles.pointType;\n          if (type) {\n            dotType = type;\n          }\n        }\n      }\n      if (fillColor === undefined) {\n        // fill color not affected by attributes, use shape settings\n        const fill = this.rootStore.ontology.getToolFillByCategoryItem(categoryName, categoryItemName);\n        if (fill) {\n          var _instanceItem$colorCo;\n          if (fill !== 'random') {\n            fillColor = parseInt(fill.substr(1), 16);\n          } else if (instanceItem === null || instanceItem === void 0 ? void 0 : (_instanceItem$colorCo = instanceItem.colorConfig) === null || _instanceItem$colorCo === void 0 ? void 0 : _instanceItem$colorCo.fillColor) {\n            fillColor = instanceItem.colorConfig.fillColor;\n          } else {\n            fillColor = parseInt(randomColor().substr(1), 16);\n          }\n        }\n      }\n      if (borderColor === undefined || borderType === undefined || borderBold === undefined || vertexColor === undefined || vertexType === undefined) {\n        const {\n          pointsStyles,\n          edgesStyles\n        } = this.rootStore.ontology.getToolStylesByCategoryItem(categoryName, categoryItemName);\n        if (borderColor === undefined && (edgesStyles === null || edgesStyles === void 0 ? void 0 : edgesStyles.edgeColor)) {\n          var _instanceItem$colorCo2;\n          if (edgesStyles.edgeColor !== 'random') {\n            borderColor = parseInt(edgesStyles.edgeColor.substr(1), 16);\n          } else if (instanceItem === null || instanceItem === void 0 ? void 0 : (_instanceItem$colorCo2 = instanceItem.colorConfig) === null || _instanceItem$colorCo2 === void 0 ? void 0 : _instanceItem$colorCo2.edgeColor) {\n            borderColor = instanceItem.colorConfig.edgeColor;\n          } else {\n            borderColor = parseInt(randomColor().substr(1), 16);\n          }\n        }\n        if (borderType === undefined && (edgesStyles === null || edgesStyles === void 0 ? void 0 : edgesStyles.edgeType)) {\n          borderType = edgesStyles.edgeType;\n        }\n        if (borderBold === undefined && (edgesStyles === null || edgesStyles === void 0 ? void 0 : edgesStyles.edgeBold) !== undefined) {\n          borderBold = edgesStyles.edgeBold;\n        }\n        if (vertexColor === undefined && (pointsStyles === null || pointsStyles === void 0 ? void 0 : pointsStyles.pointColor)) {\n          var _instanceItem$colorCo3;\n          if (pointsStyles.pointColor !== 'random') {\n            vertexColor = parseInt(pointsStyles.pointColor.substr(1), 16);\n          } else if (instanceItem === null || instanceItem === void 0 ? void 0 : (_instanceItem$colorCo3 = instanceItem.colorConfig) === null || _instanceItem$colorCo3 === void 0 ? void 0 : _instanceItem$colorCo3.pointColor) {\n            vertexColor = instanceItem.colorConfig.pointColor;\n          } else {\n            vertexColor = parseInt(randomColor().substr(1), 16);\n          }\n        }\n        if (vertexType === undefined && (pointsStyles === null || pointsStyles === void 0 ? void 0 : pointsStyles.pointType)) {\n          vertexType = pointsStyles.pointType;\n        }\n      }\n      let displayColor;\n      let displayColorString = '';\n      if (instanceItem) {\n        if (instanceItem.colorConfig.color) {\n          displayColor = parseInt(instanceItem.colorConfig.color.substr(1), 16);\n        }\n      } else if (!categoryItem || !categoryItem.displayColor || (categoryItem === null || categoryItem === void 0 ? void 0 : categoryItem.displayColor) === 'random') {\n        displayColorString = randomColor();\n        displayColor = parseInt(displayColorString.substr(1), 16);\n      } else {\n        displayColorString = categoryItem.displayColor;\n        displayColor = parseInt(categoryItem.displayColor.substr(1), 16);\n      }\n      if (!instanceItem) {\n        this.creatingShapeColor = displayColorString;\n      }\n      return {\n        dotColor: dotColor || displayColor,\n        dotType,\n        fillColor: fillColor || displayColor,\n        borderColor: borderColor || displayColor,\n        borderType,\n        borderBold,\n        vertexColor: vertexColor || displayColor,\n        vertexType\n      };\n    };\n    /**\n     * set shape styles\n     * @param shape\n     * @param instanceItem\n     * @param camera\n     * @param frameIndex\n     */\n    this.setShapeStyles = (shape, instanceItem, camera = this.rootStore.frame.currentCamera, frameIndex = this.rootStore.frame.currentFrame) => {\n      var _instanceItem$cameras;\n      const {\n        attributes\n      } = ((_instanceItem$cameras = instanceItem.cameras[camera]) === null || _instanceItem$cameras === void 0 ? void 0 : _instanceItem$cameras.frames[frameIndex]) || {};\n      const {\n        dotColor,\n        dotType,\n        fillColor,\n        borderColor,\n        borderType,\n        borderBold,\n        vertexColor,\n        vertexType\n      } = this.getShapeStyle(attributes, instanceItem.instance.category, instanceItem.name, instanceItem);\n      if (shape.shapeType === ShapeType.DOT) {\n        if (dotColor !== undefined) {\n          shape.color = dotColor;\n          shape.originColors.color = dotColor;\n        }\n        if (dotType) {\n          shape.dotType = dotType;\n        }\n      }\n      if ((shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.RECTANGLE || shape.shapeType === ShapeType.SQUARE) && fillColor !== undefined) {\n        shape.fillColor = fillColor;\n      }\n      if (shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.LINE || shape.shapeType === ShapeType.ARROW || shape.shapeType === ShapeType.RECTANGLE || shape.shapeType === ShapeType.SQUARE) {\n        if (borderColor !== undefined) {\n          shape.borderColor = borderColor;\n          shape.originColors.borderColor = borderColor;\n        }\n        if (borderType !== undefined) {\n          shape.borderType = borderType;\n        }\n        if (borderBold !== undefined) {\n          shape.borderBold = borderBold;\n        }\n      }\n      if (shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.LINE || shape.shapeType === ShapeType.ARROW || shape.shapeType === ShapeType.KEYPOINTS) {\n        if (vertexColor !== undefined) {\n          shape.vertexColor = vertexColor;\n        }\n        if (vertexType !== undefined) {\n          shape.vertexType = vertexType;\n        }\n      }\n    };\n    /**\n     * create shape instance\n     * @param shapeContainer\n     * @param imageBounds\n     * @param hexColor\n     * @param categoryName\n     * @param categoryItemName\n     * @param shapeType\n     * @param shapeData\n     * @param order\n     * @param label\n     */\n    this.createShape = (shapeContainer, imageBounds, hexColor, categoryName, categoryItemName, instanceItem, shapeType, shapeData, order, label, camera) => {\n      var _this$rootStore$frame;\n      const {\n        boundaryCheck,\n        dataPrecision,\n        draggable,\n        rotatable,\n        autoSnap,\n        activePointAttributesMode,\n        preferences,\n        layers\n      } = this.rootStore.config;\n      const {\n        shapeRotateMode = ShapeRotateMode.HANDLE,\n        shapeRotateHandleMode = ShapeRotateHandleMode.SELECTED,\n        autoSnapTolerance\n      } = preferences;\n      const {\n        currentToolItem,\n        currentTool,\n        currentShapeType,\n        currentCreateMethod,\n        getToolConfigByCategoryItem\n      } = this.rootStore.ontology;\n      const useCurrent = shapeType === undefined;\n      const controlsContainer = layers.length === 0 ? undefined : shapeContainer.parent;\n      const type = shapeType || currentShapeType;\n      const toolConfig = getToolConfigByCategoryItem(categoryName, categoryItemName);\n      const shapeStyles = this.getShapeStyle(null, categoryName, categoryItemName, instanceItem);\n      const {\n        dotType,\n        fillColor,\n        borderColor,\n        borderType,\n        borderBold,\n        vertexColor,\n        vertexType\n      } = shapeStyles;\n      let color = parseInt(hexColor.substr(1), 16);\n      if (hexColor === 'random') {\n        if (this.creatingShapeColor) {\n          color = parseInt(this.creatingShapeColor.substr(1), 16);\n        } else {\n          color = parseInt(randomColor().substr(1), 16);\n        }\n      }\n      const {\n        dotColor = color\n      } = shapeStyles;\n      const shape = ShapeFactory.getShape(type, {\n        app: this.app,\n        container: shapeContainer,\n        controlsContainer,\n        color,\n        fillColor,\n        borderColor,\n        borderType,\n        borderBold,\n        vertexColor,\n        vertexType,\n        alpha: this.config.fill ? this.config.alpha / 100 : 0,\n        dataPrecision,\n        draggable,\n        borderWidth: this.config.borderWidth,\n        borderAlpha: this.config.borderAlpha / 100,\n        showSideLength: this.config.showSideLength,\n        showDirection: this.config.showDirection,\n        showVertex: this.config.showVertex,\n        showVertexOrder: this.config.showVertexOrder,\n        vertexSize: type === ShapeType.KEYPOINTS ? this.config.dotRadius : this.config.vertexSize,\n        vertexStart: this.config.vertexStart,\n        ...((boundaryCheck || type === ShapeType.PIXEL) && {\n          bounds: imageBounds\n        }),\n        label,\n        ...shapeData,\n        ...toolConfig,\n        ...(type === ShapeType.DOT && {\n          dotRadius: this.config.dotRadius,\n          dotType,\n          color: dotColor\n        }),\n        ...((type === ShapeType.RECTANGLE || type === ShapeType.SQUARE) && {\n          autoSnapEnabled: autoSnap,\n          autoSnapTolerance\n        }),\n        ...((type === ShapeType.RECTANGLE || type === ShapeType.SQUARE || type === ShapeType.POLYGON || type === ShapeType.ELLIPSE) && {\n          rotatable\n        }),\n        ...(useCurrent && currentTool === Tool.CENTERLINE_RECTANGLE && {\n          centerLineEnabled: true\n        }),\n        ...(useCurrent && currentTool === Tool.FOUR_DOTS_RECTANGLE && {\n          rectType: RectType.FOUR_DOTS_RECT\n        }),\n        ...(useCurrent && currentTool === Tool.RECTANGLE && currentCreateMethod === CVModel.OBJECT_DETECTION && {\n          rectType: RectType.RECOGNITION\n        }),\n        ...(useCurrent && currentTool === Tool.RECTANGLE && currentCreateMethod === CVModel.OBJECT_DETECTION_MULTI && {\n          rectType: RectType.RECOGNITION_MULTI\n        }),\n        ...(useCurrent && [Tool.LINE, Tool.ARROW].includes(currentTool) && currentCreateMethod === CVModel.SEGMENTATION && {\n          lineType: LineType.RECOGNITION\n        }),\n        ...(useCurrent && (currentTool === Tool.RECOGNITION || type === ShapeType.POLYGON && currentCreateMethod === CVModel.SEGMENTATION) && {\n          polygonType: PolygonType.RECOGNITION\n        }),\n        ...(useCurrent && type === ShapeType.POLYGON && currentCreateMethod === PolygonCreateMethod.RECT && {\n          polygonType: PolygonType.RECT\n        }),\n        ...(useCurrent && (currentToolItem === null || currentToolItem === void 0 ? void 0 : currentToolItem.edges) !== undefined && [Tool.POLYGON, Tool.LINE, Tool.ARROW].includes(currentTool) && {\n          defaultEdges: currentToolItem.edges\n        }),\n        ...(useCurrent && [ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW, ShapeType.CURVE, ShapeType.FLEX_LINE].includes(type) && {\n          dblclickFinish: !!this.rootStore.config.preferences.dblclickFinish\n        }),\n        ...(type === ShapeType.PIXEL && {\n          pixelType: this.rootStore.segmentation.currPixelType,\n          brushRadius: this.rootStore.segmentation.currBrushRadius,\n          showShapeBounds: !!this.rootStore.config.preferences.showPixelShapeBounds,\n          dblclickFinish: !!this.rootStore.config.preferences.dblclickFinish,\n          canPixelUpdate: this.rootStore.segmentation.canPixelUpdate\n        }),\n        ...(type === ShapeType.RECTANGLE && {\n          showAuxiliaryLines: !!this.rootStore.config.preferences.showShapeAuxiliaryLines\n        }),\n        ...(this.rootStore.config.viewMode === ViewMode.DEFAULT ? {\n          labelDom: this.createShapeLabel(camera),\n          scale: (_this$rootStore$frame = this.rootStore.frame.cameraViews[camera || this.rootStore.frame.currentCamera]) === null || _this$rootStore$frame === void 0 ? void 0 : _this$rootStore$frame.viewScale\n        } : {\n          scale: shapeContainer.scale.x // use shape container\n        }),\n        userDataFormatter: data => this.formatPointLabel(data, categoryName, categoryItemName),\n        ...([ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW].includes(type) && {\n          pointStyler: (pIndex, data, s) => this.getPointStyle(pIndex, data, s, categoryName, categoryItemName),\n          edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName)\n        }),\n        ...([ShapeType.RECTANGLE, ShapeType.SQUARE].includes(type) && {\n          edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName)\n        }),\n        ...([ShapeType.KEYPOINTS].includes(type) && {\n          pointStyler: (pointKey, data, s) => this.getPointStyle(pointKey, data, s, categoryName, categoryItemName)\n        })\n      });\n      // destroyed, not need to proceed\n      if (shape === null || shape === void 0 ? void 0 : shape.destroyed) {\n        return shape;\n      }\n      // add inspect label component\n      if (shape === null || shape === void 0 ? void 0 : shape.labelDom) {\n        ReactDOM.render(React.createElement(InspectLabel, {\n          shapeId: shape.uid\n        }), shape.labelDom.additionalContainer);\n      }\n      // update order, prefer to use given order\n      if (order !== undefined) {\n        shape.order = order;\n      } else if (useCurrent) {\n        shape.order = shape.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder();\n      }\n      // set default rotation for rectangle & ellipse\n      if (shapeData && (type === ShapeType.RECTANGLE || type === ShapeType.SQUARE || type === ShapeType.ELLIPSE)) {\n        shape.rotation = shapeData.rotation || 0;\n      }\n      // set default user data mode\n      shape.userDataMode = activePointAttributesMode;\n      // set default rotate mode\n      shape.rotateMode = shapeRotateMode;\n      // set default rotate handle mode\n      shape.rotateHandleMode = shapeRotateHandleMode;\n      // set curve discrete points visibility\n      if (shape instanceof Curve) {\n        shape.showDiscretePointsHint = this.showCurveDiscretePoints;\n      }\n      // FIXME: set show side ratio (customized for specific project)\n      if (shape.shapeType === ShapeType.POLYGON && this.showSideRatio) {\n        shape.showSideRatio = this.showSideRatio;\n      }\n      return shape;\n    };\n    /**\n     * validate shape\n     * @param shape\n     */\n    this.validateShape = shape => {\n      if (shape.area < this.rootStore.config.minArea && shape.shapeType !== ShapeType.PIXEL) {\n        if (shape.uid === this.cuttingShape) {\n          this.endShapeCutting();\n        }\n        const {\n          instanceItem\n        } = this.shapes[shape.uid] || {};\n        if (instanceItem) {\n          // related to instance, also update data\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n        } else {\n          // has not been related to any instance, just delete the shape\n          this.deleteShape(shape);\n        }\n        message.warning(i18n.translate('MIN_AREA_ALERT'));\n        return false;\n      }\n      return true;\n    };\n    /**\n     * select shapes\n     * @param shapes\n     */\n    this.selectShapes = shapes => {\n      if (this.selectedPointIndex >= 0) {\n        // has point selected\n        if (this.selectedShapes.length === 1 && shapes.length === 1 && this.selectedShapes[0] === shapes[0]) {\n          // same shape, do not unselect\n          return;\n        }\n        this.selectedPointIndex = -1;\n      }\n      let updatingShapeCurrentSelected = false;\n      let segShapeCurrentSelected = false;\n      this.selectedShapes.forEach(shape => {\n        if (shapes.indexOf(shape) < 0) {\n          // not selected any more\n          shape.selected = false;\n          if (shape.uid === this.updatingShape) {\n            updatingShapeCurrentSelected = true;\n          } else if (shape === this.rootStore.segmentation.updatingShape) {\n            segShapeCurrentSelected = true;\n          }\n          if (this.projectedShapes[shape.uid]) {\n            Object.values(this.projectedShapes[shape.uid]).forEach(projectedShape => {\n              projectedShape.selected = false;\n            });\n          }\n        }\n      });\n      this.selectedShapes = [...shapes];\n      let updatingShapeShouldSelected = false;\n      let segShapeShouldSelected = false;\n      this.selectedShapes.forEach(shape => {\n        shape.selected = true;\n        if (shape.uid === this.updatingShape) {\n          updatingShapeShouldSelected = true;\n        } else if (shape === this.rootStore.segmentation.updatingShape) {\n          segShapeShouldSelected = true;\n        }\n        const projectedShapes = this.projectedShapes[shape.uid];\n        if (projectedShapes) {\n          Object.keys(projectedShapes).forEach(projectCamera => {\n            const projectedShape = projectedShapes[projectCamera];\n            projectedShape.selected = true;\n            this.fitProjectShape(projectedShape, projectCamera);\n          });\n        }\n      });\n      if (updatingShapeCurrentSelected && !updatingShapeShouldSelected) {\n        this.finishUpdateShape();\n      }\n      if (segShapeCurrentSelected && !segShapeShouldSelected) {\n        this.rootStore.segmentation.cancelUpdate();\n      }\n      if (!segShapeCurrentSelected || !segShapeShouldSelected) {\n        this.rootStore.segmentation.cancelSwitch();\n      }\n    };\n    /**\n     * select shape by instance item\n     * @param instanceItem\n     * @param shouldPredict\n     */\n    this.selectShapeByInstanceItem = (instanceItem, shouldPredict = true) => {\n      const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...(instanceItem ? [instanceItem] : [])];\n      this.rootStore.instance.updateActiveLayerIndexByInstanceItems(instanceItems);\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        const shapes = this.getShapesByInstanceItems(instanceItems);\n        this.selectShapes(shapes);\n        const instancesSet = new Set(instanceItems.map(i => i.instance));\n        this.updateShapesInInstance(Array.from(instancesSet));\n        if (shouldPredict) {\n          this.predict();\n        }\n        this.hideOrShowOthers();\n      }\n    };\n    /**\n     * click to unselect shape\n     */\n    this.unselectShape = () => {\n      if (this.rootStore.config.addMode || this.rootStore.config.isWorkingOnAnyShape) {\n        return;\n      }\n      this.clearPendingWithAlert();\n      this.rootStore.cancelShapeWorking();\n      this.selectedShapes.forEach(shape => {\n        shape.selected = false;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.selected = false;\n        });\n      });\n      this.selectedShapes = [];\n      this.rootStore.instance.selectInstance(null);\n    };\n    /**\n     * set selected shape points\n     * @param shapePointsMap\n     */\n    this.setSelectedPoints = shapePointsMap => {\n      let count = 0;\n      Object.keys(shapePointsMap).forEach(shapeId => {\n        const {\n          shape\n        } = this.shapes[shapeId];\n        shape.setSelectedPoints(shapePointsMap[shapeId]);\n        count += shapePointsMap[shapeId].length;\n      });\n      if (count === 1) {\n        // point can be selected\n        this.selectedPointIndex = Object.values(shapePointsMap)[0][0];\n      }\n    };\n    /**\n     * set selected shapes\n     * @param shapeIds\n     */\n    this.setSelectedShapes = shapeIds => {\n      const shapeItems = Object.values(this.shapes).filter(({\n        shape\n      }) => shapeIds.indexOf(shape.uid) >= 0);\n      const instanceItems = shapeItems.map(({\n        instanceItem\n      }) => instanceItem);\n      this.rootStore.instance.selectInstanceItem(instanceItems);\n    };\n    /**\n     * update shape border color\n     * @param instance\n     */\n    this.updateShapesInInstance = instance => {\n      const instances = Array.isArray(instance) ? instance : [...(instance ? [instance] : [])];\n      Object.values(this.shapes).forEach(({\n        shape,\n        instanceItem\n      }) => {\n        if (instances.indexOf(instanceItem.instance) >= 0) {\n          shape.borderColor = 0xFFFF00;\n          if (shape.shapeType === ShapeType.DOT) {\n            shape.color = 0xFFFF00;\n          }\n        } else {\n          shape.borderColor = shape.originColors.borderColor;\n          if (shape.shapeType === ShapeType.DOT) {\n            shape.color = shape.originColors.color;\n          }\n        }\n      });\n    };\n    /**\n     * update shape line end point\n     * @param shape\n     * @param instanceItemId\n     * @param instanceId\n     */\n    this.updateLineEndPoint = (shape, instanceItemId, instanceId) => {\n      if ((shape === null || shape === void 0 ? void 0 : shape.shapeType) === ShapeType.LINE) {\n        const {\n          currentCamera,\n          currentFrame\n        } = this.rootStore.frame;\n        if (!this.previousLineEndPoint) {\n          this.previousLineEndPoint = {};\n        }\n        if (!this.previousLineEndPoint[currentCamera]) {\n          this.previousLineEndPoint[currentCamera] = {};\n        }\n        this.previousLineEndPoint[currentCamera][currentFrame] = {\n          instanceId,\n          instanceItemId\n        };\n      }\n    };\n    /**\n     * get shape line en point by\n     */\n    this.getLineEndPoint = () => {\n      var _this$previousLineEnd, _this$previousLineEnd2;\n      let endPoint;\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const lastPointInfo = (_this$previousLineEnd = this.previousLineEndPoint) === null || _this$previousLineEnd === void 0 ? void 0 : (_this$previousLineEnd2 = _this$previousLineEnd[currentCamera]) === null || _this$previousLineEnd2 === void 0 ? void 0 : _this$previousLineEnd2[currentFrame];\n      if (lastPointInfo) {\n        var _lastInstance$items;\n        const {\n          instanceId: lastInstanceId,\n          instanceItemId: lastInstanceItemId\n        } = lastPointInfo;\n        const lastInstance = this.rootStore.instance.getInstanceById(lastInstanceId);\n        const lastInstanceItem = lastInstance === null || lastInstance === void 0 ? void 0 : (_lastInstance$items = lastInstance.items) === null || _lastInstance$items === void 0 ? void 0 : _lastInstance$items[lastInstanceItemId];\n        if (lastInstanceItem) {\n          var _lastInstanceItem$cam, _lastInstanceItem$cam2, _lastInstanceItem$cam3;\n          const {\n            points: lastPoints\n          } = (_lastInstanceItem$cam = lastInstanceItem.cameras[currentCamera]) === null || _lastInstanceItem$cam === void 0 ? void 0 : (_lastInstanceItem$cam2 = _lastInstanceItem$cam.frames) === null || _lastInstanceItem$cam2 === void 0 ? void 0 : (_lastInstanceItem$cam3 = _lastInstanceItem$cam2[currentFrame]) === null || _lastInstanceItem$cam3 === void 0 ? void 0 : _lastInstanceItem$cam3.shape;\n          if (lastPoints && lastPoints.length > 0) {\n            endPoint = lastPoints[lastPoints.length - 1];\n          }\n        }\n      }\n      return endPoint;\n    };\n    /**\n     * click to draw a shape\n     * @param point\n     * @param event\n     */\n    this.addShape = (point, event) => {\n      if (this.rootStore.initialized && this.rootStore.config.addMode && !this.drawingShape) {\n        const {\n          selectedCategoryName,\n          selectedCategoryItemName\n        } = this.rootStore.ontology;\n        const instanceItem = this.rootStore.instance.getCurrentInstanceItem(undefined, undefined, false);\n        this.drawingShape = this.createShape(this.currentLayer, this.rootStore.frame.imageBounds, this.rootStore.ontology.selectedCategoryItem.displayColor, selectedCategoryName, selectedCategoryItemName, instanceItem);\n\n        // add listeners\n        this.drawingShape.on(EventAction.FINISHED, (shape, otherShapeData) => {\n          // remove listeners after creating\n          shape.off(EventAction.FINISHED);\n          shape.off(EventAction.REMOVED);\n          shape.off(EventAction.RECOGNITION);\n          this.drawingShape = null;\n          const creatingShapeColor = this.creatingShapeColor;\n          const isPixel = shape.shapeType === ShapeType.PIXEL;\n          const isKeypoints = shape.shapeType === ShapeType.KEYPOINTS;\n          const shouldContinue = this.rootStore.config.continuousMode && !isPixel && !isKeypoints;\n          if (!shouldContinue) {\n            this.rootStore.config.setAddMode(false, false);\n          }\n          if (this.validateShape(shape)) {\n            // add shape to instance item\n            this.addShapeToCurrentInstanceItem(shape, creatingShapeColor, otherShapeData);\n            tracker.report({\n              name: TrackEventName.CREATE_SHAPE,\n              elementName: shape.shapeType,\n              extra: shape.getData()\n            });\n          }\n          if (shouldContinue) {\n            shape.interactive = false;\n            if (this.rootStore.config.continuousModeType === ContinuousModeType.IN_INSTANCE) {\n              this.rootStore.ontology.selectNextCategoryItem();\n            }\n          }\n          if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n            if (isPixel) {\n              // switch to update mode when in default view after create\n              this.rootStore.segmentation.updateShape(shape);\n            } else if (isKeypoints) {\n              this.startUpdateShape(false);\n            }\n          } else {\n            shape.destroy();\n          }\n          // finish creating\n          // if (finishCallback) {\n          //   finishCallback();\n          // }\n        });\n        this.drawingShape.on(EventAction.REMOVED, () => {\n          this.drawingShape = null;\n          if (this.recognitionStart && !this.rootStore.config.continuousMode) {\n            // if recognition shape removed, should set add mode to false\n            this.rootStore.config.setAddMode(false);\n          }\n        });\n        this.drawingShape.on(EventAction.RECOGNITION, (s, data) => this.onRecognize(s, data.controls));\n        const {\n          currentOptions\n        } = this.rootStore.ontology;\n        const {\n          lineContinuous\n        } = this.rootStore.shape;\n        if (lineContinuous && this.drawingShape.shapeType === ShapeType.LINE) {\n          const endPoint = this.getLineEndPoint();\n          if (endPoint) {\n            const {\n              x,\n              y\n            } = endPoint;\n            const newPoint = new Point(x, y);\n            this.drawingShape.create(newPoint, currentOptions, event);\n            return this.drawingShape;\n          }\n          this.drawingShape.create(undefined, currentOptions, event);\n          return this.drawingShape;\n        }\n        // start create\n        this.drawingShape.create(this.drawingShape.shapeType === ShapeType.LINE || this.drawingShape.shapeType === ShapeType.ARROW ? undefined : point, this.drawingShape.shapeType === ShapeType.KEYPOINTS ? {\n          selectedPointKey: this.selectedPointIndex\n        } : currentOptions, event);\n        return this.drawingShape;\n      }\n      return null;\n    };\n    /**\n     * add shape to current instance item\n     * @param shape\n     */\n    this.addShapeToCurrentInstanceItem = (shape, shapeColor, otherShapeData) => {\n      var _this$rootStore$nifti;\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem();\n      const data = shape.getData();\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      instanceItem.setShapeColorConifg({\n        fillColor: shape.fillColor,\n        edgeColor: shape.borderColor,\n        pointColor: shape.vertexColor,\n        color: shapeColor || instanceItem.colorConfig.color\n      });\n      this.creatingShapeColor = '';\n      const {\n        autoInterpolation,\n        activeLayerIndex\n      } = this.rootStore.config;\n      const {\n        prevState: prevStateItem,\n        currState: currStateItem\n      } = instanceItem.addShape(currentCamera, currentFrame, autoInterpolation && shape.shapeType !== ShapeType.PIXEL, shape.shapeType, data, activeLayerIndex, shape.order, this.rootStore.ontology.isOCRTool, this.rootStore.ontology.isFormulaTool);\n      this.updateLineEndPoint(shape, instanceItem.id, instanceItem.instance.id);\n      const basicInfo = instanceItem.instance.getBasicInfo();\n      const attributes = instanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n      const instanceState = {\n        [prevBasicInfo.id]: {\n          prev: {\n            ...prevBasicInfo,\n            children: prevStateItem ? [prevStateItem] : []\n          },\n          curr: {\n            ...basicInfo,\n            children: currStateItem ? [currStateItem] : []\n          }\n        }\n      };\n      const relationshipState = {\n        prev: [],\n        curr: []\n      };\n      if (otherShapeData) {\n        otherShapeData.forEach(shapeData => {\n          var _otherInstanceItem$ca;\n          const otherInstanceItem = this.rootStore.instance.getCurrentInstanceItem();\n          const prevInfo = otherInstanceItem.instance.getBasicInfo();\n          if (otherInstanceItem.instance !== instanceItem.instance) {\n            otherInstanceItem.instance.setAttributes(instanceItem.instance.attributes);\n          }\n          const {\n            layer = activeLayerIndex\n          } = ((_otherInstanceItem$ca = otherInstanceItem.cameras[currentCamera]) === null || _otherInstanceItem$ca === void 0 ? void 0 : _otherInstanceItem$ca.frames[currentFrame]) || {};\n          const {\n            prevState,\n            currState\n          } = otherInstanceItem.updateShape(currentCamera, currentFrame, autoInterpolation && shape.shapeType !== ShapeType.PIXEL, shape.shapeType, shapeData, layer, shape.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer), attributes);\n          this.setupShape(otherInstanceItem);\n          const currInfo = otherInstanceItem.instance.getBasicInfo();\n          if (!instanceState[currInfo.id]) {\n            instanceState[currInfo.id] = {\n              prev: {\n                ...prevInfo,\n                children: []\n              },\n              curr: {\n                ...currInfo,\n                children: []\n              }\n            };\n          }\n          const state = instanceState[currInfo.id];\n          if (prevState) {\n            state.prev.children.push(prevState);\n          }\n          if (currState) {\n            state.curr.children.push(currState);\n          }\n        });\n      }\n\n      // update segmentation store\n      if (shape.shapeType === ShapeType.PIXEL) {\n        const stat = this.rootStore.segmentation.update(instanceItem, activeLayerIndex, shape);\n        if (stat) {\n          Object.keys(stat.instanceState).forEach(id => {\n            if (instanceState[id]) {\n              const {\n                prev,\n                curr\n              } = stat.instanceState[id];\n              instanceState[id].prev.children = [...instanceState[id].prev.children, ...prev.children];\n              instanceState[id].curr.children = [...instanceState[id].curr.children, ...curr.children];\n            } else {\n              instanceState[id] = stat.instanceState[id];\n            }\n          });\n          relationshipState.prev = stat.relationshipState.prev;\n          relationshipState.curr = stat.relationshipState.curr;\n        }\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(instanceState).map(i => i.prev).filter(i => i.children.length > 0),\n        relationships: relationshipState.prev\n      }, {\n        instances: Object.values(instanceState).map(i => i.curr),\n        relationships: relationshipState.curr\n      });\n\n      // update shape instance\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        shape.label = instanceItem.label;\n        this.setShapeStyles(shape, instanceItem);\n        this.addShapeListeners(shape);\n        this.shapes[shape.uid] = {\n          shape,\n          camera: currentCamera,\n          instanceItem\n        };\n      }\n\n      // select\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n      // project\n      this.projectShape(shape);\n\n      // 更新nifti store中相应图形的体素信息\n      (_this$rootStore$nifti = this.rootStore.nifti) === null || _this$rootStore$nifti === void 0 ? void 0 : _this$rootStore$nifti.updateShape(instanceItem);\n    };\n    /**\n     * add predicted shape to instance item\n     * @param instanceItem\n     * @param camera\n     */\n    this.addShapeToInstanceItem = (instanceItem, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentCamera,\n        currentFrame,\n        cameraViews,\n        getImageBoundsForCamera\n      } = this.rootStore.frame;\n      const currentCameraView = cameraViews[camera];\n      const imageBounds = getImageBoundsForCamera(camera, currentFrame);\n      if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n        return;\n      }\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame]) {\n        return;\n      }\n      let shapeInfo;\n      const predictedItem = Object.values(this.predictedShapes).find(i => i.instanceItem === instanceItem);\n      if (camera === currentCamera && predictedItem) {\n        // predicted shape in current camera exists, use it\n        const {\n          shape\n        } = predictedItem;\n        shapeInfo = {\n          shapeType: shape.shapeType,\n          shape: shape.getData()\n        };\n        // remove predicted shape\n        shape.destroy();\n        delete this.predictedShapes[shape.uid];\n      } else {\n        shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n      }\n      if (shapeInfo) {\n        if (shapeInfo.shapeType === ShapeType.PIXEL) {\n          // resolve pixel\n          const newData = this.rootStore.segmentation.resolvePixelShapeData(shapeInfo.shape);\n          if (!newData) {\n            return;\n          }\n          shapeInfo.shape = newData;\n        } else {\n          const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n          if (area < this.rootStore.config.minArea) {\n            message.warning(i18n.translate('MIN_AREA_ALERT'));\n            return;\n          }\n        }\n        // add to model\n        const {\n          activeLayerIndex\n        } = this.rootStore.config;\n        this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, shapeInfo.shapeType, shapeInfo.shape, activeLayerIndex, shapeInfo.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(activeLayerIndex, currentFrame, camera), camera);\n        // create shape\n        this.setupShape(instanceItem, camera, currentCameraView.activeShapesLayer, imageBounds);\n        this.updateShapesRefreshCounter();\n        // set camera\n        if (currentCamera !== camera) {\n          this.rootStore.frame.setCamera(camera);\n        }\n        // select\n        this.rootStore.instance.selectInstanceItem(instanceItem);\n        this.rootStore.instance.autoOpenAttributesModal();\n      }\n    };\n    /**\n     * add all predicted shapes to instances\n     * @param instances\n     */\n    this.addShapesToInstances = instances => {\n      let instanceItems = [];\n      for (let index = 0; index < instances.length; index += 1) {\n        const instance = instances[index];\n        const {\n          existedCameras\n        } = instance;\n        for (let i = 0; i < existedCameras.length; i += 1) {\n          const camera = existedCameras[i];\n          const currentCameraView = this.rootStore.frame.cameraViews[camera];\n          if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n            return;\n          }\n          const newInstanceItems = this.generateInstanceItemsFromPredict(instance, currentCameraView.activeShapesLayer, camera);\n          instanceItems = instanceItems.concat(newInstanceItems);\n        }\n      }\n      if (instanceItems.length > 0) {\n        // update model\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n        instanceItems.forEach(({\n          instanceItem,\n          camera,\n          imageBounds,\n          activeShapesLayer\n        }) => {\n          this.setupShape(instanceItem, camera, activeShapesLayer, imageBounds);\n        });\n      }\n    };\n    /**\n     * add predicted shapes to instance\n     * @param instance\n     * @param camera\n     */\n    this.addShapesToInstance = (instance, camera = this.rootStore.frame.currentCamera) => {\n      const currentCameraView = this.rootStore.frame.cameraViews[camera];\n      if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n        return;\n      }\n      const instanceItems = this.generateInstanceItemsFromPredict(instance, currentCameraView.activeShapesLayer);\n      if (instanceItems.length > 0) {\n        // update model\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n        // setup shapes\n        instanceItems.forEach(({\n          instanceItem,\n          imageBounds,\n          activeShapesLayer\n        }) => {\n          this.setupShape(instanceItem, camera, activeShapesLayer, imageBounds);\n        });\n        // select\n        this.rootStore.instance.selectInstanceItem(null);\n        this.rootStore.instance.selectInstance(instance);\n        this.rootStore.instance.autoOpenAttributesModal();\n      }\n    };\n    /**\n     * generate instanceItems by predicted shapes\n     * @param instance\n     * @param activeShapesLayer\n     * @param camera\n     */\n    this.generateInstanceItemsFromPredict = (instance, activeShapesLayer, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentFrame,\n        getImageBoundsForCamera,\n        getNextShapeOrder\n      } = this.rootStore.frame;\n      const imageBounds = getImageBoundsForCamera(camera, currentFrame);\n      const {\n        activeLayerIndex\n      } = this.rootStore.config;\n      const instanceItems = [];\n      Object.values(instance.items).forEach(instanceItem => {\n        const cameraData = instanceItem.cameras[camera];\n        if (!cameraData || !cameraData.frames[currentFrame]) {\n          // not exist in current frame\n          let shapeInfo;\n          const predictedItem = Object.values(this.predictedShapes).find(i => i.instanceItem === instanceItem);\n          if (predictedItem) {\n            // predicted shape in current camera exists, use it\n            const {\n              shape\n            } = predictedItem;\n            shapeInfo = {\n              shapeType: shape.shapeType,\n              shape: shape.getData()\n            };\n            // remove predicted shape\n            shape.destroy();\n            delete this.predictedShapes[shape.uid];\n          } else {\n            shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n          }\n          if (shapeInfo) {\n            if (shapeInfo.shapeType === ShapeType.PIXEL) {\n              // resolve pixel\n              const newData = this.rootStore.segmentation.resolvePixelShapeData(shapeInfo.shape);\n              if (!newData) {\n                return;\n              }\n              shapeInfo.shape = newData;\n            } else {\n              const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n              if (area < this.rootStore.config.minArea) {\n                return;\n              }\n            }\n            instanceItems.push({\n              imageBounds,\n              activeShapesLayer,\n              instanceItem,\n              frameIndex: currentFrame,\n              layer: activeLayerIndex,\n              order: shapeInfo.shapeType === ShapeType.PIXEL ? 0 : getNextShapeOrder(activeLayerIndex, currentFrame, camera),\n              camera,\n              ...shapeInfo\n            });\n          }\n        }\n      });\n      return instanceItems;\n    };\n    /**\n     * setup shape in current camera & current frame\n     * @param instanceItem\n     * @param shapeContainer\n     * @param imageBounds\n     */\n    this.setupShape = (instanceItem, camera = this.rootStore.frame.currentCamera, shapeContainer, imageBounds) => {\n      const {\n        cameraViews,\n        currentFrame\n      } = this.rootStore.frame;\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData) {\n        const frameData = cameraData.frames[currentFrame];\n        if (frameData) {\n          var _cameraViews$camera;\n          // remove shape if already exists\n          const existingShape = this.getShapeByInstanceItem(instanceItem, camera);\n          const {\n            interactive: originInteractive = true\n          } = existingShape || {};\n          const existingShapeId = existingShape === null || existingShape === void 0 ? void 0 : existingShape.uid;\n          if (existingShape) {\n            this.deleteShape(existingShape);\n          }\n          // add shape\n          if (!((_cameraViews$camera = cameraViews[camera]) === null || _cameraViews$camera === void 0 ? void 0 : _cameraViews$camera.imageLoadError)) {\n            const {\n              layer = this.rootStore.config.activeLayerIndex\n            } = frameData;\n            let order;\n            if (frameData.order !== undefined) {\n              order = frameData.order;\n            } else {\n              order = frameData.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer, currentFrame, camera);\n            }\n            const shape = this.createShape(shapeContainer || cameraViews[camera].getShapesLayerByIndex(layer), imageBounds || this.rootStore.frame.getImageBoundsForCamera(camera, currentFrame), instanceItem.colorConfig.color, instanceItem.instance.category, instanceItem.name, instanceItem, frameData.shapeType, frameData.shape, order, instanceItem.label, camera);\n            instanceItem.setShapeColorConifg({\n              fillColor: shape.fillColor,\n              edgeColor: shape.borderColor,\n              pointColor: shape.vertexColor,\n              color: instanceItem.colorConfig.color\n            });\n            this.updateLineEndPoint(shape, instanceItem.id, instanceItem.instance.id);\n            if (shape.destroyed) {\n              // delete instance item\n              this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame, camera);\n              return;\n            }\n            shape.interactive = originInteractive && !this.rootStore.config.measureMode;\n            shape.editable = !this.rootStore.readonly && !frameData.locked;\n            if (frameData.isPreAnnotation) {\n              var _shape$labelDom2;\n              (_shape$labelDom2 = shape.labelDom) === null || _shape$labelDom2 === void 0 ? void 0 : _shape$labelDom2.setPrefix(createLabelPrefix());\n            }\n            this.setShapeStyles(shape, instanceItem, camera);\n            this.addShapeListeners(shape);\n            this.shapes[shape.uid] = {\n              shape,\n              camera,\n              instanceItem\n            };\n            this.rootStore.relationship.setupConnectionsForInstanceItem(instanceItem);\n            if (this.pendingMergePolygon === existingShapeId) {\n              this.pendingMergePolygon = shape.uid;\n            }\n            if (this.pendingMergeLine && this.pendingMergeLine.id === existingShapeId) {\n              this.pendingMergeLine.id = shape.uid;\n            }\n            if (this.cuttingShape === existingShapeId) {\n              this.cuttingShape = shape.uid;\n            }\n            if (this.splittingShape === existingShapeId) {\n              this.splittingShape = shape.uid;\n            }\n            if (this.appendingShape === existingShapeId) {\n              this.appendingShape = shape.uid;\n            }\n            if (this.updatingShape === existingShapeId) {\n              this.updatingShape = shape.uid;\n            }\n            this.projectShape(shape, camera);\n          }\n        }\n      }\n    };\n    /**\n     * predict in current camera & current frame\n     */\n    this.predict = async () => {\n      if (Object.keys(this.predictedShapes).length > 0) {\n        this.updateShapesRefreshCounter();\n      }\n      this.clearPredictedShapes();\n      if (!this.rootStore.config.autoTracking || this.rootStore.readonly || this.rootStore.config.viewMode === ViewMode.GRID || this.rootStore.filter.filterMode // no to predict in filter mode\n      ) {\n        return;\n      }\n      const {\n        isMultiSelected,\n        selectedInstances,\n        selectedInstanceItems\n      } = this.rootStore.instance;\n      if (isMultiSelected) {\n        return;\n      }\n      if (selectedInstances.length === 1) {\n        const {\n          currentCamera,\n          currentFrame,\n          currentCameraView,\n          imageBounds\n        } = this.rootStore.frame;\n        if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n          return;\n        }\n        const selectedInstance = selectedInstances[0];\n        const {\n          predictiveMode\n        } = this.rootStore.config;\n        if (predictiveMode === PredictiveMode.NONE) {\n          return;\n        }\n        const predictInstance = predictiveMode === PredictiveMode.SELECTED_INSTANCE || selectedInstanceItems.length === 0;\n        const predictiveItems = predictInstance ? Object.values(selectedInstance.items) : selectedInstanceItems;\n        const segmentPredictiveItems = [];\n        predictiveItems.forEach(item => {\n          const shapeInfo = item.predictShape(currentCamera, currentFrame, imageBounds);\n          if ((shapeInfo === null || shapeInfo === void 0 ? void 0 : shapeInfo.shapeType) === ShapeType.PIXEL || (shapeInfo === null || shapeInfo === void 0 ? void 0 : shapeInfo.shapeType) === ShapeType.POLYGON) {\n            segmentPredictiveItems.push(item);\n          } else if (shapeInfo) {\n            // create predict shape\n            this.createPredictedShape(item, shapeInfo.shapeType, shapeInfo.shape);\n          }\n        });\n        // 非物体预测模式下，或当前帧没有色块，才执行分割预测（不然预测图形可能会和现有图形重叠，出现问题）\n        const segmentPredict = !predictInstance || !predictiveItems.some(item => {\n          var _item$cameras$current, _item$cameras$current2;\n          return ((_item$cameras$current = item.cameras[currentCamera]) === null || _item$cameras$current === void 0 ? void 0 : (_item$cameras$current2 = _item$cameras$current.frames[currentFrame]) === null || _item$cameras$current2 === void 0 ? void 0 : _item$cameras$current2.shapeType) === ShapeType.PIXEL;\n        });\n        if (segmentPredict) {\n          await this.predictShapeByModel(segmentPredictiveItems);\n        }\n        this.updateShapesRefreshCounter();\n      }\n    };\n    /**\n     * delete selected shape point or instance\n     */\n    this.delete = () => {\n      const selectedShape = this.rootStore.segmentation.getSelectedShape();\n      const pixelSegDeleted = (selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.editable) && selectedShape.deleteSelectedPolygon();\n      if (pixelSegDeleted) {\n        return;\n      }\n      if (selectedShape) {\n        selectedShape.selectedPolygonIndex = -1;\n      }\n      if (this.selectedShapes.length > 0) {\n        this.deleting = true;\n        this.selectedPointIndex = -1;\n        const pointsDeletedShapes = [];\n        this.selectedShapes.forEach(shape => {\n          const deleted = shape.deleteSelectedPoints();\n          if (deleted) {\n            pointsDeletedShapes.push(shape);\n          }\n        });\n        const {\n          currentFrame\n        } = this.rootStore.frame;\n        if (pointsDeletedShapes.length > 0) {\n          // has points deleted shapes\n          const instanceItems = [];\n          pointsDeletedShapes.forEach(shape => {\n            const shapeItem = this.shapes[shape.uid];\n            if (shapeItem) {\n              instanceItems.push({\n                instanceItem: shapeItem.instanceItem,\n                frameIndex: currentFrame,\n                shapeType: shape.shapeType,\n                shape: shape.destroyed ? undefined : shape.getData()\n              });\n              if (shape.destroyed) {\n                this.deleteShape(shape);\n              } else {\n                this.projectShape(shape);\n              }\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n        } else {\n          // should delete shapes\n          const instanceItems = [];\n          this.selectedShapes.forEach(shape => {\n            const shapeItem = this.shapes[shape.uid];\n            if (shapeItem) {\n              const {\n                instanceItem\n              } = shapeItem;\n              instanceItems.push({\n                instanceItem,\n                frames: [currentFrame]\n              });\n            }\n          });\n          this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);\n          this.rootStore.filter.filterInstances();\n          this.predict();\n        }\n      }\n      this.deleting = false;\n    };\n    /**\n     * delete shape instance\n     * @param shape\n     */\n    this.deleteShape = shape => {\n      const index = this.selectedShapes.indexOf(shape);\n      if (index >= 0) {\n        this.selectedShapes.splice(index, 1);\n      }\n      shape.destroy();\n      delete this.shapes[shape.uid];\n      if (this.projectedShapes[shape.uid]) {\n        Object.values(this.projectedShapes[shape.uid]).forEach(s => {\n          s.destroy();\n        });\n        delete this.projectedShapes[shape.uid];\n      }\n    };\n    /**\n     * delete shape by instance item\n     * @param instanceItem\n     */\n    this.deleteShapeByInstanceItem = instanceItem => {\n      const shape = this.getShapeByInstanceItem(instanceItem);\n      if (shape) {\n        this.deleteShape(shape);\n      }\n    };\n    // imageSegmentation(url: string, clicks: string, prevMask = '[]', imageRotation = 0) {\n    //   const formData = new FormData();\n    //   formData.append('url', url);\n    //   formData.append('clicks', clicks);\n    //   formData.append('prev_mask', prevMask);\n    //   formData.append('rotation', `${imageRotation}`);\n    //   const fetchPromise = new Promise<{ x: number; y: number }[][]>((resolve, reject) => {\n    //     this.rootStore.jobProxy?.forwardAPI(APIForwardType.INTERACTIVE_SEGMENTATION, formData)\n    //       .then((res) => {\n    //         if (res.status === 200) {\n    //           return res;\n    //         }\n    //         throw new Error('Request failed.');\n    //       })\n    //       .then((res) => {\n    //         const { data } = res;\n    //         if (!Array.isArray(data) || data.some((d) => !Array.isArray(d))) {\n    //           throw new Error('Invalid result.');\n    //         }\n    //         resolve(data);\n    //       })\n    //       .catch((e) => reject(e));\n    //   });\n    //   const timeoutPromise = new Promise<{ x: number; y: number }[][]>((_, reject) => {\n    //     setTimeout(() => reject(), 8000);\n    //   });\n    //   return Promise.race([fetchPromise, timeoutPromise]);\n    // }\n    /**\n     * on recognize\n     * @param shape\n     * @param controls\n     */\n    this.onRecognize = (shape, controls) => {\n      const recognitionStart = this.recognitionStart === false;\n      if (shape.shapeType === ShapeType.PIXEL) {\n        this.rootStore.config.setCursor(shape.currCursor);\n      } else {\n        this.rootStore.config.setCursor(Cursor.DEFAULT); // use default cursor, not crosshair\n      }\n      // do recognition\n      this.recognitionStart = true;\n      this.requestRecognition(shape, controls, recognitionStart);\n    };\n    /**\n     * request recognition\n     * @param shape\n     * @param controls\n     * @param recognitionStart\n     */\n    this.requestRecognition = async (shape, controls, recognitionStart) => {\n      this.rootStore.frame.loading = true;\n      setTimeout(async () => {\n        if (recognitionStart) {\n          this.setupRecognizer();\n          await this.loadImageForRecognizer();\n        }\n        try {\n          if (shape.shapeType === ShapeType.RECTANGLE) {\n            // object detection\n            if (controls.length === 0) {\n              throw new Error('Invalid control points');\n            }\n            const {\n              left,\n              top,\n              right,\n              bottom\n            } = this.rootStore.frame.imageBounds;\n            const rSize = {\n              left,\n              top,\n              right,\n              bottom\n            };\n            const [p1, p2] = controls;\n            if (p1 && p2) {\n              rSize.left = Math.max(Math.min(p1.x, p2.x), left);\n              rSize.top = Math.max(Math.min(p1.y, p2.y), top);\n              rSize.right = Math.min(Math.max(p1.x, p2.x), right);\n              rSize.bottom = Math.min(Math.max(p1.y, p2.y), bottom);\n            } else {\n              const width = right - left;\n              const height = bottom - top;\n              rSize.left = Math.max(p1.x - width / 4, left);\n              rSize.top = Math.max(p1.y - height / 4, top);\n              rSize.right = Math.min(p1.x + width / 4, right);\n              rSize.bottom = Math.min(p1.y + height / 4, bottom);\n            }\n            const recognizedBoxes = await this.recognizer.detect(rSize);\n            if (this.rootStore.ontology.currentCreateMethod === CVModel.OBJECT_DETECTION_MULTI) {\n              this.finishMultiObjectsDetection(recognizedBoxes);\n            } else {\n              let recognizedBox;\n              let recognizedDis2;\n              for (let i = 0; i < recognizedBoxes.length; i += 1) {\n                const box = recognizedBoxes[i];\n                // check box contains p1\n                if (!p2 && (p1.x < box.left || p1.x > box.right || p1.y < box.top || p1.y > box.bottom)) {\n                  // eslint-disable-next-line no-continue\n                  continue;\n                }\n                const dis2 = ((box.left + box.right) / 2 - p1.x) ** 2 + ((box.top + box.bottom) / 2 - p1.y) ** 2;\n                if (recognizedDis2 === undefined || dis2 < recognizedDis2) {\n                  recognizedDis2 = dis2;\n                  recognizedBox = box;\n                }\n              }\n              if (!recognizedBox) {\n                throw new Error('No valid recognized boxes');\n              }\n              shape.finishRecognition(recognizedBox);\n            }\n          } else {\n            // segmentation\n            const isPixel = shape.shapeType === ShapeType.PIXEL;\n            const recognizedPixels = await this.recognizer.segment(controls, isPixel && !shape.pixelsData.isEmpty && shape.pixelsData, !isPixel);\n            if (!isPixel) {\n              shape.setRecognizedPolygon(recognizedPixels.cachedPolygons);\n            } else {\n              shape.finishRecognition(recognizedPixels.pixels);\n            }\n          }\n        } catch (e) {\n          message.error(i18n.translate('RECOGNITION_FAIL'));\n          if (shape.shapeType === ShapeType.RECTANGLE) {\n            this.rootStore.config.setAddMode(false);\n          }\n        }\n        this.rootStore.frame.loading = false;\n      }, 10);\n    };\n    /**\n     * finish recognition\n     */\n    this.finishRecognition = () => {\n      if (this.recognitionStart) {\n        this.drawingShape.finishCreate();\n      }\n    };\n    /**\n     * finish multii objects detection\n     * @param boxes\n     */\n    this.finishMultiObjectsDetection = boxes => {\n      // preserve color\n      const fillColor = this.drawingShape.fillColor;\n      const edgeColor = this.drawingShape.borderColor;\n      const pointColor = this.drawingShape.vertexColor;\n      const color = this.creatingShapeColor;\n      // set add mode to false\n      this.rootStore.config.setAddMode(false);\n      const {\n        currentCamera,\n        currentFrame,\n        getNextShapeOrder\n      } = this.rootStore.frame;\n      const {\n        autoInterpolation,\n        activeLayerIndex\n      } = this.rootStore.config;\n      const {\n        selectInstanceItem\n      } = this.rootStore.instance;\n      const prevInstanceMap = {};\n      const currInstanceMap = {};\n      const affectedInstanceItems = {};\n      boxes.forEach((box, i) => {\n        const data = {\n          x: this.precise(box.left),\n          y: this.precise(box.top),\n          width: this.precise(box.right - box.left),\n          height: this.precise(box.bottom - box.top),\n          area: 0,\n          points: [{\n            x: this.precise(box.left),\n            y: this.precise(box.top)\n          }, {\n            x: this.precise(box.right),\n            y: this.precise(box.top)\n          }, {\n            x: this.precise(box.right),\n            y: this.precise(box.bottom)\n          }, {\n            x: this.precise(box.left),\n            y: this.precise(box.bottom)\n          }]\n        };\n        data.area = calcShapeArea(ShapeType.RECTANGLE, data);\n        const instanceItem = this.rootStore.instance.getCurrentInstanceItem();\n        if (i === 0) {\n          // use last creating shape color\n          instanceItem.setShapeColorConifg({\n            fillColor,\n            edgeColor,\n            pointColor,\n            color: color || instanceItem.colorConfig.color\n          });\n        }\n        const {\n          prevState,\n          currState\n        } = instanceItem.addShape(currentCamera, currentFrame, autoInterpolation, ShapeType.RECTANGLE, data, activeLayerIndex, getNextShapeOrder(), false, false);\n        if (prevState) {\n          if (!prevInstanceMap[instanceItem.instance.id]) {\n            prevInstanceMap[instanceItem.instance.id] = {\n              ...instanceItem.instance.getBasicInfo(),\n              children: []\n            };\n          }\n          prevInstanceMap[instanceItem.instance.id].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceItem.instance.id]) {\n            currInstanceMap[instanceItem.instance.id] = {\n              ...instanceItem.instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instanceItem.instance.id].children.push(currState);\n        }\n        affectedInstanceItems[instanceItem.id] = instanceItem;\n        this.setupShape(instanceItem);\n        selectInstanceItem(instanceItem);\n      });\n      const items = Object.values(affectedInstanceItems);\n      if (items.length > 0) {\n        this.rootStore.undo.push({\n          instances: Object.values(prevInstanceMap)\n        }, {\n          instances: Object.values(currInstanceMap)\n        });\n        this.rootStore.instance.openAttributesModalForInstanceItems(items);\n      }\n    };\n    /**\n     * set points user data for shape by hotkey\n     * @param shape\n     * @param hotkey\n     */\n    this.setPointsUserDataByHotkey = (shape, hotkey) => {\n      if (shape instanceof Polygon || shape instanceof Line || shape instanceof QuadPrism || shape instanceof OrientedQuadPrism || shape instanceof Keypoints) {\n        const hotkeyItems = this.rootStore.config.pointHotkeyMap[hotkey] || [];\n        const selectedPoints = shape.getSelectedPoints();\n        if (hotkeyItems.length > 0 && selectedPoints.length > 0) {\n          const pointsData = [];\n          selectedPoints.forEach(({\n            index,\n            point\n          }) => {\n            let userData = {\n              ...point.userData\n            };\n            hotkeyItems.forEach(({\n              type,\n              attributes\n            }) => {\n              userData = type === 'overwrite' ? {\n                ...attributes\n              } : {\n                ...userData,\n                ...attributes\n              };\n            });\n            pointsData.push({\n              index,\n              userData\n            });\n          });\n          shape.setPointsUserData(pointsData);\n        }\n      }\n    };\n    /**\n     * set points user data for shape\n     * @param shape\n     * @param pointIndex\n     * @param userData\n     */\n    this.setPointUserData = (shape, pointIndex, userData) => {\n      if (shape instanceof Polygon || shape instanceof Line || shape instanceof QuadPrism || shape instanceof OrientedQuadPrism || shape instanceof Keypoints) {\n        const pointsData = [{\n          index: pointIndex,\n          userData\n        }];\n        shape.setPointsUserData(pointsData);\n      }\n    };\n    /**\n     * move selected shape to front\n     * @param toTop\n     */\n    this.moveFront = (toTop = false) => {\n      if (this.selectedShapes.length === 1) {\n        const selectedShape = this.selectedShapes[0];\n        if (!selectedShape.editable) {\n          return;\n        }\n        if (toTop) {\n          this.moveToTop(this.shapes[selectedShape.uid].instanceItem);\n          return;\n        }\n        const intersections = this.getIntersectionsForShape(selectedShape);\n        if (intersections.length > 0) {\n          const upperShape = getUpperShape(selectedShape, intersections);\n          if (upperShape) {\n            this.exchangeShapeOrder(selectedShape, upperShape);\n            message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_FRONT_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    };\n    /**\n     * move selected shape to back\n     * @param toBottom\n     */\n    this.moveBack = (toBottom = false) => {\n      if (this.selectedShapes.length === 1) {\n        const selectedShape = this.selectedShapes[0];\n        if (!selectedShape.editable) {\n          return;\n        }\n        if (toBottom) {\n          this.moveToBottom(this.shapes[selectedShape.uid].instanceItem);\n          return;\n        }\n        const intersections = this.getIntersectionsForShape(selectedShape);\n        if (intersections.length > 0) {\n          const underShape = getUnderShape(selectedShape, intersections);\n          if (underShape) {\n            this.exchangeShapeOrder(selectedShape, underShape);\n            message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_BACK_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    };\n    this.clearPendingWithAlert = () => {\n      if (this.pendingMergePolygon || this.pendingMergeLine || this.pendingMergePixel) {\n        message.info(i18n.translate('MERGE_CANCEL'));\n      }\n      this.clearPending();\n    };\n    this.clearPending = () => {\n      this.pendingMergePolygon = '';\n      this.pendingMergePixel = null;\n      this.clearPendingLine();\n    };\n    this.clearPendingLine = () => {\n      if (this.pendingMergeLine) {\n        Object.values(this.shapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Line) {\n            shape.hoverMode = HoverMode.DEFAULT;\n          }\n        });\n      }\n      this.pendingMergeLine = null;\n    };\n    this.merge = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || this.selectedShapes.length !== 1 || this.rootStore.segmentation.updatingShape) {\n        return;\n      }\n      const selectedShape = this.selectedShapes[0];\n      if (!selectedShape.editable) {\n        return;\n      }\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      const {\n        shapeType\n      } = selectedShape;\n      if (shapeType === ShapeType.POLYGON) {\n        // merge polygon\n        this.endShapeCutting(); // cancel cutting\n        const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera, true).map(i => i.shape);\n        const intersectPolygonIds = selectedShape.findIntersectPolygons(shapes);\n        if (intersectPolygonIds.length === 1) {\n          this.mergePolygons(selectedShape.uid, intersectPolygonIds[0]);\n        } else if (intersectPolygonIds.length === 0) {\n          message.warn(i18n.translate('MERGE_NO_INTERSECT'));\n        } else {\n          this.pendingMergePolygon = selectedShape.uid;\n          message.info(i18n.translate('MERGE_SELECT_NEXT'));\n        }\n      } else if (shapeType === ShapeType.LINE || shapeType === ShapeType.ARROW) {\n        const {\n          points\n        } = selectedShape;\n        if (this.selectedPointIndex === 0 || this.selectedPointIndex === points.length - 1) {\n          // merge line\n          this.pendingMergeLine = {\n            id: selectedShape.uid,\n            index: this.selectedPointIndex\n          };\n          message.info(i18n.translate('MERGE_SELECT_NEXT_LINE'));\n          this.getShapesForCamera(this.rootStore.frame.currentCamera, true).forEach(({\n            shape\n          }) => {\n            if (shape.uid !== selectedShape.uid && (shape.shapeType === ShapeType.LINE || shape.shapeType === ShapeType.ARROW)) {\n              shape.hoverMode = HoverMode.ENDPOINT;\n            }\n          });\n        }\n      } else if (shapeType === ShapeType.PIXEL) {\n        this.endShapeCutting();\n        this.pendingMergePixel = {\n          id: selectedShape.uid,\n          index: this.rootStore.segmentation.selectedSegmentIndex\n        };\n        message.info(i18n.translate('MERGE_SELECT_NEXT_PIXEL'));\n      }\n    };\n    this.subtractPolygon = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || this.selectedShapes.length !== 1 || this.selectedShapes[0].shapeType !== ShapeType.POLYGON) {\n        return;\n      }\n      const selectedPolygon = this.selectedShapes[0];\n      if (!selectedPolygon.editable) {\n        return;\n      }\n      this.rootStore.cancelShapeWorking();\n      const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i => i.shape);\n      const intersectPolygons = selectedPolygon.findIntersectPolygons(shapes, true).map(i => this.shapes[i].shape);\n      const subtractedData = selectedPolygon.subtract(intersectPolygons);\n      if (subtractedData && subtractedData.length > 0) {\n        this.updatePolygons(subtractedData[0][0], subtractedData.slice(1).map(d => d[0]));\n        message.success(i18n.translate('SUBTRACT_SUCCESS'));\n      } else {\n        message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));\n      }\n    };\n    this.updateConfig = ({\n      fill,\n      alpha,\n      borderAlpha,\n      borderWidth,\n      dotRadius,\n      showSideLength,\n      showDirection,\n      showVertex,\n      showVertexOrder,\n      vertexSize\n    }) => {\n      const {\n        viewMode\n      } = this.rootStore.config;\n      if (fill !== undefined) {\n        this.config.fill = fill;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesFill(fill);\n        } else {\n          this.rootStore.grid.updateShapesFill(fill);\n        }\n      }\n      if (alpha !== undefined) {\n        this.config.alpha = alpha;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesAlpha(alpha / 100);\n        } else {\n          this.rootStore.grid.updateShapesAlpha(alpha / 100);\n        }\n      }\n      if (borderAlpha !== undefined) {\n        this.config.borderAlpha = borderAlpha;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesBorderAlpha(borderAlpha / 100);\n        } else {\n          this.rootStore.grid.updateShapesBorderAlpha(borderAlpha / 100);\n        }\n      }\n      if (borderWidth !== undefined) {\n        this.config.borderWidth = borderWidth;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesBorderWidth(borderWidth);\n        } else {\n          this.rootStore.grid.updateShapesBorderWidth(borderWidth);\n        }\n      }\n      if (dotRadius !== undefined) {\n        this.config.dotRadius = dotRadius;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateDotsRadius(dotRadius);\n        } else {\n          this.rootStore.grid.updateDotsRadius(dotRadius);\n        }\n      }\n      if (showSideLength !== undefined) {\n        this.config.showSideLength = showSideLength;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShowSideLength(showSideLength);\n        } else {\n          this.rootStore.grid.updateShowSideLength(showSideLength);\n        }\n      }\n      if (showDirection !== undefined) {\n        this.config.showDirection = showDirection;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShowDirection(showDirection);\n        } else {\n          this.rootStore.grid.updateShowDirection(showDirection);\n        }\n      }\n      if (showVertex !== undefined) {\n        this.config.showVertex = showVertex;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShowVertex(showVertex);\n        } else {\n          this.rootStore.grid.updateShowVertex(showVertex);\n        }\n      }\n      if (showVertexOrder !== undefined) {\n        this.config.showVertexOrder = showVertexOrder;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShowVertexOrder(showVertexOrder);\n        } else {\n          this.rootStore.grid.updateShowVertexOrder(showVertexOrder);\n        }\n      }\n      if (vertexSize !== undefined) {\n        this.config.vertexSize = vertexSize;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateVertexSize(vertexSize);\n        } else {\n          this.rootStore.grid.updateVertexSize(vertexSize);\n        }\n      }\n      cache.set(CacheKey.SHAPE_STYLES, this.config);\n    };\n    this.updateShapesFill = fill => {\n      const fillAlpha = fill ? this.config.alpha / 100 : 0;\n      if (this.drawingShape) {\n        this.drawingShape.alpha = fillAlpha;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.alpha = fillAlpha;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.alpha = fillAlpha;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.alpha = fillAlpha;\n        });\n      });\n      if (this.rootStore.config.previewMode) {\n        Object.values(this.rootStore.frame.cameraViews).forEach(cameraView => {\n          cameraView.updatePreviewModeAlpha(fillAlpha);\n        });\n      }\n    };\n    this.updateShapesAlpha = alpha => {\n      if (this.config.fill) {\n        if (this.drawingShape) {\n          this.drawingShape.alpha = alpha;\n        }\n        Object.values(this.shapes).forEach(({\n          shape\n        }) => {\n          shape.alpha = alpha;\n        });\n        Object.values(this.predictedShapes).forEach(({\n          shape\n        }) => {\n          shape.alpha = alpha;\n        });\n        Object.values(this.projectedShapes).forEach(cameraShapes => {\n          Object.values(cameraShapes).forEach(shape => {\n            shape.alpha = alpha;\n          });\n        });\n        if (this.rootStore.config.previewMode) {\n          Object.values(this.rootStore.frame.cameraViews).forEach(cameraView => {\n            cameraView.updatePreviewModeAlpha(alpha);\n          });\n        }\n      }\n    };\n    this.updateShapesBorderAlpha = borderAlpha => {\n      if (this.drawingShape) {\n        this.drawingShape.borderAlpha = borderAlpha;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.borderAlpha = borderAlpha;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.borderAlpha = borderAlpha;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.borderAlpha = borderAlpha;\n        });\n      });\n    };\n    this.updateShapesBorderWidth = borderWidth => {\n      if (this.rootStore.config.previewMode) {\n        const cameraViews = Object.values(this.rootStore.frame.cameraViews);\n        cameraViews.forEach(cameraView => {\n          cameraView.shapesLayer.cacheAsBitmap = false;\n        });\n        Object.values(this.shapes).forEach(({\n          shape\n        }) => {\n          shape.borderWidth = borderWidth * shape.scale;\n        });\n        Object.values(this.projectedShapes).forEach(cameraShapes => {\n          Object.values(cameraShapes).forEach(shape => {\n            shape.borderWidth = borderWidth * shape.scale;\n          });\n        });\n        cameraViews.forEach(cameraView => {\n          cameraView.shapesLayer.cacheAsBitmap = true;\n        });\n        return;\n      }\n      if (this.drawingShape) {\n        this.drawingShape.borderWidth = borderWidth;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.borderWidth = borderWidth;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.borderWidth = borderWidth;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.borderWidth = borderWidth;\n        });\n      });\n    };\n    this.updateDotsRadius = dotRadius => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Dot) {\n          shape.dotRadius = dotRadius;\n        } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n          shape.vertexSize = dotRadius;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Dot) {\n          shape.dotRadius = dotRadius;\n        } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n          shape.vertexSize = dotRadius;\n        }\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          if (shape instanceof Dot) {\n            shape.dotRadius = dotRadius;\n          } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n            shape.vertexSize = dotRadius;\n          }\n        });\n      });\n    };\n    this.updateShowSideLength = showSideLength => {\n      if (this.drawingShape) {\n        this.drawingShape.showSideLength = showSideLength;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showSideLength = showSideLength;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showSideLength = showSideLength;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.showSideLength = showSideLength;\n        });\n      });\n    };\n    this.updateShowDirection = showDirection => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showDirection = showDirection;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showDirection = showDirection;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.showDirection = showDirection;\n        });\n      });\n    };\n    this.updateShowVertex = showVertex => {\n      if (this.drawingShape) {\n        this.drawingShape.showVertex = showVertex;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showVertex = showVertex;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showVertex = showVertex;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.showVertex = showVertex;\n        });\n      });\n    };\n    this.updateShowVertexOrder = showVertexOrder => {\n      if (this.drawingShape) {\n        this.drawingShape.showVertexOrder = showVertexOrder;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.showVertexOrder = showVertexOrder;\n        });\n      });\n    };\n    this.updateVertexSize = vertexSize => {\n      if (this.drawingShape && this.drawingShape.shapeType !== ShapeType.KEYPOINTS) {\n        this.drawingShape.vertexSize = vertexSize;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape.shapeType !== ShapeType.KEYPOINTS) {\n          shape.vertexSize = vertexSize;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        if (shape.shapeType !== ShapeType.KEYPOINTS) {\n          shape.vertexSize = vertexSize;\n        }\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          if (shape.shapeType !== ShapeType.KEYPOINTS) {\n            shape.vertexSize = vertexSize;\n          }\n        });\n      });\n    };\n    this.resetConfig = () => {\n      this.updateConfig({\n        ...this.defaultConfig\n      });\n    };\n    this.toggleShapeCut = (cuttingMode = 'cut') => {\n      const shape = cuttingMode === 'cut' ? this.cuttingShape : this.splittingShape;\n      if (shape) {\n        this.endShapeCutting();\n      } else {\n        this.startShapeCutting(cuttingMode);\n      }\n    };\n    /**\n     * rotate all shapes (excluding predicted shapes)\n     * @param rotation\n     * @param center\n     * @param offsetX\n     * @param offsetY\n     */\n    this.rotateShapesByCanvas = (rotation, center, offsetX, offsetY) => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const {\n        autoInterpolation,\n        activeLayerIndex\n      } = this.rootStore.config;\n      const prevInstanceMap = {};\n      const currInstanceMap = {};\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = this.rootStore.frame.imageBounds;\n      const imageWidth = right - left;\n      const imageHeight = bottom - top;\n      const matrix = getMatrixByRotation(rotation, imageWidth, imageHeight);\n      this.getShapesForCamera(currentCamera).forEach(({\n        shape,\n        instanceItem\n      }) => {\n        var _instanceItem$cameras2;\n        // update shape\n        switch (shape.shapeType) {\n          case ShapeType.RECTANGLE:\n          case ShapeType.SQUARE:\n            {\n              const rect = shape;\n              const {\n                x,\n                y,\n                width,\n                height,\n                centerLineEnabled,\n                center: c,\n                rotation: r\n              } = rect;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x: x + width / 2,\n                y: y + height / 2\n              }, rotation);\n              if (rotation % Math.PI !== 0) {\n                rect.width = height;\n                rect.height = width;\n              }\n              rect.x = this.precise(rotatedCenter.x - offsetX - rect.width / 2);\n              rect.y = this.precise(rotatedCenter.y - offsetY - rect.height / 2);\n              // update center\n              if (centerLineEnabled) {\n                rect.center = this.precise(rect.x + (c - x) / width * rect.width);\n              }\n              // reset rotation to update pivot\n              rect.rotation = r;\n              break;\n            }\n          case ShapeType.POLYGON:\n          case ShapeType.QUAD_PRISM:\n          case ShapeType.ORIENTED_QUAD_PRISM:\n          case ShapeType.LINE:\n          case ShapeType.ARROW:\n          case ShapeType.KEYPOINTS:\n            {\n              const s = shape;\n              const {\n                points\n              } = s;\n              s.points = points.map(p => {\n                const rp = computeRotatedPosition(center, p, rotation);\n                return {\n                  ...p,\n                  x: this.precise(rp.x - offsetX),\n                  y: this.precise(rp.y - offsetY)\n                };\n              });\n              break;\n            }\n          case ShapeType.CURVE:\n          case ShapeType.FLEX_LINE:\n            {\n              const s = shape;\n              s.points = s.points.map(p => {\n                const rp = computeRotatedPosition(center, p, rotation);\n                return {\n                  x: this.precise(rp.x - offsetX),\n                  y: this.precise(rp.y - offsetY),\n                  ...(p.controls && {\n                    controls: p.controls.map(c => {\n                      const rc = computeRotatedPosition(center, c, rotation);\n                      return {\n                        x: this.precise(rc.x - offsetX),\n                        y: this.precise(rc.y - offsetY)\n                      };\n                    })\n                  })\n                };\n              });\n              break;\n            }\n          case ShapeType.CURVE_PAIR:\n            {\n              const s = shape;\n              s.pairs = s.pairs.map(({\n                p1,\n                p2,\n                controls\n              }) => {\n                const rp1 = computeRotatedPosition(center, p1, rotation);\n                const rp2 = computeRotatedPosition(center, p2, rotation);\n                return {\n                  p1: {\n                    x: this.precise(rp1.x - offsetX),\n                    y: this.precise(rp1.y - offsetY)\n                  },\n                  p2: {\n                    x: this.precise(rp2.x - offsetX),\n                    y: this.precise(rp2.y - offsetY)\n                  },\n                  ...(controls && {\n                    controls: controls.map(c => {\n                      const rc = computeRotatedPosition(center, c, rotation);\n                      return {\n                        x: this.precise(rc.x - offsetX),\n                        y: this.precise(rc.y - offsetY)\n                      };\n                    })\n                  })\n                };\n              });\n              break;\n            }\n          case ShapeType.PARALLELOGRAM:\n            {\n              const s = shape;\n              const {\n                points\n              } = s;\n              s.points = points.map(p => {\n                const rp = computeRotatedPosition(center, p, rotation);\n                return {\n                  x: this.precise(rp.x - offsetX),\n                  y: this.precise(rp.y - offsetY)\n                };\n              });\n              break;\n            }\n          case ShapeType.ELLIPSE:\n            {\n              const ellipse = shape;\n              const {\n                x,\n                y,\n                halfWidth,\n                halfHeight\n              } = ellipse;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x,\n                y\n              }, rotation);\n              ellipse.x = this.precise(rotatedCenter.x - offsetX);\n              ellipse.y = this.precise(rotatedCenter.y - offsetY);\n              if (rotation % Math.PI !== 0) {\n                ellipse.halfWidth = halfHeight;\n                ellipse.halfHeight = halfWidth;\n              }\n              break;\n            }\n          case ShapeType.CIRCLE:\n            {\n              const circle = shape;\n              const {\n                x,\n                y\n              } = circle;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x,\n                y\n              }, rotation);\n              circle.x = this.precise(rotatedCenter.x - offsetX);\n              circle.y = this.precise(rotatedCenter.y - offsetY);\n              break;\n            }\n          case ShapeType.CUBOID:\n          case ShapeType.TWO_SIDES_CUBOID:\n            {\n              const cuboid = shape;\n              const {\n                x1,\n                y1,\n                w1,\n                h1,\n                x2,\n                y2,\n                w2,\n                h2\n              } = cuboid;\n              const rotatedCenter1 = computeRotatedPosition(center, {\n                x: x1 + w1 / 2,\n                y: y1 + h1 / 2\n              }, rotation);\n              const rotatedCenter2 = computeRotatedPosition(center, {\n                x: x2 + w2 / 2,\n                y: y2 + h2 / 2\n              }, rotation);\n              let fw = w1;\n              let fh = h1;\n              let bw = w2;\n              let bh = h2;\n              if (rotation % Math.PI !== 0) {\n                fw = h1;\n                fh = w1;\n                bw = h2;\n                bh = w2;\n              }\n              cuboid.setData({\n                front: {\n                  x: this.precise(rotatedCenter1.x - offsetX - fw / 2),\n                  y: this.precise(rotatedCenter1.y - offsetY - fh / 2),\n                  width: fw,\n                  height: fh\n                },\n                back: {\n                  x: this.precise(rotatedCenter2.x - offsetX - bw / 2),\n                  y: this.precise(rotatedCenter2.y - offsetY - bh / 2),\n                  width: bw,\n                  height: bh\n                }\n              });\n              break;\n            }\n          case ShapeType.LSHAPE:\n            {\n              const lshape = shape;\n              const {\n                x,\n                y,\n                w,\n                h,\n                sx1,\n                sy1,\n                sx2,\n                sy2,\n                center: c\n              } = lshape;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x: x + w / 2,\n                y: y + h / 2\n              }, rotation);\n              if (rotation % Math.PI !== 0) {\n                lshape.w = h;\n                lshape.h = w;\n              }\n              lshape.x = rotatedCenter.x - offsetX - lshape.w / 2;\n              lshape.y = rotatedCenter.y - offsetY - lshape.h / 2;\n              // update side points (side points cannot be rotated, keep the offset from origin)\n              if (Math.abs(sx1 - x) < Math.abs(sx1 - x - w)) {\n                lshape.sx1 = lshape.x + sx1 - x;\n                lshape.sx2 = lshape.x + sx2 - x;\n              } else {\n                lshape.sx1 = lshape.x + lshape.w + sx1 - (x + w);\n                lshape.sx2 = lshape.x + lshape.w + sx2 - (x + w);\n              }\n              lshape.sy1 = lshape.y + sy1 - y;\n              lshape.sy2 = lshape.y + sy2 - y;\n              // update center\n              lshape.center = this.precise(lshape.x + (c - x) / w * lshape.w);\n              lshape.x = this.precise(lshape.x);\n              lshape.y = this.precise(lshape.y);\n              lshape.sx1 = this.precise(lshape.sx1);\n              lshape.sx2 = this.precise(lshape.sx2);\n              lshape.sy1 = this.precise(lshape.sy1);\n              lshape.sy2 = this.precise(lshape.sy2);\n              break;\n            }\n          case ShapeType.DOT:\n            {\n              const dot = shape;\n              const {\n                x,\n                y\n              } = dot;\n              const rotatedPoint = computeRotatedPosition(center, {\n                x,\n                y\n              }, rotation);\n              dot.x = this.precise(rotatedPoint.x - offsetX);\n              dot.y = this.precise(rotatedPoint.y - offsetY);\n              break;\n            }\n          case ShapeType.GRID:\n            {\n              const grid = shape;\n              const {\n                cols,\n                rows,\n                x,\n                y,\n                width,\n                height\n              } = grid;\n              const gridCenter = {\n                x: x + width / 2,\n                y: y + height / 2\n              };\n              const rotatedCenter = computeRotatedPosition(center, gridCenter, rotation);\n              if (rotation % Math.PI !== 0) {\n                const c0 = rotatedCenter.x - offsetX - height / 2;\n                const r0 = rotatedCenter.y - offsetY - width / 2;\n                grid.cols = rows.map(r => ({\n                  x: this.precise(c0 + r.y - y)\n                }));\n                grid.rows = cols.map(c => ({\n                  y: this.precise(r0 + c.x - x)\n                }));\n              } else {\n                const c0 = rotatedCenter.x - offsetX - width / 2;\n                const r0 = rotatedCenter.y - offsetY - height / 2;\n                grid.cols = cols.map(c => ({\n                  x: this.precise(c0 + c.x - x)\n                }));\n                grid.rows = rows.map(r => ({\n                  y: this.precise(r0 + r.y - y)\n                }));\n              }\n              break;\n            }\n          case ShapeType.PIXEL:\n            {\n              const pixel = shape;\n              const newPixels = {};\n              let l = -1;\n              let r = -1;\n              let t = -1;\n              let b = -1;\n              const {\n                pixelsData\n              } = pixel;\n              const allX = Object.values(pixelsData.pixels);\n              for (let i = 0; i < allX.length; i += 1) {\n                const {\n                  x,\n                  yList\n                } = allX[i];\n                const allY = Object.values(yList);\n                for (let j = 0; j < allY.length; j += 1) {\n                  const y = allY[j];\n                  const {\n                    x: px,\n                    y: py\n                  } = calcPositionByMatrix({\n                    x,\n                    y\n                  }, matrix);\n                  if (!newPixels[px]) {\n                    newPixels[px] = {\n                      x: px,\n                      yList: {}\n                    };\n                  }\n                  newPixels[px].yList[py] = py;\n                  if (l === -1 || l > px) {\n                    l = px;\n                  }\n                  if (r === -1 || r < px) {\n                    r = px;\n                  }\n                  if (t === -1 || t > py) {\n                    t = py;\n                  }\n                  if (b === -1 || b < py) {\n                    b = py;\n                  }\n                }\n              }\n              pixelsData.pixels = newPixels;\n              pixelsData.left = l;\n              pixelsData.right = r;\n              pixelsData.top = t;\n              pixelsData.bottom = b;\n              pixel.drawShape();\n              break;\n            }\n          default:\n        }\n\n        // save shape data\n        const {\n          layer = activeLayerIndex\n        } = ((_instanceItem$cameras2 = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras2 === void 0 ? void 0 : _instanceItem$cameras2.frames[currentFrame]) || {};\n        const {\n          prevState,\n          currState\n        } = instanceItem.updateShape(currentCamera, currentFrame, autoInterpolation && shape.shapeType !== ShapeType.PIXEL, shape.shapeType, shape.getData(), layer);\n        const {\n          instance\n        } = instanceItem;\n        if (prevState) {\n          if (!prevInstanceMap[instance.id]) {\n            prevInstanceMap[instance.id] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          prevInstanceMap[instance.id].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instance.id]) {\n            currInstanceMap[instance.id] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instance.id].children.push(currState);\n        }\n      });\n\n      // reproject shapes\n      this.reprojectShapesByCamera();\n      return {\n        prevState: {\n          instances: Object.values(prevInstanceMap)\n        },\n        currState: {\n          instances: Object.values(currInstanceMap)\n        }\n      };\n    };\n    /**\n     * hide or show shapes based on hideOthers\n     */\n    this.hideOrShowOthers = () => {\n      const {\n        hideOthers,\n        hideAll,\n        layersVisible,\n        activeLayerIndex\n      } = this.rootStore.config;\n      const {\n        isOpen: hideOthersIsOpen,\n        mode: hideOthersMode\n      } = hideOthers;\n      const {\n        currentFrame\n      } = this.rootStore.frame;\n      const {\n        selectedInstances,\n        selectedInstanceItems\n      } = this.rootStore.instance;\n      const {\n        filterMode,\n        filteredInstances\n      } = this.rootStore.filter;\n      let updated = false;\n      const visibleShapeIds = [];\n      Object.values(this.shapes).forEach(({\n        shape,\n        camera,\n        instanceItem\n      }) => {\n        const labelDom = document.getElementById(`label-item-${instanceItem.id}`);\n        let hide = hideAll;\n        if (!hide) {\n          var _instanceItem$cameras3;\n          // check layer visible\n          const {\n            layer = activeLayerIndex\n          } = ((_instanceItem$cameras3 = instanceItem.cameras[camera]) === null || _instanceItem$cameras3 === void 0 ? void 0 : _instanceItem$cameras3.frames[currentFrame]) || {};\n          hide = layersVisible[layer] === false;\n        }\n        if (!hide && filterMode) {\n          var _filteredInstances$in, _filteredInstances$in2, _filteredInstances$in3;\n          // check filter mode\n          hide = !((_filteredInstances$in = filteredInstances[instanceItem.instance.id]) === null || _filteredInstances$in === void 0 ? void 0 : (_filteredInstances$in2 = _filteredInstances$in.cameras[camera]) === null || _filteredInstances$in2 === void 0 ? void 0 : (_filteredInstances$in3 = _filteredInstances$in2[currentFrame]) === null || _filteredInstances$in3 === void 0 ? void 0 : _filteredInstances$in3.includes(instanceItem));\n        }\n        if (!hide && hideOthersIsOpen) {\n          // check solo mode\n          if (hideOthersMode === SoloMode.INSTANCE && selectedInstances.length > 0) {\n            // instance solo\n            hide = selectedInstances.findIndex(i => i.id === instanceItem.instance.id) < 0;\n          } else if (hideOthersMode === SoloMode.ITEM && selectedInstanceItems.length > 0) {\n            // instance item solo (with relationships)\n            hide = selectedInstanceItems.findIndex(i => {\n              var _i$cameras$camera;\n              return i.id === instanceItem.id || ((_i$cameras$camera = i.cameras[camera]) === null || _i$cameras$camera === void 0 ? void 0 : _i$cameras$camera.relationships.findIndex(({\n                frames,\n                fromInstanceItem,\n                toInstanceItem\n              }) => frames[currentFrame] && (fromInstanceItem.id === instanceItem.id || toInstanceItem.id === instanceItem.id))) >= 0;\n            }) < 0;\n          }\n        }\n        if (hide) {\n          if (!updated) {\n            updated = shape.visible !== false;\n          }\n          shape.visible = false;\n          if (labelDom) {\n            labelDom.style.visibility = 'hidden';\n          }\n          if (this.projectedShapes[shape.uid]) {\n            Object.values(this.projectedShapes[shape.uid]).forEach(projectedShape => {\n              projectedShape.visible = false;\n            });\n          }\n        } else {\n          if (!updated) {\n            updated = shape.visible !== true;\n          }\n          shape.visible = true;\n          if (labelDom) {\n            labelDom.style.visibility = 'visible';\n          }\n          if (this.projectedShapes[shape.uid]) {\n            Object.values(this.projectedShapes[shape.uid]).forEach(projectedShape => {\n              projectedShape.visible = true;\n            });\n          }\n          visibleShapeIds.push(shape.uid);\n        }\n      });\n      this.visibleShapeIds = visibleShapeIds;\n      this.rootStore.relationship.hideOrShowRelationships();\n      this.rootStore.review.hideOrShowReviews();\n      if (updated) {\n        this.updateShapesRefreshCounter();\n      }\n    };\n    /**\n     * set refresh counter\n     */\n    this.updateShapesRefreshCounter = debounce(() => {\n      const {\n        viewMode,\n        cameraLayout\n      } = this.rootStore.config;\n      if (viewMode === ViewMode.DEFAULT && cameraLayout === CameraLayout.THUMBNAIL) {\n        this.shapesRefreshCounter += 1;\n      }\n    }, 0);\n    /**\n     * toggle to line append\n     */\n    this.toggleLineAppend = () => {\n      if (this.appendingShape) {\n        this.endShapeAppending();\n      } else {\n        this.startShapeAppending();\n      }\n    };\n    /**\n     * append points to selected line\n     */\n    this.startShapeAppending = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || !this.rootStore.instance.isSingleSelected || this.rootStore.segmentation.updatingShape) {\n        return;\n      }\n      const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n      const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n      if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.editable) && (selectedShape.shapeType === ShapeType.LINE || selectedShape.shapeType === ShapeType.ARROW)) {\n        this.clearPending(); // cancel merge\n        this.endShapeCutting(); // cancel cut\n        this.finishUpdateShape(); // cancel update\n        this.rootStore.relationship.cancel(); // cancel relationship\n\n        this.appendingShape = selectedShape.uid;\n        selectedShape.append(this.rootStore.currPosition, this.selectedPointIndex);\n\n        // update interactive\n        if (!isGridView) {\n          this.updateShapesInteractive(false, [selectedShape.uid]);\n        } else {\n          this.rootStore.grid.updateShapesInteractive(false, [selectedShape.uid]);\n        }\n        this.rootStore.relationship.updateConnectionsInteractive(false);\n      }\n    };\n    /**\n     * ends shape appending\n     * @param isCancel\n     */\n    this.endShapeAppending = (isCancel = true) => {\n      if (!this.appendingShape) {\n        return;\n      }\n      if (isCancel) {\n        if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n          const shapeItem = this.shapes[this.appendingShape];\n          if (shapeItem === null || shapeItem === void 0 ? void 0 : shapeItem.shape) {\n            const shape = shapeItem.shape;\n            shape.finishAppend(isCancel);\n          }\n        } else {\n          const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n          if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.uid) === this.appendingShape) {\n            selectedShape.finishAppend(isCancel);\n          }\n        }\n      }\n      this.appendingShape = '';\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        this.updateShapesInteractive(true);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(true);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(true);\n    };\n    this.startUpdateShape = (check = true) => {\n      if (check && (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || !this.rootStore.instance.isSingleSelected || this.rootStore.segmentation.updatingShape)) {\n        return;\n      }\n      const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n      const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n      if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.editable) && selectedShape.shapeType === ShapeType.KEYPOINTS) {\n        this.clearPending(); // cancel merge\n        this.endShapeCutting(); // cancel cutting\n        this.endShapeAppending(); // cancel appending\n        this.rootStore.relationship.cancel(); // cancel relationship\n\n        this.updatingShape = selectedShape.uid;\n        selectedShape.update();\n        this.rootStore.config.setCursor(selectedShape.currCursor);\n\n        // update interactive\n        if (!isGridView) {\n          this.updateShapesInteractive(false, [selectedShape.uid]);\n        } else {\n          this.rootStore.grid.updateShapesInteractive(false, [selectedShape.uid]);\n        }\n        this.rootStore.relationship.updateConnectionsInteractive(false);\n      }\n    };\n    this.finishUpdateShape = () => {\n      if (!this.updatingShape) {\n        return;\n      }\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        var _shapeItem$shape;\n        const shapeItem = this.shapes[this.updatingShape];\n        if ((shapeItem === null || shapeItem === void 0 ? void 0 : (_shapeItem$shape = shapeItem.shape) === null || _shapeItem$shape === void 0 ? void 0 : _shapeItem$shape.shapeType) === ShapeType.KEYPOINTS) {\n          shapeItem.shape.finishUpdate();\n          this.rootStore.config.setCursor(shapeItem.shape.currCursor);\n          this.updateShapesInteractive(true);\n        }\n      } else {\n        const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n        if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.uid) === this.updatingShape && selectedShape.shapeType === ShapeType.KEYPOINTS) {\n          selectedShape.finishUpdate();\n          this.rootStore.config.setCursor(selectedShape.currCursor);\n          this.rootStore.grid.updateShapesInteractive(true);\n        }\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(true);\n      this.updatingShape = '';\n    };\n    /**\n     * reverse shape direction\n     */\n    this.reverse = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing) {\n        return;\n      }\n      const isDefaultView = this.rootStore.config.viewMode === ViewMode.DEFAULT;\n      const selectedShape = isDefaultView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n      if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.editable) && (selectedShape.shapeType === ShapeType.POLYGON || selectedShape.shapeType === ShapeType.ARROW)) {\n        selectedShape.reverse();\n        if (selectedShape.shapeType === ShapeType.POLYGON && !this.config.showVertexOrder && !this.config.showDirection) {\n          message.info(i18n.translate('SHAPE_REVERSE_INFO'));\n        }\n      }\n    };\n    /**\n     * toggle when creating line, if the first point position is same with preivous line's last end of points\n     */\n    this.toggleLineContinuous = () => {\n      this.lineContinuous = !this.lineContinuous;\n      cache.set(CacheKey.TOOL_LINE_CREATE_FROM_PREVIOUS_END_POINT, this.lineContinuous);\n    };\n    this.initLineContinuous = () => {\n      this.lineContinuous = !!cache.get(CacheKey.TOOL_LINE_CREATE_FROM_PREVIOUS_END_POINT);\n    };\n    /**\n     * update shape's editable when locked or unlocked\n     * @param instanceItem\n     * @param camera\n     * @param locked\n     */\n    this.updateShapeLockedState = (instanceItem, camera, locked) => {\n      var _shape, _this$pendingMergeLin, _shape2, _shape3, _shape4, _shape5, _shape6, _this$rootStore$segme, _shape7;\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      let shape;\n      if (this.rootStore.config.viewMode === ViewMode.GRID) {\n        // only need update when the instance item show in grid view\n        const {\n          isSingleSelected,\n          selectedInstanceItems\n        } = this.rootStore.instance;\n        const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n        if ((selectedInstanceItem === null || selectedInstanceItem === void 0 ? void 0 : selectedInstanceItem.id) === instanceItem.id && currentCamera === camera) {\n          const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n          if (selectedShape) {\n            shape = selectedShape;\n          }\n        }\n      } else {\n        shape = this.getShapeByInstanceItem(instanceItem, camera);\n      }\n\n      // cancel working status\n      if (this.pendingMergePolygon === ((_shape = shape) === null || _shape === void 0 ? void 0 : _shape.uid) || ((_this$pendingMergeLin = this.pendingMergeLine) === null || _this$pendingMergeLin === void 0 ? void 0 : _this$pendingMergeLin.id) === ((_shape2 = shape) === null || _shape2 === void 0 ? void 0 : _shape2.uid)) {\n        this.clearPending();\n      }\n      if (this.cuttingShape === ((_shape3 = shape) === null || _shape3 === void 0 ? void 0 : _shape3.uid) || this.splittingShape === ((_shape4 = shape) === null || _shape4 === void 0 ? void 0 : _shape4.uid)) {\n        this.endShapeCutting();\n      }\n      if (this.appendingShape === ((_shape5 = shape) === null || _shape5 === void 0 ? void 0 : _shape5.uid)) {\n        this.endShapeAppending();\n      }\n      if (this.updatingShape === ((_shape6 = shape) === null || _shape6 === void 0 ? void 0 : _shape6.uid)) {\n        this.finishUpdateShape();\n      }\n      if (((_this$rootStore$segme = this.rootStore.segmentation.updatingShape) === null || _this$rootStore$segme === void 0 ? void 0 : _this$rootStore$segme.uid) === ((_shape7 = shape) === null || _shape7 === void 0 ? void 0 : _shape7.uid)) {\n        this.rootStore.segmentation.cancelUpdate();\n      }\n      if (shape) {\n        var _instanceItem$cameras4, _instanceItem$cameras5;\n        const matrixChangeAllowed = (_instanceItem$cameras4 = instanceItem.cameras[camera]) === null || _instanceItem$cameras4 === void 0 ? void 0 : (_instanceItem$cameras5 = _instanceItem$cameras4.frames[currentFrame]) === null || _instanceItem$cameras5 === void 0 ? void 0 : _instanceItem$cameras5.matrixChangeAllowed;\n        shape.editable = !locked && !this.rootStore.readonly && matrixChangeAllowed;\n      }\n    };\n    makeObservable(this, {\n      shapes: observable,\n      recognitionStart: observable,\n      selectedShapes: observable,\n      selectedPointIndex: observable,\n      drawingShape: observable,\n      pendingMergePixel: observable,\n      cuttingShape: observable,\n      splittingShape: observable,\n      appendingShape: observable,\n      updatingShape: observable,\n      projecting: observable,\n      shapesRefreshCounter: observable,\n      config: observable,\n      lineContinuous: observable,\n      toggleLineContinuous: action,\n      init: action,\n      clearShapes: action,\n      setupShapes: action,\n      selectShapes: action,\n      unselectShape: action,\n      addShape: action,\n      setupShape: action,\n      deleteShape: action,\n      resetRecognition: action,\n      updateConfig: action,\n      startShapeCutting: action,\n      endShapeCutting: action,\n      startShapeAppending: action,\n      endShapeAppending: action,\n      startUpdateShape: action,\n      finishUpdateShape: action\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * precise number\n   * @param num\n   */\n  precise(num) {\n    return precise(num, this.rootStore.config.dataPrecision);\n  }\n  initShapeStylesConfig(payload) {\n    const localShapeStylesConfig = cache.get(CacheKey.SHAPE_STYLES);\n    if (localShapeStylesConfig) {\n      this.defaultConfig = {\n        ...this.config\n      }; // save default settings\n      this.config = {\n        ...localShapeStylesConfig\n      };\n    } else {\n      this.config.fill = payload.is_fill !== 'false' && payload.is_fill !== false;\n      if (payload.fill_opacity !== undefined && payload.fill_opacity !== '') {\n        const alpha = Number(payload.fill_opacity);\n        if (!Number.isNaN(alpha) && alpha >= 0 && alpha <= 1) {\n          this.config.alpha = alpha * 100;\n        }\n      }\n      if (payload.border_opacity !== undefined && payload.border_opacity !== '') {\n        const borderAlpha = Number(payload.border_opacity);\n        if (!Number.isNaN(borderAlpha) && borderAlpha >= 0 && borderAlpha <= 1) {\n          this.config.borderAlpha = borderAlpha * 100;\n        }\n      }\n      if (payload.border_width !== undefined && payload.border_width !== '') {\n        const borderWidth = Number(payload.border_width);\n        if (!Number.isNaN(borderWidth) && borderWidth >= 1 && borderWidth <= 10) {\n          this.config.borderWidth = borderWidth;\n        }\n      }\n      if (payload.dot_size !== undefined && payload.dot_size !== '') {\n        const dotRadius = Number(payload.dot_size);\n        if (!Number.isNaN(dotRadius) && dotRadius >= 1 && dotRadius <= 10) {\n          this.config.dotRadius = dotRadius;\n        }\n      }\n      this.config.showSideLength = payload.show_side_length === 'true' || payload.show_side_length === true;\n      this.config.showDirection = payload.show_direction === 'true' || payload.show_direction === true;\n      this.config.showVertex = payload.show_vertex === 'true' || payload.show_vertex === true;\n      this.config.showVertexOrder = payload.show_vertex_order === 'true' || payload.show_vertex_order === true;\n      if (payload.vertex_size !== undefined && payload.vertex_size !== '') {\n        const vertexSize = Number(payload.vertex_size);\n        if (!Number.isNaN(vertexSize) && vertexSize >= 0) {\n          this.config.vertexSize = vertexSize;\n        }\n      }\n      if (payload.vertex_start !== undefined && payload.vertex_start !== '') {\n        const vertexStart = Number(payload.vertex_start);\n        if (!Number.isNaN(vertexStart)) {\n          this.config.vertexStart = vertexStart;\n        }\n      }\n      this.defaultConfig = {\n        ...this.config\n      }; // save default settings\n    }\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload) {\n    this.initShapeStylesConfig(payload);\n    this.initLineContinuous();\n    this.app = payload.app;\n  }\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable) {\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    Object.values(this.shapes).forEach(({\n      shape,\n      instanceItem,\n      camera\n    }) => {\n      var _instanceItem$cameras6, _instanceItem$cameras7;\n      shape.editable = editable && !((_instanceItem$cameras6 = instanceItem.cameras[camera]) === null || _instanceItem$cameras6 === void 0 ? void 0 : (_instanceItem$cameras7 = _instanceItem$cameras6.frames[currentFrame]) === null || _instanceItem$cameras7 === void 0 ? void 0 : _instanceItem$cameras7.locked);\n    });\n    Object.values(this.predictedShapes).forEach(({\n      shape\n    }) => {\n      shape.editable = editable;\n    });\n  }\n  /**\n   * create shape label dom\n   */\n  createShapeLabel(camera = this.rootStore.frame.currentCamera) {\n    const shapeLabelsContainer = document.getElementById(`${CAMERA_VIEW_LABELS}-${camera}`);\n    if (shapeLabelsContainer) {\n      const shapeLabel = new Label({\n        className: 'shape-label',\n        transPosition: p => {\n          const cameraView = this.rootStore.frame.cameraViews[camera];\n          if (cameraView) {\n            return cameraView.toLocal(p);\n          }\n          return p;\n        }\n      });\n      shapeLabel.addToContainer(shapeLabelsContainer);\n      return shapeLabel;\n    }\n    return undefined;\n  }\n  /**\n   * add shape listeners\n   * @param shape\n   */\n  addShapeListeners(shape) {\n    shape.on(EventAction.SELECTED, (s, p, options) => {\n      if (this.rootStore.config.isWorkingOnAnyShape) {\n        return; // do not select other shape when cutting or splitting\n      }\n      if (!this.isPredictedShape(s)) {\n        if (this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n          if (this.pendingMergePolygon && shape.shapeType === ShapeType.POLYGON) {\n            if (!shape.editable) {\n              shape.selected = false;\n              message.warning(i18n.translate('MERGE_LOCK_MSG'));\n              return;\n            }\n            this.mergePolygons(this.pendingMergePolygon, shape.uid);\n            this.pendingMergePolygon = '';\n            return;\n          }\n          if (this.pendingMergePixel && shape.shapeType === ShapeType.PIXEL) {\n            if (!shape.editable) {\n              shape.selected = false;\n              message.warning(i18n.translate('MERGE_LOCK_MSG'));\n              return;\n            }\n            this.rootStore.segmentation.merge(shape.uid, this.pendingMergePixel.id, this.pendingMergePixel.index);\n            this.pendingMergePixel = null;\n            return;\n          }\n          if (this.rootStore.relationship.settingRelationship) {\n            const {\n              instanceItem\n            } = this.shapes[s.uid];\n            if (instanceItem === this.rootStore.relationship.fromInstanceItem) {\n              return;\n            }\n            this.rootStore.relationship.add(instanceItem);\n          }\n        }\n        const isReorganizing = this.rootStore.instance.reorganizingInstance && this.rootStore.instance.reorganizingInstanceItemName;\n        let selectedShapes = [...this.selectedShapes];\n        if ((options === null || options === void 0 ? void 0 : options.shiftKey) && !isReorganizing) {\n          const index = selectedShapes.indexOf(s);\n          if (index >= 0) {\n            selectedShapes.splice(index, 1);\n          } else {\n            selectedShapes.push(s);\n          }\n          this.clearPendingWithAlert();\n        } else {\n          selectedShapes = [s];\n          if (this.selectedShapes.indexOf(s) < 0) {\n            this.clearPendingWithAlert();\n          }\n        }\n        const selectedInstanceItems = selectedShapes.map(ss => this.shapes[ss.uid].instanceItem);\n        this.selectShapes(selectedShapes);\n        this.rootStore.instance.selectInstanceItem(selectedInstanceItems);\n        if (options === null || options === void 0 ? void 0 : options.shiftKey) {\n          this.rootStore.instance.tryReorganize();\n        }\n      } else {\n        // clear selected shape status\n        this.selectedShapes.forEach(ss => {\n          ss.selected = false;\n        });\n        this.selectedShapes = [];\n        // clear predicted shape selected status\n        Object.values(this.predictedShapes).forEach(predictedShape => {\n          if (predictedShape.shape !== s) {\n            predictedShape.shape.selected = false;\n          }\n        });\n        this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);\n        const {\n          instance,\n          name\n        } = this.predictedShapes[s.uid].instanceItem;\n        this.rootStore.ontology.selectCategory(instance.category);\n        this.rootStore.ontology.selectCategoryItem(name);\n      }\n      if (this.rootStore.review.addMode) {\n        this.rootStore.review.addReview(p);\n      }\n      this.rootStore.frame.syncNIFTIViews(this.rootStore.frame.currentCamera, p.x, p.y);\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      this.clearPending();\n      if (this.isPredictedShape(s)) {\n        if (this.validateShape(s)) {\n          // predicted shape area meets the requirement\n          this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);\n        } else {\n          // repredict\n          this.predict();\n        }\n      } else if (this.validateShape(s)) {\n        const {\n          instanceItem\n        } = this.shapes[s.uid];\n        const currentFrame = this.shapesFrame;\n        if (this.splittingShape === s.uid) {\n          if (s.shapeType === ShapeType.POLYGON && s.cuttingOtherPolygon) {\n            this.updatePolygons(data, [s.cuttingOtherPolygon]);\n          }\n          if (s.shapeType === ShapeType.PIXEL && s.cuttingOtherPixels) {\n            this.updateShapes(data, [s.cuttingOtherPixels], s.shapeType);\n          } else if ((s.shapeType === ShapeType.LINE || s.shapeType === ShapeType.ARROW) && s.cuttingOtherLine) {\n            this.updateShapes(data, [s.cuttingOtherLine], s.shapeType);\n          }\n          this.endShapeCutting();\n          this.projectShape(s);\n        } else if (this.pointsMoving) {\n          // finish points moving\n          const instanceItems = [];\n          this.selectedShapes.forEach(i => {\n            if (i === s || i.shapeType === ShapeType.POLYGON || i.shapeType === ShapeType.LINE || i.shapeType === ShapeType.ARROW) {\n              var _shapeItem$instanceIt, _shapeItem$instanceIt2;\n              const shapeItem = this.shapes[i.uid];\n              if (shapeItem && !((_shapeItem$instanceIt = shapeItem.instanceItem.cameras[shapeItem.camera]) === null || _shapeItem$instanceIt === void 0 ? void 0 : (_shapeItem$instanceIt2 = _shapeItem$instanceIt.frames[currentFrame]) === null || _shapeItem$instanceIt2 === void 0 ? void 0 : _shapeItem$instanceIt2.locked)) {\n                if (s !== i) {\n                  i.normalize();\n                }\n                instanceItems.push({\n                  instanceItem: shapeItem.instanceItem,\n                  frameIndex: currentFrame,\n                  shapeType: i.shapeType,\n                  shape: s === i ? data : i.getData()\n                });\n              }\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.pointsMoving = false;\n        } else if (this.shapesMoving) {\n          // finish shapes moving\n          const instanceItems = [];\n          this.selectedShapes.forEach(i => {\n            var _shapeItem$instanceIt3, _shapeItem$instanceIt4;\n            const shapeItem = this.shapes[i.uid];\n            if (shapeItem && !((_shapeItem$instanceIt3 = shapeItem.instanceItem.cameras[shapeItem.camera]) === null || _shapeItem$instanceIt3 === void 0 ? void 0 : (_shapeItem$instanceIt4 = _shapeItem$instanceIt3.frames[currentFrame]) === null || _shapeItem$instanceIt4 === void 0 ? void 0 : _shapeItem$instanceIt4.locked)) {\n              instanceItems.push({\n                instanceItem: shapeItem.instanceItem,\n                frameIndex: currentFrame,\n                shapeType: i.shapeType,\n                shape: s === i ? data : i.getData()\n              });\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.shapesMoving = false;\n        } else if (!this.deleting) {\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, s.shapeType, data);\n          this.endShapeAppending(false);\n          this.projectShape(s);\n          if (s instanceof Keypoints && s.uid === this.updatingShape && !s.hasEmptyPoint) {\n            this.finishUpdateShape();\n            if (this.rootStore.config.continuousMode) {\n              if (this.rootStore.config.continuousModeType === ContinuousModeType.IN_INSTANCE) {\n                this.rootStore.ontology.selectNextCategoryItem();\n              }\n              this.rootStore.config.setAddMode(true);\n            }\n          }\n        }\n      }\n    });\n    shape.on(EventAction.REMOVED, s => {\n      if (!this.deleting) {\n        const {\n          instanceItem\n        } = this.shapes[s.uid];\n        if (instanceItem) {\n          if (s === this.rootStore.segmentation.updatingShape) {\n            this.rootStore.segmentation.cancelUpdate();\n          }\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.shapesFrame]);\n        }\n      }\n    });\n    shape.on(EventAction.POINTER_OVER, s => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = s.uid;\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.POINTER_OUT, s => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = '';\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.VERTEX_SELECTED, (s, index, p) => {\n      if (this.rootStore.review.addMode && p) {\n        this.rootStore.review.addReview(p);\n        return;\n      }\n      if (this.isPredictedShape(s)) {\n        return;\n      }\n      if (this.pendingMergeLine && this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n        this.mergeLines(this.pendingMergeLine, {\n          id: s.uid,\n          index\n        });\n        this.clearPendingLine();\n        return;\n      }\n      this.clearPendingLine();\n      this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n      if (this.selectedShapes.length === 1 && this.selectedShapes[0] === s) {\n        this.selectedPointIndex = index;\n      } else {\n        this.selectedPointIndex = -1;\n      }\n    });\n    shape.on(EventAction.RESIZING, (s, {\n      deltaX,\n      deltaY\n    }) => {\n      const {\n        currentCamera\n      } = this.rootStore.frame;\n      const currentFrame = this.shapesFrame;\n      if (s.shapeType === ShapeType.POLYGON || s.shapeType === ShapeType.LINE || s.shapeType === ShapeType.ARROW || s.shapeType === ShapeType.KEYPOINTS) {\n        const otherSelectedPolygonsAndLines = this.selectedShapes.filter(i => {\n          var _instanceItem$cameras8, _instanceItem$cameras9;\n          if (i === s) {\n            return false;\n          }\n          if (i.shapeType !== ShapeType.POLYGON && i.shapeType !== ShapeType.LINE && i.shapeType !== ShapeType.ARROW && i.shapeType !== ShapeType.KEYPOINTS) {\n            return false;\n          }\n          const {\n            instanceItem,\n            camera = currentCamera\n          } = this.shapes[i.uid] || {};\n          return !(instanceItem === null || instanceItem === void 0 ? void 0 : (_instanceItem$cameras8 = instanceItem.cameras[camera]) === null || _instanceItem$cameras8 === void 0 ? void 0 : (_instanceItem$cameras9 = _instanceItem$cameras8.frames[currentFrame]) === null || _instanceItem$cameras9 === void 0 ? void 0 : _instanceItem$cameras9.locked);\n        });\n        if (otherSelectedPolygonsAndLines.length > 0) {\n          // move points together\n          this.pointsMoving = true;\n          otherSelectedPolygonsAndLines.forEach(i => {\n            i.updateSelectedPointsPosistion(deltaX, deltaY);\n            this.projectShape(i);\n          });\n        }\n      }\n      this.projectShape(s);\n    });\n    shape.on(EventAction.DRAGGING, (s, {\n      deltaX,\n      deltaY\n    }) => {\n      const {\n        currentCamera\n      } = this.rootStore.frame;\n      const currentFrame = this.shapesFrame;\n      const otherSelectedShapes = this.selectedShapes.filter(i => {\n        var _instanceItem$cameras0, _instanceItem$cameras1;\n        if (i === s) {\n          return false;\n        }\n        const {\n          instanceItem,\n          camera = currentCamera\n        } = this.shapes[i.uid] || {};\n        return !(instanceItem === null || instanceItem === void 0 ? void 0 : (_instanceItem$cameras0 = instanceItem.cameras[camera]) === null || _instanceItem$cameras0 === void 0 ? void 0 : (_instanceItem$cameras1 = _instanceItem$cameras0.frames[currentFrame]) === null || _instanceItem$cameras1 === void 0 ? void 0 : _instanceItem$cameras1.locked);\n      });\n      if (otherSelectedShapes.length > 0) {\n        // move shapes together\n        this.shapesMoving = true;\n        otherSelectedShapes.forEach(i => {\n          i.updatePosition(i.position.x + deltaX, i.position.y + deltaY, false);\n          this.projectShape(i);\n        });\n      }\n      this.projectShape(s);\n    });\n    shape.on(EventAction.CONTEXT_MENU, (s, p) => this.rootStore.openContextMenu(p));\n    if (shape.shapeType === ShapeType.PIXEL) {\n      shape.on(PixelEventAction.HOVERED_POLYGON_CHANGE, (s, index) => {\n        const selectedShape = this.rootStore.segmentation.getSelectedShape();\n        if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.uid) === s.uid) {\n          this.rootStore.segmentation.updateHoveredSegmentIndex(index);\n        }\n      });\n      shape.on(PixelEventAction.SELECTED_POLYGON_CHANGE, (s, index) => {\n        const selectedShape = this.rootStore.segmentation.getSelectedShape();\n        if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.uid) === s.uid) {\n          this.rootStore.segmentation.updateSelectedSegmentIndex(index);\n        }\n      });\n    }\n  }\n  /**\n   * fit shapes to canvas for selected instances\n   */\n  fitShapes() {\n    const {\n      currentCamera,\n      cameraNames,\n      cameraViews\n    } = this.rootStore.frame;\n    const {\n      selectedInstanceItems,\n      selectedInstances\n    } = this.rootStore.instance;\n    const {\n      preferences\n    } = this.rootStore.config;\n    const cameraShapes = selectedInstanceItems.length > 0 ? [{\n      camera: currentCamera,\n      shapes: this.getShapesByInstanceItems(selectedInstanceItems)\n    }] : cameraNames.map(camera => ({\n      camera,\n      shapes: Object.values(this.shapes).filter(s => s.camera === camera && selectedInstances.indexOf(s.instanceItem.instance) >= 0).map(s => s.shape)\n    }));\n    cameraShapes.forEach(({\n      camera,\n      shapes\n    }) => {\n      const cameraView = cameraViews[camera];\n      if (shapes.length > 0 && cameraView) {\n        let {\n          left,\n          top,\n          right,\n          bottom\n        } = shapes[0].shapeBounds;\n        for (let i = 1; i < shapes.length; i += 1) {\n          const bbox = shapes[i].shapeBounds;\n          left = Math.min(bbox.left, left);\n          top = Math.min(bbox.top, top);\n          right = Math.max(bbox.right, right);\n          bottom = Math.max(bbox.bottom, bottom);\n        }\n        if (preferences.shapeFocusMode === ShapeFocusMode.ZOOM) {\n          cameraView.fitShapeToView({\n            left,\n            top,\n            right,\n            bottom\n          }, 0.5);\n        } else {\n          cameraView.moveShapeToViewCenter({\n            left,\n            top,\n            right,\n            bottom\n          });\n        }\n      }\n    });\n  }\n  /**\n   * predict shapes by model\n   * @param instanceItems\n   */\n  async predictShapeByModel(instanceItems) {\n    if (!this.rootStore.config.modelPrediction || instanceItems.length === 0) {\n      return;\n    }\n    const {\n      currentCamera,\n      currentFrame,\n      imageBounds,\n      getImageUrl,\n      getImageBoundsForCamera,\n      getFrameRotationForCamera\n    } = this.rootStore.frame;\n\n    // currently, only support predict from previous frames\n    let baseFrame = currentFrame - 1;\n    while (baseFrame >= 0) {\n      // eslint-disable-next-line no-loop-func\n      if (instanceItems.some(item => {\n        var _item$cameras$current3;\n        return ((_item$cameras$current3 = item.cameras[currentCamera]) === null || _item$cameras$current3 === void 0 ? void 0 : _item$cameras$current3.frames[baseFrame]) !== undefined;\n      })) {\n        // 只要有一个组件存在，就作为基准帧进行后续的预测\n        break;\n      }\n      baseFrame -= 1;\n    }\n    if (baseFrame >= 0) {\n      const baseShapes = [];\n      for (let i = 0; i < instanceItems.length; i += 1) {\n        var _instanceItem$cameras10;\n        const instanceItem = instanceItems[i];\n        const frameData = (_instanceItem$cameras10 = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras10 === void 0 ? void 0 : _instanceItem$cameras10.frames[baseFrame];\n        if (frameData) {\n          baseShapes.push({\n            shapeType: frameData.shapeType,\n            shape: frameData.shape,\n            layer: frameData.layer,\n            order: frameData.order,\n            instanceId: instanceItem.instance.id,\n            instanceItemId: instanceItem.id\n          });\n        }\n      }\n      const bounds = getImageBoundsForCamera(currentCamera, baseFrame);\n      const width = bounds.right - bounds.left;\n      const height = bounds.bottom - bounds.top;\n      const {\n        shapesByLayer,\n        masksByLayer\n      } = fillMask(baseShapes, width, height);\n\n      // FIXME: currently only one mask supported\n      const {\n        activeLayerIndex\n      } = this.rootStore.config;\n      const activeMask = masksByLayer[activeLayerIndex];\n      if (!activeMask) {\n        return;\n      }\n      try {\n        var _this$cachedPredictIn, _this$cachedPredictIn2;\n        // 还原回原始图片尺寸进行模型预测\n        const rotation = getFrameRotationForCamera(currentCamera, baseFrame);\n        const originMask = rotateMask(activeMask, -rotation, [width, height]);\n\n        // 检查一下mask是不是一样\n        let sameMask = true;\n        if (((_this$cachedPredictIn = this.cachedPredictInfo) === null || _this$cachedPredictIn === void 0 ? void 0 : _this$cachedPredictIn.baseFrame) === baseFrame && ((_this$cachedPredictIn2 = this.cachedPredictInfo) === null || _this$cachedPredictIn2 === void 0 ? void 0 : _this$cachedPredictIn2.targetFrame) === currentFrame) {\n          for (let i = 0; i < originMask.length; i += 1) {\n            if (originMask[i] !== this.cachedPredictInfo.mask[i]) {\n              sameMask = false;\n              break;\n            }\n          }\n        } else {\n          sameMask = false;\n        }\n        let buffer;\n        if (!sameMask) {\n          const compressed = deflate(new Uint8Array(originMask));\n          const file = new File([compressed], 'mask.bin');\n          const formData = new FormData();\n          formData.append('imgPrevUrl', getImageUrl(currentCamera, baseFrame));\n          formData.append('imgCurUrl', getImageUrl(currentCamera, currentFrame));\n          formData.append('maskPrev', file);\n          this.rootStore.frame.loading = true;\n          if (this.rootStore.config.predictProxy) {\n            buffer = await fetch(`${this.rootStore.config.predictProxy}/predict`, {\n              method: 'POST',\n              body: formData\n            }).then(res => res.arrayBuffer());\n          } else {\n            var _this$rootStore$jobPr;\n            buffer = await ((_this$rootStore$jobPr = this.rootStore.jobProxy) === null || _this$rootStore$jobPr === void 0 ? void 0 : _this$rootStore$jobPr.forwardAPI(APIForwardType.FRAME_SEGMENTATION, formData));\n          }\n          this.cachedPredictInfo = {\n            buffer,\n            baseFrame,\n            targetFrame: currentFrame,\n            mask: originMask\n          };\n        } else {\n          var _this$cachedPredictIn3;\n          buffer = (_this$cachedPredictIn3 = this.cachedPredictInfo) === null || _this$cachedPredictIn3 === void 0 ? void 0 : _this$cachedPredictIn3.buffer;\n        }\n        if (buffer && this.rootStore.frame.currentFrame === currentFrame) {\n          // continue\n          const currRotation = getFrameRotationForCamera(currentCamera, currentFrame);\n          const currWidth = imageBounds.right - imageBounds.left;\n          const currHeight = imageBounds.bottom - imageBounds.top;\n          const decompressed = inflate(buffer);\n          const currMask = rotateMask(Array.from(decompressed), currRotation, [currHeight, currWidth]); // size只有在rotation是90/270度时才有用，可以简单处理，直接反一下宽高\n          const pixels = resolveMask(currMask, currWidth, currHeight);\n          const activeShapes = shapesByLayer[activeLayerIndex];\n          for (let i = 0; i < pixels.length; i += 1) {\n            var _instanceItem$cameras11;\n            const {\n              instanceId,\n              instanceItemId\n            } = activeShapes[i];\n            const instance = this.rootStore.instance.getInstanceById(instanceId);\n            const instanceItem = instance === null || instance === void 0 ? void 0 : instance.items[instanceItemId];\n            // because prediction is async, need double check if already exist before add predict shape\n            const alreadyExist = (instanceItem === null || instanceItem === void 0 ? void 0 : (_instanceItem$cameras11 = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras11 === void 0 ? void 0 : _instanceItem$cameras11.frames[currentFrame]) !== undefined;\n            if (!alreadyExist) {\n              const pixel = pixels[i];\n              const pixelData = new PixelsData({\n                size: [currHeight, currWidth]\n              });\n              pixelData.append(pixel);\n              const {\n                shapeType\n              } = instanceItem.cameras[currentCamera].frames[baseFrame];\n              if (shapeType === ShapeType.PIXEL) {\n                const shape = {\n                  data: pixelData.data,\n                  polygons: pixelData.cachedPolygons,\n                  area: 0\n                };\n                shape.area = calcShapeArea(shapeType, shape);\n                this.rootStore.shape.createPredictedShape(instanceItem, shapeType, shape);\n              } else if (shapeType === ShapeType.POLYGON) {\n                const shape = {\n                  points: simplify(pixelData.cachedPolygons[0][0].map(([x, y]) => ({\n                    x,\n                    y\n                  }))),\n                  area: 0\n                };\n                shape.area = calcShapeArea(shapeType, shape);\n                this.rootStore.shape.createPredictedShape(instanceItem, shapeType, shape);\n              }\n            }\n          }\n        }\n        this.rootStore.frame.loading = false;\n      } catch (e) {\n        this.rootStore.frame.loading = false;\n      }\n    }\n  }\n  /**\n   * create predict shape\n   * @param item\n   * @param shapeType\n   * @param shape\n   */\n  createPredictedShape(item, shapeType, shape) {\n    const predictedShape = this.createShape(this.currentLayer, this.rootStore.frame.imageBounds, item.colorConfig.color, item.instance.category, item.name, item, shapeType, shape, 9999,\n    // predicted shape always on the top\n    item.label);\n    predictedShape.borderStyle = BorderStyle.DASHED;\n    predictedShape.borderColor = 0xFFFF00;\n    if (predictedShape.shapeType === ShapeType.DOT) {\n      predictedShape.color = 0xFFFF00;\n    }\n    predictedShape.interactive = !this.rootStore.config.measureMode;\n    predictedShape.editable = this.rootStore.config.reviewMode === ReviewMode.LABELING;\n    if (this.rootStore.instance.selectedInstanceItems.indexOf(item) >= 0) {\n      predictedShape.selected = true;\n    }\n    // add listeners\n    this.addShapeListeners(predictedShape);\n    this.predictedShapes[predictedShape.uid] = {\n      shape: predictedShape,\n      instanceItem: item\n    };\n  }\n  /**\n   * reset recognition data\n   */\n  resetRecognition() {\n    this.recognitionStart = false;\n  }\n  /**\n   * setup recognizer\n   */\n  setupRecognizer() {\n    if (!this.recognizer) {\n      this.recognizer = new Recognizer();\n    }\n  }\n\n  /**\n   * load image for recognizer\n   */\n  async loadImageForRecognizer() {\n    if (this.recognizer) {\n      var _imageEmbeddings$curr, _imageEmbeddings$curr2;\n      const {\n        currentFrame,\n        currentFrameRotation,\n        currentCamera,\n        currentCameraImage,\n        imageEmbeddings,\n        getImageUrl\n      } = this.rootStore.frame;\n      let imageUrl = getImageUrl(currentCamera, currentFrame);\n      if (isPDFUrl(imageUrl) || isVideoUrl(imageUrl)) {\n        // TODO: current pdf not support\n        imageUrl = '';\n      }\n      await this.recognizer.setImage(this.rootStore.proxyResource(imageUrl), currentFrameRotation, this.rootStore.proxyResource((_imageEmbeddings$curr = imageEmbeddings[currentCamera]) === null || _imageEmbeddings$curr === void 0 ? void 0 : (_imageEmbeddings$curr2 = _imageEmbeddings$curr[currentFrame]) === null || _imageEmbeddings$curr2 === void 0 ? void 0 : _imageEmbeddings$curr2[currentCameraImage]));\n    }\n  }\n  /**\n   * get intersections for shape\n   * @param shape\n   */\n  getIntersectionsForShape(shape) {\n    const shapes = this.getShapesForCameraByLayer(this.rootStore.frame.currentCamera).map(i => i.shape).filter(s => s.visible && s.finished);\n    const intersections = shape.findIntersections(shapes);\n    return intersections;\n  }\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA, shapeB) {\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const {\n      instanceItem: instanceItemA\n    } = this.shapes[shapeA.uid];\n    const {\n      instanceItem: instanceItemB\n    } = this.shapes[shapeB.uid];\n    const instanceInfoA = instanceItemA.instance.getBasicInfo();\n    const instanceInfoB = instanceItemB.instance.getBasicInfo();\n\n    // save state\n    const prevInstances = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      });\n    } else {\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()]\n      });\n      prevInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()]\n      });\n    }\n    const storeId = this.rootStore.undo.preserve({\n      instances: prevInstances\n    });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    shapeA.order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    shapeB.order = orderA;\n    const currInstances = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      });\n    } else {\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()]\n      });\n      currInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()]\n      });\n    }\n    this.rootStore.undo.save(storeId, {\n      instances: currInstances\n    });\n  }\n\n  /**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */\n  moveToTop(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame,\n      getNextShapeOrder\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const {\n      layer\n    } = frameData;\n    const cameraShapes = this.getShapesForCameraByLayer(currentCamera, layer);\n    const maxOrder = Math.max(...cameraShapes.map(s => s.shape.order));\n    if (maxOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_FRONT_MOST'));\n      return;\n    }\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n    // preserve state\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }]\n    });\n    // update order\n    const order = getNextShapeOrder(layer);\n    frameData.order = order;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = order;\n    }\n    // save state\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }]\n    });\n    message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));\n  }\n\n  /**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */\n  moveToBottom(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame,\n      updateNextShapeOrder\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const {\n      layer\n    } = frameData;\n    const cameraShapes = this.getShapesForCameraByLayer(currentCamera, layer);\n    const minOrder = Math.min(...cameraShapes.map(s => s.shape.order));\n    if (minOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_BACK_MOST'));\n      return;\n    }\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n\n    // prev instance state map\n    const prevInstanceMap = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }\n    };\n    // update selected shape order\n    const startOrder = this.rootStore.segmentation.enabled ? 1 : 0;\n    frameData.order = startOrder;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = startOrder;\n    }\n    // current instance state map\n    const currInstanceMap = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }\n    };\n    if (minOrder <= startOrder) {\n      // show move all camera shapes upper\n      for (let i = 0; i < cameraShapes.length; i += 1) {\n        const {\n          shape: s,\n          instanceItem: sInstanceItem\n        } = cameraShapes[i];\n        if (sInstanceItem.id !== instanceItem.id) {\n          // not selected shape\n          const sInstanceInfo = sInstanceItem.instance.getBasicInfo();\n          const sInstanceItemInfo = sInstanceItem.getBasicInfo();\n          const sCameraData = sInstanceItem.cameras[currentCamera];\n          if (!prevInstanceMap[sInstanceInfo.id]) {\n            prevInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: []\n            };\n          }\n          prevInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()]\n          });\n          // update not selected shape's order\n          const order = s.order + 1;\n          sCameraData.frames[currentFrame].order = order;\n          s.order = order;\n          updateNextShapeOrder(order, layer, currentFrame, currentCamera);\n          if (!currInstanceMap[sInstanceInfo.id]) {\n            currInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: []\n            };\n          }\n          currInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()]\n          });\n        }\n      }\n    }\n\n    // save state\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap)\n    }, {\n      instances: Object.values(currInstanceMap)\n    });\n    message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));\n  }\n  mergeLines(baseLine, line) {\n    var _baseInstanceItem$cam;\n    const {\n      shape: baseShape,\n      instanceItem: baseInstanceItem\n    } = this.shapes[baseLine.id];\n    const {\n      shape,\n      instanceItem\n    } = this.shapes[line.id];\n    const mergingPoints = shape.points;\n    const basePoints = baseShape.points;\n    const newShapeData = {\n      points: baseLine.index === 0 ? [...(line.index === 0 ? mergingPoints.reverse() : mergingPoints), ...basePoints] : [...basePoints, ...(line.index === 0 ? mergingPoints : mergingPoints.reverse())]\n    };\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const {\n      prevState,\n      currState\n    } = this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame);\n    const {\n      autoInterpolation,\n      activeLayerIndex\n    } = this.rootStore.config;\n    const {\n      layer = activeLayerIndex\n    } = ((_baseInstanceItem$cam = baseInstanceItem.cameras[currentCamera]) === null || _baseInstanceItem$cam === void 0 ? void 0 : _baseInstanceItem$cam.frames[currentFrame]) || {};\n    const {\n      prevState: prevStateItem,\n      currState: currStateItem\n    } = baseInstanceItem.updateShape(currentCamera, currentFrame, autoInterpolation && baseShape.shapeType !== ShapeType.PIXEL, baseShape.shapeType, newShapeData, layer);\n    this.setupShape(baseInstanceItem);\n    this.selectShapeByInstanceItem(baseInstanceItem);\n    const basicInfo = baseInstanceItem.instance.getBasicInfo();\n    this.rootStore.undo.push({\n      instances: [...prevState.instances, ...(prevStateItem ? [{\n        ...basicInfo,\n        children: [prevStateItem]\n      }] : [])],\n      relationships: prevState.relationships\n    }, {\n      instances: [...currState.instances, ...(currStateItem ? [{\n        ...basicInfo,\n        children: [currStateItem]\n      }] : [])],\n      relationships: currState.relationships\n    });\n    message.success(i18n.translate('MERGE_SUCCESS'));\n  }\n  mergePolygons(polygonId1, polygonId2) {\n    const {\n      shape: polygon1,\n      instanceItem: instance1\n    } = this.shapes[polygonId1];\n    const {\n      shape: polygon2,\n      instanceItem: instance2\n    } = this.shapes[polygonId2];\n    const mergedData = polygon1.merge(polygon2);\n    if (mergedData.length === 1) {\n      var _instance1$cameras$cu;\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const {\n        prevState,\n        currState\n      } = this.rootStore.instance.deleteInstanceItemByFrame(instance2, currentFrame);\n      const {\n        autoInterpolation,\n        activeLayerIndex\n      } = this.rootStore.config;\n      const {\n        layer = activeLayerIndex\n      } = ((_instance1$cameras$cu = instance1.cameras[currentCamera]) === null || _instance1$cameras$cu === void 0 ? void 0 : _instance1$cameras$cu.frames[currentFrame]) || {};\n      const {\n        prevState: prevStateItem,\n        currState: currStateItem\n      } = instance1.updateShape(currentCamera, currentFrame, autoInterpolation, ShapeType.POLYGON, mergedData[0], layer, this.rootStore.frame.getNextShapeOrder(layer));\n      this.setupShape(instance1);\n      this.selectShapeByInstanceItem(instance1);\n      const basicInfo = instance1.instance.getBasicInfo();\n      this.rootStore.undo.push({\n        instances: [...prevState.instances, ...(prevStateItem ? [{\n          ...basicInfo,\n          children: [prevStateItem]\n        }] : [])],\n        relationships: prevState.relationships\n      }, {\n        instances: [...currState.instances, ...(currStateItem ? [{\n          ...basicInfo,\n          children: [currStateItem]\n        }] : [])],\n        relationships: currState.relationships\n      });\n      message.success(i18n.translate('MERGE_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('MERGE_WITH_HOLE'));\n    }\n  }\n  updatePolygons(currPolygonData, otherPolygonData) {\n    this.updateShapes(currPolygonData, otherPolygonData, ShapeType.POLYGON);\n  }\n  updateShapes(currShapeData, otherShapeData, shapeType = ShapeType.POLYGON) {\n    var _selectedInstanceItem, _this$rootStore$nifti2;\n    const selectedShape = this.selectedShapes[0];\n    const {\n      instanceItem: selectedInstanceItem\n    } = this.shapes[selectedShape.uid];\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const attributes = selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n    const area = calcShapeArea(shapeType, currShapeData);\n    if (area < this.rootStore.config.minArea) {\n      message.warning(i18n.translate('MIN_AREA_ALERT'));\n      this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItem, [currentFrame]);\n      return;\n    }\n    const prevBasicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const {\n      autoInterpolation,\n      activeLayerIndex\n    } = this.rootStore.config;\n    const {\n      layer = activeLayerIndex\n    } = ((_selectedInstanceItem = selectedInstanceItem.cameras[currentCamera]) === null || _selectedInstanceItem === void 0 ? void 0 : _selectedInstanceItem.frames[currentFrame]) || {};\n    const {\n      prevState: prevStateItem,\n      currState: currStateItem\n    } = selectedInstanceItem.updateShape(currentCamera, currentFrame, autoInterpolation && shapeType !== ShapeType.PIXEL, shapeType, currShapeData, layer, shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer), attributes);\n    if (shapeType === ShapeType.PIXEL) {\n      this.rootStore.segmentation.update(selectedInstanceItem, layer, currShapeData);\n    }\n    const basicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const instanceState = {\n      [basicInfo.id]: {\n        prev: {\n          ...prevBasicInfo,\n          children: prevStateItem ? [prevStateItem] : []\n        },\n        curr: {\n          ...basicInfo,\n          children: currStateItem ? [currStateItem] : []\n        }\n      }\n    };\n    this.setupShape(selectedInstanceItem);\n    (_this$rootStore$nifti2 = this.rootStore.nifti) === null || _this$rootStore$nifti2 === void 0 ? void 0 : _this$rootStore$nifti2.updateShape(selectedInstanceItem);\n    for (let i = 0; i < otherShapeData.length; i += 1) {\n      var _instanceItem$cameras12, _this$rootStore$nifti3;\n      if (calcShapeArea(shapeType, otherShapeData[i]) < this.rootStore.config.minArea && shapeType !== ShapeType.PIXEL) {\n        return;\n      }\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category, selectedInstanceItem.name);\n      const prevInfo = instanceItem.instance.getBasicInfo();\n      if (instanceItem.instance !== selectedInstanceItem.instance) {\n        var _selectedInstanceItem2, _selectedInstanceItem3;\n        instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);\n        const dynamicAttributesCurrentFrame = (_selectedInstanceItem2 = selectedInstanceItem.instance.dynamicAttributes) === null || _selectedInstanceItem2 === void 0 ? void 0 : (_selectedInstanceItem3 = _selectedInstanceItem2[currentCamera]) === null || _selectedInstanceItem3 === void 0 ? void 0 : _selectedInstanceItem3[currentFrame];\n        if (dynamicAttributesCurrentFrame && instanceItem.instance.categoryRef.labelConfigDynamic) {\n          instanceItem.instance.setDynamicAttributesByCamera(currentCamera, [dynamicAttributesCurrentFrame]);\n        }\n      }\n      const {\n        layer: shapeLayer = activeLayerIndex\n      } = ((_instanceItem$cameras12 = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras12 === void 0 ? void 0 : _instanceItem$cameras12.frames[currentFrame]) || {};\n      const {\n        prevState,\n        currState\n      } = instanceItem.updateShape(currentCamera, currentFrame, autoInterpolation && shapeType !== ShapeType.PIXEL, shapeType, otherShapeData[i], shapeLayer, shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(shapeLayer), attributes);\n      if (shapeType === ShapeType.PIXEL) {\n        this.rootStore.segmentation.update(instanceItem, shapeLayer, otherShapeData[i]);\n      }\n      this.setupShape(instanceItem);\n      (_this$rootStore$nifti3 = this.rootStore.nifti) === null || _this$rootStore$nifti3 === void 0 ? void 0 : _this$rootStore$nifti3.updateShape(instanceItem);\n      const currInfo = instanceItem.instance.getBasicInfo();\n      if (!instanceState[currInfo.id]) {\n        instanceState[currInfo.id] = {\n          prev: {\n            ...prevInfo,\n            children: []\n          },\n          curr: {\n            ...currInfo,\n            children: []\n          }\n        };\n      }\n      const state = instanceState[currInfo.id];\n      if (prevState) {\n        state.prev.children.push(prevState);\n      }\n      if (currState) {\n        state.curr.children.push(currState);\n      }\n    }\n    this.selectShapeByInstanceItem(selectedInstanceItem);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map(i => i.prev).filter(i => i.children.length > 0)\n    }, {\n      instances: Object.values(instanceState).map(i => i.curr)\n    });\n  }\n  startShapeCutting(cuttingMode) {\n    if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || !this.rootStore.instance.isSingleSelected || this.rootStore.segmentation.updatingShape) {\n      return;\n    }\n    const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n    if (isGridView && cuttingMode === 'split') {\n      return;\n    }\n    const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n    if (!(selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.editable)) {\n      return;\n    }\n    const isPolygon = (selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.shapeType) === ShapeType.POLYGON;\n    const isLine = (selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.shapeType) === ShapeType.LINE || (selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.shapeType) === ShapeType.ARROW;\n    const isPixel = (selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.shapeType) === ShapeType.PIXEL;\n    if (isPolygon || isLine || cuttingMode === 'split' && isPixel) {\n      this.clearPending(); // cancel merge\n      this.endShapeAppending(); // cancel append\n      this.finishUpdateShape(); // cancel update\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      const shape = selectedShape;\n      shape.isCutting = true;\n      if (isPolygon || isLine) {\n        shape.cuttingMode = cuttingMode;\n      }\n      if (cuttingMode === 'cut') {\n        this.cuttingShape = shape.uid;\n        this.splittingShape = '';\n      } else {\n        this.splittingShape = shape.uid;\n        this.cuttingShape = '';\n      }\n      this.selectedPointIndex = -1;\n      // update interactive\n      if (!isGridView) {\n        this.updateShapesInteractive(false, [shape.uid]);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(false, [shape.uid]);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(false);\n    }\n  }\n  endShapeCutting() {\n    if (!this.cuttingShape && !this.splittingShape) {\n      return;\n    }\n    const shapeId = this.cuttingShape || this.splittingShape;\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      if (shapeId) {\n        const shape = this.shapes[shapeId].shape;\n        if (shape) {\n          shape.isCutting = false;\n        }\n      }\n      this.updateShapesInteractive(true);\n    } else {\n      const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n      if ((selectedShape === null || selectedShape === void 0 ? void 0 : selectedShape.uid) === shapeId) {\n        selectedShape.isCutting = false;\n      }\n      this.rootStore.grid.updateShapesInteractive(true);\n    }\n    this.rootStore.relationship.updateConnectionsInteractive(true);\n    this.cuttingShape = '';\n    this.splittingShape = '';\n  }\n  /**\n   * update bounds for all shapes\n   */\n  updateShapesBounds() {\n    const {\n      boundaryCheck\n    } = this.rootStore.config;\n    const {\n      currentCamera,\n      imageBounds\n    } = this.rootStore.frame;\n    if (boundaryCheck) {\n      this.getShapesForCamera(currentCamera).forEach(({\n        shape\n      }) => {\n        shape.bounds = imageBounds;\n      });\n    }\n  }\n  /**\n   * start create shape on add mode changes\n   */\n  startCreateShape() {\n    const {\n      currentTool\n    } = this.rootStore.ontology;\n    const {\n      lineContinuous\n    } = this.rootStore.shape;\n    const {\n      viewMode\n    } = this.rootStore.config;\n    if (currentTool === Tool.PIXEL) {\n      let point;\n      if (this.rootStore.currPosition) {\n        point = new Point(this.rootStore.currPosition.x, this.rootStore.currPosition.y);\n      }\n      if (viewMode === ViewMode.DEFAULT) {\n        this.addShape(point);\n        this.rootStore.segmentation.currMode = PixelToolMode.PLUS;\n      }\n    } else if (currentTool === Tool.LINE && lineContinuous) {\n      if (viewMode === ViewMode.DEFAULT) {\n        this.addShape();\n      }\n    } else if (currentTool === Tool.KEYPOINTS) {\n      var _this$rootStore$ontol, _config$groups, _config$groups$, _config$groups$$range;\n      const config = (_this$rootStore$ontol = this.rootStore.ontology.currentToolItem) === null || _this$rootStore$ontol === void 0 ? void 0 : _this$rootStore$ontol.config;\n      const startPointKey = config === null || config === void 0 ? void 0 : (_config$groups = config.groups) === null || _config$groups === void 0 ? void 0 : (_config$groups$ = _config$groups[0]) === null || _config$groups$ === void 0 ? void 0 : (_config$groups$$range = _config$groups$.range) === null || _config$groups$$range === void 0 ? void 0 : _config$groups$$range[0];\n      if (startPointKey !== undefined) {\n        this.selectedPointIndex = startPointKey;\n      }\n    }\n  }\n\n  /**\n   * cancel creating shape\n   */\n  cancelCreateShape() {\n    if (this.drawingShape && this.drawingShape.shapeType === ShapeType.PIXEL) {\n      // cancel\n      this.drawingShape.destroy();\n      this.drawingShape = null;\n    }\n  }\n\n  /**\n   * toggle to show curve discrete points\n   */\n  toggleCurveDiscretePointsVisibility() {\n    this.showCurveDiscretePoints = !this.showCurveDiscretePoints;\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Curve) {\n          shape.showDiscretePointsHint = this.showCurveDiscretePoints;\n        }\n      });\n    } else {\n      this.rootStore.grid.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Curve) {\n            shape.showDiscretePointsHint = this.showCurveDiscretePoints;\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * set side ratio visibility\n   * ---- FIXME: customized for specific project\n   * ---- PID: A5764\n   */\n  setSideRatioVisibility(visible) {\n    this.showSideRatio = visible;\n    cache.set(CacheKey.SIDE_RATIO_VISIBILITY, `${visible}`);\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape.shapeType === ShapeType.POLYGON) {\n          shape.showSideRatio = visible;\n        }\n      });\n    } else {\n      this.rootStore.grid.grids.forEach(grid => {\n        Object.values(grid.shapes).forEach(({\n          shape\n        }) => {\n          if (shape.shapeType === ShapeType.POLYGON) {\n            shape.showSideRatio = visible;\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * get side ratio visibility\n   * ---- FIXME: customized for specific project\n   * ---- PID: A5764\n   */\n  getSideRatioVisibility() {\n    const storedValue = cache.get(CacheKey.SIDE_RATIO_VISIBILITY);\n    if (storedValue && storedValue === 'true') {\n      this.showSideRatio = true;\n    } else {\n      this.showSideRatio = false;\n    }\n  }\n  /**\n   * project all shapes in current frame\n   */\n  async projectShapes() {\n    if (!this.rootStore.frame.camerasMapping.projectEnabled) {\n      return;\n    }\n    const allShapes = Object.values(this.shapes);\n    if (allShapes.length <= 0) {\n      return;\n    }\n    return Promise.all(allShapes.map(({\n      shape,\n      camera\n    }) => this.projectShape(shape, camera)));\n  }\n\n  /**\n   * project shape in current frame from base camera to camera\n   * @param shape\n   * @param baseCamera\n   * @param toCameras\n   */\n  async projectShape(shape, baseCamera = this.rootStore.frame.currentCamera, toCameras = this.rootStore.frame.cameraNames) {\n    const {\n      camerasMapping,\n      currentFrame,\n      cameraViews,\n      getImageBoundsForCamera,\n      getFrameRotationForCamera\n    } = this.rootStore.frame;\n    if (!camerasMapping.projectEnabled || !this.shapes[shape.uid] || shapeTypesSupportProject.indexOf(shape.shapeType) < 0) {\n      return;\n    }\n    const {\n      points\n    } = shape;\n    const {\n      width: baseCameraWidth,\n      height: baseCameraHeight\n    } = cameraViews[baseCamera].image;\n    const baseCameraRotation = getFrameRotationForCamera(baseCamera, currentFrame);\n    const baseCameraMatrix = getMatrixByRotation(baseCameraRotation, baseCameraWidth, baseCameraHeight);\n    const originPoints = points.map(p => {\n      if (baseCameraRotation !== 0) {\n        const op = calcPositionByMatrix(p, inv(baseCameraMatrix));\n        return [op.x, op.y];\n      }\n      return [p.x, p.y];\n    });\n    return Promise.all(toCameras.map(async toCamera => {\n      var _this$projectedShapes;\n      if (toCamera === baseCamera) {\n        // do not project to self camera\n        return;\n      }\n      if (!camerasMapping.isProjectAvailable(currentFrame)) {\n        // show loading if current not available\n        this.projecting = true;\n      }\n      const projectedPoints = await camerasMapping.projectPoints(originPoints, currentFrame, baseCamera, toCamera);\n      const {\n        width: toCameraWidth,\n        height: toCameraHeight\n      } = cameraViews[toCamera].image;\n      const toCameraRotation = getFrameRotationForCamera(toCamera, currentFrame);\n      const toCameraMatrix = getMatrixByRotation(toCameraRotation, toCameraWidth, toCameraHeight);\n      const projectedShapePoints = projectedPoints.map(p => {\n        const point = {\n          x: p[0],\n          y: p[1]\n        };\n        if (toCameraRotation !== 0) {\n          const rp = calcPositionByMatrix(point, toCameraMatrix);\n          point.x = rp.x;\n          point.y = rp.y;\n        }\n        return point;\n      });\n      const existingProjectedShape = (_this$projectedShapes = this.projectedShapes[shape.uid]) === null || _this$projectedShapes === void 0 ? void 0 : _this$projectedShapes[toCamera];\n      if (existingProjectedShape) {\n        // update\n        existingProjectedShape.points = projectedShapePoints;\n        existingProjectedShape.selected = shape.selected;\n      } else {\n        var _instanceItem$cameras13;\n        // create\n        const {\n          instanceItem\n        } = this.shapes[shape.uid];\n        const frameData = (_instanceItem$cameras13 = instanceItem.cameras[baseCamera]) === null || _instanceItem$cameras13 === void 0 ? void 0 : _instanceItem$cameras13.frames[currentFrame];\n        if (frameData) {\n          const {\n            shapeType,\n            order\n          } = frameData;\n          const layer = frameData.layer !== undefined ? frameData.layer : this.rootStore.config.activeLayerIndex;\n          const projectedShapeData = {\n            points: projectedShapePoints\n          };\n          const projectedShape = this.createShape(cameraViews[toCamera].getShapesLayerByIndex(layer), getImageBoundsForCamera(toCamera, currentFrame), instanceItem.colorConfig.color, instanceItem.instance.category, instanceItem.name, instanceItem, shapeType, projectedShapeData, order, i18n.translate('PROJECTED_SHAPE_LABEL', {\n            values: {\n              label: instanceItem.label\n            }\n          }), toCamera);\n          if (projectedShape.destroyed) {\n            return;\n          }\n          projectedShape.on(EventAction.SELECTED, () => {\n            // when projected shape selected\n            this.rootStore.instance.selectInstanceItem(instanceItem);\n            // fit source shape\n            this.fitProjectShape(shape, baseCamera);\n            // fit projected shapes in other cameras\n            Object.keys(this.projectedShapes[shape.uid]).forEach(c => {\n              if (c !== toCamera) {\n                this.fitProjectShape(this.projectedShapes[shape.uid][c], c);\n              }\n            });\n          });\n          projectedShape.on(EventAction.REMOVED, () => {\n            // when projected removed (not valid anymore)\n            if (this.projectedShapes[shape.uid]) {\n              // delete the projected shape\n              delete this.projectedShapes[shape.uid][toCamera];\n            }\n          });\n\n          // TODO: should set editable by cameras config, current is always not editable\n          projectedShape.editable = false;\n          projectedShape.selected = shape.selected;\n\n          // add to projected shapes map\n          if (!this.projectedShapes[shape.uid]) {\n            this.projectedShapes[shape.uid] = {};\n          }\n          this.projectedShapes[shape.uid][toCamera] = projectedShape;\n          if (shape.selected) {\n            // auto focus when shape selected & first created\n            this.fitProjectShape(projectedShape, toCamera);\n          }\n        }\n      }\n      this.projecting = false;\n    }));\n  }\n\n  /**\n   * fit projected shape to camera view\n   * @param shape\n   * @param camera\n   */\n  fitProjectShape(shape, camera) {\n    if (this.rootStore.config.preferences.zoomTogether && camera !== this.rootStore.frame.currentCamera) {\n      // not fit project shape when zoom together on & not current camera\n      return;\n    }\n    const cameraView = this.rootStore.frame.cameraViews[camera];\n    if (cameraView) {\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = shape.shapeBounds;\n      cameraView.fitShapeToView({\n        left,\n        top,\n        right,\n        bottom\n      }, 0.5);\n    }\n  }\n\n  /**\n   * reproject shapes\n   * @param camera\n   */\n  reprojectShapesByCamera(camera = this.rootStore.frame.currentCamera) {\n    Object.keys(this.projectedShapes).forEach(sourceShapeId => {\n      const projectedShape = this.projectedShapes[sourceShapeId][camera];\n      if (projectedShape) {\n        const sourceShape = this.shapes[sourceShapeId];\n        if (sourceShape) {\n          this.projectShape(sourceShape.shape, sourceShape.camera, [camera]);\n        }\n      }\n    });\n  }\n  /**\n   * start multi resize\n   */\n  enterMultiShapesResize() {\n    if (this.shapesResizer || this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.rootStore.config.addMode || this.rootStore.instance.reorganizingInstance || this.rootStore.segmentation.updatingShape || this.rootStore.config.viewMode !== ViewMode.DEFAULT) {\n      return;\n    }\n    const {\n      currentFrame,\n      currentCamera\n    } = this.rootStore.frame;\n    let keepRatio = false;\n    const resizableShapes = this.selectedShapes.filter(s => {\n      var _instanceItem$cameras14;\n      if (s.shapeType === ShapeType.RECTANGLE && s.rotation !== 0 || s.shapeType === ShapeType.ELLIPSE && s.rotation !== 0 || s.shapeType === ShapeType.SQUARE || s.shapeType === ShapeType.CIRCLE || s.shapeType === ShapeType.RECTANGLE && s.ratio !== undefined) {\n        keepRatio = true;\n      }\n      if (s.shapeType === ShapeType.PIXEL || s.shapeType === ShapeType.KEYPOINTS) {\n        return false;\n      }\n      const {\n        instanceItem,\n        camera\n      } = this.shapes[s.uid] || {};\n      if (camera !== currentCamera) {\n        return false;\n      }\n      // check if is locked\n      const frameData = instanceItem === null || instanceItem === void 0 ? void 0 : (_instanceItem$cameras14 = instanceItem.cameras[camera]) === null || _instanceItem$cameras14 === void 0 ? void 0 : _instanceItem$cameras14.frames[currentFrame];\n      return frameData && !frameData.locked;\n    });\n    const resizableShapesBounds = calcBoundsByShapes(resizableShapes);\n    if (resizableShapesBounds) {\n      this.updateShapesInteractive(false);\n      this.shapesResizer = new MultiShapesResizer({\n        shapes: resizableShapes,\n        shapesBounds: resizableShapesBounds,\n        container: this.currentLayer,\n        scale: this.rootStore.frame.currentCameraView.viewScale,\n        ...(this.rootStore.config.boundaryCheck && {\n          bounds: this.rootStore.frame.imageBounds\n        }),\n        keepRatio\n      });\n      this.shapesResizer.on(ResizeAction.RESIZED, changedShapes => {\n        const instanceItems = [];\n        changedShapes.forEach(i => {\n          const shapeItem = this.shapes[i.uid];\n          if (shapeItem) {\n            instanceItems.push({\n              instanceItem: shapeItem.instanceItem,\n              frameIndex: currentFrame,\n              shapeType: i.shapeType,\n              shape: i.getData()\n            });\n          }\n          this.projectShape(i);\n        });\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      });\n    }\n  }\n\n  /**\n   * finish multi resize\n   */\n  exitMultiShapesResize() {\n    if (this.shapesResizer) {\n      this.shapesResizer.destroy();\n      this.shapesResizer = undefined;\n      this.updateShapesInteractive(true);\n    }\n  }\n}","map":{"version":3,"names":["React","ReactDOM","Point","makeObservable","observable","action","message","debounce","isEqual","inv","deflate","inflate","simplify","randomColor","InspectLabel","i18n","getUnderShape","getUpperShape","parseFields","calcShapeArea","isAttributesPassCondition","isPDFUrl","isVideoUrl","Tool","ViewMode","LabelItem","ReviewMode","CameraLayout","CVModel","PolygonCreateMethod","PixelToolMode","ShapeFocusMode","PredictiveMode","SoloMode","ContinuousModeType","CAMERA_VIEW_LABELS","ShapeFactory","ShapeType","EventAction","BorderStyle","ShapeRotateMode","ShapeRotateHandleMode","Rectangle","RectType","Polygon","PolygonType","QuadPrism","OrientedQuadPrism","Line","HoverMode","LineType","Curve","Dot","Keypoints","Pixel","PixelEventAction","Label","MultiShapesResizer","ResizeAction","calcBoundsByShapes","Cursor","getFieldDisplayLabel","computeRotatedPosition","precise","getMatrixByRotation","calcPositionByMatrix","Recognizer","cache","CacheKey","tracker","TrackEventName","createLabelPrefix","APIForwardType","PixelsData","fillMask","resolveMask","rotateMask","shapeTypesSupportProject","LINE","POLYGON","ShapeStore","isDrawing","drawingShape","constructor","rootStore","app","currentLayer","shapes","shapesFrame","previousLineEndPoint","lineContinuous","visibleShapeIds","recognizer","recognitionStart","selectedShapes","selectedPointIndex","shapesResizer","predictedShapes","projectedShapes","hoveredShapeId","pendingMergePolygon","pendingMergeLine","pendingMergePixel","cuttingShape","splittingShape","appendingShape","updatingShape","deleting","pointsMoving","shapesMoving","projecting","shapesRefreshCounter","config","fill","alpha","borderAlpha","borderWidth","dotRadius","showSideLength","showDirection","showVertex","showVertexOrder","vertexSize","vertexStart","defaultConfig","showCurveDiscretePoints","showSideRatio","creatingShapeColor","cachedPredictInfo","clearShapes","Object","values","forEach","shape","destroy","frame","currentFrame","clearPredictedShapes","clearProjectedShapes","cameraShapes","isPredictedShape","s","findIndex","getShapeByInstanceItem","instanceItem","camera","currentCamera","shapeItem","find","i","undefined","getShapesByInstanceItems","instanceItems","shapeItems","filter","indexOf","map","getShapesForCamera","onlyKeepEditable","editable","getShapesForCameraByLayer","layer","activeLayerIndex","allShapes","layerShapes","length","_shape$instanceItem$c","shapeLayer","cameras","frames","push","updateShapesInteractive","interactive","ignoreIds","includes","uid","selected","updateShapesUserDataMode","userDataMode","updateShapesRotateMode","shapeRotateMode","rotateMode","updateShapesRotateHandleMode","shapeRotateHandleMode","rotateHandleMode","updateShapesShowAuxiliaryLines","showAuxiliaryLines","updatePixelShapesShowBounds","showPixelShapeBounds","showShapeBounds","updateShapesDoubleClickFinish","dblclickFinish","shapeType","PIXEL","updateRectangleShapesAutoSnapTolerance","tolerance","autoSnapTolerance","redrawShapesLabel","drawShapeLabel","setupShapes","cameraViews","currentFrameByCamera","cameraNames","getImageBoundsForCamera","layersCount","layers","allShapeOrders","noOrderShapes","cameraName","Set","startOrder","segmentation","enabled","instance","instances","items","item","cameraView","cameraFrame","imageLoadError","frameData","createShape","getShapesLayerByIndex","colorConfig","color","category","name","order","label","setShapeColorConifg","fillColor","edgeColor","borderColor","pointColor","vertexColor","destroyed","deleteInstanceItemByFrame","area","minArea","annotatable","deleteShape","readonly","locked","measureMode","isPreAnnotation","_shape$labelDom","labelDom","setPrefix","setShapeStyles","addShapeListeners","update","savedShapeData","currShapeData","getData","has","add","keys","layerIndex","getNextShapeOrder","frameIndex","projectShapes","formatPointLabel","data","categoryName","categoryItemName","pointLabelConfig","ontology","getPointLabelConfigFromCategoryItem","fieldsMap","labels","pointLabelItems","key","field","fieldValue","ATTRIBUTE_KEYS","ATTRIBUTE_VALUES","displayValue","l","join","getPointStyle","pointIndex","pointType","categoryItem","getCategoryItem","pointLabelConfigGroups","some","g","attributes","styles","parseInt","substr","type","dataKeyLen","hotkeyMap","affected","pointShape","attrKeys","getToolPointsStylesByCategoryItem","pointsColor","pointsType","getEdgeStyle","startPointIndex","edgeType","edgeBold","bold","getToolEdgesStylesByCategoryItem","edgesColor","edgesType","edgesBold","getShapeStyle","dotColor","dotType","borderType","borderBold","vertexType","labelConfig","labelConfigGroups","getToolFillByCategoryItem","_instanceItem$colorCo","pointsStyles","edgesStyles","getToolStylesByCategoryItem","_instanceItem$colorCo2","_instanceItem$colorCo3","displayColor","displayColorString","_instanceItem$cameras","DOT","originColors","RECTANGLE","SQUARE","ARROW","KEYPOINTS","shapeContainer","imageBounds","hexColor","shapeData","_this$rootStore$frame","boundaryCheck","dataPrecision","draggable","rotatable","autoSnap","activePointAttributesMode","preferences","HANDLE","SELECTED","currentToolItem","currentTool","currentShapeType","currentCreateMethod","getToolConfigByCategoryItem","useCurrent","controlsContainer","parent","toolConfig","shapeStyles","getShape","container","bounds","autoSnapEnabled","ELLIPSE","CENTERLINE_RECTANGLE","centerLineEnabled","FOUR_DOTS_RECTANGLE","rectType","FOUR_DOTS_RECT","OBJECT_DETECTION","RECOGNITION","OBJECT_DETECTION_MULTI","RECOGNITION_MULTI","SEGMENTATION","lineType","polygonType","RECT","edges","defaultEdges","CURVE","FLEX_LINE","pixelType","currPixelType","brushRadius","currBrushRadius","canPixelUpdate","showShapeAuxiliaryLines","viewMode","DEFAULT","createShapeLabel","scale","viewScale","x","userDataFormatter","pointStyler","pIndex","edgeStyler","pointKey","render","createElement","shapeId","additionalContainer","rotation","showDiscretePointsHint","validateShape","endShapeCutting","deleteFramesFromInstanceItem","warning","translate","selectShapes","updatingShapeCurrentSelected","segShapeCurrentSelected","projectedShape","updatingShapeShouldSelected","segShapeShouldSelected","projectCamera","fitProjectShape","finishUpdateShape","cancelUpdate","cancelSwitch","selectShapeByInstanceItem","shouldPredict","Array","isArray","updateActiveLayerIndexByInstanceItems","instancesSet","updateShapesInInstance","from","predict","hideOrShowOthers","unselectShape","addMode","isWorkingOnAnyShape","clearPendingWithAlert","cancelShapeWorking","selectInstance","setSelectedPoints","shapePointsMap","count","setSelectedShapes","shapeIds","selectInstanceItem","updateLineEndPoint","instanceItemId","instanceId","getLineEndPoint","_this$previousLineEnd","_this$previousLineEnd2","endPoint","lastPointInfo","_lastInstance$items","lastInstanceId","lastInstanceItemId","lastInstance","getInstanceById","lastInstanceItem","_lastInstanceItem$cam","_lastInstanceItem$cam2","_lastInstanceItem$cam3","points","lastPoints","addShape","point","event","initialized","selectedCategoryName","selectedCategoryItemName","getCurrentInstanceItem","selectedCategoryItem","on","FINISHED","otherShapeData","off","REMOVED","isPixel","isKeypoints","shouldContinue","continuousMode","setAddMode","addShapeToCurrentInstanceItem","report","CREATE_SHAPE","elementName","extra","continuousModeType","IN_INSTANCE","selectNextCategoryItem","updateShape","startUpdateShape","onRecognize","controls","currentOptions","y","newPoint","create","selectedPointKey","shapeColor","_this$rootStore$nifti","prevBasicInfo","getBasicInfo","autoInterpolation","prevState","prevStateItem","currState","currStateItem","isOCRTool","isFormulaTool","id","basicInfo","instanceState","prev","children","curr","relationshipState","_otherInstanceItem$ca","otherInstanceItem","prevInfo","setAttributes","setupShape","currInfo","state","stat","undo","relationships","autoOpenAttributesModal","projectShape","nifti","addShapeToInstanceItem","currentCameraView","cameraData","shapeInfo","predictedItem","predictShape","newData","resolvePixelShapeData","updateFrameShapeForInstanceItem","activeShapesLayer","updateShapesRefreshCounter","setCamera","addShapesToInstances","index","existedCameras","newInstanceItems","generateInstanceItemsFromPredict","concat","updateFrameShapeForInstanceItems","addShapesToInstance","_cameraViews$camera","existingShape","originInteractive","existingShapeId","_shape$labelDom2","relationship","setupConnectionsForInstanceItem","autoTracking","GRID","filterMode","isMultiSelected","selectedInstances","selectedInstanceItems","selectedInstance","predictiveMode","NONE","predictInstance","SELECTED_INSTANCE","predictiveItems","segmentPredictiveItems","createPredictedShape","segmentPredict","_item$cameras$current","_item$cameras$current2","predictShapeByModel","delete","selectedShape","getSelectedShape","pixelSegDeleted","deleteSelectedPolygon","selectedPolygonIndex","pointsDeletedShapes","deleted","deleteSelectedPoints","deleteFramesFromInstanceItems","filterInstances","splice","deleteShapeByInstanceItem","setCursor","currCursor","requestRecognition","loading","setTimeout","setupRecognizer","loadImageForRecognizer","Error","left","top","right","bottom","rSize","p1","p2","Math","max","min","width","height","recognizedBoxes","detect","finishMultiObjectsDetection","recognizedBox","recognizedDis2","box","dis2","finishRecognition","recognizedPixels","segment","pixelsData","isEmpty","setRecognizedPolygon","cachedPolygons","pixels","e","error","finishCreate","boxes","prevInstanceMap","currInstanceMap","affectedInstanceItems","openAttributesModalForInstanceItems","setPointsUserDataByHotkey","hotkey","hotkeyItems","pointHotkeyMap","selectedPoints","getSelectedPoints","pointsData","userData","setPointsUserData","setPointUserData","moveFront","toTop","moveToTop","intersections","getIntersectionsForShape","upperShape","exchangeShapeOrder","success","moveBack","toBottom","moveToBottom","underShape","info","clearPending","clearPendingLine","hoverMode","merge","isAnyModalOpened","cancel","intersectPolygonIds","findIntersectPolygons","mergePolygons","warn","ENDPOINT","selectedSegmentIndex","subtractPolygon","selectedPolygon","intersectPolygons","subtractedData","subtract","updatePolygons","slice","d","updateConfig","updateShapesFill","grid","updateShapesAlpha","updateShapesBorderAlpha","updateShapesBorderWidth","updateDotsRadius","updateShowSideLength","updateShowDirection","updateShowVertex","updateShowVertexOrder","updateVertexSize","set","SHAPE_STYLES","fillAlpha","previewMode","updatePreviewModeAlpha","shapesLayer","cacheAsBitmap","resetConfig","toggleShapeCut","cuttingMode","startShapeCutting","rotateShapesByCanvas","center","offsetX","offsetY","imageWidth","imageHeight","matrix","_instanceItem$cameras2","rect","c","r","rotatedCenter","PI","QUAD_PRISM","ORIENTED_QUAD_PRISM","p","rp","rc","CURVE_PAIR","pairs","rp1","rp2","PARALLELOGRAM","ellipse","halfWidth","halfHeight","CIRCLE","circle","CUBOID","TWO_SIDES_CUBOID","cuboid","x1","y1","w1","h1","x2","y2","w2","h2","rotatedCenter1","rotatedCenter2","fw","fh","bw","bh","setData","front","back","LSHAPE","lshape","w","h","sx1","sy1","sx2","sy2","abs","dot","rotatedPoint","cols","rows","gridCenter","c0","r0","pixel","newPixels","t","b","allX","yList","allY","j","px","py","drawShape","reprojectShapesByCamera","hideOthers","hideAll","layersVisible","isOpen","hideOthersIsOpen","mode","hideOthersMode","filteredInstances","updated","document","getElementById","hide","_instanceItem$cameras3","_filteredInstances$in","_filteredInstances$in2","_filteredInstances$in3","INSTANCE","ITEM","_i$cameras$camera","fromInstanceItem","toInstanceItem","visible","style","visibility","hideOrShowRelationships","review","hideOrShowReviews","cameraLayout","THUMBNAIL","toggleLineAppend","endShapeAppending","startShapeAppending","isSingleSelected","isGridView","getCurrentSelectedShape","append","currPosition","updateConnectionsInteractive","isCancel","finishAppend","check","_shapeItem$shape","finishUpdate","reverse","isDefaultView","toggleLineContinuous","TOOL_LINE_CREATE_FROM_PREVIOUS_END_POINT","initLineContinuous","get","updateShapeLockedState","_shape","_this$pendingMergeLin","_shape2","_shape3","_shape4","_shape5","_shape6","_this$rootStore$segme","_shape7","selectedInstanceItem","_instanceItem$cameras4","_instanceItem$cameras5","matrixChangeAllowed","init","resetRecognition","num","initShapeStylesConfig","payload","localShapeStylesConfig","is_fill","fill_opacity","Number","isNaN","border_opacity","border_width","dot_size","show_side_length","show_direction","show_vertex","show_vertex_order","vertex_size","vertex_start","updateShapesEditable","_instanceItem$cameras6","_instanceItem$cameras7","shapeLabelsContainer","shapeLabel","className","transPosition","toLocal","addToContainer","options","settingRelationship","isReorganizing","reorganizingInstance","reorganizingInstanceItemName","shiftKey","ss","tryReorganize","predictedShape","updateSelectedInstanceItem","selectCategory","selectCategoryItem","addReview","syncNIFTIViews","CHANGED","cuttingOtherPolygon","cuttingOtherPixels","updateShapes","cuttingOtherLine","_shapeItem$instanceIt","_shapeItem$instanceIt2","normalize","_shapeItem$instanceIt3","_shapeItem$instanceIt4","hasEmptyPoint","POINTER_OVER","onShapeHovered","POINTER_OUT","VERTEX_SELECTED","mergeLines","RESIZING","deltaX","deltaY","otherSelectedPolygonsAndLines","_instanceItem$cameras8","_instanceItem$cameras9","updateSelectedPointsPosistion","DRAGGING","otherSelectedShapes","_instanceItem$cameras0","_instanceItem$cameras1","updatePosition","position","CONTEXT_MENU","openContextMenu","HOVERED_POLYGON_CHANGE","updateHoveredSegmentIndex","SELECTED_POLYGON_CHANGE","updateSelectedSegmentIndex","fitShapes","shapeBounds","bbox","shapeFocusMode","ZOOM","fitShapeToView","moveShapeToViewCenter","modelPrediction","getImageUrl","getFrameRotationForCamera","baseFrame","_item$cameras$current3","baseShapes","_instanceItem$cameras10","shapesByLayer","masksByLayer","activeMask","_this$cachedPredictIn","_this$cachedPredictIn2","originMask","sameMask","targetFrame","mask","buffer","compressed","Uint8Array","file","File","formData","FormData","predictProxy","fetch","method","body","then","res","arrayBuffer","_this$rootStore$jobPr","jobProxy","forwardAPI","FRAME_SEGMENTATION","_this$cachedPredictIn3","currRotation","currWidth","currHeight","decompressed","currMask","activeShapes","_instanceItem$cameras11","alreadyExist","pixelData","size","polygons","borderStyle","DASHED","reviewMode","LABELING","_imageEmbeddings$curr","_imageEmbeddings$curr2","currentFrameRotation","currentCameraImage","imageEmbeddings","imageUrl","setImage","proxyResource","finished","findIntersections","shapeA","shapeB","orderA","orderB","instanceItemA","instanceItemB","instanceInfoA","instanceInfoB","prevInstances","toJSON","storeId","preserve","currInstances","save","maxOrder","instanceInfo","instanceItemInfo","updateNextShapeOrder","minOrder","sInstanceItem","sInstanceInfo","sInstanceItemInfo","sCameraData","baseLine","line","_baseInstanceItem$cam","baseShape","baseInstanceItem","mergingPoints","basePoints","newShapeData","polygonId1","polygonId2","polygon1","instance1","polygon2","instance2","mergedData","_instance1$cameras$cu","currPolygonData","otherPolygonData","_selectedInstanceItem","_this$rootStore$nifti2","_instanceItem$cameras12","_this$rootStore$nifti3","_selectedInstanceItem2","_selectedInstanceItem3","dynamicAttributesCurrentFrame","dynamicAttributes","categoryRef","labelConfigDynamic","setDynamicAttributesByCamera","isPolygon","isLine","isCutting","updateShapesBounds","startCreateShape","currMode","PLUS","_this$rootStore$ontol","_config$groups","_config$groups$","_config$groups$$range","startPointKey","groups","range","cancelCreateShape","toggleCurveDiscretePointsVisibility","grids","setSideRatioVisibility","SIDE_RATIO_VISIBILITY","getSideRatioVisibility","storedValue","camerasMapping","projectEnabled","Promise","all","baseCamera","toCameras","baseCameraWidth","baseCameraHeight","image","baseCameraRotation","baseCameraMatrix","originPoints","op","toCamera","_this$projectedShapes","isProjectAvailable","projectedPoints","projectPoints","toCameraWidth","toCameraHeight","toCameraRotation","toCameraMatrix","projectedShapePoints","existingProjectedShape","_instanceItem$cameras13","projectedShapeData","zoomTogether","sourceShapeId","sourceShape","enterMultiShapesResize","keepRatio","resizableShapes","_instanceItem$cameras14","ratio","resizableShapesBounds","shapesBounds","RESIZED","changedShapes","exitMultiShapesResize"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/ShapeStore.ts"],"sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Application, Container, Point } from 'pixi.js';\nimport { makeObservable, observable, action } from 'mobx';\nimport { message } from 'antd';\nimport { debounce, isEqual } from 'lodash';\nimport { inv } from 'mathjs';\nimport { deflate, inflate } from 'pako';\nimport simplify from 'simplify-js';\nimport randomColor from 'randomcolor';\n// import { APIForwardType } from 'src/libs/JobProxy';\nimport InspectLabel from '../components/attributes/InspectLabel';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport FrameData from '../model/FrameData';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape, parseFields, calcShapeArea, isAttributesPassCondition, isPDFUrl, isVideoUrl } from '../utils';\nimport { Payload, Tool, ViewMode, LabelItem, Instance as IInstance, ReviewMode, CameraLayout, CVModel, PolygonCreateMethod, Relationship as IRelationship, PixelToolMode, ShapeFocusMode, PredictiveMode, SoloMode, ContinuousModeType, KeypointsConfig } from '../types';\nimport { CAMERA_VIEW_LABELS } from '../constants';\nimport ShapeFactory from '../../common/shapes/ShapeFactory';\nimport { ShapeType, ShapeData, ShapeVertexType, ShapeLineType, ShapeDataWithArea } from '../../common/shapes/types';\nimport Shape, { EventAction, UserDataMode, BorderStyle, ShapeRotateMode, ShapeRotateHandleMode } from '../../common/shapes/Shape';\nimport Rectangle, { RectType, RectangleData } from '../../common/shapes/Rectangle';\nimport Polygon, { PolygonData, PolygonType } from '../../common/shapes/Polygon';\nimport Parallelogram from '../../common/shapes/Parallelogram';\nimport Ellipse from '../../common/shapes/Ellipse';\nimport Circle from '../../common/shapes/Circle';\nimport Cuboid from '../../common/shapes/Cuboid';\nimport LShape from '../../common/shapes/LShape';\nimport QuadPrism from '../../common/shapes/QuadPrism';\nimport OrientedQuadPrism from '../../common/shapes/OrientedQuadPrism';\nimport Line, { HoverMode, IPoint, LineData, LineType } from '../../common/shapes/Line';\nimport Curve from '../../common/shapes/Curve';\nimport CurvePair from '../../common/shapes/CurvePair';\nimport Dot from '../../common/shapes/Dot';\nimport Grid from '../../common/shapes/Grid';\nimport Arrow from '../../common/shapes/Arrow';\nimport FlexLine from '../../common/shapes/FlexLine';\nimport TwoSidesCuboid from '../../common/shapes/TwoSidesCuboid';\nimport Keypoints from '../../common/shapes/Keypoints';\nimport Pixel, { PixelData, PixelEventAction } from '../../common/shapes/Pixel';\nimport Label from '../../common/shapes/label/Label';\nimport MultiShapesResizer, { ResizeAction, calcBoundsByShapes } from '../../common/shapes/resizers/MultiShapesResizer';\nimport Cursor from '../../common/Cursor';\nimport { getFieldDisplayLabel } from '../../../utils/form';\nimport { computeRotatedPosition, precise } from '../../../utils/math';\nimport { getMatrixByRotation, calcPositionByMatrix } from '../../../utils/matrix';\nimport Recognizer, { ControlPoint } from '../../../model/Recognizer';\nimport cache, { CacheKey } from '../utils-storage';\nimport tracker, { TrackEventName } from '../../../utils/tracker';\nimport createLabelPrefix from '../shapes/LabelPrefix';\nimport { APIForwardType } from '../../../libs/JobProxy';\nimport PixelsData from '../../../utils/pixels';\nimport { PredictBaseShape, fillMask, resolveMask, rotateMask } from '../utils-predict';\n\nconst shapeTypesSupportProject = [\n  ShapeType.LINE,\n  ShapeType.POLYGON,\n];\ntype ShapeSupportProject = Line | Polygon;\ntype ShapeDataSupportProject = LineData | PolygonData;\n\n/**\n * store for shapes in current camera & current frame\n * @class\n */\nexport default class ShapeStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * app\n   */\n  app?: Application;\n\n  /**\n   * current layer\n   */\n  currentLayer?: Container;\n\n  /**\n   * shapes in current frame\n   */\n  shapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      camera: string;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * cache current frame (used in callbacks to avoid frame changes but shapes not update issues)\n   */\n  shapesFrame = 0;\n\n  /**\n   * the end point of the previous line segment in different camera and frame\n   */\n  previousLineEndPoint: {\n    [cameraName: string]: {\n      [frameIndex: number]: {\n        instanceId: string;\n        instanceItemId: string;\n      }\n    }\n  } | null = null;\n\n  /**\n   * Whether to use the last point of the previous graph of the same type as the starting point（current only line）\n   */\n  lineContinuous = false;\n\n  /**\n   * all visible shape ids\n   */\n  visibleShapeIds: string[] = [];\n\n  /**\n   * currently drawing shape\n   */\n  drawingShape: Shape<ShapeData> | null = null;\n\n  /**\n   * recognizer\n   */\n  recognizer: Recognizer | null = null;\n\n  /**\n   * if recognition prepared, start to do recognition\n   */\n  recognitionStart = false;\n\n  /**\n   * currently selected shapes\n   */\n  selectedShapes: Shape<ShapeData>[] = [];\n\n  /**\n   * currently selected shape vertex index for polygon & line\n   */\n  selectedPointIndex = -1;\n\n  /**\n   * shapes resizer\n   */\n  shapesResizer?: MultiShapesResizer;\n\n  /**\n   * predicted shapes\n   */\n  predictedShapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * projected shapes\n   */\n  projectedShapes: {\n    [baseShapeId: string]: {\n      [projectToCamera: string]: Shape<ShapeData>;\n    }\n  } = {};\n\n  /**\n   * hovered shape id\n   */\n  hoveredShapeId = '';\n\n  /**\n   * waiting merge polygon\n   */\n  pendingMergePolygon = '';\n\n  /**\n   * waiting merge line\n   */\n  pendingMergeLine: { id: string; index: number } | null = null;\n\n  /**\n   * waiting merge pixel\n   */\n  pendingMergePixel: { id: string; index: number } | null = null;\n\n  /**\n   * shape id in cut mode\n   */\n  cuttingShape = '';\n\n  /**\n   * shape id in split mode\n   */\n  splittingShape = '';\n\n  /**\n   * shape id in appending mode\n   */\n  appendingShape = '';\n\n  /**\n   * shape id in updating mode\n   */\n  updatingShape = '';\n\n  /**\n   * is deleting\n   */\n  deleting = false;\n\n  /**\n   * is points moving\n   */\n  pointsMoving = false;\n\n  /**\n   * is shapes moving\n   */\n  shapesMoving = false;\n\n  /**\n   * is shape projecting\n   */\n  projecting = false;\n\n  /**\n   * when shapes visibility change\n   */\n  shapesRefreshCounter = 0;\n\n  /**\n   * shape display config\n   */\n  config = {\n    fill: true,\n    alpha: 20,\n    borderAlpha: 100,\n    borderWidth: 1,\n    dotRadius: 5,\n    showSideLength: false,\n    showDirection: false,\n    showVertex: false,\n    showVertexOrder: false,\n    vertexSize: 4,\n    vertexStart: 1,\n  };\n\n  /**\n   * default config from payload\n   */\n  defaultConfig = this.config;\n\n  /**\n   * show discrete points for curve edges\n   */\n  showCurveDiscretePoints = false;\n\n  /**\n   * side ratio\n   * ---- FIXME: customized for specific project\n   * ---- PID: A5764\n   */\n  showSideRatio = false;\n\n  /**\n   * creating shape's display color when display_color is random\n   * @private {string}\n   */\n  creatingShapeColor = '';\n\n  /**\n   * cache predict info from API\n   */\n  cachedPredictInfo?: {\n    buffer: any;\n    baseFrame: number;\n    targetFrame: number;\n    mask: number[];\n  };\n\n  /**\n   * is drawing shape\n   * @getter\n   */\n  get isDrawing() {\n    return this.drawingShape !== null;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeObservable(this, {\n      shapes: observable,\n      recognitionStart: observable,\n      selectedShapes: observable,\n      selectedPointIndex: observable,\n      drawingShape: observable,\n      pendingMergePixel: observable,\n      cuttingShape: observable,\n      splittingShape: observable,\n      appendingShape: observable,\n      updatingShape: observable,\n      projecting: observable,\n      shapesRefreshCounter: observable,\n      config: observable,\n      lineContinuous: observable,\n      toggleLineContinuous: action,\n      init: action,\n      clearShapes: action,\n      setupShapes: action,\n      selectShapes: action,\n      unselectShape: action,\n      addShape: action,\n      setupShape: action,\n      deleteShape: action,\n      resetRecognition: action,\n      updateConfig: action,\n      startShapeCutting: action,\n      endShapeCutting: action,\n      startShapeAppending: action,\n      endShapeAppending: action,\n      startUpdateShape: action,\n      finishUpdateShape: action,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * precise number\n   * @param num\n   */\n  precise(num: number) {\n    return precise(num, this.rootStore.config.dataPrecision);\n  }\n\n  initShapeStylesConfig(payload: Payload) {\n    const localShapeStylesConfig = cache.get(CacheKey.SHAPE_STYLES);\n    if (localShapeStylesConfig) {\n      this.defaultConfig = { ...this.config }; // save default settings\n      this.config = { ...localShapeStylesConfig };\n    } else {\n      this.config.fill = payload.is_fill !== 'false' && payload.is_fill !== false;\n      if (payload.fill_opacity !== undefined && payload.fill_opacity !== '') {\n        const alpha = Number(payload.fill_opacity);\n        if (!Number.isNaN(alpha) && alpha >= 0 && alpha <= 1) {\n          this.config.alpha = alpha * 100;\n        }\n      }\n      if (payload.border_opacity !== undefined && payload.border_opacity !== '') {\n        const borderAlpha = Number(payload.border_opacity);\n        if (!Number.isNaN(borderAlpha) && borderAlpha >= 0 && borderAlpha <= 1) {\n          this.config.borderAlpha = borderAlpha * 100;\n        }\n      }\n      if (payload.border_width !== undefined && payload.border_width !== '') {\n        const borderWidth = Number(payload.border_width);\n        if (!Number.isNaN(borderWidth) && borderWidth >= 1 && borderWidth <= 10) {\n          this.config.borderWidth = borderWidth;\n        }\n      }\n      if (payload.dot_size !== undefined && payload.dot_size !== '') {\n        const dotRadius = Number(payload.dot_size);\n        if (!Number.isNaN(dotRadius) && dotRadius >= 1 && dotRadius <= 10) {\n          this.config.dotRadius = dotRadius;\n        }\n      }\n      this.config.showSideLength = payload.show_side_length === 'true' || payload.show_side_length === true;\n      this.config.showDirection = payload.show_direction === 'true' || payload.show_direction === true;\n      this.config.showVertex = payload.show_vertex === 'true' || payload.show_vertex === true;\n      this.config.showVertexOrder = payload.show_vertex_order === 'true' || payload.show_vertex_order === true;\n      if (payload.vertex_size !== undefined && payload.vertex_size !== '') {\n        const vertexSize = Number(payload.vertex_size);\n        if (!Number.isNaN(vertexSize) && vertexSize >= 0) {\n          this.config.vertexSize = vertexSize;\n        }\n      }\n      if (payload.vertex_start !== undefined && payload.vertex_start !== '') {\n        const vertexStart = Number(payload.vertex_start);\n        if (!Number.isNaN(vertexStart)) {\n          this.config.vertexStart = vertexStart;\n        }\n      }\n      this.defaultConfig = { ...this.config }; // save default settings\n    }\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload: Payload) {\n    this.initShapeStylesConfig(payload);\n    this.initLineContinuous();\n    this.app = payload.app;\n  }\n\n  /**\n   * clear shapes\n   */\n  clearShapes = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.shapes = {};\n    this.shapesFrame = this.rootStore.frame.currentFrame;\n    this.drawingShape = null;\n    this.selectedShapes = [];\n    this.clearPredictedShapes();\n    this.clearProjectedShapes();\n    this.selectedPointIndex = -1;\n  };\n\n  /**\n   * clear predicted shapes\n   */\n  clearPredictedShapes = () => {\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.predictedShapes = {};\n  };\n\n  /**\n   * clear projected shapes\n   */\n  clearProjectedShapes = () => {\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.destroy();\n      });\n    });\n    this.projectedShapes = {};\n  };\n\n  /**\n   * is predicted shape\n   * @param s\n   */\n  isPredictedShape = (s: Shape<ShapeData>) => Object.values(this.predictedShapes).findIndex(({ shape }) => shape === s) >= 0;\n\n  /**\n   * get shape by instance item\n   * @param instanceItem\n   */\n  getShapeByInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const shapeItem = Object.values(this.shapes).find((i) => i.camera === camera && i.instanceItem === instanceItem);\n    if (shapeItem) {\n      return shapeItem.shape;\n    }\n    return undefined;\n  };\n\n  /**\n   * get shapes by instance items\n   * @param instanceItems\n   * @param camera\n   */\n  getShapesByInstanceItems = (instanceItems: InstanceItem[], camera = this.rootStore.frame.currentCamera) => {\n    const shapeItems = Object.values(this.shapes).filter((i) => i.camera === camera && instanceItems.indexOf(i.instanceItem) >= 0);\n    return shapeItems.map((i) => i.shape);\n  };\n\n  /**\n   * get shapes for one camera\n   * @param camera\n   * @param onlyKeepEditable\n   */\n  getShapesForCamera = (camera: string, onlyKeepEditable = false) => Object.values(this.shapes)\n    .filter((s) => s.camera === camera && (!onlyKeepEditable || s.shape.editable));\n\n  /**\n   * get shapes in layer for one camera\n   * @param camera\n   * @param layer\n   */\n  getShapesForCameraByLayer = (camera: string, layer = this.rootStore.config.activeLayerIndex) => {\n    const { currentFrame } = this.rootStore.frame;\n    const allShapes = Object.values(this.shapes);\n    const layerShapes = [];\n    for (let i = 0; i < allShapes.length; i += 1) {\n      const shape = allShapes[i];\n      if (shape.camera === camera) {\n        const { layer: shapeLayer } = shape.instanceItem.cameras[camera]?.frames[currentFrame] || {};\n        if (shapeLayer === layer) {\n          layerShapes.push(shape);\n        }\n      }\n    }\n    return layerShapes;\n  };\n\n  /**\n   * update shapes interactive\n   * @param interactive\n   * @param ignoreIds\n   */\n  updateShapesInteractive = (interactive: boolean, ignoreIds?: string[]) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (ignoreIds && ignoreIds.includes(shape.uid)) {\n        return;\n      }\n      shape.interactive = interactive;\n      if (interactive && this.selectedShapes.indexOf(shape) >= 0) {\n        shape.selected = true;\n      }\n    });\n  };\n\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable: boolean) {\n    const { currentFrame } = this.rootStore.frame;\n    Object.values(this.shapes).forEach(({ shape, instanceItem, camera }) => {\n      shape.editable = editable && !instanceItem.cameras[camera]?.frames[currentFrame]?.locked;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.editable = editable;\n    });\n  }\n\n  /**\n   * update shapes user data mode\n   * @param userDataMode\n   */\n  updateShapesUserDataMode = (userDataMode: UserDataMode) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.userDataMode = userDataMode;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.userDataMode = userDataMode;\n    });\n  };\n\n  /**\n   * update shapes rotate mode\n   * @param shapeRotateMode\n   */\n  updateShapesRotateMode = (shapeRotateMode: ShapeRotateMode) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.rotateMode = shapeRotateMode;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.rotateMode = shapeRotateMode;\n    });\n  };\n\n  /**\n   * update rotate handle mode when shape rotate mode is handle\n   * @param shapeRotateHandleMode\n   */\n  updateShapesRotateHandleMode = (shapeRotateHandleMode: ShapeRotateHandleMode) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.rotateHandleMode = shapeRotateHandleMode;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.rotateHandleMode = shapeRotateHandleMode;\n    });\n  };\n\n  /**\n   * update shapes show auxiliary lines\n   * @param showAuxiliaryLines\n   */\n  updateShapesShowAuxiliaryLines = (showAuxiliaryLines: boolean) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape instanceof Rectangle) {\n        shape.showAuxiliaryLines = showAuxiliaryLines;\n      }\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      if (shape instanceof Rectangle) {\n        shape.showAuxiliaryLines = showAuxiliaryLines;\n      }\n    });\n  };\n\n  /**\n   * update pixel shapes show bounds\n   * @param showPixelShapeBounds\n   */\n  updatePixelShapesShowBounds = (showPixelShapeBounds: boolean) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape instanceof Pixel) {\n        shape.showShapeBounds = showPixelShapeBounds;\n      }\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      if (shape instanceof Pixel) {\n        shape.showShapeBounds = showPixelShapeBounds;\n      }\n    });\n  };\n\n  /**\n   * update shapes double click finish (only for pixel shape)\n   * @param dblclickFinish\n   */\n  updateShapesDoubleClickFinish = (dblclickFinish: boolean) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape.shapeType === ShapeType.PIXEL) {\n        (shape as Pixel).dblclickFinish = dblclickFinish;\n      }\n    });\n  };\n\n  /**\n   * update rectangle shapes auto snap tolerance\n   * @param tolerance\n   */\n  updateRectangleShapesAutoSnapTolerance = (tolerance: number) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape instanceof Rectangle) {\n        shape.autoSnapTolerance = tolerance;\n      }\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      if (shape instanceof Rectangle) {\n        shape.autoSnapTolerance = tolerance;\n      }\n    });\n  };\n\n  /**\n   * redraw shapes label\n   */\n  redrawShapesLabel = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.drawShapeLabel();\n      });\n    });\n  };\n\n  /**\n   * setup shapes for current frame\n   */\n  setupShapes = () => {\n    this.clearShapes();\n    const { cameraViews, currentCamera, currentFrameByCamera, cameraNames, getImageBoundsForCamera } = this.rootStore.frame;\n    const layersCount = this.rootStore.config.layers.length || 1;\n    const allShapeOrders: {\n      [camera: string]: Set<number>[];\n    } = {};\n    const noOrderShapes: {\n      [camera: string]: { frameData: FrameData, shape: Shape<ShapeData> }[][];\n    } = {};\n    cameraNames.forEach((cameraName) => {\n      allShapeOrders[cameraName] = [];\n      noOrderShapes[cameraName] = [];\n      for (let i = 0; i < layersCount; i += 1) {\n        allShapeOrders[cameraName][i] = new Set();\n        noOrderShapes[cameraName][i] = [];\n      }\n    });\n    const startOrder = this.rootStore.segmentation.enabled ? 1 : 0;\n    Object.values(this.rootStore.instance.instances).forEach((instance) => {\n      Object.values(instance.items).forEach((item) => {\n        Object.values(item.cameras).forEach(({ camera }) => {\n          const { frames } = item.cameras[camera];\n          const cameraView = cameraViews[camera];\n          const cameraFrame = currentFrameByCamera[camera];\n          if (frames[cameraFrame] && cameraView && !cameraView.imageLoadError) {\n            const frameData = frames[cameraFrame];\n            const { layer } = frameData;\n            const shape = this.createShape(\n              cameraView.getShapesLayerByIndex(layer),\n              getImageBoundsForCamera(camera, cameraFrame),\n              item.colorConfig.color,\n              instance.category,\n              item.name,\n              item,\n              frames[cameraFrame].shapeType,\n              frames[cameraFrame].shape,\n              frames[cameraFrame].order,\n              item.label,\n              camera,\n            );\n            item.setShapeColorConifg({\n              fillColor: shape.fillColor,\n              edgeColor: shape.borderColor,\n              pointColor: shape.vertexColor,\n              color: item.colorConfig.color\n            });\n            if (shape.destroyed) {\n              // delete instance item\n              this.rootStore.instance.deleteInstanceItemByFrame(item, cameraFrame, camera);\n              return;\n            }\n            if (shape.area < this.rootStore.config.minArea && shape.shapeType !== ShapeType.PIXEL && this.rootStore.annotatable) {\n              // delete instance item & shape when is small\n              this.deleteShape(shape);\n              this.rootStore.instance.deleteInstanceItemByFrame(item, cameraFrame, camera);\n              return;\n            }\n            if (this.rootStore.readonly || frameData.locked) {\n              shape.editable = false;\n            }\n            if (this.rootStore.config.measureMode) {\n              shape.interactive = false;\n            }\n            if (frameData.isPreAnnotation) {\n              shape.labelDom?.setPrefix(createLabelPrefix());\n            }\n            this.setShapeStyles(shape, item);\n            this.addShapeListeners(shape);\n            this.shapes[shape.uid] = {\n              shape,\n              camera,\n              instanceItem: item,\n            };\n            if (camera === currentCamera && shape.shapeType === ShapeType.PIXEL) {\n              this.rootStore.segmentation.update(item, layer, shape as Pixel);\n            }\n\n            const { shape: savedShapeData, order } = frameData;\n            const currShapeData = shape.getData();\n            if (!isEqual(savedShapeData, currShapeData) && this.rootStore.annotatable) {\n              // shape data changed, update\n              frameData.shape = currShapeData;\n            }\n            if ((currShapeData as ShapeDataWithArea).area !== undefined && (frameData.shape as ShapeDataWithArea).area === undefined) {\n              // add shape area\n              (frameData.shape as ShapeDataWithArea).area = (currShapeData as ShapeDataWithArea).area;\n            }\n            if (shape.shapeType === ShapeType.PIXEL) {\n              // only 0 is valid order for pixel shape\n              shape.order = 0;\n              frameData.order = shape.order;\n            } else if (typeof order === 'number' && order >= startOrder && !allShapeOrders[camera][layer].has(order)) {\n              // update next shape order\n              shape.order = order;\n              allShapeOrders[camera][layer].add(order);\n            } else {\n              // add to temp array\n              noOrderShapes[camera][layer].push({ frameData, shape });\n            }\n          }\n        });\n      });\n    });\n    Object.keys(noOrderShapes).forEach((cameraName) => {\n      noOrderShapes[cameraName].forEach((cameraShapes, layerIndex) => {\n        cameraShapes.forEach(({ frameData, shape }) => {\n          // new order\n          shape.order = this.rootStore.frame.getNextShapeOrder(layerIndex, frameData.frameIndex, cameraName);\n          frameData.order = shape.order;\n        });\n      });\n    });\n\n    this.projectShapes();\n  };\n\n  /**\n   * format point label\n   * @param data\n   * @param categoryName\n   * @param categoryItemName\n   */\n  formatPointLabel = (data: any, categoryName: string, categoryItemName: string) => {\n    const pointLabelConfig = this.rootStore.ontology.getPointLabelConfigFromCategoryItem(categoryName, categoryItemName);\n    const fieldsMap = parseFields(pointLabelConfig);\n    const labels: string[][] = [];\n    const { pointLabelItems } = this.rootStore.config;\n    Object.keys(data).forEach((key) => {\n      const label = [];\n      const field = fieldsMap[key];\n      const fieldValue = data[key];\n      if (pointLabelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n        label.push(field?.label || field?.name || `${key}`);\n      }\n      if (pointLabelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n        const displayValue = getFieldDisplayLabel(fieldValue, field);\n        label.push(displayValue);\n      }\n      if (label.length > 0) {\n        labels.push(label);\n      }\n    });\n    return labels.map((l) => l.join(': ')).join('; ');\n  };\n\n  /**\n   * get point style\n   * @param pointIndex\n   * @param data\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getPointStyle = (pointIndex: number, data: any, shape: Shape<ShapeData>, categoryName: string, categoryItemName: string) => {\n    let pointColor: number | undefined;\n    let pointType: ShapeVertexType | undefined;\n    // by point attributes\n    if (data) {\n      const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n      const { pointLabelConfig, pointLabelConfigGroups } = categoryItem || {};\n      if (pointLabelConfig && pointLabelConfigGroups) {\n        // from point label config settings\n        pointLabelConfigGroups.some((g) => {\n          const { attributes, ...styles } = g;\n          if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n            // match group attributes\n            if (pointColor === undefined) {\n              const color = styles.pointColor;\n              if (color) {\n                pointColor = parseInt(color.substr(1), 16);\n              }\n            }\n            if (pointType === undefined) {\n              const type = styles.pointType;\n              if (type) {\n                pointType = type as ShapeVertexType;\n              }\n            }\n          }\n          return pointColor !== undefined && pointType !== undefined;\n        });\n      } else if (pointColor === undefined) {\n        // from hotkeys config\n        const dataKeyLen = Object.keys(data).length;\n        Object.values(this.rootStore.config.hotkeyMap).some((items) => items.some(({ affected, type, color, shape: pointShape, attributes }) => {\n          if (affected === 'point' && (color !== undefined || pointShape !== undefined)) {\n            const attrKeys = Object.keys(attributes);\n            if (isAttributesPassCondition(data, attributes) && (type !== 'overwrite' || attrKeys.length === dataKeyLen)) {\n              if (color !== undefined) {\n                pointColor = parseInt(color.substr(1), 16);\n              }\n              if (pointShape !== undefined) {\n                pointType = pointShape as ShapeVertexType;\n              }\n              return true;\n            }\n          }\n          return false;\n        }));\n      }\n    }\n\n    // by point index\n    const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n    if (styles) {\n      // has style config\n      if (pointColor === undefined) {\n        // color not affected by attributes, use point index settings\n        const color = (styles.pointsColor || [])[pointIndex];\n        if (color) {\n          pointColor = parseInt(color.substr(1), 16);\n        }\n      }\n      if (pointType === undefined) {\n        // type not affected by attributes, use point index settings\n        const type = (styles.pointsType || [])[pointIndex];\n        if (type) {\n          pointType = type as ShapeVertexType;\n        }\n      }\n    }\n\n    return {\n      color: pointColor,\n      type: pointType,\n    };\n  };\n\n  /**\n   * get edge style\n   * @param startPointIndex\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getEdgeStyle = (startPointIndex: number, data: any, shape: Shape<ShapeData>, categoryName: string, categoryItemName: string) => {\n    let edgeColor: number | undefined;\n    let edgeType: ShapeLineType | undefined;\n    let edgeBold: boolean | undefined;\n\n    // by point labelConfig\n    if (data) {\n      const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n      const { pointLabelConfig, pointLabelConfigGroups } = categoryItem || {};\n      if (pointLabelConfig && pointLabelConfigGroups) {\n        // from point label config settings\n        pointLabelConfigGroups.some((g) => {\n          const { attributes, ...styles } = g;\n\n          if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n            // match group attributes\n            if (edgeColor === undefined) {\n              const color = styles.edgeColor;\n              if (color) {\n                edgeColor = parseInt(color.substr(1), 16);\n              }\n            }\n            if (edgeType === undefined) {\n              const type = styles.edgeType;\n              if (type) {\n                edgeType = type as ShapeLineType;\n              }\n            }\n\n            if (edgeBold === undefined) {\n              const bold = styles.edgeBold;\n              if (bold !== undefined) {\n                edgeBold = bold;\n              }\n            }\n          }\n          return edgeColor !== undefined && edgeType !== undefined && edgeBold !== undefined;\n        });\n      }\n    }\n\n    if (edgeColor === undefined || edgeType === undefined || edgeBold === undefined) {\n      // by point index\n      const styles = this.rootStore.ontology.getToolEdgesStylesByCategoryItem(categoryName, categoryItemName);\n      if (styles) {\n        // has style config\n        if (edgeColor === undefined) {\n          // color not affected by attributes, use point index settings\n          const color = (styles.edgesColor || [])[startPointIndex];\n          if (color) {\n            edgeColor = parseInt(color.substr(1), 16);\n          }\n        }\n        if (edgeType === undefined) {\n          // type not affected by attributes, use point index settings\n          const type = (styles.edgesType || [])[startPointIndex];\n          if (type) {\n            edgeType = type as ShapeLineType;\n          }\n        }\n        if (edgeBold === undefined) {\n          // bold not affected by attributes, use point index settings\n          const bold = (styles.edgesBold || [])[startPointIndex];\n          if (bold !== undefined) {\n            edgeBold = bold;\n          }\n        }\n      }\n    }\n\n    return {\n      color: edgeColor,\n      type: edgeType,\n      bold: edgeBold,\n    };\n  };\n\n  /**\n   * get shape style (for fill color & dot style & color)\n   * @param data\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getShapeStyle = (data: any, categoryName: string, categoryItemName: string, instanceItem?: InstanceItem) => {\n    let dotColor: number | undefined;\n    let dotType: ShapeVertexType | undefined;\n    let fillColor: number | undefined;\n    let borderColor: number | undefined;\n    let borderType: ShapeLineType | undefined;\n    let borderBold: boolean | undefined;\n    let vertexColor: number | undefined;\n    let vertexType: ShapeVertexType | undefined;\n\n    const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n    if (data) {\n      const { labelConfig, labelConfigGroups } = categoryItem || {};\n      if (labelConfig && labelConfigGroups) {\n        // has label config settings\n        labelConfigGroups.some((g) => {\n          const { attributes, ...styles } = g;\n          if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n            // match group attributes\n            if (dotColor === undefined) {\n              const color = styles.pointColor;\n              if (color) {\n                dotColor = parseInt(color.substr(1), 16);\n              }\n            }\n            if (dotType === undefined) {\n              const type = styles.pointType;\n              if (type) {\n                dotType = type as ShapeVertexType;\n              }\n            }\n            if (fillColor === undefined && styles.fillColor) {\n              fillColor = parseInt(styles.fillColor.substr(1), 16);\n            }\n            if (borderColor === undefined && styles.edgeColor) {\n              borderColor = parseInt(styles.edgeColor.substr(1), 16);\n            }\n            if (borderType === undefined && styles.edgeType) {\n              borderType = styles.edgeType as ShapeLineType;\n            }\n            if (borderBold === undefined && styles.edgeBold !== undefined) {\n              borderBold = styles.edgeBold;\n            }\n            if (vertexColor === undefined && styles.pointColor) {\n              vertexColor = parseInt(styles.pointColor.substr(1), 16);\n            }\n            if (vertexType === undefined && styles.pointType) {\n              vertexType = styles.pointType as ShapeVertexType;\n            }\n          }\n          return (\n            dotColor !== undefined &&\n            dotType !== undefined &&\n            fillColor !== undefined &&\n            borderColor !== undefined &&\n            borderType !== undefined &&\n            borderBold !== undefined &&\n            vertexColor !== undefined &&\n            vertexType !== undefined\n          );\n        });\n      }\n    }\n    const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n    if (styles) {\n      if (dotColor === undefined) {\n        // color not affected by attributes, use shape settings\n        const color = styles.pointColor;\n        if (color && color !== 'random') {\n          dotColor = parseInt(color.substr(1), 16);\n        }\n      }\n      if (dotType === undefined) {\n        // type not affected by attributes, use shape settings\n        const type = styles.pointType;\n        if (type) {\n          dotType = type as ShapeVertexType;\n        }\n      }\n    }\n    if (fillColor === undefined) {\n      // fill color not affected by attributes, use shape settings\n      const fill = this.rootStore.ontology.getToolFillByCategoryItem(categoryName, categoryItemName);\n      if (fill) {\n        if (fill !== 'random') {\n          fillColor = parseInt(fill.substr(1), 16);\n        } else if (instanceItem?.colorConfig?.fillColor) {\n          fillColor = instanceItem.colorConfig.fillColor;\n        } else {\n          fillColor = parseInt(randomColor().substr(1), 16);\n        }\n      }\n    }\n\n    if (\n      borderColor === undefined || borderType === undefined || borderBold === undefined ||\n      vertexColor === undefined || vertexType === undefined\n    ) {\n      const { pointsStyles, edgesStyles } = this.rootStore.ontology.getToolStylesByCategoryItem(categoryName, categoryItemName);\n      if (borderColor === undefined && edgesStyles?.edgeColor) {\n        if (edgesStyles.edgeColor !== 'random') {\n          borderColor = parseInt(edgesStyles.edgeColor.substr(1), 16);\n        } else if (instanceItem?.colorConfig?.edgeColor) {\n          borderColor = instanceItem.colorConfig.edgeColor;\n        } else {\n          borderColor = parseInt(randomColor().substr(1), 16);\n        }\n      }\n\n      if (borderType === undefined && edgesStyles?.edgeType) {\n        borderType = edgesStyles.edgeType as ShapeLineType;\n      }\n\n      if (borderBold === undefined && edgesStyles?.edgeBold !== undefined) {\n        borderBold = edgesStyles.edgeBold;\n      }\n\n      if (vertexColor === undefined && pointsStyles?.pointColor) {\n        if (pointsStyles.pointColor !== 'random') {\n          vertexColor = parseInt(pointsStyles.pointColor.substr(1), 16);\n        } else if (instanceItem?.colorConfig?.pointColor) {\n          vertexColor = instanceItem.colorConfig.pointColor;\n        } else {\n          vertexColor = parseInt(randomColor().substr(1), 16);\n        }\n      }\n\n      if (vertexType === undefined && pointsStyles?.pointType) {\n        vertexType = pointsStyles.pointType as ShapeVertexType;\n      }\n    }\n    let displayColor;\n    let displayColorString = '';\n    if (instanceItem) {\n      if (instanceItem.colorConfig.color) {\n        displayColor = parseInt(instanceItem.colorConfig.color.substr(1), 16);\n      }\n    } else if (!categoryItem || !categoryItem.displayColor || categoryItem?.displayColor === 'random') {\n      displayColorString = randomColor();\n      displayColor = parseInt(displayColorString.substr(1), 16);\n    } else {\n      displayColorString = categoryItem.displayColor;\n      displayColor = parseInt(categoryItem.displayColor.substr(1), 16);\n    }\n    if (!instanceItem) {\n      this.creatingShapeColor = displayColorString;\n    }\n    return {\n      dotColor: dotColor || displayColor,\n      dotType,\n      fillColor: fillColor || displayColor,\n      borderColor: borderColor || displayColor,\n      borderType,\n      borderBold,\n      vertexColor: vertexColor || displayColor,\n      vertexType,\n    };\n  };\n\n  /**\n   * set shape styles\n   * @param shape\n   * @param instanceItem\n   * @param camera\n   * @param frameIndex\n   */\n  setShapeStyles = (\n    shape: Shape<ShapeData>,\n    instanceItem: InstanceItem,\n    camera = this.rootStore.frame.currentCamera,\n    frameIndex = this.rootStore.frame.currentFrame,\n  ) => {\n    const { attributes } = instanceItem.cameras[camera]?.frames[frameIndex] || {};\n    const { dotColor, dotType, fillColor, borderColor, borderType, borderBold, vertexColor, vertexType } = this.getShapeStyle(attributes, instanceItem.instance.category, instanceItem.name, instanceItem);\n    if (shape.shapeType === ShapeType.DOT) {\n      if (dotColor !== undefined) {\n        shape.color = dotColor;\n        shape.originColors.color = dotColor;\n      }\n      if (dotType) {\n        (shape as Dot).dotType = dotType;\n      }\n    }\n    if ((shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.RECTANGLE || shape.shapeType === ShapeType.SQUARE) && fillColor !== undefined) {\n      shape.fillColor = fillColor;\n    }\n\n    if (\n      shape.shapeType === ShapeType.POLYGON ||\n      shape.shapeType === ShapeType.LINE ||\n      shape.shapeType === ShapeType.ARROW ||\n      shape.shapeType === ShapeType.RECTANGLE ||\n      shape.shapeType === ShapeType.SQUARE\n    ) {\n      if (borderColor !== undefined) {\n        shape.borderColor = borderColor;\n        shape.originColors.borderColor = borderColor;\n      }\n\n      if (borderType !== undefined) {\n        shape.borderType = borderType;\n      }\n\n      if (borderBold !== undefined) {\n        shape.borderBold = borderBold;\n      }\n    }\n    if (\n      shape.shapeType === ShapeType.POLYGON ||\n      shape.shapeType === ShapeType.LINE ||\n      shape.shapeType === ShapeType.ARROW ||\n      shape.shapeType === ShapeType.KEYPOINTS\n    ) {\n      if (vertexColor !== undefined) {\n        shape.vertexColor = vertexColor;\n      }\n\n      if (vertexType !== undefined) {\n        shape.vertexType = vertexType;\n      }\n    }\n  };\n\n  /**\n   * create shape label dom\n   */\n  createShapeLabel(camera = this.rootStore.frame.currentCamera) {\n    const shapeLabelsContainer = document.getElementById(`${CAMERA_VIEW_LABELS}-${camera}`);\n    if (shapeLabelsContainer) {\n      const shapeLabel = new Label({\n        className: 'shape-label',\n        transPosition: (p) => {\n          const cameraView = this.rootStore.frame.cameraViews[camera];\n          if (cameraView) {\n            return cameraView.toLocal(p);\n          }\n          return p;\n        },\n      });\n      shapeLabel.addToContainer(shapeLabelsContainer);\n      return shapeLabel;\n    }\n    return undefined;\n  }\n\n  /**\n   * create shape instance\n   * @param shapeContainer\n   * @param imageBounds\n   * @param hexColor\n   * @param categoryName\n   * @param categoryItemName\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param label\n   */\n  createShape = (\n    shapeContainer: Container,\n    imageBounds: { left: number; top: number; right: number; bottom: number; },\n    hexColor: string,\n    categoryName: string,\n    categoryItemName: string,\n    instanceItem?: InstanceItem,\n    shapeType?: ShapeType,\n    shapeData?: ShapeData,\n    order?: number,\n    label?: string,\n    camera?: string,\n  ) => {\n    const { boundaryCheck, dataPrecision, draggable, rotatable, autoSnap, activePointAttributesMode, preferences, layers } = this.rootStore.config;\n    const { shapeRotateMode = ShapeRotateMode.HANDLE, shapeRotateHandleMode = ShapeRotateHandleMode.SELECTED, autoSnapTolerance } = preferences;\n    const { currentToolItem, currentTool, currentShapeType, currentCreateMethod, getToolConfigByCategoryItem } = this.rootStore.ontology;\n    const useCurrent = shapeType === undefined;\n\n    const controlsContainer = layers.length === 0 ? undefined : shapeContainer.parent;\n    const type = shapeType || currentShapeType;\n    const toolConfig = getToolConfigByCategoryItem(categoryName, categoryItemName);\n    const shapeStyles = this.getShapeStyle(null, categoryName, categoryItemName, instanceItem);\n    const {\n      dotType,\n      fillColor,\n      borderColor,\n      borderType,\n      borderBold,\n      vertexColor,\n      vertexType,\n    } = shapeStyles;\n    let color = parseInt(hexColor.substr(1), 16);\n    if (hexColor === 'random') {\n      if (this.creatingShapeColor) {\n        color = parseInt(this.creatingShapeColor.substr(1), 16);\n      } else {\n        color = parseInt(randomColor().substr(1), 16);\n      }\n    }\n    const { dotColor = color } = shapeStyles;\n    const shape = ShapeFactory.getShape(type, {\n      app: this.app!,\n      container: shapeContainer,\n      controlsContainer,\n      color,\n      fillColor,\n      borderColor,\n      borderType,\n      borderBold,\n      vertexColor,\n      vertexType,\n      alpha: this.config.fill ? this.config.alpha / 100 : 0,\n      dataPrecision,\n      draggable,\n      borderWidth: this.config.borderWidth,\n      borderAlpha: this.config.borderAlpha / 100,\n      showSideLength: this.config.showSideLength,\n      showDirection: this.config.showDirection,\n      showVertex: this.config.showVertex,\n      showVertexOrder: this.config.showVertexOrder,\n      vertexSize: type === ShapeType.KEYPOINTS ? this.config.dotRadius : this.config.vertexSize,\n      vertexStart: this.config.vertexStart,\n      ...(boundaryCheck || type === ShapeType.PIXEL) && { bounds: imageBounds },\n      label,\n      ...shapeData,\n      ...toolConfig,\n      ...type === ShapeType.DOT && {\n        dotRadius: this.config.dotRadius,\n        dotType,\n        color: dotColor,\n      },\n      ...(type === ShapeType.RECTANGLE || type === ShapeType.SQUARE) && {\n        autoSnapEnabled: autoSnap,\n        autoSnapTolerance,\n      },\n      ...(type === ShapeType.RECTANGLE || type === ShapeType.SQUARE || type === ShapeType.POLYGON || type === ShapeType.ELLIPSE) && {\n        rotatable,\n      },\n      ...(useCurrent && currentTool === Tool.CENTERLINE_RECTANGLE && {\n        centerLineEnabled: true,\n      }),\n      ...(useCurrent && currentTool === Tool.FOUR_DOTS_RECTANGLE && {\n        rectType: RectType.FOUR_DOTS_RECT,\n      }),\n      ...(useCurrent && currentTool === Tool.RECTANGLE && currentCreateMethod === CVModel.OBJECT_DETECTION && {\n        rectType: RectType.RECOGNITION,\n      }),\n      ...(useCurrent && currentTool === Tool.RECTANGLE && currentCreateMethod === CVModel.OBJECT_DETECTION_MULTI && {\n        rectType: RectType.RECOGNITION_MULTI,\n      }),\n      ...(useCurrent && [Tool.LINE, Tool.ARROW].includes(currentTool) && currentCreateMethod === CVModel.SEGMENTATION && {\n        lineType: LineType.RECOGNITION,\n      }),\n      ...(useCurrent && (currentTool === Tool.RECOGNITION || (\n        type === ShapeType.POLYGON && currentCreateMethod === CVModel.SEGMENTATION\n      )) && {\n        polygonType: PolygonType.RECOGNITION,\n      }),\n      ...(useCurrent && type === ShapeType.POLYGON && currentCreateMethod === PolygonCreateMethod.RECT && {\n        polygonType: PolygonType.RECT,\n      }),\n      ...(useCurrent && currentToolItem?.edges !== undefined && [Tool.POLYGON, Tool.LINE, Tool.ARROW].includes(currentTool) && {\n        defaultEdges: currentToolItem.edges,\n      }),\n      ...(useCurrent && [ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW, ShapeType.CURVE, ShapeType.FLEX_LINE].includes(type) && {\n        dblclickFinish: !!this.rootStore.config.preferences.dblclickFinish,\n      }),\n      ...(type === ShapeType.PIXEL && {\n        pixelType: this.rootStore.segmentation.currPixelType,\n        brushRadius: this.rootStore.segmentation.currBrushRadius,\n        showShapeBounds: !!this.rootStore.config.preferences.showPixelShapeBounds,\n        dblclickFinish: !!this.rootStore.config.preferences.dblclickFinish,\n        canPixelUpdate: this.rootStore.segmentation.canPixelUpdate,\n      }),\n      ...(type === ShapeType.RECTANGLE && {\n        showAuxiliaryLines: !!this.rootStore.config.preferences.showShapeAuxiliaryLines,\n      }),\n      ...this.rootStore.config.viewMode === ViewMode.DEFAULT ? {\n        labelDom: this.createShapeLabel(camera),\n        scale: this.rootStore.frame.cameraViews[camera || this.rootStore.frame.currentCamera]?.viewScale,\n      } : {\n        scale: shapeContainer.scale.x, // use shape container\n      },\n      userDataFormatter: (data) => this.formatPointLabel(data, categoryName, categoryItemName),\n      ...[ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW].includes(type) && {\n        pointStyler: (pIndex, data, s) => this.getPointStyle(pIndex, data, s, categoryName, categoryItemName),\n        edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName),\n      },\n      ...[ShapeType.RECTANGLE, ShapeType.SQUARE].includes(type) && {\n        edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName),\n      },\n      ...[ShapeType.KEYPOINTS].includes(type) && {\n        pointStyler: (pointKey, data, s) => this.getPointStyle(pointKey, data, s, categoryName, categoryItemName),\n      },\n    });\n    // destroyed, not need to proceed\n    if (shape?.destroyed) {\n      return shape;\n    }\n    // add inspect label component\n    if (shape?.labelDom) {\n      ReactDOM.render(\n        React.createElement(InspectLabel, {\n          shapeId: shape.uid,\n        }),\n        shape.labelDom.additionalContainer,\n      );\n    }\n    // update order, prefer to use given order\n    if (order !== undefined) {\n      shape!.order = order;\n    } else if (useCurrent) {\n      shape!.order = shape!.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder();\n    }\n    // set default rotation for rectangle & ellipse\n    if (shapeData && (type === ShapeType.RECTANGLE || type === ShapeType.SQUARE || type === ShapeType.ELLIPSE)) {\n      shape!.rotation = (shapeData as RectangleData).rotation || 0;\n    }\n    // set default user data mode\n    shape!.userDataMode = activePointAttributesMode as unknown as UserDataMode;\n    // set default rotate mode\n    shape!.rotateMode = shapeRotateMode;\n    // set default rotate handle mode\n    shape!.rotateHandleMode = shapeRotateHandleMode;\n    // set curve discrete points visibility\n    if (shape instanceof Curve) {\n      shape.showDiscretePointsHint = this.showCurveDiscretePoints;\n    }\n    // FIXME: set show side ratio (customized for specific project)\n    if (shape!.shapeType === ShapeType.POLYGON && this.showSideRatio) {\n      (shape as Polygon).showSideRatio = this.showSideRatio;\n    }\n    return shape!;\n  };\n\n  /**\n   * validate shape\n   * @param shape\n   */\n  validateShape = (shape: Shape<ShapeData>) => {\n    if (shape.area < this.rootStore.config.minArea && shape.shapeType !== ShapeType.PIXEL) {\n      if (shape.uid === this.cuttingShape) {\n        this.endShapeCutting();\n      }\n      const { instanceItem } = this.shapes[shape.uid] || {};\n      if (instanceItem) {\n        // related to instance, also update data\n        this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n      } else {\n        // has not been related to any instance, just delete the shape\n        this.deleteShape(shape);\n      }\n      message.warning(i18n.translate('MIN_AREA_ALERT'));\n      return false;\n    }\n    return true;\n  };\n\n  /**\n   * add shape listeners\n   * @param shape\n   */\n  addShapeListeners(shape: Shape<ShapeData>) {\n    shape.on(EventAction.SELECTED, (s, p, options) => {\n      if (this.rootStore.config.isWorkingOnAnyShape) {\n        return; // do not select other shape when cutting or splitting\n      }\n      if (!this.isPredictedShape(s)) {\n        if (this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n          if (this.pendingMergePolygon && shape.shapeType === ShapeType.POLYGON) {\n            if (!shape.editable) {\n              shape.selected = false;\n              message.warning(i18n.translate('MERGE_LOCK_MSG'));\n              return;\n            }\n            this.mergePolygons(this.pendingMergePolygon, shape.uid);\n            this.pendingMergePolygon = '';\n            return;\n          }\n          if (this.pendingMergePixel && shape.shapeType === ShapeType.PIXEL) {\n            if (!shape.editable) {\n              shape.selected = false;\n              message.warning(i18n.translate('MERGE_LOCK_MSG'));\n              return;\n            }\n            this.rootStore.segmentation.merge(shape.uid, this.pendingMergePixel.id, this.pendingMergePixel.index);\n            this.pendingMergePixel = null;\n            return;\n          }\n          if (this.rootStore.relationship.settingRelationship) {\n            const { instanceItem } = this.shapes[s.uid];\n            if (instanceItem === this.rootStore.relationship.fromInstanceItem) {\n              return;\n            }\n            this.rootStore.relationship.add(instanceItem);\n          }\n        }\n\n        const isReorganizing = this.rootStore.instance.reorganizingInstance && this.rootStore.instance.reorganizingInstanceItemName;\n        let selectedShapes = [...this.selectedShapes];\n        if (options?.shiftKey && !isReorganizing) {\n          const index = selectedShapes.indexOf(s);\n          if (index >= 0) {\n            selectedShapes.splice(index, 1);\n          } else {\n            selectedShapes.push(s);\n          }\n          this.clearPendingWithAlert();\n        } else {\n          selectedShapes = [s];\n          if (this.selectedShapes.indexOf(s) < 0) {\n            this.clearPendingWithAlert();\n          }\n        }\n\n        const selectedInstanceItems = selectedShapes.map((ss) => this.shapes[ss.uid].instanceItem);\n        this.selectShapes(selectedShapes);\n        this.rootStore.instance.selectInstanceItem(selectedInstanceItems);\n\n        if (options?.shiftKey) {\n          this.rootStore.instance.tryReorganize();\n        }\n      } else {\n        // clear selected shape status\n        this.selectedShapes.forEach((ss) => {\n          ss.selected = false;\n        });\n        this.selectedShapes = [];\n        // clear predicted shape selected status\n        Object.values(this.predictedShapes).forEach((predictedShape) => {\n          if (predictedShape.shape !== s) {\n            predictedShape.shape.selected = false;\n          }\n        });\n        this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);\n        const { instance, name } = this.predictedShapes[s.uid].instanceItem;\n        this.rootStore.ontology.selectCategory(instance.category);\n        this.rootStore.ontology.selectCategoryItem(name);\n      }\n      if (this.rootStore.review.addMode) {\n        this.rootStore.review.addReview(p);\n      }\n      this.rootStore.frame.syncNIFTIViews(this.rootStore.frame.currentCamera, p.x, p.y);\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      this.clearPending();\n      if (this.isPredictedShape(s)) {\n        if (this.validateShape(s)) { // predicted shape area meets the requirement\n          this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);\n        } else { // repredict\n          this.predict();\n        }\n      } else if (this.validateShape(s)) {\n        const { instanceItem } = this.shapes[s.uid];\n        const currentFrame = this.shapesFrame;\n        if (this.splittingShape === s.uid) {\n          if (s.shapeType === ShapeType.POLYGON && (s as Polygon).cuttingOtherPolygon) {\n            this.updatePolygons(data, [(s as Polygon).cuttingOtherPolygon!]);\n          } if (s.shapeType === ShapeType.PIXEL && (s as Pixel).cuttingOtherPixels) {\n            this.updateShapes(data, [(s as Pixel).cuttingOtherPixels!], s.shapeType);\n          } else if ((s.shapeType === ShapeType.LINE || s.shapeType === ShapeType.ARROW) && (s as Line).cuttingOtherLine) {\n            this.updateShapes(data, [(s as Line).cuttingOtherLine!], s.shapeType);\n          }\n          this.endShapeCutting();\n          this.projectShape(s);\n        } else if (this.pointsMoving) {\n          // finish points moving\n          const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData }[] = [];\n          this.selectedShapes.forEach((i) => {\n            if (i === s || i.shapeType === ShapeType.POLYGON || i.shapeType === ShapeType.LINE || i.shapeType === ShapeType.ARROW) {\n              const shapeItem = this.shapes[i.uid];\n              if (shapeItem && !shapeItem.instanceItem.cameras[shapeItem.camera]?.frames[currentFrame]?.locked) {\n                if (s !== i) {\n                  (i as Polygon | Line).normalize();\n                }\n                instanceItems.push({\n                  instanceItem: shapeItem.instanceItem,\n                  frameIndex: currentFrame,\n                  shapeType: i.shapeType,\n                  shape: s === i ? data : i.getData(),\n                });\n              }\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.pointsMoving = false;\n        } else if (this.shapesMoving) {\n          // finish shapes moving\n          const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData }[] = [];\n          this.selectedShapes.forEach((i) => {\n            const shapeItem = this.shapes[i.uid];\n            if (shapeItem && !shapeItem.instanceItem.cameras[shapeItem.camera]?.frames[currentFrame]?.locked) {\n              instanceItems.push({\n                instanceItem: shapeItem.instanceItem,\n                frameIndex: currentFrame,\n                shapeType: i.shapeType,\n                shape: s === i ? data : i.getData(),\n              });\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.shapesMoving = false;\n        } else if (!this.deleting) {\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, s.shapeType, data);\n          this.endShapeAppending(false);\n          this.projectShape(s);\n          if (s instanceof Keypoints && s.uid === this.updatingShape && !s.hasEmptyPoint) {\n            this.finishUpdateShape();\n            if (this.rootStore.config.continuousMode) {\n              if (this.rootStore.config.continuousModeType === ContinuousModeType.IN_INSTANCE) {\n                this.rootStore.ontology.selectNextCategoryItem();\n              }\n              this.rootStore.config.setAddMode(true);\n            }\n          }\n        }\n      }\n    });\n    shape.on(EventAction.REMOVED, (s) => {\n      if (!this.deleting) {\n        const { instanceItem } = this.shapes[s.uid];\n        if (instanceItem) {\n          if (s === this.rootStore.segmentation.updatingShape) {\n            this.rootStore.segmentation.cancelUpdate();\n          }\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.shapesFrame]);\n        }\n      }\n    });\n    shape.on(EventAction.POINTER_OVER, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = s.uid;\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.POINTER_OUT, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = '';\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.VERTEX_SELECTED, (s, index, p) => {\n      if (this.rootStore.review.addMode && p) {\n        this.rootStore.review.addReview(p);\n        return;\n      }\n      if (this.isPredictedShape(s)) {\n        return;\n      }\n      if (this.pendingMergeLine && this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n        this.mergeLines(this.pendingMergeLine, { id: s.uid, index });\n        this.clearPendingLine();\n        return;\n      }\n      this.clearPendingLine();\n      this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n      if (this.selectedShapes.length === 1 && this.selectedShapes[0] === s) {\n        this.selectedPointIndex = index;\n      } else {\n        this.selectedPointIndex = -1;\n      }\n    });\n    shape.on(EventAction.RESIZING, (s, { deltaX, deltaY }) => {\n      const { currentCamera } = this.rootStore.frame;\n      const currentFrame = this.shapesFrame;\n      if (\n        s.shapeType === ShapeType.POLYGON ||\n        s.shapeType === ShapeType.LINE ||\n        s.shapeType === ShapeType.ARROW ||\n        s.shapeType === ShapeType.KEYPOINTS\n      ) {\n        const otherSelectedPolygonsAndLines = this.selectedShapes.filter((i) => {\n          if (i === s) {\n            return false;\n          }\n          if (\n            i.shapeType !== ShapeType.POLYGON &&\n            i.shapeType !== ShapeType.LINE &&\n            i.shapeType !== ShapeType.ARROW &&\n            i.shapeType !== ShapeType.KEYPOINTS\n          ) {\n            return false;\n          }\n          const { instanceItem, camera = currentCamera } = this.shapes[i.uid] || {};\n          return !instanceItem?.cameras[camera]?.frames[currentFrame]?.locked;\n        });\n        if (otherSelectedPolygonsAndLines.length > 0) {\n          // move points together\n          this.pointsMoving = true;\n          otherSelectedPolygonsAndLines.forEach((i) => {\n            (i as Polygon | Line | Keypoints).updateSelectedPointsPosistion(deltaX, deltaY);\n            this.projectShape(i);\n          });\n        }\n      }\n      this.projectShape(s);\n    });\n    shape.on(EventAction.DRAGGING, (s, { deltaX, deltaY }) => {\n      const { currentCamera } = this.rootStore.frame;\n      const currentFrame = this.shapesFrame;\n      const otherSelectedShapes = this.selectedShapes.filter((i) => {\n        if (i === s) {\n          return false;\n        }\n        const { instanceItem, camera = currentCamera } = this.shapes[i.uid] || {};\n        return !instanceItem?.cameras[camera]?.frames[currentFrame]?.locked;\n      });\n      if (otherSelectedShapes.length > 0) {\n        // move shapes together\n        this.shapesMoving = true;\n        otherSelectedShapes.forEach((i) => {\n          i.updatePosition(i.position.x + deltaX, i.position.y + deltaY, false);\n          this.projectShape(i);\n        });\n      }\n      this.projectShape(s);\n    });\n    shape.on(EventAction.CONTEXT_MENU, (s, p) => this.rootStore.openContextMenu(p));\n    if (shape.shapeType === ShapeType.PIXEL) {\n      shape.on(PixelEventAction.HOVERED_POLYGON_CHANGE, (s, index) => {\n        const selectedShape = this.rootStore.segmentation.getSelectedShape();\n        if (selectedShape?.uid === s.uid) {\n          this.rootStore.segmentation.updateHoveredSegmentIndex(index);\n        }\n      });\n      shape.on(PixelEventAction.SELECTED_POLYGON_CHANGE, (s, index) => {\n        const selectedShape = this.rootStore.segmentation.getSelectedShape();\n        if (selectedShape?.uid === s.uid) {\n          this.rootStore.segmentation.updateSelectedSegmentIndex(index);\n        }\n      });\n    }\n  }\n\n  /**\n   * select shapes\n   * @param shapes\n   */\n  selectShapes = (shapes: Shape<ShapeData>[]) => {\n    if (this.selectedPointIndex >= 0) {\n      // has point selected\n      if (this.selectedShapes.length === 1 && shapes.length === 1 && this.selectedShapes[0] === shapes[0]) {\n        // same shape, do not unselect\n        return;\n      }\n      this.selectedPointIndex = -1;\n    }\n    let updatingShapeCurrentSelected = false;\n    let segShapeCurrentSelected = false;\n    this.selectedShapes.forEach((shape) => {\n      if (shapes.indexOf(shape) < 0) { // not selected any more\n        shape.selected = false;\n        if (shape.uid === this.updatingShape) {\n          updatingShapeCurrentSelected = true;\n        } else if (shape === this.rootStore.segmentation.updatingShape) {\n          segShapeCurrentSelected = true;\n        }\n        if (this.projectedShapes[shape.uid]) {\n          Object.values(this.projectedShapes[shape.uid]).forEach((projectedShape) => {\n            projectedShape.selected = false;\n          });\n        }\n      }\n    });\n    this.selectedShapes = [...shapes];\n    let updatingShapeShouldSelected = false;\n    let segShapeShouldSelected = false;\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = true;\n      if (shape.uid === this.updatingShape) {\n        updatingShapeShouldSelected = true;\n      } else if (shape === this.rootStore.segmentation.updatingShape) {\n        segShapeShouldSelected = true;\n      }\n      const projectedShapes = this.projectedShapes[shape.uid];\n      if (projectedShapes) {\n        Object.keys(projectedShapes).forEach((projectCamera) => {\n          const projectedShape = projectedShapes[projectCamera];\n          projectedShape.selected = true;\n          this.fitProjectShape(projectedShape, projectCamera);\n        });\n      }\n    });\n    if (updatingShapeCurrentSelected && !updatingShapeShouldSelected) {\n      this.finishUpdateShape();\n    }\n    if (segShapeCurrentSelected && !segShapeShouldSelected) {\n      this.rootStore.segmentation.cancelUpdate();\n    }\n    if (!segShapeCurrentSelected || !segShapeShouldSelected) {\n      this.rootStore.segmentation.cancelSwitch();\n    }\n  };\n\n  /**\n   * select shape by instance item\n   * @param instanceItem\n   * @param shouldPredict\n   */\n  selectShapeByInstanceItem = (\n    instanceItem: InstanceItem | InstanceItem[] | null,\n    shouldPredict = true,\n  ) => {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...instanceItem ? [instanceItem] : []];\n    this.rootStore.instance.updateActiveLayerIndexByInstanceItems(instanceItems);\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      const shapes = this.getShapesByInstanceItems(instanceItems);\n      this.selectShapes(shapes);\n      const instancesSet = new Set(instanceItems.map((i) => i.instance));\n      this.updateShapesInInstance(Array.from(instancesSet));\n      if (shouldPredict) {\n        this.predict();\n      }\n      this.hideOrShowOthers();\n    }\n  };\n\n  /**\n   * fit shapes to canvas for selected instances\n   */\n  fitShapes() {\n    const { currentCamera, cameraNames, cameraViews } = this.rootStore.frame;\n    const { selectedInstanceItems, selectedInstances } = this.rootStore.instance;\n    const { preferences } = this.rootStore.config;\n    const cameraShapes = selectedInstanceItems.length > 0\n      ? [{ camera: currentCamera, shapes: this.getShapesByInstanceItems(selectedInstanceItems) }]\n      : cameraNames.map((camera) => ({\n        camera,\n        shapes: Object.values(this.shapes).filter((s) => s.camera === camera && selectedInstances.indexOf(s.instanceItem.instance) >= 0).map((s) => s.shape),\n      }));\n    cameraShapes.forEach(({ camera, shapes }) => {\n      const cameraView = cameraViews[camera];\n      if (shapes.length > 0 && cameraView) {\n        let { left, top, right, bottom } = shapes[0].shapeBounds;\n        for (let i = 1; i < shapes.length; i += 1) {\n          const bbox = shapes[i].shapeBounds;\n          left = Math.min(bbox.left, left);\n          top = Math.min(bbox.top, top);\n          right = Math.max(bbox.right, right);\n          bottom = Math.max(bbox.bottom, bottom);\n        }\n        if (preferences.shapeFocusMode === ShapeFocusMode.ZOOM) {\n          cameraView.fitShapeToView({ left, top, right, bottom }, 0.5);\n        } else {\n          cameraView.moveShapeToViewCenter({ left, top, right, bottom });\n        }\n      }\n    });\n  }\n\n  /**\n   * click to unselect shape\n   */\n  unselectShape = () => {\n    if (\n      this.rootStore.config.addMode ||\n      this.rootStore.config.isWorkingOnAnyShape\n    ) {\n      return;\n    }\n    this.clearPendingWithAlert();\n    this.rootStore.cancelShapeWorking();\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = false;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.selected = false;\n      });\n    });\n    this.selectedShapes = [];\n    this.rootStore.instance.selectInstance(null);\n  };\n\n  /**\n   * set selected shape points\n   * @param shapePointsMap\n   */\n  setSelectedPoints = (shapePointsMap: { [shapeId: string]: number[] }) => {\n    let count = 0;\n    Object.keys(shapePointsMap).forEach((shapeId) => {\n      const { shape } = this.shapes[shapeId];\n      (shape as Polygon | Line | Keypoints).setSelectedPoints(shapePointsMap[shapeId]);\n      count += shapePointsMap[shapeId].length;\n    });\n    if (count === 1) {\n      // point can be selected\n      this.selectedPointIndex = Object.values(shapePointsMap)[0][0];\n    }\n  };\n\n  /**\n   * set selected shapes\n   * @param shapeIds\n   */\n  setSelectedShapes = (shapeIds: string[]) => {\n    const shapeItems = Object.values(this.shapes).filter(({ shape }) => shapeIds.indexOf(shape.uid) >= 0);\n    const instanceItems = shapeItems.map(({ instanceItem }) => instanceItem);\n    this.rootStore.instance.selectInstanceItem(instanceItems);\n  };\n\n  /**\n   * update shape border color\n   * @param instance\n   */\n  updateShapesInInstance = (instance?: Instance | Instance[] | null) => {\n    const instances = Array.isArray(instance) ? instance : [...instance ? [instance] : []];\n    Object.values(this.shapes).forEach(({ shape, instanceItem }) => {\n      if (instances.indexOf(instanceItem.instance) >= 0) {\n        shape.borderColor = 0xFFFF00;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = 0xFFFF00;\n        }\n      } else {\n        shape.borderColor = shape.originColors.borderColor;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = shape.originColors.color;\n        }\n      }\n    });\n  };\n\n  /**\n   * update shape line end point\n   * @param shape\n   * @param instanceItemId\n   * @param instanceId\n   */\n  updateLineEndPoint = (shape: Shape<ShapeData>, instanceItemId: string, instanceId: string) => {\n    if (shape?.shapeType === ShapeType.LINE) {\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      if (!this.previousLineEndPoint) {\n        this.previousLineEndPoint = {};\n      }\n      if (!this.previousLineEndPoint[currentCamera]) {\n        this.previousLineEndPoint[currentCamera] = {};\n      }\n      this.previousLineEndPoint[currentCamera][currentFrame] = { instanceId, instanceItemId };\n    }\n  };\n\n  /**\n   * get shape line en point by\n   */\n  getLineEndPoint = (): IPoint | undefined => {\n    let endPoint;\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const lastPointInfo = this.previousLineEndPoint?.[currentCamera]?.[currentFrame];\n\n    if (lastPointInfo) {\n      const { instanceId: lastInstanceId, instanceItemId: lastInstanceItemId } = lastPointInfo;\n      const lastInstance = this.rootStore.instance.getInstanceById(lastInstanceId);\n      const lastInstanceItem = lastInstance?.items?.[lastInstanceItemId];\n      if (lastInstanceItem) {\n        const { points: lastPoints } = (lastInstanceItem.cameras[currentCamera]?.frames?.[currentFrame]?.shape as LineData);\n        if (lastPoints && lastPoints.length > 0) {\n          endPoint = lastPoints[lastPoints.length - 1];\n        }\n      }\n    }\n    return endPoint;\n  };\n\n  /**\n   * click to draw a shape\n   * @param point\n   * @param event\n   */\n  addShape = (\n    point?: Point,\n    event?: MouseEvent,\n  ) => {\n    if (this.rootStore.initialized && this.rootStore.config.addMode && !this.drawingShape) {\n      const { selectedCategoryName, selectedCategoryItemName } = this.rootStore.ontology;\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(undefined, undefined, false);\n      this.drawingShape = this.createShape(\n        this.currentLayer!,\n        this.rootStore.frame.imageBounds,\n        this.rootStore.ontology.selectedCategoryItem.displayColor,\n        selectedCategoryName,\n        selectedCategoryItemName,\n        instanceItem\n      );\n\n      // add listeners\n      this.drawingShape.on(EventAction.FINISHED, (shape, otherShapeData) => {\n        // remove listeners after creating\n        shape.off(EventAction.FINISHED);\n        shape.off(EventAction.REMOVED);\n        shape.off(EventAction.RECOGNITION);\n\n        this.drawingShape = null;\n        const creatingShapeColor = this.creatingShapeColor;\n        const isPixel = shape.shapeType === ShapeType.PIXEL;\n        const isKeypoints = shape.shapeType === ShapeType.KEYPOINTS;\n        const shouldContinue = this.rootStore.config.continuousMode && !isPixel && !isKeypoints;\n        if (!shouldContinue) {\n          this.rootStore.config.setAddMode(false, false);\n        }\n        if (this.validateShape(shape)) {\n          // add shape to instance item\n          this.addShapeToCurrentInstanceItem(shape, creatingShapeColor, otherShapeData);\n          tracker.report({\n            name: TrackEventName.CREATE_SHAPE,\n            elementName: shape.shapeType,\n            extra: shape.getData(),\n          });\n        }\n        if (shouldContinue) {\n          shape.interactive = false;\n          if (this.rootStore.config.continuousModeType === ContinuousModeType.IN_INSTANCE) {\n            this.rootStore.ontology.selectNextCategoryItem();\n          }\n        }\n\n        if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n          if (isPixel) {\n            // switch to update mode when in default view after create\n            this.rootStore.segmentation.updateShape(shape as Pixel);\n          } else if (isKeypoints) {\n            this.startUpdateShape(false);\n          }\n        } else {\n          shape.destroy();\n        }\n        // finish creating\n        // if (finishCallback) {\n        //   finishCallback();\n        // }\n      });\n      this.drawingShape.on(EventAction.REMOVED, () => {\n        this.drawingShape = null;\n        if (this.recognitionStart && !this.rootStore.config.continuousMode) {\n          // if recognition shape removed, should set add mode to false\n          this.rootStore.config.setAddMode(false);\n        }\n      });\n      this.drawingShape.on(EventAction.RECOGNITION, (s, data) => this.onRecognize(s, data.controls));\n      const { currentOptions } = this.rootStore.ontology;\n      const { lineContinuous } = this.rootStore.shape;\n      if (lineContinuous && this.drawingShape.shapeType === ShapeType.LINE) {\n        const endPoint = this.getLineEndPoint();\n        if (endPoint) {\n          const { x, y } = endPoint;\n          const newPoint = new Point(x, y);\n          this.drawingShape.create(newPoint, currentOptions, event);\n          return this.drawingShape;\n        }\n\n        this.drawingShape.create(undefined, currentOptions, event);\n        return this.drawingShape;\n      }\n      // start create\n      this.drawingShape.create(\n        this.drawingShape.shapeType === ShapeType.LINE || this.drawingShape.shapeType === ShapeType.ARROW ? undefined : point,\n        this.drawingShape.shapeType === ShapeType.KEYPOINTS ? { selectedPointKey: this.selectedPointIndex } : currentOptions,\n        event,\n      );\n      return this.drawingShape;\n    }\n    return null;\n  };\n\n  /**\n   * add shape to current instance item\n   * @param shape\n   */\n  addShapeToCurrentInstanceItem = (shape: Shape<ShapeData>, shapeColor: string, otherShapeData?: ShapeData[]) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const instanceItem = this.rootStore.instance.getCurrentInstanceItem()!;\n    const data = shape.getData();\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    instanceItem.setShapeColorConifg({\n      fillColor: shape.fillColor,\n      edgeColor: shape.borderColor,\n      pointColor: shape.vertexColor,\n      color: shapeColor || instanceItem.colorConfig.color\n    });\n    this.creatingShapeColor = '';\n    const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n    const { prevState: prevStateItem, currState: currStateItem } = instanceItem.addShape(\n      currentCamera,\n      currentFrame,\n      autoInterpolation && shape.shapeType !== ShapeType.PIXEL,\n      shape.shapeType,\n      data,\n      activeLayerIndex,\n      shape.order,\n      this.rootStore.ontology.isOCRTool,\n      this.rootStore.ontology.isFormulaTool,\n    );\n    this.updateLineEndPoint(shape, instanceItem.id, instanceItem.instance.id);\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    const attributes = instanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [prevBasicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevStateItem ? [prevStateItem] : [] },\n        curr: { ...basicInfo, children: currStateItem ? [currStateItem] : [] }\n      }\n    };\n    const relationshipState: { prev: IRelationship[], curr: IRelationship[] } = {\n      prev: [],\n      curr: [],\n    };\n\n    if (otherShapeData) {\n      otherShapeData.forEach((shapeData) => {\n        const otherInstanceItem = this.rootStore.instance.getCurrentInstanceItem()!;\n        const prevInfo = otherInstanceItem.instance.getBasicInfo();\n        if (otherInstanceItem.instance !== instanceItem.instance) {\n          otherInstanceItem.instance.setAttributes(instanceItem.instance.attributes);\n        }\n        const { layer = activeLayerIndex } = otherInstanceItem.cameras[currentCamera]?.frames[currentFrame] || {};\n        const { prevState, currState } = otherInstanceItem.updateShape(\n          currentCamera,\n          currentFrame,\n          autoInterpolation && shape.shapeType !== ShapeType.PIXEL,\n          shape.shapeType,\n          shapeData,\n          layer,\n          shape.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer),\n          attributes,\n        );\n        this.setupShape(otherInstanceItem);\n        const currInfo = otherInstanceItem.instance.getBasicInfo();\n        if (!instanceState[currInfo.id]) {\n          instanceState[currInfo.id] = {\n            prev: { ...prevInfo, children: [] },\n            curr: { ...currInfo, children: [] }\n          };\n        }\n        const state = instanceState[currInfo.id];\n        if (prevState) {\n          state.prev.children.push(prevState);\n        }\n        if (currState) {\n          state.curr.children.push(currState);\n        }\n      });\n    }\n\n    // update segmentation store\n    if (shape.shapeType === ShapeType.PIXEL) {\n      const stat = this.rootStore.segmentation.update(instanceItem, activeLayerIndex, shape as Pixel);\n      if (stat) {\n        Object.keys(stat.instanceState).forEach((id) => {\n          if (instanceState[id]) {\n            const { prev, curr } = stat.instanceState[id];\n            instanceState[id].prev.children = [...instanceState[id].prev.children, ...prev.children];\n            instanceState[id].curr.children = [...instanceState[id].curr.children, ...curr.children];\n          } else {\n            instanceState[id] = stat.instanceState[id];\n          }\n        });\n        relationshipState.prev = stat.relationshipState.prev;\n        relationshipState.curr = stat.relationshipState.curr;\n      }\n    }\n\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev).filter((i) => i.children.length > 0),\n      relationships: relationshipState.prev,\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr),\n      relationships: relationshipState.curr,\n    });\n\n    // update shape instance\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      shape.label = instanceItem.label;\n      this.setShapeStyles(shape, instanceItem);\n      this.addShapeListeners(shape);\n      this.shapes[shape.uid] = { shape, camera: currentCamera, instanceItem };\n    }\n\n    // select\n    this.rootStore.instance.selectInstanceItem(instanceItem);\n    this.rootStore.instance.autoOpenAttributesModal();\n    // project\n    this.projectShape(shape);\n\n    // 更新nifti store中相应图形的体素信息\n    this.rootStore.nifti?.updateShape(instanceItem);\n  };\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const { currentCamera, currentFrame, cameraViews, getImageBoundsForCamera } = this.rootStore.frame;\n    const currentCameraView = cameraViews[camera];\n    const imageBounds = getImageBoundsForCamera(camera, currentFrame);\n    if (currentCameraView?.imageLoadError) {\n      return;\n    }\n\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData?.frames[currentFrame]) {\n      return;\n    }\n\n    let shapeInfo;\n    const predictedItem = Object.values(this.predictedShapes).find((i) => i.instanceItem === instanceItem);\n    if (camera === currentCamera && predictedItem) {\n      // predicted shape in current camera exists, use it\n      const { shape } = predictedItem;\n      shapeInfo = {\n        shapeType: shape.shapeType,\n        shape: shape.getData(),\n      };\n      // remove predicted shape\n      shape.destroy();\n      delete this.predictedShapes[shape.uid];\n    } else {\n      shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n    }\n\n    if (shapeInfo) {\n      if (shapeInfo.shapeType === ShapeType.PIXEL) {\n        // resolve pixel\n        const newData = this.rootStore.segmentation.resolvePixelShapeData(shapeInfo.shape as PixelData);\n        if (!newData) {\n          return;\n        }\n        shapeInfo.shape = newData;\n      } else {\n        const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n        if (area < this.rootStore.config.minArea) {\n          message.warning(i18n.translate('MIN_AREA_ALERT'));\n          return;\n        }\n      }\n      // add to model\n      const { activeLayerIndex } = this.rootStore.config;\n      this.rootStore.instance.updateFrameShapeForInstanceItem(\n        instanceItem,\n        currentFrame,\n        shapeInfo.shapeType,\n        shapeInfo.shape,\n        activeLayerIndex,\n        shapeInfo.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(activeLayerIndex, currentFrame, camera),\n        camera,\n      );\n      // create shape\n      this.setupShape(instanceItem, camera, currentCameraView.activeShapesLayer, imageBounds);\n      this.updateShapesRefreshCounter();\n      // set camera\n      if (currentCamera !== camera) {\n        this.rootStore.frame.setCamera(camera);\n      }\n      // select\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  };\n\n  /**\n   * add all predicted shapes to instances\n   * @param instances\n   */\n  addShapesToInstances = (instances: Instance[]) => {\n    let instanceItems: {\n      imageBounds: {\n        left: number;\n        top: number;\n        right: number;\n        bottom: number;\n      },\n      activeShapesLayer: Container;\n      instanceItem: InstanceItem,\n      frameIndex: number,\n      shapeType: ShapeType,\n      shape: ShapeData,\n      layer: number,\n      order: number,\n      camera: string,\n    }[] = [];\n\n    for (let index = 0; index < instances.length; index += 1) {\n      const instance = instances[index];\n      const { existedCameras } = instance;\n      for (let i = 0; i < existedCameras.length; i += 1) {\n        const camera = existedCameras[i];\n        const currentCameraView = this.rootStore.frame.cameraViews[camera];\n        if (currentCameraView?.imageLoadError) {\n          return;\n        }\n        const newInstanceItems = this.generateInstanceItemsFromPredict(instance, currentCameraView.activeShapesLayer, camera);\n        instanceItems = instanceItems.concat(newInstanceItems);\n      }\n    }\n    if (instanceItems.length > 0) {\n      // update model\n      this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      instanceItems.forEach(({ instanceItem, camera, imageBounds, activeShapesLayer }) => {\n        this.setupShape(instanceItem, camera, activeShapesLayer, imageBounds);\n      });\n    }\n  };\n\n  /**\n   * add predicted shapes to instance\n   * @param instance\n   * @param camera\n   */\n  addShapesToInstance = (instance: Instance, camera = this.rootStore.frame.currentCamera) => {\n    const currentCameraView = this.rootStore.frame.cameraViews[camera];\n    if (currentCameraView?.imageLoadError) {\n      return;\n    }\n    const instanceItems = this.generateInstanceItemsFromPredict(instance, currentCameraView.activeShapesLayer);\n    if (instanceItems.length > 0) {\n      // update model\n      this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      // setup shapes\n      instanceItems.forEach(({ instanceItem, imageBounds, activeShapesLayer }) => {\n        this.setupShape(instanceItem, camera, activeShapesLayer, imageBounds);\n      });\n      // select\n      this.rootStore.instance.selectInstanceItem(null);\n      this.rootStore.instance.selectInstance(instance);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  };\n\n  /**\n   * generate instanceItems by predicted shapes\n   * @param instance\n   * @param activeShapesLayer\n   * @param camera\n   */\n  generateInstanceItemsFromPredict = (instance: Instance, activeShapesLayer: Container, camera = this.rootStore.frame.currentCamera) => {\n    const { currentFrame, getImageBoundsForCamera, getNextShapeOrder } = this.rootStore.frame;\n    const imageBounds = getImageBoundsForCamera(camera, currentFrame);\n    const { activeLayerIndex } = this.rootStore.config;\n    const instanceItems: {\n      imageBounds: {\n        left: number;\n        top: number;\n        right: number;\n        bottom: number;\n      },\n      activeShapesLayer: Container,\n      instanceItem: InstanceItem,\n      frameIndex: number,\n      shapeType: ShapeType,\n      shape: ShapeData,\n      layer: number,\n      order: number,\n      camera: string,\n    }[] = [];\n    Object.values(instance.items).forEach((instanceItem) => {\n      const cameraData = instanceItem.cameras[camera];\n      if (!cameraData || !cameraData.frames[currentFrame]) {\n        // not exist in current frame\n        let shapeInfo;\n        const predictedItem = Object.values(this.predictedShapes).find((i) => i.instanceItem === instanceItem);\n        if (predictedItem) {\n          // predicted shape in current camera exists, use it\n          const { shape } = predictedItem;\n          shapeInfo = {\n            shapeType: shape.shapeType,\n            shape: shape.getData(),\n          };\n          // remove predicted shape\n          shape.destroy();\n          delete this.predictedShapes[shape.uid];\n        } else {\n          shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n        }\n\n        if (shapeInfo) {\n          if (shapeInfo.shapeType === ShapeType.PIXEL) {\n            // resolve pixel\n            const newData = this.rootStore.segmentation.resolvePixelShapeData(shapeInfo.shape as PixelData);\n            if (!newData) {\n              return;\n            }\n            shapeInfo.shape = newData;\n          } else {\n            const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n            if (area < this.rootStore.config.minArea) {\n              return;\n            }\n          }\n          instanceItems.push({\n            imageBounds,\n            activeShapesLayer,\n            instanceItem,\n            frameIndex: currentFrame,\n            layer: activeLayerIndex,\n            order: shapeInfo.shapeType === ShapeType.PIXEL ? 0 : getNextShapeOrder(activeLayerIndex, currentFrame, camera),\n            camera,\n            ...shapeInfo,\n          });\n        }\n      }\n    });\n    return instanceItems;\n  };\n\n  /**\n   * setup shape in current camera & current frame\n   * @param instanceItem\n   * @param shapeContainer\n   * @param imageBounds\n   */\n  setupShape = (\n    instanceItem: InstanceItem,\n    camera = this.rootStore.frame.currentCamera,\n    shapeContainer?: Container,\n    imageBounds?: { left: number; top: number; right: number; bottom: number; },\n  ) => {\n    const { cameraViews, currentFrame } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        // remove shape if already exists\n        const existingShape = this.getShapeByInstanceItem(instanceItem, camera);\n        const { interactive: originInteractive = true } = existingShape || {};\n        const existingShapeId = existingShape?.uid;\n        if (existingShape) {\n          this.deleteShape(existingShape);\n        }\n        // add shape\n        if (!cameraViews[camera]?.imageLoadError) {\n          const { layer = this.rootStore.config.activeLayerIndex } = frameData;\n          let order;\n          if (frameData.order !== undefined) {\n            order = frameData.order;\n          } else {\n            order = frameData.shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer, currentFrame, camera);\n          }\n          const shape = this.createShape(\n            shapeContainer || cameraViews[camera].getShapesLayerByIndex(layer),\n            imageBounds || this.rootStore.frame.getImageBoundsForCamera(camera, currentFrame),\n            instanceItem.colorConfig.color,\n            instanceItem.instance.category,\n            instanceItem.name,\n            instanceItem,\n            frameData.shapeType,\n            frameData.shape,\n            order,\n            instanceItem.label,\n            camera,\n          );\n          instanceItem.setShapeColorConifg({\n            fillColor: shape.fillColor,\n            edgeColor: shape.borderColor,\n            pointColor: shape.vertexColor,\n            color: instanceItem.colorConfig.color\n          });\n          this.updateLineEndPoint(shape, instanceItem.id, instanceItem.instance.id);\n          if (shape.destroyed) {\n            // delete instance item\n            this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame, camera);\n            return;\n          }\n          shape.interactive = originInteractive && !this.rootStore.config.measureMode;\n          shape.editable = !this.rootStore.readonly && !frameData.locked;\n          if (frameData.isPreAnnotation) {\n            shape.labelDom?.setPrefix(createLabelPrefix());\n          }\n          this.setShapeStyles(shape, instanceItem, camera);\n          this.addShapeListeners(shape);\n          this.shapes[shape.uid] = { shape, camera, instanceItem };\n          this.rootStore.relationship.setupConnectionsForInstanceItem(instanceItem);\n          if (this.pendingMergePolygon === existingShapeId) {\n            this.pendingMergePolygon = shape.uid;\n          }\n          if (this.pendingMergeLine && this.pendingMergeLine.id === existingShapeId) {\n            this.pendingMergeLine.id = shape.uid;\n          }\n          if (this.cuttingShape === existingShapeId) {\n            this.cuttingShape = shape.uid;\n          }\n          if (this.splittingShape === existingShapeId) {\n            this.splittingShape = shape.uid;\n          }\n          if (this.appendingShape === existingShapeId) {\n            this.appendingShape = shape.uid;\n          }\n          if (this.updatingShape === existingShapeId) {\n            this.updatingShape = shape.uid;\n          }\n          this.projectShape(shape, camera);\n        }\n      }\n    }\n  };\n\n  /**\n   * predict in current camera & current frame\n   */\n  predict = async () => {\n    if (Object.keys(this.predictedShapes).length > 0) {\n      this.updateShapesRefreshCounter();\n    }\n    this.clearPredictedShapes();\n\n    if (\n      !this.rootStore.config.autoTracking ||\n      this.rootStore.readonly ||\n      this.rootStore.config.viewMode === ViewMode.GRID ||\n      this.rootStore.filter.filterMode // no to predict in filter mode\n    ) {\n      return;\n    }\n\n    const { isMultiSelected, selectedInstances, selectedInstanceItems } = this.rootStore.instance;\n    if (isMultiSelected) {\n      return;\n    }\n\n    if (selectedInstances.length === 1) {\n      const { currentCamera, currentFrame, currentCameraView, imageBounds } = this.rootStore.frame;\n      if (currentCameraView?.imageLoadError) {\n        return;\n      }\n\n      const selectedInstance = selectedInstances[0];\n      const { predictiveMode } = this.rootStore.config;\n      if (predictiveMode === PredictiveMode.NONE) {\n        return;\n      }\n\n      const predictInstance = predictiveMode === PredictiveMode.SELECTED_INSTANCE || selectedInstanceItems.length === 0;\n      const predictiveItems = predictInstance ? Object.values(selectedInstance.items) : selectedInstanceItems;\n      const segmentPredictiveItems: InstanceItem[] = [];\n      predictiveItems.forEach((item) => {\n        const shapeInfo = item.predictShape(currentCamera, currentFrame, imageBounds);\n        if (shapeInfo?.shapeType === ShapeType.PIXEL || shapeInfo?.shapeType === ShapeType.POLYGON) {\n          segmentPredictiveItems.push(item);\n        } else if (shapeInfo) {\n          // create predict shape\n          this.createPredictedShape(item, shapeInfo.shapeType, shapeInfo.shape);\n        }\n      });\n      // 非物体预测模式下，或当前帧没有色块，才执行分割预测（不然预测图形可能会和现有图形重叠，出现问题）\n      const segmentPredict = !predictInstance || !predictiveItems.some((item) => item.cameras[currentCamera]?.frames[currentFrame]?.shapeType === ShapeType.PIXEL);\n      if (segmentPredict) {\n        await this.predictShapeByModel(segmentPredictiveItems);\n      }\n      this.updateShapesRefreshCounter();\n    }\n  };\n\n  /**\n   * predict shapes by model\n   * @param instanceItems\n   */\n  async predictShapeByModel(instanceItems: InstanceItem[]) {\n    if (!this.rootStore.config.modelPrediction || instanceItems.length === 0) {\n      return;\n    }\n\n    const { currentCamera, currentFrame, imageBounds, getImageUrl, getImageBoundsForCamera, getFrameRotationForCamera } = this.rootStore.frame;\n\n    // currently, only support predict from previous frames\n    let baseFrame = currentFrame - 1;\n    while (baseFrame >= 0) {\n      // eslint-disable-next-line no-loop-func\n      if (instanceItems.some((item) => item.cameras[currentCamera]?.frames[baseFrame] !== undefined)) {\n        // 只要有一个组件存在，就作为基准帧进行后续的预测\n        break;\n      }\n      baseFrame -= 1;\n    }\n\n    if (baseFrame >= 0) {\n      const baseShapes: PredictBaseShape[] = [];\n      for (let i = 0; i < instanceItems.length; i += 1) {\n        const instanceItem = instanceItems[i];\n        const frameData = instanceItem.cameras[currentCamera]?.frames[baseFrame];\n        if (frameData) {\n          baseShapes.push({\n            shapeType: frameData.shapeType,\n            shape: frameData.shape,\n            layer: frameData.layer,\n            order: frameData.order,\n            instanceId: instanceItem.instance.id,\n            instanceItemId: instanceItem.id,\n          });\n        }\n      }\n\n      const bounds = getImageBoundsForCamera(currentCamera, baseFrame);\n      const width = bounds.right - bounds.left;\n      const height = bounds.bottom - bounds.top;\n\n      const { shapesByLayer, masksByLayer } = fillMask(baseShapes, width, height);\n\n      // FIXME: currently only one mask supported\n      const { activeLayerIndex } = this.rootStore.config;\n      const activeMask = masksByLayer[activeLayerIndex];\n\n      if (!activeMask) {\n        return;\n      }\n\n      try {\n        // 还原回原始图片尺寸进行模型预测\n        const rotation = getFrameRotationForCamera(currentCamera, baseFrame);\n        const originMask = rotateMask(activeMask, -rotation, [width, height]);\n\n        // 检查一下mask是不是一样\n        let sameMask = true;\n        if (\n          this.cachedPredictInfo?.baseFrame === baseFrame &&\n          this.cachedPredictInfo?.targetFrame === currentFrame\n        ) {\n          for (let i = 0; i < originMask.length; i += 1) {\n            if (originMask[i] !== this.cachedPredictInfo.mask[i]) {\n              sameMask = false;\n              break;\n            }\n          }\n        } else {\n          sameMask = false;\n        }\n\n        let buffer;\n        if (!sameMask) {\n          const compressed = deflate(new Uint8Array(originMask));\n          const file = new File([compressed], 'mask.bin');\n\n          const formData = new FormData();\n          formData.append('imgPrevUrl', getImageUrl(currentCamera, baseFrame));\n          formData.append('imgCurUrl', getImageUrl(currentCamera, currentFrame));\n          formData.append('maskPrev', file);\n\n          this.rootStore.frame.loading = true;\n          if (this.rootStore.config.predictProxy) {\n            buffer = await fetch(`${this.rootStore.config.predictProxy}/predict`, {\n              method: 'POST',\n              body: formData,\n            }).then((res) => res.arrayBuffer());\n          } else {\n            buffer = await this.rootStore.jobProxy?.forwardAPI(APIForwardType.FRAME_SEGMENTATION, formData);\n          }\n\n          this.cachedPredictInfo = {\n            buffer,\n            baseFrame,\n            targetFrame: currentFrame,\n            mask: originMask,\n          };\n        } else {\n          buffer = this.cachedPredictInfo?.buffer;\n        }\n\n        if (buffer && this.rootStore.frame.currentFrame === currentFrame) {\n          // continue\n          const currRotation = getFrameRotationForCamera(currentCamera, currentFrame);\n          const currWidth = imageBounds.right - imageBounds.left;\n          const currHeight = imageBounds.bottom - imageBounds.top;\n\n          const decompressed = inflate(buffer);\n          const currMask = rotateMask(Array.from(decompressed), currRotation, [currHeight, currWidth]); // size只有在rotation是90/270度时才有用，可以简单处理，直接反一下宽高\n          const pixels = resolveMask(currMask, currWidth, currHeight);\n\n          const activeShapes = shapesByLayer[activeLayerIndex];\n          for (let i = 0; i < pixels.length; i += 1) {\n            const { instanceId, instanceItemId } = activeShapes[i];\n            const instance = this.rootStore.instance.getInstanceById(instanceId);\n            const instanceItem = instance?.items[instanceItemId];\n            // because prediction is async, need double check if already exist before add predict shape\n            const alreadyExist = instanceItem?.cameras[currentCamera]?.frames[currentFrame] !== undefined;\n            if (!alreadyExist) {\n              const pixel = pixels[i];\n              const pixelData = new PixelsData({ size: [currHeight, currWidth] });\n              pixelData.append(pixel);\n\n              const { shapeType } = instanceItem.cameras[currentCamera].frames[baseFrame];\n              if (shapeType === ShapeType.PIXEL) {\n                const shape: PixelData = {\n                  data: pixelData.data,\n                  polygons: pixelData.cachedPolygons,\n                  area: 0,\n                };\n                shape.area = calcShapeArea(shapeType, shape);\n                this.rootStore.shape.createPredictedShape(instanceItem, shapeType, shape);\n              } else if (shapeType === ShapeType.POLYGON) {\n                const shape: PolygonData = {\n                  points: simplify(pixelData.cachedPolygons[0][0].map(([x, y]) => ({ x, y }))),\n                  area: 0,\n                };\n                shape.area = calcShapeArea(shapeType, shape);\n                this.rootStore.shape.createPredictedShape(instanceItem, shapeType, shape);\n              }\n            }\n          }\n        }\n        this.rootStore.frame.loading = false;\n      } catch (e) {\n        this.rootStore.frame.loading = false;\n      }\n    }\n  };\n\n  /**\n   * create predict shape\n   * @param item\n   * @param shapeType\n   * @param shape\n   */\n  createPredictedShape(item: InstanceItem, shapeType: ShapeType, shape: ShapeData) {\n    const predictedShape = this.createShape(\n      this.currentLayer!,\n      this.rootStore.frame.imageBounds,\n      item.colorConfig.color,\n      item.instance.category,\n      item.name,\n      item,\n      shapeType,\n      shape,\n      9999, // predicted shape always on the top\n      item.label,\n    );\n    predictedShape.borderStyle = BorderStyle.DASHED;\n    predictedShape.borderColor = 0xFFFF00;\n    if (predictedShape.shapeType === ShapeType.DOT) {\n      predictedShape.color = 0xFFFF00;\n    }\n    predictedShape.interactive = !this.rootStore.config.measureMode;\n    predictedShape.editable = this.rootStore.config.reviewMode === ReviewMode.LABELING;\n    if (this.rootStore.instance.selectedInstanceItems.indexOf(item) >= 0) {\n      predictedShape.selected = true;\n    }\n    // add listeners\n    this.addShapeListeners(predictedShape);\n    this.predictedShapes[predictedShape.uid] = {\n      shape: predictedShape,\n      instanceItem: item,\n    };\n  };\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete = () => {\n    const selectedShape = this.rootStore.segmentation.getSelectedShape();\n    const pixelSegDeleted = selectedShape?.editable && selectedShape.deleteSelectedPolygon();\n    if (pixelSegDeleted) {\n      return;\n    }\n    if (selectedShape) {\n      selectedShape.selectedPolygonIndex = -1;\n    }\n\n    if (this.selectedShapes.length > 0) {\n      this.deleting = true;\n      this.selectedPointIndex = -1;\n\n      const pointsDeletedShapes: Shape<ShapeData>[] = [];\n      this.selectedShapes.forEach((shape) => {\n        const deleted = shape.deleteSelectedPoints();\n        if (deleted) {\n          pointsDeletedShapes.push(shape);\n        }\n      });\n\n      const { currentFrame } = this.rootStore.frame;\n      if (pointsDeletedShapes.length > 0) {\n        // has points deleted shapes\n        const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape?: ShapeData }[] = [];\n        pointsDeletedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            instanceItems.push({\n              instanceItem: shapeItem.instanceItem,\n              frameIndex: currentFrame,\n              shapeType: shape.shapeType,\n              shape: shape.destroyed ? undefined : shape.getData(),\n            });\n            if (shape.destroyed) {\n              this.deleteShape(shape);\n            } else {\n              this.projectShape(shape);\n            }\n          }\n        });\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      } else {\n        // should delete shapes\n        const instanceItems: { instanceItem: InstanceItem, frames: number[] }[] = [];\n        this.selectedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            const { instanceItem } = shapeItem;\n            instanceItems.push({ instanceItem, frames: [currentFrame] });\n          }\n        });\n        this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);\n        this.rootStore.filter.filterInstances();\n        this.predict();\n      }\n    }\n    this.deleting = false;\n  };\n\n  /**\n   * delete shape instance\n   * @param shape\n   */\n  deleteShape = (shape: Shape<ShapeData>) => {\n    const index = this.selectedShapes.indexOf(shape);\n    if (index >= 0) {\n      this.selectedShapes.splice(index, 1);\n    }\n    shape.destroy();\n    delete this.shapes[shape.uid];\n\n    if (this.projectedShapes[shape.uid]) {\n      Object.values(this.projectedShapes[shape.uid]).forEach((s) => {\n        s.destroy();\n      });\n      delete this.projectedShapes[shape.uid];\n    }\n  };\n\n  /**\n   * delete shape by instance item\n   * @param instanceItem\n   */\n  deleteShapeByInstanceItem = (instanceItem: InstanceItem) => {\n    const shape = this.getShapeByInstanceItem(instanceItem);\n    if (shape) {\n      this.deleteShape(shape);\n    }\n  };\n\n  /**\n   * reset recognition data\n   */\n  resetRecognition() {\n    this.recognitionStart = false;\n  }\n\n  // imageSegmentation(url: string, clicks: string, prevMask = '[]', imageRotation = 0) {\n  //   const formData = new FormData();\n  //   formData.append('url', url);\n  //   formData.append('clicks', clicks);\n  //   formData.append('prev_mask', prevMask);\n  //   formData.append('rotation', `${imageRotation}`);\n\n  //   const fetchPromise = new Promise<{ x: number; y: number }[][]>((resolve, reject) => {\n  //     this.rootStore.jobProxy?.forwardAPI(APIForwardType.INTERACTIVE_SEGMENTATION, formData)\n  //       .then((res) => {\n  //         if (res.status === 200) {\n  //           return res;\n  //         }\n  //         throw new Error('Request failed.');\n  //       })\n  //       .then((res) => {\n  //         const { data } = res;\n  //         if (!Array.isArray(data) || data.some((d) => !Array.isArray(d))) {\n  //           throw new Error('Invalid result.');\n  //         }\n  //         resolve(data);\n  //       })\n  //       .catch((e) => reject(e));\n  //   });\n  //   const timeoutPromise = new Promise<{ x: number; y: number }[][]>((_, reject) => {\n  //     setTimeout(() => reject(), 8000);\n  //   });\n\n  //   return Promise.race([fetchPromise, timeoutPromise]);\n  // }\n\n  /**\n   * on recognize\n   * @param shape\n   * @param controls\n   */\n  onRecognize = (shape: Shape<ShapeData>, controls: ControlPoint[]) => {\n    const recognitionStart = this.recognitionStart === false;\n    if (shape.shapeType === ShapeType.PIXEL) {\n      this.rootStore.config.setCursor((shape as Pixel).currCursor);\n    } else {\n      this.rootStore.config.setCursor(Cursor.DEFAULT); // use default cursor, not crosshair\n    }\n    // do recognition\n    this.recognitionStart = true;\n    this.requestRecognition(shape, controls, recognitionStart);\n  };\n\n  /**\n   * setup recognizer\n   */\n  setupRecognizer() {\n    if (!this.recognizer) {\n      this.recognizer = new Recognizer();\n    }\n  }\n\n  /**\n   * load image for recognizer\n   */\n  async loadImageForRecognizer() {\n    if (this.recognizer) {\n      const { currentFrame, currentFrameRotation, currentCamera, currentCameraImage, imageEmbeddings, getImageUrl } = this.rootStore.frame;\n      let imageUrl = getImageUrl(currentCamera, currentFrame);\n      if (isPDFUrl(imageUrl) || isVideoUrl(imageUrl)) {\n        // TODO: current pdf not support\n        imageUrl = '';\n      }\n      await this.recognizer.setImage(\n        this.rootStore.proxyResource(imageUrl),\n        currentFrameRotation,\n        this.rootStore.proxyResource(imageEmbeddings[currentCamera]?.[currentFrame]?.[currentCameraImage]),\n      );\n    }\n  }\n\n  /**\n   * request recognition\n   * @param shape\n   * @param controls\n   * @param recognitionStart\n   */\n  requestRecognition = async (shape: Shape<ShapeData>, controls: ControlPoint[], recognitionStart: boolean) => {\n    this.rootStore.frame.loading = true;\n    setTimeout(async () => {\n      if (recognitionStart) {\n        this.setupRecognizer();\n        await this.loadImageForRecognizer();\n      }\n      try {\n        if (shape.shapeType === ShapeType.RECTANGLE) {\n          // object detection\n          if (controls.length === 0) {\n            throw new Error('Invalid control points');\n          }\n          const { left, top, right, bottom } = this.rootStore.frame.imageBounds;\n          const rSize = { left, top, right, bottom };\n          const [p1, p2] = controls;\n          if (p1 && p2) {\n            rSize.left = Math.max(Math.min(p1.x, p2.x), left);\n            rSize.top = Math.max(Math.min(p1.y, p2.y), top);\n            rSize.right = Math.min(Math.max(p1.x, p2.x), right);\n            rSize.bottom = Math.min(Math.max(p1.y, p2.y), bottom);\n          } else {\n            const width = right - left;\n            const height = bottom - top;\n            rSize.left = Math.max(p1.x - width / 4, left);\n            rSize.top = Math.max(p1.y - height / 4, top);\n            rSize.right = Math.min(p1.x + width / 4, right);\n            rSize.bottom = Math.min(p1.y + height / 4, bottom);\n          }\n\n          const recognizedBoxes = await this.recognizer!.detect(rSize);\n          if (this.rootStore.ontology.currentCreateMethod === CVModel.OBJECT_DETECTION_MULTI) {\n            this.finishMultiObjectsDetection(recognizedBoxes);\n          } else {\n            let recognizedBox;\n            let recognizedDis2;\n            for (let i = 0; i < recognizedBoxes.length; i += 1) {\n              const box = recognizedBoxes[i];\n              // check box contains p1\n              if (!p2 && (p1.x < box.left || p1.x > box.right || p1.y < box.top || p1.y > box.bottom)) {\n                // eslint-disable-next-line no-continue\n                continue;\n              }\n              const dis2 = ((box.left + box.right) / 2 - p1.x) ** 2 + ((box.top + box.bottom) / 2 - p1.y) ** 2;\n              if (recognizedDis2 === undefined || dis2 < recognizedDis2) {\n                recognizedDis2 = dis2;\n                recognizedBox = box;\n              }\n            }\n            if (!recognizedBox) {\n              throw new Error('No valid recognized boxes');\n            }\n            (shape as Rectangle).finishRecognition(recognizedBox);\n          }\n        } else {\n          // segmentation\n          const isPixel = shape.shapeType === ShapeType.PIXEL;\n          const recognizedPixels = await this.recognizer!.segment(\n            controls,\n            isPixel && !(shape as Pixel).pixelsData.isEmpty && (shape as Pixel).pixelsData,\n            !isPixel,\n          );\n          if (!isPixel) {\n            (shape as Polygon | Line).setRecognizedPolygon(recognizedPixels.cachedPolygons);\n          } else {\n            (shape as Pixel).finishRecognition(recognizedPixels.pixels);\n          }\n        }\n      } catch (e) {\n        message.error(i18n.translate('RECOGNITION_FAIL'));\n        if (shape.shapeType === ShapeType.RECTANGLE) {\n          this.rootStore.config.setAddMode(false);\n        }\n      }\n      this.rootStore.frame.loading = false;\n    }, 10);\n  };\n\n  /**\n   * finish recognition\n   */\n  finishRecognition = () => {\n    if (this.recognitionStart) {\n      (this.drawingShape as Polygon).finishCreate();\n    }\n  };\n\n  /**\n   * finish multii objects detection\n   * @param boxes\n   */\n  finishMultiObjectsDetection = (boxes: { left: number; top: number; right: number; bottom: number }[]) => {\n    // preserve color\n    const fillColor = this.drawingShape!.fillColor;\n    const edgeColor = this.drawingShape!.borderColor;\n    const pointColor = this.drawingShape!.vertexColor;\n    const color = this.creatingShapeColor;\n    // set add mode to false\n    this.rootStore.config.setAddMode(false);\n\n    const { currentCamera, currentFrame, getNextShapeOrder } = this.rootStore.frame;\n    const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n    const { selectInstanceItem } = this.rootStore.instance;\n\n    const prevInstanceMap: Record<string, IInstance> = {};\n    const currInstanceMap: Record<string, IInstance> = {};\n    const affectedInstanceItems: Record<string, InstanceItem> = {};\n    boxes.forEach((box, i) => {\n      const data: RectangleData = {\n        x: this.precise(box.left),\n        y: this.precise(box.top),\n        width: this.precise(box.right - box.left),\n        height: this.precise(box.bottom - box.top),\n        area: 0,\n        points: [\n          { x: this.precise(box.left), y: this.precise(box.top) },\n          { x: this.precise(box.right), y: this.precise(box.top) },\n          { x: this.precise(box.right), y: this.precise(box.bottom) },\n          { x: this.precise(box.left), y: this.precise(box.bottom) },\n        ],\n      };\n      data.area = calcShapeArea(ShapeType.RECTANGLE, data);\n\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem()!;\n\n      if (i === 0) {\n        // use last creating shape color\n        instanceItem.setShapeColorConifg({\n          fillColor,\n          edgeColor,\n          pointColor,\n          color: color || instanceItem.colorConfig.color,\n        });\n      }\n\n      const { prevState, currState } = instanceItem.addShape(\n        currentCamera,\n        currentFrame,\n        autoInterpolation,\n        ShapeType.RECTANGLE,\n        data,\n        activeLayerIndex,\n        getNextShapeOrder(),\n        false,\n        false,\n      );\n      if (prevState) {\n        if (!prevInstanceMap[instanceItem.instance.id]) {\n          prevInstanceMap[instanceItem.instance.id] = {\n            ...instanceItem.instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        prevInstanceMap[instanceItem.instance.id].children.push(prevState);\n      }\n      if (currState) {\n        if (!currInstanceMap[instanceItem.instance.id]) {\n          currInstanceMap[instanceItem.instance.id] = {\n            ...instanceItem.instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        currInstanceMap[instanceItem.instance.id].children.push(currState);\n      }\n\n      affectedInstanceItems[instanceItem.id] = instanceItem;\n      this.setupShape(instanceItem);\n      selectInstanceItem(instanceItem);\n    });\n\n    const items = Object.values(affectedInstanceItems);\n    if (items.length > 0) {\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap),\n      }, {\n        instances: Object.values(currInstanceMap),\n      });\n      this.rootStore.instance.openAttributesModalForInstanceItems(items);\n    }\n  };\n\n  /**\n   * set points user data for shape by hotkey\n   * @param shape\n   * @param hotkey\n   */\n  setPointsUserDataByHotkey = (shape: Shape<ShapeData>, hotkey: string) => {\n    if (\n      shape instanceof Polygon ||\n      shape instanceof Line ||\n      shape instanceof QuadPrism ||\n      shape instanceof OrientedQuadPrism ||\n      shape instanceof Keypoints\n    ) {\n      const hotkeyItems = this.rootStore.config.pointHotkeyMap[hotkey] || [];\n      const selectedPoints = shape.getSelectedPoints();\n      if (hotkeyItems.length > 0 && selectedPoints.length > 0) {\n        const pointsData: { index: number; userData: any }[] = [];\n        selectedPoints.forEach(({ index, point }) => {\n          let userData = { ...point.userData };\n          hotkeyItems.forEach(({ type, attributes }) => {\n            userData = type === 'overwrite' ? { ...attributes } : { ...userData, ...attributes };\n          });\n          pointsData.push({ index, userData });\n        });\n        shape.setPointsUserData(pointsData);\n      }\n    }\n  };\n\n  /**\n   * set points user data for shape\n   * @param shape\n   * @param pointIndex\n   * @param userData\n   */\n  setPointUserData = (shape: Shape<ShapeData>, pointIndex: number, userData: any) => {\n    if (\n      shape instanceof Polygon ||\n      shape instanceof Line ||\n      shape instanceof QuadPrism ||\n      shape instanceof OrientedQuadPrism ||\n      shape instanceof Keypoints\n    ) {\n      const pointsData = [{ index: pointIndex, userData }];\n      shape.setPointsUserData(pointsData);\n    }\n  };\n\n  /**\n   * get intersections for shape\n   * @param shape\n   */\n  getIntersectionsForShape(shape: Shape<ShapeData>) {\n    const shapes = this.getShapesForCameraByLayer(this.rootStore.frame.currentCamera).map((i) => i.shape).filter((s) => s.visible && s.finished);\n    const intersections = shape.findIntersections(shapes);\n    return intersections;\n  }\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA: Shape<ShapeData>, shapeB: Shape<ShapeData>) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const { instanceItem: instanceItemA } = this.shapes[shapeA.uid];\n    const { instanceItem: instanceItemB } = this.shapes[shapeB.uid];\n    const instanceInfoA = instanceItemA.instance.getBasicInfo();\n    const instanceInfoB = instanceItemB.instance.getBasicInfo();\n\n    // save state\n    const prevInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      prevInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    const storeId = this.rootStore.undo.preserve({ instances: prevInstances });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    shapeA.order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    shapeB.order = orderA;\n\n    const currInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      currInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    this.rootStore.undo.save(storeId, { instances: currInstances });\n  }\n\n  /**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */\n  moveToTop(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, getNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const { layer } = frameData;\n    const cameraShapes = this.getShapesForCameraByLayer(currentCamera, layer);\n    const maxOrder = Math.max(...cameraShapes.map((s) => s.shape.order));\n    if (maxOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_FRONT_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n    // preserve state\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n    // update order\n    const order = getNextShapeOrder(layer);\n    frameData.order = order;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = order;\n    }\n    // save state\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n\n    message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));\n  }\n\n  /**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */\n  moveToBottom(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, updateNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const { layer } = frameData;\n    const cameraShapes = this.getShapesForCameraByLayer(currentCamera, layer);\n    const minOrder = Math.min(...cameraShapes.map((s) => s.shape.order));\n    if (minOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_BACK_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n\n    // prev instance state map\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n    // update selected shape order\n    const startOrder = this.rootStore.segmentation.enabled ? 1 : 0;\n    frameData.order = startOrder;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = startOrder;\n    }\n    // current instance state map\n    const currInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n\n    if (minOrder <= startOrder) {\n      // show move all camera shapes upper\n      for (let i = 0; i < cameraShapes.length; i += 1) {\n        const { shape: s, instanceItem: sInstanceItem } = cameraShapes[i];\n        if (sInstanceItem.id !== instanceItem.id) {\n          // not selected shape\n          const sInstanceInfo = sInstanceItem.instance.getBasicInfo();\n          const sInstanceItemInfo = sInstanceItem.getBasicInfo();\n          const sCameraData = sInstanceItem.cameras[currentCamera];\n          if (!prevInstanceMap[sInstanceInfo.id]) {\n            prevInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          prevInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n          // update not selected shape's order\n          const order = s.order + 1;\n          sCameraData.frames[currentFrame].order = order;\n          s.order = order;\n          updateNextShapeOrder(order, layer, currentFrame, currentCamera);\n          if (!currInstanceMap[sInstanceInfo.id]) {\n            currInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          currInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n        }\n      }\n    }\n\n    // save state\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n    });\n\n    message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));\n  }\n\n  /**\n   * move selected shape to front\n   * @param toTop\n   */\n  moveFront = (toTop = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (!selectedShape.editable) {\n        return;\n      }\n      if (toTop) {\n        this.moveToTop(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const upperShape = getUpperShape(selectedShape, intersections);\n        if (upperShape) {\n          this.exchangeShapeOrder(selectedShape, upperShape);\n          message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_FRONT_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  /**\n   * move selected shape to back\n   * @param toBottom\n   */\n  moveBack = (toBottom = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (!selectedShape.editable) {\n        return;\n      }\n      if (toBottom) {\n        this.moveToBottom(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const underShape = getUnderShape(selectedShape, intersections);\n        if (underShape) {\n          this.exchangeShapeOrder(selectedShape, underShape);\n          message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_BACK_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  clearPendingWithAlert = () => {\n    if (this.pendingMergePolygon || this.pendingMergeLine || this.pendingMergePixel) {\n      message.info(i18n.translate('MERGE_CANCEL'));\n    }\n    this.clearPending();\n  };\n\n  clearPending = () => {\n    this.pendingMergePolygon = '';\n    this.pendingMergePixel = null;\n    this.clearPendingLine();\n  };\n\n  clearPendingLine = () => {\n    if (this.pendingMergeLine) {\n      Object.values(this.shapes).forEach(({ shape }) => {\n        if (shape instanceof Line) {\n          shape.hoverMode = HoverMode.DEFAULT;\n        }\n      });\n    }\n    this.pendingMergeLine = null;\n  };\n\n  merge = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1 ||\n      this.rootStore.segmentation.updatingShape\n    ) {\n      return;\n    }\n\n    const selectedShape = this.selectedShapes[0];\n    if (!selectedShape.editable) {\n      return;\n    }\n\n    this.rootStore.relationship.cancel(); // cancel relationship\n\n    const { shapeType } = selectedShape;\n    if (shapeType === ShapeType.POLYGON) {\n      // merge polygon\n      this.endShapeCutting(); // cancel cutting\n      const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera, true).map((i) => i.shape);\n      const intersectPolygonIds = (selectedShape as Polygon).findIntersectPolygons(shapes);\n      if (intersectPolygonIds.length === 1) {\n        this.mergePolygons(selectedShape.uid, intersectPolygonIds[0]);\n      } else if (intersectPolygonIds.length === 0) {\n        message.warn(i18n.translate('MERGE_NO_INTERSECT'));\n      } else {\n        this.pendingMergePolygon = selectedShape.uid;\n        message.info(i18n.translate('MERGE_SELECT_NEXT'));\n      }\n    } else if (shapeType === ShapeType.LINE || shapeType === ShapeType.ARROW) {\n      const { points } = selectedShape as Line;\n      if (this.selectedPointIndex === 0 || this.selectedPointIndex === points.length - 1) {\n        // merge line\n        this.pendingMergeLine = {\n          id: selectedShape.uid,\n          index: this.selectedPointIndex,\n        };\n        message.info(i18n.translate('MERGE_SELECT_NEXT_LINE'));\n        this.getShapesForCamera(this.rootStore.frame.currentCamera, true).forEach(({ shape }) => {\n          if (shape.uid !== selectedShape.uid && (shape.shapeType === ShapeType.LINE || shape.shapeType === ShapeType.ARROW)) {\n            (shape as Line).hoverMode = HoverMode.ENDPOINT;\n          }\n        });\n      }\n    } else if (shapeType === ShapeType.PIXEL) {\n      this.endShapeCutting();\n      this.pendingMergePixel = {\n        id: selectedShape.uid,\n        index: this.rootStore.segmentation.selectedSegmentIndex,\n      };\n      message.info(i18n.translate('MERGE_SELECT_NEXT_PIXEL'));\n    }\n  };\n\n  mergeLines(baseLine: { id: string; index: number }, line: { id: string; index: number }) {\n    const { shape: baseShape, instanceItem: baseInstanceItem } = this.shapes[baseLine.id];\n    const { shape, instanceItem } = this.shapes[line.id];\n\n    const mergingPoints = (shape as Line).points;\n    const basePoints = (baseShape as Line).points;\n    const newShapeData: ShapeData = {\n      points: baseLine.index === 0 ? [\n        ...line.index === 0 ? mergingPoints.reverse() : mergingPoints,\n        ...basePoints,\n      ] : [\n        ...basePoints,\n        ...line.index === 0 ? mergingPoints : mergingPoints.reverse(),\n      ],\n    };\n\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const { prevState, currState } = this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame);\n\n    const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n    const { layer = activeLayerIndex } = baseInstanceItem.cameras[currentCamera]?.frames[currentFrame] || {};\n    const { prevState: prevStateItem, currState: currStateItem } = baseInstanceItem.updateShape(\n      currentCamera,\n      currentFrame,\n      autoInterpolation && baseShape.shapeType !== ShapeType.PIXEL,\n      baseShape.shapeType,\n      newShapeData,\n      layer,\n    );\n\n    this.setupShape(baseInstanceItem);\n    this.selectShapeByInstanceItem(baseInstanceItem);\n    const basicInfo = baseInstanceItem.instance.getBasicInfo();\n\n    this.rootStore.undo.push({\n      instances: [\n        ...prevState.instances,\n        ...prevStateItem ? [{ ...basicInfo, children: [prevStateItem] }] : [],\n      ],\n      relationships: prevState.relationships,\n    }, {\n      instances: [\n        ...currState.instances,\n        ...currStateItem ? [{ ...basicInfo, children: [currStateItem] }] : [],\n      ],\n      relationships: currState.relationships,\n    });\n\n    message.success(i18n.translate('MERGE_SUCCESS'));\n  }\n\n  mergePolygons(polygonId1: string, polygonId2: string) {\n    const { shape: polygon1, instanceItem: instance1 } = this.shapes[polygonId1];\n    const { shape: polygon2, instanceItem: instance2 } = this.shapes[polygonId2];\n    const mergedData = (polygon1 as Polygon).merge(polygon2 as Polygon);\n    if (mergedData.length === 1) {\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const { prevState, currState } = this.rootStore.instance.deleteInstanceItemByFrame(instance2, currentFrame);\n\n      const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n      const { layer = activeLayerIndex } = instance1.cameras[currentCamera]?.frames[currentFrame] || {};\n      const { prevState: prevStateItem, currState: currStateItem } = instance1.updateShape(\n        currentCamera,\n        currentFrame,\n        autoInterpolation,\n        ShapeType.POLYGON,\n        mergedData[0],\n        layer,\n        this.rootStore.frame.getNextShapeOrder(layer),\n      );\n\n      this.setupShape(instance1);\n      this.selectShapeByInstanceItem(instance1);\n      const basicInfo = instance1.instance.getBasicInfo();\n\n      this.rootStore.undo.push({\n        instances: [\n          ...prevState.instances,\n          ...prevStateItem ? [{ ...basicInfo, children: [prevStateItem] }] : [],\n        ],\n        relationships: prevState.relationships,\n      }, {\n        instances: [\n          ...currState.instances,\n          ...currStateItem ? [{ ...basicInfo, children: [currStateItem] }] : [],\n        ],\n        relationships: currState.relationships,\n      });\n\n      message.success(i18n.translate('MERGE_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('MERGE_WITH_HOLE'));\n    }\n  }\n\n  subtractPolygon = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1 ||\n      this.selectedShapes[0].shapeType !== ShapeType.POLYGON\n    ) {\n      return;\n    }\n\n    const selectedPolygon = this.selectedShapes[0] as Polygon;\n    if (!selectedPolygon.editable) {\n      return;\n    }\n\n    this.rootStore.cancelShapeWorking();\n\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape);\n    const intersectPolygons = selectedPolygon.findIntersectPolygons(shapes, true).map((i) => this.shapes[i].shape);\n    const subtractedData = selectedPolygon.subtract(intersectPolygons);\n\n    if (subtractedData && subtractedData.length > 0) {\n      this.updatePolygons(subtractedData[0][0], subtractedData.slice(1).map((d) => d[0]));\n      message.success(i18n.translate('SUBTRACT_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));\n    }\n  };\n\n  updatePolygons(currPolygonData: PolygonData, otherPolygonData: PolygonData[]) {\n    this.updateShapes(currPolygonData, otherPolygonData, ShapeType.POLYGON);\n  }\n\n  updateShapes(currShapeData: ShapeData, otherShapeData: ShapeData[], shapeType = ShapeType.POLYGON) {\n    const selectedShape = this.selectedShapes[0];\n    const { instanceItem: selectedInstanceItem } = this.shapes[selectedShape.uid];\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const attributes = selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n\n    const area = calcShapeArea(shapeType, currShapeData);\n    if (area < this.rootStore.config.minArea) {\n      message.warning(i18n.translate('MIN_AREA_ALERT'));\n      this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItem, [currentFrame]);\n      return;\n    }\n    const prevBasicInfo = selectedInstanceItem.instance.getBasicInfo();\n\n    const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n    const { layer = activeLayerIndex } = selectedInstanceItem.cameras[currentCamera]?.frames[currentFrame] || {};\n    const { prevState: prevStateItem, currState: currStateItem } = selectedInstanceItem.updateShape(\n      currentCamera,\n      currentFrame,\n      autoInterpolation && shapeType !== ShapeType.PIXEL,\n      shapeType,\n      currShapeData,\n      layer,\n      shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(layer),\n      attributes,\n    );\n    if (shapeType === ShapeType.PIXEL) {\n      this.rootStore.segmentation.update(selectedInstanceItem, layer, currShapeData as PixelData);\n    }\n\n    const basicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [basicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevStateItem ? [prevStateItem] : [] },\n        curr: { ...basicInfo, children: currStateItem ? [currStateItem] : [] }\n      }\n    };\n\n    this.setupShape(selectedInstanceItem);\n    this.rootStore.nifti?.updateShape(selectedInstanceItem);\n\n    for (let i = 0; i < otherShapeData.length; i += 1) {\n      if (calcShapeArea(shapeType, otherShapeData[i]) < this.rootStore.config.minArea && shapeType !== ShapeType.PIXEL) {\n        return;\n      }\n\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category, selectedInstanceItem.name)!;\n\n      const prevInfo = instanceItem.instance.getBasicInfo();\n      if (instanceItem.instance !== selectedInstanceItem.instance) {\n        instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);\n        const dynamicAttributesCurrentFrame = selectedInstanceItem.instance.dynamicAttributes?.[currentCamera]?.[currentFrame];\n        if (dynamicAttributesCurrentFrame && instanceItem.instance.categoryRef.labelConfigDynamic) {\n          instanceItem.instance.setDynamicAttributesByCamera(currentCamera, [dynamicAttributesCurrentFrame]);\n        }\n      }\n      const { layer: shapeLayer = activeLayerIndex } = instanceItem.cameras[currentCamera]?.frames[currentFrame] || {};\n      const { prevState, currState } = instanceItem.updateShape(\n        currentCamera,\n        currentFrame,\n        autoInterpolation && shapeType !== ShapeType.PIXEL,\n        shapeType,\n        otherShapeData[i],\n        shapeLayer,\n        shapeType === ShapeType.PIXEL ? 0 : this.rootStore.frame.getNextShapeOrder(shapeLayer),\n        attributes,\n      );\n      if (shapeType === ShapeType.PIXEL) {\n        this.rootStore.segmentation.update(instanceItem, shapeLayer, otherShapeData[i] as PixelData);\n      }\n      this.setupShape(instanceItem);\n      this.rootStore.nifti?.updateShape(instanceItem);\n      const currInfo = instanceItem.instance.getBasicInfo();\n      if (!instanceState[currInfo.id]) {\n        instanceState[currInfo.id] = {\n          prev: { ...prevInfo, children: [] },\n          curr: { ...currInfo, children: [] }\n        };\n      }\n      const state = instanceState[currInfo.id];\n      if (prevState) {\n        state.prev.children.push(prevState);\n      }\n      if (currState) {\n        state.curr.children.push(currState);\n      }\n    }\n    this.selectShapeByInstanceItem(selectedInstanceItem);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev).filter((i) => i.children.length > 0)\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr)\n    });\n  }\n\n  updateConfig = ({ fill, alpha, borderAlpha, borderWidth, dotRadius, showSideLength, showDirection, showVertex, showVertexOrder, vertexSize }: {\n    fill?: boolean,\n    alpha?: number,\n    borderAlpha?: number,\n    borderWidth?: number,\n    dotRadius?: number,\n    showSideLength?: boolean,\n    showDirection?: boolean,\n    showVertex?: boolean,\n    showVertexOrder?: boolean,\n    vertexSize?: number,\n  }) => {\n    const { viewMode } = this.rootStore.config;\n    if (fill !== undefined) {\n      this.config.fill = fill;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesFill(fill);\n      } else {\n        this.rootStore.grid.updateShapesFill(fill);\n      }\n    }\n    if (alpha !== undefined) {\n      this.config.alpha = alpha;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesAlpha(alpha / 100);\n      } else {\n        this.rootStore.grid.updateShapesAlpha(alpha / 100);\n      }\n    }\n    if (borderAlpha !== undefined) {\n      this.config.borderAlpha = borderAlpha;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesBorderAlpha(borderAlpha / 100);\n      } else {\n        this.rootStore.grid.updateShapesBorderAlpha(borderAlpha / 100);\n      }\n    }\n    if (borderWidth !== undefined) {\n      this.config.borderWidth = borderWidth;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesBorderWidth(borderWidth);\n      } else {\n        this.rootStore.grid.updateShapesBorderWidth(borderWidth);\n      }\n    }\n    if (dotRadius !== undefined) {\n      this.config.dotRadius = dotRadius;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateDotsRadius(dotRadius);\n      } else {\n        this.rootStore.grid.updateDotsRadius(dotRadius);\n      }\n    }\n    if (showSideLength !== undefined) {\n      this.config.showSideLength = showSideLength;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShowSideLength(showSideLength);\n      } else {\n        this.rootStore.grid.updateShowSideLength(showSideLength);\n      }\n    }\n    if (showDirection !== undefined) {\n      this.config.showDirection = showDirection;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShowDirection(showDirection);\n      } else {\n        this.rootStore.grid.updateShowDirection(showDirection);\n      }\n    }\n    if (showVertex !== undefined) {\n      this.config.showVertex = showVertex;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShowVertex(showVertex);\n      } else {\n        this.rootStore.grid.updateShowVertex(showVertex);\n      }\n    }\n    if (showVertexOrder !== undefined) {\n      this.config.showVertexOrder = showVertexOrder;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShowVertexOrder(showVertexOrder);\n      } else {\n        this.rootStore.grid.updateShowVertexOrder(showVertexOrder);\n      }\n    }\n    if (vertexSize !== undefined) {\n      this.config.vertexSize = vertexSize;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateVertexSize(vertexSize);\n      } else {\n        this.rootStore.grid.updateVertexSize(vertexSize);\n      }\n    }\n    cache.set(CacheKey.SHAPE_STYLES, this.config);\n  };\n\n  updateShapesFill = (fill: boolean) => {\n    const fillAlpha = fill ? this.config.alpha / 100 : 0;\n    if (this.drawingShape) {\n      this.drawingShape.alpha = fillAlpha;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.alpha = fillAlpha;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.alpha = fillAlpha;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.alpha = fillAlpha;\n      });\n    });\n    if (this.rootStore.config.previewMode) {\n      Object.values(this.rootStore.frame.cameraViews).forEach((cameraView) => {\n        cameraView.updatePreviewModeAlpha(fillAlpha);\n      });\n    }\n  };\n\n  updateShapesAlpha = (alpha: number) => {\n    if (this.config.fill) {\n      if (this.drawingShape) {\n        this.drawingShape.alpha = alpha;\n      }\n      Object.values(this.shapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n      Object.values(this.predictedShapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n      Object.values(this.projectedShapes).forEach((cameraShapes) => {\n        Object.values(cameraShapes).forEach((shape) => {\n          shape.alpha = alpha;\n        });\n      });\n      if (this.rootStore.config.previewMode) {\n        Object.values(this.rootStore.frame.cameraViews).forEach((cameraView) => {\n          cameraView.updatePreviewModeAlpha(alpha);\n        });\n      }\n    }\n  };\n\n  updateShapesBorderAlpha = (borderAlpha: number) => {\n    if (this.drawingShape) {\n      this.drawingShape.borderAlpha = borderAlpha;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.borderAlpha = borderAlpha;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.borderAlpha = borderAlpha;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.borderAlpha = borderAlpha;\n      });\n    });\n  };\n\n  updateShapesBorderWidth = (borderWidth: number) => {\n    if (this.rootStore.config.previewMode) {\n      const cameraViews = Object.values(this.rootStore.frame.cameraViews);\n      cameraViews.forEach((cameraView) => {\n        cameraView.shapesLayer.cacheAsBitmap = false;\n      });\n      Object.values(this.shapes).forEach(({ shape }) => {\n        shape.borderWidth = borderWidth * shape.scale;\n      });\n      Object.values(this.projectedShapes).forEach((cameraShapes) => {\n        Object.values(cameraShapes).forEach((shape) => {\n          shape.borderWidth = borderWidth * shape.scale;\n        });\n      });\n      cameraViews.forEach((cameraView) => {\n        cameraView.shapesLayer.cacheAsBitmap = true;\n      });\n      return;\n    }\n    if (this.drawingShape) {\n      this.drawingShape.borderWidth = borderWidth;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.borderWidth = borderWidth;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.borderWidth = borderWidth;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.borderWidth = borderWidth;\n      });\n    });\n  };\n\n  updateDotsRadius = (dotRadius: number) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape instanceof Dot) {\n        shape.dotRadius = dotRadius;\n      } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n        shape.vertexSize = dotRadius;\n      }\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      if (shape instanceof Dot) {\n        shape.dotRadius = dotRadius;\n      } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n        shape.vertexSize = dotRadius;\n      }\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        if (shape instanceof Dot) {\n          shape.dotRadius = dotRadius;\n        } else if (shape.shapeType === ShapeType.KEYPOINTS) {\n          shape.vertexSize = dotRadius;\n        }\n      });\n    });\n  };\n\n  updateShowSideLength = (showSideLength: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showSideLength = showSideLength;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showSideLength = showSideLength;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showSideLength = showSideLength;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.showSideLength = showSideLength;\n      });\n    });\n  };\n\n  updateShowDirection = (showDirection: boolean) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showDirection = showDirection;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showDirection = showDirection;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.showDirection = showDirection;\n      });\n    });\n  };\n\n  updateShowVertex = (showVertex: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertex = showVertex;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.showVertex = showVertex;\n      });\n    });\n  };\n\n  updateShowVertexOrder = (showVertexOrder: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertexOrder = showVertexOrder;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n    });\n  };\n\n  updateVertexSize = (vertexSize: number) => {\n    if (this.drawingShape && this.drawingShape.shapeType !== ShapeType.KEYPOINTS) {\n      this.drawingShape.vertexSize = vertexSize;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape.shapeType !== ShapeType.KEYPOINTS) {\n        shape.vertexSize = vertexSize;\n      }\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      if (shape.shapeType !== ShapeType.KEYPOINTS) {\n        shape.vertexSize = vertexSize;\n      }\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        if (shape.shapeType !== ShapeType.KEYPOINTS) {\n          shape.vertexSize = vertexSize;\n        }\n      });\n    });\n  };\n\n  resetConfig = () => {\n    this.updateConfig({ ...this.defaultConfig });\n  };\n\n  toggleShapeCut = (cuttingMode: 'cut' | 'split' = 'cut') => {\n    const shape = cuttingMode === 'cut' ? this.cuttingShape : this.splittingShape;\n    if (shape) {\n      this.endShapeCutting();\n    } else {\n      this.startShapeCutting(cuttingMode);\n    }\n  };\n\n  startShapeCutting(cuttingMode: 'cut' | 'split') {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      !this.rootStore.instance.isSingleSelected ||\n      this.rootStore.segmentation.updatingShape\n    ) {\n      return;\n    }\n\n    const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n    if (isGridView && cuttingMode === 'split') {\n      return;\n    }\n\n    const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n    if (!selectedShape?.editable) {\n      return;\n    }\n\n    const isPolygon = selectedShape?.shapeType === ShapeType.POLYGON;\n    const isLine = selectedShape?.shapeType === ShapeType.LINE || selectedShape?.shapeType === ShapeType.ARROW;\n    const isPixel = selectedShape?.shapeType === ShapeType.PIXEL;\n    if (isPolygon || isLine || (cuttingMode === 'split' && isPixel)) {\n      this.clearPending(); // cancel merge\n      this.endShapeAppending(); // cancel append\n      this.finishUpdateShape(); // cancel update\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      const shape = selectedShape as Polygon | Line | Pixel;\n      shape.isCutting = true;\n      if (isPolygon || isLine) {\n        (shape as Polygon | Line).cuttingMode = cuttingMode;\n      }\n      if (cuttingMode === 'cut') {\n        this.cuttingShape = shape.uid;\n        this.splittingShape = '';\n      } else {\n        this.splittingShape = shape.uid;\n        this.cuttingShape = '';\n      }\n      this.selectedPointIndex = -1;\n      // update interactive\n      if (!isGridView) {\n        this.updateShapesInteractive(false, [shape.uid]);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(false, [shape.uid]);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(false);\n    }\n  }\n\n  endShapeCutting() {\n    if (!this.cuttingShape && !this.splittingShape) {\n      return;\n    }\n    const shapeId = this.cuttingShape || this.splittingShape;\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      if (shapeId) {\n        const shape = this.shapes[shapeId].shape;\n        if (shape) {\n          (shape as Polygon | Line).isCutting = false;\n        }\n      }\n      this.updateShapesInteractive(true);\n    } else {\n      const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n      if (selectedShape?.uid === shapeId) {\n        (selectedShape as Polygon | Line).isCutting = false;\n      }\n      this.rootStore.grid.updateShapesInteractive(true);\n    }\n    this.rootStore.relationship.updateConnectionsInteractive(true);\n    this.cuttingShape = '';\n    this.splittingShape = '';\n  }\n\n  /**\n   * rotate all shapes (excluding predicted shapes)\n   * @param rotation\n   * @param center\n   * @param offsetX\n   * @param offsetY\n   */\n  rotateShapesByCanvas = (rotation: number, center: { x: number; y: number }, offsetX: number, offsetY: number) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n\n    const { left, top, right, bottom } = this.rootStore.frame.imageBounds;\n    const imageWidth = right - left;\n    const imageHeight = bottom - top;\n    const matrix = getMatrixByRotation(rotation, imageWidth, imageHeight);\n    this.getShapesForCamera(currentCamera).forEach(({ shape, instanceItem }) => {\n      // update shape\n      switch (shape.shapeType) {\n        case ShapeType.RECTANGLE:\n        case ShapeType.SQUARE: {\n          const rect = shape as Rectangle;\n          const { x, y, width, height, centerLineEnabled, center: c, rotation: r } = rect;\n          const rotatedCenter = computeRotatedPosition(center, { x: x + width / 2, y: y + height / 2 }, rotation);\n          if (rotation % Math.PI !== 0) {\n            rect.width = height;\n            rect.height = width;\n          }\n          rect.x = this.precise(rotatedCenter.x - offsetX - rect.width / 2);\n          rect.y = this.precise(rotatedCenter.y - offsetY - rect.height / 2);\n          // update center\n          if (centerLineEnabled) {\n            rect.center = this.precise(rect.x + ((c - x) / width) * rect.width);\n          }\n          // reset rotation to update pivot\n          rect.rotation = r;\n          break;\n        }\n        case ShapeType.POLYGON:\n        case ShapeType.QUAD_PRISM:\n        case ShapeType.ORIENTED_QUAD_PRISM:\n        case ShapeType.LINE:\n        case ShapeType.ARROW:\n        case ShapeType.KEYPOINTS: {\n          const s = shape as Polygon | Line | Arrow | QuadPrism | Keypoints;\n          const { points } = s;\n          s.points = points.map((p) => {\n            const rp = computeRotatedPosition(center, p, rotation);\n            return { ...p, x: this.precise(rp.x - offsetX), y: this.precise(rp.y - offsetY) };\n          });\n          break;\n        }\n        case ShapeType.CURVE:\n        case ShapeType.FLEX_LINE: {\n          const s = shape as Curve | FlexLine;\n          s.points = s.points.map((p) => {\n            const rp = computeRotatedPosition(center, p, rotation);\n            return {\n              x: this.precise(rp.x - offsetX),\n              y: this.precise(rp.y - offsetY),\n              ...p.controls && {\n                controls: p.controls.map((c) => {\n                  const rc = computeRotatedPosition(center, c, rotation);\n                  return {\n                    x: this.precise(rc.x - offsetX),\n                    y: this.precise(rc.y - offsetY),\n                  };\n                }),\n              },\n            };\n          });\n          break;\n        }\n        case ShapeType.CURVE_PAIR: {\n          const s = shape as CurvePair;\n          s.pairs = s.pairs.map(({ p1, p2, controls }) => {\n            const rp1 = computeRotatedPosition(center, p1, rotation);\n            const rp2 = computeRotatedPosition(center, p2, rotation);\n            return {\n              p1: {\n                x: this.precise(rp1.x - offsetX),\n                y: this.precise(rp1.y - offsetY),\n              },\n              p2: {\n                x: this.precise(rp2.x - offsetX),\n                y: this.precise(rp2.y - offsetY),\n              },\n              ...controls && {\n                controls: controls.map((c) => {\n                  const rc = computeRotatedPosition(center, c, rotation);\n                  return {\n                    x: this.precise(rc.x - offsetX),\n                    y: this.precise(rc.y - offsetY),\n                  };\n                }),\n              },\n            };\n          });\n          break;\n        }\n        case ShapeType.PARALLELOGRAM: {\n          const s = shape as Parallelogram;\n          const { points } = s;\n          s.points = points.map((p) => {\n            const rp = computeRotatedPosition(center, p, rotation);\n            return { x: this.precise(rp.x - offsetX), y: this.precise(rp.y - offsetY) };\n          });\n          break;\n        }\n        case ShapeType.ELLIPSE: {\n          const ellipse = shape as Ellipse;\n          const { x, y, halfWidth, halfHeight } = ellipse;\n          const rotatedCenter = computeRotatedPosition(center, { x, y }, rotation);\n          ellipse.x = this.precise(rotatedCenter.x - offsetX);\n          ellipse.y = this.precise(rotatedCenter.y - offsetY);\n          if (rotation % Math.PI !== 0) {\n            ellipse.halfWidth = halfHeight;\n            ellipse.halfHeight = halfWidth;\n          }\n          break;\n        }\n        case ShapeType.CIRCLE: {\n          const circle = shape as Circle;\n          const { x, y } = circle;\n          const rotatedCenter = computeRotatedPosition(center, { x, y }, rotation);\n          circle.x = this.precise(rotatedCenter.x - offsetX);\n          circle.y = this.precise(rotatedCenter.y - offsetY);\n          break;\n        }\n        case ShapeType.CUBOID:\n        case ShapeType.TWO_SIDES_CUBOID: {\n          const cuboid = shape as Cuboid | TwoSidesCuboid;\n          const { x1, y1, w1, h1, x2, y2, w2, h2 } = cuboid;\n          const rotatedCenter1 = computeRotatedPosition(center, { x: x1 + w1 / 2, y: y1 + h1 / 2 }, rotation);\n          const rotatedCenter2 = computeRotatedPosition(center, { x: x2 + w2 / 2, y: y2 + h2 / 2 }, rotation);\n          let fw = w1;\n          let fh = h1;\n          let bw = w2;\n          let bh = h2;\n          if (rotation % Math.PI !== 0) {\n            fw = h1;\n            fh = w1;\n            bw = h2;\n            bh = w2;\n          }\n          cuboid.setData({\n            front: {\n              x: this.precise(rotatedCenter1.x - offsetX - fw / 2),\n              y: this.precise(rotatedCenter1.y - offsetY - fh / 2),\n              width: fw,\n              height: fh,\n            },\n            back: {\n              x: this.precise(rotatedCenter2.x - offsetX - bw / 2),\n              y: this.precise(rotatedCenter2.y - offsetY - bh / 2),\n              width: bw,\n              height: bh,\n            },\n          });\n          break;\n        }\n        case ShapeType.LSHAPE: {\n          const lshape = shape as LShape;\n          const { x, y, w, h, sx1, sy1, sx2, sy2, center: c } = lshape;\n          const rotatedCenter = computeRotatedPosition(center, { x: x + w / 2, y: y + h / 2 }, rotation);\n          if (rotation % Math.PI !== 0) {\n            lshape.w = h;\n            lshape.h = w;\n          }\n          lshape.x = rotatedCenter.x - offsetX - lshape.w / 2;\n          lshape.y = rotatedCenter.y - offsetY - lshape.h / 2;\n          // update side points (side points cannot be rotated, keep the offset from origin)\n          if (Math.abs(sx1 - x) < Math.abs(sx1 - x - w)) {\n            lshape.sx1 = lshape.x + sx1 - x;\n            lshape.sx2 = lshape.x + sx2 - x;\n          } else {\n            lshape.sx1 = lshape.x + lshape.w + sx1 - (x + w);\n            lshape.sx2 = lshape.x + lshape.w + sx2 - (x + w);\n          }\n          lshape.sy1 = lshape.y + sy1 - y;\n          lshape.sy2 = lshape.y + sy2 - y;\n          // update center\n          lshape.center = this.precise(lshape.x + ((c - x) / w) * lshape.w);\n          lshape.x = this.precise(lshape.x);\n          lshape.y = this.precise(lshape.y);\n          lshape.sx1 = this.precise(lshape.sx1);\n          lshape.sx2 = this.precise(lshape.sx2);\n          lshape.sy1 = this.precise(lshape.sy1);\n          lshape.sy2 = this.precise(lshape.sy2);\n          break;\n        }\n        case ShapeType.DOT: {\n          const dot = shape as Dot;\n          const { x, y } = dot;\n          const rotatedPoint = computeRotatedPosition(center, { x, y }, rotation);\n          dot.x = this.precise(rotatedPoint.x - offsetX);\n          dot.y = this.precise(rotatedPoint.y - offsetY);\n          break;\n        }\n        case ShapeType.GRID: {\n          const grid = shape as Grid;\n          const { cols, rows, x, y, width, height } = grid;\n          const gridCenter = { x: x + width / 2, y: y + height / 2 };\n          const rotatedCenter = computeRotatedPosition(center, gridCenter, rotation);\n          if (rotation % Math.PI !== 0) {\n            const c0 = rotatedCenter.x - offsetX - height / 2;\n            const r0 = rotatedCenter.y - offsetY - width / 2;\n            grid.cols = rows.map((r) => ({ x: this.precise(c0 + r.y - y) }));\n            grid.rows = cols.map((c) => ({ y: this.precise(r0 + c.x - x) }));\n          } else {\n            const c0 = rotatedCenter.x - offsetX - width / 2;\n            const r0 = rotatedCenter.y - offsetY - height / 2;\n            grid.cols = cols.map((c) => ({ x: this.precise(c0 + c.x - x) }));\n            grid.rows = rows.map((r) => ({ y: this.precise(r0 + r.y - y) }));\n          }\n          break;\n        }\n        case ShapeType.PIXEL: {\n          const pixel = shape as Pixel;\n          const newPixels: {\n            [x: number]: {\n              x: number;\n              yList: {\n                [y: number]: number;\n              };\n            };\n          } = {};\n          let l = -1;\n          let r = -1;\n          let t = -1;\n          let b = -1;\n          const { pixelsData } = pixel;\n          const allX = Object.values(pixelsData.pixels);\n          for (let i = 0; i < allX.length; i += 1) {\n            const { x, yList } = allX[i];\n            const allY = Object.values(yList);\n            for (let j = 0; j < allY.length; j += 1) {\n              const y = allY[j];\n              const { x: px, y: py } = calcPositionByMatrix({ x, y }, matrix);\n              if (!newPixels[px]) {\n                newPixels[px] = {\n                  x: px,\n                  yList: {},\n                };\n              }\n              newPixels[px].yList[py] = py;\n              if (l === -1 || l > px) {\n                l = px;\n              }\n              if (r === -1 || r < px) {\n                r = px;\n              }\n              if (t === -1 || t > py) {\n                t = py;\n              }\n              if (b === -1 || b < py) {\n                b = py;\n              }\n            }\n          }\n          pixelsData.pixels = newPixels;\n          pixelsData.left = l;\n          pixelsData.right = r;\n          pixelsData.top = t;\n          pixelsData.bottom = b;\n          pixel.drawShape();\n          break;\n        }\n        default:\n      }\n\n      // save shape data\n      const { layer = activeLayerIndex } = instanceItem.cameras[currentCamera]?.frames[currentFrame] || {};\n      const { prevState, currState } = instanceItem.updateShape(\n        currentCamera,\n        currentFrame,\n        autoInterpolation && shape.shapeType !== ShapeType.PIXEL,\n        shape.shapeType,\n        shape.getData(),\n        layer,\n      );\n      const { instance } = instanceItem;\n      if (prevState) {\n        if (!prevInstanceMap[instance.id]) {\n          prevInstanceMap[instance.id] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        prevInstanceMap[instance.id].children.push(prevState);\n      }\n      if (currState) {\n        if (!currInstanceMap[instance.id]) {\n          currInstanceMap[instance.id] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        currInstanceMap[instance.id].children.push(currState);\n      }\n    });\n\n    // reproject shapes\n    this.reprojectShapesByCamera();\n\n    return {\n      prevState: { instances: Object.values(prevInstanceMap) },\n      currState: { instances: Object.values(currInstanceMap) },\n    };\n  };\n\n  /**\n   * update bounds for all shapes\n   */\n  updateShapesBounds() {\n    const { boundaryCheck } = this.rootStore.config;\n    const { currentCamera, imageBounds } = this.rootStore.frame;\n    if (boundaryCheck) {\n      this.getShapesForCamera(currentCamera).forEach(({ shape }) => {\n        shape.bounds = imageBounds;\n      });\n    }\n  }\n\n  /**\n   * hide or show shapes based on hideOthers\n   */\n  hideOrShowOthers = () => {\n    const { hideOthers, hideAll, layersVisible, activeLayerIndex } = this.rootStore.config;\n    const { isOpen: hideOthersIsOpen, mode: hideOthersMode } = hideOthers;\n    const { currentFrame } = this.rootStore.frame;\n    const { selectedInstances, selectedInstanceItems } = this.rootStore.instance;\n    const { filterMode, filteredInstances } = this.rootStore.filter;\n\n    let updated = false;\n    const visibleShapeIds: string[] = [];\n    Object.values(this.shapes).forEach(({ shape, camera, instanceItem }) => {\n      const labelDom = document.getElementById(`label-item-${instanceItem.id}`);\n\n      let hide = hideAll;\n      if (!hide) {\n        // check layer visible\n        const { layer = activeLayerIndex } = instanceItem.cameras[camera]?.frames[currentFrame] || {};\n        hide = layersVisible[layer] === false;\n      }\n      if (!hide && filterMode) {\n        // check filter mode\n        hide = !filteredInstances[instanceItem.instance.id]?.cameras[camera]?.[currentFrame]?.includes(instanceItem);\n      }\n      if (!hide && hideOthersIsOpen) {\n        // check solo mode\n        if (hideOthersMode === SoloMode.INSTANCE && selectedInstances.length > 0) {\n          // instance solo\n          hide = selectedInstances.findIndex((i) => i.id === instanceItem.instance.id) < 0;\n        } else if (hideOthersMode === SoloMode.ITEM && selectedInstanceItems.length > 0) {\n          // instance item solo (with relationships)\n          hide = selectedInstanceItems.findIndex((i) => (\n            i.id === instanceItem.id ||\n            i.cameras[camera]?.relationships.findIndex(({ frames, fromInstanceItem, toInstanceItem }) => (\n              frames[currentFrame] &&\n              (fromInstanceItem.id === instanceItem.id || toInstanceItem.id === instanceItem.id)\n            )) >= 0\n          )) < 0;\n        }\n      }\n\n      if (hide) {\n        if (!updated) {\n          updated = shape.visible !== false;\n        }\n        shape.visible = false;\n        if (labelDom) {\n          labelDom.style.visibility = 'hidden';\n        }\n        if (this.projectedShapes[shape.uid]) {\n          Object.values(this.projectedShapes[shape.uid]).forEach((projectedShape) => {\n            projectedShape.visible = false;\n          });\n        }\n      } else {\n        if (!updated) {\n          updated = shape.visible !== true;\n        }\n        shape.visible = true;\n        if (labelDom) {\n          labelDom.style.visibility = 'visible';\n        }\n        if (this.projectedShapes[shape.uid]) {\n          Object.values(this.projectedShapes[shape.uid]).forEach((projectedShape) => {\n            projectedShape.visible = true;\n          });\n        }\n        visibleShapeIds.push(shape.uid);\n      }\n    });\n    this.visibleShapeIds = visibleShapeIds;\n\n    this.rootStore.relationship.hideOrShowRelationships();\n    this.rootStore.review.hideOrShowReviews();\n    if (updated) {\n      this.updateShapesRefreshCounter();\n    }\n  };\n\n  /**\n   * set refresh counter\n   */\n  updateShapesRefreshCounter = debounce(() => {\n    const { viewMode, cameraLayout } = this.rootStore.config;\n    if (viewMode === ViewMode.DEFAULT && cameraLayout === CameraLayout.THUMBNAIL) {\n      this.shapesRefreshCounter += 1;\n    }\n  }, 0);\n\n  /**\n   * toggle to line append\n   */\n  toggleLineAppend = () => {\n    if (this.appendingShape) {\n      this.endShapeAppending();\n    } else {\n      this.startShapeAppending();\n    }\n  };\n\n  /**\n   * append points to selected line\n   */\n  startShapeAppending = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      !this.rootStore.instance.isSingleSelected ||\n      this.rootStore.segmentation.updatingShape\n    ) {\n      return;\n    }\n\n    const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n    const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n    if (selectedShape?.editable && (selectedShape.shapeType === ShapeType.LINE || selectedShape.shapeType === ShapeType.ARROW)) {\n      this.clearPending(); // cancel merge\n      this.endShapeCutting(); // cancel cut\n      this.finishUpdateShape(); // cancel update\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      this.appendingShape = selectedShape.uid;\n      (selectedShape as Line).append(this.rootStore.currPosition, this.selectedPointIndex);\n\n      // update interactive\n      if (!isGridView) {\n        this.updateShapesInteractive(false, [selectedShape.uid]);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(false, [selectedShape.uid]);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(false);\n    }\n  };\n\n  /**\n   * ends shape appending\n   * @param isCancel\n   */\n  endShapeAppending = (isCancel = true) => {\n    if (!this.appendingShape) {\n      return;\n    }\n\n    if (isCancel) {\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        const shapeItem = this.shapes[this.appendingShape];\n        if (shapeItem?.shape) {\n          const shape = shapeItem.shape as Line;\n          shape.finishAppend(isCancel);\n        }\n      } else {\n        const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n        if (selectedShape?.uid === this.appendingShape) {\n          (selectedShape as Line).finishAppend(isCancel);\n        }\n      }\n    }\n    this.appendingShape = '';\n\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      this.updateShapesInteractive(true);\n    } else {\n      this.rootStore.grid.updateShapesInteractive(true);\n    }\n    this.rootStore.relationship.updateConnectionsInteractive(true);\n  };\n\n  startUpdateShape = (check = true) => {\n    if (check && (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      !this.rootStore.instance.isSingleSelected ||\n      this.rootStore.segmentation.updatingShape\n    )) {\n      return;\n    }\n\n    const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n    const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n    if (selectedShape?.editable && selectedShape.shapeType === ShapeType.KEYPOINTS) {\n      this.clearPending(); // cancel merge\n      this.endShapeCutting(); // cancel cutting\n      this.endShapeAppending(); // cancel appending\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      this.updatingShape = selectedShape.uid;\n      (selectedShape as Keypoints).update();\n      this.rootStore.config.setCursor((selectedShape as Keypoints).currCursor);\n\n      // update interactive\n      if (!isGridView) {\n        this.updateShapesInteractive(false, [selectedShape.uid]);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(false, [selectedShape.uid]);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(false);\n    }\n  };\n\n  finishUpdateShape = () => {\n    if (!this.updatingShape) {\n      return;\n    }\n\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      const shapeItem = this.shapes[this.updatingShape];\n      if (shapeItem?.shape?.shapeType === ShapeType.KEYPOINTS) {\n        (shapeItem.shape as Keypoints).finishUpdate();\n        this.rootStore.config.setCursor((shapeItem.shape as Keypoints).currCursor);\n        this.updateShapesInteractive(true);\n      }\n    } else {\n      const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n      if (selectedShape?.uid === this.updatingShape && selectedShape.shapeType === ShapeType.KEYPOINTS) {\n        (selectedShape as Keypoints).finishUpdate();\n        this.rootStore.config.setCursor((selectedShape as Keypoints).currCursor);\n        this.rootStore.grid.updateShapesInteractive(true);\n      }\n    }\n    this.rootStore.relationship.updateConnectionsInteractive(true);\n    this.updatingShape = '';\n  };\n\n  /**\n   * start create shape on add mode changes\n   */\n  startCreateShape() {\n    const { currentTool } = this.rootStore.ontology;\n    const { lineContinuous } = this.rootStore.shape;\n    const { viewMode } = this.rootStore.config;\n    if (currentTool === Tool.PIXEL) {\n      let point: Point | undefined;\n      if (this.rootStore.currPosition) {\n        point = new Point(\n          this.rootStore.currPosition.x,\n          this.rootStore.currPosition.y,\n        );\n      }\n      if (viewMode === ViewMode.DEFAULT) {\n        this.addShape(point);\n        this.rootStore.segmentation.currMode = PixelToolMode.PLUS;\n      }\n    } else if (currentTool === Tool.LINE && lineContinuous) {\n      if (viewMode === ViewMode.DEFAULT) {\n        this.addShape();\n      }\n    } else if (currentTool === Tool.KEYPOINTS) {\n      const config = this.rootStore.ontology.currentToolItem?.config as KeypointsConfig;\n      const startPointKey = config?.groups?.[0]?.range?.[0];\n      if (startPointKey !== undefined) {\n        this.selectedPointIndex = startPointKey;\n      }\n    }\n  }\n\n  /**\n   * cancel creating shape\n   */\n  cancelCreateShape() {\n    if (this.drawingShape && this.drawingShape.shapeType === ShapeType.PIXEL) {\n      // cancel\n      this.drawingShape.destroy();\n      this.drawingShape = null;\n    }\n  }\n\n  /**\n   * toggle to show curve discrete points\n   */\n  toggleCurveDiscretePointsVisibility() {\n    this.showCurveDiscretePoints = !this.showCurveDiscretePoints;\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      Object.values(this.shapes).forEach(({ shape }) => {\n        if (shape instanceof Curve) {\n          shape.showDiscretePointsHint = this.showCurveDiscretePoints;\n        }\n      });\n    } else {\n      this.rootStore.grid.grids.forEach((grid) => {\n        Object.values(grid.shapes).forEach(({ shape }) => {\n          if (shape instanceof Curve) {\n            shape.showDiscretePointsHint = this.showCurveDiscretePoints;\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * set side ratio visibility\n   * ---- FIXME: customized for specific project\n   * ---- PID: A5764\n   */\n  setSideRatioVisibility(visible: boolean) {\n    this.showSideRatio = visible;\n    cache.set(CacheKey.SIDE_RATIO_VISIBILITY, `${visible}`);\n\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      Object.values(this.shapes).forEach(({ shape }) => {\n        if (shape.shapeType === ShapeType.POLYGON) {\n          (shape as Polygon).showSideRatio = visible;\n        }\n      });\n    } else {\n      this.rootStore.grid.grids.forEach((grid) => {\n        Object.values(grid.shapes).forEach(({ shape }) => {\n          if (shape.shapeType === ShapeType.POLYGON) {\n            (shape as Polygon).showSideRatio = visible;\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * get side ratio visibility\n   * ---- FIXME: customized for specific project\n   * ---- PID: A5764\n   */\n  getSideRatioVisibility() {\n    const storedValue = cache.get(CacheKey.SIDE_RATIO_VISIBILITY);\n    if (storedValue && storedValue === 'true') {\n      this.showSideRatio = true;\n    } else {\n      this.showSideRatio = false;\n    }\n  }\n\n  /**\n   * reverse shape direction\n   */\n  reverse = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing\n    ) {\n      return;\n    }\n    const isDefaultView = this.rootStore.config.viewMode === ViewMode.DEFAULT;\n    const selectedShape = isDefaultView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n    if (selectedShape?.editable && (\n      selectedShape.shapeType === ShapeType.POLYGON ||\n      selectedShape.shapeType === ShapeType.ARROW\n    )) {\n      (selectedShape as Polygon | Arrow).reverse();\n      if (selectedShape.shapeType === ShapeType.POLYGON && !this.config.showVertexOrder && !this.config.showDirection) {\n        message.info(i18n.translate('SHAPE_REVERSE_INFO'));\n      }\n    }\n  };\n\n  /**\n   * toggle when creating line, if the first point position is same with preivous line's last end of points\n   */\n  toggleLineContinuous = () => {\n    this.lineContinuous = !this.lineContinuous;\n    cache.set(CacheKey.TOOL_LINE_CREATE_FROM_PREVIOUS_END_POINT, this.lineContinuous);\n  };\n\n  initLineContinuous = () => {\n    this.lineContinuous = !!cache.get(CacheKey.TOOL_LINE_CREATE_FROM_PREVIOUS_END_POINT);\n  };\n\n  /**\n   * project all shapes in current frame\n   */\n  async projectShapes() {\n    if (!this.rootStore.frame.camerasMapping.projectEnabled) {\n      return;\n    }\n    const allShapes = Object.values(this.shapes);\n    if (allShapes.length <= 0) {\n      return;\n    }\n    return Promise.all(\n      allShapes.map(({ shape, camera }) => this.projectShape(shape, camera))\n    );\n  }\n\n  /**\n   * project shape in current frame from base camera to camera\n   * @param shape\n   * @param baseCamera\n   * @param toCameras\n   */\n  async projectShape(\n    shape: Shape<ShapeData>,\n    baseCamera = this.rootStore.frame.currentCamera,\n    toCameras = this.rootStore.frame.cameraNames,\n  ) {\n    const {\n      camerasMapping,\n      currentFrame,\n      cameraViews,\n      getImageBoundsForCamera,\n      getFrameRotationForCamera,\n    } = this.rootStore.frame;\n\n    if (\n      !camerasMapping.projectEnabled ||\n      !this.shapes[shape.uid] ||\n      shapeTypesSupportProject.indexOf(shape.shapeType) < 0\n    ) {\n      return;\n    }\n\n    const { points } = shape as ShapeSupportProject;\n    const { width: baseCameraWidth, height: baseCameraHeight } = cameraViews[baseCamera].image;\n    const baseCameraRotation = getFrameRotationForCamera(baseCamera, currentFrame);\n    const baseCameraMatrix = getMatrixByRotation(baseCameraRotation, baseCameraWidth, baseCameraHeight);\n    const originPoints: [number, number][] = points.map((p) => {\n      if (baseCameraRotation !== 0) {\n        const op = calcPositionByMatrix(p, inv(baseCameraMatrix));\n        return [op.x, op.y];\n      }\n      return [p.x, p.y];\n    });\n\n    return Promise.all(\n      toCameras\n        .map(async (toCamera) => {\n          if (toCamera === baseCamera) {\n            // do not project to self camera\n            return;\n          }\n\n          if (!camerasMapping.isProjectAvailable(currentFrame)) {\n            // show loading if current not available\n            this.projecting = true;\n          }\n\n          const projectedPoints = await camerasMapping.projectPoints(\n            originPoints,\n            currentFrame,\n            baseCamera,\n            toCamera,\n          );\n\n          const { width: toCameraWidth, height: toCameraHeight } = cameraViews[toCamera].image;\n          const toCameraRotation = getFrameRotationForCamera(toCamera, currentFrame);\n          const toCameraMatrix = getMatrixByRotation(toCameraRotation, toCameraWidth, toCameraHeight);\n          const projectedShapePoints = projectedPoints.map((p) => {\n            const point = { x: p[0], y: p[1] };\n            if (toCameraRotation !== 0) {\n              const rp = calcPositionByMatrix(point, toCameraMatrix);\n              point.x = rp.x;\n              point.y = rp.y;\n            }\n            return point;\n          });\n\n          const existingProjectedShape = this.projectedShapes[shape.uid]?.[toCamera];\n          if (existingProjectedShape) {\n            // update\n            (existingProjectedShape as ShapeSupportProject).points = projectedShapePoints;\n            existingProjectedShape.selected = shape.selected;\n          } else {\n            // create\n            const { instanceItem } = this.shapes[shape.uid];\n            const frameData = instanceItem.cameras[baseCamera]?.frames[currentFrame];\n            if (frameData) {\n              const { shapeType, order } = frameData;\n              const layer = frameData.layer !== undefined\n                ? frameData.layer\n                : this.rootStore.config.activeLayerIndex;\n              const projectedShapeData = {\n                points: projectedShapePoints,\n              } as ShapeDataSupportProject;\n\n              const projectedShape = this.createShape(\n                cameraViews[toCamera].getShapesLayerByIndex(layer),\n                getImageBoundsForCamera(toCamera, currentFrame),\n                instanceItem.colorConfig.color,\n                instanceItem.instance.category,\n                instanceItem.name,\n                instanceItem,\n                shapeType,\n                projectedShapeData,\n                order,\n                i18n.translate('PROJECTED_SHAPE_LABEL', { values: { label: instanceItem.label } }),\n                toCamera,\n              );\n              if (projectedShape.destroyed) {\n                return;\n              }\n\n              projectedShape.on(EventAction.SELECTED, () => {\n                // when projected shape selected\n                this.rootStore.instance.selectInstanceItem(instanceItem);\n                // fit source shape\n                this.fitProjectShape(shape, baseCamera);\n                // fit projected shapes in other cameras\n                Object.keys(this.projectedShapes[shape.uid]).forEach((c) => {\n                  if (c !== toCamera) {\n                    this.fitProjectShape(this.projectedShapes[shape.uid][c], c);\n                  }\n                });\n              });\n              projectedShape.on(EventAction.REMOVED, () => {\n                // when projected removed (not valid anymore)\n                if (this.projectedShapes[shape.uid]) {\n                  // delete the projected shape\n                  delete this.projectedShapes[shape.uid][toCamera];\n                }\n              });\n\n              // TODO: should set editable by cameras config, current is always not editable\n              projectedShape.editable = false;\n              projectedShape.selected = shape.selected;\n\n              // add to projected shapes map\n              if (!this.projectedShapes[shape.uid]) {\n                this.projectedShapes[shape.uid] = {};\n              }\n              this.projectedShapes[shape.uid][toCamera] = projectedShape;\n\n              if (shape.selected) {\n                // auto focus when shape selected & first created\n                this.fitProjectShape(projectedShape, toCamera);\n              }\n            }\n          }\n\n          this.projecting = false;\n        })\n    );\n  }\n\n  /**\n   * fit projected shape to camera view\n   * @param shape\n   * @param camera\n   */\n  fitProjectShape(shape: Shape<ShapeData>, camera: string) {\n    if (this.rootStore.config.preferences.zoomTogether && camera !== this.rootStore.frame.currentCamera) {\n      // not fit project shape when zoom together on & not current camera\n      return;\n    }\n    const cameraView = this.rootStore.frame.cameraViews[camera];\n    if (cameraView) {\n      const { left, top, right, bottom } = shape.shapeBounds;\n      cameraView.fitShapeToView({ left, top, right, bottom }, 0.5);\n    }\n  }\n\n  /**\n   * reproject shapes\n   * @param camera\n   */\n  reprojectShapesByCamera(camera = this.rootStore.frame.currentCamera) {\n    Object.keys(this.projectedShapes).forEach((sourceShapeId) => {\n      const projectedShape = this.projectedShapes[sourceShapeId][camera];\n      if (projectedShape) {\n        const sourceShape = this.shapes[sourceShapeId];\n        if (sourceShape) {\n          this.projectShape(sourceShape.shape, sourceShape.camera, [camera]);\n        }\n      }\n    });\n  }\n\n  /**\n   * update shape's editable when locked or unlocked\n   * @param instanceItem\n   * @param camera\n   * @param locked\n   */\n  updateShapeLockedState = (instanceItem: InstanceItem, camera: string, locked: boolean) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    let shape;\n    if (this.rootStore.config.viewMode === ViewMode.GRID) {\n      // only need update when the instance item show in grid view\n      const { isSingleSelected, selectedInstanceItems } = this.rootStore.instance;\n      const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n      if (selectedInstanceItem?.id === instanceItem.id && currentCamera === camera) {\n        const selectedShape = this.rootStore.grid.getCurrentSelectedShape();\n        if (selectedShape) {\n          shape = selectedShape;\n        }\n      }\n    } else {\n      shape = this.getShapeByInstanceItem(instanceItem, camera);\n    }\n\n    // cancel working status\n    if (this.pendingMergePolygon === shape?.uid || this.pendingMergeLine?.id === shape?.uid) {\n      this.clearPending();\n    }\n    if (this.cuttingShape === shape?.uid || this.splittingShape === shape?.uid) {\n      this.endShapeCutting();\n    }\n    if (this.appendingShape === shape?.uid) {\n      this.endShapeAppending();\n    }\n    if (this.updatingShape === shape?.uid) {\n      this.finishUpdateShape();\n    }\n    if (this.rootStore.segmentation.updatingShape?.uid === shape?.uid) {\n      this.rootStore.segmentation.cancelUpdate();\n    }\n\n    if (shape) {\n      const matrixChangeAllowed = instanceItem.cameras[camera]?.frames[currentFrame]?.matrixChangeAllowed;\n      shape.editable = !locked && !this.rootStore.readonly && matrixChangeAllowed;\n    }\n  };\n\n  /**\n   * start multi resize\n   */\n  enterMultiShapesResize() {\n    if (\n      this.shapesResizer ||\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.rootStore.config.addMode ||\n      this.rootStore.instance.reorganizingInstance ||\n      this.rootStore.segmentation.updatingShape ||\n      this.rootStore.config.viewMode !== ViewMode.DEFAULT\n    ) {\n      return;\n    }\n\n    const { currentFrame, currentCamera } = this.rootStore.frame;\n    let keepRatio = false;\n    const resizableShapes = this.selectedShapes.filter((s) => {\n      if (\n        (s.shapeType === ShapeType.RECTANGLE && s.rotation !== 0) ||\n        (s.shapeType === ShapeType.ELLIPSE && s.rotation !== 0) ||\n        s.shapeType === ShapeType.SQUARE ||\n        s.shapeType === ShapeType.CIRCLE ||\n        (s.shapeType === ShapeType.RECTANGLE && (s as Rectangle).ratio !== undefined)\n      ) {\n        keepRatio = true;\n      }\n      if (s.shapeType === ShapeType.PIXEL || s.shapeType === ShapeType.KEYPOINTS) {\n        return false;\n      }\n      const { instanceItem, camera } = this.shapes[s.uid] || {};\n      if (camera !== currentCamera) {\n        return false;\n      }\n      // check if is locked\n      const frameData = instanceItem?.cameras[camera]?.frames[currentFrame];\n      return frameData && !frameData.locked;\n    });\n    const resizableShapesBounds = calcBoundsByShapes(resizableShapes);\n    if (resizableShapesBounds) {\n      this.updateShapesInteractive(false);\n      this.shapesResizer = new MultiShapesResizer({\n        shapes: resizableShapes,\n        shapesBounds: resizableShapesBounds,\n        container: this.currentLayer!,\n        scale: this.rootStore.frame.currentCameraView!.viewScale,\n        ...this.rootStore.config.boundaryCheck && {\n          bounds: this.rootStore.frame.imageBounds,\n        },\n        keepRatio,\n      });\n      this.shapesResizer.on(ResizeAction.RESIZED, (changedShapes: Shape<ShapeData>[]) => {\n        const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData }[] = [];\n        changedShapes.forEach((i) => {\n          const shapeItem = this.shapes[i.uid];\n          if (shapeItem) {\n            instanceItems.push({\n              instanceItem: shapeItem.instanceItem,\n              frameIndex: currentFrame,\n              shapeType: i.shapeType,\n              shape: i.getData(),\n            });\n          }\n          this.projectShape(i);\n        });\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      });\n    }\n  }\n\n  /**\n   * finish multi resize\n   */\n  exitMultiShapesResize() {\n    if (this.shapesResizer) {\n      this.shapesResizer.destroy();\n      this.shapesResizer = undefined;\n      this.updateShapesInteractive(true);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}