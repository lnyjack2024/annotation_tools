{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/components/grid/GridView.tsx\";\nimport React from 'react';\nimport { reaction } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { message } from 'antd';\nimport { BorderStyle, EventAction } from '../../../common/shapes/Shape';\nimport GridCanvas from '../../../common/shapes/canvas/GridCanvas';\nimport Header from './Header';\nimport store from '../../store/RootStore';\nimport i18n from '../../locales';\nimport { ReviewMode, ReviewResult } from '../../types';\nimport './GridView.scss';\nclass GridView extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // when grid size changed\n    this.reactionDisposers = [];\n    this.gridCanvasRef = React.createRef();\n    /**\n     * update all grids shapes\n     */\n    this.updateShapes = () => {\n      var _this$gridCanvasRef$c;\n      (_this$gridCanvasRef$c = this.gridCanvasRef.current) === null || _this$gridCanvasRef$c === void 0 ? void 0 : _this$gridCanvasRef$c.updateShapes(store.grid.grids);\n    };\n    /**\n     * create shape for grid\n     * @param gridIndex\n     * @param container\n     * @param imageBounds\n     */\n    this.createShapesForGrid = (gridIndex, container, imageBounds) => {\n      const shapes = [];\n      const {\n        currentCamera\n      } = store.frame;\n      const {\n        isSingleSelected,\n        selectedInstances,\n        selectedInstanceItems\n      } = store.instance;\n      const selectedInstance = isSingleSelected ? selectedInstances[0] : undefined;\n      const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n      if (selectedInstance) {\n        const {\n          items\n        } = selectedInstance;\n        Object.values(items).forEach(item => {\n          const cameraData = item.cameras[currentCamera];\n          if (cameraData) {\n            const {\n              frames\n            } = cameraData;\n            const label = store.config.labelMode ? item.label : undefined;\n            let shape;\n            if (frames[gridIndex]) {\n              // create shape\n              shape = store.shape.createShape(container, imageBounds, item.categoryItemRef.displayColor, selectedInstance.category, item.name, frames[gridIndex].shapeType, frames[gridIndex].shape, frames[gridIndex].order, label);\n            } else {\n              // predict\n              const shapeInfo = item.predictShape(currentCamera, gridIndex, imageBounds);\n              if (shapeInfo) {\n                shape = store.shape.createShape(container, imageBounds, item.categoryItemRef.displayColor, selectedInstance.category, item.name, shapeInfo.shapeType, shapeInfo.shape, 9999, label);\n                shape.borderStyle = BorderStyle.DASHED;\n              }\n            }\n            if (shape) {\n              const isSelectedItem = selectedInstanceItem === item;\n              shape.on(EventAction.SELECTED, () => {\n                store.instance.selectInstanceItem(item);\n                if (gridIndex !== store.frame.currentFrame) {\n                  store.frame.setFrame(gridIndex);\n                }\n              });\n              shape.on(EventAction.CHANGED, (s, data) => {\n                if (s.area < store.config.minArea) {\n                  message.warning(i18n.translate('MIN_AREA_ALERT'));\n                  store.instance.deleteFramesFromInstanceItem(item, [gridIndex]);\n                  return;\n                }\n                store.instance.updateFrameShapeForInstanceItem(item, gridIndex, s.shapeType, data, frames[gridIndex] ? frames[gridIndex].order : store.frame.getNextShapeOrder());\n                store.frame.setFrame(gridIndex);\n              });\n              if (store.readonly || !isSelectedItem) {\n                shape.editable = false;\n              }\n              shape.borderColor = 0xFFFF00;\n              shape.selected = isSelectedItem;\n              shape.data = item; // link shape & instance item\n              if (store.config.addMode) {\n                shape.interactive = false;\n              }\n              store.shape.setShapeStyles(shape, item, currentCamera, gridIndex);\n              shapes.push(shape);\n            }\n          }\n        });\n      }\n      return shapes;\n    };\n    /**\n     * create review anchors for grid\n     * @param gridIndex\n     * @param container\n     * @param viewScale\n     */\n    this.createReviewsForGrid = (gridIndex, container, viewScale) => {\n      const anchors = [];\n      const frameReviews = store.review.reviews[gridIndex] || [];\n      const {\n        isSingleSelected,\n        selectedInstances,\n        selectedInstanceItems\n      } = store.instance;\n      const selectedInstance = isSingleSelected ? selectedInstances[0] : undefined;\n      const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n      let reviews;\n      if (selectedInstanceItem) {\n        reviews = frameReviews.filter(r => r.instanceItemId === selectedInstanceItem.id && r.camera === store.frame.currentCamera);\n      } else if (!selectedInstance) {\n        reviews = frameReviews.filter(r => !r.instanceItemId && !r.instanceId && r.camera === store.frame.currentCamera);\n      }\n      if (reviews) {\n        reviews.forEach(review => {\n          if (!store.isRework || review.result === ReviewResult.REJECT) {\n            const anchor = store.review.createReviewAnchor(review.result, review.x, review.y, container, viewScale);\n            if (anchor) {\n              anchor.data = review;\n              anchors.push(anchor);\n              if (store.review.selectedReviewId === review.id) {\n                store.review.selectReview(review, anchor);\n              }\n            }\n          }\n        });\n      }\n      return anchors;\n    };\n    /**\n     * on grid mouse move\n     * @param point\n     */\n    this.onGridMouseMove = point => {\n      // update current position on canvas\n      store.currPosition = point ? {\n        x: point.x,\n        y: point.y\n      } : undefined;\n    };\n    /**\n     * on selected grid changed\n     * @param _\n     * @param layer\n     * @param offset\n     */\n    this.onSelectedGridChanged = (_, layer, offset) => {\n      store.review.setReviewLayer(layer);\n      store.review.setReviewLayerOffset(offset.x, offset.y);\n    };\n    /**\n     * add shape or review anchor\n     * @param point\n     * @param container\n     * @param imageBounds\n     * @param viewScale\n     */\n    this.addShape = (point, container, imageBounds, viewScale) => {\n      if (store.config.reviewMode === ReviewMode.LABELING) {\n        return store.shape.addShape(point, container, imageBounds, this.updateShapes);\n      }\n      return store.review.addReview(point, container, viewScale);\n    };\n    this.reactionDisposers.push(reaction(() => store.grid.gridSize, () => {\n      var _this$gridCanvasRef$c2;\n      (_this$gridCanvasRef$c2 = this.gridCanvasRef.current) === null || _this$gridCanvasRef$c2 === void 0 ? void 0 : _this$gridCanvasRef$c2.updateCanvas(store.grid.gridSize);\n    }));\n\n    // when current frame changed\n    this.reactionDisposers.push(reaction(() => store.frame.currentFrame, () => {\n      var _this$gridCanvasRef$c3, _this$gridCanvasRef$c4;\n      (_this$gridCanvasRef$c3 = this.gridCanvasRef.current) === null || _this$gridCanvasRef$c3 === void 0 ? void 0 : _this$gridCanvasRef$c3.setGridSelected(store.frame.currentFrame);\n      (_this$gridCanvasRef$c4 = this.gridCanvasRef.current) === null || _this$gridCanvasRef$c4 === void 0 ? void 0 : _this$gridCanvasRef$c4.scrollTo(store.frame.currentFrame);\n    }));\n    this.reactionDisposers.push(reaction(() => store.instance.selectedInstanceItems,\n    // selected instance item changed\n    (items, prevItems) => {\n      const itemIds = items.map(i => i.id);\n      const prevItemIds = prevItems.map(i => i.id);\n      if (itemIds.some(i => prevItemIds.indexOf(i) < 0) || prevItemIds.some(i => itemIds.indexOf(i) < 0)) {\n        this.updateShapes();\n      }\n    }));\n    this.reactionDisposers.push(reaction(() => store.instance.selectedInstances,\n    // selected instance changed\n    (instances, prevInstances) => {\n      const instanceIds = instances.map(i => i.id);\n      const prevInstanceIds = prevInstances.map(i => i.id);\n      if (instanceIds.some(i => prevInstanceIds.indexOf(i) < 0) || prevInstanceIds.some(i => instanceIds.indexOf(i) < 0)) {\n        this.updateShapes();\n      }\n    }));\n    this.reactionDisposers.push(reaction(() => [store.config.reviewMode,\n    // review mode changed\n    store.config.labelMode,\n    // shape label mode changed\n    store.config.activePointAttributesMode // shape point attributes mode changed\n    ], () => {\n      this.updateShapes();\n    }));\n    this.reactionDisposers.push(reaction(() => [store.undo.pointer,\n    // action happens\n    store.undo.lastStoreId], (value, prevValue) => {\n      const {\n        reviewMode\n      } = store.config;\n      if (value[1] === prevValue[1]) {\n        // update by undo & redo\n        if (reviewMode === ReviewMode.REVIEW) {\n          var _this$gridCanvasRef$c5;\n          (_this$gridCanvasRef$c5 = this.gridCanvasRef.current) === null || _this$gridCanvasRef$c5 === void 0 ? void 0 : _this$gridCanvasRef$c5.updateReviews();\n        }\n      }\n      if (store.config.reviewMode === ReviewMode.LABELING) {\n        this.updateShapes();\n      }\n    }));\n  }\n  componentDidMount() {\n    store.grid.gridCanvas = this.gridCanvasRef.current;\n  }\n  componentWillUnmount() {\n    this.reactionDisposers.forEach(disposer => disposer());\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"grid-view\",\n      style: {\n        cursor: store.config.cursor\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 287,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(Header, {\n      reset: () => {\n        var _this$gridCanvasRef$c6;\n        return (_this$gridCanvasRef$c6 = this.gridCanvasRef.current) === null || _this$gridCanvasRef$c6 === void 0 ? void 0 : _this$gridCanvasRef$c6.fitShapes();\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 288,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(GridCanvas, {\n      ref: this.gridCanvasRef,\n      app: this.props.app,\n      grids: store.grid.grids,\n      gridWidth: store.grid.gridSize,\n      onGridSelected: store.frame.setFrame,\n      onGridMouseMove: this.onGridMouseMove,\n      onSelectedGridChanged: this.onSelectedGridChanged,\n      createShapesForGrid: this.createShapesForGrid,\n      createReviewsForGrid: this.createReviewsForGrid,\n      addShape: this.addShape,\n      onImageLoad: (i, w, h) => {\n        store.frame.updateImageSize(store.frame.currentCamera, i, w, h);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 289,\n        columnNumber: 9\n      }\n    }));\n  }\n}\nexport default observer(GridView);","map":{"version":3,"names":["React","reaction","observer","message","BorderStyle","EventAction","GridCanvas","Header","store","i18n","ReviewMode","ReviewResult","GridView","Component","constructor","props","reactionDisposers","gridCanvasRef","createRef","updateShapes","_this$gridCanvasRef$c","current","grid","grids","createShapesForGrid","gridIndex","container","imageBounds","shapes","currentCamera","frame","isSingleSelected","selectedInstances","selectedInstanceItems","instance","selectedInstance","undefined","selectedInstanceItem","items","Object","values","forEach","item","cameraData","cameras","frames","label","config","labelMode","shape","createShape","categoryItemRef","displayColor","category","name","shapeType","order","shapeInfo","predictShape","borderStyle","DASHED","isSelectedItem","on","SELECTED","selectInstanceItem","currentFrame","setFrame","CHANGED","s","data","area","minArea","warning","translate","deleteFramesFromInstanceItem","updateFrameShapeForInstanceItem","getNextShapeOrder","readonly","editable","borderColor","selected","addMode","interactive","setShapeStyles","push","createReviewsForGrid","viewScale","anchors","frameReviews","review","reviews","filter","r","instanceItemId","id","camera","instanceId","isRework","result","REJECT","anchor","createReviewAnchor","x","y","selectedReviewId","selectReview","onGridMouseMove","point","currPosition","onSelectedGridChanged","_","layer","offset","setReviewLayer","setReviewLayerOffset","addShape","reviewMode","LABELING","addReview","gridSize","_this$gridCanvasRef$c2","updateCanvas","_this$gridCanvasRef$c3","_this$gridCanvasRef$c4","setGridSelected","scrollTo","prevItems","itemIds","map","i","prevItemIds","some","indexOf","instances","prevInstances","instanceIds","prevInstanceIds","activePointAttributesMode","undo","pointer","lastStoreId","value","prevValue","REVIEW","_this$gridCanvasRef$c5","updateReviews","componentDidMount","gridCanvas","componentWillUnmount","disposer","render","createElement","className","style","cursor","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","reset","_this$gridCanvasRef$c6","fitShapes","ref","app","gridWidth","onGridSelected","onImageLoad","w","h","updateImageSize"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/components/grid/GridView.tsx"],"sourcesContent":["import React from 'react';\nimport { reaction, IReactionDisposer } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { Application, Container, Point } from 'pixi.js';\nimport { message } from 'antd';\nimport Shape, { BorderStyle, EventAction } from '../../../common/shapes/Shape';\nimport { ShapeData } from '../../../common/shapes/types';\nimport GridCanvas from '../../../common/shapes/canvas/GridCanvas';\nimport Anchor from '../../../common/shapes/anchors/Anchor';\nimport Header from './Header';\nimport store from '../../store/RootStore';\nimport i18n from '../../locales';\nimport { ReviewMode, ReviewResult } from '../../types';\nimport './GridView.scss';\n\ninterface GridViewProps {\n  app: Application;\n}\n\nclass GridView extends React.Component<GridViewProps> {\n  reactionDisposers: IReactionDisposer[] = [];\n\n  gridCanvasRef = React.createRef<GridCanvas>();\n\n  constructor(props: GridViewProps) {\n    super(props);\n\n    // when grid size changed\n    this.reactionDisposers.push(reaction(\n      () => store.grid.gridSize,\n      () => {\n        this.gridCanvasRef.current?.updateCanvas(store.grid.gridSize);\n      },\n    ));\n\n    // when current frame changed\n    this.reactionDisposers.push(reaction(\n      () => store.frame.currentFrame,\n      () => {\n        this.gridCanvasRef.current?.setGridSelected(store.frame.currentFrame);\n        this.gridCanvasRef.current?.scrollTo(store.frame.currentFrame);\n      },\n    ));\n\n    this.reactionDisposers.push(reaction(\n      () => store.instance.selectedInstanceItems, // selected instance item changed\n      (items, prevItems) => {\n        const itemIds = items.map((i) => i.id);\n        const prevItemIds = prevItems.map((i) => i.id);\n        if (itemIds.some((i) => prevItemIds.indexOf(i) < 0) || prevItemIds.some((i) => itemIds.indexOf(i) < 0)) {\n          this.updateShapes();\n        }\n      },\n    ));\n\n    this.reactionDisposers.push(reaction(\n      () => store.instance.selectedInstances, // selected instance changed\n      (instances, prevInstances) => {\n        const instanceIds = instances.map((i) => i.id);\n        const prevInstanceIds = prevInstances.map((i) => i.id);\n        if (instanceIds.some((i) => prevInstanceIds.indexOf(i) < 0) || prevInstanceIds.some((i) => instanceIds.indexOf(i) < 0)) {\n          this.updateShapes();\n        }\n      },\n    ));\n\n    this.reactionDisposers.push(reaction(\n      () => [\n        store.config.reviewMode, // review mode changed\n        store.config.labelMode, // shape label mode changed\n        store.config.activePointAttributesMode, // shape point attributes mode changed\n      ],\n      () => {\n        this.updateShapes();\n      },\n    ));\n\n    this.reactionDisposers.push(reaction(\n      () => [\n        store.undo.pointer, // action happens\n        store.undo.lastStoreId,\n      ],\n      (value, prevValue) => {\n        const { reviewMode } = store.config;\n        if (value[1] === prevValue[1]) {\n          // update by undo & redo\n          if (reviewMode === ReviewMode.REVIEW) {\n            this.gridCanvasRef.current?.updateReviews();\n          }\n        }\n        if (store.config.reviewMode === ReviewMode.LABELING) {\n          this.updateShapes();\n        }\n      },\n    ));\n  }\n\n  componentDidMount() {\n    store.grid.gridCanvas = this.gridCanvasRef.current!;\n  }\n\n  componentWillUnmount() {\n    this.reactionDisposers.forEach((disposer) => disposer());\n  }\n\n  /**\n   * update all grids shapes\n   */\n  updateShapes = () => {\n    this.gridCanvasRef.current?.updateShapes(store.grid.grids);\n  };\n\n  /**\n   * create shape for grid\n   * @param gridIndex\n   * @param container\n   * @param imageBounds\n   */\n  createShapesForGrid = (\n    gridIndex: number,\n    container: Container,\n    imageBounds: { left: number; top: number; right: number; bottom: number },\n  ) => {\n    const shapes: Shape<ShapeData>[] = [];\n\n    const { currentCamera } = store.frame;\n    const { isSingleSelected, selectedInstances, selectedInstanceItems } = store.instance;\n    const selectedInstance = isSingleSelected ? selectedInstances[0] : undefined;\n    const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n    if (selectedInstance) {\n      const { items } = selectedInstance;\n      Object.values(items).forEach((item) => {\n        const cameraData = item.cameras[currentCamera];\n        if (cameraData) {\n          const { frames } = cameraData;\n          const label = store.config.labelMode ? item.label : undefined;\n          let shape;\n          if (frames[gridIndex]) {\n            // create shape\n            shape = store.shape.createShape(\n              container,\n              imageBounds,\n              item.categoryItemRef.displayColor,\n              selectedInstance.category,\n              item.name,\n              frames[gridIndex].shapeType,\n              frames[gridIndex].shape,\n              frames[gridIndex].order,\n              label,\n            );\n          } else {\n            // predict\n            const shapeInfo = item.predictShape(currentCamera, gridIndex, imageBounds);\n            if (shapeInfo) {\n              shape = store.shape.createShape(\n                container,\n                imageBounds,\n                item.categoryItemRef.displayColor,\n                selectedInstance.category,\n                item.name,\n                shapeInfo.shapeType,\n                shapeInfo.shape,\n                9999,\n                label,\n              );\n              shape.borderStyle = BorderStyle.DASHED;\n            }\n          }\n          if (shape) {\n            const isSelectedItem = selectedInstanceItem === item;\n            shape.on(EventAction.SELECTED, () => {\n              store.instance.selectInstanceItem(item);\n              if (gridIndex !== store.frame.currentFrame) {\n                store.frame.setFrame(gridIndex);\n              }\n            });\n            shape.on(EventAction.CHANGED, (s, data) => {\n              if (s.area < store.config.minArea) {\n                message.warning(i18n.translate('MIN_AREA_ALERT'));\n                store.instance.deleteFramesFromInstanceItem(item, [gridIndex]);\n                return;\n              }\n              store.instance.updateFrameShapeForInstanceItem(\n                item,\n                gridIndex,\n                s.shapeType,\n                data,\n                frames[gridIndex] ? frames[gridIndex].order : store.frame.getNextShapeOrder(),\n              );\n              store.frame.setFrame(gridIndex);\n            });\n\n            if (store.readonly || !isSelectedItem) {\n              shape.editable = false;\n            }\n            shape.borderColor = 0xFFFF00;\n            shape.selected = isSelectedItem;\n            shape.data = item; // link shape & instance item\n            if (store.config.addMode) {\n              shape.interactive = false;\n            }\n            store.shape.setShapeStyles(shape, item, currentCamera, gridIndex);\n            shapes.push(shape);\n          }\n        }\n      });\n    }\n\n    return shapes;\n  };\n\n  /**\n   * create review anchors for grid\n   * @param gridIndex\n   * @param container\n   * @param viewScale\n   */\n  createReviewsForGrid = (gridIndex: number, container: Container, viewScale: number) => {\n    const anchors: Anchor[] = [];\n    const frameReviews = store.review.reviews[gridIndex] || [];\n\n    const { isSingleSelected, selectedInstances, selectedInstanceItems } = store.instance;\n    const selectedInstance = isSingleSelected ? selectedInstances[0] : undefined;\n    const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n\n    let reviews;\n    if (selectedInstanceItem) {\n      reviews = frameReviews.filter((r) => r.instanceItemId === selectedInstanceItem.id && r.camera === store.frame.currentCamera);\n    } else if (!selectedInstance) {\n      reviews = frameReviews.filter((r) => !r.instanceItemId && !r.instanceId && r.camera === store.frame.currentCamera);\n    }\n\n    if (reviews) {\n      reviews.forEach((review) => {\n        if (!store.isRework || review.result === ReviewResult.REJECT) {\n          const anchor = store.review.createReviewAnchor(review.result, review.x, review.y, container, viewScale);\n          if (anchor) {\n            anchor.data = review;\n            anchors.push(anchor);\n            if (store.review.selectedReviewId === review.id) {\n              store.review.selectReview(review, anchor);\n            }\n          }\n        }\n      });\n    }\n\n    return anchors;\n  };\n\n  /**\n   * on grid mouse move\n   * @param point\n   */\n  onGridMouseMove = (point: Point | null) => {\n    // update current position on canvas\n    store.currPosition = point ? { x: point.x, y: point.y } : undefined;\n  };\n\n  /**\n   * on selected grid changed\n   * @param _\n   * @param layer\n   * @param offset\n   */\n  onSelectedGridChanged = (_: number, layer: Container, offset: { x: number; y: number }) => {\n    store.review.setReviewLayer(layer);\n    store.review.setReviewLayerOffset(offset.x, offset.y);\n  };\n\n  /**\n   * add shape or review anchor\n   * @param point\n   * @param container\n   * @param imageBounds\n   * @param viewScale\n   */\n  addShape = (point: Point, container: Container, imageBounds: { left: number; top: number; right: number; bottom: number; }, viewScale?: number) => {\n    if (store.config.reviewMode === ReviewMode.LABELING) {\n      return store.shape.addShape(point, container, imageBounds, this.updateShapes);\n    }\n    return store.review.addReview(point, container, viewScale);\n  };\n\n  render() {\n    return (\n      <div className=\"grid-view\" style={{ cursor: store.config.cursor }}>\n        <Header reset={() => this.gridCanvasRef.current?.fitShapes()} />\n        <GridCanvas\n          ref={this.gridCanvasRef}\n          app={this.props.app}\n          grids={store.grid.grids}\n          gridWidth={store.grid.gridSize}\n          onGridSelected={store.frame.setFrame}\n          onGridMouseMove={this.onGridMouseMove}\n          onSelectedGridChanged={this.onSelectedGridChanged}\n          createShapesForGrid={this.createShapesForGrid}\n          createReviewsForGrid={this.createReviewsForGrid}\n          addShape={this.addShape}\n          onImageLoad={(i, w, h) => {\n            store.frame.updateImageSize(store.frame.currentCamera, i, w, h);\n          }}\n        />\n      </div>\n    );\n  }\n}\n\nexport default observer(GridView);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}