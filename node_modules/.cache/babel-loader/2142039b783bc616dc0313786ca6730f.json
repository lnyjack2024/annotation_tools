{"ast":null,"code":"import { Container, Text, utils as PIXIUtils } from 'pixi.js';\nimport ShapeGraphics from './ShapeGraphics';\nimport ControlBar from '../controls/ControlBar';\nimport rootStore from '../../store/RootStore';\nimport { AnnotationType, MoveType, ReviewResult, ReviewColor } from '../../types';\nimport eventBus, { ShapeAction, EventAction } from '../../utils/event';\nexport default class Shape {\n  /**\n   * emit event\n   * @protected\n   * @param eventName\n   */\n  _emit(eventName, ...args) {\n    this._eventEmitter.emit(eventName, this, ...args);\n  }\n\n  /**\n   * set hovered\n   */\n  set hovered(hover) {\n    this._hovered = hover;\n  }\n\n  /**\n   * get hovered\n   */\n  get hovered() {\n    return this._hovered;\n  }\n\n  /**\n   * set start\n   */\n  set start(start) {\n    const shouldUpdate = this._start !== start;\n    this._start = start;\n    if (shouldUpdate) {\n      this.normalize();\n    }\n  }\n\n  /**\n   * get start\n   */\n  get start() {\n    return this._start;\n  }\n\n  /**\n   * set end\n   */\n  set end(end) {\n    const shouldUpdate = this._end !== end;\n    this._end = end;\n    if (shouldUpdate) {\n      this.normalize();\n    }\n  }\n\n  /**\n   * get end\n   */\n  get end() {\n    return this._end;\n  }\n\n  /**\n   * set selected\n   */\n  set selected(selected) {\n    const shouldUpdate = this._selected !== selected;\n    this._selected = selected;\n    if (this.control) {\n      this.control.selected = selected;\n    }\n    if (shouldUpdate) {\n      this.getAdjoinShapes();\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get selected\n   */\n  get selected() {\n    return this._selected;\n  }\n\n  /**\n   * set selectedStart\n   */\n  set selectedStart(selected) {\n    this._selectedStart = selected;\n    if (this.control) {\n      this.control.selectedStart = selected;\n    }\n  }\n\n  /**\n   * get selectedStart\n   */\n  get selectedStart() {\n    return this._selectedStart;\n  }\n\n  /**\n   * set text\n   */\n  set text(text) {\n    const shouldUpdate = this._text !== text;\n    this._text = text;\n    if (shouldUpdate) {\n      this.clearText();\n      this.drawText();\n    }\n  }\n\n  /**\n   * get text\n   */\n  get text() {\n    return this._text;\n  }\n\n  /**\n   * get reviewResult\n   */\n  get reviewResult() {\n    return this._reviewResult;\n  }\n\n  /**\n   * set text\n   */\n  set reviewResult(result) {\n    const shouldUpdate = this._reviewResult !== result;\n    this._reviewResult = result;\n    if (shouldUpdate) {\n      switch (result) {\n        case ReviewResult.APPROVE:\n          this.reviewColor = ReviewColor.APPROVE;\n          this.reviewBackgroundColor = ReviewColor.APPROVE_BG;\n          break;\n        case ReviewResult.REJECT:\n          this.reviewColor = ReviewColor.REJECT;\n          this.reviewBackgroundColor = ReviewColor.REJECT_BG;\n          break;\n        case ReviewResult.SUSPEND:\n          this.reviewColor = ReviewColor.SUSPEND;\n          this.reviewBackgroundColor = ReviewColor.SUSPEND_BG;\n          break;\n        default:\n          this.reviewColor = undefined;\n          this.reviewBackgroundColor = undefined;\n          break;\n      }\n      this.drawShape();\n    }\n  }\n\n  /**\n   * add listener\n   * @param eventName\n   * @param callback\n   */\n  on(eventName, callback) {\n    this._eventEmitter.on(eventName, callback);\n    return this;\n  }\n\n  /**\n   * select shape\n   */\n\n  constructor(props) {\n    /**\n     * unique id\n     * @member {string}\n     */\n    this.id = void 0;\n    /**\n     * shape type\n     */\n    this.shapeType = void 0;\n    /**\n     * category\n     */\n    this.category = void 0;\n    /**\n     * cagtegory index\n     */\n    this.categoryIndex = 0;\n    /**\n     * pixi application\n     */\n    this.app = void 0;\n    /**\n     * PIXI instance\n     * @member {Graphics}\n     */\n    this.instance = new ShapeGraphics(this);\n    /**\n     * PIXI instance\n     * @member {Graphics}\n     */\n    this.label = void 0;\n    /**\n     * shape start time\n     */\n    this._start = void 0;\n    /**\n     * shape end time\n     */\n    this._end = void 0;\n    /**\n     * shape selected\n     */\n    this._selected = false;\n    /**\n     * shape start selected\n     */\n    this._selectedStart = false;\n    /**\n     * is hover\n     */\n    this._hovered = false;\n    /**\n     * position start\n     */\n    this.startX = 0;\n    /**\n     * position end\n     */\n    this._endX = 0;\n    /**\n     * position y\n     */\n    this._y = 0;\n    /**\n     * height\n     */\n    this._height = 0;\n    /**\n     * shape container\n     */\n    this.container = void 0;\n    /**\n     * shape container\n     * @member {PIXI.Container}\n     */\n    this.shapeContainer = new Container();\n    /**\n     * label container\n     * @member {PIXI.Container}\n     */\n    this.labelContainer = new Container();\n    /**\n     * control\n     */\n    this.control = void 0;\n    /**\n     * color\n     */\n    this.color = 0xE6ECF0;\n    /**\n     * text color\n     */\n    this.textColor = 0x363B44;\n    /**\n     * selected color\n     */\n    this.selectedColor = 0xFFE477;\n    /**\n     * selected text color\n     */\n    this.selectedTextColor = 0x0060FF;\n    this.reviewColor = void 0;\n    this.reviewBackgroundColor = void 0;\n    /**\n     * review status\n     */\n    this._reviewResult = void 0;\n    /**\n     * annotation text\n     */\n    this._text = void 0;\n    /**\n     * dragPosistion\n     */\n    this._dragPosistion = null;\n    /**\n     * is drag\n     */\n    this._dragged = false;\n    /**\n     * is shape destroyed\n     * @member {boolean}\n     */\n    this.destroyed = false;\n    /**\n     * prev shape\n     */\n    this.prevShape = void 0;\n    /**\n     * prev shape\n     */\n    this.nextShape = void 0;\n    this.sameTimeShapes = [];\n    this.adjoinTimeShapes = [];\n    /**\n     * events emitter\n     * @private {PIXI.utils.EventEmitter}\n     */\n    this._eventEmitter = new PIXIUtils.EventEmitter();\n    this.selectShape = void 0;\n    /**\n     * listen position change\n     */\n    this.positionListener = void 0;\n    /**\n     * move shape\n     */\n    this.moveShape = void 0;\n    /**\n     * get prev time shape\n     */\n    this.getPrevShape = void 0;\n    /**\n     * get same & prev time shape\n     */\n    this.getSameAndAdjoinTimeShapes = void 0;\n    this.remove = () => {\n      var _this$control;\n      this.clearText();\n      (_this$control = this.control) === null || _this$control === void 0 ? void 0 : _this$control.remove();\n      this.instance.clear();\n    };\n    /**\n     * destroy segment\n     */\n    this.destroy = () => {\n      var _this$control2;\n      this.destroyed = true;\n      (_this$control2 = this.control) === null || _this$control2 === void 0 ? void 0 : _this$control2.remove();\n      this.container.removeChild(this.labelContainer);\n      this.labelContainer.destroy({\n        children: true,\n        texture: true,\n        baseTexture: true\n      });\n      this.shapeContainer.removeChild(this.instance);\n      this.container.removeChild(this.shapeContainer);\n      this.shapeContainer.destroy({\n        children: true,\n        texture: true,\n        baseTexture: true\n      });\n    };\n    /**\n     * normalize segment\n     */\n    this.normalize = () => {\n      if (this.destroyed) return;\n      const {\n        displayBuffer: {\n          start: visibleStart,\n          precent: visiblePrecent\n        },\n        placement: {\n          atlasWidth,\n          duration\n        },\n        oneTierHeight\n      } = rootStore.analyse;\n      const visibleStartTime = visibleStart * duration;\n      const visibleDuration = visiblePrecent * duration;\n      const colWidth = atlasWidth / visibleDuration;\n      this.startX = (this.start - visibleStartTime) * colWidth;\n      if (this.end) {\n        this._endX = (this.end - visibleStartTime) * colWidth;\n      }\n      this._y = this.categoryIndex * oneTierHeight;\n      this._height = oneTierHeight;\n      this.drawShape();\n    };\n    this.resize = ({\n      start,\n      end\n    }) => {\n      if (this.destroyed) return;\n      const {\n        placement: {\n          atlasWidth,\n          duration\n        }\n      } = rootStore.analyse;\n      const visibleStartTime = start * duration;\n      const visibleDuration = (end - start) * duration;\n      const colWidth = atlasWidth / visibleDuration;\n      this.startX = (this.start - visibleStartTime) * colWidth;\n      if (this.end) {\n        this._endX = (this.end - visibleStartTime) * colWidth;\n      }\n      this.drawShape();\n    };\n    this.getAdjoinShapes = () => {\n      if (this.selected) {\n        const {\n          prev,\n          next\n        } = this.getPrevShape(this.category, this.start);\n        this.prevShape = prev;\n        this.nextShape = next;\n        const {\n          sameTimeShapes,\n          adjoinTimeShapes\n        } = this.getSameAndAdjoinTimeShapes(this.start);\n        this.sameTimeShapes = sameTimeShapes;\n        this.adjoinTimeShapes = adjoinTimeShapes;\n      } else {\n        this.prevShape = undefined;\n        this.nextShape = undefined;\n        this.sameTimeShapes = [];\n        this.adjoinTimeShapes = [];\n      }\n    };\n    this.getBoundary = type => {\n      const {\n        placement: {\n          atlasWidth\n        }\n      } = rootStore.analyse;\n      const boundary = [0, atlasWidth];\n      const computedBound = (prev, next) => {\n        if (prev) {\n          boundary[0] = Math.max(boundary[0], prev.startX);\n        }\n        if (next) {\n          boundary[1] = Math.min(boundary[1], next.startX);\n        }\n      };\n      if (type === MoveType.SINGLE) {\n        computedBound(this.prevShape, this.nextShape);\n      } else {\n        this.adjoinTimeShapes.forEach(({\n          prev,\n          next\n        }) => {\n          computedBound(prev, next);\n        });\n      }\n      return this.shapeType === AnnotationType.SEGMENT ? [boundary[0] + 10, boundary[1] - 10] : [boundary[0] + 5, boundary[1] - 5];\n    };\n    this.onPositionChange = (distance, type) => {\n      const [min, max] = this.getBoundary(type);\n      const x = this.startX + distance;\n      if (this.startX <= min && distance < 0 || x >= max && distance > 0) {\n        return;\n      }\n      const {\n        displayBuffer: {\n          precent: visiblePrecent\n        },\n        placement: {\n          atlasWidth,\n          duration\n        }\n      } = rootStore.analyse;\n      const moveDuration = distance / atlasWidth * (visiblePrecent * duration);\n      const start = this.start + moveDuration;\n      this.start = start;\n      if (type === MoveType.SINGLE) {\n        if (this.prevShape && this.prevShape.shapeType === AnnotationType.SEGMENT) {\n          this.prevShape.end = start;\n        }\n      } else {\n        this.sameTimeShapes.forEach(shape => {\n          shape.start = start;\n        });\n        this.adjoinTimeShapes.forEach(({\n          prev\n        }) => {\n          if (prev && prev.shapeType === AnnotationType.SEGMENT) {\n            prev.end = start;\n          }\n        });\n      }\n      this.positionListener(start);\n    };\n    this.finishPositionChange = () => {\n      const updateShapes = new Set();\n      updateShapes.add(this);\n      this.sameTimeShapes.forEach(shape => {\n        updateShapes.add(shape);\n      });\n      this.adjoinTimeShapes.forEach(({\n        prev\n      }) => {\n        if (prev && prev.shapeType === AnnotationType.SEGMENT) {\n          updateShapes.add(prev);\n        }\n      });\n      this.moveShape(Array.from(updateShapes));\n    };\n    const {\n      id,\n      app,\n      start: _start,\n      end: _end,\n      container,\n      category,\n      shapeType,\n      categoryIndex,\n      color,\n      selectedColor,\n      text,\n      reviewResult,\n      selectShape,\n      positionListener,\n      moveShape,\n      getPrevShape,\n      getSameAndAdjoinTimeShapes\n    } = props;\n    this.id = id;\n    this.app = app;\n    this.shapeType = shapeType;\n    this.category = category;\n    this.categoryIndex = categoryIndex;\n    this.container = container;\n    this._start = _start;\n    if (reviewResult) {\n      this.reviewResult = reviewResult;\n    }\n    this.selectShape = selectShape;\n    this.positionListener = positionListener;\n    this.moveShape = moveShape;\n    this.getPrevShape = getPrevShape;\n    this.getSameAndAdjoinTimeShapes = getSameAndAdjoinTimeShapes;\n    this.shapeContainer.zIndex = 99;\n    this.labelContainer.zIndex = 999;\n    this.labelContainer.interactive = false;\n    this.shapeContainer.addChild(this.instance);\n    this.shapeContainer.addChild(this.labelContainer);\n    this.container.addChild(this.shapeContainer);\n    if (_end) {\n      this.end = _end;\n    }\n    if (color) {\n      this.color = color;\n    }\n    if (selectedColor) {\n      this.selectedColor = selectedColor;\n    }\n    if (text) {\n      this.text = text;\n    }\n    eventBus.on(EventAction.DISPLAY_CHANGE, range => {\n      this.resize(range);\n    });\n    this.normalize();\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  _changed() {\n    this._emit(ShapeAction.CHANGED, this.getData());\n  }\n\n  /**\n   * actual draw the shape on canvas\n   */\n\n  /**\n  * get shape data\n  */\n\n  clearText() {\n    this.labelContainer.removeChildren();\n  }\n  drawText() {\n    const start = this.shapeType === AnnotationType.TIMING ? this.startX : (this.startX + this._endX) / 2;\n    if (this.text) {\n      let color = this.selected ? this.selectedTextColor : this.textColor;\n      if (this.reviewColor) {\n        color = this.reviewColor;\n      }\n      const label = new Text(this.text, {\n        fill: color,\n        fontSize: 20\n      });\n      const {\n        width,\n        height\n      } = label.getBounds();\n      label.zIndex = 99;\n      label.position.set(start - width / 2, this._y + (this._height - height) / 2);\n      this.labelContainer.addChild(label);\n    }\n  }\n  _initControl() {\n    if (!this.control) {\n      this.control = new ControlBar({\n        container: this.shapeContainer,\n        position: {\n          x: this.startX,\n          y: this._y\n        },\n        shapeType: this.shapeType,\n        height: this._height,\n        selected: this._selected,\n        onPositionChange: this.onPositionChange,\n        onClick: () => {\n          this.selectShape(this.id);\n        },\n        finishPositionChange: this.finishPositionChange\n      });\n    } else {\n      this.control.init({\n        position: {\n          x: this.startX,\n          y: this._y\n        },\n        shapeType: this.shapeType,\n        height: this._height,\n        selected: this._selected,\n        color: this.reviewColor\n      });\n    }\n  }\n}","map":{"version":3,"names":["Container","Text","utils","PIXIUtils","ShapeGraphics","ControlBar","rootStore","AnnotationType","MoveType","ReviewResult","ReviewColor","eventBus","ShapeAction","EventAction","Shape","_emit","eventName","args","_eventEmitter","emit","hovered","hover","_hovered","start","shouldUpdate","_start","normalize","end","_end","selected","_selected","control","getAdjoinShapes","drawShape","selectedStart","_selectedStart","text","_text","clearText","drawText","reviewResult","_reviewResult","result","APPROVE","reviewColor","reviewBackgroundColor","APPROVE_BG","REJECT","REJECT_BG","SUSPEND","SUSPEND_BG","undefined","on","callback","constructor","props","id","shapeType","category","categoryIndex","app","instance","label","startX","_endX","_y","_height","container","shapeContainer","labelContainer","color","textColor","selectedColor","selectedTextColor","_dragPosistion","_dragged","destroyed","prevShape","nextShape","sameTimeShapes","adjoinTimeShapes","EventEmitter","selectShape","positionListener","moveShape","getPrevShape","getSameAndAdjoinTimeShapes","remove","_this$control","clear","destroy","_this$control2","removeChild","children","texture","baseTexture","displayBuffer","visibleStart","precent","visiblePrecent","placement","atlasWidth","duration","oneTierHeight","analyse","visibleStartTime","visibleDuration","colWidth","resize","prev","next","getBoundary","type","boundary","computedBound","Math","max","min","SINGLE","forEach","SEGMENT","onPositionChange","distance","x","moveDuration","shape","finishPositionChange","updateShapes","Set","add","Array","from","zIndex","interactive","addChild","DISPLAY_CHANGE","range","_changed","CHANGED","getData","removeChildren","TIMING","fill","fontSize","width","height","getBounds","position","set","_initControl","y","onClick","init"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/common/shapes/Shape.ts"],"sourcesContent":["import { Application, Container, Text, utils as PIXIUtils } from 'pixi.js';\nimport ShapeGraphics from './ShapeGraphics';\nimport ControlBar from '../controls/ControlBar';\nimport rootStore from '../../store/RootStore';\nimport { AnnotationType, MoveType, ReviewResult, ReviewColor } from '../../types';\nimport eventBus, { ShapeAction, EventAction } from '../../utils/event';\n\nexport interface ShapeOptions {\n  id: string;\n  app: Application;\n  start: number;\n  end?: number;\n  shapeType: AnnotationType;\n  container: Container;\n  category: string;\n  categoryIndex: number;\n  color?: number;\n  selectedColor?: number;\n  text?: string;\n  reviewResult?: ReviewResult;\n  selectShape: (id: string) => void;\n  positionListener: (start: number) => void;\n  moveShape: (shapes: Shape<unknown>[]) => void;\n  getPrevShape: (category: string, start: number) => { prev?: Shape<unknown>; next?: Shape<unknown>; };\n  getSameAndAdjoinTimeShapes: (time: number) => {\n    sameTimeShapes: Shape<unknown>[];\n    adjoinTimeShapes: {\n      prev: Shape<unknown> | undefined;\n      next: Shape<unknown> | undefined;\n    }[];\n  };\n}\n\nexport default abstract class Shape<T> {\n  /**\n   * unique id\n   * @member {string}\n   */\n  id: string;\n\n  /**\n   * shape type\n   */\n  shapeType: AnnotationType;\n\n  /**\n   * category\n   */\n  category: string;\n\n  /**\n   * cagtegory index\n   */\n  categoryIndex = 0;\n\n  /**\n   * pixi application\n   */\n  app: Application;\n\n  /**\n   * PIXI instance\n   * @member {Graphics}\n   */\n  instance = new ShapeGraphics<T>(this);\n\n  /**\n   * PIXI instance\n   * @member {Graphics}\n   */\n  label?: Text;\n\n  /**\n   * shape start time\n   */\n  _start: number;\n\n  /**\n   * shape end time\n   */\n  _end?: number;\n\n  /**\n   * shape selected\n   */\n  private _selected = false;\n\n  /**\n   * shape start selected\n   */\n  private _selectedStart = false;\n\n  /**\n   * is hover\n   */\n  protected _hovered = false;\n\n  /**\n   * position start\n   */\n  startX = 0;\n\n  /**\n   * position end\n   */\n  protected _endX = 0;\n\n  /**\n   * position y\n   */\n  protected _y = 0;\n\n  /**\n   * height\n   */\n  protected _height = 0;\n\n  /**\n   * shape container\n   */\n  container: Container;\n\n  /**\n   * shape container\n   * @member {PIXI.Container}\n   */\n  shapeContainer = new Container();\n\n  /**\n   * label container\n   * @member {PIXI.Container}\n   */\n  labelContainer = new Container();\n\n  /**\n   * control\n   */\n  control?: ControlBar;\n\n  /**\n   * color\n   */\n  color = 0xE6ECF0;\n\n  /**\n   * text color\n   */\n  textColor = 0x363B44;\n\n  /**\n   * selected color\n   */\n  selectedColor = 0xFFE477;\n\n  /**\n   * selected text color\n   */\n  selectedTextColor = 0x0060FF;\n\n  reviewColor?: number;\n\n  reviewBackgroundColor?: number;\n\n  /**\n   * review status\n   */\n  _reviewResult?: ReviewResult;\n\n  /**\n   * annotation text\n   */\n  _text?: string;\n\n  /**\n   * dragPosistion\n   */\n  _dragPosistion: number | null = null;\n\n  /**\n   * is drag\n   */\n  _dragged = false;\n\n  /**\n   * is shape destroyed\n   * @member {boolean}\n   */\n  destroyed = false;\n\n  /**\n   * prev shape\n   */\n  prevShape: Shape<unknown> | undefined;\n\n  /**\n   * prev shape\n   */\n  nextShape: Shape<unknown> | undefined;\n\n  sameTimeShapes: Shape<unknown>[] = [];\n\n  adjoinTimeShapes: {\n    prev: Shape<unknown> | undefined;\n    next: Shape<unknown> | undefined;\n  }[] = [];\n\n  /**\n   * events emitter\n   * @private {PIXI.utils.EventEmitter}\n   */\n  private _eventEmitter = new PIXIUtils.EventEmitter();\n\n  /**\n   * emit event\n   * @protected\n   * @param eventName\n   */\n  protected _emit(eventName: string, ...args: any[]) {\n    this._eventEmitter.emit(eventName, this, ...args);\n  }\n\n  /**\n   * set hovered\n   */\n  set hovered(hover: boolean) {\n    this._hovered = hover;\n  }\n\n  /**\n   * get hovered\n   */\n  get hovered() {\n    return this._hovered;\n  }\n\n  /**\n   * set start\n   */\n  set start(start: number) {\n    const shouldUpdate = this._start !== start;\n    this._start = start;\n    if (shouldUpdate) {\n      this.normalize();\n    }\n  }\n\n  /**\n   * get start\n   */\n  get start() {\n    return this._start;\n  }\n\n  /**\n   * set end\n   */\n  set end(end: number | undefined) {\n    const shouldUpdate = this._end !== end;\n    this._end = end;\n    if (shouldUpdate) {\n      this.normalize();\n    }\n  }\n\n  /**\n   * get end\n   */\n  get end() {\n    return this._end;\n  }\n\n  /**\n   * set selected\n   */\n  set selected(selected: boolean) {\n    const shouldUpdate = this._selected !== selected;\n    this._selected = selected;\n    if (this.control) {\n      this.control.selected = selected;\n    }\n\n    if (shouldUpdate) {\n      this.getAdjoinShapes();\n      this.drawShape();\n    }\n  }\n\n  /**\n   * get selected\n   */\n  get selected() {\n    return this._selected;\n  }\n\n  /**\n   * set selectedStart\n   */\n  set selectedStart(selected: boolean) {\n    this._selectedStart = selected;\n    if (this.control) {\n      this.control.selectedStart = selected;\n    }\n  }\n\n  /**\n   * get selectedStart\n   */\n  get selectedStart() {\n    return this._selectedStart;\n  }\n\n  /**\n   * set text\n   */\n  set text(text: string | undefined) {\n    const shouldUpdate = this._text !== text;\n    this._text = text;\n\n    if (shouldUpdate) {\n      this.clearText();\n      this.drawText();\n    }\n  }\n\n  /**\n   * get text\n   */\n  get text() {\n    return this._text;\n  }\n\n  /**\n   * get reviewResult\n   */\n  get reviewResult() {\n    return this._reviewResult;\n  }\n\n  /**\n   * set text\n   */\n  set reviewResult(result: ReviewResult | undefined) {\n    const shouldUpdate = this._reviewResult !== result;\n    this._reviewResult = result;\n    if (shouldUpdate) {\n      switch (result) {\n        case ReviewResult.APPROVE:\n          this.reviewColor = ReviewColor.APPROVE;\n          this.reviewBackgroundColor = ReviewColor.APPROVE_BG;\n          break;\n        case ReviewResult.REJECT:\n          this.reviewColor = ReviewColor.REJECT;\n          this.reviewBackgroundColor = ReviewColor.REJECT_BG;\n          break;\n        case ReviewResult.SUSPEND:\n          this.reviewColor = ReviewColor.SUSPEND;\n          this.reviewBackgroundColor = ReviewColor.SUSPEND_BG;\n          break;\n        default:\n          this.reviewColor = undefined;\n          this.reviewBackgroundColor = undefined;\n          break;\n      }\n      this.drawShape();\n    }\n  }\n\n  /**\n   * add listener\n   * @param eventName\n   * @param callback\n   */\n  on(eventName: string, callback: (shape: Shape<T>, ...args: any[]) => void) {\n    this._eventEmitter.on(eventName, callback);\n    return this;\n  }\n\n  /**\n   * select shape\n   */\n  selectShape: (id: string) => void;\n\n  /**\n   * listen position change\n   */\n  positionListener: (start: number) => void;\n\n  /**\n   * move shape\n   */\n  moveShape: (shapes: Shape<unknown>[]) => void;\n\n  /**\n   * get prev time shape\n   */\n  getPrevShape: (category: string, start: number) => { prev?: Shape<unknown>; next?: Shape<unknown>; };\n\n  /**\n   * get same & prev time shape\n   */\n  getSameAndAdjoinTimeShapes: (time: number) => {\n    sameTimeShapes: Shape<unknown>[];\n    adjoinTimeShapes: {\n      prev: Shape<unknown> | undefined;\n      next: Shape<unknown> | undefined;\n    }[];\n  };\n\n  constructor(props: ShapeOptions) {\n    const {\n      id, app, start, end, container, category, shapeType,\n      categoryIndex, color, selectedColor, text, reviewResult,\n      selectShape, positionListener, moveShape, getPrevShape, getSameAndAdjoinTimeShapes,\n    } = props;\n    this.id = id;\n    this.app = app;\n    this.shapeType = shapeType;\n    this.category = category;\n    this.categoryIndex = categoryIndex;\n    this.container = container;\n    this._start = start;\n    if (reviewResult) {\n      this.reviewResult = reviewResult;\n    }\n    this.selectShape = selectShape;\n    this.positionListener = positionListener;\n    this.moveShape = moveShape;\n    this.getPrevShape = getPrevShape;\n    this.getSameAndAdjoinTimeShapes = getSameAndAdjoinTimeShapes;\n\n    this.shapeContainer.zIndex = 99;\n    this.labelContainer.zIndex = 999;\n    this.labelContainer.interactive = false;\n    this.shapeContainer.addChild(this.instance);\n    this.shapeContainer.addChild(this.labelContainer);\n    this.container.addChild(this.shapeContainer);\n    if (end) {\n      this.end = end;\n    }\n    if (color) {\n      this.color = color;\n    }\n    if (selectedColor) {\n      this.selectedColor = selectedColor;\n    }\n    if (text) {\n      this.text = text;\n    }\n    eventBus.on(EventAction.DISPLAY_CHANGE, (range: { start: number, end: number }) => {\n      this.resize(range);\n    });\n    this.normalize();\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  protected _changed() {\n    this._emit(ShapeAction.CHANGED, this.getData());\n  }\n\n  remove = () => {\n    this.clearText();\n    this.control?.remove();\n    this.instance.clear();\n  };\n\n  /**\n   * destroy segment\n   */\n  destroy = () => {\n    this.destroyed = true;\n    this.control?.remove();\n    this.container.removeChild(this.labelContainer);\n    this.labelContainer.destroy({\n      children: true,\n      texture: true,\n      baseTexture: true,\n    });\n    this.shapeContainer.removeChild(this.instance);\n    this.container.removeChild(this.shapeContainer);\n    this.shapeContainer.destroy({\n      children: true,\n      texture: true,\n      baseTexture: true,\n    });\n  };\n\n  /**\n   * normalize segment\n   */\n  normalize = () => {\n    if (this.destroyed) return;\n    const {\n      displayBuffer: { start: visibleStart, precent: visiblePrecent },\n      placement: { atlasWidth, duration },\n      oneTierHeight,\n    } = rootStore.analyse;\n    const visibleStartTime = visibleStart * duration;\n    const visibleDuration = visiblePrecent * duration;\n    const colWidth = atlasWidth / visibleDuration;\n    this.startX = (this.start - visibleStartTime) * colWidth;\n    if (this.end) {\n      this._endX = (this.end - visibleStartTime) * colWidth;\n    }\n    this._y = this.categoryIndex * oneTierHeight;\n    this._height = oneTierHeight;\n    this.drawShape();\n  };\n\n  resize = ({ start, end }: { start: number, end: number }) => {\n    if (this.destroyed) return;\n    const {\n      placement: { atlasWidth, duration },\n    } = rootStore.analyse;\n    const visibleStartTime = start * duration;\n    const visibleDuration = (end - start) * duration;\n    const colWidth = atlasWidth / visibleDuration;\n    this.startX = (this.start - visibleStartTime) * colWidth;\n    if (this.end) {\n      this._endX = (this.end - visibleStartTime) * colWidth;\n    }\n    this.drawShape();\n  };\n\n  getAdjoinShapes = () => {\n    if (this.selected) {\n      const { prev, next } = this.getPrevShape(this.category, this.start);\n      this.prevShape = prev;\n      this.nextShape = next;\n      const { sameTimeShapes, adjoinTimeShapes } = this.getSameAndAdjoinTimeShapes(this.start);\n      this.sameTimeShapes = sameTimeShapes;\n      this.adjoinTimeShapes = adjoinTimeShapes;\n    } else {\n      this.prevShape = undefined;\n      this.nextShape = undefined;\n      this.sameTimeShapes = [];\n      this.adjoinTimeShapes = [];\n    }\n  };\n\n  getBoundary = (type: MoveType) => {\n    const {\n      placement: { atlasWidth },\n    } = rootStore.analyse;\n    const boundary = [0, atlasWidth];\n    const computedBound = (prev: Shape<unknown> | undefined, next: Shape<unknown> | undefined) => {\n      if (prev) {\n        boundary[0] = Math.max(boundary[0], prev.startX);\n      }\n      if (next) {\n        boundary[1] = Math.min(boundary[1], next.startX);\n      }\n    };\n    if (type === MoveType.SINGLE) {\n      computedBound(this.prevShape, this.nextShape);\n    } else {\n      this.adjoinTimeShapes.forEach(({ prev, next }) => {\n        computedBound(prev, next);\n      });\n    }\n    return this.shapeType === AnnotationType.SEGMENT ? [\n      boundary[0] + 10,\n      boundary[1] - 10,\n    ] : [\n      boundary[0] + 5,\n      boundary[1] - 5,\n    ];\n  };\n\n  /**\n   * actual draw the shape on canvas\n   */\n  abstract drawShape(): void;\n\n  /**\n  * get shape data\n  */\n  abstract getData(): T;\n\n  clearText() {\n    this.labelContainer.removeChildren();\n  }\n\n  drawText() {\n    const start = this.shapeType === AnnotationType.TIMING ? this.startX : (this.startX + this._endX) / 2;\n    if (this.text) {\n      let color = this.selected ? this.selectedTextColor : this.textColor;\n      if (this.reviewColor) {\n        color = this.reviewColor;\n      }\n      const label = new Text(this.text, { fill: color, fontSize: 20 });\n      const { width, height } = label.getBounds();\n      label.zIndex = 99;\n      label.position.set(start - width / 2, this._y + (this._height - height) / 2);\n      this.labelContainer.addChild(label);\n    }\n  }\n\n  _initControl() {\n    if (!this.control) {\n      this.control = new ControlBar({\n        container: this.shapeContainer,\n        position: { x: this.startX, y: this._y },\n        shapeType: this.shapeType,\n        height: this._height,\n        selected: this._selected,\n        onPositionChange: this.onPositionChange,\n        onClick: () => {\n          this.selectShape(this.id);\n        },\n        finishPositionChange: this.finishPositionChange,\n      });\n    } else {\n      this.control.init({\n        position: { x: this.startX, y: this._y },\n        shapeType: this.shapeType,\n        height: this._height,\n        selected: this._selected,\n        color: this.reviewColor,\n      });\n    }\n  }\n\n  onPositionChange = (distance: number, type: MoveType) => {\n    const [min, max] = this.getBoundary(type);\n    const x = this.startX + distance;\n    if ((this.startX <= min && distance < 0) || (x >= max && distance > 0)) {\n      return;\n    }\n    const {\n      displayBuffer: { precent: visiblePrecent },\n      placement: { atlasWidth, duration },\n    } = rootStore.analyse;\n    const moveDuration = (distance / atlasWidth) * (visiblePrecent * duration);\n    const start = this.start + moveDuration;\n    this.start = start;\n    if (type === MoveType.SINGLE) {\n      if (this.prevShape && this.prevShape.shapeType === AnnotationType.SEGMENT) {\n        this.prevShape.end = start;\n      }\n    } else {\n      this.sameTimeShapes.forEach((shape) => {\n        shape.start = start;\n      });\n      this.adjoinTimeShapes.forEach(({ prev }) => {\n        if (prev && prev.shapeType === AnnotationType.SEGMENT) {\n          prev.end = start;\n        }\n      });\n    }\n    this.positionListener(start);\n  };\n\n  finishPositionChange = () => {\n    const updateShapes: Set<Shape<unknown>> = new Set();\n    updateShapes.add(this);\n    this.sameTimeShapes.forEach((shape) => {\n      updateShapes.add(shape);\n    });\n    this.adjoinTimeShapes.forEach(({ prev }) => {\n      if (prev && prev.shapeType === AnnotationType.SEGMENT) {\n        updateShapes.add(prev);\n      }\n    });\n    this.moveShape(Array.from(updateShapes));\n  };\n}\n"],"mappings":"AAAA,SAAsBA,SAAS,EAAEC,IAAI,EAAEC,KAAK,IAAIC,SAAS,QAAQ,SAAS;AAC1E,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,UAAU,MAAM,wBAAwB;AAC/C,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,SAASC,cAAc,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,WAAW,QAAQ,aAAa;AACjF,OAAOC,QAAQ,IAAIC,WAAW,EAAEC,WAAW,QAAQ,mBAAmB;AA4BtE,eAAe,MAAeC,KAAK,CAAI;EAmLrC;AACF;AACA;AACA;AACA;EACYC,KAAKA,CAACC,SAAiB,EAAE,GAAGC,IAAW,EAAE;IACjD,IAAI,CAACC,aAAa,CAACC,IAAI,CAACH,SAAS,EAAE,IAAI,EAAE,GAAGC,IAAI,CAAC;EACnD;;EAEA;AACF;AACA;EACE,IAAIG,OAAOA,CAACC,KAAc,EAAE;IAC1B,IAAI,CAACC,QAAQ,GAAGD,KAAK;EACvB;;EAEA;AACF;AACA;EACE,IAAID,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACE,QAAQ;EACtB;;EAEA;AACF;AACA;EACE,IAAIC,KAAKA,CAACA,KAAa,EAAE;IACvB,MAAMC,YAAY,GAAG,IAAI,CAACC,MAAM,KAAKF,KAAK;IAC1C,IAAI,CAACE,MAAM,GAAGF,KAAK;IACnB,IAAIC,YAAY,EAAE;MAChB,IAAI,CAACE,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;EACE,IAAIH,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACE,MAAM;EACpB;;EAEA;AACF;AACA;EACE,IAAIE,GAAGA,CAACA,GAAuB,EAAE;IAC/B,MAAMH,YAAY,GAAG,IAAI,CAACI,IAAI,KAAKD,GAAG;IACtC,IAAI,CAACC,IAAI,GAAGD,GAAG;IACf,IAAIH,YAAY,EAAE;MAChB,IAAI,CAACE,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;EACE,IAAIC,GAAGA,CAAA,EAAG;IACR,OAAO,IAAI,CAACC,IAAI;EAClB;;EAEA;AACF;AACA;EACE,IAAIC,QAAQA,CAACA,QAAiB,EAAE;IAC9B,MAAML,YAAY,GAAG,IAAI,CAACM,SAAS,KAAKD,QAAQ;IAChD,IAAI,CAACC,SAAS,GAAGD,QAAQ;IACzB,IAAI,IAAI,CAACE,OAAO,EAAE;MAChB,IAAI,CAACA,OAAO,CAACF,QAAQ,GAAGA,QAAQ;IAClC;IAEA,IAAIL,YAAY,EAAE;MAChB,IAAI,CAACQ,eAAe,CAAC,CAAC;MACtB,IAAI,CAACC,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;EACE,IAAIJ,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACC,SAAS;EACvB;;EAEA;AACF;AACA;EACE,IAAII,aAAaA,CAACL,QAAiB,EAAE;IACnC,IAAI,CAACM,cAAc,GAAGN,QAAQ;IAC9B,IAAI,IAAI,CAACE,OAAO,EAAE;MAChB,IAAI,CAACA,OAAO,CAACG,aAAa,GAAGL,QAAQ;IACvC;EACF;;EAEA;AACF;AACA;EACE,IAAIK,aAAaA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACC,cAAc;EAC5B;;EAEA;AACF;AACA;EACE,IAAIC,IAAIA,CAACA,IAAwB,EAAE;IACjC,MAAMZ,YAAY,GAAG,IAAI,CAACa,KAAK,KAAKD,IAAI;IACxC,IAAI,CAACC,KAAK,GAAGD,IAAI;IAEjB,IAAIZ,YAAY,EAAE;MAChB,IAAI,CAACc,SAAS,CAAC,CAAC;MAChB,IAAI,CAACC,QAAQ,CAAC,CAAC;IACjB;EACF;;EAEA;AACF;AACA;EACE,IAAIH,IAAIA,CAAA,EAAG;IACT,OAAO,IAAI,CAACC,KAAK;EACnB;;EAEA;AACF;AACA;EACE,IAAIG,YAAYA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACC,aAAa;EAC3B;;EAEA;AACF;AACA;EACE,IAAID,YAAYA,CAACE,MAAgC,EAAE;IACjD,MAAMlB,YAAY,GAAG,IAAI,CAACiB,aAAa,KAAKC,MAAM;IAClD,IAAI,CAACD,aAAa,GAAGC,MAAM;IAC3B,IAAIlB,YAAY,EAAE;MAChB,QAAQkB,MAAM;QACZ,KAAKjC,YAAY,CAACkC,OAAO;UACvB,IAAI,CAACC,WAAW,GAAGlC,WAAW,CAACiC,OAAO;UACtC,IAAI,CAACE,qBAAqB,GAAGnC,WAAW,CAACoC,UAAU;UACnD;QACF,KAAKrC,YAAY,CAACsC,MAAM;UACtB,IAAI,CAACH,WAAW,GAAGlC,WAAW,CAACqC,MAAM;UACrC,IAAI,CAACF,qBAAqB,GAAGnC,WAAW,CAACsC,SAAS;UAClD;QACF,KAAKvC,YAAY,CAACwC,OAAO;UACvB,IAAI,CAACL,WAAW,GAAGlC,WAAW,CAACuC,OAAO;UACtC,IAAI,CAACJ,qBAAqB,GAAGnC,WAAW,CAACwC,UAAU;UACnD;QACF;UACE,IAAI,CAACN,WAAW,GAAGO,SAAS;UAC5B,IAAI,CAACN,qBAAqB,GAAGM,SAAS;UACtC;MACJ;MACA,IAAI,CAAClB,SAAS,CAAC,CAAC;IAClB;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEmB,EAAEA,CAACpC,SAAiB,EAAEqC,QAAmD,EAAE;IACzE,IAAI,CAACnC,aAAa,CAACkC,EAAE,CAACpC,SAAS,EAAEqC,QAAQ,CAAC;IAC1C,OAAO,IAAI;EACb;;EAEA;AACF;AACA;;EA6BEC,WAAWA,CAACC,KAAmB,EAAE;IAtXjC;AACF;AACA;AACA;IAHE,KAIAC,EAAE;IAEF;AACF;AACA;IAFE,KAGAC,SAAS;IAET;AACF;AACA;IAFE,KAGAC,QAAQ;IAER;AACF;AACA;IAFE,KAGAC,aAAa,GAAG,CAAC;IAEjB;AACF;AACA;IAFE,KAGAC,GAAG;IAEH;AACF;AACA;AACA;IAHE,KAIAC,QAAQ,GAAG,IAAIzD,aAAa,CAAI,IAAI,CAAC;IAErC;AACF;AACA;AACA;IAHE,KAIA0D,KAAK;IAEL;AACF;AACA;IAFE,KAGArC,MAAM;IAEN;AACF;AACA;IAFE,KAGAG,IAAI;IAEJ;AACF;AACA;IAFE,KAGQE,SAAS,GAAG,KAAK;IAEzB;AACF;AACA;IAFE,KAGQK,cAAc,GAAG,KAAK;IAE9B;AACF;AACA;IAFE,KAGUb,QAAQ,GAAG,KAAK;IAE1B;AACF;AACA;IAFE,KAGAyC,MAAM,GAAG,CAAC;IAEV;AACF;AACA;IAFE,KAGUC,KAAK,GAAG,CAAC;IAEnB;AACF;AACA;IAFE,KAGUC,EAAE,GAAG,CAAC;IAEhB;AACF;AACA;IAFE,KAGUC,OAAO,GAAG,CAAC;IAErB;AACF;AACA;IAFE,KAGAC,SAAS;IAET;AACF;AACA;AACA;IAHE,KAIAC,cAAc,GAAG,IAAIpE,SAAS,CAAC,CAAC;IAEhC;AACF;AACA;AACA;IAHE,KAIAqE,cAAc,GAAG,IAAIrE,SAAS,CAAC,CAAC;IAEhC;AACF;AACA;IAFE,KAGA+B,OAAO;IAEP;AACF;AACA;IAFE,KAGAuC,KAAK,GAAG,QAAQ;IAEhB;AACF;AACA;IAFE,KAGAC,SAAS,GAAG,QAAQ;IAEpB;AACF;AACA;IAFE,KAGAC,aAAa,GAAG,QAAQ;IAExB;AACF;AACA;IAFE,KAGAC,iBAAiB,GAAG,QAAQ;IAAA,KAE5B7B,WAAW;IAAA,KAEXC,qBAAqB;IAErB;AACF;AACA;IAFE,KAGAJ,aAAa;IAEb;AACF;AACA;IAFE,KAGAJ,KAAK;IAEL;AACF;AACA;IAFE,KAGAqC,cAAc,GAAkB,IAAI;IAEpC;AACF;AACA;IAFE,KAGAC,QAAQ,GAAG,KAAK;IAEhB;AACF;AACA;AACA;IAHE,KAIAC,SAAS,GAAG,KAAK;IAEjB;AACF;AACA;IAFE,KAGAC,SAAS;IAET;AACF;AACA;IAFE,KAGAC,SAAS;IAAA,KAETC,cAAc,GAAqB,EAAE;IAAA,KAErCC,gBAAgB,GAGV,EAAE;IAER;AACF;AACA;AACA;IAHE,KAIQ9D,aAAa,GAAG,IAAIf,SAAS,CAAC8E,YAAY,CAAC,CAAC;IAAA,KA0KpDC,WAAW;IAEX;AACF;AACA;IAFE,KAGAC,gBAAgB;IAEhB;AACF;AACA;IAFE,KAGAC,SAAS;IAET;AACF;AACA;IAFE,KAGAC,YAAY;IAEZ;AACF;AACA;IAFE,KAGAC,0BAA0B;IAAA,KA8D1BC,MAAM,GAAG,MAAM;MAAA,IAAAC,aAAA;MACb,IAAI,CAAClD,SAAS,CAAC,CAAC;MAChB,CAAAkD,aAAA,OAAI,CAACzD,OAAO,cAAAyD,aAAA,uBAAZA,aAAA,CAAcD,MAAM,CAAC,CAAC;MACtB,IAAI,CAAC1B,QAAQ,CAAC4B,KAAK,CAAC,CAAC;IACvB,CAAC;IAED;AACF;AACA;IAFE,KAGAC,OAAO,GAAG,MAAM;MAAA,IAAAC,cAAA;MACd,IAAI,CAACf,SAAS,GAAG,IAAI;MACrB,CAAAe,cAAA,OAAI,CAAC5D,OAAO,cAAA4D,cAAA,uBAAZA,cAAA,CAAcJ,MAAM,CAAC,CAAC;MACtB,IAAI,CAACpB,SAAS,CAACyB,WAAW,CAAC,IAAI,CAACvB,cAAc,CAAC;MAC/C,IAAI,CAACA,cAAc,CAACqB,OAAO,CAAC;QAC1BG,QAAQ,EAAE,IAAI;QACdC,OAAO,EAAE,IAAI;QACbC,WAAW,EAAE;MACf,CAAC,CAAC;MACF,IAAI,CAAC3B,cAAc,CAACwB,WAAW,CAAC,IAAI,CAAC/B,QAAQ,CAAC;MAC9C,IAAI,CAACM,SAAS,CAACyB,WAAW,CAAC,IAAI,CAACxB,cAAc,CAAC;MAC/C,IAAI,CAACA,cAAc,CAACsB,OAAO,CAAC;QAC1BG,QAAQ,EAAE,IAAI;QACdC,OAAO,EAAE,IAAI;QACbC,WAAW,EAAE;MACf,CAAC,CAAC;IACJ,CAAC;IAED;AACF;AACA;IAFE,KAGArE,SAAS,GAAG,MAAM;MAChB,IAAI,IAAI,CAACkD,SAAS,EAAE;MACpB,MAAM;QACJoB,aAAa,EAAE;UAAEzE,KAAK,EAAE0E,YAAY;UAAEC,OAAO,EAAEC;QAAe,CAAC;QAC/DC,SAAS,EAAE;UAAEC,UAAU;UAAEC;QAAS,CAAC;QACnCC;MACF,CAAC,GAAGjG,SAAS,CAACkG,OAAO;MACrB,MAAMC,gBAAgB,GAAGR,YAAY,GAAGK,QAAQ;MAChD,MAAMI,eAAe,GAAGP,cAAc,GAAGG,QAAQ;MACjD,MAAMK,QAAQ,GAAGN,UAAU,GAAGK,eAAe;MAC7C,IAAI,CAAC3C,MAAM,GAAG,CAAC,IAAI,CAACxC,KAAK,GAAGkF,gBAAgB,IAAIE,QAAQ;MACxD,IAAI,IAAI,CAAChF,GAAG,EAAE;QACZ,IAAI,CAACqC,KAAK,GAAG,CAAC,IAAI,CAACrC,GAAG,GAAG8E,gBAAgB,IAAIE,QAAQ;MACvD;MACA,IAAI,CAAC1C,EAAE,GAAG,IAAI,CAACN,aAAa,GAAG4C,aAAa;MAC5C,IAAI,CAACrC,OAAO,GAAGqC,aAAa;MAC5B,IAAI,CAACtE,SAAS,CAAC,CAAC;IAClB,CAAC;IAAA,KAED2E,MAAM,GAAG,CAAC;MAAErF,KAAK;MAAEI;IAAoC,CAAC,KAAK;MAC3D,IAAI,IAAI,CAACiD,SAAS,EAAE;MACpB,MAAM;QACJwB,SAAS,EAAE;UAAEC,UAAU;UAAEC;QAAS;MACpC,CAAC,GAAGhG,SAAS,CAACkG,OAAO;MACrB,MAAMC,gBAAgB,GAAGlF,KAAK,GAAG+E,QAAQ;MACzC,MAAMI,eAAe,GAAG,CAAC/E,GAAG,GAAGJ,KAAK,IAAI+E,QAAQ;MAChD,MAAMK,QAAQ,GAAGN,UAAU,GAAGK,eAAe;MAC7C,IAAI,CAAC3C,MAAM,GAAG,CAAC,IAAI,CAACxC,KAAK,GAAGkF,gBAAgB,IAAIE,QAAQ;MACxD,IAAI,IAAI,CAAChF,GAAG,EAAE;QACZ,IAAI,CAACqC,KAAK,GAAG,CAAC,IAAI,CAACrC,GAAG,GAAG8E,gBAAgB,IAAIE,QAAQ;MACvD;MACA,IAAI,CAAC1E,SAAS,CAAC,CAAC;IAClB,CAAC;IAAA,KAEDD,eAAe,GAAG,MAAM;MACtB,IAAI,IAAI,CAACH,QAAQ,EAAE;QACjB,MAAM;UAAEgF,IAAI;UAAEC;QAAK,CAAC,GAAG,IAAI,CAACzB,YAAY,CAAC,IAAI,CAAC3B,QAAQ,EAAE,IAAI,CAACnC,KAAK,CAAC;QACnE,IAAI,CAACsD,SAAS,GAAGgC,IAAI;QACrB,IAAI,CAAC/B,SAAS,GAAGgC,IAAI;QACrB,MAAM;UAAE/B,cAAc;UAAEC;QAAiB,CAAC,GAAG,IAAI,CAACM,0BAA0B,CAAC,IAAI,CAAC/D,KAAK,CAAC;QACxF,IAAI,CAACwD,cAAc,GAAGA,cAAc;QACpC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;MAC1C,CAAC,MAAM;QACL,IAAI,CAACH,SAAS,GAAG1B,SAAS;QAC1B,IAAI,CAAC2B,SAAS,GAAG3B,SAAS;QAC1B,IAAI,CAAC4B,cAAc,GAAG,EAAE;QACxB,IAAI,CAACC,gBAAgB,GAAG,EAAE;MAC5B;IACF,CAAC;IAAA,KAED+B,WAAW,GAAIC,IAAc,IAAK;MAChC,MAAM;QACJZ,SAAS,EAAE;UAAEC;QAAW;MAC1B,CAAC,GAAG/F,SAAS,CAACkG,OAAO;MACrB,MAAMS,QAAQ,GAAG,CAAC,CAAC,EAAEZ,UAAU,CAAC;MAChC,MAAMa,aAAa,GAAGA,CAACL,IAAgC,EAAEC,IAAgC,KAAK;QAC5F,IAAID,IAAI,EAAE;UACRI,QAAQ,CAAC,CAAC,CAAC,GAAGE,IAAI,CAACC,GAAG,CAACH,QAAQ,CAAC,CAAC,CAAC,EAAEJ,IAAI,CAAC9C,MAAM,CAAC;QAClD;QACA,IAAI+C,IAAI,EAAE;UACRG,QAAQ,CAAC,CAAC,CAAC,GAAGE,IAAI,CAACE,GAAG,CAACJ,QAAQ,CAAC,CAAC,CAAC,EAAEH,IAAI,CAAC/C,MAAM,CAAC;QAClD;MACF,CAAC;MACD,IAAIiD,IAAI,KAAKxG,QAAQ,CAAC8G,MAAM,EAAE;QAC5BJ,aAAa,CAAC,IAAI,CAACrC,SAAS,EAAE,IAAI,CAACC,SAAS,CAAC;MAC/C,CAAC,MAAM;QACL,IAAI,CAACE,gBAAgB,CAACuC,OAAO,CAAC,CAAC;UAAEV,IAAI;UAAEC;QAAK,CAAC,KAAK;UAChDI,aAAa,CAACL,IAAI,EAAEC,IAAI,CAAC;QAC3B,CAAC,CAAC;MACJ;MACA,OAAO,IAAI,CAACrD,SAAS,KAAKlD,cAAc,CAACiH,OAAO,GAAG,CACjDP,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,EAChBA,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,CACjB,GAAG,CACFA,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EACfA,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAChB;IACH,CAAC;IAAA,KAwDDQ,gBAAgB,GAAG,CAACC,QAAgB,EAAEV,IAAc,KAAK;MACvD,MAAM,CAACK,GAAG,EAAED,GAAG,CAAC,GAAG,IAAI,CAACL,WAAW,CAACC,IAAI,CAAC;MACzC,MAAMW,CAAC,GAAG,IAAI,CAAC5D,MAAM,GAAG2D,QAAQ;MAChC,IAAK,IAAI,CAAC3D,MAAM,IAAIsD,GAAG,IAAIK,QAAQ,GAAG,CAAC,IAAMC,CAAC,IAAIP,GAAG,IAAIM,QAAQ,GAAG,CAAE,EAAE;QACtE;MACF;MACA,MAAM;QACJ1B,aAAa,EAAE;UAAEE,OAAO,EAAEC;QAAe,CAAC;QAC1CC,SAAS,EAAE;UAAEC,UAAU;UAAEC;QAAS;MACpC,CAAC,GAAGhG,SAAS,CAACkG,OAAO;MACrB,MAAMoB,YAAY,GAAIF,QAAQ,GAAGrB,UAAU,IAAKF,cAAc,GAAGG,QAAQ,CAAC;MAC1E,MAAM/E,KAAK,GAAG,IAAI,CAACA,KAAK,GAAGqG,YAAY;MACvC,IAAI,CAACrG,KAAK,GAAGA,KAAK;MAClB,IAAIyF,IAAI,KAAKxG,QAAQ,CAAC8G,MAAM,EAAE;QAC5B,IAAI,IAAI,CAACzC,SAAS,IAAI,IAAI,CAACA,SAAS,CAACpB,SAAS,KAAKlD,cAAc,CAACiH,OAAO,EAAE;UACzE,IAAI,CAAC3C,SAAS,CAAClD,GAAG,GAAGJ,KAAK;QAC5B;MACF,CAAC,MAAM;QACL,IAAI,CAACwD,cAAc,CAACwC,OAAO,CAAEM,KAAK,IAAK;UACrCA,KAAK,CAACtG,KAAK,GAAGA,KAAK;QACrB,CAAC,CAAC;QACF,IAAI,CAACyD,gBAAgB,CAACuC,OAAO,CAAC,CAAC;UAAEV;QAAK,CAAC,KAAK;UAC1C,IAAIA,IAAI,IAAIA,IAAI,CAACpD,SAAS,KAAKlD,cAAc,CAACiH,OAAO,EAAE;YACrDX,IAAI,CAAClF,GAAG,GAAGJ,KAAK;UAClB;QACF,CAAC,CAAC;MACJ;MACA,IAAI,CAAC4D,gBAAgB,CAAC5D,KAAK,CAAC;IAC9B,CAAC;IAAA,KAEDuG,oBAAoB,GAAG,MAAM;MAC3B,MAAMC,YAAiC,GAAG,IAAIC,GAAG,CAAC,CAAC;MACnDD,YAAY,CAACE,GAAG,CAAC,IAAI,CAAC;MACtB,IAAI,CAAClD,cAAc,CAACwC,OAAO,CAAEM,KAAK,IAAK;QACrCE,YAAY,CAACE,GAAG,CAACJ,KAAK,CAAC;MACzB,CAAC,CAAC;MACF,IAAI,CAAC7C,gBAAgB,CAACuC,OAAO,CAAC,CAAC;QAAEV;MAAK,CAAC,KAAK;QAC1C,IAAIA,IAAI,IAAIA,IAAI,CAACpD,SAAS,KAAKlD,cAAc,CAACiH,OAAO,EAAE;UACrDO,YAAY,CAACE,GAAG,CAACpB,IAAI,CAAC;QACxB;MACF,CAAC,CAAC;MACF,IAAI,CAACzB,SAAS,CAAC8C,KAAK,CAACC,IAAI,CAACJ,YAAY,CAAC,CAAC;IAC1C,CAAC;IAlQC,MAAM;MACJvE,EAAE;MAAEI,GAAG;MAAErC,KAAK,EAALA,MAAK;MAAEI,GAAG,EAAHA,IAAG;MAAEwC,SAAS;MAAET,QAAQ;MAAED,SAAS;MACnDE,aAAa;MAAEW,KAAK;MAAEE,aAAa;MAAEpC,IAAI;MAAEI,YAAY;MACvD0C,WAAW;MAAEC,gBAAgB;MAAEC,SAAS;MAAEC,YAAY;MAAEC;IAC1D,CAAC,GAAG/B,KAAK;IACT,IAAI,CAACC,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACI,GAAG,GAAGA,GAAG;IACd,IAAI,CAACH,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACQ,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC1C,MAAM,GAAGF,MAAK;IACnB,IAAIiB,YAAY,EAAE;MAChB,IAAI,CAACA,YAAY,GAAGA,YAAY;IAClC;IACA,IAAI,CAAC0C,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,0BAA0B,GAAGA,0BAA0B;IAE5D,IAAI,CAAClB,cAAc,CAACgE,MAAM,GAAG,EAAE;IAC/B,IAAI,CAAC/D,cAAc,CAAC+D,MAAM,GAAG,GAAG;IAChC,IAAI,CAAC/D,cAAc,CAACgE,WAAW,GAAG,KAAK;IACvC,IAAI,CAACjE,cAAc,CAACkE,QAAQ,CAAC,IAAI,CAACzE,QAAQ,CAAC;IAC3C,IAAI,CAACO,cAAc,CAACkE,QAAQ,CAAC,IAAI,CAACjE,cAAc,CAAC;IACjD,IAAI,CAACF,SAAS,CAACmE,QAAQ,CAAC,IAAI,CAAClE,cAAc,CAAC;IAC5C,IAAIzC,IAAG,EAAE;MACP,IAAI,CAACA,GAAG,GAAGA,IAAG;IAChB;IACA,IAAI2C,KAAK,EAAE;MACT,IAAI,CAACA,KAAK,GAAGA,KAAK;IACpB;IACA,IAAIE,aAAa,EAAE;MACjB,IAAI,CAACA,aAAa,GAAGA,aAAa;IACpC;IACA,IAAIpC,IAAI,EAAE;MACR,IAAI,CAACA,IAAI,GAAGA,IAAI;IAClB;IACAzB,QAAQ,CAACyC,EAAE,CAACvC,WAAW,CAAC0H,cAAc,EAAGC,KAAqC,IAAK;MACjF,IAAI,CAAC5B,MAAM,CAAC4B,KAAK,CAAC;IACpB,CAAC,CAAC;IACF,IAAI,CAAC9G,SAAS,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;EACY+G,QAAQA,CAAA,EAAG;IACnB,IAAI,CAAC1H,KAAK,CAACH,WAAW,CAAC8H,OAAO,EAAE,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EACjD;;EA+GA;AACF;AACA;;EAGE;AACF;AACA;;EAGErG,SAASA,CAAA,EAAG;IACV,IAAI,CAAC+B,cAAc,CAACuE,cAAc,CAAC,CAAC;EACtC;EAEArG,QAAQA,CAAA,EAAG;IACT,MAAMhB,KAAK,GAAG,IAAI,CAACkC,SAAS,KAAKlD,cAAc,CAACsI,MAAM,GAAG,IAAI,CAAC9E,MAAM,GAAG,CAAC,IAAI,CAACA,MAAM,GAAG,IAAI,CAACC,KAAK,IAAI,CAAC;IACrG,IAAI,IAAI,CAAC5B,IAAI,EAAE;MACb,IAAIkC,KAAK,GAAG,IAAI,CAACzC,QAAQ,GAAG,IAAI,CAAC4C,iBAAiB,GAAG,IAAI,CAACF,SAAS;MACnE,IAAI,IAAI,CAAC3B,WAAW,EAAE;QACpB0B,KAAK,GAAG,IAAI,CAAC1B,WAAW;MAC1B;MACA,MAAMkB,KAAK,GAAG,IAAI7D,IAAI,CAAC,IAAI,CAACmC,IAAI,EAAE;QAAE0G,IAAI,EAAExE,KAAK;QAAEyE,QAAQ,EAAE;MAAG,CAAC,CAAC;MAChE,MAAM;QAAEC,KAAK;QAAEC;MAAO,CAAC,GAAGnF,KAAK,CAACoF,SAAS,CAAC,CAAC;MAC3CpF,KAAK,CAACsE,MAAM,GAAG,EAAE;MACjBtE,KAAK,CAACqF,QAAQ,CAACC,GAAG,CAAC7H,KAAK,GAAGyH,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC/E,EAAE,GAAG,CAAC,IAAI,CAACC,OAAO,GAAG+E,MAAM,IAAI,CAAC,CAAC;MAC5E,IAAI,CAAC5E,cAAc,CAACiE,QAAQ,CAACxE,KAAK,CAAC;IACrC;EACF;EAEAuF,YAAYA,CAAA,EAAG;IACb,IAAI,CAAC,IAAI,CAACtH,OAAO,EAAE;MACjB,IAAI,CAACA,OAAO,GAAG,IAAI1B,UAAU,CAAC;QAC5B8D,SAAS,EAAE,IAAI,CAACC,cAAc;QAC9B+E,QAAQ,EAAE;UAAExB,CAAC,EAAE,IAAI,CAAC5D,MAAM;UAAEuF,CAAC,EAAE,IAAI,CAACrF;QAAG,CAAC;QACxCR,SAAS,EAAE,IAAI,CAACA,SAAS;QACzBwF,MAAM,EAAE,IAAI,CAAC/E,OAAO;QACpBrC,QAAQ,EAAE,IAAI,CAACC,SAAS;QACxB2F,gBAAgB,EAAE,IAAI,CAACA,gBAAgB;QACvC8B,OAAO,EAAEA,CAAA,KAAM;UACb,IAAI,CAACrE,WAAW,CAAC,IAAI,CAAC1B,EAAE,CAAC;QAC3B,CAAC;QACDsE,oBAAoB,EAAE,IAAI,CAACA;MAC7B,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,IAAI,CAAC/F,OAAO,CAACyH,IAAI,CAAC;QAChBL,QAAQ,EAAE;UAAExB,CAAC,EAAE,IAAI,CAAC5D,MAAM;UAAEuF,CAAC,EAAE,IAAI,CAACrF;QAAG,CAAC;QACxCR,SAAS,EAAE,IAAI,CAACA,SAAS;QACzBwF,MAAM,EAAE,IAAI,CAAC/E,OAAO;QACpBrC,QAAQ,EAAE,IAAI,CAACC,SAAS;QACxBwC,KAAK,EAAE,IAAI,CAAC1B;MACd,CAAC,CAAC;IACJ;EACF;AA6CF","ignoreList":[]},"metadata":{},"sourceType":"module"}