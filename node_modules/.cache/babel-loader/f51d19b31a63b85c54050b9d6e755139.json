{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/WavesurferComp/WavesurferComp.js\";\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport hexToRgba from 'hex-to-rgba';\nimport { notification } from 'antd';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { defaultColor, formatTimestamp, translate } from '../../constants';\nimport HandleIcon from '../common/Icons/HandleIcon';\nimport { debug, getWavesurfers, mergeSegmentBackward, setPlayingState, setSegmentTimestamp, splitSegmentForward, setVideoValid, setVideoZoom, deleteLine, pushLine, setLineRole, removeSegment, parseSegments, setErrorMsg, moveSegmentInBatch, updateVideoInfo, setLoading } from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { timeInterval, primaryLabelInterval, secondaryLabelInterval, formatTimeCallback } from '../utils/TimelineUtil';\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\nclass WavesurferComp extends React.Component {\n  constructor() {\n    super();\n    this.insertLine = data => {\n      // eslint-disable-next-line prefer-const\n      let {\n        start,\n        end,\n        role,\n        videoIndex,\n        segmentIndex,\n        lineIndex\n      } = data;\n      const {\n        segments\n      } = this.regions;\n      const {\n        ontology\n      } = this.props;\n      videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n      const wavesurfer = this.wavesurfers[videoIndex];\n      lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? 0 : lineIndex;\n      end = Number.isNaN(parseFloat(end)) ? wavesurfer.getDuration() : end;\n      if (!segments[videoIndex]) segments[videoIndex] = [];\n      if (!segments[videoIndex][segmentIndex]) segments[videoIndex][segmentIndex] = [];\n      role = role || 'none';\n      const color = hexToRgba(ontology.get(role) || defaultColor.defaultWhite, role === 'none' ? 0 : defaultColor.defaultAlpha);\n      const item = {\n        start,\n        end,\n        color,\n        resize: false,\n        drag: false,\n        data: {\n          type: 'line'\n        },\n        formatTimeCallback: () => ''\n      };\n      const region = wavesurfer.addRegion(item);\n      region.element.classList.add('line-region');\n      const mark = document.createElement('div');\n      mark.className = 'line-mark';\n      region.element.appendChild(mark);\n      const title = document.createElement('div');\n      title.className = 'line-title';\n      title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(region.end - region.start).toFixed(3)}s (${formatTimestamp(region.start)}~${formatTimestamp(region.end)})` : '';\n      mark.appendChild(title);\n      region.title = title;\n      region.role = role;\n      segments[videoIndex][segmentIndex].splice(lineIndex, 0, region);\n      segments[videoIndex][segmentIndex].forEach((line, index, array) => {\n        const height = 100 / array.length;\n        const top = height * index;\n        line.element.style.height = `${height}%`;\n        line.element.style.top = `${top}%`;\n      });\n      return region;\n    };\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null,\n      // Minimap container\n      waveform: null,\n      // Waveform container\n      timeline: null,\n      // Timeline container\n      audioContainer: null,\n      // Cursor container\n      videoContainer: null // Video container\n    };\n    this.regions = {\n      segments: [],\n      anchors: []\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      segments: null,\n      anchors: null,\n      segmentSelected: null,\n      anchorSelected: null,\n      undoList: null,\n      redoList: null,\n      undoLock: false,\n      redoLock: false\n    };\n    this.state = {\n      cursorTime: 0 // seconds\n    };\n  }\n  shouldComponentUpdate(nextProps) {\n    return nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n  componentDidUpdate() {\n    this.initWaveSurfer();\n  }\n  addHistory(type, data) {\n    const {\n      undoList,\n      undoLock,\n      redoLock,\n      redoList\n    } = this.current;\n    let recallList;\n    if (undoLock) recallList = redoList;else if (redoLock) recallList = undoList;else {\n      recallList = undoList;\n      this.current.redoList = [];\n    }\n    if (type === 'trimAnchor' && recallList.length) {\n      const prev = recallList[recallList.length - 1];\n      if (prev.type === 'trimAnchor' && prev.data.trimAnchor === data.trimAnchor) return;\n    }\n    recallList.push({\n      type,\n      data\n    });\n    if (recallList.length > 50) recallList.shift();\n  }\n  recallHistory(action) {\n    const {\n      undoList,\n      redoList,\n      anchors\n    } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) return;\n    if (action === 'undo') this.current.undoLock = true; // lock\n    if (action === 'redo') this.current.redoLock = true;\n    const recallItem = recallList.pop();\n    const {\n      type,\n      data\n    } = recallItem;\n    switch (type) {\n      case 'singleLination-recall':\n        this.singleLination(data.sec); // addHistory inside\n        break;\n      case 'doubleLination-recall':\n        this.doubleLination(data.start, data.end); // addHistory inside\n        break;\n      case 'singleLination-adjust':\n        {\n          const {\n            nearbyAnchorIndex,\n            prevStart\n          } = data;\n          const nearbyAnchor = anchors[nearbyAnchorIndex];\n          const sec = nearbyAnchor.start;\n          nearbyAnchor.update({\n            start: prevStart\n          });\n          this.handleAnchorDrag(nearbyAnchor);\n          this.addHistory('singleLination-recall', {\n            sec\n          });\n        }\n        break;\n      case 'singleLination-split':\n        {\n          const {\n            splitAnchorIndex\n          } = data;\n          const splitAnchor = anchors[splitAnchorIndex];\n          const sec = splitAnchor.start;\n          this.mergeSegment(splitAnchor);\n          this.addHistory('singleLination-recall', {\n            sec\n          });\n        }\n        break;\n      case 'doubleLination-adjust-adjust':\n        {\n          const {\n            nearbyLeftAnchorIndex,\n            prevLeftStart,\n            nearbyRightAnchorIndex,\n            prevRightStart\n          } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const {\n            start\n          } = nearbyLeftAnchor;\n          const end = nearbyRightAnchor.start;\n          nearbyLeftAnchor.update({\n            start: prevLeftStart\n          });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          nearbyRightAnchor.update({\n            start: prevRightStart\n          });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'doubleLination-adjust-split':\n        {\n          const {\n            nearbyLeftAnchorIndex,\n            prevLeftStart,\n            splitRightAnchorIndex\n          } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const {\n            start\n          } = nearbyLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          nearbyLeftAnchor.update({\n            start: prevLeftStart\n          });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'doubleLination-split-adjust':\n        {\n          const {\n            splitLeftAnchorIndex,\n            nearbyRightAnchorIndex,\n            prevRightStart\n          } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const {\n            start\n          } = splitLeftAnchor.start;\n          const end = nearbyRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          nearbyRightAnchor.update({\n            start: prevRightStart\n          });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'doubleLination-split-split':\n        {\n          const {\n            splitLeftAnchorIndex,\n            splitRightAnchorIndex\n          } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const {\n            start\n          } = splitLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'pushLine':\n        this.props.deleteLine(data); // addHistory inside\n        break;\n      case 'deleteLine':\n        this.props.pushLine(data); // addHistory inside\n        break;\n      case 'dragAnchor':\n        {\n          const {\n            dragAnchorIndex,\n            prevStart\n          } = data;\n          const dragAnchor = anchors[dragAnchorIndex];\n          const {\n            start\n          } = dragAnchor;\n          dragAnchor.update({\n            start: prevStart\n          });\n          this.handleAnchorDrag(dragAnchor);\n          this.addHistory('dragAnchor', {\n            dragAnchorIndex,\n            prevStart: start\n          });\n        }\n        break;\n      case 'trimAnchor':\n        {\n          const {\n            trimAnchorIndex,\n            prevStart\n          } = data;\n          const trimAnchor = anchors[trimAnchorIndex];\n          const {\n            start\n          } = trimAnchor;\n          trimAnchor.update({\n            start: prevStart\n          });\n          this.handleAnchorDrag(trimAnchor);\n          this.addHistory('trimAnchor', {\n            trimAnchorIndex,\n            prevStart: start\n          });\n        }\n        break;\n      case 'mergeSegment':\n        {\n          const {\n            mergeSec,\n            prevRules,\n            nextRules\n          } = data;\n          const splitSegment = this.getSegmentByTime(mergeSec);\n          this.splitSegment(splitSegment, mergeSec, prevRules, nextRules);\n        }\n        break;\n      case 'setLineColor':\n        this.props.setLineRole(data); // addHistory inside\n        break;\n      case 'bulkMovement':\n        {\n          const {\n            step\n          } = data;\n          const bulkMovementDirection = action === 'redo' ? 1 : -1;\n          this.moveRegionsInBatch(bulkMovementDirection * step);\n          this.addHistory('bulkMovement', {\n            step: -bulkMovementDirection * step\n          });\n          break;\n        }\n      default:\n        break;\n    }\n    if (action === 'undo') this.current.undoLock = false; // lock\n    if (action === 'redo') this.current.redoLock = false;\n  }\n\n  // Called after currentVideo change\n  setNewVideo() {\n    const {\n      videoIndex\n    } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.segments = this.regions.segments[videoIndex];\n    this.current.anchors = this.regions.anchors[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n  setCurrentVideo(newVideoIndex) {\n    const {\n      videoIndex\n    } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.removeSelectedSegment();\n    this.removeSelectedAnchor();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n  removeSelectedAnchor() {\n    const {\n      anchorSelected\n    } = this.current;\n    if (!anchorSelected) return;\n    anchorSelected.mark.classList.remove('anchor-mark-selected');\n    this.current.anchorSelected = null;\n  }\n  setCurrentZoom(newZoom) {\n    if (newZoom) this.current.zoom = newZoom;\n    const {\n      zoom,\n      videoIndex,\n      wavesurfer\n    } = this.current;\n    const duration = this.wavesurfers[videoIndex].getDuration();\n    const cursorTime = this.getCursorTime();\n    const currentTime = wavesurfer.getCurrentTime();\n    const {\n      offsetWidth\n    } = wavesurfer.container;\n    const {\n      offsetLeft\n    } = wavesurfer.cursor.cursor;\n    const totalWidth = offsetWidth * zoom;\n    const pxPerSec = totalWidth / duration;\n    wavesurfer.zoom(pxPerSec);\n    this.setCurrentScroll(cursorTime < 0 ? currentTime : cursorTime, cursorTime < 0 ? offsetWidth / 2 : offsetLeft, false);\n  }\n  componentDidMount() {\n    // Record currentTime and locate currentCursor\n    setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const {\n        wavesurfer\n      } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n  }\n  componentWillUnmount() {\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach(c => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n  setCurrentScroll(destTime, offsetLeft, boundaryCheck) {\n    offsetLeft = offsetLeft || 0;\n    destTime = destTime || 0;\n    const {\n      wavesurfer\n    } = this.current;\n    const {\n      scrollLeft\n    } = wavesurfer.container.lastChild;\n    const {\n      offsetWidth\n    } = wavesurfer.container;\n    const {\n      minPxPerSec\n    } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) wavesurfer.drawer.recenter(scrollTime / duration);else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) wavesurfer.drawer.recenter(scrollTime / duration);\n    }\n  }\n  insertSegment(data) {\n    const {\n      start,\n      end,\n      segmentIndex\n    } = data;\n    let {\n      videoIndex\n    } = data;\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    const {\n      segments\n    } = this.regions;\n    if (!segments[videoIndex]) segments[videoIndex] = [];\n    segments[videoIndex].splice(segmentIndex, 0, []);\n    this.insertLine({\n      start,\n      end,\n      videoIndex,\n      segmentIndex\n    });\n    return segments[videoIndex][segmentIndex];\n  }\n  insertTempAnchor(data) {\n    const {\n      segmentSelected\n    } = this.current;\n    const {\n      start,\n      end\n    } = data;\n    const items = [{\n      start,\n      resize: false,\n      drag: true,\n      data: {\n        type: 'tempAnchor',\n        prevStart: start\n      },\n      formatTimeCallback: () => ''\n    }, {\n      start: end,\n      resize: false,\n      drag: true,\n      data: {\n        type: 'tempAnchor',\n        prevStart: end\n      }\n    }];\n    const {\n      wavesurfer\n    } = this.current;\n    const regions = new Array(2);\n    regions[0] = wavesurfer.addRegion(items[0]);\n    regions[1] = wavesurfer.addRegion(items[1]);\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.leftTempAnchor = regions[0];\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.rightTempAnchor = regions[1];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const region of regions) {\n      region.element.classList.add('anchor-region');\n      const handle = document.createElement('div');\n      handle.className = 'anchor-handle';\n      ReactDOM.render(/*#__PURE__*/React.createElement(HandleIcon, {\n        style: {\n          height: '100%',\n          width: '100%'\n        },\n        viewBox: \"0, 10, 16, 16\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 411,\n          columnNumber: 24\n        }\n      }), handle);\n      region.element.appendChild(handle);\n      region.hanlde = handle;\n      const mark = document.createElement('div');\n      mark.className = 'anchor-mark-temp';\n      region.element.appendChild(mark);\n      region.mark = mark;\n    }\n  }\n  insertAnchor(data) {\n    // eslint-disable-next-line prefer-const\n    let {\n      start,\n      videoIndex,\n      segmentIndex\n    } = data;\n    const {\n      toolMode\n    } = this.props;\n    const {\n      anchors\n    } = this.regions;\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    if (segmentIndex === 0) return;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const item = {\n      start,\n      resize: false,\n      drag: !isAnnotationReadonly(toolMode),\n      // toolMode !== 'QA_RO',\n      data: {\n        type: 'anchor',\n        prevStart: start\n      },\n      formatTimeCallback: () => ''\n    };\n    const region = wavesurfer.addRegion(item);\n    anchors[videoIndex].splice(segmentIndex - 1, 0, region);\n    region.element.classList.add('anchor-region');\n    const handle = document.createElement('div');\n    handle.className = 'anchor-handle';\n    if (isAnnotationReadonly(toolMode)) handle.classList.add('anchor-handle-lock');\n    ReactDOM.render(/*#__PURE__*/React.createElement(HandleIcon, {\n      style: {\n        height: '100%',\n        width: '100%'\n      },\n      viewBox: \"0, 10, 16, 16\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 445,\n        columnNumber: 22\n      }\n    }), handle);\n    region.element.appendChild(handle);\n    region.hanlde = handle;\n    const mark = document.createElement('div');\n    mark.className = 'anchor-mark';\n    region.element.appendChild(mark);\n    region.mark = mark;\n    return region;\n  }\n  removeSelectedSegment() {\n    const {\n      segmentSelected,\n      anchorSelected\n    } = this.current;\n    if (anchorSelected && anchorSelected.data.type === 'tempAnchor') this.removeSelectedAnchor();\n    if (segmentSelected && segmentSelected.data.type === 'temp') {\n      segmentSelected.remove();\n      if (segmentSelected.leftTempAnchor) segmentSelected.leftTempAnchor.remove();\n      if (segmentSelected.rightTempAnchor) segmentSelected.rightTempAnchor.remove();\n    }\n    this.current.segmentSelected = null;\n  }\n  setSelectedSegment(region) {\n    this.removeSelectedSegment();\n    if (region.data.type === 'line') this.current.wavesurfer.frame.update({\n      start: region.start,\n      end: region.end\n    });\n    this.current.segmentSelected = region;\n  }\n  setCurrentSegment(currentSegment, start) {\n    const {\n      currentPlayMode\n    } = this.props;\n    const {\n      wavesurfer\n    } = this.current;\n    const region = this.current.segments[currentSegment][0];\n    start = start || region.start;\n    this.setSelectedSegment(region);\n    this.seekCurrentAudio(start);\n    this.setCurrentScroll(start, 0, true);\n    if (currentPlayMode !== 'overallLoop') {\n      wavesurfer.play();\n    }\n  }\n  setLineColor(videoIndex, segmentIndex, lineIndex, role) {\n    try {\n      const line = this.regions.segments[videoIndex][segmentIndex][lineIndex];\n      const prevRole = line.role;\n      line.update({\n        color: hexToRgba(this.props.ontology.get(role), role === 'none' ? 0 : defaultColor.defaultAlpha)\n      });\n      line.role = role;\n      this.addHistory('setLineColor', {\n        videoIndex,\n        segmentIndex,\n        lineIndex,\n        role: prevRole\n      });\n    } catch (e) {\n      console.error('Line region not found');\n    }\n  }\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) this.initWaveSurfer();\n  }\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) this.initWaveSurfer();\n  }\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n  playVideo() {\n    const {\n      wavesurfer,\n      segmentSelected\n    } = this.current;\n    if (segmentSelected && wavesurfer.getCurrentTime() > segmentSelected.end - ANCHOR_MOVEMENT_STEP) {\n      this.seekCurrentAudio(segmentSelected.start);\n      this.setCurrentScroll(segmentSelected.start, 0, true);\n    }\n    wavesurfer.play();\n  }\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n  parseSegments(videoIndex) {\n    const {\n      results,\n      ontology,\n      lineConfig,\n      keyAttribute,\n      segmentConfig\n    } = this.props;\n    const segments = results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map(value => value.name);\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map(value => value.name);\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start\n      if (!segment.start && segment.start !== 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_NULL')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end === null || segment.end === undefined) {\n        segment.end = duration;\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      if (!segment.attributes) segment.attributes = {};\n      Object.keys(segment.attributes).forEach(key => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = line.attributes || {};\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach(key => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n    }\n    // segments = segments.filter(segment => segment.isValid);\n    const MIN_LENGTH = this.props.minSegmentLength;\n    segments.sort((a, b) => {\n      if (a.start < b.start + MIN_LENGTH && a.start > b.start - MIN_LENGTH) {\n        if (a.end == null) return -1;\n        if (b.end == null) return 1;\n        return a.end - b.end;\n      }\n      return a.start - b.start;\n    });\n    let currentEnd = 0;\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      if (segment.end - segment.start <= MIN_LENGTH && i < segments.length - 1) {\n        segments[i + 1].start = segment.start;\n        segments.splice(i, 1);\n        i -= 1;\n      } else if (segment.start > currentEnd - MIN_LENGTH && segment.start < currentEnd + MIN_LENGTH && (segment.end > currentEnd || !segment.end)) {\n        segments[i].start = currentEnd;\n        currentEnd = segment.end;\n      } else if (segment.start < currentEnd - MIN_LENGTH || currentEnd == null) {\n        // throw new Error(`${translate('PAYLOAD_ERROR_OVERLAP_SEGMENT')} ${JSON.stringify(segment)} start=${segment.start} currentEnd=${currentEnd} min=${MIN_LENGTH}`);\n        segments.splice(i, 1);\n        i -= 1;\n      } else if (segment.start > currentEnd + MIN_LENGTH) {\n        segments.splice(i, 0, createSegment(currentEnd, segment.start, segmentConfig, lineConfig));\n        currentEnd = segment.end;\n        i += 1;\n      }\n      if (i === segments.length - 1) {\n        if (segment.end < duration) {\n          if (duration - segment.end <= MIN_LENGTH) {\n            segment.end = duration;\n          } else {\n            segments.push(createSegment(segment.end, duration, segmentConfig, lineConfig));\n          }\n        }\n      }\n    }\n    // videoIndex, segments\n    this.props.parseSegments({\n      videoIndex,\n      segments\n    });\n    return segments;\n  }\n  initRegion(videoIndex, segments) {\n    const wavesurfer = this.wavesurfers[videoIndex];\n    wavesurfer.frame = wavesurfer.addRegion({\n      start: segments[0].start,\n      end: segments[0].end,\n      color: 'rgba(0,0,0,0)',\n      resize: false,\n      drag: false\n    });\n    wavesurfer.frame.element.classList.add('segment-frame');\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      segment.content.forEach((line, lineIndex) => {\n        this.insertLine({\n          videoIndex,\n          segmentIndex,\n          lineIndex,\n          role: line.role,\n          start: segment.start,\n          end: segment.end\n        });\n      });\n      this.insertAnchor({\n        videoIndex,\n        segmentIndex,\n        start: segment.start\n      });\n    }\n  }\n  getSegmentByRegion(region) {\n    let segmentIndex = -1;\n    const {\n      segments\n    } = this.current;\n    segments.forEach((segment, index) => {\n      if (segment.indexOf(region) >= 0) segmentIndex = index;\n    });\n    return segmentIndex;\n  }\n  seekCurrentAudio(currentTime = 0) {\n    const {\n      wavesurfer\n    } = this.current;\n    const duration = wavesurfer.getDuration();\n    /*\n    currentTime = currentTime || 0;\n    let rate = currentTime / duration;\n    if (rate > 1) rate = 1;\n    if (rate < 0) rate = 0;\n    wavesurfer.seekTo(rate);\n    */\n    // Skip function wavesurfer.seekTo(progress), use wavesurfer.backend.seekTo(time) instead.\n    // Fireevent seek will be ignored\n    if (currentTime < 0) currentTime = 0;\n    if (currentTime > duration) currentTime = duration;\n    wavesurfer.backend.seekTo(currentTime);\n  }\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const {\n      currentPlayMode\n    } = this.props;\n    if (region.data.type === 'temp') {\n      this.setCurrentScroll(region.start, 0, true);\n      region.play();\n    } else if (region.data.type === 'line') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const cursorTime = this.getCursorTime();\n      const start = cursorTime > 0 && (e.altKey || e.ctrlKey) || currentPlayMode === 'overallLoop' ? cursorTime : null;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({\n        index: segmentIndex,\n        start\n      });\n    } else if (region.data.type === 'anchor' || region.data.type === 'tempAnchor') {\n      const {\n        anchorSelected\n      } = this.current;\n      if (region !== anchorSelected) this.setSelectedAnchor(region);else this.removeSelectedAnchor();\n    }\n  }\n  setSelectedAnchor(region) {\n    this.removeSelectedAnchor();\n    region.mark.classList.add('anchor-mark-selected');\n    this.current.anchorSelected = region;\n  }\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n  setCurrentSpeed(speed) {\n    this.current.wavesurfer.setPlaybackRate(speed);\n  }\n  resetRegionTitle() {\n    const {\n      segments\n    } = this.current;\n    segments.forEach((segment, segmentIndex) => {\n      segment.forEach((line, lineIndex) => {\n        line.title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(line.end - line.start).toFixed(3)} [${formatTimestamp(line.start)}~${formatTimestamp(line.end)}]` : '';\n      });\n    });\n  }\n  moveRegionsInBatch(step) {\n    const {\n      wavesurfer,\n      anchors,\n      segmentSelected\n    } = this.current;\n    const min = 0;\n    const max = wavesurfer.getDuration();\n    Object.keys(wavesurfer.regions.list).forEach(id => {\n      const region = wavesurfer.regions.list[id];\n      if (region.data.type !== 'line') {\n        return;\n      }\n      this.__moveRegion(region, step, min, max);\n      if (segmentSelected === region) {\n        wavesurfer.frame.update({\n          start: region.start,\n          end: region.end\n        });\n      }\n    });\n    anchors.forEach(anchor => {\n      this.__moveRegion(anchor, step, min, max);\n    });\n    this.props.moveSegmentInBatch({\n      step,\n      min,\n      max\n    });\n    this.resetRegionTitle();\n  }\n  __moveRegion(region, step, min, max) {\n    if (region.start > min || region.end < max) {\n      if (region.start > min) {\n        region.start = region.start + step < min ? min : region.start + step;\n      }\n      if (region.end < max) {\n        region.end = region.end + step > max ? max : region.end + step;\n      }\n      region.update({\n        start: region.start,\n        end: region.end\n      });\n    }\n  }\n  handleAnchorDrag(region) {\n    const {\n      wavesurfer,\n      anchors,\n      segments,\n      segmentSelected\n    } = this.current;\n    const {\n      minSegmentLength,\n      toolMode\n    } = this.props;\n    const i = anchors.indexOf(region);\n    if (i < 0) return false;\n    const leftBoundary = i === 0 ? 0 : anchors[i - 1].start;\n    const rightBoundary = i === anchors.length - 1 ? wavesurfer.getDuration() : anchors[i + 1].start;\n    if (region.start < rightBoundary - minSegmentLength && region.start > leftBoundary + minSegmentLength && !isAnnotationReadonly(toolMode)) {\n      region.data.prevStart = region.start;\n      const prevSegment = segments[i];\n      const nextSegment = segments[i + 1];\n      prevSegment.forEach(line => {\n        line.update({\n          end: region.start\n        });\n      });\n      nextSegment.forEach(line => {\n        line.update({\n          start: region.start\n        });\n      });\n      this.props.setSegmentTimestamp({\n        segmentIndex: i,\n        end: region.start\n      });\n      this.props.setSegmentTimestamp({\n        segmentIndex: i + 1,\n        start: region.start\n      });\n      this.resetRegionTitle();\n      if (segmentSelected === prevSegment[0]) {\n        wavesurfer.frame.update({\n          start: prevSegment[0].start,\n          end: prevSegment[0].end\n        });\n      }\n      if (segmentSelected === nextSegment[0]) {\n        wavesurfer.frame.update({\n          start: nextSegment[0].start,\n          end: nextSegment[0].end\n        });\n      }\n      return true;\n    }\n    region.update({\n      start: region.data.prevStart,\n      end: region.data.prevStart\n    });\n    return false;\n  }\n  handleRegionUpdate(region, e) {\n    const {\n      type\n    } = region.data;\n    const {\n      segmentSelected\n    } = this.current;\n    if (type === 'temp' && region !== segmentSelected) {\n      this.setSelectedSegment(region);\n      region.element.classList.add('line-region');\n    }\n  }\n  handleRegionEdit(region) {\n    const {\n      type\n    } = region.data;\n    const {\n      wavesurfer\n    } = this.current;\n    if (type === 'temp') {\n      if (region.end - region.start < this.props.minSegmentLength || this.props.currentPlayMode === 'overallLoop') {\n        this.removeSelectedSegment();\n      } else {\n        region.play();\n        this.insertTempAnchor({\n          start: region.start,\n          end: region.end\n        });\n        wavesurfer.frame.update({\n          start: region.start,\n          end: region.end\n        });\n      }\n    } else if (type === 'anchor') {\n      const {\n        prevStart\n      } = region.data;\n      const {\n        anchors\n      } = this.current;\n      const result = this.handleAnchorDrag(region);\n      if (result === false) return;\n      const dragAnchorIndex = anchors.indexOf(region);\n      this.addHistory('dragAnchor', {\n        dragAnchorIndex,\n        prevStart\n      });\n      this.setSelectedAnchor(region);\n    } else if (type === 'tempAnchor') {\n      this.setTempSegment();\n    }\n  }\n  setTempSegment() {\n    const {\n      segmentSelected,\n      wavesurfer\n    } = this.current;\n    const {\n      leftTempAnchor,\n      rightTempAnchor\n    } = segmentSelected;\n    if (leftTempAnchor.start > rightTempAnchor.start - this.props.minSegmentLength) {\n      leftTempAnchor.update({\n        start: leftTempAnchor.data.prevStart\n      });\n      rightTempAnchor.update({\n        start: rightTempAnchor.data.prevStart\n      });\n    } else {\n      leftTempAnchor.data.prevStart = leftTempAnchor.start;\n      rightTempAnchor.data.prevStart = rightTempAnchor.start;\n      segmentSelected.update({\n        start: leftTempAnchor.start,\n        end: rightTempAnchor.start\n      });\n      wavesurfer.frame.update({\n        start: segmentSelected.start,\n        end: segmentSelected.end\n      });\n    }\n  }\n  handleRegionOut(region) {\n    const {\n      currentPlayMode\n    } = this.props;\n    const {\n      segmentSelected,\n      wavesurfer\n    } = this.current;\n    const {\n      type\n    } = region.data;\n    if (type !== 'line' && type !== 'temp') return;\n    if (segmentSelected === region && currentPlayMode === 'regionLoop') {\n      this.seekCurrentAudio(region.start);\n      this.setCurrentScroll(region.start, 0, true);\n    } else if (segmentSelected === region && currentPlayMode === 'regionPlay') {\n      wavesurfer.pause();\n      this.seekCurrentAudio(region.end);\n    }\n  }\n  handlePlayPause() {\n    this.props.setPlayingState({\n      isPlaying: this.current.wavesurfer.isPlaying()\n    });\n  }\n  handleRegionContextmenu(region, e) {\n    e.preventDefault();\n    if (region.data.type === 'anchor') {\n      const {\n        anchors,\n        segments\n      } = this.current;\n      const i = anchors.indexOf(region);\n      const nextSegment = segments[i + 1];\n      const prevSegment = segments[i];\n      const nextRules = [];\n      const prevRules = [];\n      prevSegment.forEach((line, index) => {\n        prevRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i,\n          lineIndex: index\n        });\n      });\n      nextSegment.forEach((line, index) => {\n        nextRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i + 1,\n          lineIndex: index\n        });\n      });\n      this.mergeSegment(region);\n      const mergeSec = region.start;\n      this.addHistory('mergeSegment', {\n        mergeSec,\n        prevRules,\n        nextRules\n      });\n    }\n  }\n  mergeSegment(region) {\n    const {\n      anchors,\n      segments,\n      anchorSelected,\n      segmentSelected,\n      wavesurfer\n    } = this.current;\n    const i = anchors.indexOf(region);\n    const nextSegment = segments[i + 1];\n    const prevSegment = segments[i];\n    const {\n      start\n    } = prevSegment[0];\n    const {\n      end\n    } = nextSegment[0];\n    const prevRules = [];\n    if (anchorSelected === region) this.removeSelectedAnchor();\n    region.remove();\n    anchors.splice(i, 1);\n    this.props.setSegmentTimestamp({\n      segmentIndex: i,\n      end\n    });\n    prevSegment.forEach((line, index) => {\n      prevRules.push(line.role);\n      line.update({\n        end\n      });\n    });\n    this.props.setCurrentSegment({\n      index: i\n    });\n    this.props.mergeSegmentBackward({\n      segmentIndex: i + 1\n    });\n    nextSegment.forEach(line => {\n      if (prevRules.indexOf(line.role) < 0 && line.role !== 'none') {\n        this.insertLine({\n          start,\n          end,\n          role: line.role,\n          segmentIndex: i,\n          lineIndex: prevSegment.length\n        });\n      }\n      line.remove();\n    });\n    segments.splice(i + 1, 1);\n    if (segmentSelected === prevSegment[0]) {\n      wavesurfer.frame.update({\n        start: prevSegment[0].start,\n        end: prevSegment[0].end\n      });\n    }\n    this.resetRegionTitle();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  setPlayMode(mode) {\n    // none\n  }\n  checkNearbyAnchor(sec) {\n    const {\n      anchors\n    } = this.current;\n    const {\n      minSegmentLength\n    } = this.props;\n    let invalidAnchor = null;\n    let minDistance = null;\n    anchors.forEach(value => {\n      const distance = Math.abs(value.start - sec);\n      if (distance < minSegmentLength) {\n        if (!invalidAnchor || minDistance > distance) {\n          invalidAnchor = value;\n          minDistance = distance;\n        }\n      }\n    });\n    return invalidAnchor;\n  }\n  singleLination(sec) {\n    const {\n      minSegmentLength,\n      disableSegment,\n      annotateDisabled\n    } = this.props;\n    const {\n      wavesurfer,\n      anchors\n    } = this.current;\n    if (sec < minSegmentLength || disableSegment || annotateDisabled) return;\n    if (sec > wavesurfer.getDuration() - minSegmentLength) return;\n    const nearbyAnchor = this.checkNearbyAnchor(sec);\n    if (nearbyAnchor) {\n      const prevStart = nearbyAnchor.start;\n      nearbyAnchor.update({\n        start: sec\n      });\n      this.handleAnchorDrag(nearbyAnchor);\n      const nearbyAnchorIndex = anchors.indexOf(nearbyAnchor);\n      this.addHistory('singleLination-adjust', {\n        nearbyAnchorIndex,\n        prevStart\n      });\n    } else {\n      const splitSegment = this.getSegmentByTime(sec);\n      const splitAnchor = this.splitSegment(splitSegment, sec);\n      const splitAnchorIndex = anchors.indexOf(splitAnchor);\n      this.addHistory('singleLination-split', {\n        splitAnchorIndex\n      });\n    }\n  }\n  getSegmentByTime(sec) {\n    const {\n      segments\n    } = this.current;\n    // eslint-disable-next-line no-restricted-syntax\n    for (const value of segments) {\n      const line = value[0];\n      if (line.start <= sec && line.end >= sec) return value;\n    }\n    return null;\n  }\n  splitSegment(segment, sec, prevRules, nextRules, focusPrevSegment) {\n    const {\n      segments,\n      anchors\n    } = this.current;\n    if (!segment) return;\n    const {\n      end\n    } = segment[0];\n    const i = segments.indexOf(segment);\n    const anchor = this.insertAnchor({\n      start: sec,\n      segmentIndex: i + 1\n    });\n    this.insertSegment({\n      start: sec,\n      end,\n      segmentIndex: i + 1\n    });\n    segment.forEach(line => {\n      line.update({\n        end: sec\n      });\n    });\n    if (prevRules && nextRules) {\n      const arr = [];\n      prevRules.forEach(rule => {\n        arr.push(rule.role);\n      });\n      segment.forEach((line, index) => {\n        if (arr.indexOf(line.role) < 0) this.deleteLine({\n          lineIndex: index,\n          segmentIndex: i\n        });\n      });\n      this.deleteLine({\n        lineIndex: 0,\n        segmentIndex: i + 1\n      });\n      nextRules.forEach(role => {\n        this.insertLine(role);\n      });\n      const splitAnchorIndex = anchors.indexOf(anchor);\n      this.addHistory('singleLination-split', {\n        splitAnchorIndex\n      });\n    }\n    this.props.setSegmentTimestamp({\n      segmentIndex: i,\n      end: sec\n    });\n    this.props.splitSegmentForward({\n      segmentIndex: i,\n      start: sec,\n      end,\n      prevRules,\n      nextRules\n    });\n    this.removeSelectedSegment();\n    this.resetRegionTitle();\n    this.props.setCurrentSegment({\n      index: focusPrevSegment ? i : i + 1\n    });\n    return anchor;\n  }\n  deleteLine(data) {\n    const {\n      segments\n    } = this.current;\n    const {\n      segmentIndex,\n      lineIndex\n    } = data;\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    data.start = line.start;\n    data.end = line.end;\n    data.role = line.role;\n    line.remove();\n    segment.splice(lineIndex, 1);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n  toppingLine(data) {\n    const {\n      segments\n    } = this.current;\n    const {\n      segmentIndex,\n      lineIndex\n    } = data;\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    segment.splice(lineIndex, 1);\n    segment.unshift(line);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n  doubleLination(start, end) {\n    const {\n      minSegmentLength,\n      disableSegment,\n      annotateDisabled\n    } = this.props;\n    const {\n      anchors,\n      segmentSelected\n    } = this.current;\n    if (!start || Number.isNaN(start)) start = segmentSelected.start;\n    if (!end || Number.isNaN(end)) end = segmentSelected.end;\n    if (end - start <= minSegmentLength || disableSegment || annotateDisabled) return;\n    const nearbyLeftAnchor = this.checkNearbyAnchor(start);\n    const nearbyRightAnchor = this.checkNearbyAnchor(end);\n    const prevLeftStart = nearbyLeftAnchor ? nearbyLeftAnchor.start : -1;\n    const prevRightStart = nearbyRightAnchor ? nearbyRightAnchor.start : -1;\n    if (start < minSegmentLength) return;\n    if (end > this.current.wavesurfer.getDuration() - minSegmentLength) return;\n    if (nearbyLeftAnchor && nearbyRightAnchor) {\n      nearbyLeftAnchor.update({\n        start\n      });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      nearbyRightAnchor.update({\n        start: end\n      });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-adjust-adjust', {\n        nearbyLeftAnchorIndex,\n        prevLeftStart,\n        nearbyRightAnchorIndex,\n        prevRightStart\n      });\n    } else if (!nearbyLeftAnchor && nearbyRightAnchor) {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      nearbyRightAnchor.update({\n        start: end\n      });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-split-adjust', {\n        splitLeftAnchorIndex,\n        nearbyRightAnchorIndex,\n        prevRightStart\n      });\n    } else if (nearbyLeftAnchor && !nearbyRightAnchor) {\n      nearbyLeftAnchor.update({\n        start\n      });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      this.addHistory('doubleLination-adjust-split', {\n        nearbyLeftAnchorIndex,\n        prevLeftStart,\n        splitRightAnchorIndex\n      });\n    } else {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end, null, null, true);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      this.addHistory('doubleLination-split-split', {\n        splitLeftAnchorIndex,\n        splitRightAnchorIndex\n      });\n    }\n  }\n  handleKeyDown(e) {\n    if (window.disableLongAudioHotKeys) return;\n    if (isInput()) return;\n    if (isAnnotationReadonly(this.props.toolMode)) return;\n    // if (this.props.toolMode === 'QA_RO') return;\n    if (e.key.toUpperCase() === 'S') {\n      const sec = this.getCursorTime();\n      if (sec < 0) return;\n      this.singleLination(sec);\n    } else if (e.key.toUpperCase() === 'D') {\n      const {\n        segmentSelected\n      } = this.current;\n      if (segmentSelected && segmentSelected.data.type === 'temp') this.doubleLination();\n    } else if (e.key === ',' || e.key === '<') {\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(-ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', {\n          step: -ANCHOR_MOVEMENT_STEP\n        });\n      } else {\n        this.forwardAnchor();\n      }\n    } else if (e.key === '.' || e.key === '>') {\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', {\n          step: ANCHOR_MOVEMENT_STEP\n        });\n      } else {\n        this.backwardAnchor();\n      }\n    } else if (e.ctrlKey && e.key.toUpperCase() === 'Z') {\n      this.recallHistory('undo');\n    } else if (e.ctrlKey && e.key.toUpperCase() === 'Y') {\n      this.recallHistory('redo');\n    }\n  }\n  backwardAnchor() {\n    const {\n      anchorSelected,\n      wavesurfer,\n      anchors\n    } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start + ANCHOR_MOVEMENT_STEP >= wavesurfer.getDuration()) return;\n    anchorSelected.update({\n      start: anchorSelected.start + ANCHOR_MOVEMENT_STEP\n    });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', {\n        trimAnchorIndex,\n        prevStart: anchorSelected.start - ANCHOR_MOVEMENT_STEP\n      });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n  forwardAnchor() {\n    const {\n      anchorSelected,\n      anchors\n    } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start - ANCHOR_MOVEMENT_STEP <= 0) return;\n    anchorSelected.update({\n      start: anchorSelected.start - ANCHOR_MOVEMENT_STEP\n    });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', {\n        trimAnchorIndex,\n        prevStart: anchorSelected.start + ANCHOR_MOVEMENT_STEP\n      });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n  handleRegionIn(region) {\n    const {\n      currentPlayMode,\n      currentSegment\n    } = this.props;\n    const {\n      wavesurfer\n    } = this.current;\n    const {\n      type\n    } = region.data;\n    if (type !== 'line') return;\n    if (currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const currentTime = wavesurfer.getCurrentTime();\n      if (segmentIndex === currentSegment) return;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({\n        index: segmentIndex,\n        start: currentTime\n      });\n    }\n  }\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          // partialRender: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [RegionsPlugin.create(), CursorPlugin.create({\n            width: '1px',\n            height: '10px',\n            container: this.container.audioContainer[i],\n            color: defaultColor.defaultGreen,\n            showTime: true,\n            opacity: 1,\n            customShowTimeStyle: {\n              color: defaultColor.defaultGreen,\n              fontSize: '14px',\n              paddingLeft: '5px',\n              position: 'absolute',\n              bottom: '3px'\n            },\n            formatTimeCallback: sec => {\n              this.setState({\n                cursorTime: sec\n              });\n              return formatTimestamp(sec);\n            }\n          }), TimelinePlugin.create({\n            container: this.container.timeline[i],\n            primaryFontColor: defaultColor.defaultWhite,\n            secondaryFontColor: defaultColor.defaultWhite,\n            primaryColor: defaultColor.defaultWhite,\n            secondaryColor: defaultColor.defaultWhite,\n            fontSize: '10',\n            notchPercentHeight: 30,\n            timeInterval,\n            primaryLabelInterval,\n            secondaryLabelInterval,\n            formatTimeCallback\n          }), MinimapPlugin.create({\n            container: this.container.minimap[i]\n          })]\n        });\n        urls[i] = this.container.videoContainer[i];\n        this.wavesurfers[i].on('ready', () => {\n          this.props.setLoading(false);\n          this.wavesurfers[i].pause();\n          this.wavesurfers[i].enableDragSelection({\n            color: hexToRgba(defaultColor.defaultRed, defaultColor.defaultAlpha),\n            drag: false,\n            resize: false,\n            data: {\n              type: 'temp'\n            },\n            formatTimeCallback: () => ''\n          });\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            console.log('Error', e);\n            this.props.setErrorMsg({\n              errorMsg: e === null || e === void 0 ? void 0 : e.toString()\n            });\n            return;\n          }\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (!i) {\n            this.setNewVideo();\n            this.setSelectedSegment(this.current.segments[0][0]);\n          }\n          if (i === 0) this.addWindowEvent();\n          this.wavesurfers[i].on('play', e => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', e => this.handlePlayPause());\n          this.wavesurfers[i].on('region-updated', (region, e) => this.handleRegionUpdate(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (region, e) => this.handleRegionContextmenu(region, e));\n          this.wavesurfers[i].on('region-update-end', (region, e) => this.handleRegionEdit(region));\n          this.wavesurfers[i].on('region-out', (region, e) => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', (region, e) => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.props.setVideoValid({\n            index: i\n          });\n          this.props.updateVideoInfo({\n            index: i,\n            duration: this.wavesurfers[i].getDuration()\n          });\n        });\n        this.wavesurfers[i].on('error', () => {\n          notification.error({\n            message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}`\n          });\n          console.log('error', urls[i].src);\n          if (i !== size - 1) this.wavesurfers[i].load(urls[i]);\n          if (i === 0) this.addWindowEvent();\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.wavesurfers[i].destroy();\n        });\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const {\n          zoom,\n          wavesurfer\n        } = this.current;\n        if (!cursorHelper) {\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer.cursor.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const {\n          offsetWidth\n        } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = totalWidth / duration * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n  addWindowEvent() {\n    window.addEventListener('keydown', e => this.handleKeyDown(e));\n    window.addEventListener('resize', e => this.setCurrentZoom());\n  }\n\n  // eslint-disable-next-line react/no-deprecated\n  componentWillMount() {\n    this.props.getWavesurfers({\n      wavesurfers: this\n    });\n  }\n  render() {\n    return null;\n  }\n}\nconst mapStateToProps = state => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  keyAttribute: state.keyAttribute,\n  disableSegment: state.disableSegment,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw\n});\nconst mapDispatchToProps = {\n  debug,\n  getWavesurfers,\n  setPlayingState,\n  setSegmentTimestamp,\n  mergeSegmentBackward,\n  splitSegmentForward,\n  setVideoValid,\n  setVideoZoom,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  removeSegment,\n  parseSegments,\n  setErrorMsg,\n  moveSegmentInBatch,\n  updateVideoInfo,\n  setLoading\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(WavesurferComp);","map":{"version":3,"names":["React","ReactDOM","hexToRgba","notification","WaveSurfer","TimelinePlugin","RegionsPlugin","CursorPlugin","MinimapPlugin","connect","v4","uuid","defaultColor","formatTimestamp","translate","HandleIcon","debug","getWavesurfers","mergeSegmentBackward","setPlayingState","setSegmentTimestamp","splitSegmentForward","setVideoValid","setVideoZoom","deleteLine","pushLine","setLineRole","removeSegment","parseSegments","setErrorMsg","moveSegmentInBatch","updateVideoInfo","setLoading","createLine","createSegment","isInput","isAnnotationReadonly","timeInterval","primaryLabelInterval","secondaryLabelInterval","formatTimeCallback","ANCHOR_MOVEMENT_STEP","WavesurferComp","Component","constructor","insertLine","data","start","end","role","videoIndex","segmentIndex","lineIndex","segments","regions","ontology","props","Number","isNaN","parseInt","current","wavesurfer","wavesurfers","parseFloat","getDuration","color","get","defaultWhite","defaultAlpha","item","resize","drag","type","region","addRegion","element","classList","add","mark","document","createElement","className","appendChild","title","innerText","toFixed","splice","forEach","line","index","array","height","length","top","style","undoList","redoList","container","minimap","waveform","timeline","audioContainer","videoContainer","anchors","zoom","segmentSelected","anchorSelected","undoLock","redoLock","state","cursorTime","shouldComponentUpdate","nextProps","isLoadedAlaw","componentDidUpdate","initWaveSurfer","addHistory","recallList","prev","trimAnchor","push","shift","recallHistory","action","recallItem","pop","singleLination","sec","doubleLination","nearbyAnchorIndex","prevStart","nearbyAnchor","update","handleAnchorDrag","splitAnchorIndex","splitAnchor","mergeSegment","nearbyLeftAnchorIndex","prevLeftStart","nearbyRightAnchorIndex","prevRightStart","nearbyLeftAnchor","nearbyRightAnchor","splitRightAnchorIndex","splitRightAnchor","splitLeftAnchorIndex","splitLeftAnchor","dragAnchorIndex","dragAnchor","trimAnchorIndex","mergeSec","prevRules","nextRules","splitSegment","getSegmentByTime","step","bulkMovementDirection","moveRegionsInBatch","setNewVideo","isDestroyed","console","error","videos","setCurrentZoom","setCurrentVideo","newVideoIndex","pause","removeSelectedSegment","removeSelectedAnchor","remove","newZoom","duration","getCursorTime","currentTime","getCurrentTime","offsetWidth","offsetLeft","cursor","totalWidth","pxPerSec","setCurrentScroll","componentDidMount","setInterval","isPlaying","timestamp","componentWillUnmount","Array","isArray","c","removeEventListener","updateMeasurement","destTime","boundaryCheck","scrollLeft","lastChild","minPxPerSec","params","scrollTime","drawer","recenter","rightBoundaryTime","leftBoundaryTime","insertSegment","insertTempAnchor","items","leftTempAnchor","rightTempAnchor","handle","render","width","viewBox","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","hanlde","insertAnchor","toolMode","setSelectedSegment","frame","setCurrentSegment","currentSegment","currentPlayMode","seekCurrentAudio","play","setLineColor","prevRole","e","getAudioContainer","getVideoContainer","pauseVideo","playVideo","forwardVideo","skipForward","backwardVideo","skipBackward","results","lineConfig","keyAttribute","segmentConfig","segmentConfigValidKeys","fields","map","value","name","lineConfigValidKeys","ontologyValidKeys","key","i","segment","startNum","Error","JSON","stringify","endNum","id","undefined","log","attributes","Object","keys","indexOf","content","arr","MIN_LENGTH","minSegmentLength","sort","a","b","currentEnd","initRegion","getSegmentByRegion","backend","seekTo","handleRegionClick","stopPropagation","altKey","ctrlKey","setSelectedAnchor","setCurrentSpeed","speed","setPlaybackRate","resetRegionTitle","min","max","list","__moveRegion","anchor","leftBoundary","rightBoundary","prevSegment","nextSegment","handleRegionUpdate","handleRegionEdit","result","setTempSegment","handleRegionOut","handlePlayPause","handleRegionContextmenu","preventDefault","setPlayMode","mode","checkNearbyAnchor","invalidAnchor","minDistance","distance","Math","abs","disableSegment","annotateDisabled","focusPrevSegment","rule","li","toppingLine","unshift","splitLeftSegment","splitRightSegment","handleKeyDown","window","disableLongAudioHotKeys","toUpperCase","forwardAnchor","backwardAnchor","handleRegionIn","initMiniMap","wave","getElementsByTagName","size","urls","loaded","create","autoCenter","normalize","loopSelection","scrollParent","backgroundColor","defaultGray","waveColor","darkGray","progressColor","cursorColor","defaultRed","pixelRatio","maxCanvasWidth","plugins","defaultGreen","showTime","opacity","customShowTimeStyle","fontSize","paddingLeft","position","bottom","setState","primaryFontColor","secondaryFontColor","primaryColor","secondaryColor","notchPercentHeight","on","enableDragSelection","errorMsg","toString","addWindowEvent","un","message","src","load","destroy","addEventListener","cursorHelper","getElementsByClassName","selectedMeasurement","left","componentWillMount","mapStateToProps","currentVideo","spaceLine","mapDispatchToProps"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/WavesurferComp/WavesurferComp.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport hexToRgba from 'hex-to-rgba';\nimport { notification } from 'antd';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { defaultColor, formatTimestamp, translate } from '../../constants';\nimport HandleIcon from '../common/Icons/HandleIcon';\nimport {\n  debug,\n  getWavesurfers,\n  mergeSegmentBackward,\n  setPlayingState,\n  setSegmentTimestamp,\n  splitSegmentForward,\n  setVideoValid,\n  setVideoZoom,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  removeSegment,\n  parseSegments,\n  setErrorMsg,\n  moveSegmentInBatch,\n  updateVideoInfo,\n  setLoading,\n} from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { timeInterval, primaryLabelInterval, secondaryLabelInterval, formatTimeCallback } from '../utils/TimelineUtil';\n\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\n\nclass WavesurferComp extends React.Component {\n  constructor() {\n    super();\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null, // Minimap container\n      waveform: null, // Waveform container\n      timeline: null, // Timeline container\n      audioContainer: null, // Cursor container\n      videoContainer: null, // Video container\n    };\n    this.regions = {\n      segments: [],\n      anchors: [],\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      segments: null,\n      anchors: null,\n      segmentSelected: null,\n      anchorSelected: null,\n      undoList: null,\n      redoList: null,\n      undoLock: false,\n      redoLock: false,\n    };\n    this.state = {\n      cursorTime: 0, // seconds\n    };\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n\n  componentDidUpdate() {\n    this.initWaveSurfer();\n  }\n\n  addHistory(type, data) {\n    const { undoList, undoLock, redoLock, redoList } = this.current;\n    let recallList;\n    if (undoLock) recallList = redoList;\n    else if (redoLock) recallList = undoList;\n    else {\n      recallList = undoList;\n      this.current.redoList = [];\n    }\n    if (type === 'trimAnchor' && recallList.length) {\n      const prev = recallList[recallList.length - 1];\n      if (prev.type === 'trimAnchor' && prev.data.trimAnchor === data.trimAnchor) return;\n    }\n    recallList.push({ type, data });\n    if (recallList.length > 50) recallList.shift();\n  }\n\n  recallHistory(action) {\n    const { undoList, redoList, anchors } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) return;\n    if (action === 'undo') this.current.undoLock = true; // lock\n    if (action === 'redo') this.current.redoLock = true;\n    const recallItem = recallList.pop();\n    const { type, data } = recallItem;\n    switch (type) {\n      case 'singleLination-recall':\n        this.singleLination(data.sec); // addHistory inside\n        break;\n      case 'doubleLination-recall':\n        this.doubleLination(data.start, data.end); // addHistory inside\n        break;\n      case 'singleLination-adjust':\n        {\n          const { nearbyAnchorIndex, prevStart } = data;\n          const nearbyAnchor = anchors[nearbyAnchorIndex];\n          const sec = nearbyAnchor.start;\n          nearbyAnchor.update({ start: prevStart });\n          this.handleAnchorDrag(nearbyAnchor);\n          this.addHistory('singleLination-recall', { sec });\n        }\n        break;\n      case 'singleLination-split':\n        {\n          const { splitAnchorIndex } = data;\n          const splitAnchor = anchors[splitAnchorIndex];\n          const sec = splitAnchor.start;\n          this.mergeSegment(splitAnchor);\n          this.addHistory('singleLination-recall', { sec });\n        }\n        break;\n      case 'doubleLination-adjust-adjust':\n        {\n          const { nearbyLeftAnchorIndex, prevLeftStart, nearbyRightAnchorIndex, prevRightStart } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const { start } = nearbyLeftAnchor;\n          const end = nearbyRightAnchor.start;\n          nearbyLeftAnchor.update({ start: prevLeftStart });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          nearbyRightAnchor.update({ start: prevRightStart });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'doubleLination-adjust-split':\n        {\n          const { nearbyLeftAnchorIndex, prevLeftStart, splitRightAnchorIndex } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const { start } = nearbyLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          nearbyLeftAnchor.update({ start: prevLeftStart });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'doubleLination-split-adjust':\n        {\n          const { splitLeftAnchorIndex, nearbyRightAnchorIndex, prevRightStart } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const { start } = splitLeftAnchor.start;\n          const end = nearbyRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          nearbyRightAnchor.update({ start: prevRightStart });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'doubleLination-split-split':\n        {\n          const { splitLeftAnchorIndex, splitRightAnchorIndex } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const { start } = splitLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'pushLine':\n        this.props.deleteLine(data); // addHistory inside\n        break;\n      case 'deleteLine':\n        this.props.pushLine(data); // addHistory inside\n        break;\n      case 'dragAnchor':\n        {\n          const { dragAnchorIndex, prevStart } = data;\n          const dragAnchor = anchors[dragAnchorIndex];\n          const { start } = dragAnchor;\n          dragAnchor.update({ start: prevStart });\n          this.handleAnchorDrag(dragAnchor);\n          this.addHistory('dragAnchor', { dragAnchorIndex, prevStart: start });\n        }\n        break;\n      case 'trimAnchor':\n        {\n          const { trimAnchorIndex, prevStart } = data;\n          const trimAnchor = anchors[trimAnchorIndex];\n          const { start } = trimAnchor;\n          trimAnchor.update({ start: prevStart });\n          this.handleAnchorDrag(trimAnchor);\n          this.addHistory('trimAnchor', { trimAnchorIndex, prevStart: start });\n        }\n        break;\n      case 'mergeSegment':\n        {\n          const { mergeSec, prevRules, nextRules } = data;\n          const splitSegment = this.getSegmentByTime(mergeSec);\n          this.splitSegment(splitSegment, mergeSec, prevRules, nextRules);\n        }\n        break;\n      case 'setLineColor':\n        this.props.setLineRole(data); // addHistory inside\n        break;\n      case 'bulkMovement': {\n        const { step } = data;\n        const bulkMovementDirection = action === 'redo' ? 1 : -1;\n        this.moveRegionsInBatch(bulkMovementDirection * step);\n        this.addHistory('bulkMovement', { step: -bulkMovementDirection * step });\n        break;\n      }\n      default:\n        break;\n    }\n    if (action === 'undo') this.current.undoLock = false; // lock\n    if (action === 'redo') this.current.redoLock = false;\n  }\n\n  // Called after currentVideo change\n  setNewVideo() {\n    const { videoIndex } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.segments = this.regions.segments[videoIndex];\n    this.current.anchors = this.regions.anchors[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n\n  setCurrentVideo(newVideoIndex) {\n    const { videoIndex } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.removeSelectedSegment();\n    this.removeSelectedAnchor();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n\n  removeSelectedAnchor() {\n    const { anchorSelected } = this.current;\n    if (!anchorSelected) return;\n    anchorSelected.mark.classList.remove('anchor-mark-selected');\n    this.current.anchorSelected = null;\n  }\n\n  setCurrentZoom(newZoom) {\n    if (newZoom) this.current.zoom = newZoom;\n    const { zoom, videoIndex, wavesurfer } = this.current;\n    const duration = this.wavesurfers[videoIndex].getDuration();\n    const cursorTime = this.getCursorTime();\n    const currentTime = wavesurfer.getCurrentTime();\n    const { offsetWidth } = wavesurfer.container;\n    const { offsetLeft } = wavesurfer.cursor.cursor;\n    const totalWidth = offsetWidth * zoom;\n    const pxPerSec = totalWidth / duration;\n    wavesurfer.zoom(pxPerSec);\n    this.setCurrentScroll(\n      cursorTime < 0 ? currentTime : cursorTime,\n      cursorTime < 0 ? offsetWidth / 2 : offsetLeft,\n      false,\n    );\n  }\n\n  componentDidMount() {\n    // Record currentTime and locate currentCursor\n    setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const { wavesurfer } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n  }\n\n  componentWillUnmount() {\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach((c) => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n\n  setCurrentScroll(destTime, offsetLeft, boundaryCheck) {\n    offsetLeft = offsetLeft || 0;\n    destTime = destTime || 0;\n    const { wavesurfer } = this.current;\n    const { scrollLeft } = wavesurfer.container.lastChild;\n    const { offsetWidth } = wavesurfer.container;\n    const { minPxPerSec } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) wavesurfer.drawer.recenter(scrollTime / duration);\n    else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) wavesurfer.drawer.recenter(scrollTime / duration);\n    }\n  }\n\n  insertLine = (data) => {\n    // eslint-disable-next-line prefer-const\n    let { start, end, role, videoIndex, segmentIndex, lineIndex } = data;\n    const { segments } = this.regions;\n    const { ontology } = this.props;\n\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    const wavesurfer = this.wavesurfers[videoIndex];\n    lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? 0 : lineIndex;\n    end = Number.isNaN(parseFloat(end)) ? wavesurfer.getDuration() : end;\n    if (!segments[videoIndex]) segments[videoIndex] = [];\n    if (!segments[videoIndex][segmentIndex]) segments[videoIndex][segmentIndex] = [];\n    role = role || 'none';\n    const color = hexToRgba(ontology.get(role) || defaultColor.defaultWhite, role === 'none' ? 0 : defaultColor.defaultAlpha);\n    const item = {\n      start,\n      end,\n      color,\n      resize: false,\n      drag: false,\n      data: { type: 'line' },\n      formatTimeCallback: () => '',\n    };\n    const region = wavesurfer.addRegion(item);\n    region.element.classList.add('line-region');\n    const mark = document.createElement('div');\n    mark.className = 'line-mark';\n    region.element.appendChild(mark);\n    const title = document.createElement('div');\n    title.className = 'line-title';\n    title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(region.end - region.start).toFixed(3)}s (${formatTimestamp(region.start)}~${formatTimestamp(region.end)})` : '';\n    mark.appendChild(title);\n    region.title = title;\n    region.role = role;\n    segments[videoIndex][segmentIndex].splice(lineIndex, 0, region);\n    segments[videoIndex][segmentIndex].forEach((line, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      line.element.style.height = `${height}%`;\n      line.element.style.top = `${top}%`;\n    });\n    return region;\n  };\n\n  insertSegment(data) {\n    const { start, end, segmentIndex } = data;\n    let { videoIndex } = data;\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    const { segments } = this.regions;\n    if (!segments[videoIndex]) segments[videoIndex] = [];\n    segments[videoIndex].splice(segmentIndex, 0, []);\n    this.insertLine({ start, end, videoIndex, segmentIndex });\n    return segments[videoIndex][segmentIndex];\n  }\n\n  insertTempAnchor(data) {\n    const { segmentSelected } = this.current;\n    const { start, end } = data;\n    const items = [{\n      start,\n      resize: false,\n      drag: true,\n      data: { type: 'tempAnchor', prevStart: start },\n      formatTimeCallback: () => '',\n    }, {\n      start: end,\n      resize: false,\n      drag: true,\n      data: { type: 'tempAnchor', prevStart: end },\n    }];\n    const { wavesurfer } = this.current;\n    const regions = new Array(2);\n    regions[0] = wavesurfer.addRegion(items[0]);\n    regions[1] = wavesurfer.addRegion(items[1]);\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.leftTempAnchor = regions[0];\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.rightTempAnchor = regions[1];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const region of regions) {\n      region.element.classList.add('anchor-region');\n      const handle = document.createElement('div');\n      handle.className = 'anchor-handle';\n      ReactDOM.render((<HandleIcon style={{ height: '100%', width: '100%' }} viewBox=\"0, 10, 16, 16\" />), handle);\n      region.element.appendChild(handle);\n      region.hanlde = handle;\n      const mark = document.createElement('div');\n      mark.className = 'anchor-mark-temp';\n      region.element.appendChild(mark);\n      region.mark = mark;\n    }\n  }\n\n  insertAnchor(data) {\n    // eslint-disable-next-line prefer-const\n    let { start, videoIndex, segmentIndex } = data;\n    const { toolMode } = this.props;\n    const { anchors } = this.regions;\n\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    if (segmentIndex === 0) return;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const item = {\n      start,\n      resize: false,\n      drag: !isAnnotationReadonly(toolMode), // toolMode !== 'QA_RO',\n      data: { type: 'anchor', prevStart: start },\n      formatTimeCallback: () => '',\n    };\n    const region = wavesurfer.addRegion(item);\n    anchors[videoIndex].splice(segmentIndex - 1, 0, region);\n    region.element.classList.add('anchor-region');\n    const handle = document.createElement('div');\n    handle.className = 'anchor-handle';\n    if (isAnnotationReadonly(toolMode)) handle.classList.add('anchor-handle-lock');\n    ReactDOM.render((<HandleIcon style={{ height: '100%', width: '100%' }} viewBox=\"0, 10, 16, 16\" />), handle);\n    region.element.appendChild(handle);\n    region.hanlde = handle;\n    const mark = document.createElement('div');\n    mark.className = 'anchor-mark';\n    region.element.appendChild(mark);\n    region.mark = mark;\n    return region;\n  }\n\n  removeSelectedSegment() {\n    const { segmentSelected, anchorSelected } = this.current;\n    if (anchorSelected && anchorSelected.data.type === 'tempAnchor') this.removeSelectedAnchor();\n    if (segmentSelected && segmentSelected.data.type === 'temp') {\n      segmentSelected.remove();\n      if (segmentSelected.leftTempAnchor) segmentSelected.leftTempAnchor.remove();\n      if (segmentSelected.rightTempAnchor) segmentSelected.rightTempAnchor.remove();\n    }\n    this.current.segmentSelected = null;\n  }\n\n  setSelectedSegment(region) {\n    this.removeSelectedSegment();\n    if (region.data.type === 'line') this.current.wavesurfer.frame.update({ start: region.start, end: region.end });\n    this.current.segmentSelected = region;\n  }\n\n  setCurrentSegment(currentSegment, start) {\n    const { currentPlayMode } = this.props;\n    const { wavesurfer } = this.current;\n    const region = this.current.segments[currentSegment][0];\n    start = start || region.start;\n    this.setSelectedSegment(region);\n    this.seekCurrentAudio(start);\n    this.setCurrentScroll(start, 0, true);\n    if (currentPlayMode !== 'overallLoop') {\n      wavesurfer.play();\n    }\n  }\n\n  setLineColor(videoIndex, segmentIndex, lineIndex, role) {\n    try {\n      const line = this.regions.segments[videoIndex][segmentIndex][lineIndex];\n      const prevRole = line.role;\n      line.update({ color: hexToRgba(this.props.ontology.get(role), role === 'none' ? 0 : defaultColor.defaultAlpha) });\n      line.role = role;\n      this.addHistory('setLineColor', { videoIndex, segmentIndex, lineIndex, role: prevRole });\n    } catch (e) { console.error('Line region not found'); }\n  }\n\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) this.initWaveSurfer();\n  }\n\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) this.initWaveSurfer();\n  }\n\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n\n  playVideo() {\n    const { wavesurfer, segmentSelected } = this.current;\n    if (segmentSelected && wavesurfer.getCurrentTime() > segmentSelected.end - ANCHOR_MOVEMENT_STEP) {\n      this.seekCurrentAudio(segmentSelected.start);\n      this.setCurrentScroll(segmentSelected.start, 0, true);\n    }\n    wavesurfer.play();\n  }\n\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n\n  parseSegments(videoIndex) {\n    const { results, ontology, lineConfig, keyAttribute, segmentConfig } = this.props;\n    const segments = results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map((value) => value.name);\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map((value) => value.name);\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start\n      if (!segment.start && segment.start !== 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_NULL')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end === null || segment.end === undefined) {\n        segment.end = duration;\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      if (!segment.attributes) segment.attributes = {};\n      Object.keys(segment.attributes).forEach((key) => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = line.attributes || {};\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach((key) => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n    }\n    // segments = segments.filter(segment => segment.isValid);\n    const MIN_LENGTH = this.props.minSegmentLength;\n    segments.sort((a, b) => {\n      if (a.start < b.start + MIN_LENGTH && a.start > b.start - MIN_LENGTH) {\n        if (a.end == null) return -1;\n        if (b.end == null) return 1;\n        return a.end - b.end;\n      }\n      return a.start - b.start;\n    });\n    let currentEnd = 0;\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      if (segment.end - segment.start <= MIN_LENGTH && i < segments.length - 1) {\n        segments[i + 1].start = segment.start;\n        segments.splice(i, 1);\n        i -= 1;\n      } else if ((segment.start > currentEnd - MIN_LENGTH) && (segment.start < currentEnd + MIN_LENGTH) && (segment.end > currentEnd || !segment.end)) {\n        segments[i].start = currentEnd;\n        currentEnd = segment.end;\n      } else if (segment.start < currentEnd - MIN_LENGTH || currentEnd == null) {\n        // throw new Error(`${translate('PAYLOAD_ERROR_OVERLAP_SEGMENT')} ${JSON.stringify(segment)} start=${segment.start} currentEnd=${currentEnd} min=${MIN_LENGTH}`);\n        segments.splice(i, 1);\n        i -= 1;\n      } else if (segment.start > currentEnd + MIN_LENGTH) {\n        segments.splice(i, 0, createSegment(currentEnd, segment.start, segmentConfig, lineConfig));\n        currentEnd = segment.end;\n        i += 1;\n      }\n      if (i === segments.length - 1) {\n        if (segment.end < duration) {\n          if (duration - segment.end <= MIN_LENGTH) {\n            segment.end = duration;\n          } else {\n            segments.push(createSegment(segment.end, duration, segmentConfig, lineConfig));\n          }\n        }\n      }\n    }\n    // videoIndex, segments\n    this.props.parseSegments({\n      videoIndex,\n      segments,\n    });\n    return segments;\n  }\n\n  initRegion(videoIndex, segments) {\n    const wavesurfer = this.wavesurfers[videoIndex];\n    wavesurfer.frame = wavesurfer.addRegion({\n      start: segments[0].start,\n      end: segments[0].end,\n      color: 'rgba(0,0,0,0)',\n      resize: false,\n      drag: false,\n    });\n    wavesurfer.frame.element.classList.add('segment-frame');\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      segment.content.forEach((line, lineIndex) => {\n        this.insertLine({\n          videoIndex,\n          segmentIndex,\n          lineIndex,\n          role: line.role,\n          start: segment.start,\n          end: segment.end,\n        });\n      });\n      this.insertAnchor({\n        videoIndex,\n        segmentIndex,\n        start: segment.start,\n      });\n    }\n  }\n\n  getSegmentByRegion(region) {\n    let segmentIndex = -1;\n    const { segments } = this.current;\n    segments.forEach((segment, index) => {\n      if (segment.indexOf(region) >= 0) segmentIndex = index;\n    });\n    return segmentIndex;\n  }\n\n  seekCurrentAudio(currentTime = 0) {\n    const { wavesurfer } = this.current;\n    const duration = wavesurfer.getDuration();\n    /*\n    currentTime = currentTime || 0;\n    let rate = currentTime / duration;\n    if (rate > 1) rate = 1;\n    if (rate < 0) rate = 0;\n    wavesurfer.seekTo(rate);\n    */\n    // Skip function wavesurfer.seekTo(progress), use wavesurfer.backend.seekTo(time) instead.\n    // Fireevent seek will be ignored\n    if (currentTime < 0) currentTime = 0;\n    if (currentTime > duration) currentTime = duration;\n    wavesurfer.backend.seekTo(currentTime);\n  }\n\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const { currentPlayMode } = this.props;\n    if (region.data.type === 'temp') {\n      this.setCurrentScroll(region.start, 0, true);\n      region.play();\n    } else if (region.data.type === 'line') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const cursorTime = this.getCursorTime();\n      const start = ((cursorTime > 0 && (e.altKey || e.ctrlKey)) || currentPlayMode === 'overallLoop') ? cursorTime : null;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({ index: segmentIndex, start });\n    } else if (region.data.type === 'anchor' || region.data.type === 'tempAnchor') {\n      const { anchorSelected } = this.current;\n      if (region !== anchorSelected) this.setSelectedAnchor(region);\n      else this.removeSelectedAnchor();\n    }\n  }\n\n  setSelectedAnchor(region) {\n    this.removeSelectedAnchor();\n    region.mark.classList.add('anchor-mark-selected');\n    this.current.anchorSelected = region;\n  }\n\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n\n  setCurrentSpeed(speed) {\n    this.current.wavesurfer.setPlaybackRate(speed);\n  }\n\n  resetRegionTitle() {\n    const { segments } = this.current;\n    segments.forEach((segment, segmentIndex) => {\n      segment.forEach((line, lineIndex) => {\n        line.title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(line.end - line.start).toFixed(3)} [${formatTimestamp(line.start)}~${formatTimestamp(line.end)}]` : '';\n      });\n    });\n  }\n\n  moveRegionsInBatch(step) {\n    const { wavesurfer, anchors, segmentSelected } = this.current;\n    const min = 0;\n    const max = wavesurfer.getDuration();\n    Object.keys(wavesurfer.regions.list).forEach((id) => {\n      const region = wavesurfer.regions.list[id];\n      if (region.data.type !== 'line') {\n        return;\n      }\n      this.__moveRegion(region, step, min, max);\n      if (segmentSelected === region) { wavesurfer.frame.update({ start: region.start, end: region.end }); }\n    });\n    anchors.forEach((anchor) => {\n      this.__moveRegion(anchor, step, min, max);\n    });\n    this.props.moveSegmentInBatch({ step, min, max });\n    this.resetRegionTitle();\n  }\n\n  __moveRegion(region, step, min, max) {\n    if (region.start > min || region.end < max) {\n      if (region.start > min) {\n        region.start = region.start + step < min ? min : region.start + step;\n      }\n      if (region.end < max) {\n        region.end = region.end + step > max ? max : region.end + step;\n      }\n      region.update({ start: region.start, end: region.end });\n    }\n  }\n\n  handleAnchorDrag(region) {\n    const { wavesurfer, anchors, segments, segmentSelected } = this.current;\n    const { minSegmentLength, toolMode } = this.props;\n    const i = anchors.indexOf(region);\n    if (i < 0) return false;\n    const leftBoundary = (i === 0) ? 0 : anchors[i - 1].start;\n    const rightBoundary = (i === anchors.length - 1) ? wavesurfer.getDuration() : anchors[i + 1].start;\n    if (region.start < rightBoundary - minSegmentLength && region.start > leftBoundary + minSegmentLength && !isAnnotationReadonly(toolMode)) {\n      region.data.prevStart = region.start;\n      const prevSegment = segments[i];\n      const nextSegment = segments[i + 1];\n      prevSegment.forEach((line) => {\n        line.update({ end: region.start });\n      });\n      nextSegment.forEach((line) => {\n        line.update({ start: region.start });\n      });\n      this.props.setSegmentTimestamp({ segmentIndex: i, end: region.start });\n      this.props.setSegmentTimestamp({ segmentIndex: i + 1, start: region.start });\n      this.resetRegionTitle();\n      if (segmentSelected === prevSegment[0]) { wavesurfer.frame.update({ start: prevSegment[0].start, end: prevSegment[0].end }); }\n      if (segmentSelected === nextSegment[0]) { wavesurfer.frame.update({ start: nextSegment[0].start, end: nextSegment[0].end }); }\n      return true;\n    }\n    region.update({ start: region.data.prevStart, end: region.data.prevStart });\n    return false;\n  }\n\n  handleRegionUpdate(region, e) {\n    const { type } = region.data;\n    const { segmentSelected } = this.current;\n    if (type === 'temp' && region !== segmentSelected) {\n      this.setSelectedSegment(region);\n      region.element.classList.add('line-region');\n    }\n  }\n\n  handleRegionEdit(region) {\n    const { type } = region.data;\n    const { wavesurfer } = this.current;\n    if (type === 'temp') {\n      if ((region.end - region.start < this.props.minSegmentLength) || this.props.currentPlayMode === 'overallLoop') {\n        this.removeSelectedSegment();\n      } else {\n        region.play();\n        this.insertTempAnchor({ start: region.start, end: region.end });\n        wavesurfer.frame.update({ start: region.start, end: region.end });\n      }\n    } else if (type === 'anchor') {\n      const { prevStart } = region.data;\n      const { anchors } = this.current;\n      const result = this.handleAnchorDrag(region);\n      if (result === false) return;\n      const dragAnchorIndex = anchors.indexOf(region);\n      this.addHistory('dragAnchor', { dragAnchorIndex, prevStart });\n      this.setSelectedAnchor(region);\n    } else if (type === 'tempAnchor') {\n      this.setTempSegment();\n    }\n  }\n\n  setTempSegment() {\n    const { segmentSelected, wavesurfer } = this.current;\n    const { leftTempAnchor, rightTempAnchor } = segmentSelected;\n    if (leftTempAnchor.start > rightTempAnchor.start - this.props.minSegmentLength) {\n      leftTempAnchor.update({ start: leftTempAnchor.data.prevStart });\n      rightTempAnchor.update({ start: rightTempAnchor.data.prevStart });\n    } else {\n      leftTempAnchor.data.prevStart = leftTempAnchor.start;\n      rightTempAnchor.data.prevStart = rightTempAnchor.start;\n      segmentSelected.update({ start: leftTempAnchor.start, end: rightTempAnchor.start });\n      wavesurfer.frame.update({ start: segmentSelected.start, end: segmentSelected.end });\n    }\n  }\n\n  handleRegionOut(region) {\n    const { currentPlayMode } = this.props;\n    const { segmentSelected, wavesurfer } = this.current;\n    const { type } = region.data;\n    if (type !== 'line' && type !== 'temp') return;\n    if (segmentSelected === region && currentPlayMode === 'regionLoop') {\n      this.seekCurrentAudio(region.start);\n      this.setCurrentScroll(region.start, 0, true);\n    } else if (segmentSelected === region && currentPlayMode === 'regionPlay') {\n      wavesurfer.pause();\n      this.seekCurrentAudio(region.end);\n    }\n  }\n\n  handlePlayPause() {\n    this.props.setPlayingState({ isPlaying: this.current.wavesurfer.isPlaying() });\n  }\n\n  handleRegionContextmenu(region, e) {\n    e.preventDefault();\n    if (region.data.type === 'anchor') {\n      const { anchors, segments } = this.current;\n      const i = anchors.indexOf(region);\n      const nextSegment = segments[i + 1];\n      const prevSegment = segments[i];\n      const nextRules = [];\n      const prevRules = [];\n      prevSegment.forEach((line, index) => {\n        prevRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i,\n          lineIndex: index,\n        });\n      });\n      nextSegment.forEach((line, index) => {\n        nextRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i + 1,\n          lineIndex: index,\n        });\n      });\n      this.mergeSegment(region);\n      const mergeSec = region.start;\n      this.addHistory('mergeSegment', { mergeSec, prevRules, nextRules });\n    }\n  }\n\n  mergeSegment(region) {\n    const { anchors, segments, anchorSelected, segmentSelected, wavesurfer } = this.current;\n    const i = anchors.indexOf(region);\n    const nextSegment = segments[i + 1];\n    const prevSegment = segments[i];\n    const { start } = prevSegment[0];\n    const { end } = nextSegment[0];\n    const prevRules = [];\n    if (anchorSelected === region) this.removeSelectedAnchor();\n    region.remove();\n    anchors.splice(i, 1);\n    this.props.setSegmentTimestamp({ segmentIndex: i, end });\n    prevSegment.forEach((line, index) => {\n      prevRules.push(line.role);\n      line.update({ end });\n    });\n    this.props.setCurrentSegment({ index: i });\n    this.props.mergeSegmentBackward({ segmentIndex: i + 1 });\n    nextSegment.forEach((line) => {\n      if (prevRules.indexOf(line.role) < 0 && line.role !== 'none') {\n        this.insertLine({\n          start,\n          end,\n          role: line.role,\n          segmentIndex: i,\n          lineIndex: prevSegment.length,\n        });\n      }\n      line.remove();\n    });\n    segments.splice(i + 1, 1);\n    if (segmentSelected === prevSegment[0]) { wavesurfer.frame.update({ start: prevSegment[0].start, end: prevSegment[0].end }); }\n    this.resetRegionTitle();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  setPlayMode(mode) {\n    // none\n  }\n\n  checkNearbyAnchor(sec) {\n    const { anchors } = this.current;\n    const { minSegmentLength } = this.props;\n    let invalidAnchor = null;\n    let minDistance = null;\n    anchors.forEach((value) => {\n      const distance = Math.abs(value.start - sec);\n      if (distance < minSegmentLength) {\n        if (!invalidAnchor || minDistance > distance) {\n          invalidAnchor = value;\n          minDistance = distance;\n        }\n      }\n    });\n    return invalidAnchor;\n  }\n\n  singleLination(sec) {\n    const { minSegmentLength, disableSegment, annotateDisabled } = this.props;\n    const { wavesurfer, anchors } = this.current;\n    if (sec < minSegmentLength || disableSegment || annotateDisabled) return;\n    if (sec > wavesurfer.getDuration() - minSegmentLength) return;\n    const nearbyAnchor = this.checkNearbyAnchor(sec);\n    if (nearbyAnchor) {\n      const prevStart = nearbyAnchor.start;\n      nearbyAnchor.update({ start: sec });\n      this.handleAnchorDrag(nearbyAnchor);\n      const nearbyAnchorIndex = anchors.indexOf(nearbyAnchor);\n      this.addHistory('singleLination-adjust', { nearbyAnchorIndex, prevStart });\n    } else {\n      const splitSegment = this.getSegmentByTime(sec);\n      const splitAnchor = this.splitSegment(splitSegment, sec);\n      const splitAnchorIndex = anchors.indexOf(splitAnchor);\n      this.addHistory('singleLination-split', { splitAnchorIndex });\n    }\n  }\n\n  getSegmentByTime(sec) {\n    const { segments } = this.current;\n    // eslint-disable-next-line no-restricted-syntax\n    for (const value of segments) {\n      const line = value[0];\n      if (line.start <= sec && line.end >= sec) return value;\n    }\n    return null;\n  }\n\n  splitSegment(segment, sec, prevRules, nextRules, focusPrevSegment) {\n    const { segments, anchors } = this.current;\n    if (!segment) return;\n    const { end } = segment[0];\n    const i = segments.indexOf(segment);\n    const anchor = this.insertAnchor({ start: sec, segmentIndex: i + 1 });\n    this.insertSegment({ start: sec, end, segmentIndex: i + 1 });\n    segment.forEach((line) => { line.update({ end: sec }); });\n    if (prevRules && nextRules) {\n      const arr = [];\n      prevRules.forEach((rule) => { arr.push(rule.role); });\n      segment.forEach((line, index) => {\n        if (arr.indexOf(line.role) < 0) this.deleteLine({ lineIndex: index, segmentIndex: i });\n      });\n      this.deleteLine({ lineIndex: 0, segmentIndex: i + 1 });\n      nextRules.forEach((role) => { this.insertLine(role); });\n      const splitAnchorIndex = anchors.indexOf(anchor);\n      this.addHistory('singleLination-split', { splitAnchorIndex });\n    }\n    this.props.setSegmentTimestamp({ segmentIndex: i, end: sec });\n    this.props.splitSegmentForward({ segmentIndex: i, start: sec, end, prevRules, nextRules });\n    this.removeSelectedSegment();\n    this.resetRegionTitle();\n    this.props.setCurrentSegment({ index: focusPrevSegment ? i : i + 1 });\n    return anchor;\n  }\n\n  deleteLine(data) {\n    const { segments } = this.current;\n    const { segmentIndex, lineIndex } = data;\n\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    data.start = line.start;\n    data.end = line.end;\n    data.role = line.role;\n    line.remove();\n    segment.splice(lineIndex, 1);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n\n  toppingLine(data) {\n    const { segments } = this.current;\n    const { segmentIndex, lineIndex } = data;\n\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    segment.splice(lineIndex, 1);\n    segment.unshift(line);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n\n  doubleLination(start, end) {\n    const { minSegmentLength, disableSegment, annotateDisabled } = this.props;\n    const { anchors, segmentSelected } = this.current;\n    if (!start || Number.isNaN(start)) start = segmentSelected.start;\n    if (!end || Number.isNaN(end)) end = segmentSelected.end;\n    if (end - start <= minSegmentLength || disableSegment || annotateDisabled) return;\n    const nearbyLeftAnchor = this.checkNearbyAnchor(start);\n    const nearbyRightAnchor = this.checkNearbyAnchor(end);\n    const prevLeftStart = nearbyLeftAnchor ? nearbyLeftAnchor.start : -1;\n    const prevRightStart = nearbyRightAnchor ? nearbyRightAnchor.start : -1;\n    if (start < minSegmentLength) return;\n    if (end > this.current.wavesurfer.getDuration() - minSegmentLength) return;\n\n    if (nearbyLeftAnchor && nearbyRightAnchor) {\n      nearbyLeftAnchor.update({ start });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      nearbyRightAnchor.update({ start: end });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-adjust-adjust', { nearbyLeftAnchorIndex, prevLeftStart, nearbyRightAnchorIndex, prevRightStart });\n    } else if (!nearbyLeftAnchor && nearbyRightAnchor) {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      nearbyRightAnchor.update({ start: end });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-split-adjust', { splitLeftAnchorIndex, nearbyRightAnchorIndex, prevRightStart });\n    } else if (nearbyLeftAnchor && !nearbyRightAnchor) {\n      nearbyLeftAnchor.update({ start });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      this.addHistory('doubleLination-adjust-split', { nearbyLeftAnchorIndex, prevLeftStart, splitRightAnchorIndex });\n    } else {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end, null, null, true);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      this.addHistory('doubleLination-split-split', { splitLeftAnchorIndex, splitRightAnchorIndex });\n    }\n  }\n\n  handleKeyDown(e) {\n    if (window.disableLongAudioHotKeys) return;\n    if (isInput()) return;\n    if (isAnnotationReadonly(this.props.toolMode)) return;\n    // if (this.props.toolMode === 'QA_RO') return;\n    if (e.key.toUpperCase() === 'S') {\n      const sec = this.getCursorTime();\n      if (sec < 0) return;\n      this.singleLination(sec);\n    } else if (e.key.toUpperCase() === 'D') {\n      const { segmentSelected } = this.current;\n      if (segmentSelected && segmentSelected.data.type === 'temp') this.doubleLination();\n    } else if (e.key === ',' || e.key === '<') {\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(-ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', { step: -ANCHOR_MOVEMENT_STEP });\n      } else {\n        this.forwardAnchor();\n      }\n    } else if (e.key === '.' || e.key === '>') {\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', { step: ANCHOR_MOVEMENT_STEP });\n      } else {\n        this.backwardAnchor();\n      }\n    } else if (e.ctrlKey && e.key.toUpperCase() === 'Z') {\n      this.recallHistory('undo');\n    } else if (e.ctrlKey && e.key.toUpperCase() === 'Y') {\n      this.recallHistory('redo');\n    }\n  }\n\n  backwardAnchor() {\n    const { anchorSelected, wavesurfer, anchors } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start + ANCHOR_MOVEMENT_STEP >= wavesurfer.getDuration()) return;\n    anchorSelected.update({ start: anchorSelected.start + ANCHOR_MOVEMENT_STEP });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', { trimAnchorIndex, prevStart: anchorSelected.start - ANCHOR_MOVEMENT_STEP });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n\n  forwardAnchor() {\n    const { anchorSelected, anchors } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start - ANCHOR_MOVEMENT_STEP <= 0) return;\n    anchorSelected.update({ start: anchorSelected.start - ANCHOR_MOVEMENT_STEP });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', { trimAnchorIndex, prevStart: anchorSelected.start + ANCHOR_MOVEMENT_STEP });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n\n  handleRegionIn(region) {\n    const { currentPlayMode, currentSegment } = this.props;\n    const { wavesurfer } = this.current;\n    const { type } = region.data;\n    if (type !== 'line') return;\n    if (currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const currentTime = wavesurfer.getCurrentTime();\n      if (segmentIndex === currentSegment) return;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({ index: segmentIndex, start: currentTime });\n    }\n  }\n\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          // partialRender: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [\n            RegionsPlugin.create(),\n            CursorPlugin.create({\n              width: '1px',\n              height: '10px',\n              container: this.container.audioContainer[i],\n              color: defaultColor.defaultGreen,\n              showTime: true,\n              opacity: 1,\n              customShowTimeStyle: {\n                color: defaultColor.defaultGreen,\n                fontSize: '14px',\n                paddingLeft: '5px',\n                position: 'absolute',\n                bottom: '3px',\n              },\n              formatTimeCallback: (sec) => {\n                this.setState({ cursorTime: sec });\n                return formatTimestamp(sec);\n              },\n            }),\n            TimelinePlugin.create({\n              container: this.container.timeline[i],\n              primaryFontColor: defaultColor.defaultWhite,\n              secondaryFontColor: defaultColor.defaultWhite,\n              primaryColor: defaultColor.defaultWhite,\n              secondaryColor: defaultColor.defaultWhite,\n              fontSize: '10',\n              notchPercentHeight: 30,\n              timeInterval,\n              primaryLabelInterval,\n              secondaryLabelInterval,\n              formatTimeCallback,\n            }),\n            MinimapPlugin.create({\n              container: this.container.minimap[i],\n            }),\n          ],\n        });\n        urls[i] = this.container.videoContainer[i];\n        this.wavesurfers[i].on('ready', () => {\n          this.props.setLoading(false);\n          this.wavesurfers[i].pause();\n          this.wavesurfers[i].enableDragSelection({\n            color: hexToRgba(defaultColor.defaultRed, defaultColor.defaultAlpha),\n            drag: false,\n            resize: false,\n            data: { type: 'temp' },\n            formatTimeCallback: () => '',\n          });\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            console.log('Error', e);\n            this.props.setErrorMsg({ errorMsg: e?.toString() });\n            return;\n          }\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (!i) {\n            this.setNewVideo();\n            this.setSelectedSegment(this.current.segments[0][0]);\n          }\n          if (i === 0) this.addWindowEvent();\n          this.wavesurfers[i].on('play', (e) => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', (e) => this.handlePlayPause());\n          this.wavesurfers[i].on('region-updated', (region, e) => this.handleRegionUpdate(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (region, e) => this.handleRegionContextmenu(region, e));\n          this.wavesurfers[i].on('region-update-end', (region, e) => this.handleRegionEdit(region));\n          this.wavesurfers[i].on('region-out', (region, e) => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', (region, e) => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.props.setVideoValid({ index: i });\n          this.props.updateVideoInfo({ index: i, duration: this.wavesurfers[i].getDuration() });\n        });\n        this.wavesurfers[i].on('error', () => {\n          notification.error({ message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}` });\n          console.log('error', urls[i].src);\n          if (i !== size - 1) this.wavesurfers[i].load(urls[i]);\n          if (i === 0) this.addWindowEvent();\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.wavesurfers[i].destroy();\n        });\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const { zoom, wavesurfer } = this.current;\n        if (!cursorHelper) {\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer.cursor.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const { offsetWidth } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = (totalWidth / duration) * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n\n  addWindowEvent() {\n    window.addEventListener('keydown', (e) => this.handleKeyDown(e));\n    window.addEventListener('resize', (e) => this.setCurrentZoom());\n  }\n\n  // eslint-disable-next-line react/no-deprecated\n  componentWillMount() {\n    this.props.getWavesurfers({ wavesurfers: this });\n  }\n\n  render() { return null; }\n}\n\nconst mapStateToProps = (state) => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  keyAttribute: state.keyAttribute,\n  disableSegment: state.disableSegment,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw,\n});\nconst mapDispatchToProps = {\n  debug,\n  getWavesurfers,\n  setPlayingState,\n  setSegmentTimestamp,\n  mergeSegmentBackward,\n  splitSegmentForward,\n  setVideoValid,\n  setVideoZoom,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  removeSegment,\n  parseSegments,\n  setErrorMsg,\n  moveSegmentInBatch,\n  updateVideoInfo,\n  setLoading,\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(WavesurferComp);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}