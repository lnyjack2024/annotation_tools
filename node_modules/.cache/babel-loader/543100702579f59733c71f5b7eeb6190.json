{"ast":null,"code":"import { Point, BitmapText } from 'pixi.js';\nimport Flatten from '@flatten-js/core';\nimport { cloneDeep } from 'lodash';\nimport polygonClipping from 'polygon-clipping';\nimport pointOnLine from '@turf/boolean-point-on-line';\nimport { lineString, point as turfPoint } from '@turf/helpers';\nimport polylabel from 'polylabel';\nimport Shape, { EventAction } from './Shape';\nimport { ShapeType } from './types';\nimport ControlPoint from './controls/ControlPoint';\nimport ControlRotation from './controls/ControlRotation';\nimport { precise, normalizePoints } from './utils';\nimport Cursor from '../Cursor';\nimport { computeRotatedPosition, computePolygonAreaCenter } from '../../../utils/math';\n/**\n * Polygon shape\n * @class\n */\nexport default class Polygon extends Shape {\n  /**\n   * get points\n   * @getter\n   */\n  get points() {\n    return this._points.map(p => ({\n      x: p.x,\n      y: p.y,\n      ...(p.userData && {\n        userData: p.userData\n      })\n    }));\n  }\n\n  /**\n   * set points\n   * @setter\n   */\n  set points(points) {\n    this._points = points.map(p => ({\n      x: p.x,\n      y: p.y,\n      userData: cloneDeep(p.userData)\n    }));\n    this.normalize();\n  }\n\n  /**\n   * get position\n   * @getter\n   */\n  get position() {\n    return new Point(this._points[0].x, this._points[0].y);\n  }\n\n  /**\n   * set position\n   * @setter\n   */\n  set position(point) {\n    const offsetX = point.x - this._points[0].x;\n    const offsetY = point.y - this._points[0].y;\n    this._points.forEach(p => {\n      p.x = precise(p.x + offsetX);\n      p.y = precise(p.y + offsetY);\n    });\n    this.updateGeometory();\n    this.drawShape();\n  }\n\n  /**\n   * get pivot\n   * @getter\n   */\n  get pivot() {\n    const {\n      x,\n      y\n    } = computePolygonAreaCenter(this.points);\n    return new Point(x, y);\n  }\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  get shapeBounds() {\n    const shapePoints = this.points;\n    const left = Math.min(...shapePoints.map(p => p.x));\n    const right = Math.max(...shapePoints.map(p => p.x));\n    const top = Math.min(...shapePoints.map(p => p.y));\n    const bottom = Math.max(...shapePoints.map(p => p.y));\n    return {\n      left,\n      top,\n      right,\n      bottom\n    };\n  }\n\n  /**\n   * shape area\n   * @getter\n   */\n  get area() {\n    return this._geometory.faces.values().next().value.area();\n  }\n  constructor(options) {\n    super(options);\n    this.shapeType = ShapeType.POLYGON;\n    /**\n     * polygon points\n     * @private\n     */\n    this._points = [];\n    /**\n     * indicate next point when creating\n     * @private\n     */\n    this._nextPoint = null;\n    /**\n     * is mouse down\n     * @private\n     */\n    this._isDown = false;\n    /**\n     * is dragging\n     * @private\n     */\n    this._isDragging = false;\n    /**\n     * polygon geometory data\n     */\n    this._geometory = new Flatten.Polygon();\n    /**\n     * mouse down listener when creating\n     * @private\n     */\n    this._mouseDown = e => {\n      if (e.button === 0) {\n        // not right click\n        this._isDown = true;\n      }\n    };\n    /**\n     * mouse move listener when creating\n     * @private\n     * @param event\n     */\n    this._mouseMove = event => {\n      if (this._isDown) {\n        this._isDragging = true;\n      }\n      let localPoint = this.globalSnappingPoint;\n      if (!localPoint) {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        localPoint = this._mapStageToLocalPosition(point);\n      }\n      const p = localPoint;\n      if (this._isDragging) {\n        // add point directly when dragging to draw a polygon\n        const lastPoint = this.points[this.points.length - 1] || {\n          x: 0,\n          y: 0\n        };\n        const tolerance = 10 / this.scale;\n        if (Math.abs(p.x - lastPoint.x) > tolerance || Math.abs(p.y - lastPoint.y) > tolerance) {\n          this.addPoint(p);\n        }\n        this._nextPoint = null;\n      } else {\n        this._nextPoint = p;\n        this.drawShape();\n      }\n    };\n    /**\n     * mouse up listener when creating\n     * @private\n     * @param event\n     */\n    this._mouseUp = event => {\n      if (this._isDown && !this._isDragging) {\n        let localPoint = this.globalSnappingPoint;\n        if (!localPoint) {\n          const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n          localPoint = this._mapStageToLocalPosition(point);\n        }\n        const p = localPoint;\n        this.addPoint(p);\n      }\n      this._isDown = false;\n      this._isDragging = false;\n    };\n    /**\n     * finish by double clicking\n     * @private\n     */\n    this._finishByDoubleClick = () => {\n      this.finishCreate();\n    };\n    /**\n     * key down handler\n     * @private\n     * @param e\n     */\n    this._keyDown = e => {\n      var _e$key;\n      switch ((_e$key = e.key) === null || _e$key === void 0 ? void 0 : _e$key.toLowerCase()) {\n        case 'q':\n          if (!this._finished) {\n            e.preventDefault();\n            this.removePoint(this.points.length - 1);\n          }\n          break;\n        case 'enter':\n          if (!this._finished) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            this.finishCreate();\n          }\n          break;\n        default:\n          break;\n      }\n    };\n    /**\n     * finish create\n     */\n    this.finishCreate = () => {\n      let otherShapeData;\n      this.normalize();\n      this._finish(otherShapeData);\n      this._removeListeners();\n    };\n    const {\n      points\n    } = options;\n    if (Array.isArray(points) && points.every(p => p.x !== undefined && p.y !== undefined)) {\n      this.points = points;\n    }\n    document.addEventListener('keydown', this._keyDown, false);\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  _changed() {\n    if (this.rotation !== 0) {\n      this.rotatePoints();\n    }\n    this._emit(EventAction.CHANGED, this.getData());\n  }\n  /**\n   * draw shape\n   */\n  drawShape() {\n    this.instance.clear();\n    this._controlLine.clear();\n    this._drawShapeFill();\n    this._drawShapeLine();\n    this._drawShapeVertex();\n    this._drawSnappingPoint();\n    if (this._finished) {\n      this.drawShapeLabel();\n      this.attachControlPoints();\n    }\n  }\n\n  /**\n   * draw shape fill\n   * @private\n   */\n  _drawShapeFill() {\n    if (this._finished) {\n      this.instance.beginFill(this.color, this.alpha);\n      this.instance.drawPolygon(this._points.map(({\n        x,\n        y\n      }) => new Point(x, y)));\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw shape border\n   * @private\n   */\n  _drawShapeLine() {\n    if (this._points.length === 0) return;\n    const ctx = this.selected ? this._controlLine : this.instance;\n    const baseWidth = 1 / this.scale;\n    const color = this.displayBorderColor;\n    ctx.moveTo(this._points[0].x, this._points[0].y);\n    this._points.slice(1).forEach(point => {\n      ctx.lineStyle(baseWidth, color);\n      ctx.drawLine(point.x, point.y, this.borderStyle, this.scale);\n    });\n    ctx.lineStyle(baseWidth, color);\n    if (this._finished) {\n      ctx.drawLine(this._points[0].x, this._points[0].y, this.borderStyle, this.scale);\n    } else if (this._nextPoint) {\n      ctx.drawLine(this._nextPoint.x, this._nextPoint.y, this.borderStyle, this.scale);\n    }\n  }\n\n  /**\n   * draw shape vertexes\n   * @private\n   */\n  _drawShapeVertex() {\n    var _this$vertexesContain;\n    (_this$vertexesContain = this.vertexesContainer) === null || _this$vertexesContain === void 0 ? void 0 : _this$vertexesContain.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n    const r = 4 / this.scale;\n    const offset = this.showVertex ? r : 4 / this.scale;\n    this.instance.lineStyle(1 / this.scale, this.displayBorderColor);\n    this._points.forEach((point, index) => {\n      if (this.showVertex && (!this.editable || !this.selected)) {\n        // draw vertex dot\n        this.instance.beginFill(this.color);\n        this.instance.drawVertex(point.x, point.y, r);\n        this.instance.endFill();\n      }\n      if (this.showVertexOrder) {\n        // draw vertext order\n        const text = new BitmapText(`${1 + index} `, {\n          fontName: 'ALPHA_NUMERIC'\n        });\n        text.scale.set(1 / this.scale);\n        text.position.set(point.x + offset, point.y + offset);\n        if (!this.vertexesContainer) {\n          this._createVertexesContainer();\n        }\n        this.vertexesContainer.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * draw snapping point\n   */\n  _drawSnappingPoint() {\n    if (this._snappingPoint) {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(this._snappingPoint.x, this._snappingPoint.y, 3 / this.scale);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * create by click to add point\n   * @param point\n   */\n  create() {\n    this.app.view.addEventListener('mousedown', this._mouseDown, false);\n    document.addEventListener('mousemove', this._mouseMove, false);\n    document.addEventListener('mouseup', this._mouseUp, false);\n    this.app.view.addEventListener('dblclick', this._finishByDoubleClick, false);\n    this._finished = false;\n    this._nextPoint = null;\n    this._isDown = true; // create start is mouse down\n    this._isDragging = false;\n  }\n  /**\n   * remove all listeners\n   * @private\n   */\n  _removeListeners() {\n    this.app.view.removeEventListener('mousedown', this._mouseDown, false);\n    document.removeEventListener('mousemove', this._mouseMove, false);\n    document.removeEventListener('mouseup', this._mouseUp, false);\n    this.app.view.removeEventListener('dblclick', this._finishByDoubleClick, false);\n  }\n\n  /**\n   * get label position\n   */\n  getLabelPosition() {\n    const sorted = [...this._points].sort((a, b) => {\n      if (a.y === b.y) return a.x - b.x;\n      return a.y - b.y;\n    });\n    return new Point(sorted[0].x, sorted[0].y);\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      points: this.points\n    };\n  }\n\n  /**\n   * get geo json\n   */\n  getAreaAsGeoJSON() {\n    return [[this.points.map(p => [p.x, p.y])]];\n  }\n\n  /**\n   * delete selected points\n   */\n  deleteSelectedPoints() {\n    if (this.selected) {\n      const deletedIndexes = [];\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          deletedIndexes.push(i);\n          c.selected = false;\n        }\n      });\n      if (deletedIndexes.length > 0) {\n        this._points = this._points.filter((_, i) => !deletedIndexes.includes(i));\n        this.normalize();\n        this._changed();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * snap to point\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point, tolerance = 8) {\n    const t = tolerance / this.scale;\n\n    // bbox\n    const {\n      x,\n      y\n    } = point;\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.shapeBounds;\n    if (x < left - t || x > right + t || y < top - t || y > bottom + t) {\n      return null;\n    }\n\n    // points\n    let nearestPoint;\n    let d;\n    this.points.forEach(p => {\n      const pointDistance = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);\n      if (pointDistance < t && (d === undefined || pointDistance < d)) {\n        d = pointDistance;\n        nearestPoint = p;\n      }\n    });\n    if (nearestPoint) {\n      return new Point(nearestPoint.x, nearestPoint.y);\n    }\n\n    // edges\n    const location = new Flatten.Point(x, y);\n    const [distance, segment] = this._geometory.distanceTo(location);\n    if (distance < t) {\n      const {\n        ps,\n        pe\n      } = segment;\n      const edgePoint = ps.equalTo(location) ? pe : ps;\n      return new Point(edgePoint.x, edgePoint.y);\n    }\n    return null;\n  }\n\n  /**\n   * snap to polygon edges\n   */\n  snap(event) {\n    if (event.data.originalEvent.altKey) {\n      const point = event.data.getLocalPosition(this.container);\n      const location = new Flatten.Point(point.x, point.y);\n      const [distance, segment] = this._geometory.distanceTo(location);\n      if (distance < 8 / this.scale) {\n        const {\n          ps,\n          pe\n        } = segment;\n        const edgePoint = ps.equalTo(location) ? pe : ps;\n        this._snappingPoint = new Point(edgePoint.x, edgePoint.y);\n        this.drawShape();\n        return true;\n      }\n    }\n    if (this._snappingPoint) {\n      this._snappingPoint = null;\n      this.drawShape();\n    }\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    if (this._snappingPoint) {\n      const {\n        point,\n        edge,\n        previousPointIndex\n      } = this._findEdgeByPointPosition(this._snappingPoint);\n      const x = precise(point.x);\n      const y = precise(point.y);\n      this._geometory.addVertex(new Flatten.Point(x, y), edge);\n      this._points.splice(previousPointIndex + 1, 0, {\n        x,\n        y\n      });\n      this._snappingPoint = null;\n      this._controls.forEach(c => {\n        c.selected = false;\n      });\n      this.drawShape();\n      this._changed();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * find edge for new point position\n   * @param point\n   */\n  _findEdgeByPointPosition({\n    x,\n    y\n  }) {\n    const point = new Flatten.Point(x, y);\n    const edge = this._geometory.findEdgeByPoint(point);\n    const {\n      start,\n      end\n    } = edge;\n    // find the edge segment point index in points array\n    let i = 0;\n    while (i < this._points.length) {\n      const p1 = this._points[i];\n      const p2 = this._points[(i + 1) % this._points.length];\n      if (p1.x === start.x && p1.y === start.y && p2.x === end.x && p2.y === end.y || p1.x === end.x && p1.y === end.y && p2.x === start.x && p2.y === start.y) {\n        // if has more than one edge that has the same start-end point, just use the first found one\n        // in canvas when snapping point added, just the first of the overlapped edge can be divided\n        break;\n      }\n      i += 1;\n    }\n    return {\n      point,\n      edge,\n      previousPointIndex: i\n    };\n  }\n\n  /**\n   * attach control points\n   */\n  attachControlPoints() {\n    if (!this.editable) {\n      this.removeControls();\n      return;\n    }\n    [...this._points].forEach((point, index) => {\n      if (this.selected || this.hovered && this.showVertex) {\n        // create if never created before\n        if (!this._controls[index]) {\n          this._controls[index] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.displayBorderColor,\n            cursor: Cursor.POINTER,\n            onPositionChange: (x, y) => this._updateByPointPosition(index, x, y),\n            onFinish: () => this._finishResize(),\n            onClick: () => this._updatePointSelectedStatus(index)\n          });\n        }\n\n        // update\n        this._controls[index].color = this.displayBorderColor;\n        this._controls[index].position = point;\n        this._controls[index].add();\n      } else if (this._controls[index]) {\n        // remove\n        this._controls[index].selected = false;\n        this._controls[index].remove();\n      }\n    });\n    if (this._controls.length > this._points.length) {\n      // remove redundant control points\n      this._controls.slice(this._points.length).forEach(c => {\n        c.remove();\n      });\n      this._controls = this._controls.slice(0, this._points.length);\n    }\n    if (this.rotatable) {\n      if (this.selected) {\n        const {\n          top,\n          bottom\n        } = this.shapeBounds;\n        const size = this.pivot.y - Math.abs(top - bottom) / 2 - 50 / this.scale;\n        if (!this._rotateControl) {\n          this._rotateControl = new ControlRotation({\n            container: this.container,\n            position: this.pivot,\n            size,\n            rotation: this.shapeContainer.rotation,\n            scale: this.scale,\n            color: this.selectedColor,\n            onRotationChange: angle => {\n              if (this.rotation !== undefined) {\n                this.rotation += angle;\n                if (this.rotation >= Math.PI) {\n                  this.rotation -= 2 * Math.PI;\n                }\n                if (this.rotation <= -Math.PI) {\n                  this.rotation += 2 * Math.PI;\n                }\n              }\n            },\n            onFinish: () => {\n              this._changed();\n            }\n          });\n        }\n        this._rotateControl.rotation = this.shapeContainer.rotation;\n        this._rotateControl.position = this.pivot;\n        this._rotateControl.size = size;\n        this._rotateControl.add();\n      } else if (this._rotateControl) {\n        this._rotateControl.remove();\n      }\n    }\n  }\n\n  /**\n   * update polygon point\n   * @private\n   * @param index point index\n   * @param x new position x\n   * @param y new position y\n   */\n  _updateByPointPosition(index, x, y) {\n    const position = this.globalSnappingPoint || new Point(x, y);\n    const deltaX = position.x - this._points[index].x;\n    const deltaY = position.y - this._points[index].y;\n    this.updateSelectedPointsPosistion(deltaX, deltaY);\n    this._resizing({\n      deltaX,\n      deltaY\n    });\n  }\n\n  /**\n   * update selected points position\n   * @param deltaX\n   * @param deltaY\n   */\n  updateSelectedPointsPosistion(deltaX, deltaY) {\n    // move together\n    this._controls.forEach((c, i) => {\n      if (c.selected) {\n        const position = new Point(this._points[i].x + deltaX, this._points[i].y + deltaY);\n        this._points[i].x = position.x;\n        this._points[i].y = position.y;\n      }\n    });\n    this.drawShape();\n  }\n\n  /**\n   * update selected point\n   * @private\n   * @param index\n   */\n  _updatePointSelectedStatus(index) {\n    if (!this._controls[index].selected) {\n      this._emit(EventAction.VERTEX_SELECTED, index);\n      this._controls.forEach((c, i) => {\n        if (i === index) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * when finish resize\n   */\n  _finishResize() {\n    this.resizing = false;\n    this.normalize();\n    this._changed();\n  }\n\n  /**\n   * add a point\n   * @param point\n   * @param index\n   */\n  addPoint(point, index) {\n    const pIndex = index === undefined ? this._points.length : index;\n    this._points.splice(pIndex, 0, {\n      x: precise(point.x),\n      y: precise(point.y)\n    });\n    this.drawShape();\n  }\n\n  /**\n   * remove a point\n   * @param index\n   */\n  removePoint(index) {\n    if (index >= 0 && index < this._points.length) {\n      this._points.splice(index, 1);\n      this.drawShape();\n    }\n  }\n\n  /**\n   * normalize polygon shape, remove it if necessary\n   */\n  normalize() {\n    // remove duplicated points\n    const points = [];\n    this._points.forEach((point, index) => {\n      if (index === this._points.length - 1 || point.x !== this._points[index + 1].x || point.y !== this._points[index + 1].y) {\n        points.push(point);\n      }\n    });\n    this._points = points;\n\n    // crossing\n    if (this._points.length > 3) {\n      try {\n        this.splitPolygon();\n      } catch (e) {\n        this._remove();\n        return;\n      }\n    }\n    if (this._points.length < 3) {\n      this._remove();\n      return;\n    }\n    this._points.forEach(p => {\n      p.x = precise(p.x);\n      p.y = precise(p.y);\n    });\n    this.updateGeometory();\n    if (this.area <= 0) {\n      this._remove();\n      return;\n    }\n    this.drawShape();\n  }\n\n  // has crossing\n  splitPolygon() {\n    const pointsData = [[this.points.map(p => [p.x, p.y])]];\n    const intersection = polygonClipping.intersection(pointsData);\n    let points = [];\n    if (intersection.length > 1) {\n      // crossing\n      let maxArea = {\n        size: 0,\n        index: 0\n      };\n      intersection.forEach((i, index) => {\n        const polygon = new Flatten.Polygon();\n        polygon.addFace(i[0].map(p => new Flatten.Point(p[0], p[1])));\n        const area = polygon.faces.values().next().value.area();\n        if (area > maxArea.size) {\n          maxArea = {\n            size: area,\n            index\n          };\n        }\n      });\n      points = intersection[maxArea.index][0];\n    } else if (intersection.length === 1 && intersection[0].length > 0) {\n      const polygonData = lineString(intersection[0][0]);\n      const allPointsOnEdge = this.points.every(p => pointOnLine(turfPoint([p.x, p.y]), polygonData));\n      if (!allPointsOnEdge) {\n        // contains\n        points = intersection[0][0];\n      }\n    }\n    if (points.length > 0) {\n      const setPoints = {};\n      points.slice(0, points.length - 1).forEach(point => {\n        setPoints[point.join(',')] = point;\n      });\n      this._points = Object.values(setPoints).map(p => ({\n        x: p[0],\n        y: p[1]\n      }));\n      this.setSelectedPoints([]);\n    }\n  }\n\n  /**\n   * update geometory\n   */\n  updateGeometory() {\n    this._geometory.faces.forEach(face => this._geometory.deleteFace(face));\n    this._geometory.addFace(this._points.map(p => new Flatten.Point(p.x, p.y)));\n  }\n\n  /**\n   * shape destroy\n   */\n  destroy() {\n    document.removeEventListener('keydown', this._keyDown, false);\n    this._removeListeners();\n    // call parent\n    super.destroy();\n  }\n\n  /**\n   * selected points with point index & point instance\n   * @returns\n   */\n  getSelectedPoints() {\n    if (!this._finished) {\n      const lastPointIndex = this._points.length - 1;\n      return [{\n        index: lastPointIndex,\n        point: this._points[lastPointIndex]\n      }];\n    }\n    const selectedPoints = [];\n    const points = [...this.points];\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          selectedPoints.push({\n            index: i,\n            point: points[i]\n          });\n        }\n      });\n    }\n    return selectedPoints;\n  }\n\n  /**\n   * set selected points\n   * @param pointsIndex\n   */\n  setSelectedPoints(pointsIndex) {\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (pointsIndex.includes(i)) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * set points user data\n   * @param pointsData\n   */\n  setPointsUserData(pointsData) {\n    pointsData.forEach(({\n      index,\n      userData\n    }) => {\n      this._points[index].userData = cloneDeep(userData);\n    });\n    this.drawShape();\n    if (this._finished) {\n      this._changed();\n    }\n  }\n  static getPolygons(shapes) {\n    return shapes.filter(i => i.shapeType === ShapeType.POLYGON);\n  }\n  findInnerPolygons(shapes) {\n    const polygons = Polygon.getPolygons(shapes).filter(i => i.uid !== this.uid);\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.shapeBounds;\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const {\n        left: l,\n        right: r,\n        top: t,\n        bottom: b\n      } = polygon.shapeBounds;\n      if (l >= left && r <= right && t <= top && b >= bottom) {\n        //\n      }\n    }\n  }\n  findIntersectPolygons(shapes, includeCover = false) {\n    const polygons = Polygon.getPolygons(shapes).filter(i => i.uid !== this.uid);\n    const pointsData = [[this.points.map(p => [p.x, p.y])]];\n    const intersects = [];\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const points = [[polygon.points.map(p => [p.x, p.y])]];\n      const intersection = polygonClipping.intersection(pointsData, points);\n      // has crossing, check include\n      if (intersection.length > 0) {\n        const differenceA = polygonClipping.difference(pointsData, points);\n        const differenceB = polygonClipping.difference(points, pointsData);\n        if (differenceA.length > 0 && differenceB.length > 0) {\n          intersects.push(polygon.uid);\n        } else if (includeCover && differenceA.length > 0 && differenceB.length === 0) {\n          // covered polygons\n          intersects.push(polygon.uid);\n        }\n      }\n    }\n    return intersects;\n  }\n  merge(polygon) {\n    const pointsData = [[this.points.map(p => [p.x, p.y])]];\n    const polygonPoints = [[polygon.points.map(p => [p.x, p.y])]];\n    const mergedPolygonPoints = polygonClipping.union(pointsData, polygonPoints);\n    return (mergedPolygonPoints[0] || []).map(points => ({\n      points: normalizePoints(points)\n    }));\n  }\n  subtract(shapes) {\n    const polygons = shapes.filter(i => i.shapeType === ShapeType.POLYGON);\n    if (polygons.length === 0) {\n      // no intersection\n      return null;\n    }\n    const pointsData = [this.points.map(p => [p.x, p.y])];\n    const polygonsPointsData = polygons.map(i => [i.points.map(p => [p.x, p.y])]);\n    const subtractData = polygonClipping.difference(pointsData, ...polygonsPointsData);\n    const newSubtractData = [];\n    const addToNewSubtractData = polygon => {\n      const newPolygon = new Flatten.Polygon(polygon[0]);\n      const area = newPolygon.faces.values().next().value.area();\n      newSubtractData.push({\n        polygon,\n        area\n      });\n    };\n    subtractData.forEach(i => {\n      if (i.length === 1) {\n        // simple polygon, add directly\n        addToNewSubtractData(i);\n      } else if (i.length > 1) {\n        // complex polygon, need split\n        const points = i[0];\n        const innerPolygons = i.slice(1);\n        const innerPolygonCenters = innerPolygons.map(polygon => {\n          // get visual center of the polygon\n          // ensure polygon contains the center point\n          // otherwise, it may fail to split some concave polygons by the split line\n          // ref: https://blog.mapbox.com/a-new-algorithm-for-finding-a-visual-center-of-a-polygon-7c77e6492fbc\n          const p = polylabel([polygon], 1);\n          return p;\n        }).sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]); // sort from left to right\n\n        const sortedPoints = [...points].sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\n        const LPoint = sortedPoints[0];\n        const RPoint = sortedPoints[sortedPoints.length - 1];\n        const LPointIndex = points.findIndex(p => p[0] === LPoint[0] && p[1] === LPoint[1]);\n        const RPointIndex = points.findIndex(p => p[0] === RPoint[0] && p[1] === RPoint[1]);\n        const splitLine = [LPoint, ...innerPolygonCenters, RPoint];\n        let p1;\n        let p2;\n        if (LPointIndex < RPointIndex) {\n          p1 = [...points.slice(RPointIndex + 1), ...points.slice(0, LPointIndex), ...splitLine];\n          p2 = [...points.slice(LPointIndex + 1, RPointIndex), ...splitLine.reverse()];\n        } else {\n          p1 = [...points.slice(RPointIndex + 1, LPointIndex), ...splitLine];\n          p2 = [...points.slice(LPointIndex + 1), ...points.slice(0, RPointIndex), ...splitLine.reverse()];\n        }\n        const innerGeom = innerPolygons.map(p => [p]);\n        const subtractedPolygons = [...polygonClipping.difference([p1], [p2], ...innerGeom), ...polygonClipping.difference([p2], [p1], ...innerGeom)];\n        subtractedPolygons.forEach(polygon => addToNewSubtractData(polygon));\n      }\n    });\n    return newSubtractData.sort((a, b) => b.area - a.area) // sort by area\n    .map(i => i.polygon.map(points => ({\n      points: normalizePoints(points)\n    })));\n  }\n\n  /**\n   * set actual points position\n   * reset rotation\n   */\n  rotatePoints() {\n    const points = JSON.parse(JSON.stringify(this.points));\n    if (this.rotation !== 0) {\n      points.forEach(p => {\n        const point = computeRotatedPosition(this.pivot, p, this.rotation);\n        p.x = precise(point.x);\n        p.y = precise(point.y);\n      });\n    }\n    this._rotation = 0;\n    this._updatePosition();\n    this.points = points;\n  }\n}","map":{"version":3,"names":["Point","BitmapText","Flatten","cloneDeep","polygonClipping","pointOnLine","lineString","point","turfPoint","polylabel","Shape","EventAction","ShapeType","ControlPoint","ControlRotation","precise","normalizePoints","Cursor","computeRotatedPosition","computePolygonAreaCenter","Polygon","points","_points","map","p","x","y","userData","normalize","position","offsetX","offsetY","forEach","updateGeometory","drawShape","pivot","shapeBounds","shapePoints","left","Math","min","right","max","top","bottom","area","_geometory","faces","values","next","value","constructor","options","shapeType","POLYGON","_nextPoint","_isDown","_isDragging","_mouseDown","e","button","_mouseMove","event","localPoint","globalSnappingPoint","_mapScreenToStagePosition","clientX","clientY","_mapStageToLocalPosition","lastPoint","length","tolerance","scale","abs","addPoint","_mouseUp","_finishByDoubleClick","finishCreate","_keyDown","_e$key","key","toLowerCase","_finished","preventDefault","removePoint","stopImmediatePropagation","otherShapeData","_finish","_removeListeners","Array","isArray","every","undefined","document","addEventListener","_changed","rotation","rotatePoints","_emit","CHANGED","getData","instance","clear","_controlLine","_drawShapeFill","_drawShapeLine","_drawShapeVertex","_drawSnappingPoint","drawShapeLabel","attachControlPoints","beginFill","color","alpha","drawPolygon","endFill","ctx","selected","baseWidth","displayBorderColor","moveTo","slice","lineStyle","drawLine","borderStyle","_this$vertexesContain","vertexesContainer","removeChildren","showVertex","showVertexOrder","r","offset","index","editable","drawVertex","text","fontName","set","_createVertexesContainer","addChild","_snappingPoint","selectedColor","drawCircle","create","app","view","removeEventListener","getLabelPosition","sorted","sort","a","b","getAreaAsGeoJSON","deleteSelectedPoints","deletedIndexes","_controls","c","i","push","filter","_","includes","snapToPoint","t","nearestPoint","d","pointDistance","sqrt","location","distance","segment","distanceTo","ps","pe","edgePoint","equalTo","snap","data","originalEvent","altKey","getLocalPosition","container","addSnappingPointToShape","edge","previousPointIndex","_findEdgeByPointPosition","addVertex","splice","findEdgeByPoint","start","end","p1","p2","removeControls","hovered","controlsContainer","cursor","POINTER","onPositionChange","_updateByPointPosition","onFinish","_finishResize","onClick","_updatePointSelectedStatus","add","remove","rotatable","size","_rotateControl","shapeContainer","onRotationChange","angle","PI","deltaX","deltaY","updateSelectedPointsPosistion","_resizing","VERTEX_SELECTED","resizing","pIndex","splitPolygon","_remove","pointsData","intersection","maxArea","polygon","addFace","polygonData","allPointsOnEdge","setPoints","join","Object","setSelectedPoints","face","deleteFace","destroy","getSelectedPoints","lastPointIndex","selectedPoints","pointsIndex","setPointsUserData","getPolygons","shapes","findInnerPolygons","polygons","uid","l","findIntersectPolygons","includeCover","intersects","differenceA","difference","differenceB","merge","polygonPoints","mergedPolygonPoints","union","subtract","polygonsPointsData","subtractData","newSubtractData","addToNewSubtractData","newPolygon","innerPolygons","innerPolygonCenters","sortedPoints","LPoint","RPoint","LPointIndex","findIndex","RPointIndex","splitLine","reverse","innerGeom","subtractedPolygons","JSON","parse","stringify","_rotation","_updatePosition"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/Polygon.ts"],"sourcesContent":["import { Point, BitmapText, InteractionEvent } from 'pixi.js';\nimport Flatten from '@flatten-js/core';\nimport { cloneDeep } from 'lodash';\nimport polygonClipping, { Ring, Pair } from 'polygon-clipping';\nimport pointOnLine from '@turf/boolean-point-on-line';\nimport { lineString, point as turfPoint } from '@turf/helpers';\nimport polylabel from 'polylabel';\nimport Shape, { ShapeOptions, EventAction } from './Shape';\nimport { ShapeData, ShapeType } from './types';\nimport ControlPoint from './controls/ControlPoint';\nimport ControlRotation from './controls/ControlRotation';\nimport { precise, normalizePoints } from './utils';\nimport Cursor from '../Cursor';\nimport { computeRotatedPosition, computePolygonAreaCenter } from '../../../utils/math';\n\ninterface IPoint {\n  x: number;\n  y: number;\n  userData?: any;\n}\n\nexport interface PolygonData {\n  points: IPoint[];\n}\n\nexport interface PolygonOptions extends ShapeOptions {\n  points?: IPoint[];\n}\n\n/**\n * Polygon shape\n * @class\n */\nexport default class Polygon extends Shape<PolygonData> {\n  shapeType = ShapeType.POLYGON;\n\n  /**\n   * polygon points\n   * @private\n   */\n  private _points: IPoint[] = [];\n\n  /**\n   * indicate next point when creating\n   * @private\n   */\n  private _nextPoint: IPoint | null = null;\n\n  /**\n   * is mouse down\n   * @private\n   */\n  private _isDown = false;\n\n  /**\n   * is dragging\n   * @private\n   */\n  private _isDragging = false;\n\n  /**\n   * polygon geometory data\n   */\n  private _geometory = new Flatten.Polygon();\n\n  /**\n   * get points\n   * @getter\n   */\n  get points() {\n    return this._points.map((p) => ({\n      x: p.x,\n      y: p.y,\n      ...p.userData && { userData: p.userData },\n    }));\n  }\n\n  /**\n   * set points\n   * @setter\n   */\n  set points(points: IPoint[]) {\n    this._points = points.map((p) => ({ x: p.x, y: p.y, userData: cloneDeep(p.userData) }));\n    this.normalize();\n  }\n\n  /**\n   * get position\n   * @getter\n   */\n  get position() {\n    return new Point(this._points[0].x, this._points[0].y);\n  }\n\n  /**\n   * set position\n   * @setter\n   */\n  set position(point: Point) {\n    const offsetX = point.x - this._points[0].x;\n    const offsetY = point.y - this._points[0].y;\n    this._points.forEach((p) => {\n      p.x = precise(p.x + offsetX);\n      p.y = precise(p.y + offsetY);\n    });\n    this.updateGeometory();\n    this.drawShape();\n  }\n\n  /**\n   * get pivot\n   * @getter\n   */\n  get pivot() {\n    const { x, y } = computePolygonAreaCenter(this.points);\n    return new Point(x, y);\n  }\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  get shapeBounds() {\n    const shapePoints = this.points;\n    const left = Math.min(...shapePoints.map((p) => p.x));\n    const right = Math.max(...shapePoints.map((p) => p.x));\n    const top = Math.min(...shapePoints.map((p) => p.y));\n    const bottom = Math.max(...shapePoints.map((p) => p.y));\n    return { left, top, right, bottom };\n  }\n\n  /**\n   * shape area\n   * @getter\n   */\n  get area() {\n    return this._geometory.faces.values().next().value.area();\n  }\n\n  constructor(options: PolygonOptions) {\n    super(options);\n\n    const { points } = options;\n    if (Array.isArray(points) && points.every((p) => p.x !== undefined && p.y !== undefined)) {\n      this.points = points;\n    }\n\n    document.addEventListener('keydown', this._keyDown, false);\n  }\n\n  /**\n   * when shape move & resize\n   * @protected\n   */\n  protected _changed() {\n    if (this.rotation !== 0) {\n      this.rotatePoints();\n    }\n    this._emit(EventAction.CHANGED, this.getData());\n  };\n\n  /**\n   * draw shape\n   */\n  drawShape() {\n    this.instance.clear();\n    this._controlLine.clear();\n    this._drawShapeFill();\n    this._drawShapeLine();\n    this._drawShapeVertex();\n    this._drawSnappingPoint();\n    if (this._finished) {\n      this.drawShapeLabel();\n      this.attachControlPoints();\n    }\n  }\n\n  /**\n   * draw shape fill\n   * @private\n   */\n  private _drawShapeFill() {\n    if (this._finished) {\n      this.instance.beginFill(this.color, this.alpha);\n      this.instance.drawPolygon(this._points.map(({ x, y }) => new Point(x, y)));\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw shape border\n   * @private\n   */\n  private _drawShapeLine() {\n    if (this._points.length === 0) return;\n    const ctx = this.selected ? this._controlLine : this.instance;\n    const baseWidth = 1 / this.scale;\n    const color = this.displayBorderColor;\n    ctx.moveTo(this._points[0].x, this._points[0].y);\n    this._points.slice(1).forEach((point) => {\n      ctx.lineStyle(baseWidth, color);\n      ctx.drawLine(point.x, point.y, this.borderStyle, this.scale);\n    });\n    ctx.lineStyle(baseWidth, color);\n    if (this._finished) {\n      ctx.drawLine(this._points[0].x, this._points[0].y, this.borderStyle, this.scale);\n    } else if (this._nextPoint) {\n      ctx.drawLine(this._nextPoint.x, this._nextPoint.y, this.borderStyle, this.scale);\n    }\n  }\n\n  /**\n   * draw shape vertexes\n   * @private\n   */\n  private _drawShapeVertex() {\n    this.vertexesContainer?.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n\n    const r = 4 / this.scale;\n    const offset = this.showVertex ? r : 4 / this.scale;\n    this.instance.lineStyle(1 / this.scale, this.displayBorderColor);\n    this._points.forEach((point, index) => {\n      if (this.showVertex && (!this.editable || !this.selected)) {\n        // draw vertex dot\n        this.instance.beginFill(this.color);\n        this.instance.drawVertex(point.x, point.y, r);\n        this.instance.endFill();\n      }\n      if (this.showVertexOrder) {\n        // draw vertext order\n        const text = new BitmapText(`${1 + index} `, { fontName: 'ALPHA_NUMERIC' });\n        text.scale.set(1 / this.scale);\n        text.position.set(point.x + offset, point.y + offset);\n        if (!this.vertexesContainer) {\n          this._createVertexesContainer();\n        }\n        this.vertexesContainer!.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * draw snapping point\n   */\n  private _drawSnappingPoint() {\n    if (this._snappingPoint) {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(this._snappingPoint.x, this._snappingPoint.y, 3 / this.scale);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * create by click to add point\n   * @param point\n   */\n  create() {\n    this.app.view.addEventListener('mousedown', this._mouseDown, false);\n    document.addEventListener('mousemove', this._mouseMove, false);\n    document.addEventListener('mouseup', this._mouseUp, false);\n    this.app.view.addEventListener('dblclick', this._finishByDoubleClick, false);\n\n    this._finished = false;\n    this._nextPoint = null;\n    this._isDown = true; // create start is mouse down\n    this._isDragging = false;\n  }\n\n  /**\n   * mouse down listener when creating\n   * @private\n   */\n  private _mouseDown = (e: MouseEvent) => {\n    if (e.button === 0) { // not right click\n      this._isDown = true;\n    }\n  };\n\n  /**\n   * mouse move listener when creating\n   * @private\n   * @param event\n   */\n  private _mouseMove = (event: MouseEvent) => {\n    if (this._isDown) {\n      this._isDragging = true;\n    }\n\n    let localPoint = this.globalSnappingPoint;\n    if (!localPoint) {\n      const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n      localPoint = this._mapStageToLocalPosition(point);\n    }\n    const p = localPoint;\n    if (this._isDragging) {\n      // add point directly when dragging to draw a polygon\n      const lastPoint = this.points[this.points.length - 1] || { x: 0, y: 0 };\n      const tolerance = 10 / this.scale;\n      if (Math.abs(p.x - lastPoint.x) > tolerance || Math.abs(p.y - lastPoint.y) > tolerance) {\n        this.addPoint(p);\n      }\n      this._nextPoint = null;\n    } else {\n      this._nextPoint = p;\n      this.drawShape();\n    }\n  };\n\n  /**\n   * mouse up listener when creating\n   * @private\n   * @param event\n   */\n  private _mouseUp = (event: MouseEvent) => {\n    if (this._isDown && !this._isDragging) {\n      let localPoint = this.globalSnappingPoint;\n      if (!localPoint) {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        localPoint = this._mapStageToLocalPosition(point);\n      }\n      const p = localPoint;\n      this.addPoint(p);\n    }\n    this._isDown = false;\n    this._isDragging = false;\n  };\n\n  /**\n   * finish by double clicking\n   * @private\n   */\n  private _finishByDoubleClick = () => {\n    this.finishCreate();\n  };\n\n  /**\n   * key down handler\n   * @private\n   * @param e\n   */\n  private _keyDown = (e: KeyboardEvent) => {\n    switch (e.key?.toLowerCase()) {\n      case 'q':\n        if (!this._finished) {\n          e.preventDefault();\n          this.removePoint(this.points.length - 1);\n        }\n        break;\n      case 'enter':\n        if (!this._finished) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.finishCreate();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * finish create\n   */\n  finishCreate = () => {\n    let otherShapeData: PolygonData[] | undefined;\n    this.normalize();\n    this._finish(otherShapeData);\n    this._removeListeners();\n  };\n\n  /**\n   * remove all listeners\n   * @private\n   */\n  private _removeListeners() {\n    this.app.view.removeEventListener('mousedown', this._mouseDown, false);\n    document.removeEventListener('mousemove', this._mouseMove, false);\n    document.removeEventListener('mouseup', this._mouseUp, false);\n    this.app.view.removeEventListener('dblclick', this._finishByDoubleClick, false);\n  }\n\n  /**\n   * get label position\n   */\n  getLabelPosition() {\n    const sorted = [...this._points].sort((a, b) => {\n      if (a.y === b.y) return a.x - b.x;\n      return a.y - b.y;\n    });\n    return new Point(sorted[0].x, sorted[0].y);\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      points: this.points,\n    };\n  }\n\n  /**\n   * get geo json\n   */\n  getAreaAsGeoJSON() {\n    return [[this.points.map((p) => [p.x, p.y] as [number, number])]];\n  }\n\n  /**\n   * delete selected points\n   */\n  deleteSelectedPoints() {\n    if (this.selected) {\n      const deletedIndexes: number[] = [];\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          deletedIndexes.push(i);\n          c.selected = false;\n        }\n      });\n      if (deletedIndexes.length > 0) {\n        this._points = this._points.filter((_, i) => !deletedIndexes.includes(i));\n        this.normalize();\n        this._changed();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * snap to point\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point: Point, tolerance = 8) {\n    const t = tolerance / this.scale;\n\n    // bbox\n    const { x, y } = point;\n    const { left, right, top, bottom } = this.shapeBounds;\n    if (x < left - t || x > right + t || y < top - t || y > bottom + t) {\n      return null;\n    }\n\n    // points\n    let nearestPoint: IPoint | undefined;\n    let d: number | undefined;\n    this.points.forEach((p) => {\n      const pointDistance = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);\n      if (pointDistance < t && (d === undefined || pointDistance < d)) {\n        d = pointDistance;\n        nearestPoint = p;\n      }\n    });\n    if (nearestPoint) {\n      return new Point(nearestPoint.x, nearestPoint.y);\n    }\n\n    // edges\n    const location = new Flatten.Point(x, y);\n    const [distance, segment] = this._geometory.distanceTo(location);\n    if (distance < t) {\n      const { ps, pe } = segment;\n      const edgePoint = ps.equalTo(location) ? pe : ps;\n      return new Point(edgePoint.x, edgePoint.y);\n    }\n\n    return null;\n  }\n\n  /**\n   * snap to polygon edges\n   */\n  snap(event: InteractionEvent) {\n    if (event.data.originalEvent.altKey) {\n      const point = event.data.getLocalPosition(this.container);\n      const location = new Flatten.Point(point.x, point.y);\n      const [distance, segment] = this._geometory.distanceTo(location);\n      if (distance < 8 / this.scale) {\n        const { ps, pe } = segment;\n        const edgePoint = ps.equalTo(location) ? pe : ps;\n        this._snappingPoint = new Point(edgePoint.x, edgePoint.y);\n        this.drawShape();\n        return true;\n      }\n    }\n\n    if (this._snappingPoint) {\n      this._snappingPoint = null;\n      this.drawShape();\n    }\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    if (this._snappingPoint) {\n      const { point, edge, previousPointIndex } = this._findEdgeByPointPosition(this._snappingPoint);\n      const x = precise(point.x);\n      const y = precise(point.y);\n      this._geometory.addVertex(new Flatten.Point(x, y), edge);\n      this._points.splice(previousPointIndex + 1, 0, { x, y });\n      this._snappingPoint = null;\n      this._controls.forEach((c) => {\n        c.selected = false;\n      });\n      this.drawShape();\n      this._changed();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * find edge for new point position\n   * @param point\n   */\n  private _findEdgeByPointPosition({ x, y }: { x: number; y: number }) {\n    const point = new Flatten.Point(x, y);\n    const edge = this._geometory.findEdgeByPoint(point);\n    const { start, end } = edge;\n    // find the edge segment point index in points array\n    let i = 0;\n    while (i < this._points.length) {\n      const p1 = this._points[i];\n      const p2 = this._points[(i + 1) % this._points.length];\n      if (\n        (p1.x === start.x && p1.y === start.y && p2.x === end.x && p2.y === end.y) ||\n        (p1.x === end.x && p1.y === end.y && p2.x === start.x && p2.y === start.y)\n      ) {\n        // if has more than one edge that has the same start-end point, just use the first found one\n        // in canvas when snapping point added, just the first of the overlapped edge can be divided\n        break;\n      }\n      i += 1;\n    }\n    return { point, edge, previousPointIndex: i };\n  }\n\n  /**\n   * attach control points\n   */\n  attachControlPoints() {\n    if (!this.editable) {\n      this.removeControls();\n      return;\n    }\n\n    [...this._points].forEach((point, index) => {\n      if (this.selected || (this.hovered && this.showVertex)) {\n        // create if never created before\n        if (!this._controls[index]) {\n          this._controls[index] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.displayBorderColor,\n            cursor: Cursor.POINTER,\n            onPositionChange: (x, y) => this._updateByPointPosition(index, x, y),\n            onFinish: () => this._finishResize(),\n            onClick: () => this._updatePointSelectedStatus(index),\n          });\n        }\n\n        // update\n        this._controls[index].color = this.displayBorderColor;\n        this._controls[index].position = point;\n        this._controls[index].add();\n      } else if (this._controls[index]) {\n        // remove\n        this._controls[index].selected = false;\n        this._controls[index].remove();\n      }\n    });\n    if (this._controls.length > this._points.length) {\n      // remove redundant control points\n      this._controls.slice(this._points.length).forEach((c) => {\n        c.remove();\n      });\n      this._controls = this._controls.slice(0, this._points.length);\n    }\n\n    if (this.rotatable) {\n      if (this.selected) {\n        const { top, bottom } = this.shapeBounds;\n        const size = this.pivot.y - Math.abs(top - bottom) / 2 - 50 / this.scale;\n        if (!this._rotateControl) {\n          this._rotateControl = new ControlRotation({\n            container: this.container,\n            position: this.pivot,\n            size,\n            rotation: this.shapeContainer.rotation,\n            scale: this.scale,\n            color: this.selectedColor,\n            onRotationChange: (angle) => {\n              if (this.rotation !== undefined) {\n                this.rotation += angle;\n                if (this.rotation >= Math.PI) {\n                  this.rotation -= 2 * Math.PI;\n                }\n                if (this.rotation <= -Math.PI) {\n                  this.rotation += 2 * Math.PI;\n                }\n              }\n            },\n            onFinish: () => {\n              this._changed();\n            }\n          });\n        }\n        this._rotateControl.rotation = this.shapeContainer.rotation;\n        this._rotateControl.position = this.pivot;\n        this._rotateControl.size = size;\n        this._rotateControl.add();\n      } else if (this._rotateControl) {\n        this._rotateControl.remove();\n      }\n    }\n  }\n\n  /**\n   * update polygon point\n   * @private\n   * @param index point index\n   * @param x new position x\n   * @param y new position y\n   */\n  private _updateByPointPosition(index: number, x: number, y: number) {\n    const position = this.globalSnappingPoint || new Point(x, y);\n    const deltaX = position.x - this._points[index].x;\n    const deltaY = position.y - this._points[index].y;\n    this.updateSelectedPointsPosistion(deltaX, deltaY);\n    this._resizing({ deltaX, deltaY });\n  }\n\n  /**\n   * update selected points position\n   * @param deltaX\n   * @param deltaY\n   */\n  updateSelectedPointsPosistion(deltaX: number, deltaY: number) {\n    // move together\n    this._controls.forEach((c, i) => {\n      if (c.selected) {\n        const position = new Point(this._points[i].x + deltaX, this._points[i].y + deltaY);\n        this._points[i].x = position.x;\n        this._points[i].y = position.y;\n      }\n    });\n    this.drawShape();\n  }\n\n  /**\n   * update selected point\n   * @private\n   * @param index\n   */\n  private _updatePointSelectedStatus(index: number) {\n    if (!this._controls[index].selected) {\n      this._emit(EventAction.VERTEX_SELECTED, index);\n      this._controls.forEach((c, i) => {\n        if (i === index) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * when finish resize\n   */\n  private _finishResize() {\n    this.resizing = false;\n    this.normalize();\n    this._changed();\n  }\n\n  /**\n   * add a point\n   * @param point\n   * @param index\n   */\n  addPoint(point: IPoint | Point, index?: number) {\n    const pIndex = index === undefined ? this._points.length : index;\n    this._points.splice(pIndex, 0, { x: precise(point.x), y: precise(point.y) });\n    this.drawShape();\n  }\n\n  /**\n   * remove a point\n   * @param index\n   */\n  removePoint(index: number) {\n    if (index >= 0 && index < this._points.length) {\n      this._points.splice(index, 1);\n      this.drawShape();\n    }\n  }\n\n  /**\n   * normalize polygon shape, remove it if necessary\n   */\n  normalize() {\n    // remove duplicated points\n    const points: IPoint[] = [];\n    this._points.forEach((point, index) => {\n      if (index === this._points.length - 1 || point.x !== this._points[index + 1].x || point.y !== this._points[index + 1].y) {\n        points.push(point);\n      }\n    });\n    this._points = points;\n\n    // crossing\n    if (this._points.length > 3) {\n      try {\n        this.splitPolygon();\n      } catch (e) {\n        this._remove();\n        return;\n      }\n    }\n\n    if (this._points.length < 3) {\n      this._remove();\n      return;\n    }\n\n    this._points.forEach((p) => {\n      p.x = precise(p.x);\n      p.y = precise(p.y);\n    });\n\n    this.updateGeometory();\n\n    if (this.area <= 0) {\n      this._remove();\n      return;\n    }\n\n    this.drawShape();\n  }\n\n  // has crossing\n  splitPolygon() {\n    const pointsData: polygonClipping.Geom = [[this.points.map((p) => [p.x, p.y] as Pair)]];\n    const intersection = polygonClipping.intersection(pointsData);\n    let points: Ring = [];\n    if (intersection.length > 1) {\n      // crossing\n      let maxArea = {\n        size: 0,\n        index: 0\n      };\n      intersection.forEach((i, index) => {\n        const polygon = new Flatten.Polygon();\n        polygon.addFace(i[0].map((p) => new Flatten.Point(p[0], p[1])));\n        const area = polygon.faces.values().next().value.area();\n        if (area > maxArea.size) {\n          maxArea = {\n            size: area,\n            index\n          };\n        }\n      });\n      points = intersection[maxArea.index][0];\n    } else if (intersection.length === 1 && intersection[0].length > 0) {\n      const polygonData = lineString(intersection[0][0]);\n      const allPointsOnEdge = this.points.every((p) => pointOnLine(turfPoint([p.x, p.y]), polygonData));\n      if (!allPointsOnEdge) {\n        // contains\n        points = intersection[0][0];\n      }\n    }\n    if (points.length > 0) {\n      const setPoints: {[key: string]: number[]} = {};\n      points.slice(0, points.length - 1).forEach((point) => {\n        setPoints[point.join(',')] = point;\n      });\n      this._points = Object.values(setPoints).map((p) => ({ x: p[0], y: p[1] }));\n      this.setSelectedPoints([]);\n    }\n  }\n\n  /**\n   * update geometory\n   */\n  updateGeometory() {\n    this._geometory.faces.forEach((face) => this._geometory.deleteFace(face));\n    this._geometory.addFace(this._points.map((p) => new Flatten.Point(p.x, p.y)));\n  }\n\n  /**\n   * shape destroy\n   */\n  destroy() {\n    document.removeEventListener('keydown', this._keyDown, false);\n    this._removeListeners();\n    // call parent\n    super.destroy();\n  }\n\n  /**\n   * selected points with point index & point instance\n   * @returns\n   */\n  getSelectedPoints() {\n    if (!this._finished) {\n      const lastPointIndex = this._points.length - 1;\n      return [{ index: lastPointIndex, point: this._points[lastPointIndex] }];\n    }\n    const selectedPoints: {index: number; point: IPoint}[] = [];\n    const points = [...this.points];\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          selectedPoints.push({\n            index: i,\n            point: points[i],\n          });\n        }\n      });\n    }\n    return selectedPoints;\n  }\n\n  /**\n   * set selected points\n   * @param pointsIndex\n   */\n  setSelectedPoints(pointsIndex: number[]) {\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (pointsIndex.includes(i)) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * set points user data\n   * @param pointsData\n   */\n  setPointsUserData(pointsData: {index: number; userData: any}[]) {\n    pointsData.forEach(({ index, userData }) => {\n      this._points[index].userData = cloneDeep(userData);\n    });\n    this.drawShape();\n    if (this._finished) {\n      this._changed();\n    }\n  }\n\n  static getPolygons(shapes: Shape<ShapeData>[]) {\n    return shapes.filter((i) => i.shapeType === ShapeType.POLYGON) as Polygon[];\n  }\n\n  findInnerPolygons(shapes: Shape<ShapeData>[]) {\n    const polygons = Polygon.getPolygons(shapes).filter((i) => i.uid !== this.uid);\n\n    const { left, right, top, bottom } = this.shapeBounds;\n\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const { left: l, right: r, top: t, bottom: b } = polygon.shapeBounds;\n      if (l >= left && r <= right && t <= top && b >= bottom) {\n        //\n      }\n    }\n  }\n\n  findIntersectPolygons(shapes: Shape<ShapeData>[], includeCover = false) {\n    const polygons = Polygon.getPolygons(shapes).filter((i) => i.uid !== this.uid);\n    const pointsData: polygonClipping.Geom = [[this.points.map((p) => [p.x, p.y])]];\n\n    const intersects: string[] = [];\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const points: polygonClipping.Geom = [[polygon.points.map((p) => [p.x, p.y])]];\n      const intersection = polygonClipping.intersection(pointsData, points);\n      // has crossing, check include\n      if (intersection.length > 0) {\n        const differenceA = polygonClipping.difference(pointsData, points);\n        const differenceB = polygonClipping.difference(points, pointsData);\n        if (differenceA.length > 0 && differenceB.length > 0) {\n          intersects.push(polygon.uid);\n        } else if (includeCover && differenceA.length > 0 && differenceB.length === 0) {\n          // covered polygons\n          intersects.push(polygon.uid);\n        }\n      }\n    }\n\n    return intersects;\n  }\n\n  merge(polygon: Polygon): PolygonData[] {\n    const pointsData: polygonClipping.Geom = [[this.points.map((p) => [p.x, p.y])]];\n    const polygonPoints: polygonClipping.Geom = [[polygon.points.map((p) => [p.x, p.y])]];\n\n    const mergedPolygonPoints = polygonClipping.union(pointsData, polygonPoints);\n    return (mergedPolygonPoints[0] || []).map((points) => ({\n      points: normalizePoints(points),\n    }));\n  }\n\n  subtract(shapes: Shape<ShapeData>[]): PolygonData[][] | null {\n    const polygons = shapes.filter((i) => i.shapeType === ShapeType.POLYGON) as Polygon[];\n    if (polygons.length === 0) {\n      // no intersection\n      return null;\n    }\n\n    const pointsData = [this.points.map((p) => [p.x, p.y] as [number, number])];\n    const polygonsPointsData = polygons.map((i) => [i.points.map((p) => [p.x, p.y] as [number, number])]);\n\n    const subtractData = polygonClipping.difference(pointsData, ...polygonsPointsData);\n    const newSubtractData: {\n      polygon: polygonClipping.Polygon,\n      area: number,\n    }[] = [];\n    const addToNewSubtractData = (polygon: polygonClipping.Polygon) => {\n      const newPolygon = new Flatten.Polygon(polygon[0]);\n      const area = newPolygon.faces.values().next().value.area();\n      newSubtractData.push({\n        polygon, area,\n      });\n    };\n\n    subtractData.forEach((i) => {\n      if (i.length === 1) {\n        // simple polygon, add directly\n        addToNewSubtractData(i);\n      } else if (i.length > 1) {\n        // complex polygon, need split\n        const points = i[0];\n        const innerPolygons = i.slice(1);\n        const innerPolygonCenters = innerPolygons.map((polygon) => {\n          // get visual center of the polygon\n          // ensure polygon contains the center point\n          // otherwise, it may fail to split some concave polygons by the split line\n          // ref: https://blog.mapbox.com/a-new-algorithm-for-finding-a-visual-center-of-a-polygon-7c77e6492fbc\n          const p = polylabel([polygon], 1);\n          return p as [number, number];\n        }).sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0])); // sort from left to right\n\n        const sortedPoints = [...points].sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]));\n        const LPoint = sortedPoints[0];\n        const RPoint = sortedPoints[sortedPoints.length - 1];\n        const LPointIndex = points.findIndex((p) => p[0] === LPoint[0] && p[1] === LPoint[1]);\n        const RPointIndex = points.findIndex((p) => p[0] === RPoint[0] && p[1] === RPoint[1]);\n\n        const splitLine = [LPoint, ...innerPolygonCenters, RPoint];\n        let p1: polygonClipping.Pair[];\n        let p2: polygonClipping.Pair[];\n        if (LPointIndex < RPointIndex) {\n          p1 = [...points.slice(RPointIndex + 1), ...points.slice(0, LPointIndex), ...splitLine];\n          p2 = [...points.slice(LPointIndex + 1, RPointIndex), ...splitLine.reverse()];\n        } else {\n          p1 = [...points.slice(RPointIndex + 1, LPointIndex), ...splitLine];\n          p2 = [...points.slice(LPointIndex + 1), ...points.slice(0, RPointIndex), ...splitLine.reverse()];\n        }\n\n        const innerGeom = innerPolygons.map((p) => [p]);\n        const subtractedPolygons = [\n          ...polygonClipping.difference([p1], [p2], ...innerGeom),\n          ...polygonClipping.difference([p2], [p1], ...innerGeom),\n        ];\n        subtractedPolygons.forEach((polygon) => addToNewSubtractData(polygon));\n      }\n    });\n\n    return newSubtractData\n      .sort((a, b) => b.area - a.area) // sort by area\n      .map((i) => i.polygon.map((points) => ({\n        points: normalizePoints(points),\n      })));\n  }\n\n  /**\n   * set actual points position\n   * reset rotation\n   */\n  rotatePoints() {\n    const points = JSON.parse(JSON.stringify(this.points)) as IPoint[];\n    if (this.rotation !== 0) {\n      points.forEach((p) => {\n        const point = computeRotatedPosition(this.pivot, p, this.rotation);\n        p.x = precise(point.x);\n        p.y = precise(point.y);\n      });\n    }\n    this._rotation = 0;\n    this._updatePosition();\n    this.points = points;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}