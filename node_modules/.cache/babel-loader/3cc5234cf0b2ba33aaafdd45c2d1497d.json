{"ast":null,"code":"import React from 'react';\nimport { makeAutoObservable, runInAction } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { message } from 'antd';\nimport { cloneDeep, debounce } from 'lodash';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport ShapeWorker from '../worker/shape.worker';\nimport InterpolationWorker from '../worker/interpolation.worker';\nimport i18n from '../locales';\nimport { formatFrames, getNextKeyFrames, getShapeTypeByTool, getToolTypeFromFrameData, includeSameTool, isCategoryChangeAllowed, isNumberChangeAllowed, isShapeDataMinified, preciseShapeByType, updateAttributesByFieldsCompare } from '../utils';\nimport { DraggableType, NumberingMode, ViewMode, InstanceItemNumberingMode } from '../types';\nimport { ShapeType } from '../../common/shapes/types';\nimport Message from '../components/message/Message';\nexport const interpolationSupportedShapeTypes = [ShapeType.PIXEL, ShapeType.POLYGON];\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map = {};\n    Object.values(this.instances).forEach(instance => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({\n      className\n    }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.number - b.number);\n      }\n    });\n    return map;\n  }\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    const {\n      categories\n    } = this.rootStore.ontology;\n    return Object.values(this.instances).sort((a, b) => {\n      const instanceAFirstFrame = Number(Object.keys(a.frameStatus)[0]);\n      const instanceBFirstFrame = Number(Object.keys(b.frameStatus)[0]);\n      if (instanceAFirstFrame > instanceBFirstFrame) {\n        return 1;\n      }\n      if (instanceAFirstFrame < instanceBFirstFrame) {\n        return -1;\n      }\n      const instanceACategoryIndex = categories.findIndex(c => c.className === a.category);\n      const instanceBCategoryIndex = categories.findIndex(c => c.className === b.category);\n      if (instanceACategoryIndex > instanceBCategoryIndex) {\n        return 1;\n      }\n      if (instanceACategoryIndex < instanceBCategoryIndex) {\n        return -1;\n      }\n      return a.number > b.number ? 1 : -1;\n    });\n  }\n\n  /**\n   * multiple instance item selected\n   * @getter\n   */\n  get isMultiSelected() {\n    return this.selectedInstances.length > 1 || this.selectedInstanceItems.length > 1;\n  }\n\n  /**\n   * single instance item selected\n   */\n  get isSingleSelected() {\n    return this.selectedInstances.length === 1 && this.selectedInstanceItems.length === 1;\n  }\n\n  /**\n   * does selected instance has label config to set attributes\n   * @getter\n   */\n  get selectedInstanceAttributesEnabled() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return false;\n    }\n    const selectedInstance = this.selectedInstances[0];\n    const selectedInstanceItem = this.selectedInstanceItems.length === 1 ? this.selectedInstanceItems[0] : undefined;\n    return this.isAttributesEnabled(selectedInstance, selectedInstanceItem);\n  }\n\n  /**\n   * is all shapes locked in current frame\n   */\n  get currentLockedStatus() {\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const allInstances = Object.values(this.instances);\n    let currentEmpty = true;\n    let locked = true;\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const status = instance.frameLocked[currentFrame];\n      if (status !== undefined) {\n        currentEmpty = false;\n        if (locked && !status) {\n          locked = false;\n        }\n      }\n      if (!currentEmpty && !locked) {\n        break;\n      }\n    }\n    return {\n      locked,\n      currentEmpty\n    };\n  }\n\n  /**\n   * category locked status\n   */\n  get categoryLockedStatus() {\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const {\n      categories\n    } = this.rootStore.ontology;\n    const allInstances = Object.values(this.instances);\n    const lockedStatus = categories.reduce((acc, curr) => ({\n      ...acc,\n      [curr.className]: {\n        locked: true,\n        currentEmpty: true\n      }\n    }), {});\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const {\n        category\n      } = instance;\n      if (lockedStatus[category].locked || lockedStatus[category].currentEmpty) {\n        const status = instance.frameLocked[currentFrame];\n        if (status !== undefined) {\n          lockedStatus[instance.category].currentEmpty = false;\n          if (lockedStatus[instance.category].locked && !status) {\n            lockedStatus[instance.category].locked = false;\n          }\n        }\n      }\n    }\n    return lockedStatus;\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * all instances\n     */\n    this.instances = {};\n    /**\n     * selected instances\n     */\n    this.selectedInstances = [];\n    /**\n     * selected instance items\n     */\n    this.selectedInstanceItems = [];\n    /**\n     * current dragging type\n     */\n    this.draggingType = DraggableType.INSTANCE;\n    /**\n     * current max instance item number (used when item numbering mode is global)\n     */\n    this.maxInstanceItemNumber = 0;\n    /**\n     * instance items waiting for attributes setting\n     */\n    this.attrPendingInstanceItems = [];\n    /**\n     * last selected pending instance item\n     */\n    this.lastPendingInstanceItem = null;\n    /**\n     * minified shapes\n     */\n    this.minifiedShapes = [];\n    /**\n     * minified shapes count\n     */\n    this.minifiedShapesCount = 0;\n    /**\n     * minified shape resolver\n     */\n    this.minifiedShapeResolver = void 0;\n    /**\n     * interpolation worker\n     */\n    this.interpolator = void 0;\n    /**\n     * interpolated shapes (not add to store yet)\n     */\n    this.interpolatedShapes = {};\n    /**\n     * interpolated success frames\n     */\n    this.interpolatedFrames = new Set();\n    /**\n     * reorganizing instance\n     */\n    this.reorganizingInstance = void 0;\n    /**\n     * instance item name being reorganizing\n     */\n    this.reorganizingInstanceItemName = void 0;\n    /**\n     * reorganizing message\n     */\n    this.reorganizingMsg = void 0;\n    /**\n     * is any category or number change disblaed\n     */\n    this.isAnyCategoryOrNumberChangeDisabled = false;\n    /**\n     * delete frames from instance item\n     * @param instanceItem\n     * @param frames\n     * @param camera\n     */\n    this.deleteFramesFromInstanceItem = (instanceItem, frames, camera = this.rootStore.frame.currentCamera) => {\n      var _this$rootStore$nifti;\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const unlockedFrames = frames.filter(frameIndex => {\n        var _instanceItem$cameras;\n        const frameData = (_instanceItem$cameras = instanceItem.cameras[camera]) === null || _instanceItem$cameras === void 0 ? void 0 : _instanceItem$cameras.frames[frameIndex];\n        return !(frameData === null || frameData === void 0 ? void 0 : frameData.deleteLocked);\n      });\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      if (camera === currentCamera && unlockedFrames.includes(currentFrame)) {\n        var _instanceItem$cameras2;\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        // update segmentation store\n        const {\n          shapeType,\n          layer = this.rootStore.config.activeLayerIndex\n        } = ((_instanceItem$cameras2 = instanceItem.cameras[camera]) === null || _instanceItem$cameras2 === void 0 ? void 0 : _instanceItem$cameras2.frames[currentFrame]) || {};\n        if (shapeType === ShapeType.PIXEL) {\n          this.rootStore.segmentation.update(instanceItem, layer);\n        }\n      }\n\n      // remove relationship\n      const {\n        prevRelationships,\n        currRelationships\n      } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, unlockedFrames);\n      const {\n        prevState,\n        currState\n      } = instanceItem.remove(camera, unlockedFrames);\n      const basicInfo = instanceItem.instance.getBasicInfo();\n      this.rootStore.undo.push({\n        instances: prevState ? [{\n          ...prevBasicInfo,\n          children: [prevState]\n        }] : [],\n        relationships: [...prevRelationships]\n      }, {\n        instances: currState ? [{\n          ...basicInfo,\n          children: [currState]\n        }] : [],\n        relationships: [...currRelationships]\n      });\n      (_this$rootStore$nifti = this.rootStore.nifti) === null || _this$rootStore$nifti === void 0 ? void 0 : _this$rootStore$nifti.updateShape(instanceItem, unlockedFrames);\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instanceItem.instance.isEmpty) {\n        this.deleteInstance(instanceItem.instance);\n      }\n      if (!instanceItem.cameras[camera]) {\n        this.selectInstanceItem(null);\n        this.selectInstance(instanceItem.instance.isEmpty ? null : instanceItem.instance);\n      }\n    };\n    /**\n     * delete frames from instance items\n     * @param instanceItems\n     */\n    this.deleteFramesFromInstanceItems = instanceItems => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const prevInstanceMap = {};\n      const currInstanceMap = {};\n      const prevRelationshipMap = {};\n      const currRelationshipMap = {};\n      for (let i = 0; i < instanceItems.length; i += 1) {\n        var _this$rootStore$nifti2;\n        const {\n          instanceItem,\n          frames,\n          camera = currentCamera\n        } = instanceItems[i];\n        const {\n          instance\n        } = instanceItem;\n        const {\n          id: instanceId\n        } = instance;\n        const unlockedFrames = frames.filter(frameIndex => {\n          var _instanceItem$cameras3;\n          const frameData = (_instanceItem$cameras3 = instanceItem.cameras[camera]) === null || _instanceItem$cameras3 === void 0 ? void 0 : _instanceItem$cameras3.frames[frameIndex];\n          return !(frameData === null || frameData === void 0 ? void 0 : frameData.deleteLocked);\n        });\n        if (camera === currentCamera && unlockedFrames.includes(currentFrame)) {\n          var _instanceItem$cameras4;\n          // remove shape\n          this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n          // update segmentation store\n          const {\n            shapeType,\n            layer = this.rootStore.config.activeLayerIndex\n          } = ((_instanceItem$cameras4 = instanceItem.cameras[camera]) === null || _instanceItem$cameras4 === void 0 ? void 0 : _instanceItem$cameras4.frames[currentFrame]) || {};\n          if (shapeType === ShapeType.PIXEL) {\n            this.rootStore.segmentation.update(instanceItem, layer);\n          }\n        }\n\n        // remove relationship\n        const {\n          prevRelationships,\n          currRelationships\n        } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, unlockedFrames);\n        prevRelationships.forEach(r => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currRelationships.forEach(r => {\n          currRelationshipMap[r.id] = r;\n        });\n        const prevInstanceBasicInfo = instance.getBasicInfo();\n        const {\n          prevState,\n          currState\n        } = instanceItem.remove(camera, unlockedFrames);\n        if (prevState) {\n          if (!prevInstanceMap[instanceId]) {\n            prevInstanceMap[instanceId] = {\n              ...prevInstanceBasicInfo,\n              children: []\n            };\n          }\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n        (_this$rootStore$nifti2 = this.rootStore.nifti) === null || _this$rootStore$nifti2 === void 0 ? void 0 : _this$rootStore$nifti2.updateShape(instanceItem, unlockedFrames);\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instance.isEmpty) {\n          this.deleteInstance(instance);\n        }\n        if (!instanceItem.cameras[camera]) {\n          this.selectInstanceItem(null);\n          this.selectInstance(instance.isEmpty ? null : instance);\n        }\n      }\n      if (Object.values(prevInstanceMap).length > 0) {\n        this.rootStore.undo.push({\n          instances: Object.values(prevInstanceMap),\n          relationships: Object.values(prevRelationshipMap)\n        }, {\n          instances: Object.values(currInstanceMap),\n          relationships: Object.values(currRelationshipMap)\n        });\n      }\n    };\n    this.deleteInstanceItemByFrame = (instanceItem, frame, camera = this.rootStore.frame.currentCamera) => {\n      var _this$rootStore$nifti3;\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const prevInstanceBasicInfo = instanceItem.instance.getBasicInfo();\n      if (camera === currentCamera && frame === currentFrame) {\n        var _instanceItem$cameras5;\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        // update segmentation store\n        const {\n          shapeType,\n          layer = this.rootStore.config.activeLayerIndex\n        } = ((_instanceItem$cameras5 = instanceItem.cameras[camera]) === null || _instanceItem$cameras5 === void 0 ? void 0 : _instanceItem$cameras5.frames[currentFrame]) || {};\n        if (shapeType === ShapeType.PIXEL) {\n          this.rootStore.segmentation.update(instanceItem, layer);\n        }\n      }\n      // remove relationship\n      const {\n        prevRelationships,\n        currRelationships\n      } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [currentFrame]);\n      const {\n        prevState,\n        currState\n      } = instanceItem.remove(camera, [frame]);\n      (_this$rootStore$nifti3 = this.rootStore.nifti) === null || _this$rootStore$nifti3 === void 0 ? void 0 : _this$rootStore$nifti3.updateShape(instanceItem, [frame]);\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instanceItem.instance.isEmpty) {\n        this.deleteInstance(instanceItem.instance);\n      }\n      return {\n        prevState: {\n          instances: prevState ? [{\n            ...prevInstanceBasicInfo,\n            children: [prevState]\n          }] : [],\n          relationships: [...prevRelationships]\n        },\n        currState: {\n          instances: currState ? [{\n            ...instanceItem.instance.getBasicInfo(),\n            children: [currState]\n          }] : [],\n          relationships: [...currRelationships]\n        }\n      };\n    };\n    /**\n     * delete frames from instance item by type\n     * @param instanceItem\n     * @param type\n     * @param camera\n     */\n    this.deleteFramesFromInstanceItemByType = (instanceItem, type = 'current', camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentFrame\n      } = this.rootStore.frame;\n      switch (type) {\n        case 'current':\n          this.deleteFramesFromInstanceItem(instanceItem, [currentFrame]);\n          break;\n        case 'key':\n          {\n            const nextKeyFrames = getNextKeyFrames(1, currentFrame, instanceItem.cameras[camera].frames);\n            const nextKeyFrame = nextKeyFrames[0];\n            if (nextKeyFrame) {\n              this.deleteFramesFromInstanceItem(instanceItem, Array.from({\n                length: nextKeyFrame - currentFrame\n              }).map((_, index) => currentFrame + index));\n            }\n            break;\n          }\n        case 'following':\n          {\n            const allFrames = Object.keys(instanceItem.cameras[camera].frames).map(f => parseInt(f, 10));\n            const index = allFrames.indexOf(currentFrame);\n            this.deleteFramesFromInstanceItem(instanceItem, allFrames.slice(index, allFrames.length));\n            break;\n          }\n        case 'all':\n          {\n            const allFrames = Object.keys(instanceItem.cameras[camera].frames).map(f => parseInt(f, 10));\n            this.deleteFramesFromInstanceItem(instanceItem, allFrames);\n            break;\n          }\n        default:\n      }\n    };\n    /**\n     * show interpolated success message\n     */\n    this.showInterpolatedSuccessMessage = debounce(() => {\n      const frames = Array.from(this.interpolatedFrames).sort((a, b) => a - b);\n      frames.forEach(frameIndex => this.interpolatedFrames.delete(frameIndex));\n      message.success(i18n.translate('INTERPOLATION_FRAMES_SUCCESS', {\n        values: {\n          frames: formatFrames(frames)\n        }\n      }));\n    }, 500);\n    makeAutoObservable(this, {\n      rootStore: false,\n      maxInstanceItemNumber: false,\n      attrPendingInstanceItems: false,\n      lastPendingInstanceItem: false,\n      minifiedShapes: false,\n      minifiedShapeResolver: false,\n      interpolator: false,\n      interpolatedShapes: false,\n      interpolatedFrames: false,\n      reorganizingInstance: false,\n      reorganizingInstanceItemName: false,\n      reorganizingMsg: false,\n      isAnyCategoryOrNumberChangeDisabled: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n  clearInstances() {\n    this.instances = {};\n    this.selectedInstances = [];\n    this.selectedInstanceItems = [];\n  }\n\n  /**\n   * init instances\n   * @param instances\n   * @param fromPreAnnotation\n   */\n  async init(instances, fromPreAnnotation = false) {\n    this.clearInstances();\n    const {\n      categories\n    } = this.rootStore.ontology;\n    const {\n      cameraNames,\n      updateNextShapeOrder\n    } = this.rootStore.frame;\n    const {\n      layers,\n      numberingMode,\n      instanceItemNumberingMode,\n      dataPrecision\n    } = this.rootStore.config;\n    const layersCount = layers.length || 1;\n    const globalInstanceItemNumbers = [];\n    const categoryNumbers = {};\n    const numberDuplicatedInstances = {};\n    instances.forEach(instance => {\n      const category = categories.find(c => c.className === instance.category);\n      if (category) {\n        let instanceNumberChangeDisabled = false;\n        instance.children.forEach(instanceItem => {\n          const categoryItem = category.children.find(c => c.name === instanceItem.name);\n          if (categoryItem) {\n            instanceItem.cameras.forEach(cameraData => {\n              if (cameraNames.includes(cameraData.camera)) {\n                cameraData.frames.forEach(frameData => {\n                  var _frameData$preAnnotat, _frameData$preAnnotat2;\n                  // fix shape data precision\n                  preciseShapeByType(frameData.shapeType, frameData.shape, dataPrecision);\n                  // fix shape layer\n                  if (frameData.layer === undefined || frameData.layer >= layersCount || frameData.layer < 0) {\n                    frameData.layer = 0;\n                  }\n                  // update next shape order\n                  if (typeof frameData.order === 'number' && frameData.order >= 0) {\n                    updateNextShapeOrder(frameData.order, frameData.layer, frameData.frameIndex, cameraData.camera);\n                  }\n                  // check minified\n                  if (isShapeDataMinified(frameData.shapeType, frameData.shape)) {\n                    this.minifiedShapes.push({\n                      instanceId: instance.id,\n                      instanceItemId: instanceItem.id,\n                      camera: cameraData.camera,\n                      frameIndex: frameData.frameIndex,\n                      shapeType: frameData.shapeType,\n                      shape: frameData.shape\n                    });\n                    this.minifiedShapesCount += 1;\n                  }\n                  // set raw status\n                  frameData.isRaw = frameData.isRaw || fromPreAnnotation;\n                  // set category change disabled status\n                  instanceNumberChangeDisabled = instanceNumberChangeDisabled || !isNumberChangeAllowed((_frameData$preAnnotat = frameData.preAnnotationData) === null || _frameData$preAnnotat === void 0 ? void 0 : _frameData$preAnnotat.editMode);\n                  this.isAnyCategoryOrNumberChangeDisabled = this.isAnyCategoryOrNumberChangeDisabled || instanceNumberChangeDisabled || !isCategoryChangeAllowed((_frameData$preAnnotat2 = frameData.preAnnotationData) === null || _frameData$preAnnotat2 === void 0 ? void 0 : _frameData$preAnnotat2.editMode);\n                });\n              } else {\n                cameraData.frames = [];\n              }\n            });\n            instanceItem.cameras = instanceItem.cameras.filter(c => c.frames.length > 0); // remove invalid camera data\n          } else {\n            instanceItem.cameras = [];\n          }\n        });\n        instance.children = instance.children.filter(i => i.cameras.length > 0); // remove invalid instance item data\n        if (instance.children.length > 0) {\n          var _numberDuplicatedInst;\n          // check instance item number\n          if (instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL) {\n            instance.children.forEach(child => {\n              if (this.rootStore.annotatable && globalInstanceItemNumbers.indexOf(child.number) >= 0) {\n                if (!numberDuplicatedInstances[instance.id]) {\n                  numberDuplicatedInstances[instance.id] = {\n                    instance,\n                    fixInstance: false,\n                    fixItems: []\n                  };\n                }\n                numberDuplicatedInstances[instance.id].fixItems.push(child.id);\n              } else {\n                globalInstanceItemNumbers.push(child.number);\n                if (child.number > this.maxInstanceItemNumber) {\n                  this.maxInstanceItemNumber = child.number;\n                }\n              }\n            });\n          }\n\n          // check instance number\n          if (!categoryNumbers[category.className]) {\n            categoryNumbers[category.className] = [];\n          }\n          const checkNumbers = numberingMode === NumberingMode.GLOBAL ? Object.values(categoryNumbers).flatMap(n => n) : categoryNumbers[category.className];\n          if (this.rootStore.annotatable && !instanceNumberChangeDisabled && checkNumbers.indexOf(instance.number) >= 0) {\n            // number already exists, fix number later\n            if (!numberDuplicatedInstances[instance.id]) {\n              numberDuplicatedInstances[instance.id] = {\n                instance,\n                fixInstance: true\n              };\n            } else {\n              numberDuplicatedInstances[instance.id].fixInstance = true;\n            }\n          } else {\n            categoryNumbers[category.className].push(instance.number);\n          }\n\n          // noneed to fix number\n          if (!((_numberDuplicatedInst = numberDuplicatedInstances[instance.id]) === null || _numberDuplicatedInst === void 0 ? void 0 : _numberDuplicatedInst.fixInstance)) {\n            this.createInstanceFromData(instance);\n          }\n        }\n      }\n    });\n    Object.values(numberDuplicatedInstances).forEach(({\n      instance,\n      fixInstance,\n      fixItems\n    }) => {\n      if (fixInstance) {\n        const number = this.getNextInstanceNumber(instance.category);\n        instance.number = number;\n        this.createInstanceFromData(instance);\n      }\n      const currInstance = this.instances[instance.id];\n      if (currInstance) {\n        fixItems === null || fixItems === void 0 ? void 0 : fixItems.forEach(itemId => {\n          const item = instance.children.find(i => i.id === itemId);\n          if (item) {\n            const number = this.getNextInstanceItemNumber(instance.id, item.name);\n            item.number = number;\n            currInstance.createItemFromData(item);\n          }\n        });\n      }\n    });\n    this.resolveMinifiedShapes();\n  }\n\n  /**\n   * create instance from structured instance data\n   * @param instance\n   */\n  createInstanceFromData(instance) {\n    const category = this.rootStore.ontology.getCategory(instance.category);\n    if (category) {\n      const {\n        instanceItemNumberingMode,\n        dataPrecision\n      } = this.rootStore.config;\n      const forceMultiple = instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL;\n      const newInstance = new Instance({\n        id: instance.id,\n        categoryRef: category,\n        currentWorkerId: this.rootStore.jobProxy.workerId,\n        currentWorkerName: this.rootStore.jobProxy.workerName,\n        forceMultiple,\n        dataPrecision,\n        number: instance.number,\n        attributes: instance.attributes,\n        dynamicAttributes: instance.dynamicAttributes,\n        items: instance.children,\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder\n      });\n      this.instances[newInstance.id] = newInstance;\n    }\n  }\n\n  /**\n   * resolve minified shapes\n   */\n  resolveMinifiedShapes() {\n    if (this.minifiedShapes.length > 0) {\n      if (!this.minifiedShapeResolver) {\n        this.minifiedShapeResolver = new ShapeWorker();\n        this.minifiedShapeResolver.addEventListener('message', e => {\n          const {\n            instanceId,\n            instanceItemId,\n            camera,\n            frameIndex,\n            shape\n          } = e.data;\n          const instance = this.instances[instanceId];\n          if (instance) {\n            const instanceItem = instance.items[instanceItemId];\n            if (instanceItem) {\n              const cameraData = instanceItem.cameras[camera];\n              if (cameraData) {\n                const frameData = cameraData.frames[frameIndex];\n                if (frameData && !frameData.shapeUpdated) {\n                  // only update when shape data haven't been updated\n                  runInAction(() => {\n                    frameData.shape = shape;\n                  });\n                }\n              }\n            }\n          }\n          // continue\n          this.resolveMinifiedShapes();\n        });\n      }\n      this.minifiedShapesCount -= 1;\n      const item = this.minifiedShapes.pop();\n      this.minifiedShapeResolver.postMessage(item);\n    }\n  }\n\n  /**\n   * is instance attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceAttributesEnabled(instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfig;\n  }\n\n  /**\n   * is instance dynamic attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceDynamicAttributesEnabled(instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfigDynamic;\n  }\n\n  /**\n   * is instance item attributes enabled\n   * @param instanceItem\n   */\n  isInstanceItemAttributesEnabled(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        if (frameData.isOCR || frameData.isFormula) {\n          // instance item currently is ocr shape or formula shape\n          return true;\n        }\n        if (instanceItem.categoryItemRef.labelConfig) {\n          // instance item has label config setting\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * is instance & instance item attributes enabled\n   * @param instance\n   * @param instanceItem\n   */\n  isAttributesEnabled(instance, instanceItem) {\n    const instanceAttributesEnabled = this.isInstanceAttributesEnabled(instance);\n    if (instanceAttributesEnabled) {\n      return true;\n    }\n    const instanceDynamicAttributesEnabled = this.isInstanceDynamicAttributesEnabled(instance);\n    if (instanceDynamicAttributesEnabled) {\n      return true;\n    }\n    if (instanceItem) {\n      return this.isInstanceItemAttributesEnabled(instanceItem);\n    }\n    return Object.values(instance.items).some(item => this.isInstanceItemAttributesEnabled(item));\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * get next instance number\n   * @param categoryName\n   */\n  getNextInstanceNumber(categoryName) {\n    if (this.rootStore.config.numberingMode === NumberingMode.GLOBAL) {\n      const allInstanceNumbers = Object.values(this.instances).map(i => i.number);\n      return Math.max(...allInstanceNumbers, 0) + 1;\n    }\n    const categoryInstanceNumbers = (this.categoryInstancesMap[categoryName] || []).map(i => i.number);\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * get next instance item number\n   * @param instanceId\n   * @param categoryItemName\n   * @param camera\n   */\n  getNextInstanceItemNumber(instanceId, categoryItemName, camera = this.rootStore.frame.currentCamera) {\n    if (this.rootStore.config.instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL) {\n      this.maxInstanceItemNumber += 1;\n      return this.maxInstanceItemNumber;\n    }\n    const instance = this.instances[instanceId];\n    const items = Object.values(instance.items).filter(i => i.name === categoryItemName);\n    const itemsInCamera = items.filter(i => {\n      const cameraData = i.cameras[camera];\n      return cameraData && !cameraData.isEmpty;\n    });\n    const itemNumbers = itemsInCamera.map(i => i.number);\n    return Math.max(...itemNumbers, 0) + 1;\n  }\n\n  /**\n   * update selected instance\n   * @param instance\n   */\n  updateSelectedInstance(instance) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances.forEach(i => {\n      if (instances.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstances = [...instances];\n    this.selectedInstances.forEach(i => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * update selected instance item\n   * @param instanceItem\n   */\n  updateSelectedInstanceItem(instanceItem) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems.forEach(i => {\n      if (instanceItems.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstanceItems = [...instanceItems];\n    this.selectedInstanceItems.forEach(i => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * select instance\n   * @param instance\n   * @param autoFocus\n   * @param shouldPredict\n   */\n  selectInstance(instance, autoFocus = false, shouldPredict = true) {\n    const instances = Array.isArray(instance) ? instance : [...(instance ? [instance] : [])];\n    this.updateSelectedInstance(instances);\n    if (instances.length > 0) {\n      // filter selected instance item\n      const instanceItems = this.selectedInstanceItems.filter(i => instances.indexOf(i.instance) >= 0);\n\n      // if the instance is single, default select first instance item\n      if (this.rootStore.frame.isSingleCamera) {\n        instances.forEach(i => {\n          if (i.isSingle && Object.keys(i.items).length > 0) {\n            const item = Object.values(i.items)[0];\n            if (instanceItems.indexOf(item) < 0) {\n              instanceItems.push(item);\n            }\n          }\n        });\n      }\n      this.updateSelectedInstanceItem(instanceItems);\n\n      // select category & category item if needed\n      if (instanceItems.length === 1) {\n        // only one item is selected\n        this.rootStore.ontology.selectCategory(instanceItems[0].instance.category);\n        this.rootStore.ontology.selectCategoryItem(instanceItems[0].name);\n      } else {\n        // select first category if needed\n        const allCategories = instances.map(i => i.category);\n        if (allCategories.indexOf(this.rootStore.ontology.selectedCategoryName) < 0) {\n          this.rootStore.ontology.selectCategory(allCategories[0]);\n        }\n      }\n    } else {\n      this.updateSelectedInstanceItem([]);\n    }\n\n    // update shape selection\n    this.rootStore.shape.selectShapeByInstanceItem(this.selectedInstanceItems, shouldPredict);\n    this.rootStore.shape.updateShapesInInstance(instances);\n    if (autoFocus) {\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        this.rootStore.shape.fitShapes();\n      } else {\n        // this.rootStore.grid.gridCanvas?.fitShapes();\n      }\n    }\n  }\n\n  /**\n   * select instance item\n   * @param instanceItem\n   * @param autoFocus\n   * @param shouldPredict\n   */\n  selectInstanceItem(instanceItem, autoFocus = false, shouldPredict = true) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...(instanceItem ? [instanceItem] : [])];\n    this.updateSelectedInstanceItem(instanceItems);\n    const instanceSet = new Set(instanceItems.map(i => i.instance));\n    const instances = Array.from(instanceSet);\n    this.selectInstance(instances, autoFocus, shouldPredict);\n  }\n\n  /**\n   * update active layer index by instance items\n   * @param instanceItems\n   */\n  updateActiveLayerIndexByInstanceItems(instanceItems) {\n    const {\n      layers,\n      activeLayerIndex\n    } = this.rootStore.config;\n    if (layers.length === 0) {\n      // not multi layers\n      return;\n    }\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const allLayers = new Set();\n    instanceItems.forEach(instanceItem => {\n      var _instanceItem$cameras6;\n      const {\n        layer = activeLayerIndex\n      } = ((_instanceItem$cameras6 = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras6 === void 0 ? void 0 : _instanceItem$cameras6.frames[currentFrame]) || {};\n      allLayers.add(layer);\n    });\n    if (!allLayers.has(activeLayerIndex) && allLayers.size > 0) {\n      const allLayersArr = Array.from(allLayers);\n      this.rootStore.config.setActiveLayerIndex(allLayersArr[0]);\n    }\n  }\n\n  /**\n   * get current editing instance item\n   */\n  getCurrentInstanceItem(currentCategoryName = this.rootStore.ontology.selectedCategoryName, currentCategoryItemName = this.rootStore.ontology.selectedCategoryItemName, create = true) {\n    const selectedInstance = this.selectedInstances.find(i => i.category === currentCategoryName) || this.selectedInstances[0];\n    if (selectedInstance && selectedInstance.category === currentCategoryName) {\n      const selectedInstanceItems = this.selectedInstanceItems.filter(i => i.instance === selectedInstance);\n      const selectedInstanceItem = selectedInstanceItems.find(i => i.name === currentCategoryItemName) || selectedInstanceItems[0];\n      if (selectedInstanceItem && selectedInstanceItem.name === currentCategoryItemName) {\n        // has selected instance item\n        const {\n          currentCamera,\n          currentFrame\n        } = this.rootStore.frame;\n        const {\n          frames\n        } = selectedInstanceItem.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          // not exist in current frame\n          return selectedInstanceItem;\n        }\n      }\n      if (!create) {\n        return undefined;\n      }\n      const category = this.rootStore.ontology.getCategoryItem(currentCategoryName, currentCategoryItemName);\n      if (category) {\n        const {\n          currentCamera\n        } = this.rootStore.frame;\n        const {\n          name,\n          count,\n          maxCount = Infinity\n        } = category;\n        // find items exist in current camera\n        const isGlobalItem = this.rootStore.config.instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL;\n        const items = selectedInstance.getItemsByName(name).filter(i => {\n          const cameraData = i.cameras[currentCamera];\n          return isGlobalItem || cameraData && !cameraData.isEmpty;\n        });\n        if (count !== undefined && items.length < count || count === undefined && items.length < maxCount) {\n          return this.createInstanceItem(selectedInstance, currentCategoryItemName);\n        }\n      }\n    }\n    if (!create) {\n      return undefined;\n    }\n    // return a new instance\n    const instance = this.createInstance(currentCategoryName);\n    return this.createInstanceItem(instance, currentCategoryItemName);\n  }\n\n  /**\n   * get instance item for paste\n   * @param shapeType\n   */\n  getInstanceItemForPaste(shapeType) {\n    const {\n      selectedCategory\n    } = this.rootStore.ontology;\n    const supportedCategoryItems = [];\n    selectedCategory.children.forEach(item => {\n      const shapeTypes = new Set(item.tools.map(tool => getShapeTypeByTool(tool.type)));\n      if (shapeTypes.has(shapeType)) {\n        supportedCategoryItems.push(item);\n      }\n    });\n    if (supportedCategoryItems.length <= 0) {\n      // no avaliable category items\n      return null;\n    }\n    const supportedCategoryItemNames = supportedCategoryItems.map(i => i.name);\n    const selectedInstance = this.selectedInstances.find(i => i.category === selectedCategory.className);\n    if (selectedInstance) {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const supportedSelectedInstanceItems = this.selectedInstanceItems.filter(i => i.instance === selectedInstance && supportedCategoryItemNames.includes(i.name));\n      let instanceItem;\n      let i = 0;\n      while (!instanceItem && i < supportedSelectedInstanceItems.length) {\n        const item = supportedSelectedInstanceItems[i];\n        const {\n          frames\n        } = item.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          instanceItem = item;\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // find selected empty instance item\n      }\n      i = 0;\n      while (!instanceItem && i < supportedCategoryItems.length) {\n        const categoryItem = supportedCategoryItems[i];\n        const {\n          name,\n          count,\n          maxCount = Infinity\n        } = categoryItem;\n        const items = selectedInstance.getItemsByName(name);\n        if (count !== undefined && items.length < count || count === undefined && items.length < maxCount) {\n          instanceItem = this.createInstanceItem(selectedInstance, name);\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // new instance item\n      }\n    }\n    const instance = this.createInstance(selectedCategory.className);\n    return this.createInstanceItem(instance, supportedCategoryItemNames[0]);\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   * @param defaultNumber\n   */\n  createInstance(categoryName = this.rootStore.ontology.selectedCategory.className, defaultNumber) {\n    const category = this.rootStore.ontology.getCategory(categoryName);\n    if (category) {\n      const {\n        instanceItemNumberingMode,\n        dataPrecision\n      } = this.rootStore.config;\n      const forceMultiple = instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL;\n      const instance = new Instance({\n        categoryRef: category,\n        currentWorkerId: this.rootStore.jobProxy.workerId,\n        currentWorkerName: this.rootStore.jobProxy.workerName,\n        forceMultiple,\n        dataPrecision,\n        number: defaultNumber !== undefined ? defaultNumber : this.getNextInstanceNumber(categoryName),\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder\n      });\n      this.instances[instance.id] = instance;\n      return instance;\n    }\n    return undefined;\n  }\n\n  /**\n   * create instance item\n   * @param instance\n   * @param categoryItem\n   * @param defaultNumber\n   */\n  createInstanceItem(instance, categoryItem = this.rootStore.ontology.selectedCategoryItem.name, defaultNumber) {\n    const number = defaultNumber !== undefined ? defaultNumber : this.getNextInstanceItemNumber(instance.id, categoryItem);\n    const existItem = instance.getItem(categoryItem, number);\n    if (existItem) {\n      return existItem;\n    }\n    // create\n    const {\n      children = []\n    } = instance.categoryRef;\n    const item = children.find(c => c.name === categoryItem);\n    const instanceItem = new InstanceItem({\n      instance,\n      categoryItemRef: item || children[0],\n      number\n    });\n    instance.items[instanceItem.id] = instanceItem;\n    return instanceItem;\n  }\n\n  /**\n   * delete instance\n   * @param instance\n   */\n  deleteInstance(instance) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances = this.selectedInstances.filter(i => instances.indexOf(i) < 0);\n    this.selectedInstanceItems = this.selectedInstanceItems.filter(i => instances.indexOf(i.instance) < 0);\n    instances.forEach(i => {\n      i.destroy();\n      delete this.instances[i.id];\n    });\n  }\n\n  /**\n   * delete instance item\n   * @param instanceItem\n   */\n  deleteInstanceItem(instanceItem) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems = this.selectedInstanceItems.filter(i => instanceItems.indexOf(i) < 0);\n    instanceItems.forEach(({\n      id,\n      instance\n    }) => {\n      instance.removeItem(id);\n    });\n  }\n  /**\n   * update frame shape info for instance item\n   * @param instanceItem\n   * @param frameIndex\n   * @param shapeType\n   * @param shape\n   * @param layer\n   * @param order\n   * @param camera\n   */\n  updateFrameShapeForInstanceItem(instanceItem, frameIndex, shapeType, shape, layer, order, camera = this.rootStore.frame.currentCamera) {\n    var _this$rootStore$nifti4;\n    const {\n      autoInterpolation,\n      activeLayerIndex\n    } = this.rootStore.config;\n    let shapeLayer = layer;\n    if (shapeLayer === undefined) {\n      var _instanceItem$cameras7;\n      const frameData = (_instanceItem$cameras7 = instanceItem.cameras[camera]) === null || _instanceItem$cameras7 === void 0 ? void 0 : _instanceItem$cameras7.frames[frameIndex];\n      if ((frameData === null || frameData === void 0 ? void 0 : frameData.layer) !== undefined) {\n        shapeLayer = frameData.layer;\n      } else {\n        shapeLayer = activeLayerIndex;\n      }\n    }\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    const {\n      prevState,\n      currState\n    } = instanceItem.updateShape(camera, frameIndex, autoInterpolation && shapeType !== ShapeType.PIXEL, shapeType, shape, shapeLayer, order);\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    const instanceState = {\n      [basicInfo.id]: {\n        prev: {\n          ...prevBasicInfo,\n          children: prevState ? [prevState] : []\n        },\n        curr: {\n          ...basicInfo,\n          children: currState ? [currState] : []\n        }\n      }\n    };\n    const relationshipState = {\n      prev: [],\n      curr: []\n    };\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    if (shapeType === ShapeType.PIXEL && camera === currentCamera && frameIndex === currentFrame) {\n      const stat = this.rootStore.segmentation.update(instanceItem, shapeLayer, shape);\n      if (stat) {\n        Object.keys(stat.instanceState).forEach(id => {\n          if (instanceState[id]) {\n            const {\n              prev,\n              curr\n            } = stat.instanceState[id];\n            instanceState[id].prev.children = [...instanceState[id].prev.children, ...prev.children];\n            instanceState[id].curr.children = [...instanceState[id].curr.children, ...curr.children];\n          } else {\n            instanceState[id] = stat.instanceState[id];\n          }\n        });\n        relationshipState.prev = stat.relationshipState.prev;\n        relationshipState.curr = stat.relationshipState.curr;\n      }\n    }\n    (_this$rootStore$nifti4 = this.rootStore.nifti) === null || _this$rootStore$nifti4 === void 0 ? void 0 : _this$rootStore$nifti4.updateShape(instanceItem, [frameIndex]);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map(i => i.prev),\n      relationships: relationshipState.prev\n    }, {\n      instances: Object.values(instanceState).map(i => i.curr),\n      relationships: relationshipState.curr\n    });\n  }\n\n  /**\n   * update frame shape info for instance items list\n   * @param instanceItems\n   */\n  updateFrameShapeForInstanceItems(instanceItems) {\n    const prevInstanceMap = {};\n    const currInstanceMap = {};\n    const prevRelationshipMap = {};\n    const currRelationshipMap = {};\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      var _this$rootStore$nifti5;\n      const {\n        instanceItem,\n        frameIndex,\n        shapeType,\n        shape,\n        layer,\n        order,\n        camera = this.rootStore.frame.currentCamera\n      } = instanceItems[i];\n      let state;\n      const {\n        autoInterpolation,\n        activeLayerIndex\n      } = this.rootStore.config;\n      let shapeLayer = layer;\n      if (shapeLayer === undefined) {\n        var _instanceItem$cameras8;\n        const frameData = (_instanceItem$cameras8 = instanceItem.cameras[camera]) === null || _instanceItem$cameras8 === void 0 ? void 0 : _instanceItem$cameras8.frames[frameIndex];\n        if ((frameData === null || frameData === void 0 ? void 0 : frameData.layer) !== undefined) {\n          shapeLayer = frameData.layer;\n        } else {\n          shapeLayer = activeLayerIndex;\n        }\n      }\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      if (shape) {\n        // update\n        state = instanceItem.updateShape(camera, frameIndex, autoInterpolation && shapeType !== ShapeType.PIXEL, shapeType, shape, shapeLayer, order);\n        if (shapeType === ShapeType.PIXEL && camera === currentCamera && frameIndex === currentFrame) {\n          const stat = this.rootStore.segmentation.update(instanceItem, shapeLayer, shape);\n          if (stat) {\n            Object.keys(stat.instanceState).forEach(id => {\n              const {\n                prev,\n                curr\n              } = stat.instanceState[id];\n              if (!prevInstanceMap[id]) {\n                prevInstanceMap[id] = prev;\n              }\n              currInstanceMap[id] = curr;\n            });\n            stat.relationshipState.prev.forEach(r => {\n              if (!prevRelationshipMap[r.id]) {\n                prevRelationshipMap[r.id] = r;\n              }\n            });\n            stat.relationshipState.curr.forEach(r => {\n              currRelationshipMap[r.id] = r;\n            });\n          }\n        }\n      } else {\n        // delete\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        // delete relationship\n        const {\n          prevRelationships,\n          currRelationships\n        } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [this.rootStore.frame.currentFrame]);\n        prevRelationships.forEach(r => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currRelationships.forEach(r => {\n          currRelationshipMap[r.id] = r;\n        });\n        state = instanceItem.remove(camera, [frameIndex]);\n        if (shapeType === ShapeType.PIXEL) {\n          this.rootStore.segmentation.update(instanceItem, shapeLayer);\n        }\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instanceItem.instance.isEmpty) {\n          this.deleteInstance(instanceItem.instance);\n        }\n        if (!instanceItem.cameras[camera]) {\n          this.selectInstanceItem(null);\n          this.selectInstance(instanceItem.instance.isEmpty ? null : instanceItem.instance);\n        }\n      }\n      if (state) {\n        const {\n          prevState,\n          currState\n        } = state;\n        const {\n          instance\n        } = instanceItem;\n        const {\n          id: instanceId\n        } = instance;\n        if (!prevInstanceMap[instanceId]) {\n          prevInstanceMap[instanceId] = {\n            ...prevBasicInfo,\n            children: []\n          };\n        }\n        if (prevState) {\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n      }\n      (_this$rootStore$nifti5 = this.rootStore.nifti) === null || _this$rootStore$nifti5 === void 0 ? void 0 : _this$rootStore$nifti5.updateShape(instanceItem, [frameIndex]);\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n      relationships: Object.values(prevRelationshipMap)\n    }, {\n      instances: Object.values(currInstanceMap),\n      relationships: Object.values(currRelationshipMap)\n    });\n  }\n\n  /**\n   * move instance item\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param targetInstanceId\n   * @param targetInstanceItemId\n   * @param frames\n   * @param newInstanceAttr\n   * @param newInstanceItemAttr\n   */\n  moveInstanceItem(targetCategory, targetCategoryItem, targetInstanceId, targetInstanceItemId, frames, newDynamicInstanceAttr, newInstanceAttr, newInstanceItemAttr) {\n    if (!this.isSingleSelected) {\n      return;\n    }\n    const selectedInstanceItem = this.selectedInstanceItems[0];\n    const currPrevInstance = selectedInstanceItem.instance.getBasicInfo();\n    const targetInstance = targetInstanceId === 'new' ? this.createInstance(targetCategory) : this.instances[targetInstanceId];\n    if (targetInstance) {\n      const targetPrevInstance = targetInstance.getBasicInfo();\n      const targetInstanceItemDefaultNumber = this.rootStore.config.instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL ? selectedInstanceItem.number : undefined;\n      const targetInstanceItem = targetInstanceItemId === 'new' ? this.createInstanceItem(targetInstance, targetCategoryItem, targetInstanceItemDefaultNumber) : targetInstance.items[targetInstanceItemId];\n      if (targetInstanceItem) {\n        var _targetInstance$dynam;\n        // FIXME: current only support single camera\n        const {\n          currentCamera,\n          currentFrame\n        } = this.rootStore.frame;\n\n        // update target instance item\n        let currIsPixelShape = false;\n        const currInstanceItem = selectedInstanceItem;\n        const framesData = frames.map(frameIndex => {\n          const frameJson = currInstanceItem.cameras[currentCamera].frames[frameIndex].toJSON();\n          if (frameIndex === currentFrame && frameJson.shapeType === ShapeType.PIXEL) {\n            currIsPixelShape = true;\n          }\n          if (targetCategory === currInstanceItem.instance.category && targetCategoryItem === currInstanceItem.name) {\n            return frameJson;\n          }\n          if (newInstanceItemAttr) {\n            frameJson.attributes = newInstanceItemAttr;\n          } else {\n            delete frameJson.attributes;\n          }\n          return frameJson;\n        });\n        const {\n          prevState: targetPrevState,\n          currState: targetCurrState\n        } = targetInstanceItem.updateFramesFromData(currentCamera, framesData);\n        if (newInstanceAttr) {\n          targetInstance.setAttributes(newInstanceAttr);\n        }\n        // update relationships\n        const prevRelationships = {};\n        const currRelationships = {};\n        currInstanceItem.cameras[currentCamera].relationships.forEach(r => {\n          if (!prevRelationships[r.id]) {\n            prevRelationships[r.id] = r.toJSON();\n          }\n          r.deleteFromFrames(frames);\n          this.rootStore.relationship.deleteConnection(r);\n          this.rootStore.relationship.createConnection(r);\n          currRelationships[r.id] = r.toJSON();\n        });\n        // remove from current instance item\n        const {\n          prevState,\n          currState\n        } = currInstanceItem.remove(currentCamera, frames);\n\n        // update instance dynamic attributes\n        if (newDynamicInstanceAttr && !((_targetInstance$dynam = targetInstance.dynamicAttributes) === null || _targetInstance$dynam === void 0 ? void 0 : _targetInstance$dynam[currentCamera])) {\n          targetInstance.setDynamicAttributesByCamera(currentCamera, newDynamicInstanceAttr);\n        }\n        if (currInstanceItem.isEmpty) {\n          this.deleteInstanceItem(currInstanceItem);\n        }\n        if (currInstanceItem.instance.isEmpty) {\n          this.deleteInstance(currInstanceItem.instance);\n        }\n        const targetCurrInstance = targetInstance.getBasicInfo();\n        // update state\n        if (currInstanceItem.instance.id === targetInstanceItem.instance.id) {\n          // same instance\n          const prevInstance = {\n            ...targetPrevInstance,\n            children: []\n          }; // target instance old\n          if (targetPrevState) {\n            prevInstance.children.push(targetPrevState);\n          }\n          if (prevState) {\n            prevInstance.children.push(prevState);\n          }\n          const currInstance = {\n            ...targetCurrInstance,\n            children: []\n          };\n          if (targetCurrState) {\n            currInstance.children.push(targetCurrState);\n          }\n          if (currState) {\n            currInstance.children.push(currState);\n          }\n          this.rootStore.undo.push({\n            instances: prevInstance.children.length > 0 ? [prevInstance] : [],\n            relationships: Object.values(prevRelationships)\n          }, {\n            instances: currInstance.children.length > 0 ? [currInstance] : [],\n            relationships: Object.values(currRelationships)\n          });\n        } else {\n          this.rootStore.undo.push({\n            instances: [...(prevState ? [{\n              ...currPrevInstance,\n              children: prevState ? [prevState] : []\n            }] : []), ...(targetPrevState ? [{\n              ...targetPrevInstance,\n              children: targetPrevState ? [targetPrevState] : []\n            }] : [])],\n            relationships: Object.values(prevRelationships)\n          }, {\n            instances: [{\n              ...targetCurrInstance,\n              children: currState ? [currState] : []\n            }, {\n              ...targetCurrInstance,\n              children: targetCurrState ? [targetCurrState] : []\n            }],\n            relationships: Object.values(currRelationships)\n          });\n        }\n\n        // change instance item\n        if (currIsPixelShape) {\n          this.rootStore.segmentation.changeInstanceItemForInfoMap(currInstanceItem, targetInstanceItem);\n        }\n        // uppdate shapes\n        const currentShape = this.rootStore.shape.getShapeByInstanceItem(currInstanceItem);\n        if (currentShape) {\n          this.rootStore.shape.deleteShape(currentShape);\n        }\n        this.rootStore.shape.setupShape(targetInstanceItem);\n      }\n    }\n  }\n\n  /**\n   * get target instance & affected instance with same number\n   * @param sourceInstance\n   * @param targetCategory\n   * @param targetInstanceNum\n   */\n  getTargetInstance(sourceInstance, targetCategory, targetInstanceNum) {\n    const {\n      numberingMode\n    } = this.rootStore.config;\n    let targetInstance;\n    let isTargetInstanceNewCreated = false;\n    let affectedInstanceInGlobalMode;\n    if (targetInstanceNum !== undefined) {\n      targetInstance = Object.values(this.instances).find(i => i.category === targetCategory && i.number === targetInstanceNum);\n      // if not found, find same number when in global mode\n      if (!targetInstance && numberingMode === NumberingMode.GLOBAL) {\n        affectedInstanceInGlobalMode = Object.values(this.instances).find(i => i.number === targetInstanceNum);\n      }\n    }\n    if (!targetInstance) {\n      var _affectedInstanceInGl;\n      if (!((_affectedInstanceInGl = affectedInstanceInGlobalMode) === null || _affectedInstanceInGl === void 0 ? void 0 : _affectedInstanceInGl.isNumberChangeDisabled)) {\n        targetInstance = this.createInstance(targetCategory, targetInstanceNum);\n      }\n      if (targetInstance) {\n        var _sourceInstance$categ, _targetInstance$categ;\n        isTargetInstanceNewCreated = true;\n        // set instance attributes\n        const newInstanceAttributes = updateAttributesByFieldsCompare(((_sourceInstance$categ = sourceInstance.categoryRef.labelConfig) === null || _sourceInstance$categ === void 0 ? void 0 : _sourceInstance$categ.fields) || [], ((_targetInstance$categ = targetInstance.categoryRef.labelConfig) === null || _targetInstance$categ === void 0 ? void 0 : _targetInstance$categ.fields) || [], sourceInstance.attributes, {});\n        targetInstance.setAttributes(newInstanceAttributes);\n      }\n    }\n    return {\n      targetInstance,\n      isTargetInstanceNewCreated,\n      affectedInstanceInGlobalMode\n    };\n  }\n\n  /**\n   * get target instance item in target instance\n   * @param targetInstance\n   * @param targetCategoryItem\n   * @param isTargetInstanceNewCreated\n   * @param sourceInstanceItemNumber\n   */\n  getTargetInstanceItem(targetInstance, targetCategoryItem, isTargetInstanceNewCreated, sourceInstanceItemNumber) {\n    var _targetInstance$categ2;\n    const existingItems = targetInstance.getItemsByName(targetCategoryItem);\n    const existingItemWithSameNumber = existingItems.find(i => i.number === sourceInstanceItemNumber);\n    if (existingItemWithSameNumber) {\n      return existingItemWithSameNumber;\n    }\n    const isSingle = ((_targetInstance$categ2 = targetInstance.categoryRef.children.find(c => c.name === targetCategoryItem)) === null || _targetInstance$categ2 === void 0 ? void 0 : _targetInstance$categ2.count) === 1;\n    if (isSingle && existingItems.length > 1) {\n      throw new Error(i18n.translate('CHANGE_CATEGORY_ERROR_ITEM_COUNT'));\n    }\n    const {\n      instanceItemNumberingMode\n    } = this.rootStore.config;\n    let targetInstanceItem;\n    if (isSingle && existingItems.length === 1) {\n      targetInstanceItem = existingItems[0];\n    }\n    if (!targetInstanceItem) {\n      let targetInstanceItemNumber;\n      if (instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL) {\n        if (isTargetInstanceNewCreated) {\n          // keep item number in global mode when target instance is newly created\n          targetInstanceItemNumber = sourceInstanceItemNumber;\n        }\n      } else if (!isSingle && existingItems.findIndex(item => item.number === sourceInstanceItemNumber) < 0) {\n        // multi-item instance, keep item number if not exist\n        targetInstanceItemNumber = sourceInstanceItemNumber;\n      }\n      targetInstanceItem = this.createInstanceItem(targetInstance, targetCategoryItem, targetInstanceItemNumber);\n    }\n    return targetInstanceItem;\n  }\n\n  /**\n   * change category for instance item\n   * @param sourceInstanceItem\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param affectedCameraFrames\n   * @param targetInstanceNum\n   */\n  changeCategoryForInstanceItemPure(sourceInstanceItem, targetCategory, targetCategoryItem, affectedCameraFrames, targetInstanceNum) {\n    var _this$reorganizingIns, _this$reorganizingIns2, _this$reorganizingIns3;\n    const {\n      categoryItemRef: sourceCategoryItemRef,\n      instance: sourceInstance,\n      number: sourceInstanceItemNumber\n    } = sourceInstanceItem;\n    const {\n      targetInstance,\n      isTargetInstanceNewCreated,\n      affectedInstanceInGlobalMode\n    } = this.getTargetInstance(sourceInstance, targetCategory, targetInstanceNum);\n    if (!targetInstance) {\n      throw new Error(i18n.translate('CHANGE_CATEGORY_ERROR_NO_TARGET_INSTANCE'));\n    }\n    if (((_this$reorganizingIns = this.reorganizingInstance) === null || _this$reorganizingIns === void 0 ? void 0 : _this$reorganizingIns.category) === targetInstance.category && ((_this$reorganizingIns2 = this.reorganizingInstance) === null || _this$reorganizingIns2 === void 0 ? void 0 : _this$reorganizingIns2.number) === targetInstance.number && ((_this$reorganizingIns3 = this.reorganizingInstance) === null || _this$reorganizingIns3 === void 0 ? void 0 : _this$reorganizingIns3.id) !== targetInstance.id) {\n      // update reorganizing instance if target instance is newly created\n      this.reorganizingInstance = targetInstance;\n    }\n    const prevSourceInstanceBasicInfo = sourceInstance.getBasicInfo();\n    const prevTargetInstanceBasicInfo = targetInstance.getBasicInfo();\n    const targetInstanceItem = this.getTargetInstanceItem(targetInstance, targetCategoryItem, isTargetInstanceNewCreated, sourceInstanceItemNumber);\n    if (!targetInstanceItem) {\n      throw new Error(i18n.translate('CHANGE_CATEGORY_ERROR_NO_TARGET_INSTANCE_ITEM'));\n    }\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const {\n      categoryItemRef: targetCategoryItemRef\n    } = targetInstanceItem;\n    let instanceItemMovedTo;\n    const prevInstanceMap = {};\n    const currInstanceMap = {};\n    const prevRelationshipMap = {};\n    const currRelationshipMap = {};\n    const updateInstanceMap = (instanceMap, instance, stat, prevInstanceBasicInfo) => {\n      if (!instanceMap[instance.id]) {\n        if (prevInstanceBasicInfo) {\n          instanceMap[instance.id] = {\n            ...prevInstanceBasicInfo,\n            children: []\n          };\n        } else {\n          instanceMap[instance.id] = {\n            ...instance.getBasicInfo(),\n            children: []\n          };\n        }\n      }\n      if (stat) {\n        const index = instanceMap[instance.id].children.findIndex(child => child.id === (stat === null || stat === void 0 ? void 0 : stat.id));\n        if (index >= 0) {\n          instanceMap[instance.id].children[index] = {\n            ...stat,\n            cameras: instanceMap[instance.id].children[index].cameras.concat(stat.cameras)\n          };\n        } else {\n          instanceMap[instance.id].children.push(stat);\n        }\n      }\n    };\n    const updatedFramesSet = new Set();\n    const affectedCameras = Object.keys(affectedCameraFrames);\n    for (let c = 0; c < affectedCameras.length; c += 1) {\n      var _sourceInstanceItem$c, _targetInstanceItem$c;\n      const cameraName = affectedCameras[c];\n      const sourceFramesCount = Object.values(((_sourceInstanceItem$c = sourceInstanceItem.cameras[cameraName]) === null || _sourceInstanceItem$c === void 0 ? void 0 : _sourceInstanceItem$c.frames) || {}).length;\n      const targetFramesCount = Object.values(((_targetInstanceItem$c = targetInstanceItem.cameras[cameraName]) === null || _targetInstanceItem$c === void 0 ? void 0 : _targetInstanceItem$c.frames) || {}).length;\n      const {\n        relationships: sourceRelationships\n      } = sourceInstanceItem.cameras[cameraName] || {};\n      const {\n        relationships: targetRelationships\n      } = targetInstanceItem.cameras[cameraName] || {};\n      const frames = affectedCameraFrames[cameraName];\n      // frames data to target instance item\n      const framesData = [];\n      // frames data moved from target to new instance item\n      const movedFrameData = [];\n      // relationships updated\n      const updatedRelationships = [];\n      for (let i = 0; i < frames.length; i += 1) {\n        var _sourceInstanceItem$c2, _targetInstanceItem$c2;\n        const frameIndex = frames[i];\n        const sourceFrameData = (_sourceInstanceItem$c2 = sourceInstanceItem.cameras[cameraName]) === null || _sourceInstanceItem$c2 === void 0 ? void 0 : _sourceInstanceItem$c2.frames[frameIndex];\n        const targetFrameData = (_targetInstanceItem$c2 = targetInstanceItem.cameras[cameraName]) === null || _targetInstanceItem$c2 === void 0 ? void 0 : _targetInstanceItem$c2.frames[frameIndex];\n        if ((sourceInstance.category === targetCategory ? sourceFrameData === null || sourceFrameData === void 0 ? void 0 : sourceFrameData.numberChangeAllowed : sourceFrameData === null || sourceFrameData === void 0 ? void 0 : sourceFrameData.categoryChangeAllowed) && (!targetFrameData || targetFrameData.numberChangeAllowed)) {\n          updatedFramesSet.add(frameIndex);\n          const frameDataJson = sourceFrameData.toJSON();\n          if ((targetCategoryItem !== sourceInstanceItem.name || targetCategory !== sourceInstance.category) && sourceFrameData.attrChangeAllowed) {\n            var _sourceCategoryItemRe, _targetCategoryItemRe;\n            // update attributes when category not same\n            frameDataJson.attributes = updateAttributesByFieldsCompare((sourceCategoryItemRef === null || sourceCategoryItemRef === void 0 ? void 0 : (_sourceCategoryItemRe = sourceCategoryItemRef.labelConfig) === null || _sourceCategoryItemRe === void 0 ? void 0 : _sourceCategoryItemRe.fields) || [], ((_targetCategoryItemRe = targetCategoryItemRef.labelConfig) === null || _targetCategoryItemRe === void 0 ? void 0 : _targetCategoryItemRe.fields) || [], sourceFrameData.attributes, {});\n          }\n          framesData.push(frameDataJson);\n\n          // move target frame to new\n          if (targetFrameData) {\n            movedFrameData.push(targetFrameData.toJSON());\n          }\n          if (frameIndex === currentFrame) {\n            // change instance item for pixel shape\n            if (sourceFrameData.shapeType === ShapeType.PIXEL) {\n              this.rootStore.segmentation.changeInstanceItemForInfoMap(sourceInstanceItem, targetInstanceItem);\n            }\n            // delete shape in current frame\n            const shape = this.rootStore.shape.getShapeByInstanceItem(sourceInstanceItem, cameraName);\n            if (shape) {\n              this.rootStore.shape.deleteShape(shape);\n            }\n          }\n        }\n      }\n\n      // should move frames to new instance item\n      const movedFramesCount = movedFrameData.length;\n      if (movedFramesCount > 0) {\n        if (!instanceItemMovedTo) {\n          const instanceMovedTo = this.createInstance(targetCategory);\n          if (instanceMovedTo) {\n            instanceItemMovedTo = this.createInstanceItem(instanceMovedTo, targetCategoryItem);\n          }\n        }\n        if (instanceItemMovedTo) {\n          instanceItemMovedTo.updateFramesFromData(cameraName, movedFrameData);\n          if (targetRelationships) {\n            const shouldMoveRelationship = movedFramesCount === targetFramesCount;\n            for (let i = 0; i < targetRelationships.length; i += 1) {\n              const r = targetRelationships[i];\n              if (!prevRelationshipMap[r.id]) {\n                prevRelationshipMap[r.id] = r.toJSON();\n              }\n              if (shouldMoveRelationship) {\n                if (r.fromInstanceItem.id === targetInstanceItem.id) {\n                  r.fromInstanceItem = instanceItemMovedTo;\n                } else {\n                  r.toInstanceItem = instanceItemMovedTo;\n                }\n                instanceItemMovedTo.cameras[cameraName].relationships.push(r);\n                currRelationshipMap[r.id] = r.toJSON();\n              } else {\n                r.deleteFromFrames(movedFrameData.map(f => f.frameIndex));\n                if (Object.values(r.frames).length > 0) {\n                  currRelationshipMap[r.id] = r.toJSON();\n                } else {\n                  this.rootStore.relationship.deleteRelationship(r);\n                }\n              }\n              updatedRelationships.push(r);\n            }\n          }\n        }\n      }\n      const framesCount = framesData.length;\n      if (framesCount > 0) {\n        var _sourceInstance$categ2, _sourceInstance$categ3, _targetInstance$categ3, _targetInstance$categ4;\n        const {\n          dynamicAttributes: sourceInstanceDynamicAttr\n        } = sourceInstance;\n        const sourceInstanceDynamicAttrByCamera = cloneDeep(sourceInstanceDynamicAttr === null || sourceInstanceDynamicAttr === void 0 ? void 0 : sourceInstanceDynamicAttr[cameraName]);\n        const framesIndex = framesData.map(f => f.frameIndex);\n        // remove frames from source instance item\n        const sourceStat = sourceInstanceItem.remove(cameraName, framesIndex);\n        updateInstanceMap(prevInstanceMap, sourceInstance, sourceStat.prevState, prevSourceInstanceBasicInfo);\n        updateInstanceMap(currInstanceMap, sourceInstance, sourceStat.currState);\n        // update frames for target instance item\n        const targetStat = targetInstanceItem.updateFramesFromData(cameraName, framesData);\n        if (!isTargetInstanceNewCreated) {\n          updateInstanceMap(prevInstanceMap, targetInstance, targetStat.prevState, prevTargetInstanceBasicInfo);\n        }\n        updateInstanceMap(currInstanceMap, targetInstance, targetStat.currState);\n        // update instance dynamic attributes\n        const sourceFields = ((_sourceInstance$categ2 = sourceInstance.categoryRef) === null || _sourceInstance$categ2 === void 0 ? void 0 : (_sourceInstance$categ3 = _sourceInstance$categ2.labelConfigDynamic) === null || _sourceInstance$categ3 === void 0 ? void 0 : _sourceInstance$categ3.fields) || [];\n        const targetFields = ((_targetInstance$categ3 = targetInstance.categoryRef) === null || _targetInstance$categ3 === void 0 ? void 0 : (_targetInstance$categ4 = _targetInstance$categ3.labelConfigDynamic) === null || _targetInstance$categ4 === void 0 ? void 0 : _targetInstance$categ4.fields) || [];\n        const updatedFrames = Array.from(updatedFramesSet);\n        const {\n          dynamicAttributes: targetInstanceDynamicAttr\n        } = targetInstance;\n        const targetInstanceDynamicAttrByCamera = targetInstanceDynamicAttr === null || targetInstanceDynamicAttr === void 0 ? void 0 : targetInstanceDynamicAttr[cameraName];\n        const updatedDynamicAttrs = [];\n        for (let index = 0; index < updatedFrames.length; index += 1) {\n          const frameIndex = updatedFrames[index];\n          if (targetCategoryItem === sourceInstanceItem.name && targetCategory === sourceInstance.category) {\n            if (targetInstanceDynamicAttrByCamera) {\n              if (!targetInstanceDynamicAttrByCamera[frameIndex]) {\n                var _sourceInstanceDynami;\n                updatedDynamicAttrs.push({\n                  frameIndex,\n                  attributes: sourceInstanceDynamicAttrByCamera === null || sourceInstanceDynamicAttrByCamera === void 0 ? void 0 : (_sourceInstanceDynami = sourceInstanceDynamicAttrByCamera[frameIndex]) === null || _sourceInstanceDynami === void 0 ? void 0 : _sourceInstanceDynami.attributes\n                });\n              }\n            } else {\n              var _sourceInstanceDynami2;\n              const updatedDynamicAttrbutes = updateAttributesByFieldsCompare(sourceFields, targetFields, sourceInstanceDynamicAttrByCamera === null || sourceInstanceDynamicAttrByCamera === void 0 ? void 0 : (_sourceInstanceDynami2 = sourceInstanceDynamicAttrByCamera[frameIndex]) === null || _sourceInstanceDynami2 === void 0 ? void 0 : _sourceInstanceDynami2.attributes, {});\n              updatedDynamicAttrs.push({\n                frameIndex,\n                attributes: updatedDynamicAttrbutes\n              });\n            }\n          } else if (targetInstanceDynamicAttrByCamera && !targetInstanceDynamicAttrByCamera[frameIndex] || !targetInstanceDynamicAttrByCamera) {\n            var _sourceInstanceDynami3;\n            const updatedDynamicAttrbutes = updateAttributesByFieldsCompare(sourceFields, targetFields, sourceInstanceDynamicAttrByCamera === null || sourceInstanceDynamicAttrByCamera === void 0 ? void 0 : (_sourceInstanceDynami3 = sourceInstanceDynamicAttrByCamera[frameIndex]) === null || _sourceInstanceDynami3 === void 0 ? void 0 : _sourceInstanceDynami3.attributes, {});\n            updatedDynamicAttrs.push({\n              frameIndex,\n              attributes: updatedDynamicAttrbutes\n            });\n          }\n        }\n        targetInstance.setDynamicAttributesByCamera(cameraName, updatedDynamicAttrs);\n        sourceInstance.deleteDynamicAttributesByCamera(cameraName, Array.from(updatedFramesSet), sourceInstanceItem.id);\n\n        // update relationships\n        if (sourceRelationships) {\n          const shouldMoveRelationship = framesCount === sourceFramesCount;\n          for (let i = 0; i < sourceRelationships.length; i += 1) {\n            const r = sourceRelationships[i];\n            if (!prevRelationshipMap[r.id]) {\n              prevRelationshipMap[r.id] = r.toJSON();\n            }\n            if (shouldMoveRelationship) {\n              if (r.fromInstanceItem.id === sourceInstanceItem.id && r.toInstanceItem.id !== targetInstanceItem.id) {\n                r.fromInstanceItem = targetInstanceItem;\n                targetInstanceItem.cameras[cameraName].relationships.push(r);\n                currRelationshipMap[r.id] = r.toJSON();\n              } else if (r.toInstanceItem.id === sourceInstanceItem.id && r.fromInstanceItem.id !== targetInstanceItem.id) {\n                r.toInstanceItem = targetInstanceItem;\n                targetInstanceItem.cameras[cameraName].relationships.push(r);\n                currRelationshipMap[r.id] = r.toJSON();\n              }\n            } else {\n              r.deleteFromFrames(framesIndex);\n              if (Object.values(r.frames).length > 0) {\n                currRelationshipMap[r.id] = r.toJSON();\n              } else {\n                this.rootStore.relationship.deleteRelationship(r);\n              }\n            }\n            updatedRelationships.push(r);\n          }\n        }\n        if (sourceInstanceItem.isEmpty) {\n          this.deleteInstanceItem(sourceInstanceItem);\n          currInstanceMap[sourceInstance.id].children = [];\n        }\n        if (sourceInstance.isEmpty) {\n          this.deleteInstance(sourceInstance);\n          delete currInstanceMap[sourceInstance.id];\n        }\n      }\n\n      // setup shapes\n      this.rootStore.shape.setupShape(targetInstanceItem, cameraName);\n      if (instanceItemMovedTo) {\n        this.rootStore.shape.setupShape(instanceItemMovedTo, cameraName);\n      }\n      // setup connections\n      updatedRelationships.forEach(r => {\n        this.rootStore.relationship.deleteConnection(r);\n        this.rootStore.relationship.createConnection(r);\n      });\n    }\n    const prevInstances = Object.values(prevInstanceMap);\n    const currInstances = Object.values(currInstanceMap);\n    if (instanceItemMovedTo) {\n      currInstances.push(instanceItemMovedTo.instance.toJSON());\n    }\n    if (affectedInstanceInGlobalMode) {\n      prevInstances.push({\n        ...affectedInstanceInGlobalMode.getBasicInfo(),\n        children: []\n      });\n      affectedInstanceInGlobalMode.number = this.getNextInstanceNumber(affectedInstanceInGlobalMode.category);\n      currInstances.push({\n        ...affectedInstanceInGlobalMode.getBasicInfo(),\n        children: []\n      });\n    }\n    const prevRelationships = Object.values(prevRelationshipMap);\n    const currRelationships = Object.values(currRelationshipMap);\n    return {\n      targetInstanceItem,\n      instanceItemMovedTo,\n      updatedFramesSet,\n      prevState: {\n        instances: prevInstances,\n        relationships: prevRelationships\n      },\n      currState: {\n        instances: currInstances,\n        relationships: currRelationships\n      }\n    };\n  }\n  changeCategoryForInstance({\n    targetCategoryName,\n    pendingInstanceItems\n  }) {\n    const allItems = Object.values(pendingInstanceItems);\n    if (allItems.length <= 0) {\n      message.error(i18n.translate('FILTER_MOVE_TO_EMPTY'));\n      return;\n    }\n    const prevInstanceMap = {};\n    const currInstanceMap = {};\n    const prevRelationshipMap = {};\n    const currRelationshipMap = {};\n    try {\n      let targetInstance;\n      for (let i = 0; i < allItems.length; i += 1) {\n        var _targetInstance;\n        const {\n          sourceInstanceItem,\n          affectedCameraFrames\n        } = allItems[i];\n        const {\n          targetInstanceItem,\n          prevState,\n          currState\n        } = this.changeCategoryForInstanceItemPure(sourceInstanceItem, targetCategoryName, sourceInstanceItem.name, affectedCameraFrames, (_targetInstance = targetInstance) === null || _targetInstance === void 0 ? void 0 : _targetInstance.number);\n        targetInstance = targetInstanceItem.instance;\n\n        // eslint-disable-next-line no-loop-func\n        prevState.instances.forEach(instance => {\n          var _targetInstance2;\n          // target instance 是上一次受影响的 instance\n          // 在下一次循环中，prev state 中无需保存上一次受影响的 instance\n          if (instance.id === ((_targetInstance2 = targetInstance) === null || _targetInstance2 === void 0 ? void 0 : _targetInstance2.id)) {\n            return;\n          }\n          if (!prevInstanceMap[instance.id]) {\n            prevInstanceMap[instance.id] = instance;\n          } else {\n            prevInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        currState.instances.forEach(instance => {\n          if (!currInstanceMap[instance.id]) {\n            currInstanceMap[instance.id] = instance;\n          } else {\n            currInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        prevState.relationships.forEach(r => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currState.relationships.forEach(r => {\n          currRelationshipMap[r.id] = r;\n        });\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap),\n        relationships: Object.values(prevRelationshipMap)\n      }, {\n        instances: Object.values(currInstanceMap),\n        relationships: Object.values(currRelationshipMap)\n      });\n      this.rootStore.filter.filterInstances();\n      // select\n      this.selectInstance(targetInstance);\n      // open attributes modal\n      this.autoOpenAttributesModal(true);\n    } catch (e) {\n      message.error(e.message);\n    }\n  }\n  changeCategoryForInstanceItem(sourceInstanceItem, targetCategory, targetCategoryItem, affectedCameraFrames, targetInstanceNum) {\n    try {\n      const {\n        targetInstanceItem,\n        instanceItemMovedTo,\n        updatedFramesSet,\n        prevState,\n        currState\n      } = this.changeCategoryForInstanceItemPure(sourceInstanceItem, targetCategory, targetCategoryItem, affectedCameraFrames, targetInstanceNum);\n      const {\n        instances: prevInstances,\n        relationships: prevRelationships\n      } = prevState;\n      const {\n        instances: currInstances,\n        relationships: currRelationships\n      } = currState;\n      if (prevInstances.length > 0 || currInstances.length > 0) {\n        // save to undo/redo stack\n        this.rootStore.undo.push({\n          instances: prevInstances,\n          relationships: prevRelationships\n        }, {\n          instances: currInstances,\n          relationships: currRelationships\n        });\n        // filter\n        this.rootStore.filter.filterInstances();\n        // select\n        this.selectInstanceItem(targetInstanceItem);\n        // open attributes modal only when category changes\n        if (targetCategory !== sourceInstanceItem.instance.category || targetCategoryItem !== sourceInstanceItem.name) {\n          this.autoOpenAttributesModal(true);\n        }\n        message.success(i18n.translate('CHANGE_CATEGORY_SUCCESS', {\n          values: {\n            source: sourceInstanceItem.label,\n            target: targetInstanceItem.label,\n            frames: formatFrames(Array.from(updatedFramesSet))\n          }\n        }));\n        if (instanceItemMovedTo) {\n          message.success(i18n.translate('CHANGE_CATEGORY_SUCCESS', {\n            values: {\n              source: targetInstanceItem.label,\n              target: instanceItemMovedTo.label,\n              frames: formatFrames(Object.keys(instanceItemMovedTo.frameStatus).map(f => Number(f)))\n            }\n          }));\n        }\n      } else {\n        message.warning(i18n.translate('CHANGE_CATEGORY_WARNING'));\n      }\n    } catch (e) {\n      message.error(e.message);\n    }\n  }\n\n  /**\n   * change category for instance items\n   * @param selectedInstanceInfo\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param attrs\n  */\n  changeCategoryForInstanceItems(selectedInstanceInfo, targetCategory, targetCategoryItem, attrs) {\n    const prevInstanceMap = {};\n    const currInstanceMap = {};\n    const getInstancesState = (instance, instanceItem, camera) => {\n      const newInstance = {\n        ...instance.getBasicInfo(),\n        children: []\n      };\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData && !cameraData.isEmpty) {\n        newInstance.children.push({\n          ...instanceItem.getBasicInfo(),\n          cameras: [cameraData.toJSON()]\n        });\n      }\n      return newInstance;\n    };\n    const selectInstanceInfoMap = new Map();\n    selectedInstanceInfo === null || selectedInstanceInfo === void 0 ? void 0 : selectedInstanceInfo.forEach(instanceInfo => {\n      // delete old and add attributes\n      const {\n        instanceId,\n        instanceItemId,\n        camera,\n        frames\n      } = instanceInfo;\n      if (!camera) {\n        return;\n      }\n      const sourceInstance = this.getInstanceById(instanceId);\n      let sourceInstanceItem = null;\n      if (sourceInstance && instanceItemId) {\n        sourceInstanceItem = sourceInstance.items[instanceItemId];\n      }\n      if (!sourceInstanceItem) {\n        return;\n      }\n      // if selected category is same with instance's current ,then return\n      if (sourceInstance.categoryRef.className === targetCategory && sourceInstanceItem.categoryItemRef.name === targetCategoryItem) {\n        return;\n      }\n      const key = `${instanceId}-${instanceItemId}`;\n      let targetInstance;\n      let targetInstanceItem;\n      if (selectInstanceInfoMap.has(key)) {\n        const {\n          targetInstanceId,\n          targetInstanceItemId\n        } = selectInstanceInfoMap.get(key);\n        targetInstance = this.getInstanceById(targetInstanceId);\n        if (targetInstance && targetInstanceItemId) {\n          targetInstanceItem = targetInstance.items[targetInstanceItemId];\n        }\n      } else {\n        // create new\n        try {\n          targetInstance = this.createInstance(targetCategory);\n          if (targetInstance) {\n            targetInstanceItem = this.createInstanceItem(targetInstance, targetCategoryItem);\n          }\n        } catch (e) {\n          message.error(e.message);\n          return;\n        }\n        if (!targetInstance || !targetInstanceItem) {\n          return;\n        }\n        selectInstanceInfoMap.set(key, {\n          targetInstanceId: targetInstance.id,\n          targetInstanceItemId: targetInstanceItem.id\n        });\n      }\n      if (!targetInstance || !targetInstanceItem) {\n        return;\n      }\n      if (!prevInstanceMap[sourceInstance.id]) {\n        prevInstanceMap[sourceInstance.id] = getInstancesState(sourceInstance, sourceInstanceItem, camera);\n      }\n      // delete attributes  for source instance's item by frame\n      sourceInstance.deleteDynamicAttributesByCamera(camera, frames, sourceInstanceItem.id);\n      const {\n        currentFrame\n      } = this.rootStore.frame;\n      frames.forEach(frame => {\n        var _cameras$camera;\n        // frames data to target instance item\n        const sourceFrameData = (_cameras$camera = sourceInstanceItem.cameras[camera]) === null || _cameras$camera === void 0 ? void 0 : _cameras$camera.frames[frame];\n        if (!sourceFrameData) {\n          return;\n        }\n        const frameDataJson = sourceFrameData.toJSON();\n        targetInstanceItem.updateFramesFromData(camera, [frameDataJson]);\n        if (frame === currentFrame) {\n          // change instance item for pixel shape\n          if (sourceFrameData.shapeType === ShapeType.PIXEL) {\n            this.rootStore.segmentation.changeInstanceItemForInfoMap(sourceInstanceItem, targetInstanceItem);\n          }\n          // delete shape in current frame\n          const shape = this.rootStore.shape.getShapeByInstanceItem(sourceInstanceItem, camera);\n          if (shape) {\n            this.rootStore.shape.deleteShape(shape);\n          }\n        }\n        const {\n          currState\n        } = this.deleteInstanceItemByFrame(sourceInstanceItem, frame, camera);\n        currInstanceMap[sourceInstance.id] = currState ? currState.instances[0] : {\n          ...sourceInstanceItem.instance.getBasicInfo(),\n          children: []\n        };\n      });\n\n      // set attributes for target instance and instance item\n      if (attrs) {\n        var _targetInstance4;\n        const {\n          static: newInstanceAttr,\n          dynamic: newInstanceDynamicAttr,\n          item: newInstanceItemAttr\n        } = attrs;\n        if (newInstanceAttr) {\n          var _targetInstance3;\n          (_targetInstance3 = targetInstance) === null || _targetInstance3 === void 0 ? void 0 : _targetInstance3.setAttributes(newInstanceAttr);\n        }\n        const updatedFrameAttributes = [];\n        frames.forEach(frame => {\n          if (newInstanceItemAttr) {\n            targetInstanceItem.setAttributesByFrame(camera, {\n              [frame]: {\n                attributes: newInstanceItemAttr\n              }\n            });\n          }\n          if (newInstanceDynamicAttr) {\n            updatedFrameAttributes.push({\n              frameIndex: frame,\n              attributes: newInstanceDynamicAttr\n            });\n          }\n        });\n        (_targetInstance4 = targetInstance) === null || _targetInstance4 === void 0 ? void 0 : _targetInstance4.setDynamicAttributesByCamera(camera, updatedFrameAttributes);\n      }\n\n      // setup shapes\n      this.rootStore.shape.setupShape(targetInstanceItem, camera);\n      currInstanceMap[targetInstance.id] = getInstancesState(targetInstanceItem.instance, targetInstanceItem, camera);\n    });\n    const prevInstances = Object.values(prevInstanceMap);\n    const currInstances = Object.values(currInstanceMap);\n    // filter\n    this.rootStore.filter.filterInstances();\n    if (prevInstances.length > 0 || currInstances.length > 0) {\n      // save to undo/redo stack\n      this.rootStore.undo.push({\n        instances: prevInstances\n      }, {\n        instances: currInstances\n      });\n      message.success(i18n.translate('CHANGE_CATEGORY_BATCH_SUCCESS'));\n    } else {\n      message.warning(i18n.translate('CHANGE_CATEGORY_WARNING'));\n    }\n  }\n\n  /**\n   * change layer for selected instance item\n   * @param targetLayer\n   */\n  changeLayer(targetLayer) {\n    if (this.isSingleSelected) {\n      var _selectedInstanceItem;\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const frameData = (_selectedInstanceItem = selectedInstanceItem.cameras[currentCamera]) === null || _selectedInstanceItem === void 0 ? void 0 : _selectedInstanceItem.frames[currentFrame];\n      if (!(frameData === null || frameData === void 0 ? void 0 : frameData.locked) && (frameData === null || frameData === void 0 ? void 0 : frameData.layer) !== targetLayer) {\n        const prevInstanceMap = {};\n        const currInstanceMap = {};\n        let prevRelationships;\n        let currRelationships;\n\n        // update layer\n        if (frameData.shapeType === ShapeType.PIXEL) {\n          // for pixel shape, layer change may affect self or others\n          const {\n            instanceState,\n            relationshipState\n          } = this.rootStore.segmentation.changeLayer(selectedInstanceItem, frameData.layer, targetLayer);\n          Object.keys(instanceState).forEach(id => {\n            const {\n              prev,\n              curr\n            } = instanceState[id];\n            if (!prevInstanceMap[id]) {\n              prevInstanceMap[id] = prev;\n            }\n            currInstanceMap[id] = curr;\n          });\n          prevRelationships = relationshipState.prev;\n          currRelationships = relationshipState.curr;\n        } else {\n          // not pixel shape, only need to update layer & order\n          const instanceBasicInfo = selectedInstanceItem.instance.getBasicInfo();\n          const itemBasicInfo = selectedInstanceItem.getBasicInfo();\n          prevInstanceMap[instanceBasicInfo.id] = {\n            ...instanceBasicInfo,\n            children: [{\n              ...itemBasicInfo,\n              cameras: [{\n                camera: currentCamera,\n                frames: [frameData.toJSON()]\n              }]\n            }]\n          };\n          frameData.layer = targetLayer;\n          frameData.order = this.rootStore.frame.getNextShapeOrder(targetLayer, currentFrame, currentCamera);\n          currInstanceMap[instanceBasicInfo.id] = {\n            ...instanceBasicInfo,\n            children: [{\n              ...itemBasicInfo,\n              cameras: [{\n                camera: currentCamera,\n                frames: [frameData.toJSON()]\n              }]\n            }]\n          };\n        }\n        this.rootStore.undo.push({\n          instances: Object.values(prevInstanceMap),\n          relationships: prevRelationships\n        }, {\n          instances: Object.values(currInstanceMap),\n          relationships: currRelationships\n        });\n        this.rootStore.config.setContextMenuVisible(false);\n        this.rootStore.shape.setupShape(selectedInstanceItem, currentCamera);\n        if (!selectedInstanceItem.cameras[currentCamera]) {\n          this.selectInstanceItem(null);\n          this.selectInstance(selectedInstanceItem.instance.isEmpty ? null : selectedInstanceItem.instance);\n          this.rootStore.config.setActiveLayerIndex(targetLayer);\n        } else {\n          this.selectInstanceItem(selectedInstanceItem);\n        }\n        message.success(i18n.translate('LAYER_CHANGED_SUCCESS', {\n          values: {\n            label: selectedInstanceItem.label,\n            layer: this.rootStore.config.layers[targetLayer]\n          }\n        }));\n      }\n    }\n  }\n\n  /**\n   * open attributes modal automatically for selected instance\n   * @param ignoreAttributes ignore whether if frameData's attributes existed or not\n   */\n  autoOpenAttributesModal(ignoreAttributes = false) {\n    var _selectedInstance$dyn, _selectedInstance$dyn2;\n    if (!this.rootStore.config.preferences.autoOpenAttributesModal || this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return false;\n    }\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const shouldOpen = instanceItem => {\n      var _instanceItem$cameras9;\n      const frameData = (_instanceItem$cameras9 = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras9 === void 0 ? void 0 : _instanceItem$cameras9.frames[currentFrame];\n      if ((frameData === null || frameData === void 0 ? void 0 : frameData.isOCR) && !(frameData === null || frameData === void 0 ? void 0 : frameData.OCRText)) {\n        this.rootStore.config.shouldSyncOCR = true;\n        return true;\n      }\n      if ((frameData === null || frameData === void 0 ? void 0 : frameData.isFormula) && !(frameData === null || frameData === void 0 ? void 0 : frameData.formulaText)) {\n        this.rootStore.config.shouldSyncOCR = true;\n        return true;\n      }\n      if (instanceItem.categoryItemRef.labelConfig && (ignoreAttributes || !(frameData === null || frameData === void 0 ? void 0 : frameData.attributes))) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n      return false;\n    };\n    if (this.selectedInstanceItems.length === 1) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const open = shouldOpen(selectedInstanceItem);\n      if (open) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n    }\n    const selectedInstance = this.selectedInstances[0];\n    const {\n      labelConfig,\n      labelConfigDynamic\n    } = selectedInstance.categoryRef;\n    if (labelConfig && (ignoreAttributes || !selectedInstance.attributes) || labelConfigDynamic && (ignoreAttributes || !selectedInstance.dynamicAttributes || !((_selectedInstance$dyn = selectedInstance.dynamicAttributes[currentCamera]) === null || _selectedInstance$dyn === void 0 ? void 0 : (_selectedInstance$dyn2 = _selectedInstance$dyn[currentFrame]) === null || _selectedInstance$dyn2 === void 0 ? void 0 : _selectedInstance$dyn2.attributes))) {\n      this.rootStore.config.setAttributesModalVisible(true);\n      return true;\n    }\n    if (this.selectedInstanceItems.length <= 0 && Object.values(selectedInstance.items).some(i => shouldOpen(i))) {\n      // no instance item selected\n      this.rootStore.config.setAttributesModalVisible(true);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * move to next pending instance item & open attributes modal if needed\n   */\n  openAttributesModalFromPending() {\n    const item = this.attrPendingInstanceItems.shift();\n    if (item) {\n      this.selectInstanceItem(item);\n      const open = this.autoOpenAttributesModal();\n      if (open) {\n        // async to set last pending instance item\n        setTimeout(() => {\n          this.lastPendingInstanceItem = item;\n        }, 0);\n        // focus\n        if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n          this.rootStore.shape.fitShapes();\n        } else {\n          // this.rootStore.grid.gridCanvas?.fitShapes();\n        }\n      } else {\n        // move to next\n        this.openAttributesModalFromPending();\n      }\n    } else {\n      // no any pending instance item\n      this.lastPendingInstanceItem = null;\n    }\n  }\n\n  /**\n   * open attributes modal for instance items one by one\n   * @param instanceItems\n   */\n  openAttributesModalForInstanceItems(instanceItems) {\n    this.attrPendingInstanceItems = instanceItems;\n    this.lastPendingInstanceItem = null;\n    this.openAttributesModalFromPending();\n  }\n\n  /**\n   * set dragging type by draggable id\n   * @param draggableId\n   */\n  setDraggingType(draggableId) {\n    const [type] = draggableId.split('_');\n    this.draggingType = type;\n  }\n\n  /**\n   * update instances or instance items by dragging\n   * @param destination\n   */\n  updateByDragging(destination) {\n    if (!destination || !this.rootStore.config.autoTracking || this.rootStore.config.autoTracking && !this.rootStore.config.inexistentGraphicsCardVisibility) {\n      return;\n    }\n    const {\n      droppableId,\n      index\n    } = destination;\n\n    // ========== drag instance ==========\n    // reorder all instances number in the category\n    // just update instances number to 1, 2, 3, ...\n    if (this.draggingType === DraggableType.INSTANCE) {\n      const category = droppableId;\n      const selectedInstance = this.selectedInstances[0];\n      if (!selectedInstance || selectedInstance.category !== category) {\n        return;\n      }\n      const categoryInstances = [...this.categoryInstancesMap[category]];\n      const originIndex = categoryInstances.indexOf(selectedInstance);\n      if (originIndex === index) {\n        // same order, no need to udpate\n        return;\n      }\n\n      // reorder\n      categoryInstances.splice(originIndex, 1);\n      categoryInstances.splice(index, 0, selectedInstance);\n      const prevInstances = [];\n      const currInstances = [];\n      categoryInstances.forEach((instance, i) => {\n        const number = i + 1;\n        if (instance.number !== number) {\n          // update number\n          const basicInfo = instance.getBasicInfo();\n          instance.number = number;\n          prevInstances.push({\n            ...basicInfo,\n            children: []\n          });\n          currInstances.push({\n            ...basicInfo,\n            children: [],\n            number\n          });\n          // update shapes in the instance\n          Object.values(instance.items).forEach(item => {\n            Object.values(item.cameras).forEach(cameraData => {\n              this.rootStore.shape.setupShape(item, cameraData.camera);\n            });\n          });\n        }\n      });\n      this.rootStore.undo.push({\n        instances: prevInstances\n      }, {\n        instances: currInstances\n      });\n\n      // reselect\n      this.selectInstance(selectedInstance);\n    }\n\n    // ========== drag instance item in one camera ==========\n    // reorder all instance items (same name) number\n    // should move camera data from source to target (not just update number), keep other camera data not change\n    if (this.draggingType === DraggableType.ITEM) {\n      const [targetId, targetCamera] = droppableId.split('|DS|');\n      const camera = targetCamera || this.rootStore.frame.currentCamera;\n      const targetInstance = this.instances[targetId];\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      if (!targetInstance || !selectedInstanceItem) {\n        return;\n      }\n      const {\n        name: selectedName,\n        instance: selectedInstance,\n        categoryItemRef\n      } = selectedInstanceItem;\n      const selectedNameItemsCount = targetInstance.getItemsByName(selectedName).filter(item => {\n        var _item$cameras$camera;\n        return !((_item$cameras$camera = item.cameras[camera]) === null || _item$cameras$camera === void 0 ? void 0 : _item$cameras$camera.isEmpty);\n      }).length;\n      if (selectedInstance.id !== targetId && (selectedNameItemsCount === categoryItemRef.count || selectedNameItemsCount === categoryItemRef.maxCount)) {\n        // cannot dragged any instance item in because of count limits\n        return;\n      }\n      const sameInstance = selectedInstance.id === targetId;\n      const getInstancesState = instances => instances.map(instance => {\n        const newInstance = {\n          ...instance.getBasicInfo(),\n          children: []\n        };\n        instance.getItemsByName(selectedName).forEach(item => {\n          const cameraData = item.cameras[camera];\n          if (cameraData && !cameraData.isEmpty) {\n            newInstance.children.push({\n              ...item.getBasicInfo(),\n              cameras: [cameraData.toJSON()]\n            });\n          }\n        });\n        return newInstance;\n      });\n      const prevInstances = getInstancesState([targetInstance, ...(!sameInstance ? [selectedInstance] : [])]);\n      const prevRelationships = {};\n      const currRelationships = {};\n\n      // current selected number (updated when new number given)\n      let selectedNumber = selectedInstanceItem.number;\n      // update camera data in instance item\n      const updateCameraData = (number, cameraData, relationships, originInstanceItem) => {\n        let targetInstanceItem = targetInstance.getItemsByName(selectedName).find(item => item.number === number); // existed instance item with the number\n        if (!targetInstanceItem) {\n          // should create\n          const newInstanceItem = {\n            id: uuidv4(),\n            name: selectedName,\n            number,\n            cameras: []\n          };\n          targetInstance.createItemFromData(newInstanceItem);\n          targetInstanceItem = targetInstance.items[newInstanceItem.id];\n        }\n        targetInstanceItem.createCameraFromData(cameraData);\n        this.rootStore.shape.setupShape(targetInstanceItem, camera);\n\n        // update relationships related\n        const {\n          deleteConnection,\n          createConnection\n        } = this.rootStore.relationship;\n        const targetCameraData = targetInstanceItem.cameras[camera];\n        for (let i = 0; i < relationships.length; i += 1) {\n          const relationship = relationships[i];\n          if (!prevRelationships[relationship.id]) {\n            prevRelationships[relationship.id] = relationship.toJSON();\n          }\n          deleteConnection(relationship);\n          if (originInstanceItem === relationship.fromInstanceItem) {\n            relationship.fromInstanceItem = targetInstanceItem;\n          } else if (originInstanceItem === relationship.toInstanceItem) {\n            relationship.toInstanceItem = targetInstanceItem;\n          }\n          targetCameraData.addRelationship(relationship);\n          createConnection(relationship);\n          currRelationships[relationship.id] = relationship.toJSON();\n        }\n      };\n      if (targetCamera !== undefined) {\n        // drag to existing camera\n        const targetInstanceItems = Object.values(targetInstance.items).filter(item => {\n          var _item$cameras$camera2;\n          return !((_item$cameras$camera2 = item.cameras[camera]) === null || _item$cameras$camera2 === void 0 ? void 0 : _item$cameras$camera2.isEmpty);\n        }).sort((a, b) => {\n          const {\n            children\n          } = targetInstance.categoryRef;\n          const aIndex = children.findIndex(c => c.name === a.name);\n          const bIndex = children.findIndex(c => c.name === b.name);\n          if (aIndex < bIndex) {\n            return -1;\n          }\n          if (aIndex > bIndex) {\n            return 1;\n          }\n          return a.number - b.number;\n        });\n        const selectedNameFirstItemIndex = targetInstanceItems.findIndex(item => item.name === selectedName);\n        const selectedNameLastItemIndex = selectedNameFirstItemIndex + selectedNameItemsCount - (sameInstance ? 1 : 0);\n        const targetCameraDataList = targetInstanceItems.slice(selectedNameFirstItemIndex, selectedNameLastItemIndex + 1).map(item => ({\n          id: item.id,\n          cameraData: item.cameras[camera].toJSON(),\n          relationships: [...item.cameras[camera].relationships]\n        }));\n        const exactIndex = Math.min(Math.max(index, selectedNameFirstItemIndex), selectedNameLastItemIndex) - selectedNameFirstItemIndex;\n        if (sameInstance) {\n          // dragging in the same instance\n          const originIndex = targetInstanceItems.indexOf(selectedInstanceItem) - selectedNameFirstItemIndex;\n          if (originIndex === exactIndex) {\n            // same order in the same instance, no need to update\n            return;\n          }\n          targetCameraDataList.splice(originIndex, 1);\n        }\n        targetCameraDataList.splice(exactIndex, 0, {\n          id: selectedInstanceItem.id,\n          cameraData: selectedInstanceItem.cameras[camera].toJSON(),\n          relationships: [...selectedInstanceItem.cameras[camera].relationships]\n        });\n        targetCameraDataList.forEach((d, i) => {\n          const number = i + 1;\n          if (d.id === selectedInstanceItem.id) {\n            selectedNumber = number; // update selected number\n          }\n          const originTargetInstanceItem = targetInstance.items[d.id];\n          if (!originTargetInstanceItem || originTargetInstanceItem.name === selectedName && originTargetInstanceItem.number !== number) {\n            // should create new, or should update camera data because number changed\n            updateCameraData(number, d.cameraData, d.relationships, originTargetInstanceItem || selectedInstanceItem);\n          }\n        });\n        targetInstance.getItemsByName(selectedName).forEach(item => {\n          if (item.number > targetCameraDataList.length) {\n            delete item.cameras[camera];\n            if (item.isEmpty) {\n              this.deleteInstanceItem(item);\n            }\n          }\n        });\n      } else if (!sameInstance) {\n        // append to target instance, no instance item in current camera\n        selectedNumber = this.getNextInstanceItemNumber(targetInstance.id, selectedName, camera);\n        const cameraData = selectedInstanceItem.cameras[camera];\n        updateCameraData(selectedNumber, cameraData.toJSON(), [...cameraData.relationships], selectedInstanceItem);\n      }\n      if (!sameInstance) {\n        var _targetInstance$dynam2, _targetInstance$dynam3, _targetInstance$dynam6, _targetInstance$dynam7, _selectedInstance$dyn3, _selectedInstance$dyn4, _selectedInstance$dyn7, _selectedInstance$dyn8;\n        // delete dragged item\n        const shape = this.rootStore.shape.getShapeByInstanceItem(selectedInstanceItem, camera);\n        if (shape) {\n          this.rootStore.shape.deleteShape(shape);\n        }\n        delete selectedInstanceItem.cameras[camera];\n        if (selectedInstanceItem.isEmpty) {\n          this.deleteInstanceItem(selectedInstanceItem);\n        }\n        if (selectedInstance.isEmpty) {\n          this.deleteInstance(selectedInstance);\n        }\n        // update instance dynamic attributes\n        const {\n          currentFrame\n        } = this.rootStore.frame;\n        if ((_targetInstance$dynam2 = targetInstance.dynamicAttributes) === null || _targetInstance$dynam2 === void 0 ? void 0 : (_targetInstance$dynam3 = _targetInstance$dynam2[camera]) === null || _targetInstance$dynam3 === void 0 ? void 0 : _targetInstance$dynam3[currentFrame]) {\n          var _targetInstance$dynam4, _targetInstance$dynam5;\n          selectedInstance.setDynamicAttributesByCamera(camera, [targetInstance === null || targetInstance === void 0 ? void 0 : (_targetInstance$dynam4 = targetInstance.dynamicAttributes) === null || _targetInstance$dynam4 === void 0 ? void 0 : (_targetInstance$dynam5 = _targetInstance$dynam4[camera]) === null || _targetInstance$dynam5 === void 0 ? void 0 : _targetInstance$dynam5[currentFrame]]);\n        } else if (!(targetInstance === null || targetInstance === void 0 ? void 0 : (_targetInstance$dynam6 = targetInstance.dynamicAttributes) === null || _targetInstance$dynam6 === void 0 ? void 0 : (_targetInstance$dynam7 = _targetInstance$dynam6[camera]) === null || _targetInstance$dynam7 === void 0 ? void 0 : _targetInstance$dynam7[currentFrame]) && ((_selectedInstance$dyn3 = selectedInstance.dynamicAttributes) === null || _selectedInstance$dyn3 === void 0 ? void 0 : (_selectedInstance$dyn4 = _selectedInstance$dyn3[camera]) === null || _selectedInstance$dyn4 === void 0 ? void 0 : _selectedInstance$dyn4[currentFrame])) {\n          var _selectedInstance$dyn5, _selectedInstance$dyn6;\n          targetInstance.setDynamicAttributesByCamera(camera, [(_selectedInstance$dyn5 = selectedInstance.dynamicAttributes) === null || _selectedInstance$dyn5 === void 0 ? void 0 : (_selectedInstance$dyn6 = _selectedInstance$dyn5[camera]) === null || _selectedInstance$dyn6 === void 0 ? void 0 : _selectedInstance$dyn6[currentFrame]]);\n        }\n        if (selectedInstance === null || selectedInstance === void 0 ? void 0 : (_selectedInstance$dyn7 = selectedInstance.dynamicAttributes) === null || _selectedInstance$dyn7 === void 0 ? void 0 : (_selectedInstance$dyn8 = _selectedInstance$dyn7[camera]) === null || _selectedInstance$dyn8 === void 0 ? void 0 : _selectedInstance$dyn8[currentFrame]) {\n          selectedInstance.deleteDynamicAttributesByCamera(camera, [currentFrame], selectedInstanceItem.id);\n        }\n      }\n      const currInstances = getInstancesState([targetInstance, ...(!sameInstance && !selectedInstance.isEmpty ? [selectedInstance] : [])]);\n      this.rootStore.undo.push({\n        instances: prevInstances,\n        relationships: Object.values(prevRelationships)\n      }, {\n        instances: currInstances,\n        relationships: Object.values(currRelationships)\n      });\n\n      // reselect\n      const currentSelectedInstanceItem = targetInstance.getItemsByName(selectedName).find(item => item.number === selectedNumber);\n      this.selectInstanceItem(currentSelectedInstanceItem);\n    }\n  }\n\n  /**\n   * get instances json data (for save)\n   * @param options\n   */\n  instancesJSON(options) {\n    return Object.values(this.instances).map(instance => instance.toJSON(options));\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  getCurrentDynamicAttributesByInstance(instance) {\n    var _instance$dynamicAttr, _instance$dynamicAttr2;\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const {\n      attributes = {}\n    } = ((_instance$dynamicAttr = instance.dynamicAttributes) === null || _instance$dynamicAttr === void 0 ? void 0 : (_instance$dynamicAttr2 = _instance$dynamicAttr[currentCamera]) === null || _instance$dynamicAttr2 === void 0 ? void 0 : _instance$dynamicAttr2[currentFrame]) || {};\n    return attributes;\n  }\n\n  /**\n   * switch between instances or instance items\n   */\n  switch() {\n    // default switch between instances\n    let searchClassName = '.sidebar-category-instance__label';\n    const selectedInstanceItem = this.selectedInstanceItems[0];\n    if (selectedInstanceItem && !selectedInstanceItem.instance.isSingle) {\n      // item in multiple instance selected, switch between instance items\n      searchClassName = '.sidebar-category-instance__item, .sidebar-category-instance__label.single';\n    }\n    const nodes = Array.from(document.querySelectorAll(searchClassName));\n    const selectedIndex = nodes.findIndex(i => i.classList.contains('selected'));\n    const nextIndex = selectedIndex === nodes.length - 1 ? 0 : selectedIndex + 1;\n    const nextNodes = nodes.slice(nextIndex).filter(i => !i.classList.contains('hidden'));\n    const nextNode = nextNodes.length > 0 ? nextNodes[0] : nodes.find(i => !i.classList.contains('hidden'));\n    if (nextNode) {\n      ['mousedown', 'mouseup'].forEach(eventName => {\n        nextNode.dispatchEvent(new MouseEvent(eventName, {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n          buttons: 1\n        }));\n      });\n    }\n  }\n\n  /**\n   * set locked for all category shapes in current frame\n   * @param category\n   * @param locked\n   */\n  setLockedForCategory(category, locked) {\n    const {\n      updateShapeLockedState\n    } = this.rootStore.shape;\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const prevInstances = [];\n    const currInstances = [];\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      if (instance.category === category && instance.frameStatus[currentFrame] !== undefined) {\n        const basicInfo = instance.getBasicInfo();\n        const prevItems = [];\n        const currItems = [];\n        const items = Object.values(instance.items);\n        for (let j = 0; j < items.length; j += 1) {\n          const item = items[j];\n          const {\n            prevState,\n            currState\n          } = item.setLockedForAllCameras(currentFrame, locked);\n          if (prevState) {\n            prevItems.push(prevState);\n          }\n          if (currState) {\n            currItems.push(currState);\n            currState.cameras.forEach(({\n              camera\n            }) => {\n              updateShapeLockedState(item, camera, locked);\n            });\n          }\n        }\n        if (prevItems.length > 0) {\n          prevInstances.push({\n            ...basicInfo,\n            children: prevItems\n          });\n        }\n        if (currItems.length > 0) {\n          currInstances.push({\n            ...basicInfo,\n            children: currItems\n          });\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: prevInstances\n    }, {\n      instances: currInstances\n    });\n  }\n\n  /**\n   * is all layer shapes locked in current frame\n   * @param camera\n   * @param layer\n   */\n  isLayerLocked(camera, layer) {\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const {\n      activeLayerIndex\n    } = this.rootStore.config;\n    let locked = true;\n    let currentEmpty = true;\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const items = Object.values(instance.items);\n      for (let j = 0; j < items.length; j += 1) {\n        var _item$cameras$camera3;\n        const item = items[j];\n        const frameData = (_item$cameras$camera3 = item.cameras[camera]) === null || _item$cameras$camera3 === void 0 ? void 0 : _item$cameras$camera3.frames[currentFrame];\n        if (frameData && frameData.matrixChangeAllowed) {\n          const {\n            layer: l = activeLayerIndex\n          } = frameData;\n          if (l === layer) {\n            currentEmpty = false;\n            if (!frameData.locked) {\n              locked = false;\n            }\n          }\n        }\n        if (!locked && !currentEmpty) {\n          break;\n        }\n      }\n      if (!locked && !currentEmpty) {\n        break;\n      }\n    }\n    return {\n      locked,\n      currentEmpty\n    };\n  }\n\n  /**\n   * set locked for all layer shapes in current frame\n   * @param camera\n   * @param layer\n   * @param locked\n   */\n  setLockedForLayer(camera, layer, locked) {\n    const {\n      updateShapeLockedState\n    } = this.rootStore.shape;\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const {\n      activeLayerIndex\n    } = this.rootStore.config;\n    const prevInstances = [];\n    const currInstances = [];\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const basicInfo = instance.getBasicInfo();\n      const prevItems = [];\n      const currItems = [];\n      const items = Object.values(instance.items);\n      for (let j = 0; j < items.length; j += 1) {\n        var _item$cameras$camera4;\n        const item = items[j];\n        const frameData = (_item$cameras$camera4 = item.cameras[camera]) === null || _item$cameras$camera4 === void 0 ? void 0 : _item$cameras$camera4.frames[currentFrame];\n        if (frameData) {\n          const {\n            layer: l = activeLayerIndex\n          } = frameData;\n          if (l === layer) {\n            const {\n              prevState,\n              currState\n            } = item.setLocked(camera, currentFrame, locked);\n            if (prevState) {\n              prevItems.push(prevState);\n            }\n            if (currState) {\n              currItems.push(currState);\n            }\n            updateShapeLockedState(item, camera, locked);\n          }\n        }\n      }\n      if (prevItems.length > 0) {\n        prevInstances.push({\n          ...basicInfo,\n          children: prevItems\n        });\n      }\n      if (currItems.length > 0) {\n        currInstances.push({\n          ...basicInfo,\n          children: currItems\n        });\n      }\n    }\n    this.rootStore.undo.push({\n      instances: prevInstances\n    }, {\n      instances: currInstances\n    });\n  }\n\n  /**\n   * lock or unlock all shapes in current frame\n   */\n  setAllLocked(locked) {\n    const {\n      updateShapeLockedState\n    } = this.rootStore.shape;\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const prevInstances = [];\n    const currInstances = [];\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      if (instance.frameStatus[currentFrame] !== undefined) {\n        const basicInfo = instance.getBasicInfo();\n        const prevItems = [];\n        const currItems = [];\n        const items = Object.values(instance.items);\n        for (let j = 0; j < items.length; j += 1) {\n          const item = items[j];\n          const {\n            prevState,\n            currState\n          } = item.setLockedForAllCameras(currentFrame, locked);\n          if (prevState) {\n            prevItems.push(prevState);\n          }\n          if (currState) {\n            currItems.push(currState);\n            currState.cameras.forEach(({\n              camera\n            }) => {\n              updateShapeLockedState(item, camera, locked);\n            });\n          }\n        }\n        if (prevItems.length > 0) {\n          prevInstances.push({\n            ...basicInfo,\n            children: prevItems\n          });\n        }\n        if (currItems.length > 0) {\n          currInstances.push({\n            ...basicInfo,\n            children: currItems\n          });\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: prevInstances\n    }, {\n      instances: currInstances\n    });\n  }\n\n  /**\n   * toggle locked status for selected items\n   */\n  toggleLockedForSelectedItems() {\n    const {\n      updateShapeLockedState\n    } = this.rootStore.shape;\n    const {\n      currentFrame,\n      currentCamera\n    } = this.rootStore.frame;\n    const selectedItems = this.selectedInstanceItems.length > 0 ? this.selectedInstanceItems : this.selectedInstances.map(i => Object.values(i.items)).flat();\n    const items = selectedItems.filter(item => {\n      var _item$cameras$current, _item$cameras$current2;\n      return (_item$cameras$current = item.cameras[currentCamera]) === null || _item$cameras$current === void 0 ? void 0 : (_item$cameras$current2 = _item$cameras$current.frames[currentFrame]) === null || _item$cameras$current2 === void 0 ? void 0 : _item$cameras$current2.matrixChangeAllowed;\n    });\n    if (items.length > 0) {\n      const currAllLocked = items.every(item => item.frameLocked[currentFrame]);\n      const prevInstances = {};\n      const currInstances = {};\n      for (let i = 0; i < items.length; i += 1) {\n        const item = items[i];\n        const basicInfo = item.instance.getBasicInfo();\n        const {\n          prevState,\n          currState\n        } = item.setLocked(currentCamera, currentFrame, !currAllLocked);\n        if (prevState) {\n          if (!prevInstances[item.instance.id]) {\n            prevInstances[item.instance.id] = {\n              ...basicInfo,\n              children: []\n            };\n          }\n          prevInstances[item.instance.id].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstances[item.instance.id]) {\n            currInstances[item.instance.id] = {\n              ...basicInfo,\n              children: []\n            };\n          }\n          currInstances[item.instance.id].children.push(currState);\n          currState.cameras.forEach(({\n            camera\n          }) => {\n            updateShapeLockedState(item, camera, !currAllLocked);\n          });\n        }\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstances)\n      }, {\n        instances: Object.values(currInstances)\n      });\n    }\n  }\n\n  /**\n   * get interpolator worker, create it if has not been initialized\n   */\n  getInterpolator() {\n    if (!this.interpolator) {\n      var _this$interpolator;\n      this.interpolator = new InterpolationWorker();\n      (_this$interpolator = this.interpolator) === null || _this$interpolator === void 0 ? void 0 : _this$interpolator.addEventListener('message', e => {\n        const {\n          type,\n          data\n        } = e.data;\n        if (type === 'interpolated') {\n          const timestamp = Date.now();\n          const {\n            camera,\n            frames\n          } = data;\n          frames.forEach(({\n            frameIndex,\n            shapes\n          }) => {\n            shapes.forEach(shape => {\n              const {\n                instanceItemId\n              } = shape;\n              const dataKey = `${frameIndex}-${camera}`;\n              const shapeKey = `${instanceItemId}-${camera}`;\n              if (!this.interpolatedShapes[dataKey]) {\n                this.interpolatedShapes[dataKey] = {\n                  timestamp,\n                  frameIndex,\n                  camera,\n                  shapes: {}\n                };\n              } else {\n                this.interpolatedShapes[dataKey].timestamp = timestamp;\n              }\n              this.interpolatedShapes[dataKey].shapes[shapeKey] = shape;\n            });\n          });\n          this.resolveInterpolatedShapes();\n        }\n        if (type === 'pixel-resolved') {\n          const instanceItems = [];\n          const {\n            camera,\n            frameIndex,\n            shapes\n          } = data;\n          for (let i = 0; i < shapes.length; i += 1) {\n            var _this$instances$insta;\n            const {\n              shapeType,\n              shape,\n              layer,\n              instanceId,\n              instanceItemId\n            } = shapes[i];\n            const instanceItem = (_this$instances$insta = this.instances[instanceId]) === null || _this$instances$insta === void 0 ? void 0 : _this$instances$insta.items[instanceItemId];\n            if (instanceItem) {\n              instanceItems.push({\n                instanceItem,\n                camera,\n                frameIndex,\n                shapeType,\n                shape,\n                layer,\n                order: 0\n              });\n            }\n          }\n          if (instanceItems.length > 0) {\n            this.updateFrameShapeForInstanceItems(instanceItems);\n            if (frameIndex === this.rootStore.frame.currentFrame) {\n              instanceItems.forEach(({\n                instanceItem\n              }) => {\n                this.rootStore.shape.setupShape(instanceItem, camera);\n              });\n            }\n            this.interpolatedFrames.add(frameIndex);\n            this.showInterpolatedSuccessMessage();\n          }\n          this.resolveInterpolatedShapes();\n        }\n      });\n    }\n    return this.interpolator;\n  }\n\n  /**\n   * interpolate frames by base frame\n   * @param baseFrame\n   * @param frames\n   * @param camera\n   * @param instanceItems\n   */\n  interpolate(baseFrame, frames, camera = this.rootStore.frame.currentCamera, instanceItems) {\n    var _attributes$camera$ba, _attributes$camera$ba2, _attributes$camera$ba3, _attributes$camera$ba4, _attributes$camera$ba5, _attributes$camera$ba6;\n    const {\n      niftiParser,\n      attributes,\n      getReadableImage\n    } = this.rootStore.frame;\n    const data = {\n      interpolateUrl: `${this.rootStore.config.interpolateProxy}/interpolate`,\n      baseUrl: getReadableImage(camera, baseFrame),\n      baseSize: [(_attributes$camera$ba = (_attributes$camera$ba2 = attributes[camera][baseFrame]) === null || _attributes$camera$ba2 === void 0 ? void 0 : _attributes$camera$ba2.imageWidth) !== null && _attributes$camera$ba !== void 0 ? _attributes$camera$ba : 0, (_attributes$camera$ba3 = (_attributes$camera$ba4 = attributes[camera][baseFrame]) === null || _attributes$camera$ba4 === void 0 ? void 0 : _attributes$camera$ba4.imageHeight) !== null && _attributes$camera$ba3 !== void 0 ? _attributes$camera$ba3 : 0],\n      baseRotation: (_attributes$camera$ba5 = (_attributes$camera$ba6 = attributes[camera][baseFrame]) === null || _attributes$camera$ba6 === void 0 ? void 0 : _attributes$camera$ba6.rotation) !== null && _attributes$camera$ba5 !== void 0 ? _attributes$camera$ba5 : 0,\n      baseShapes: [],\n      camera,\n      frames: frames.map(frameIndex => ({\n        frameIndex,\n        url: getReadableImage(camera, frameIndex)\n      })),\n      isBase64: !!niftiParser\n    };\n    const items = instanceItems !== null && instanceItems !== void 0 ? instanceItems : Object.values(this.instances).map(instance => Object.values(instance.items)).flat();\n    for (let i = 0; i < items.length; i += 1) {\n      const instanceItem = items[i];\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData) {\n        const frameData = cameraData.frames[baseFrame];\n        if (interpolationSupportedShapeTypes.includes(frameData === null || frameData === void 0 ? void 0 : frameData.shapeType)) {\n          data.baseShapes.push({\n            shapeType: frameData.shapeType,\n            shape: frameData.shape,\n            layer: frameData.layer,\n            order: frameData.order,\n            instanceId: instanceItem.instance.id,\n            instanceItemId: instanceItem.id\n          });\n        }\n      }\n    }\n    if (data.baseShapes.length > 0) {\n      var _this$getInterpolator;\n      (_this$getInterpolator = this.getInterpolator()) === null || _this$getInterpolator === void 0 ? void 0 : _this$getInterpolator.postMessage({\n        type: 'interpolate',\n        data\n      });\n      message.info(i18n.translate('INTERPOLATION_FRAMES_INFO', {\n        values: {\n          frames: formatFrames(frames)\n        }\n      }));\n    } else {\n      message.warn(i18n.translate('INTERPOLATION_FRAMES_WARN'));\n    }\n  }\n\n  /**\n   * resolve interpolated shapes, including:\n   * 1) resolve pixel shapes overlaps\n   */\n  resolveInterpolatedShapes() {\n    const sorted = Object.values(this.interpolatedShapes).sort((a, b) => a.timestamp - b.timestamp);\n    const oldest = sorted[0];\n    if (oldest !== undefined) {\n      var _this$getInterpolator2;\n      const {\n        frameIndex,\n        camera,\n        shapes\n      } = oldest;\n      const dataKey = `${frameIndex}-${camera}`;\n      delete this.interpolatedShapes[dataKey];\n      const rotation = this.rootStore.frame.getFrameRotationForCamera(camera, frameIndex);\n      const data = {\n        camera,\n        frameIndex,\n        rotation,\n        shapes: Object.values(shapes),\n        originPixelShapes: [],\n        pixelLocked: this.rootStore.segmentation.locked\n      };\n      Object.values(this.instances).forEach(instance => {\n        Object.values(instance.items).forEach(instanceItem => {\n          var _instanceItem$cameras0;\n          const frameData = (_instanceItem$cameras0 = instanceItem.cameras[camera]) === null || _instanceItem$cameras0 === void 0 ? void 0 : _instanceItem$cameras0.frames[frameIndex];\n          if ((frameData === null || frameData === void 0 ? void 0 : frameData.shapeType) === ShapeType.PIXEL) {\n            const shapeKey = `${instanceItem.id}-${camera}`;\n            if (!shapes[shapeKey]) {\n              data.originPixelShapes.push({\n                shape: frameData.shape,\n                locked: frameData.locked,\n                layer: frameData.layer,\n                instanceId: instance.id,\n                instanceItemId: instanceItem.id\n              });\n            }\n          }\n        });\n      });\n      (_this$getInterpolator2 = this.getInterpolator()) === null || _this$getInterpolator2 === void 0 ? void 0 : _this$getInterpolator2.postMessage({\n        type: 'pixel-resolve',\n        data\n      });\n    }\n  }\n  /**\n   * enter reorganize mode\n   * @param instanceItemName\n   */\n  enterReorganizeMode(instanceItemName) {\n    this.exitReorganizeMode();\n    if (this.selectedInstances.length === 1 && (instanceItemName || this.selectedInstanceItems.length === 1)) {\n      this.reorganizingInstance = this.selectedInstances[0];\n      this.reorganizingInstanceItemName = instanceItemName || this.selectedInstanceItems[0].name;\n      let label = '';\n      if (this.reorganizingInstance.isSingle) {\n        // single\n        label = i18n.translate('CHANGE_CATEGORY_REORGANIZE_ITEM_LABEL_SINGLE', {\n          values: {\n            instance: this.reorganizingInstance.label\n          }\n        });\n      } else {\n        var _this$reorganizingIns4;\n        const itemLabel = (_this$reorganizingIns4 = this.reorganizingInstance.categoryRef.children.find(c => c.name === this.reorganizingInstanceItemName)) === null || _this$reorganizingIns4 === void 0 ? void 0 : _this$reorganizingIns4.displayName;\n        label = i18n.translate('CHANGE_CATEGORY_REORGANIZE_ITEM_LABEL', {\n          values: {\n            instance: this.reorganizingInstance.label,\n            item: itemLabel || this.reorganizingInstanceItemName\n          }\n        });\n      }\n      this.reorganizingMsg = message.open({\n        content: React.createElement(Message, {\n          message: i18n.translate('CHANGE_CATEGORY_REORGANIZE_TIP', {\n            values: {\n              label\n            }\n          }),\n          btn: i18n.translate('CHANGE_CATEGORY_REORGANIZE_FINISH'),\n          onBtnClick: () => this.exitReorganizeMode()\n        }),\n        duration: 0,\n        icon: null,\n        className: 'mode-message'\n      });\n    }\n  }\n\n  /**\n   * exit reorganize mode\n   */\n  exitReorganizeMode() {\n    if (this.reorganizingMsg) {\n      this.reorganizingMsg();\n    }\n    this.reorganizingInstance = undefined;\n    this.reorganizingInstanceItemName = undefined;\n    this.reorganizingMsg = undefined;\n  }\n\n  /**\n   * try to reorganize\n   */\n  tryReorganize() {\n    if (this.reorganizingInstance && this.reorganizingInstanceItemName && this.isSingleSelected) {\n      var _selectedInstanceItem2;\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const frameData = (_selectedInstanceItem2 = selectedInstanceItem.cameras[currentCamera]) === null || _selectedInstanceItem2 === void 0 ? void 0 : _selectedInstanceItem2.frames[currentFrame];\n      if (selectedInstanceItem.instance.id === this.reorganizingInstance.id) {\n        if (!(frameData === null || frameData === void 0 ? void 0 : frameData.numberChangeAllowed)) {\n          // same instance, but number change is disabled\n          return;\n        }\n      } else if (!(frameData === null || frameData === void 0 ? void 0 : frameData.numberChangeAllowed) && selectedInstanceItem.instance.number !== this.reorganizingInstance.number || !(frameData === null || frameData === void 0 ? void 0 : frameData.categoryChangeAllowed) && selectedInstanceItem.instance.category !== this.reorganizingInstance.category) {\n        return;\n      }\n      const currentTool = getToolTypeFromFrameData(frameData);\n      if (currentTool) {\n        const categoryItem = this.reorganizingInstance.categoryRef.children.find(c => c.name === this.reorganizingInstanceItemName);\n        if (categoryItem) {\n          const tools = categoryItem.tools.map(t => t.type);\n          if (includeSameTool(currentTool, tools)) {\n            // same shape type, do reorganize\n            const targetInstanceNum = selectedInstanceItem.instance.id === this.reorganizingInstance.id && selectedInstanceItem.name === this.reorganizingInstanceItemName ? undefined // in same instance, and same instance item name, should move to new instance\n            : this.reorganizingInstance.number;\n            this.changeCategoryForInstanceItem(selectedInstanceItem, this.reorganizingInstance.category, this.reorganizingInstanceItemName, {\n              [currentCamera]: [currentFrame]\n            }, targetInstanceNum);\n          } else {\n            message.warning(i18n.translate('CHANGE_CATEGORY_REORGANIZE_DIFF_SHAPE'));\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["React","makeAutoObservable","runInAction","v4","uuidv4","message","cloneDeep","debounce","Instance","InstanceItem","ShapeWorker","InterpolationWorker","i18n","formatFrames","getNextKeyFrames","getShapeTypeByTool","getToolTypeFromFrameData","includeSameTool","isCategoryChangeAllowed","isNumberChangeAllowed","isShapeDataMinified","preciseShapeByType","updateAttributesByFieldsCompare","DraggableType","NumberingMode","ViewMode","InstanceItemNumberingMode","ShapeType","Message","interpolationSupportedShapeTypes","PIXEL","POLYGON","InstanceStore","categoryInstancesMap","map","Object","values","instances","forEach","instance","category","push","rootStore","ontology","categories","className","sort","a","b","number","allInstances","instanceAFirstFrame","Number","keys","frameStatus","instanceBFirstFrame","instanceACategoryIndex","findIndex","c","instanceBCategoryIndex","isMultiSelected","selectedInstances","length","selectedInstanceItems","isSingleSelected","selectedInstanceAttributesEnabled","selectedInstance","selectedInstanceItem","undefined","isAttributesEnabled","currentLockedStatus","currentFrame","frame","currentEmpty","locked","i","status","frameLocked","categoryLockedStatus","lockedStatus","reduce","acc","curr","constructor","draggingType","INSTANCE","maxInstanceItemNumber","attrPendingInstanceItems","lastPendingInstanceItem","minifiedShapes","minifiedShapesCount","minifiedShapeResolver","interpolator","interpolatedShapes","interpolatedFrames","Set","reorganizingInstance","reorganizingInstanceItemName","reorganizingMsg","isAnyCategoryOrNumberChangeDisabled","deleteFramesFromInstanceItem","instanceItem","frames","camera","currentCamera","_this$rootStore$nifti","unlockedFrames","filter","frameIndex","_instanceItem$cameras","frameData","cameras","deleteLocked","prevBasicInfo","getBasicInfo","includes","_instanceItem$cameras2","shape","deleteShapeByInstanceItem","shapeType","layer","config","activeLayerIndex","segmentation","update","prevRelationships","currRelationships","relationship","deleteFromFramesByInstanceItem","prevState","currState","remove","basicInfo","undo","children","relationships","nifti","updateShape","isEmpty","deleteInstanceItem","deleteInstance","selectInstanceItem","selectInstance","deleteFramesFromInstanceItems","instanceItems","prevInstanceMap","currInstanceMap","prevRelationshipMap","currRelationshipMap","_this$rootStore$nifti2","id","instanceId","_instanceItem$cameras3","_instanceItem$cameras4","r","prevInstanceBasicInfo","deleteInstanceItemByFrame","_this$rootStore$nifti3","_instanceItem$cameras5","deleteFramesFromInstanceItemByType","type","nextKeyFrames","nextKeyFrame","Array","from","_","index","allFrames","f","parseInt","indexOf","slice","showInterpolatedSuccessMessage","delete","success","translate","autoBind","clearInstances","init","fromPreAnnotation","cameraNames","updateNextShapeOrder","layers","numberingMode","instanceItemNumberingMode","dataPrecision","layersCount","globalInstanceItemNumbers","categoryNumbers","numberDuplicatedInstances","find","instanceNumberChangeDisabled","categoryItem","name","cameraData","_frameData$preAnnotat","_frameData$preAnnotat2","order","instanceItemId","isRaw","preAnnotationData","editMode","_numberDuplicatedInst","GLOBAL","child","annotatable","fixInstance","fixItems","checkNumbers","flatMap","n","createInstanceFromData","getNextInstanceNumber","currInstance","itemId","item","getNextInstanceItemNumber","createItemFromData","resolveMinifiedShapes","getCategory","forceMultiple","newInstance","categoryRef","currentWorkerId","jobProxy","workerId","currentWorkerName","workerName","attributes","dynamicAttributes","items","getNextShapeOrder","addEventListener","e","data","shapeUpdated","pop","postMessage","isInstanceAttributesEnabled","labelConfig","isInstanceDynamicAttributesEnabled","labelConfigDynamic","isInstanceItemAttributesEnabled","isOCR","isFormula","categoryItemRef","instanceAttributesEnabled","instanceDynamicAttributesEnabled","some","getInstanceById","categoryName","allInstanceNumbers","Math","max","categoryInstanceNumbers","categoryItemName","itemsInCamera","itemNumbers","updateSelectedInstance","isArray","setSelected","updateSelectedInstanceItem","autoFocus","shouldPredict","isSingleCamera","isSingle","selectCategory","selectCategoryItem","allCategories","selectedCategoryName","selectShapeByInstanceItem","updateShapesInInstance","viewMode","DEFAULT","fitShapes","instanceSet","updateActiveLayerIndexByInstanceItems","allLayers","_instanceItem$cameras6","add","has","size","allLayersArr","setActiveLayerIndex","getCurrentInstanceItem","currentCategoryName","currentCategoryItemName","selectedCategoryItemName","create","getCategoryItem","count","maxCount","Infinity","isGlobalItem","getItemsByName","createInstanceItem","createInstance","getInstanceItemForPaste","selectedCategory","supportedCategoryItems","shapeTypes","tools","tool","supportedCategoryItemNames","supportedSelectedInstanceItems","defaultNumber","selectedCategoryItem","existItem","getItem","destroy","removeItem","updateFrameShapeForInstanceItem","_this$rootStore$nifti4","autoInterpolation","shapeLayer","_instanceItem$cameras7","instanceState","prev","relationshipState","stat","updateFrameShapeForInstanceItems","_this$rootStore$nifti5","state","_instanceItem$cameras8","moveInstanceItem","targetCategory","targetCategoryItem","targetInstanceId","targetInstanceItemId","newDynamicInstanceAttr","newInstanceAttr","newInstanceItemAttr","currPrevInstance","targetInstance","targetPrevInstance","targetInstanceItemDefaultNumber","targetInstanceItem","_targetInstance$dynam","currIsPixelShape","currInstanceItem","framesData","frameJson","toJSON","targetPrevState","targetCurrState","updateFramesFromData","setAttributes","deleteFromFrames","deleteConnection","createConnection","setDynamicAttributesByCamera","targetCurrInstance","prevInstance","changeInstanceItemForInfoMap","currentShape","getShapeByInstanceItem","deleteShape","setupShape","getTargetInstance","sourceInstance","targetInstanceNum","isTargetInstanceNewCreated","affectedInstanceInGlobalMode","_affectedInstanceInGl","isNumberChangeDisabled","_sourceInstance$categ","_targetInstance$categ","newInstanceAttributes","fields","getTargetInstanceItem","sourceInstanceItemNumber","_targetInstance$categ2","existingItems","existingItemWithSameNumber","Error","targetInstanceItemNumber","changeCategoryForInstanceItemPure","sourceInstanceItem","affectedCameraFrames","_this$reorganizingIns","_this$reorganizingIns2","_this$reorganizingIns3","sourceCategoryItemRef","prevSourceInstanceBasicInfo","prevTargetInstanceBasicInfo","targetCategoryItemRef","instanceItemMovedTo","updateInstanceMap","instanceMap","concat","updatedFramesSet","affectedCameras","_sourceInstanceItem$c","_targetInstanceItem$c","cameraName","sourceFramesCount","targetFramesCount","sourceRelationships","targetRelationships","movedFrameData","updatedRelationships","_sourceInstanceItem$c2","_targetInstanceItem$c2","sourceFrameData","targetFrameData","numberChangeAllowed","categoryChangeAllowed","frameDataJson","attrChangeAllowed","_sourceCategoryItemRe","_targetCategoryItemRe","movedFramesCount","instanceMovedTo","shouldMoveRelationship","fromInstanceItem","toInstanceItem","deleteRelationship","framesCount","_sourceInstance$categ2","_sourceInstance$categ3","_targetInstance$categ3","_targetInstance$categ4","sourceInstanceDynamicAttr","sourceInstanceDynamicAttrByCamera","framesIndex","sourceStat","targetStat","sourceFields","targetFields","updatedFrames","targetInstanceDynamicAttr","targetInstanceDynamicAttrByCamera","updatedDynamicAttrs","_sourceInstanceDynami","_sourceInstanceDynami2","updatedDynamicAttrbutes","_sourceInstanceDynami3","deleteDynamicAttributesByCamera","prevInstances","currInstances","changeCategoryForInstance","targetCategoryName","pendingInstanceItems","allItems","error","_targetInstance","_targetInstance2","filterInstances","autoOpenAttributesModal","changeCategoryForInstanceItem","source","label","target","warning","changeCategoryForInstanceItems","selectedInstanceInfo","attrs","getInstancesState","selectInstanceInfoMap","Map","instanceInfo","key","get","set","_cameras$camera","_targetInstance4","static","dynamic","newInstanceDynamicAttr","_targetInstance3","updatedFrameAttributes","setAttributesByFrame","changeLayer","targetLayer","_selectedInstanceItem","instanceBasicInfo","itemBasicInfo","setContextMenuVisible","ignoreAttributes","_selectedInstance$dyn","_selectedInstance$dyn2","preferences","shouldOpen","_instanceItem$cameras9","OCRText","shouldSyncOCR","formulaText","setAttributesModalVisible","open","openAttributesModalFromPending","shift","setTimeout","openAttributesModalForInstanceItems","setDraggingType","draggableId","split","updateByDragging","destination","autoTracking","inexistentGraphicsCardVisibility","droppableId","categoryInstances","originIndex","splice","ITEM","targetId","targetCamera","selectedName","selectedNameItemsCount","_item$cameras$camera","sameInstance","selectedNumber","updateCameraData","originInstanceItem","newInstanceItem","createCameraFromData","targetCameraData","addRelationship","targetInstanceItems","_item$cameras$camera2","aIndex","bIndex","selectedNameFirstItemIndex","selectedNameLastItemIndex","targetCameraDataList","exactIndex","min","d","originTargetInstanceItem","_targetInstance$dynam2","_targetInstance$dynam3","_targetInstance$dynam6","_targetInstance$dynam7","_selectedInstance$dyn3","_selectedInstance$dyn4","_selectedInstance$dyn7","_selectedInstance$dyn8","_targetInstance$dynam4","_targetInstance$dynam5","_selectedInstance$dyn5","_selectedInstance$dyn6","currentSelectedInstanceItem","instancesJSON","options","getCurrentDynamicAttributesByInstance","_instance$dynamicAttr","_instance$dynamicAttr2","switch","searchClassName","nodes","document","querySelectorAll","selectedIndex","classList","contains","nextIndex","nextNodes","nextNode","eventName","dispatchEvent","MouseEvent","view","window","bubbles","cancelable","buttons","setLockedForCategory","updateShapeLockedState","prevItems","currItems","j","setLockedForAllCameras","isLayerLocked","_item$cameras$camera3","matrixChangeAllowed","l","setLockedForLayer","_item$cameras$camera4","setLocked","setAllLocked","toggleLockedForSelectedItems","selectedItems","flat","_item$cameras$current","_item$cameras$current2","currAllLocked","every","getInterpolator","_this$interpolator","timestamp","Date","now","shapes","dataKey","shapeKey","resolveInterpolatedShapes","_this$instances$insta","interpolate","baseFrame","_attributes$camera$ba","_attributes$camera$ba2","_attributes$camera$ba3","_attributes$camera$ba4","_attributes$camera$ba5","_attributes$camera$ba6","niftiParser","getReadableImage","interpolateUrl","interpolateProxy","baseUrl","baseSize","imageWidth","imageHeight","baseRotation","rotation","baseShapes","url","isBase64","_this$getInterpolator","info","warn","sorted","oldest","_this$getInterpolator2","getFrameRotationForCamera","originPixelShapes","pixelLocked","_instanceItem$cameras0","enterReorganizeMode","instanceItemName","exitReorganizeMode","_this$reorganizingIns4","itemLabel","displayName","content","createElement","btn","onBtnClick","duration","icon","tryReorganize","_selectedInstanceItem2","currentTool","t"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/InstanceStore.ts"],"sourcesContent":["import React from 'react';\nimport { makeAutoObservable, runInAction } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { message } from 'antd';\nimport { MessageType } from 'antd/es/message';\nimport { cloneDeep, debounce } from 'lodash';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport Relationship from '../model/Relationship';\nimport ShapeWorker from '../worker/shape.worker';\nimport InterpolationWorker, { InterpolatedShape, InterpolationData, InterpolationResult, ShapeResolutionData, ShapeResolutionResult } from '../worker/interpolation.worker';\nimport i18n from '../locales';\nimport { formatFrames, getNextKeyFrames, getShapeTypeByTool, getToolTypeFromFrameData, includeSameTool, isCategoryChangeAllowed, isNumberChangeAllowed, isShapeDataMinified, preciseShapeByType, updateAttributesByFieldsCompare } from '../utils';\nimport { Instance as IInstance, InstanceItem as IInstanceItem, CategoryItem, Relationship as IRelationship, DraggableType, CameraData, NumberingMode, ViewMode, InstanceItemNumberingMode, FrameData, DynamicAttributes } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\nimport { PixelData } from '../../common/shapes/Pixel';\nimport Message from '../components/message/Message';\n\nexport const interpolationSupportedShapeTypes = [\n  ShapeType.PIXEL,\n  ShapeType.POLYGON,\n];\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * all instances\n   */\n  instances: { [instanceId: string]: Instance } = {};\n\n  /**\n   * selected instances\n   */\n  selectedInstances: Instance[] = [];\n\n  /**\n   * selected instance items\n   */\n  selectedInstanceItems: InstanceItem[] = [];\n\n  /**\n   * current dragging type\n   */\n  draggingType: DraggableType = DraggableType.INSTANCE;\n\n  /**\n   * current max instance item number (used when item numbering mode is global)\n   */\n  maxInstanceItemNumber = 0;\n\n  /**\n   * instance items waiting for attributes setting\n   */\n  attrPendingInstanceItems: InstanceItem[] = [];\n\n  /**\n   * last selected pending instance item\n   */\n  lastPendingInstanceItem: InstanceItem | null = null;\n\n  /**\n   * minified shapes\n   */\n  minifiedShapes: {\n    instanceId: string\n    instanceItemId: string;\n    camera: string;\n    frameIndex: number;\n    shapeType: ShapeType;\n    shape: ShapeData;\n  }[] = [];\n\n  /**\n   * minified shapes count\n   */\n  minifiedShapesCount = 0;\n\n  /**\n   * minified shape resolver\n   */\n  minifiedShapeResolver?: Worker;\n\n  /**\n   * interpolation worker\n   */\n  interpolator?: Worker;\n\n  /**\n   * interpolated shapes (not add to store yet)\n   */\n  interpolatedShapes: Record<string, {\n    timestamp: number;\n    frameIndex: number;\n    camera: string;\n    shapes: Record<string, InterpolatedShape>;\n  }> = {};\n\n  /**\n   * interpolated success frames\n   */\n  interpolatedFrames: Set<number> = new Set();\n\n  /**\n   * reorganizing instance\n   */\n  reorganizingInstance?: Instance;\n\n  /**\n   * instance item name being reorganizing\n   */\n  reorganizingInstanceItemName?: string;\n\n  /**\n   * reorganizing message\n   */\n  reorganizingMsg?: MessageType;\n\n  /**\n   * is any category or number change disblaed\n   */\n  isAnyCategoryOrNumberChangeDisabled = false;\n\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map: { [categoryName: string]: Instance[] } = {};\n    Object.values(this.instances).forEach((instance) => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({ className }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.number - b.number);\n      }\n    });\n    return map;\n  };\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    const { categories } = this.rootStore.ontology;\n    return Object.values(this.instances)\n      .sort((a, b) => {\n        const instanceAFirstFrame = Number(Object.keys(a.frameStatus)[0]);\n        const instanceBFirstFrame = Number(Object.keys(b.frameStatus)[0]);\n        if (instanceAFirstFrame > instanceBFirstFrame) {\n          return 1;\n        }\n        if (instanceAFirstFrame < instanceBFirstFrame) {\n          return -1;\n        }\n        const instanceACategoryIndex = categories.findIndex((c) => c.className === a.category);\n        const instanceBCategoryIndex = categories.findIndex((c) => c.className === b.category);\n        if (instanceACategoryIndex > instanceBCategoryIndex) {\n          return 1;\n        }\n        if (instanceACategoryIndex < instanceBCategoryIndex) {\n          return -1;\n        }\n        return a.number > b.number ? 1 : -1;\n      });\n  }\n\n  /**\n   * multiple instance item selected\n   * @getter\n   */\n  get isMultiSelected() {\n    return this.selectedInstances.length > 1 || this.selectedInstanceItems.length > 1;\n  }\n\n  /**\n   * single instance item selected\n   */\n  get isSingleSelected() {\n    return this.selectedInstances.length === 1 && this.selectedInstanceItems.length === 1;\n  }\n\n  /**\n   * does selected instance has label config to set attributes\n   * @getter\n   */\n  get selectedInstanceAttributesEnabled() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return false;\n    }\n\n    const selectedInstance = this.selectedInstances[0];\n    const selectedInstanceItem = this.selectedInstanceItems.length === 1 ? this.selectedInstanceItems[0] : undefined;\n    return this.isAttributesEnabled(selectedInstance, selectedInstanceItem);\n  }\n\n  /**\n   * is all shapes locked in current frame\n   */\n  get currentLockedStatus() {\n    const { currentFrame } = this.rootStore.frame;\n    const allInstances = Object.values(this.instances);\n\n    let currentEmpty = true;\n    let locked = true;\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const status = instance.frameLocked[currentFrame];\n      if (status !== undefined) {\n        currentEmpty = false;\n        if (locked && !status) {\n          locked = false;\n        }\n      }\n      if (!currentEmpty && !locked) {\n        break;\n      }\n    }\n\n    return {\n      locked,\n      currentEmpty,\n    };\n  }\n\n  /**\n   * category locked status\n   */\n  get categoryLockedStatus() {\n    const { currentFrame } = this.rootStore.frame;\n    const { categories } = this.rootStore.ontology;\n    const allInstances = Object.values(this.instances);\n\n    const lockedStatus: {\n      [category: string]: {\n        locked: boolean;\n        currentEmpty: boolean;\n      }\n    } = categories.reduce((acc, curr) => ({\n      ...acc,\n      [curr.className]: { locked: true, currentEmpty: true },\n    }), {});\n\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const { category } = instance;\n      if (lockedStatus[category].locked || lockedStatus[category].currentEmpty) {\n        const status = instance.frameLocked[currentFrame];\n        if (status !== undefined) {\n          lockedStatus[instance.category].currentEmpty = false;\n          if (lockedStatus[instance.category].locked && !status) {\n            lockedStatus[instance.category].locked = false;\n          }\n        }\n      }\n    }\n\n    return lockedStatus;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      maxInstanceItemNumber: false,\n      attrPendingInstanceItems: false,\n      lastPendingInstanceItem: false,\n      minifiedShapes: false,\n      minifiedShapeResolver: false,\n      interpolator: false,\n      interpolatedShapes: false,\n      interpolatedFrames: false,\n      reorganizingInstance: false,\n      reorganizingInstanceItemName: false,\n      reorganizingMsg: false,\n      isAnyCategoryOrNumberChangeDisabled: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  clearInstances() {\n    this.instances = {};\n    this.selectedInstances = [];\n    this.selectedInstanceItems = [];\n  }\n\n  /**\n   * init instances\n   * @param instances\n   * @param fromPreAnnotation\n   */\n  async init(instances: IInstance[], fromPreAnnotation = false) {\n    this.clearInstances();\n    const { categories } = this.rootStore.ontology;\n    const { cameraNames, updateNextShapeOrder } = this.rootStore.frame;\n    const { layers, numberingMode, instanceItemNumberingMode, dataPrecision } = this.rootStore.config;\n    const layersCount = layers.length || 1;\n    const globalInstanceItemNumbers: number[] = [];\n    const categoryNumbers: { [category: string]: number[] } = {};\n    const numberDuplicatedInstances: {\n      [instanceId: string]: {\n        instance: IInstance;\n        fixInstance: boolean;\n        fixItems?: string[];\n      };\n    } = {};\n    instances.forEach((instance) => {\n      const category = categories.find((c) => c.className === instance.category);\n      if (category) {\n        let instanceNumberChangeDisabled = false;\n        instance.children.forEach((instanceItem) => {\n          const categoryItem = category.children.find((c) => c.name === instanceItem.name);\n          if (categoryItem) {\n            instanceItem.cameras.forEach((cameraData) => {\n              if (cameraNames.includes(cameraData.camera)) {\n                cameraData.frames.forEach((frameData) => {\n                  // fix shape data precision\n                  preciseShapeByType(frameData.shapeType, frameData.shape, dataPrecision);\n                  // fix shape layer\n                  if (frameData.layer === undefined || frameData.layer >= layersCount || frameData.layer < 0) {\n                    frameData.layer = 0;\n                  }\n                  // update next shape order\n                  if (typeof frameData.order === 'number' && frameData.order >= 0) {\n                    updateNextShapeOrder(frameData.order, frameData.layer, frameData.frameIndex, cameraData.camera);\n                  }\n                  // check minified\n                  if (isShapeDataMinified(frameData.shapeType, frameData.shape)) {\n                    this.minifiedShapes.push({\n                      instanceId: instance.id,\n                      instanceItemId: instanceItem.id,\n                      camera: cameraData.camera,\n                      frameIndex: frameData.frameIndex,\n                      shapeType: frameData.shapeType,\n                      shape: frameData.shape,\n                    });\n                    this.minifiedShapesCount += 1;\n                  }\n                  // set raw status\n                  frameData.isRaw = frameData.isRaw || fromPreAnnotation;\n                  // set category change disabled status\n                  instanceNumberChangeDisabled = instanceNumberChangeDisabled\n                    || !isNumberChangeAllowed(frameData.preAnnotationData?.editMode);\n                  this.isAnyCategoryOrNumberChangeDisabled = this.isAnyCategoryOrNumberChangeDisabled\n                    || instanceNumberChangeDisabled\n                    || !isCategoryChangeAllowed(frameData.preAnnotationData?.editMode);\n                });\n              } else {\n                cameraData.frames = [];\n              }\n            });\n            instanceItem.cameras = instanceItem.cameras.filter((c) => c.frames.length > 0); // remove invalid camera data\n          } else {\n            instanceItem.cameras = [];\n          }\n        });\n        instance.children = instance.children.filter((i) => i.cameras.length > 0); // remove invalid instance item data\n        if (instance.children.length > 0) {\n          // check instance item number\n          if (instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL) {\n            instance.children.forEach((child) => {\n              if (this.rootStore.annotatable && globalInstanceItemNumbers.indexOf(child.number) >= 0) {\n                if (!numberDuplicatedInstances[instance.id]) {\n                  numberDuplicatedInstances[instance.id] = {\n                    instance,\n                    fixInstance: false,\n                    fixItems: [],\n                  };\n                }\n                numberDuplicatedInstances[instance.id].fixItems!.push(child.id);\n              } else {\n                globalInstanceItemNumbers.push(child.number);\n                if (child.number > this.maxInstanceItemNumber) {\n                  this.maxInstanceItemNumber = child.number;\n                }\n              }\n            });\n          }\n\n          // check instance number\n          if (!categoryNumbers[category.className]) {\n            categoryNumbers[category.className] = [];\n          }\n          const checkNumbers = numberingMode === NumberingMode.GLOBAL\n            ? Object.values(categoryNumbers).flatMap((n) => n)\n            : categoryNumbers[category.className];\n          if (this.rootStore.annotatable && !instanceNumberChangeDisabled && checkNumbers.indexOf(instance.number) >= 0) {\n            // number already exists, fix number later\n            if (!numberDuplicatedInstances[instance.id]) {\n              numberDuplicatedInstances[instance.id] = {\n                instance,\n                fixInstance: true,\n              };\n            } else {\n              numberDuplicatedInstances[instance.id].fixInstance = true;\n            }\n          } else {\n            categoryNumbers[category.className].push(instance.number);\n          }\n\n          // noneed to fix number\n          if (!numberDuplicatedInstances[instance.id]?.fixInstance) {\n            this.createInstanceFromData(instance);\n          }\n        }\n      }\n    });\n    Object.values(numberDuplicatedInstances).forEach(({ instance, fixInstance, fixItems }) => {\n      if (fixInstance) {\n        const number = this.getNextInstanceNumber(instance.category);\n        instance.number = number;\n        this.createInstanceFromData(instance);\n      }\n      const currInstance = this.instances[instance.id];\n      if (currInstance) {\n        fixItems?.forEach((itemId) => {\n          const item = instance.children.find((i) => i.id === itemId);\n          if (item) {\n            const number = this.getNextInstanceItemNumber(instance.id, item.name);\n            item.number = number;\n            currInstance.createItemFromData(item);\n          }\n        });\n      }\n    });\n    this.resolveMinifiedShapes();\n  }\n\n  /**\n   * create instance from structured instance data\n   * @param instance\n   */\n  createInstanceFromData(instance: IInstance) {\n    const category = this.rootStore.ontology.getCategory(instance.category);\n    if (category) {\n      const { instanceItemNumberingMode, dataPrecision } = this.rootStore.config;\n      const forceMultiple = instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL;\n      const newInstance = new Instance({\n        id: instance.id,\n        categoryRef: category,\n        currentWorkerId: this.rootStore.jobProxy!.workerId,\n        currentWorkerName: this.rootStore.jobProxy!.workerName,\n        forceMultiple,\n        dataPrecision,\n        number: instance.number,\n        attributes: instance.attributes,\n        dynamicAttributes: instance.dynamicAttributes,\n        items: instance.children,\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder,\n      });\n      this.instances[newInstance.id] = newInstance;\n    }\n  }\n\n  /**\n   * resolve minified shapes\n   */\n  resolveMinifiedShapes() {\n    if (this.minifiedShapes.length > 0) {\n      if (!this.minifiedShapeResolver) {\n        this.minifiedShapeResolver = new ShapeWorker();\n        this.minifiedShapeResolver!.addEventListener('message', (e) => {\n          const { instanceId, instanceItemId, camera, frameIndex, shape } = e.data;\n          const instance = this.instances[instanceId];\n          if (instance) {\n            const instanceItem = instance.items[instanceItemId];\n            if (instanceItem) {\n              const cameraData = instanceItem.cameras[camera];\n              if (cameraData) {\n                const frameData = cameraData.frames[frameIndex];\n                if (frameData && !frameData.shapeUpdated) {\n                  // only update when shape data haven't been updated\n                  runInAction(() => {\n                    frameData.shape = shape;\n                  });\n                }\n              }\n            }\n          }\n          // continue\n          this.resolveMinifiedShapes();\n        });\n      }\n\n      this.minifiedShapesCount -= 1;\n      const item = this.minifiedShapes.pop();\n      this.minifiedShapeResolver!.postMessage(item);\n    }\n  }\n\n  /**\n   * is instance attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceAttributesEnabled(instance: Instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfig;\n  }\n\n  /**\n   * is instance dynamic attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceDynamicAttributesEnabled(instance: Instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfigDynamic;\n  }\n\n  /**\n   * is instance item attributes enabled\n   * @param instanceItem\n   */\n  isInstanceItemAttributesEnabled(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        if (frameData.isOCR || frameData.isFormula) {\n          // instance item currently is ocr shape or formula shape\n          return true;\n        }\n        if (instanceItem.categoryItemRef.labelConfig) {\n          // instance item has label config setting\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * is instance & instance item attributes enabled\n   * @param instance\n   * @param instanceItem\n   */\n  isAttributesEnabled(instance: Instance, instanceItem?: InstanceItem) {\n    const instanceAttributesEnabled = this.isInstanceAttributesEnabled(instance);\n    if (instanceAttributesEnabled) {\n      return true;\n    }\n    const instanceDynamicAttributesEnabled = this.isInstanceDynamicAttributesEnabled(instance);\n    if (instanceDynamicAttributesEnabled) {\n      return true;\n    }\n    if (instanceItem) {\n      return this.isInstanceItemAttributesEnabled(instanceItem);\n    }\n    return Object.values(instance.items).some((item) => this.isInstanceItemAttributesEnabled(item));\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId: string) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * get next instance number\n   * @param categoryName\n   */\n  getNextInstanceNumber(categoryName: string) {\n    if (this.rootStore.config.numberingMode === NumberingMode.GLOBAL) {\n      const allInstanceNumbers = Object.values(this.instances).map((i) => i.number);\n      return Math.max(...allInstanceNumbers, 0) + 1;\n    }\n    const categoryInstanceNumbers = (this.categoryInstancesMap[categoryName] || []).map((i) => i.number);\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * get next instance item number\n   * @param instanceId\n   * @param categoryItemName\n   * @param camera\n   */\n  getNextInstanceItemNumber(instanceId: string, categoryItemName: string, camera = this.rootStore.frame.currentCamera) {\n    if (this.rootStore.config.instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL) {\n      this.maxInstanceItemNumber += 1;\n      return this.maxInstanceItemNumber;\n    }\n    const instance = this.instances[instanceId];\n    const items = Object.values(instance.items).filter((i) => i.name === categoryItemName);\n    const itemsInCamera = items.filter((i) => {\n      const cameraData = i.cameras[camera];\n      return cameraData && !cameraData.isEmpty;\n    });\n    const itemNumbers = itemsInCamera.map((i) => i.number);\n    return Math.max(...itemNumbers, 0) + 1;\n  }\n\n  /**\n   * update selected instance\n   * @param instance\n   */\n  updateSelectedInstance(instance: Instance | Instance[]) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances.forEach((i) => {\n      if (instances.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstances = [...instances];\n    this.selectedInstances.forEach((i) => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * update selected instance item\n   * @param instanceItem\n   */\n  updateSelectedInstanceItem(instanceItem: InstanceItem | InstanceItem[]) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems.forEach((i) => {\n      if (instanceItems.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstanceItems = [...instanceItems];\n    this.selectedInstanceItems.forEach((i) => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * select instance\n   * @param instance\n   * @param autoFocus\n   * @param shouldPredict\n   */\n  selectInstance(instance?: Instance | Instance[] | null, autoFocus = false, shouldPredict = true) {\n    const instances = Array.isArray(instance) ? instance : [...instance ? [instance] : []];\n    this.updateSelectedInstance(instances);\n\n    if (instances.length > 0) {\n      // filter selected instance item\n      const instanceItems: InstanceItem[] = this.selectedInstanceItems.filter((i) => instances.indexOf(i.instance) >= 0);\n\n      // if the instance is single, default select first instance item\n      if (this.rootStore.frame.isSingleCamera) {\n        instances.forEach((i) => {\n          if (i.isSingle && Object.keys(i.items).length > 0) {\n            const item = Object.values(i.items)[0];\n            if (instanceItems.indexOf(item) < 0) {\n              instanceItems.push(item);\n            }\n          }\n        });\n      }\n      this.updateSelectedInstanceItem(instanceItems);\n\n      // select category & category item if needed\n      if (instanceItems.length === 1) {\n        // only one item is selected\n        this.rootStore.ontology.selectCategory(instanceItems[0].instance.category);\n        this.rootStore.ontology.selectCategoryItem(instanceItems[0].name);\n      } else {\n        // select first category if needed\n        const allCategories = instances.map((i) => i.category);\n        if (allCategories.indexOf(this.rootStore.ontology.selectedCategoryName) < 0) {\n          this.rootStore.ontology.selectCategory(allCategories[0]);\n        }\n      }\n    } else {\n      this.updateSelectedInstanceItem([]);\n    }\n\n    // update shape selection\n    this.rootStore.shape.selectShapeByInstanceItem(this.selectedInstanceItems, shouldPredict);\n    this.rootStore.shape.updateShapesInInstance(instances);\n    if (autoFocus) {\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        this.rootStore.shape.fitShapes();\n      } else {\n        // this.rootStore.grid.gridCanvas?.fitShapes();\n      }\n    }\n  }\n\n  /**\n   * select instance item\n   * @param instanceItem\n   * @param autoFocus\n   * @param shouldPredict\n   */\n  selectInstanceItem(instanceItem?: InstanceItem | InstanceItem[] | null, autoFocus = false, shouldPredict = true) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...instanceItem ? [instanceItem] : []];\n    this.updateSelectedInstanceItem(instanceItems);\n    const instanceSet = new Set(instanceItems.map((i) => i.instance));\n    const instances = Array.from(instanceSet);\n    this.selectInstance(instances, autoFocus, shouldPredict);\n  }\n\n  /**\n   * update active layer index by instance items\n   * @param instanceItems\n   */\n  updateActiveLayerIndexByInstanceItems(instanceItems: InstanceItem[]) {\n    const { layers, activeLayerIndex } = this.rootStore.config;\n    if (layers.length === 0) {\n      // not multi layers\n      return;\n    }\n\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const allLayers = new Set<number>();\n    instanceItems.forEach((instanceItem) => {\n      const { layer = activeLayerIndex } = instanceItem.cameras[currentCamera]?.frames[currentFrame] || {};\n      allLayers.add(layer);\n    });\n    if (!allLayers.has(activeLayerIndex) && allLayers.size > 0) {\n      const allLayersArr = Array.from(allLayers);\n      this.rootStore.config.setActiveLayerIndex(allLayersArr[0]);\n    }\n  }\n\n  /**\n   * get current editing instance item\n   */\n  getCurrentInstanceItem(\n    currentCategoryName = this.rootStore.ontology.selectedCategoryName,\n    currentCategoryItemName = this.rootStore.ontology.selectedCategoryItemName,\n    create = true\n  ) {\n    const selectedInstance = this.selectedInstances.find((i) => i.category === currentCategoryName) || this.selectedInstances[0];\n    if (selectedInstance && selectedInstance.category === currentCategoryName) {\n      const selectedInstanceItems = this.selectedInstanceItems.filter((i) => i.instance === selectedInstance);\n      const selectedInstanceItem = selectedInstanceItems.find((i) => i.name === currentCategoryItemName) || selectedInstanceItems[0];\n      if (selectedInstanceItem && selectedInstanceItem.name === currentCategoryItemName) {\n        // has selected instance item\n        const { currentCamera, currentFrame } = this.rootStore.frame;\n        const { frames } = selectedInstanceItem.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          // not exist in current frame\n          return selectedInstanceItem;\n        }\n      }\n      if (!create) {\n        return undefined;\n      }\n\n      const category = this.rootStore.ontology.getCategoryItem(currentCategoryName, currentCategoryItemName);\n      if (category) {\n        const { currentCamera } = this.rootStore.frame;\n        const { name, count, maxCount = Infinity } = category;\n        // find items exist in current camera\n        const isGlobalItem = this.rootStore.config.instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL;\n        const items = selectedInstance.getItemsByName(name).filter((i) => {\n          const cameraData = i.cameras[currentCamera];\n          return isGlobalItem || (cameraData && !cameraData.isEmpty);\n        });\n        if ((count !== undefined && items.length < count) || (count === undefined && items.length < maxCount)) {\n          return this.createInstanceItem(selectedInstance, currentCategoryItemName);\n        }\n      }\n    }\n    if (!create) {\n      return undefined;\n    }\n    // return a new instance\n    const instance = this.createInstance(currentCategoryName);\n    return this.createInstanceItem(instance!, currentCategoryItemName);\n  }\n\n  /**\n   * get instance item for paste\n   * @param shapeType\n   */\n  getInstanceItemForPaste(shapeType: ShapeType) {\n    const { selectedCategory } = this.rootStore.ontology;\n\n    const supportedCategoryItems: CategoryItem[] = [];\n    selectedCategory.children.forEach((item) => {\n      const shapeTypes = new Set(item.tools.map((tool) => getShapeTypeByTool(tool.type)));\n      if (shapeTypes.has(shapeType)) {\n        supportedCategoryItems.push(item);\n      }\n    });\n    if (supportedCategoryItems.length <= 0) {\n      // no avaliable category items\n      return null;\n    }\n\n    const supportedCategoryItemNames = supportedCategoryItems.map((i) => i.name);\n    const selectedInstance = this.selectedInstances.find((i) => i.category === selectedCategory.className);\n    if (selectedInstance) {\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const supportedSelectedInstanceItems = this.selectedInstanceItems.filter((i) => i.instance === selectedInstance && supportedCategoryItemNames.includes(i.name));\n\n      let instanceItem;\n      let i = 0;\n      while (!instanceItem && i < supportedSelectedInstanceItems.length) {\n        const item = supportedSelectedInstanceItems[i];\n        const { frames } = item.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          instanceItem = item;\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // find selected empty instance item\n      }\n\n      i = 0;\n      while (!instanceItem && i < supportedCategoryItems.length) {\n        const categoryItem = supportedCategoryItems[i];\n        const { name, count, maxCount = Infinity } = categoryItem;\n        const items = selectedInstance.getItemsByName(name);\n        if ((count !== undefined && items.length < count) || (count === undefined && items.length < maxCount)) {\n          instanceItem = this.createInstanceItem(selectedInstance, name);\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // new instance item\n      }\n    }\n\n    const instance = this.createInstance(selectedCategory.className);\n    return this.createInstanceItem(instance!, supportedCategoryItemNames[0]);\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   * @param defaultNumber\n   */\n  createInstance(\n    categoryName = this.rootStore.ontology.selectedCategory.className,\n    defaultNumber?: number,\n  ) {\n    const category = this.rootStore.ontology.getCategory(categoryName);\n    if (category) {\n      const { instanceItemNumberingMode, dataPrecision } = this.rootStore.config;\n      const forceMultiple = instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL;\n      const instance = new Instance({\n        categoryRef: category,\n        currentWorkerId: this.rootStore.jobProxy!.workerId,\n        currentWorkerName: this.rootStore.jobProxy!.workerName,\n        forceMultiple,\n        dataPrecision,\n        number: defaultNumber !== undefined ? defaultNumber : this.getNextInstanceNumber(categoryName),\n        getNextShapeOrder: this.rootStore.frame.getNextShapeOrder,\n      });\n      this.instances[instance.id] = instance;\n      return instance;\n    }\n    return undefined;\n  }\n\n  /**\n   * create instance item\n   * @param instance\n   * @param categoryItem\n   * @param defaultNumber\n   */\n  createInstanceItem(\n    instance: Instance,\n    categoryItem = this.rootStore.ontology.selectedCategoryItem.name,\n    defaultNumber?: number,\n  ) {\n    const number = defaultNumber !== undefined ? defaultNumber : this.getNextInstanceItemNumber(instance.id, categoryItem);\n    const existItem = instance.getItem(categoryItem, number);\n    if (existItem) {\n      return existItem;\n    }\n    // create\n    const { children = [] } = instance.categoryRef;\n    const item = children.find((c) => c.name === categoryItem);\n    const instanceItem = new InstanceItem({\n      instance,\n      categoryItemRef: item || children[0],\n      number,\n    });\n    instance.items[instanceItem.id] = instanceItem;\n    return instanceItem;\n  }\n\n  /**\n   * delete instance\n   * @param instance\n   */\n  deleteInstance(instance: Instance | Instance[]) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances = this.selectedInstances.filter((i) => instances.indexOf(i) < 0);\n    this.selectedInstanceItems = this.selectedInstanceItems.filter((i) => instances.indexOf(i.instance) < 0);\n    instances.forEach((i) => {\n      i.destroy();\n      delete this.instances[i.id];\n    });\n  }\n\n  /**\n   * delete instance item\n   * @param instanceItem\n   */\n  deleteInstanceItem(instanceItem: InstanceItem | InstanceItem[]) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems = this.selectedInstanceItems.filter((i) => instanceItems.indexOf(i) < 0);\n    instanceItems.forEach(({ id, instance }) => {\n      instance.removeItem(id);\n    });\n  }\n\n  /**\n   * delete frames from instance item\n   * @param instanceItem\n   * @param frames\n   * @param camera\n   */\n  deleteFramesFromInstanceItem = (\n    instanceItem: InstanceItem,\n    frames: number[],\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const unlockedFrames = frames.filter((frameIndex) => {\n      const frameData = instanceItem.cameras[camera]?.frames[frameIndex];\n      return !frameData?.deleteLocked;\n    });\n\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    if (camera === currentCamera && unlockedFrames.includes(currentFrame)) {\n      // remove shape\n      this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      // update segmentation store\n      const { shapeType, layer = this.rootStore.config.activeLayerIndex } = instanceItem.cameras[camera]?.frames[currentFrame] || {};\n      if (shapeType === ShapeType.PIXEL) {\n        this.rootStore.segmentation.update(instanceItem, layer);\n      }\n    }\n\n    // remove relationship\n    const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, unlockedFrames);\n    const { prevState, currState } = instanceItem.remove(camera, unlockedFrames);\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    this.rootStore.undo.push({\n      instances: prevState ? [{ ...prevBasicInfo, children: [prevState] }] : [],\n      relationships: [...prevRelationships],\n    }, {\n      instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n      relationships: [...currRelationships],\n    });\n\n    this.rootStore.nifti?.updateShape(instanceItem, unlockedFrames);\n\n    if (instanceItem.isEmpty) {\n      this.deleteInstanceItem(instanceItem);\n    }\n    if (instanceItem.instance.isEmpty) {\n      this.deleteInstance(instanceItem.instance);\n    }\n    if (!instanceItem.cameras[camera]) {\n      this.selectInstanceItem(null);\n      this.selectInstance(instanceItem.instance.isEmpty ? null : instanceItem.instance);\n    }\n  };\n\n  /**\n   * delete frames from instance items\n   * @param instanceItems\n   */\n  deleteFramesFromInstanceItems = (instanceItems: { instanceItem: InstanceItem, frames: number[], camera?: string }[]) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n    const prevRelationshipMap: { [id: string]: IRelationship } = {};\n    const currRelationshipMap: { [id: string]: IRelationship } = {};\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const { instanceItem, frames, camera = currentCamera } = instanceItems[i];\n      const { instance } = instanceItem;\n      const { id: instanceId } = instance;\n\n      const unlockedFrames = frames.filter((frameIndex) => {\n        const frameData = instanceItem.cameras[camera]?.frames[frameIndex];\n        return !frameData?.deleteLocked;\n      });\n\n      if (camera === currentCamera && unlockedFrames.includes(currentFrame)) {\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        // update segmentation store\n        const { shapeType, layer = this.rootStore.config.activeLayerIndex } = instanceItem.cameras[camera]?.frames[currentFrame] || {};\n        if (shapeType === ShapeType.PIXEL) {\n          this.rootStore.segmentation.update(instanceItem, layer);\n        }\n      }\n\n      // remove relationship\n      const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, unlockedFrames);\n      prevRelationships.forEach((r) => {\n        if (!prevRelationshipMap[r.id]) {\n          prevRelationshipMap[r.id] = r;\n        }\n      });\n      currRelationships.forEach((r) => {\n        currRelationshipMap[r.id] = r;\n      });\n      const prevInstanceBasicInfo = instance.getBasicInfo();\n      const { prevState, currState } = instanceItem.remove(camera, unlockedFrames);\n      if (prevState) {\n        if (!prevInstanceMap[instanceId]) {\n          prevInstanceMap[instanceId] = {\n            ...prevInstanceBasicInfo,\n            children: [],\n          };\n        }\n        prevInstanceMap[instanceId].children.push(prevState);\n      }\n      if (currState) {\n        if (!currInstanceMap[instanceId]) {\n          currInstanceMap[instanceId] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        currInstanceMap[instanceId].children.push(currState);\n      }\n\n      this.rootStore.nifti?.updateShape(instanceItem, unlockedFrames);\n\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instance.isEmpty) {\n        this.deleteInstance(instance);\n      }\n      if (!instanceItem.cameras[camera]) {\n        this.selectInstanceItem(null);\n        this.selectInstance(instance.isEmpty ? null : instance);\n      }\n    }\n    if (Object.values(prevInstanceMap).length > 0) {\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap),\n        relationships: Object.values(prevRelationshipMap),\n      }, {\n        instances: Object.values(currInstanceMap),\n        relationships: Object.values(currRelationshipMap),\n      });\n    }\n  };\n\n  deleteInstanceItemByFrame = (\n    instanceItem: InstanceItem,\n    frame: number,\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const prevInstanceBasicInfo = instanceItem.instance.getBasicInfo();\n    if (camera === currentCamera && frame === currentFrame) {\n      // remove shape\n      this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      // update segmentation store\n      const { shapeType, layer = this.rootStore.config.activeLayerIndex } = instanceItem.cameras[camera]?.frames[currentFrame] || {};\n      if (shapeType === ShapeType.PIXEL) {\n        this.rootStore.segmentation.update(instanceItem, layer);\n      }\n    }\n    // remove relationship\n    const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [currentFrame]);\n\n    const { prevState, currState } = instanceItem.remove(camera, [frame]);\n\n    this.rootStore.nifti?.updateShape(instanceItem, [frame]);\n\n    if (instanceItem.isEmpty) {\n      this.deleteInstanceItem(instanceItem);\n    }\n    if (instanceItem.instance.isEmpty) {\n      this.deleteInstance(instanceItem.instance);\n    }\n    return {\n      prevState: {\n        instances: prevState ? [{ ...prevInstanceBasicInfo, children: [prevState] }] : [],\n        relationships: [...prevRelationships],\n      },\n      currState: {\n        instances: currState ? [{ ...instanceItem.instance.getBasicInfo(), children: [currState] }] : [],\n        relationships: [...currRelationships],\n      },\n    };\n  };\n\n  /**\n   * delete frames from instance item by type\n   * @param instanceItem\n   * @param type\n   * @param camera\n   */\n  deleteFramesFromInstanceItemByType = (\n    instanceItem: InstanceItem,\n    type: 'current' | 'key' | 'following' | 'all' = 'current',\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentFrame } = this.rootStore.frame;\n    switch (type) {\n      case 'current':\n        this.deleteFramesFromInstanceItem(instanceItem, [currentFrame]);\n        break;\n      case 'key': {\n        const nextKeyFrames = getNextKeyFrames(1, currentFrame, instanceItem.cameras[camera].frames);\n        const nextKeyFrame = nextKeyFrames[0];\n        if (nextKeyFrame) {\n          this.deleteFramesFromInstanceItem(\n            instanceItem,\n            Array.from({ length: nextKeyFrame - currentFrame }).map((_, index) => currentFrame + index),\n          );\n        }\n        break;\n      }\n      case 'following': {\n        const allFrames = Object.keys(instanceItem.cameras[camera].frames).map((f) => parseInt(f, 10));\n        const index = allFrames.indexOf(currentFrame);\n        this.deleteFramesFromInstanceItem(\n          instanceItem,\n          allFrames.slice(index, allFrames.length),\n        );\n        break;\n      }\n      case 'all': {\n        const allFrames = Object.keys(instanceItem.cameras[camera].frames).map((f) => parseInt(f, 10));\n        this.deleteFramesFromInstanceItem(\n          instanceItem,\n          allFrames,\n        );\n        break;\n      }\n      default:\n    }\n  };\n\n  /**\n   * update frame shape info for instance item\n   * @param instanceItem\n   * @param frameIndex\n   * @param shapeType\n   * @param shape\n   * @param layer\n   * @param order\n   * @param camera\n   */\n  updateFrameShapeForInstanceItem(instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData, layer?: number, order?: number, camera = this.rootStore.frame.currentCamera) {\n    const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n    let shapeLayer = layer;\n    if (shapeLayer === undefined) {\n      const frameData = instanceItem.cameras[camera]?.frames[frameIndex];\n      if (frameData?.layer !== undefined) {\n        shapeLayer = frameData.layer;\n      } else {\n        shapeLayer = activeLayerIndex;\n      }\n    }\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    const { prevState, currState } = instanceItem.updateShape(\n      camera,\n      frameIndex,\n      autoInterpolation && shapeType !== ShapeType.PIXEL,\n      shapeType,\n      shape,\n      shapeLayer,\n      order,\n    );\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [basicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevState ? [prevState] : [] },\n        curr: { ...basicInfo, children: currState ? [currState] : [] },\n      }\n    };\n    const relationshipState: { prev: IRelationship[], curr: IRelationship[] } = {\n      prev: [],\n      curr: [],\n    };\n\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    if (shapeType === ShapeType.PIXEL && camera === currentCamera && frameIndex === currentFrame) {\n      const stat = this.rootStore.segmentation.update(instanceItem, shapeLayer, shape as PixelData);\n      if (stat) {\n        Object.keys(stat.instanceState).forEach((id) => {\n          if (instanceState[id]) {\n            const { prev, curr } = stat.instanceState[id];\n            instanceState[id].prev.children = [...instanceState[id].prev.children, ...prev.children];\n            instanceState[id].curr.children = [...instanceState[id].curr.children, ...curr.children];\n          } else {\n            instanceState[id] = stat.instanceState[id];\n          }\n        });\n        relationshipState.prev = stat.relationshipState.prev;\n        relationshipState.curr = stat.relationshipState.curr;\n      }\n    }\n\n    this.rootStore.nifti?.updateShape(instanceItem, [frameIndex]);\n\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev),\n      relationships: relationshipState.prev,\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr),\n      relationships: relationshipState.curr,\n    });\n  }\n\n  /**\n   * update frame shape info for instance items list\n   * @param instanceItems\n   */\n  updateFrameShapeForInstanceItems(instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape?: ShapeData, layer?: number, order?: number, camera?: string }[]) {\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n    const prevRelationshipMap: { [id: string]: IRelationship } = {};\n    const currRelationshipMap: { [id: string]: IRelationship } = {};\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const { instanceItem, frameIndex, shapeType, shape, layer, order, camera = this.rootStore.frame.currentCamera } = instanceItems[i];\n      let state;\n      const { autoInterpolation, activeLayerIndex } = this.rootStore.config;\n      let shapeLayer = layer;\n      if (shapeLayer === undefined) {\n        const frameData = instanceItem.cameras[camera]?.frames[frameIndex];\n        if (frameData?.layer !== undefined) {\n          shapeLayer = frameData.layer;\n        } else {\n          shapeLayer = activeLayerIndex;\n        }\n      }\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      if (shape) {\n        // update\n        state = instanceItem.updateShape(\n          camera,\n          frameIndex,\n          autoInterpolation && shapeType !== ShapeType.PIXEL,\n          shapeType,\n          shape,\n          shapeLayer,\n          order,\n        );\n        if (shapeType === ShapeType.PIXEL && camera === currentCamera && frameIndex === currentFrame) {\n          const stat = this.rootStore.segmentation.update(instanceItem, shapeLayer, shape as PixelData);\n          if (stat) {\n            Object.keys(stat.instanceState).forEach((id) => {\n              const { prev, curr } = stat.instanceState[id];\n              if (!prevInstanceMap[id]) {\n                prevInstanceMap[id] = prev;\n              }\n              currInstanceMap[id] = curr;\n            });\n            stat.relationshipState.prev.forEach((r) => {\n              if (!prevRelationshipMap[r.id]) {\n                prevRelationshipMap[r.id] = r;\n              }\n            });\n            stat.relationshipState.curr.forEach((r) => {\n              currRelationshipMap[r.id] = r;\n            });\n          }\n        }\n      } else {\n        // delete\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        // delete relationship\n        const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [this.rootStore.frame.currentFrame]);\n        prevRelationships.forEach((r) => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currRelationships.forEach((r) => {\n          currRelationshipMap[r.id] = r;\n        });\n\n        state = instanceItem.remove(camera, [frameIndex]);\n        if (shapeType === ShapeType.PIXEL) {\n          this.rootStore.segmentation.update(instanceItem, shapeLayer);\n        }\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instanceItem.instance.isEmpty) {\n          this.deleteInstance(instanceItem.instance);\n        }\n        if (!instanceItem.cameras[camera]) {\n          this.selectInstanceItem(null);\n          this.selectInstance(instanceItem.instance.isEmpty ? null : instanceItem.instance);\n        }\n      }\n\n      if (state) {\n        const { prevState, currState } = state;\n        const { instance } = instanceItem;\n        const { id: instanceId } = instance;\n        if (!prevInstanceMap[instanceId]) {\n          prevInstanceMap[instanceId] = {\n            ...prevBasicInfo,\n            children: [],\n          };\n        }\n        if (prevState) {\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: [],\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n      }\n\n      this.rootStore.nifti?.updateShape(instanceItem, [frameIndex]);\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n      relationships: Object.values(prevRelationshipMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n      relationships: Object.values(currRelationshipMap),\n    });\n  }\n\n  /**\n   * move instance item\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param targetInstanceId\n   * @param targetInstanceItemId\n   * @param frames\n   * @param newInstanceAttr\n   * @param newInstanceItemAttr\n   */\n  moveInstanceItem(targetCategory: string, targetCategoryItem: string, targetInstanceId: string, targetInstanceItemId: string, frames: number[], newDynamicInstanceAttr?: DynamicAttributes[], newInstanceAttr?: any, newInstanceItemAttr?: any) {\n    if (!this.isSingleSelected) {\n      return;\n    }\n    const selectedInstanceItem = this.selectedInstanceItems[0];\n    const currPrevInstance = selectedInstanceItem.instance.getBasicInfo();\n    const targetInstance = targetInstanceId === 'new'\n      ? this.createInstance(targetCategory)\n      : this.instances[targetInstanceId];\n    if (targetInstance) {\n      const targetPrevInstance = targetInstance.getBasicInfo();\n\n      const targetInstanceItemDefaultNumber = this.rootStore.config.instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL\n        ? selectedInstanceItem.number\n        : undefined;\n      const targetInstanceItem = targetInstanceItemId === 'new'\n        ? this.createInstanceItem(targetInstance, targetCategoryItem, targetInstanceItemDefaultNumber)\n        : targetInstance.items[targetInstanceItemId];\n      if (targetInstanceItem) {\n        // FIXME: current only support single camera\n        const { currentCamera, currentFrame } = this.rootStore.frame;\n\n        // update target instance item\n        let currIsPixelShape = false;\n        const currInstanceItem = selectedInstanceItem;\n        const framesData = frames.map((frameIndex) => {\n          const frameJson = currInstanceItem.cameras[currentCamera].frames[frameIndex].toJSON();\n          if (frameIndex === currentFrame && frameJson.shapeType === ShapeType.PIXEL) {\n            currIsPixelShape = true;\n          }\n          if (targetCategory === currInstanceItem.instance.category && targetCategoryItem === currInstanceItem.name) {\n            return frameJson;\n          }\n          if (newInstanceItemAttr) {\n            frameJson.attributes = newInstanceItemAttr;\n          } else {\n            delete frameJson.attributes;\n          }\n          return frameJson;\n        });\n\n        const { prevState: targetPrevState, currState: targetCurrState } = targetInstanceItem.updateFramesFromData(currentCamera, framesData);\n        if (newInstanceAttr) {\n          targetInstance.setAttributes(newInstanceAttr);\n        }\n        // update relationships\n        const prevRelationships: { [id: string]: IRelationship } = {};\n        const currRelationships: { [id: string]: IRelationship } = {};\n        currInstanceItem.cameras[currentCamera].relationships.forEach((r) => {\n          if (!prevRelationships[r.id]) {\n            prevRelationships[r.id] = r.toJSON();\n          }\n          r.deleteFromFrames(frames);\n          this.rootStore.relationship.deleteConnection(r);\n          this.rootStore.relationship.createConnection(r);\n          currRelationships[r.id] = r.toJSON();\n        });\n        // remove from current instance item\n        const { prevState, currState } = currInstanceItem.remove(currentCamera, frames);\n\n        // update instance dynamic attributes\n        if (newDynamicInstanceAttr && !targetInstance.dynamicAttributes?.[currentCamera]) {\n          targetInstance.setDynamicAttributesByCamera(currentCamera, newDynamicInstanceAttr);\n        }\n        if (currInstanceItem.isEmpty) {\n          this.deleteInstanceItem(currInstanceItem);\n        }\n        if (currInstanceItem.instance.isEmpty) {\n          this.deleteInstance(currInstanceItem.instance);\n        }\n\n        const targetCurrInstance = targetInstance.getBasicInfo();\n        // update state\n        if (currInstanceItem.instance.id === targetInstanceItem.instance.id) {\n          // same instance\n          const prevInstance: IInstance = { ...targetPrevInstance, children: [] }; // target instance old\n          if (targetPrevState) {\n            prevInstance.children.push(targetPrevState);\n          }\n          if (prevState) {\n            prevInstance.children.push(prevState);\n          }\n          const currInstance: IInstance = { ...targetCurrInstance, children: [] };\n          if (targetCurrState) {\n            currInstance.children.push(targetCurrState);\n          }\n          if (currState) {\n            currInstance.children.push(currState);\n          }\n          this.rootStore.undo.push({\n            instances: prevInstance.children.length > 0 ? [prevInstance] : [],\n            relationships: Object.values(prevRelationships),\n          }, {\n            instances: currInstance.children.length > 0 ? [currInstance] : [],\n            relationships: Object.values(currRelationships),\n          });\n        } else {\n          this.rootStore.undo.push({\n            instances: [\n              ...prevState ? [{ ...currPrevInstance, children: prevState ? [prevState] : [] }] : [],\n              ...targetPrevState ? [{ ...targetPrevInstance, children: targetPrevState ? [targetPrevState] : [] }] : [],\n            ],\n            relationships: Object.values(prevRelationships),\n          }, {\n            instances: [\n              { ...targetCurrInstance, children: currState ? [currState] : [] },\n              { ...targetCurrInstance, children: targetCurrState ? [targetCurrState] : [] },\n            ],\n            relationships: Object.values(currRelationships),\n          });\n        }\n\n        // change instance item\n        if (currIsPixelShape) {\n          this.rootStore.segmentation.changeInstanceItemForInfoMap(currInstanceItem, targetInstanceItem);\n        }\n        // uppdate shapes\n        const currentShape = this.rootStore.shape.getShapeByInstanceItem(currInstanceItem);\n        if (currentShape) {\n          this.rootStore.shape.deleteShape(currentShape);\n        }\n        this.rootStore.shape.setupShape(targetInstanceItem);\n      }\n    }\n  }\n\n  /**\n   * get target instance & affected instance with same number\n   * @param sourceInstance\n   * @param targetCategory\n   * @param targetInstanceNum\n   */\n  getTargetInstance(\n    sourceInstance: Instance,\n    targetCategory: string,\n    targetInstanceNum?: number,\n  ) {\n    const { numberingMode } = this.rootStore.config;\n    let targetInstance: Instance | undefined;\n    let isTargetInstanceNewCreated = false;\n    let affectedInstanceInGlobalMode: Instance | undefined;\n    if (targetInstanceNum !== undefined) {\n      targetInstance = Object.values(this.instances).find((i) => i.category === targetCategory && i.number === targetInstanceNum);\n      // if not found, find same number when in global mode\n      if (!targetInstance && numberingMode === NumberingMode.GLOBAL) {\n        affectedInstanceInGlobalMode = Object.values(this.instances).find((i) => i.number === targetInstanceNum);\n      }\n    }\n    if (!targetInstance) {\n      if (!affectedInstanceInGlobalMode?.isNumberChangeDisabled) {\n        targetInstance = this.createInstance(targetCategory, targetInstanceNum);\n      }\n      if (targetInstance) {\n        isTargetInstanceNewCreated = true;\n        // set instance attributes\n        const newInstanceAttributes = updateAttributesByFieldsCompare(\n          sourceInstance.categoryRef.labelConfig?.fields || [],\n          targetInstance.categoryRef.labelConfig?.fields || [],\n          sourceInstance.attributes,\n          {},\n        );\n        targetInstance.setAttributes(newInstanceAttributes);\n      }\n    }\n    return {\n      targetInstance,\n      isTargetInstanceNewCreated,\n      affectedInstanceInGlobalMode,\n    };\n  }\n\n  /**\n   * get target instance item in target instance\n   * @param targetInstance\n   * @param targetCategoryItem\n   * @param isTargetInstanceNewCreated\n   * @param sourceInstanceItemNumber\n   */\n  getTargetInstanceItem(\n    targetInstance: Instance,\n    targetCategoryItem: string,\n    isTargetInstanceNewCreated: boolean,\n    sourceInstanceItemNumber?: number,\n  ) {\n    const existingItems = targetInstance.getItemsByName(targetCategoryItem);\n    const existingItemWithSameNumber = existingItems.find((i) => i.number === sourceInstanceItemNumber);\n    if (existingItemWithSameNumber) {\n      return existingItemWithSameNumber;\n    }\n\n    const isSingle = targetInstance.categoryRef.children.find((c) => c.name === targetCategoryItem)?.count === 1;\n    if (isSingle && existingItems.length > 1) {\n      throw new Error(i18n.translate('CHANGE_CATEGORY_ERROR_ITEM_COUNT'));\n    }\n\n    const { instanceItemNumberingMode } = this.rootStore.config;\n    let targetInstanceItem: InstanceItem | undefined;\n    if (isSingle && existingItems.length === 1) {\n      targetInstanceItem = existingItems[0];\n    }\n    if (!targetInstanceItem) {\n      let targetInstanceItemNumber: number | undefined;\n      if (instanceItemNumberingMode === InstanceItemNumberingMode.GLOBAL) {\n        if (isTargetInstanceNewCreated) {\n          // keep item number in global mode when target instance is newly created\n          targetInstanceItemNumber = sourceInstanceItemNumber;\n        }\n      } else if (!isSingle && existingItems.findIndex((item) => item.number === sourceInstanceItemNumber) < 0) {\n        // multi-item instance, keep item number if not exist\n        targetInstanceItemNumber = sourceInstanceItemNumber;\n      }\n      targetInstanceItem = this.createInstanceItem(targetInstance, targetCategoryItem, targetInstanceItemNumber);\n    }\n    return targetInstanceItem;\n  }\n\n  /**\n   * change category for instance item\n   * @param sourceInstanceItem\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param affectedCameraFrames\n   * @param targetInstanceNum\n   */\n  changeCategoryForInstanceItemPure(\n    sourceInstanceItem: InstanceItem,\n    targetCategory: string,\n    targetCategoryItem: string,\n    affectedCameraFrames: Record<string, number[]>,\n    targetInstanceNum?: number,\n  ) {\n    const {\n      categoryItemRef: sourceCategoryItemRef,\n      instance: sourceInstance,\n      number: sourceInstanceItemNumber,\n    } = sourceInstanceItem;\n    const {\n      targetInstance,\n      isTargetInstanceNewCreated,\n      affectedInstanceInGlobalMode,\n    } = this.getTargetInstance(sourceInstance, targetCategory, targetInstanceNum);\n\n    if (!targetInstance) {\n      throw new Error(i18n.translate('CHANGE_CATEGORY_ERROR_NO_TARGET_INSTANCE'));\n    }\n\n    if (\n      this.reorganizingInstance?.category === targetInstance.category &&\n      this.reorganizingInstance?.number === targetInstance.number &&\n      this.reorganizingInstance?.id !== targetInstance.id\n    ) {\n      // update reorganizing instance if target instance is newly created\n      this.reorganizingInstance = targetInstance;\n    }\n\n    const prevSourceInstanceBasicInfo = sourceInstance.getBasicInfo();\n    const prevTargetInstanceBasicInfo = targetInstance.getBasicInfo();\n\n    const targetInstanceItem = this.getTargetInstanceItem(\n      targetInstance,\n      targetCategoryItem,\n      isTargetInstanceNewCreated,\n      sourceInstanceItemNumber,\n    );\n\n    if (!targetInstanceItem) {\n      throw new Error(i18n.translate('CHANGE_CATEGORY_ERROR_NO_TARGET_INSTANCE_ITEM'));\n    }\n\n    const { currentFrame } = this.rootStore.frame;\n    const { categoryItemRef: targetCategoryItemRef } = targetInstanceItem;\n    let instanceItemMovedTo: InstanceItem | undefined;\n\n    const prevInstanceMap: Record<string, IInstance> = {};\n    const currInstanceMap: Record<string, IInstance> = {};\n    const prevRelationshipMap: Record<string, IRelationship> = {};\n    const currRelationshipMap: Record<string, IRelationship> = {};\n    const updateInstanceMap = (\n      instanceMap: Record<string, IInstance>,\n      instance: Instance,\n      stat?: IInstanceItem,\n      prevInstanceBasicInfo?: any,\n    ) => {\n      if (!instanceMap[instance.id]) {\n        if (prevInstanceBasicInfo) {\n          instanceMap[instance.id] = {\n            ...prevInstanceBasicInfo,\n            children: [],\n          };\n        } else {\n          instanceMap[instance.id] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n      }\n\n      if (stat) {\n        const index = instanceMap[instance.id].children.findIndex((child) => child.id === stat?.id);\n        if (index >= 0) {\n          instanceMap[instance.id].children[index] = {\n            ...stat,\n            cameras: instanceMap[instance.id].children[index].cameras.concat(stat.cameras),\n          };\n        } else {\n          instanceMap[instance.id].children.push(stat);\n        }\n      }\n    };\n\n    const updatedFramesSet = new Set<number>();\n    const affectedCameras = Object.keys(affectedCameraFrames);\n    for (let c = 0; c < affectedCameras.length; c += 1) {\n      const cameraName = affectedCameras[c];\n      const sourceFramesCount = Object.values(sourceInstanceItem.cameras[cameraName]?.frames || {}).length;\n      const targetFramesCount = Object.values(targetInstanceItem.cameras[cameraName]?.frames || {}).length;\n      const { relationships: sourceRelationships } = sourceInstanceItem.cameras[cameraName] || {};\n      const { relationships: targetRelationships } = targetInstanceItem.cameras[cameraName] || {};\n\n      const frames = affectedCameraFrames[cameraName];\n      // frames data to target instance item\n      const framesData: FrameData[] = [];\n      // frames data moved from target to new instance item\n      const movedFrameData: FrameData[] = [];\n      // relationships updated\n      const updatedRelationships: Relationship[] = [];\n\n      for (let i = 0; i < frames.length; i += 1) {\n        const frameIndex = frames[i];\n        const sourceFrameData = sourceInstanceItem.cameras[cameraName]?.frames[frameIndex];\n        const targetFrameData = targetInstanceItem.cameras[cameraName]?.frames[frameIndex];\n\n        if (\n          (sourceInstance.category === targetCategory\n            ? sourceFrameData?.numberChangeAllowed\n            : sourceFrameData?.categoryChangeAllowed) &&\n          (!targetFrameData || targetFrameData.numberChangeAllowed)\n        ) {\n          updatedFramesSet.add(frameIndex);\n          const frameDataJson = sourceFrameData.toJSON();\n          if ((targetCategoryItem !== sourceInstanceItem.name || targetCategory !== sourceInstance.category)\n            && sourceFrameData.attrChangeAllowed) {\n            // update attributes when category not same\n            frameDataJson.attributes = updateAttributesByFieldsCompare(\n              sourceCategoryItemRef?.labelConfig?.fields || [],\n              targetCategoryItemRef.labelConfig?.fields || [],\n              sourceFrameData.attributes,\n              {},\n            );\n          }\n          framesData.push(frameDataJson);\n\n          // move target frame to new\n          if (targetFrameData) {\n            movedFrameData.push(targetFrameData.toJSON());\n          }\n\n          if (frameIndex === currentFrame) {\n            // change instance item for pixel shape\n            if (sourceFrameData.shapeType === ShapeType.PIXEL) {\n              this.rootStore.segmentation.changeInstanceItemForInfoMap(sourceInstanceItem, targetInstanceItem);\n            }\n            // delete shape in current frame\n            const shape = this.rootStore.shape.getShapeByInstanceItem(sourceInstanceItem, cameraName);\n            if (shape) {\n              this.rootStore.shape.deleteShape(shape);\n            }\n          }\n        }\n      }\n\n      // should move frames to new instance item\n      const movedFramesCount = movedFrameData.length;\n      if (movedFramesCount > 0) {\n        if (!instanceItemMovedTo) {\n          const instanceMovedTo = this.createInstance(targetCategory);\n          if (instanceMovedTo) {\n            instanceItemMovedTo = this.createInstanceItem(instanceMovedTo, targetCategoryItem);\n          }\n        }\n        if (instanceItemMovedTo) {\n          instanceItemMovedTo.updateFramesFromData(cameraName, movedFrameData);\n\n          if (targetRelationships) {\n            const shouldMoveRelationship = movedFramesCount === targetFramesCount;\n            for (let i = 0; i < targetRelationships.length; i += 1) {\n              const r = targetRelationships[i];\n              if (!prevRelationshipMap[r.id]) {\n                prevRelationshipMap[r.id] = r.toJSON();\n              }\n              if (shouldMoveRelationship) {\n                if (r.fromInstanceItem.id === targetInstanceItem.id) {\n                  r.fromInstanceItem = instanceItemMovedTo!;\n                } else {\n                  r.toInstanceItem = instanceItemMovedTo!;\n                }\n                instanceItemMovedTo!.cameras[cameraName].relationships.push(r);\n                currRelationshipMap[r.id] = r.toJSON();\n              } else {\n                r.deleteFromFrames(movedFrameData.map((f) => f.frameIndex));\n                if (Object.values(r.frames).length > 0) {\n                  currRelationshipMap[r.id] = r.toJSON();\n                } else {\n                  this.rootStore.relationship.deleteRelationship(r);\n                }\n              }\n              updatedRelationships.push(r);\n            }\n          }\n        }\n      }\n\n      const framesCount = framesData.length;\n      if (framesCount > 0) {\n        const { dynamicAttributes: sourceInstanceDynamicAttr } = sourceInstance;\n        const sourceInstanceDynamicAttrByCamera = cloneDeep(sourceInstanceDynamicAttr?.[cameraName]);\n\n        const framesIndex = framesData.map((f) => f.frameIndex);\n        // remove frames from source instance item\n        const sourceStat = sourceInstanceItem.remove(cameraName, framesIndex);\n        updateInstanceMap(prevInstanceMap, sourceInstance, sourceStat.prevState, prevSourceInstanceBasicInfo);\n        updateInstanceMap(currInstanceMap, sourceInstance, sourceStat.currState);\n        // update frames for target instance item\n        const targetStat = targetInstanceItem.updateFramesFromData(cameraName, framesData);\n        if (!isTargetInstanceNewCreated) {\n          updateInstanceMap(prevInstanceMap, targetInstance, targetStat.prevState, prevTargetInstanceBasicInfo);\n        }\n        updateInstanceMap(currInstanceMap, targetInstance, targetStat.currState);\n        // update instance dynamic attributes\n        const sourceFields = sourceInstance.categoryRef?.labelConfigDynamic?.fields || [];\n        const targetFields = targetInstance.categoryRef?.labelConfigDynamic?.fields || [];\n        const updatedFrames = Array.from(updatedFramesSet);\n        const { dynamicAttributes: targetInstanceDynamicAttr } = targetInstance;\n        const targetInstanceDynamicAttrByCamera = targetInstanceDynamicAttr?.[cameraName];\n\n        const updatedDynamicAttrs = [];\n        for (let index = 0; index < updatedFrames.length; index += 1) {\n          const frameIndex = updatedFrames[index];\n          if (targetCategoryItem === sourceInstanceItem.name && targetCategory === sourceInstance.category) {\n            if (targetInstanceDynamicAttrByCamera) {\n              if (!targetInstanceDynamicAttrByCamera[frameIndex]) {\n                updatedDynamicAttrs.push({ frameIndex, attributes: sourceInstanceDynamicAttrByCamera?.[frameIndex]?.attributes });\n              }\n            } else {\n              const updatedDynamicAttrbutes = updateAttributesByFieldsCompare(\n                sourceFields,\n                targetFields,\n                sourceInstanceDynamicAttrByCamera?.[frameIndex]?.attributes,\n                {}\n              );\n              updatedDynamicAttrs.push({ frameIndex, attributes: updatedDynamicAttrbutes });\n            }\n          } else if (\n            (targetInstanceDynamicAttrByCamera && !targetInstanceDynamicAttrByCamera[frameIndex]) ||\n            (!targetInstanceDynamicAttrByCamera)\n          ) {\n            const updatedDynamicAttrbutes = updateAttributesByFieldsCompare(\n              sourceFields,\n              targetFields,\n              sourceInstanceDynamicAttrByCamera?.[frameIndex]?.attributes,\n              {}\n            );\n            updatedDynamicAttrs.push({ frameIndex, attributes: updatedDynamicAttrbutes });\n          }\n        }\n        targetInstance.setDynamicAttributesByCamera(cameraName, updatedDynamicAttrs);\n        sourceInstance.deleteDynamicAttributesByCamera(cameraName, Array.from(updatedFramesSet), sourceInstanceItem.id);\n\n        // update relationships\n        if (sourceRelationships) {\n          const shouldMoveRelationship = framesCount === sourceFramesCount;\n          for (let i = 0; i < sourceRelationships.length; i += 1) {\n            const r = sourceRelationships[i];\n            if (!prevRelationshipMap[r.id]) {\n              prevRelationshipMap[r.id] = r.toJSON();\n            }\n            if (shouldMoveRelationship) {\n              if (r.fromInstanceItem.id === sourceInstanceItem.id && r.toInstanceItem.id !== targetInstanceItem.id) {\n                r.fromInstanceItem = targetInstanceItem;\n                targetInstanceItem.cameras[cameraName].relationships.push(r);\n                currRelationshipMap[r.id] = r.toJSON();\n              } else if (r.toInstanceItem.id === sourceInstanceItem.id && r.fromInstanceItem.id !== targetInstanceItem.id) {\n                r.toInstanceItem = targetInstanceItem;\n                targetInstanceItem.cameras[cameraName].relationships.push(r);\n                currRelationshipMap[r.id] = r.toJSON();\n              }\n            } else {\n              r.deleteFromFrames(framesIndex);\n              if (Object.values(r.frames).length > 0) {\n                currRelationshipMap[r.id] = r.toJSON();\n              } else {\n                this.rootStore.relationship.deleteRelationship(r);\n              }\n            }\n            updatedRelationships.push(r);\n          }\n        }\n\n        if (sourceInstanceItem.isEmpty) {\n          this.deleteInstanceItem(sourceInstanceItem);\n          currInstanceMap[sourceInstance.id].children = [];\n        }\n        if (sourceInstance.isEmpty) {\n          this.deleteInstance(sourceInstance);\n          delete currInstanceMap[sourceInstance.id];\n        }\n      }\n\n      // setup shapes\n      this.rootStore.shape.setupShape(targetInstanceItem, cameraName);\n      if (instanceItemMovedTo) {\n        this.rootStore.shape.setupShape(instanceItemMovedTo, cameraName);\n      }\n      // setup connections\n      updatedRelationships.forEach((r) => {\n        this.rootStore.relationship.deleteConnection(r);\n        this.rootStore.relationship.createConnection(r);\n      });\n    }\n\n    const prevInstances = Object.values(prevInstanceMap);\n    const currInstances = Object.values(currInstanceMap);\n    if (instanceItemMovedTo) {\n      currInstances.push(instanceItemMovedTo.instance.toJSON());\n    }\n    if (affectedInstanceInGlobalMode) {\n      prevInstances.push({\n        ...affectedInstanceInGlobalMode.getBasicInfo(),\n        children: [],\n      });\n      affectedInstanceInGlobalMode.number = this.getNextInstanceNumber(affectedInstanceInGlobalMode.category);\n      currInstances.push({\n        ...affectedInstanceInGlobalMode.getBasicInfo(),\n        children: [],\n      });\n    }\n    const prevRelationships = Object.values(prevRelationshipMap);\n    const currRelationships = Object.values(currRelationshipMap);\n    return {\n      targetInstanceItem,\n      instanceItemMovedTo,\n      updatedFramesSet,\n      prevState: {\n        instances: prevInstances,\n        relationships: prevRelationships,\n      },\n      currState: {\n        instances: currInstances,\n        relationships: currRelationships,\n      },\n    };\n  }\n\n  changeCategoryForInstance({ targetCategoryName, pendingInstanceItems }: {\n    targetCategoryName: string;\n    pendingInstanceItems: {\n      [instanceItemId: string]: {\n        sourceInstanceItem: InstanceItem;\n        affectedCameraFrames: Record<string, number[]>;\n      }\n    }\n  }) {\n    const allItems = Object.values(pendingInstanceItems);\n    if (allItems.length <= 0) {\n      message.error(i18n.translate('FILTER_MOVE_TO_EMPTY'));\n      return;\n    }\n    const prevInstanceMap: Record<string, IInstance> = {};\n    const currInstanceMap: Record<string, IInstance> = {};\n    const prevRelationshipMap: Record<string, IRelationship> = {};\n    const currRelationshipMap: Record<string, IRelationship> = {};\n    try {\n      let targetInstance: Instance | undefined;\n\n      for (let i = 0; i < allItems.length; i += 1) {\n        const { sourceInstanceItem, affectedCameraFrames } = allItems[i];\n        const { targetInstanceItem, prevState, currState } = this.changeCategoryForInstanceItemPure(\n          sourceInstanceItem,\n          targetCategoryName,\n          sourceInstanceItem.name,\n          affectedCameraFrames,\n          targetInstance?.number,\n        );\n        targetInstance = targetInstanceItem.instance;\n\n        // eslint-disable-next-line no-loop-func\n        prevState.instances.forEach((instance) => {\n          // target instance 是上一次受影响的 instance\n          // 在下一次循环中，prev state 中无需保存上一次受影响的 instance\n          if (instance.id === targetInstance?.id) {\n            return;\n          }\n          if (!prevInstanceMap[instance.id]) {\n            prevInstanceMap[instance.id] = instance;\n          } else {\n            prevInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        currState.instances.forEach((instance) => {\n          if (!currInstanceMap[instance.id]) {\n            currInstanceMap[instance.id] = instance;\n          } else {\n            currInstanceMap[instance.id].children.push(...instance.children);\n          }\n        });\n        prevState.relationships.forEach((r) => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currState.relationships.forEach((r) => {\n          currRelationshipMap[r.id] = r;\n        });\n      }\n\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap),\n        relationships: Object.values(prevRelationshipMap),\n      }, {\n        instances: Object.values(currInstanceMap),\n        relationships: Object.values(currRelationshipMap),\n      });\n      this.rootStore.filter.filterInstances();\n      // select\n      this.selectInstance(targetInstance);\n      // open attributes modal\n      this.autoOpenAttributesModal(true);\n    } catch (e) {\n      message.error((e as Error).message);\n    }\n  }\n\n  changeCategoryForInstanceItem(\n    sourceInstanceItem: InstanceItem,\n    targetCategory: string,\n    targetCategoryItem: string,\n    affectedCameraFrames: Record<string, number[]>,\n    targetInstanceNum?: number,\n  ) {\n    try {\n      const {\n        targetInstanceItem,\n        instanceItemMovedTo,\n        updatedFramesSet,\n        prevState,\n        currState,\n      } = this.changeCategoryForInstanceItemPure(\n        sourceInstanceItem,\n        targetCategory,\n        targetCategoryItem,\n        affectedCameraFrames,\n        targetInstanceNum,\n      );\n      const {\n        instances: prevInstances,\n        relationships: prevRelationships,\n      } = prevState;\n      const {\n        instances: currInstances,\n        relationships: currRelationships,\n      } = currState;\n      if (prevInstances.length > 0 || currInstances.length > 0) {\n        // save to undo/redo stack\n        this.rootStore.undo.push({\n          instances: prevInstances,\n          relationships: prevRelationships,\n        }, {\n          instances: currInstances,\n          relationships: currRelationships,\n        });\n        // filter\n        this.rootStore.filter.filterInstances();\n        // select\n        this.selectInstanceItem(targetInstanceItem);\n        // open attributes modal only when category changes\n        if (targetCategory !== sourceInstanceItem.instance.category || targetCategoryItem !== sourceInstanceItem.name) {\n          this.autoOpenAttributesModal(true);\n        }\n        message.success(i18n.translate('CHANGE_CATEGORY_SUCCESS', {\n          values: {\n            source: sourceInstanceItem.label,\n            target: targetInstanceItem.label,\n            frames: formatFrames(Array.from(updatedFramesSet)),\n          },\n        }));\n        if (instanceItemMovedTo) {\n          message.success(i18n.translate('CHANGE_CATEGORY_SUCCESS', {\n            values: {\n              source: targetInstanceItem.label,\n              target: instanceItemMovedTo.label,\n              frames: formatFrames(Object.keys(instanceItemMovedTo.frameStatus).map((f) => Number(f))),\n            },\n          }));\n        }\n      } else {\n        message.warning(i18n.translate('CHANGE_CATEGORY_WARNING'));\n      }\n    } catch (e) {\n      message.error((e as Error).message);\n    }\n  }\n\n  /**\n   * change category for instance items\n   * @param selectedInstanceInfo\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param attrs\n  */\n  changeCategoryForInstanceItems(\n    selectedInstanceInfo: {\n      id: string; instanceId: string; instanceItemId?: string; camera?: string; frames: number[]; order: number;\n    }[],\n    targetCategory: string,\n    targetCategoryItem: string,\n    attrs?: {\n      static?: any;\n      dynamic?: any;\n      item?: any;\n    } | undefined\n  ) {\n    const prevInstanceMap: Record<string, IInstance> = {};\n    const currInstanceMap: Record<string, IInstance> = {};\n    const getInstancesState = (instance: Instance, instanceItem: InstanceItem, camera: string) => {\n      const newInstance: IInstance = {\n        ...instance.getBasicInfo(),\n        children: [],\n      };\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData && !cameraData.isEmpty) {\n        newInstance.children.push({\n          ...instanceItem.getBasicInfo(),\n          cameras: [cameraData.toJSON()],\n        });\n      }\n\n      return newInstance;\n    };\n    const selectInstanceInfoMap = new Map();\n\n    selectedInstanceInfo?.forEach((instanceInfo: {\n      id: string; instanceId: string; instanceItemId?: string; camera?: string; frames: number[]; order: number;\n    }) => {\n      // delete old and add attributes\n      const { instanceId, instanceItemId, camera, frames } = instanceInfo;\n      if (!camera) {\n        return;\n      }\n      const sourceInstance = this.getInstanceById(instanceId);\n      let sourceInstanceItem: InstanceItem | null = null;\n      if (sourceInstance && instanceItemId) {\n        sourceInstanceItem = sourceInstance.items[instanceItemId];\n      }\n      if (!sourceInstanceItem) {\n        return;\n      }\n      // if selected category is same with instance's current ,then return\n      if (sourceInstance.categoryRef.className === targetCategory && sourceInstanceItem.categoryItemRef.name === targetCategoryItem) {\n        return;\n      }\n      const key = `${instanceId}-${instanceItemId}`;\n      let targetInstance: Instance | undefined;\n      let targetInstanceItem: InstanceItem | undefined;\n      if (selectInstanceInfoMap.has(key)) {\n        const { targetInstanceId, targetInstanceItemId } = selectInstanceInfoMap.get(key);\n        targetInstance = this.getInstanceById(targetInstanceId);\n        if (targetInstance && targetInstanceItemId) {\n          targetInstanceItem = targetInstance.items[targetInstanceItemId];\n        }\n      } else {\n        // create new\n        try {\n          targetInstance = this.createInstance(targetCategory);\n          if (targetInstance) {\n            targetInstanceItem = this.createInstanceItem(targetInstance, targetCategoryItem);\n          }\n        } catch (e) {\n          message.error((e as Error).message);\n          return;\n        }\n        if (!targetInstance || !targetInstanceItem) {\n          return;\n        }\n        selectInstanceInfoMap.set(key, { targetInstanceId: targetInstance.id, targetInstanceItemId: targetInstanceItem.id });\n      }\n      if (!targetInstance || !targetInstanceItem) {\n        return;\n      }\n      if (!prevInstanceMap[sourceInstance.id]) {\n        prevInstanceMap[sourceInstance.id] = getInstancesState(sourceInstance, sourceInstanceItem, camera);\n      }\n      // delete attributes  for source instance's item by frame\n      sourceInstance.deleteDynamicAttributesByCamera(camera, frames, sourceInstanceItem.id);\n      const { currentFrame } = this.rootStore.frame;\n\n      frames.forEach((frame) => {\n        // frames data to target instance item\n        const sourceFrameData = sourceInstanceItem!.cameras[camera]?.frames[frame];\n        if (!sourceFrameData) {\n          return;\n        }\n        const frameDataJson = sourceFrameData.toJSON();\n        targetInstanceItem!.updateFramesFromData(camera, [frameDataJson]);\n\n        if (frame === currentFrame) {\n          // change instance item for pixel shape\n          if (sourceFrameData.shapeType === ShapeType.PIXEL) {\n            this.rootStore.segmentation.changeInstanceItemForInfoMap(sourceInstanceItem!, targetInstanceItem!);\n          }\n          // delete shape in current frame\n          const shape = this.rootStore.shape.getShapeByInstanceItem(sourceInstanceItem!, camera);\n          if (shape) {\n            this.rootStore.shape.deleteShape(shape);\n          }\n        }\n\n        const { currState } = this.deleteInstanceItemByFrame(sourceInstanceItem!, frame, camera);\n        currInstanceMap[sourceInstance.id] = currState ? currState.instances[0] : { ...sourceInstanceItem!.instance.getBasicInfo(), children: [] };\n      });\n\n      // set attributes for target instance and instance item\n      if (attrs) {\n        const { static: newInstanceAttr, dynamic: newInstanceDynamicAttr, item: newInstanceItemAttr } = attrs;\n        if (newInstanceAttr) {\n          targetInstance?.setAttributes(newInstanceAttr);\n        }\n        const updatedFrameAttributes: DynamicAttributes[] = [];\n        frames.forEach((frame) => {\n          if (newInstanceItemAttr) {\n            targetInstanceItem!.setAttributesByFrame(camera, { [frame]: { attributes: newInstanceItemAttr } });\n          }\n          if (newInstanceDynamicAttr) {\n            updatedFrameAttributes.push({\n              frameIndex: frame,\n              attributes: newInstanceDynamicAttr\n            });\n          }\n        });\n\n        targetInstance?.setDynamicAttributesByCamera(camera, updatedFrameAttributes);\n      }\n\n      // setup shapes\n      this.rootStore.shape.setupShape(targetInstanceItem, camera);\n      currInstanceMap[targetInstance.id] = getInstancesState(targetInstanceItem.instance, targetInstanceItem, camera);\n    });\n\n    const prevInstances = Object.values(prevInstanceMap);\n    const currInstances = Object.values(currInstanceMap);\n    // filter\n    this.rootStore.filter.filterInstances();\n    if (prevInstances.length > 0 || currInstances.length > 0) {\n      // save to undo/redo stack\n      this.rootStore.undo.push({\n        instances: prevInstances,\n      }, {\n        instances: currInstances,\n      });\n\n      message.success(i18n.translate('CHANGE_CATEGORY_BATCH_SUCCESS'));\n    } else {\n      message.warning(i18n.translate('CHANGE_CATEGORY_WARNING'));\n    }\n  }\n\n  /**\n   * change layer for selected instance item\n   * @param targetLayer\n   */\n  changeLayer(targetLayer: number) {\n    if (this.isSingleSelected) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const frameData = selectedInstanceItem.cameras[currentCamera]?.frames[currentFrame];\n      if (!frameData?.locked && frameData?.layer !== targetLayer) {\n        const prevInstanceMap: Record<string, IInstance> = {};\n        const currInstanceMap: Record<string, IInstance> = {};\n        let prevRelationships: IRelationship[] | undefined;\n        let currRelationships: IRelationship[] | undefined;\n\n        // update layer\n        if (frameData.shapeType === ShapeType.PIXEL) {\n          // for pixel shape, layer change may affect self or others\n          const { instanceState, relationshipState } = this.rootStore.segmentation.changeLayer(selectedInstanceItem, frameData.layer, targetLayer);\n          Object.keys(instanceState).forEach((id) => {\n            const { prev, curr } = instanceState[id];\n            if (!prevInstanceMap[id]) {\n              prevInstanceMap[id] = prev;\n            }\n            currInstanceMap[id] = curr;\n          });\n          prevRelationships = relationshipState.prev;\n          currRelationships = relationshipState.curr;\n        } else {\n          // not pixel shape, only need to update layer & order\n          const instanceBasicInfo = selectedInstanceItem.instance.getBasicInfo();\n          const itemBasicInfo = selectedInstanceItem.getBasicInfo();\n          prevInstanceMap[instanceBasicInfo.id] = {\n            ...instanceBasicInfo,\n            children: [{\n              ...itemBasicInfo,\n              cameras: [{\n                camera: currentCamera,\n                frames: [frameData.toJSON()],\n              }]\n            }]\n          };\n          frameData.layer = targetLayer;\n          frameData.order = this.rootStore.frame.getNextShapeOrder(targetLayer, currentFrame, currentCamera);\n          currInstanceMap[instanceBasicInfo.id] = {\n            ...instanceBasicInfo,\n            children: [{\n              ...itemBasicInfo,\n              cameras: [{\n                camera: currentCamera,\n                frames: [frameData.toJSON()],\n              }],\n            }]\n          };\n        }\n\n        this.rootStore.undo.push({\n          instances: Object.values(prevInstanceMap),\n          relationships: prevRelationships,\n        }, {\n          instances: Object.values(currInstanceMap),\n          relationships: currRelationships,\n        });\n\n        this.rootStore.config.setContextMenuVisible(false);\n        this.rootStore.shape.setupShape(selectedInstanceItem, currentCamera);\n        if (!selectedInstanceItem.cameras[currentCamera]) {\n          this.selectInstanceItem(null);\n          this.selectInstance(selectedInstanceItem.instance.isEmpty ? null : selectedInstanceItem.instance);\n          this.rootStore.config.setActiveLayerIndex(targetLayer);\n        } else {\n          this.selectInstanceItem(selectedInstanceItem);\n        }\n        message.success(i18n.translate('LAYER_CHANGED_SUCCESS', {\n          values: {\n            label: selectedInstanceItem.label,\n            layer: this.rootStore.config.layers[targetLayer],\n          },\n        }));\n      }\n    }\n  }\n\n  /**\n   * open attributes modal automatically for selected instance\n   * @param ignoreAttributes ignore whether if frameData's attributes existed or not\n   */\n  autoOpenAttributesModal(ignoreAttributes = false) {\n    if (\n      !this.rootStore.config.preferences.autoOpenAttributesModal ||\n      this.isMultiSelected ||\n      this.selectedInstances.length <= 0\n    ) {\n      return false;\n    }\n\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const shouldOpen = (instanceItem: InstanceItem) => {\n      const frameData = instanceItem.cameras[currentCamera]?.frames[currentFrame];\n\n      if (frameData?.isOCR && !frameData?.OCRText) {\n        this.rootStore.config.shouldSyncOCR = true;\n        return true;\n      }\n\n      if (frameData?.isFormula && !frameData?.formulaText) {\n        this.rootStore.config.shouldSyncOCR = true;\n        return true;\n      }\n\n      if (\n        instanceItem.categoryItemRef.labelConfig &&\n        (ignoreAttributes || !frameData?.attributes)\n      ) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n\n      return false;\n    };\n\n    if (this.selectedInstanceItems.length === 1) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const open = shouldOpen(selectedInstanceItem);\n      if (open) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n    }\n\n    const selectedInstance = this.selectedInstances[0];\n    const { labelConfig, labelConfigDynamic } = selectedInstance.categoryRef;\n    if (\n      (labelConfig && (ignoreAttributes || !selectedInstance.attributes)) ||\n      (labelConfigDynamic && (ignoreAttributes || !selectedInstance.dynamicAttributes || !selectedInstance.dynamicAttributes[currentCamera]?.[currentFrame]?.attributes))\n    ) {\n      this.rootStore.config.setAttributesModalVisible(true);\n      return true;\n    }\n\n    if (this.selectedInstanceItems.length <= 0 && Object.values(selectedInstance.items).some((i) => shouldOpen(i))) {\n      // no instance item selected\n      this.rootStore.config.setAttributesModalVisible(true);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * move to next pending instance item & open attributes modal if needed\n   */\n  openAttributesModalFromPending() {\n    const item = this.attrPendingInstanceItems.shift();\n    if (item) {\n      this.selectInstanceItem(item);\n      const open = this.autoOpenAttributesModal();\n      if (open) {\n        // async to set last pending instance item\n        setTimeout(() => {\n          this.lastPendingInstanceItem = item;\n        }, 0);\n        // focus\n        if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n          this.rootStore.shape.fitShapes();\n        } else {\n          // this.rootStore.grid.gridCanvas?.fitShapes();\n        }\n      } else {\n        // move to next\n        this.openAttributesModalFromPending();\n      }\n    } else {\n      // no any pending instance item\n      this.lastPendingInstanceItem = null;\n    }\n  }\n\n  /**\n   * open attributes modal for instance items one by one\n   * @param instanceItems\n   */\n  openAttributesModalForInstanceItems(instanceItems: InstanceItem[]) {\n    this.attrPendingInstanceItems = instanceItems;\n    this.lastPendingInstanceItem = null;\n    this.openAttributesModalFromPending();\n  }\n\n  /**\n   * set dragging type by draggable id\n   * @param draggableId\n   */\n  setDraggingType(draggableId: string) {\n    const [type] = draggableId.split('_');\n    this.draggingType = type as DraggableType;\n  }\n\n  /**\n   * update instances or instance items by dragging\n   * @param destination\n   */\n  updateByDragging(destination?: { droppableId: string; index: number }) {\n    if (\n      !destination ||\n      !this.rootStore.config.autoTracking ||\n      (this.rootStore.config.autoTracking && !this.rootStore.config.inexistentGraphicsCardVisibility)\n    ) {\n      return;\n    }\n\n    const { droppableId, index } = destination;\n\n    // ========== drag instance ==========\n    // reorder all instances number in the category\n    // just update instances number to 1, 2, 3, ...\n    if (this.draggingType === DraggableType.INSTANCE) {\n      const category = droppableId;\n      const selectedInstance = this.selectedInstances[0];\n      if (!selectedInstance || selectedInstance.category !== category) {\n        return;\n      }\n\n      const categoryInstances = [...this.categoryInstancesMap[category]];\n      const originIndex = categoryInstances.indexOf(selectedInstance);\n      if (originIndex === index) {\n        // same order, no need to udpate\n        return;\n      }\n\n      // reorder\n      categoryInstances.splice(originIndex, 1);\n      categoryInstances.splice(index, 0, selectedInstance);\n\n      const prevInstances: IInstance[] = [];\n      const currInstances: IInstance[] = [];\n      categoryInstances.forEach((instance, i) => {\n        const number = i + 1;\n        if (instance.number !== number) {\n          // update number\n          const basicInfo = instance.getBasicInfo();\n          instance.number = number;\n          prevInstances.push({ ...basicInfo, children: [] });\n          currInstances.push({ ...basicInfo, children: [], number });\n          // update shapes in the instance\n          Object.values(instance.items).forEach((item) => {\n            Object.values(item.cameras).forEach((cameraData) => {\n              this.rootStore.shape.setupShape(item, cameraData.camera);\n            });\n          });\n        }\n      });\n      this.rootStore.undo.push({ instances: prevInstances }, { instances: currInstances });\n\n      // reselect\n      this.selectInstance(selectedInstance);\n    }\n\n    // ========== drag instance item in one camera ==========\n    // reorder all instance items (same name) number\n    // should move camera data from source to target (not just update number), keep other camera data not change\n    if (this.draggingType === DraggableType.ITEM) {\n      const [targetId, targetCamera] = droppableId.split('|DS|');\n      const camera = targetCamera || this.rootStore.frame.currentCamera;\n      const targetInstance = this.instances[targetId];\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      if (!targetInstance || !selectedInstanceItem) {\n        return;\n      }\n\n      const { name: selectedName, instance: selectedInstance, categoryItemRef } = selectedInstanceItem;\n      const selectedNameItemsCount = targetInstance.getItemsByName(selectedName).filter((item) => !item.cameras[camera]?.isEmpty).length;\n      if (selectedInstance.id !== targetId && (selectedNameItemsCount === categoryItemRef.count || selectedNameItemsCount === categoryItemRef.maxCount)) {\n        // cannot dragged any instance item in because of count limits\n        return;\n      }\n\n      const sameInstance = selectedInstance.id === targetId;\n      const getInstancesState = (instances: Instance[]) => instances.map((instance) => {\n        const newInstance: IInstance = {\n          ...instance.getBasicInfo(),\n          children: [],\n        };\n        instance.getItemsByName(selectedName).forEach((item) => {\n          const cameraData = item.cameras[camera];\n          if (cameraData && !cameraData.isEmpty) {\n            newInstance.children.push({\n              ...item.getBasicInfo(),\n              cameras: [cameraData.toJSON()],\n            });\n          }\n        });\n        return newInstance;\n      });\n      const prevInstances = getInstancesState([\n        targetInstance,\n        ...!sameInstance ? [selectedInstance] : [],\n      ]);\n      const prevRelationships: { [id: string]: IRelationship } = {};\n      const currRelationships: { [id: string]: IRelationship } = {};\n\n      // current selected number (updated when new number given)\n      let selectedNumber = selectedInstanceItem.number;\n      // update camera data in instance item\n      const updateCameraData = (number: number, cameraData: CameraData, relationships: Relationship[], originInstanceItem: InstanceItem) => {\n        let targetInstanceItem = targetInstance.getItemsByName(selectedName).find((item) => item.number === number); // existed instance item with the number\n        if (!targetInstanceItem) {\n          // should create\n          const newInstanceItem: IInstanceItem = {\n            id: uuidv4(),\n            name: selectedName,\n            number,\n            cameras: [],\n          };\n          targetInstance.createItemFromData(newInstanceItem);\n          targetInstanceItem = targetInstance.items[newInstanceItem.id];\n        }\n        targetInstanceItem.createCameraFromData(cameraData);\n        this.rootStore.shape.setupShape(targetInstanceItem, camera);\n\n        // update relationships related\n        const { deleteConnection, createConnection } = this.rootStore.relationship;\n        const targetCameraData = targetInstanceItem.cameras[camera];\n        for (let i = 0; i < relationships.length; i += 1) {\n          const relationship = relationships[i];\n          if (!prevRelationships[relationship.id]) {\n            prevRelationships[relationship.id] = relationship.toJSON();\n          }\n          deleteConnection(relationship);\n          if (originInstanceItem === relationship.fromInstanceItem) {\n            relationship.fromInstanceItem = targetInstanceItem;\n          } else if (originInstanceItem === relationship.toInstanceItem) {\n            relationship.toInstanceItem = targetInstanceItem;\n          }\n          targetCameraData.addRelationship(relationship);\n          createConnection(relationship);\n          currRelationships[relationship.id] = relationship.toJSON();\n        }\n      };\n\n      if (targetCamera !== undefined) {\n        // drag to existing camera\n        const targetInstanceItems = Object.values(targetInstance.items)\n          .filter((item) => !item.cameras[camera]?.isEmpty)\n          .sort((a, b) => {\n            const { children } = targetInstance.categoryRef;\n            const aIndex = children.findIndex((c) => c.name === a.name);\n            const bIndex = children.findIndex((c) => c.name === b.name);\n            if (aIndex < bIndex) {\n              return -1;\n            }\n            if (aIndex > bIndex) {\n              return 1;\n            }\n            return a.number - b.number;\n          });\n\n        const selectedNameFirstItemIndex = targetInstanceItems.findIndex((item) => item.name === selectedName);\n        const selectedNameLastItemIndex = selectedNameFirstItemIndex + selectedNameItemsCount - (sameInstance ? 1 : 0);\n        const targetCameraDataList = targetInstanceItems.slice(selectedNameFirstItemIndex, selectedNameLastItemIndex + 1).map((item) => ({\n          id: item.id,\n          cameraData: item.cameras[camera].toJSON(),\n          relationships: [...item.cameras[camera].relationships],\n        }));\n\n        const exactIndex = Math.min(Math.max(index, selectedNameFirstItemIndex), selectedNameLastItemIndex) - selectedNameFirstItemIndex;\n        if (sameInstance) {\n          // dragging in the same instance\n          const originIndex = targetInstanceItems.indexOf(selectedInstanceItem) - selectedNameFirstItemIndex;\n          if (originIndex === exactIndex) {\n            // same order in the same instance, no need to update\n            return;\n          }\n          targetCameraDataList.splice(originIndex, 1);\n        }\n\n        targetCameraDataList.splice(exactIndex, 0, {\n          id: selectedInstanceItem.id,\n          cameraData: selectedInstanceItem.cameras[camera].toJSON(),\n          relationships: [...selectedInstanceItem.cameras[camera].relationships],\n        });\n\n        targetCameraDataList.forEach((d, i) => {\n          const number = i + 1;\n          if (d.id === selectedInstanceItem.id) {\n            selectedNumber = number; // update selected number\n          }\n\n          const originTargetInstanceItem = targetInstance.items[d.id];\n          if (!originTargetInstanceItem || (originTargetInstanceItem.name === selectedName && originTargetInstanceItem.number !== number)) {\n            // should create new, or should update camera data because number changed\n            updateCameraData(number, d.cameraData, d.relationships, originTargetInstanceItem || selectedInstanceItem);\n          }\n        });\n\n        targetInstance.getItemsByName(selectedName).forEach((item) => {\n          if (item.number > targetCameraDataList.length) {\n            delete item.cameras[camera];\n            if (item.isEmpty) {\n              this.deleteInstanceItem(item);\n            }\n          }\n        });\n      } else if (!sameInstance) {\n        // append to target instance, no instance item in current camera\n        selectedNumber = this.getNextInstanceItemNumber(targetInstance.id, selectedName, camera);\n        const cameraData = selectedInstanceItem.cameras[camera];\n        updateCameraData(selectedNumber, cameraData.toJSON(), [...cameraData.relationships], selectedInstanceItem);\n      }\n\n      if (!sameInstance) {\n        // delete dragged item\n        const shape = this.rootStore.shape.getShapeByInstanceItem(selectedInstanceItem, camera);\n        if (shape) {\n          this.rootStore.shape.deleteShape(shape);\n        }\n        delete selectedInstanceItem.cameras[camera];\n        if (selectedInstanceItem.isEmpty) {\n          this.deleteInstanceItem(selectedInstanceItem);\n        }\n        if (selectedInstance.isEmpty) {\n          this.deleteInstance(selectedInstance);\n        }\n        // update instance dynamic attributes\n        const { currentFrame } = this.rootStore.frame;\n        if (targetInstance.dynamicAttributes?.[camera]?.[currentFrame]) {\n          selectedInstance.setDynamicAttributesByCamera(camera, [targetInstance?.dynamicAttributes?.[camera]?.[currentFrame]]);\n        } else if (!targetInstance?.dynamicAttributes?.[camera]?.[currentFrame] && selectedInstance.dynamicAttributes?.[camera]?.[currentFrame]) {\n          targetInstance.setDynamicAttributesByCamera(camera, [selectedInstance.dynamicAttributes?.[camera]?.[currentFrame]]);\n        }\n        if (selectedInstance?.dynamicAttributes?.[camera]?.[currentFrame]) {\n          selectedInstance.deleteDynamicAttributesByCamera(camera, [currentFrame], selectedInstanceItem.id);\n        }\n      }\n\n      const currInstances = getInstancesState([\n        targetInstance,\n        ...!sameInstance && !selectedInstance.isEmpty ? [selectedInstance] : [],\n      ]);\n      this.rootStore.undo.push({\n        instances: prevInstances,\n        relationships: Object.values(prevRelationships),\n      }, {\n        instances: currInstances,\n        relationships: Object.values(currRelationships),\n      });\n\n      // reselect\n      const currentSelectedInstanceItem = targetInstance.getItemsByName(selectedName).find((item) => item.number === selectedNumber);\n      this.selectInstanceItem(currentSelectedInstanceItem);\n    }\n  }\n\n  /**\n   * get instances json data (for save)\n   * @param options\n   */\n  instancesJSON(options?: {\n    minify?: boolean;\n    noLock?: boolean;\n  }): IInstance[] {\n    return Object.values(this.instances).map((instance) => instance.toJSON(options));\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  getCurrentDynamicAttributesByInstance(instance: Instance) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const { attributes = {} } = instance.dynamicAttributes?.[currentCamera]?.[currentFrame] || {};\n    return attributes;\n  }\n\n  /**\n   * switch between instances or instance items\n   */\n  switch() {\n    // default switch between instances\n    let searchClassName = '.sidebar-category-instance__label';\n    const selectedInstanceItem = this.selectedInstanceItems[0];\n    if (selectedInstanceItem && !selectedInstanceItem.instance.isSingle) {\n      // item in multiple instance selected, switch between instance items\n      searchClassName = '.sidebar-category-instance__item, .sidebar-category-instance__label.single';\n    }\n    const nodes = Array.from(document.querySelectorAll(searchClassName));\n    const selectedIndex = nodes.findIndex((i) => i.classList.contains('selected'));\n    const nextIndex = selectedIndex === nodes.length - 1 ? 0 : selectedIndex + 1;\n    const nextNodes = nodes.slice(nextIndex).filter((i) => !i.classList.contains('hidden'));\n    const nextNode = nextNodes.length > 0 ? nextNodes[0] : nodes.find((i) => !i.classList.contains('hidden'));\n    if (nextNode) {\n      ['mousedown', 'mouseup'].forEach((eventName) => {\n        nextNode.dispatchEvent(new MouseEvent(eventName, {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n          buttons: 1,\n        }));\n      });\n    }\n  }\n\n  /**\n   * set locked for all category shapes in current frame\n   * @param category\n   * @param locked\n   */\n  setLockedForCategory(category: string, locked: boolean) {\n    const { updateShapeLockedState } = this.rootStore.shape;\n    const { currentFrame } = this.rootStore.frame;\n    const prevInstances: IInstance[] = [];\n    const currInstances: IInstance[] = [];\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      if (instance.category === category && instance.frameStatus[currentFrame] !== undefined) {\n        const basicInfo = instance.getBasicInfo();\n        const prevItems: IInstanceItem[] = [];\n        const currItems: IInstanceItem[] = [];\n        const items = Object.values(instance.items);\n        for (let j = 0; j < items.length; j += 1) {\n          const item = items[j];\n          const { prevState, currState } = item.setLockedForAllCameras(currentFrame, locked);\n          if (prevState) {\n            prevItems.push(prevState);\n          }\n          if (currState) {\n            currItems.push(currState);\n            currState.cameras.forEach(({ camera }) => {\n              updateShapeLockedState(item, camera, locked);\n            });\n          }\n        }\n        if (prevItems.length > 0) {\n          prevInstances.push({ ...basicInfo, children: prevItems });\n        }\n        if (currItems.length > 0) {\n          currInstances.push({ ...basicInfo, children: currItems });\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: prevInstances,\n    }, {\n      instances: currInstances,\n    });\n  }\n\n  /**\n   * is all layer shapes locked in current frame\n   * @param camera\n   * @param layer\n   */\n  isLayerLocked(camera: string, layer: number) {\n    const { currentFrame } = this.rootStore.frame;\n    const { activeLayerIndex } = this.rootStore.config;\n    let locked = true;\n    let currentEmpty = true;\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const items = Object.values(instance.items);\n      for (let j = 0; j < items.length; j += 1) {\n        const item = items[j];\n        const frameData = item.cameras[camera]?.frames[currentFrame];\n        if (frameData && frameData.matrixChangeAllowed) {\n          const { layer: l = activeLayerIndex } = frameData;\n          if (l === layer) {\n            currentEmpty = false;\n            if (!frameData.locked) {\n              locked = false;\n            }\n          }\n        }\n        if (!locked && !currentEmpty) {\n          break;\n        }\n      }\n      if (!locked && !currentEmpty) {\n        break;\n      }\n    }\n    return {\n      locked,\n      currentEmpty,\n    };\n  }\n\n  /**\n   * set locked for all layer shapes in current frame\n   * @param camera\n   * @param layer\n   * @param locked\n   */\n  setLockedForLayer(camera: string, layer: number, locked: boolean) {\n    const { updateShapeLockedState } = this.rootStore.shape;\n    const { currentFrame } = this.rootStore.frame;\n    const { activeLayerIndex } = this.rootStore.config;\n    const prevInstances: IInstance[] = [];\n    const currInstances: IInstance[] = [];\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      const basicInfo = instance.getBasicInfo();\n      const prevItems: IInstanceItem[] = [];\n      const currItems: IInstanceItem[] = [];\n      const items = Object.values(instance.items);\n      for (let j = 0; j < items.length; j += 1) {\n        const item = items[j];\n        const frameData = item.cameras[camera]?.frames[currentFrame];\n        if (frameData) {\n          const { layer: l = activeLayerIndex } = frameData;\n          if (l === layer) {\n            const { prevState, currState } = item.setLocked(camera, currentFrame, locked);\n            if (prevState) {\n              prevItems.push(prevState);\n            }\n            if (currState) {\n              currItems.push(currState);\n            }\n            updateShapeLockedState(item, camera, locked);\n          }\n        }\n      }\n      if (prevItems.length > 0) {\n        prevInstances.push({ ...basicInfo, children: prevItems });\n      }\n      if (currItems.length > 0) {\n        currInstances.push({ ...basicInfo, children: currItems });\n      }\n    }\n    this.rootStore.undo.push({\n      instances: prevInstances,\n    }, {\n      instances: currInstances,\n    });\n  }\n\n  /**\n   * lock or unlock all shapes in current frame\n   */\n  setAllLocked(locked: boolean) {\n    const { updateShapeLockedState } = this.rootStore.shape;\n    const { currentFrame } = this.rootStore.frame;\n    const prevInstances: IInstance[] = [];\n    const currInstances: IInstance[] = [];\n    const allInstances = Object.values(this.instances);\n    for (let i = 0; i < allInstances.length; i += 1) {\n      const instance = allInstances[i];\n      if (instance.frameStatus[currentFrame] !== undefined) {\n        const basicInfo = instance.getBasicInfo();\n        const prevItems: IInstanceItem[] = [];\n        const currItems: IInstanceItem[] = [];\n        const items = Object.values(instance.items);\n        for (let j = 0; j < items.length; j += 1) {\n          const item = items[j];\n          const { prevState, currState } = item.setLockedForAllCameras(currentFrame, locked);\n          if (prevState) {\n            prevItems.push(prevState);\n          }\n          if (currState) {\n            currItems.push(currState);\n            currState.cameras.forEach(({ camera }) => {\n              updateShapeLockedState(item, camera, locked);\n            });\n          }\n        }\n        if (prevItems.length > 0) {\n          prevInstances.push({ ...basicInfo, children: prevItems });\n        }\n        if (currItems.length > 0) {\n          currInstances.push({ ...basicInfo, children: currItems });\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: prevInstances,\n    }, {\n      instances: currInstances,\n    });\n  }\n\n  /**\n   * toggle locked status for selected items\n   */\n  toggleLockedForSelectedItems() {\n    const { updateShapeLockedState } = this.rootStore.shape;\n    const { currentFrame, currentCamera } = this.rootStore.frame;\n    const selectedItems = this.selectedInstanceItems.length > 0\n      ? this.selectedInstanceItems\n      : this.selectedInstances.map((i) => Object.values(i.items)).flat();\n    const items = selectedItems.filter((item) => item.cameras[currentCamera]?.frames[currentFrame]?.matrixChangeAllowed);\n    if (items.length > 0) {\n      const currAllLocked = items.every((item) => item.frameLocked[currentFrame]);\n      const prevInstances: Record<string, IInstance> = {};\n      const currInstances: Record<string, IInstance> = {};\n      for (let i = 0; i < items.length; i += 1) {\n        const item = items[i];\n        const basicInfo = item.instance.getBasicInfo();\n        const { prevState, currState } = item.setLocked(currentCamera, currentFrame, !currAllLocked);\n        if (prevState) {\n          if (!prevInstances[item.instance.id]) {\n            prevInstances[item.instance.id] = { ...basicInfo, children: [] };\n          }\n          prevInstances[item.instance.id].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstances[item.instance.id]) {\n            currInstances[item.instance.id] = { ...basicInfo, children: [] };\n          }\n          currInstances[item.instance.id].children.push(currState);\n          currState.cameras.forEach(({ camera }) => {\n            updateShapeLockedState(item, camera, !currAllLocked);\n          });\n        }\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstances),\n      }, {\n        instances: Object.values(currInstances),\n      });\n    }\n  }\n\n  /**\n   * get interpolator worker, create it if has not been initialized\n   */\n  getInterpolator() {\n    if (!this.interpolator) {\n      this.interpolator = new InterpolationWorker();\n      this.interpolator?.addEventListener('message', (e) => {\n        const { type, data } = e.data;\n\n        if (type === 'interpolated') {\n          const timestamp = Date.now();\n          const { camera, frames } = data as InterpolationResult;\n          frames.forEach(({ frameIndex, shapes }) => {\n            shapes.forEach((shape) => {\n              const { instanceItemId } = shape;\n              const dataKey = `${frameIndex}-${camera}`;\n              const shapeKey = `${instanceItemId}-${camera}`;\n\n              if (!this.interpolatedShapes[dataKey]) {\n                this.interpolatedShapes[dataKey] = {\n                  timestamp,\n                  frameIndex,\n                  camera,\n                  shapes: {},\n                };\n              } else {\n                this.interpolatedShapes[dataKey].timestamp = timestamp;\n              }\n              this.interpolatedShapes[dataKey].shapes[shapeKey] = shape;\n            });\n          });\n          this.resolveInterpolatedShapes();\n        }\n\n        if (type === 'pixel-resolved') {\n          const instanceItems: {\n            instanceItem: InstanceItem;\n            camera: string;\n            frameIndex: number;\n            shapeType: ShapeType;\n            shape?: ShapeData;\n            layer: number;\n            order: number;\n          }[] = [];\n\n          const { camera, frameIndex, shapes } = data as ShapeResolutionResult;\n          for (let i = 0; i < shapes.length; i += 1) {\n            const { shapeType, shape, layer, instanceId, instanceItemId } = shapes[i];\n            const instanceItem = this.instances[instanceId]?.items[instanceItemId];\n            if (instanceItem) {\n              instanceItems.push({\n                instanceItem,\n                camera,\n                frameIndex,\n                shapeType,\n                shape,\n                layer,\n                order: 0,\n              });\n            }\n          }\n\n          if (instanceItems.length > 0) {\n            this.updateFrameShapeForInstanceItems(instanceItems);\n            if (frameIndex === this.rootStore.frame.currentFrame) {\n              instanceItems.forEach(({ instanceItem }) => {\n                this.rootStore.shape.setupShape(instanceItem, camera);\n              });\n            }\n            this.interpolatedFrames.add(frameIndex);\n            this.showInterpolatedSuccessMessage();\n          }\n          this.resolveInterpolatedShapes();\n        }\n      });\n    }\n    return this.interpolator;\n  }\n\n  /**\n   * interpolate frames by base frame\n   * @param baseFrame\n   * @param frames\n   * @param camera\n   * @param instanceItems\n   */\n  interpolate(\n    baseFrame: number,\n    frames: number[],\n    camera = this.rootStore.frame.currentCamera,\n    instanceItems?: InstanceItem[],\n  ) {\n    const { niftiParser, attributes, getReadableImage } = this.rootStore.frame;\n    const data: InterpolationData = {\n      interpolateUrl: `${this.rootStore.config.interpolateProxy}/interpolate`,\n      baseUrl: getReadableImage(camera, baseFrame),\n      baseSize: [attributes[camera][baseFrame]?.imageWidth ?? 0, attributes[camera][baseFrame]?.imageHeight ?? 0],\n      baseRotation: attributes[camera][baseFrame]?.rotation ?? 0,\n      baseShapes: [],\n      camera,\n      frames: frames.map((frameIndex) => ({\n        frameIndex,\n        url: getReadableImage(camera, frameIndex),\n      })),\n      isBase64: !!niftiParser,\n    };\n\n    const items = instanceItems ?? Object.values(this.instances).map((instance) => Object.values(instance.items)).flat();\n    for (let i = 0; i < items.length; i += 1) {\n      const instanceItem = items[i];\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData) {\n        const frameData = cameraData.frames[baseFrame];\n        if (interpolationSupportedShapeTypes.includes(frameData?.shapeType)) {\n          data.baseShapes.push({\n            shapeType: frameData.shapeType,\n            shape: frameData.shape,\n            layer: frameData.layer,\n            order: frameData.order,\n            instanceId: instanceItem.instance.id,\n            instanceItemId: instanceItem.id,\n          });\n        }\n      }\n    }\n\n    if (data.baseShapes.length > 0) {\n      this.getInterpolator()?.postMessage({\n        type: 'interpolate',\n        data,\n      });\n      message.info(i18n.translate('INTERPOLATION_FRAMES_INFO', { values: { frames: formatFrames(frames) } }));\n    } else {\n      message.warn(i18n.translate('INTERPOLATION_FRAMES_WARN'));\n    }\n  }\n\n  /**\n   * resolve interpolated shapes, including:\n   * 1) resolve pixel shapes overlaps\n   */\n  resolveInterpolatedShapes() {\n    const sorted = Object.values(this.interpolatedShapes).sort((a, b) => a.timestamp - b.timestamp);\n\n    const oldest = sorted[0];\n    if (oldest !== undefined) {\n      const { frameIndex, camera, shapes } = oldest;\n      const dataKey = `${frameIndex}-${camera}`;\n      delete this.interpolatedShapes[dataKey];\n      const rotation = this.rootStore.frame.getFrameRotationForCamera(camera, frameIndex);\n      const data: ShapeResolutionData = {\n        camera,\n        frameIndex,\n        rotation,\n        shapes: Object.values(shapes),\n        originPixelShapes: [],\n        pixelLocked: this.rootStore.segmentation.locked,\n      };\n      Object.values(this.instances).forEach((instance) => {\n        Object.values(instance.items).forEach((instanceItem) => {\n          const frameData = instanceItem.cameras[camera]?.frames[frameIndex];\n          if (frameData?.shapeType === ShapeType.PIXEL) {\n            const shapeKey = `${instanceItem.id}-${camera}`;\n            if (!shapes[shapeKey]) {\n              data.originPixelShapes.push({\n                shape: frameData.shape as PixelData,\n                locked: frameData.locked,\n                layer: frameData.layer,\n                instanceId: instance.id,\n                instanceItemId: instanceItem.id,\n              });\n            }\n          }\n        });\n      });\n      this.getInterpolator()?.postMessage({\n        type: 'pixel-resolve',\n        data,\n      });\n    }\n  }\n\n  /**\n   * show interpolated success message\n   */\n  showInterpolatedSuccessMessage = debounce(() => {\n    const frames = Array.from(this.interpolatedFrames).sort((a, b) => a - b);\n    frames.forEach((frameIndex) => this.interpolatedFrames.delete(frameIndex));\n    message.success(i18n.translate('INTERPOLATION_FRAMES_SUCCESS', { values: { frames: formatFrames(frames) } }));\n  }, 500);\n\n  /**\n   * enter reorganize mode\n   * @param instanceItemName\n   */\n  enterReorganizeMode(instanceItemName?: string) {\n    this.exitReorganizeMode();\n\n    if (this.selectedInstances.length === 1 && (\n      instanceItemName || this.selectedInstanceItems.length === 1\n    )) {\n      this.reorganizingInstance = this.selectedInstances[0];\n      this.reorganizingInstanceItemName = instanceItemName || this.selectedInstanceItems[0].name;\n\n      let label = '';\n      if (this.reorganizingInstance.isSingle) {\n        // single\n        label = i18n.translate('CHANGE_CATEGORY_REORGANIZE_ITEM_LABEL_SINGLE', {\n          values: {\n            instance: this.reorganizingInstance.label,\n          },\n        });\n      } else {\n        const itemLabel = this.reorganizingInstance.categoryRef.children.find((c) => c.name === this.reorganizingInstanceItemName)?.displayName;\n        label = i18n.translate('CHANGE_CATEGORY_REORGANIZE_ITEM_LABEL', {\n          values: {\n            instance: this.reorganizingInstance.label,\n            item: itemLabel || this.reorganizingInstanceItemName,\n          },\n        });\n      }\n\n      this.reorganizingMsg = message.open({\n        content: React.createElement(Message, {\n          message: i18n.translate('CHANGE_CATEGORY_REORGANIZE_TIP', { values: { label } }),\n          btn: i18n.translate('CHANGE_CATEGORY_REORGANIZE_FINISH'),\n          onBtnClick: () => this.exitReorganizeMode(),\n        }),\n        duration: 0,\n        icon: null,\n        className: 'mode-message',\n      });\n    }\n  }\n\n  /**\n   * exit reorganize mode\n   */\n  exitReorganizeMode() {\n    if (this.reorganizingMsg) {\n      this.reorganizingMsg();\n    }\n    this.reorganizingInstance = undefined;\n    this.reorganizingInstanceItemName = undefined;\n    this.reorganizingMsg = undefined;\n  }\n\n  /**\n   * try to reorganize\n   */\n  tryReorganize() {\n    if (this.reorganizingInstance && this.reorganizingInstanceItemName && this.isSingleSelected) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const frameData = selectedInstanceItem.cameras[currentCamera]?.frames[currentFrame];\n      if (selectedInstanceItem.instance.id === this.reorganizingInstance.id) {\n        if (!frameData?.numberChangeAllowed) {\n          // same instance, but number change is disabled\n          return;\n        }\n      } else if (\n        (!frameData?.numberChangeAllowed && selectedInstanceItem.instance.number !== this.reorganizingInstance.number) ||\n        (!frameData?.categoryChangeAllowed && selectedInstanceItem.instance.category !== this.reorganizingInstance.category)\n      ) {\n        return;\n      }\n      const currentTool = getToolTypeFromFrameData(frameData);\n      if (currentTool) {\n        const categoryItem = this.reorganizingInstance.categoryRef.children.find((c) => c.name === this.reorganizingInstanceItemName);\n        if (categoryItem) {\n          const tools = categoryItem.tools.map((t) => t.type);\n          if (includeSameTool(currentTool, tools)) {\n            // same shape type, do reorganize\n            const targetInstanceNum = (\n              selectedInstanceItem.instance.id === this.reorganizingInstance.id &&\n              selectedInstanceItem.name === this.reorganizingInstanceItemName\n            )\n              ? undefined // in same instance, and same instance item name, should move to new instance\n              : this.reorganizingInstance.number;\n            this.changeCategoryForInstanceItem(\n              selectedInstanceItem,\n              this.reorganizingInstance.category,\n              this.reorganizingInstanceItemName,\n              { [currentCamera]: [currentFrame] },\n              targetInstanceNum,\n            );\n          } else {\n            message.warning(i18n.translate('CHANGE_CATEGORY_REORGANIZE_DIFF_SHAPE'));\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}