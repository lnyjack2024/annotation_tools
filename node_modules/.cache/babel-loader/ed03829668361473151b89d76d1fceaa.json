{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/WavesurferComp/WavesurferComp.jsx\";\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport hexToRgba from 'hex-to-rgba';\nimport { notification, Modal } from 'antd';\nimport { cloneDeep } from 'lodash';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { defaultColor, formatTimestamp, translate, triggerForm, StyleConfigMode, getConfigColor } from '../../constants';\nimport HandleIcon from '../common/Icons/HandleIcon';\nimport { debug, getWavesurfers, mergeSegmentBackward, setPlayingState, setSegmentTimestamp, splitSegmentForward, setVideoValid, setVideoZoom, deleteLine, pushLine, setLineRole, removeSegment, setSegments, parseSegments, setErrorMsg, setAudioErrorMsg, moveSegmentInBatch, updateVideoInfo, setLoading } from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { timeInterval, primaryLabelInterval, secondaryLabelInterval, formatTimeCallback } from '../utils/TimelineUtil';\nimport i18n from '../../locales';\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\nclass WavesurferComp extends React.Component {\n  constructor() {\n    super();\n    this.insertLine = data => {\n      var _styleConfig$groups;\n      // eslint-disable-next-line prefer-const\n      let {\n        start,\n        end,\n        role,\n        videoIndex,\n        segmentIndex,\n        lineIndex,\n        attributes\n      } = data;\n      const {\n        segments\n      } = this.regions;\n      const {\n        ontology,\n        styleConfig\n      } = this.props;\n      videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n      const wavesurfer = this.wavesurfers[videoIndex];\n      lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? 0 : lineIndex;\n      end = Number.isNaN(parseFloat(end)) ? wavesurfer.getDuration() : end;\n      if (!segments[videoIndex]) segments[videoIndex] = [];\n      if (!segments[videoIndex][segmentIndex]) segments[videoIndex][segmentIndex] = [];\n      role = role || 'none';\n      let configColor = '';\n      if (attributes && (styleConfig === null || styleConfig === void 0 ? void 0 : (_styleConfig$groups = styleConfig.groups) === null || _styleConfig$groups === void 0 ? void 0 : _styleConfig$groups.length) > 0) {\n        configColor = getConfigColor(attributes, styleConfig.groups);\n      }\n      const color = hexToRgba(configColor || ontology.get(role) || defaultColor.defaultWhite, role === 'none' && !configColor ? 0 : defaultColor.defaultAlpha);\n      const item = {\n        start,\n        end,\n        color,\n        resize: false,\n        drag: false,\n        data: {\n          type: 'line'\n        },\n        formatTimeCallback: () => ''\n      };\n      const region = wavesurfer.addRegion(item);\n      region.element.classList.add('line-region');\n      const mark = document.createElement('div');\n      mark.className = 'line-mark';\n      region.element.appendChild(mark);\n      const title = document.createElement('div');\n      title.className = 'line-title';\n      title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(region.end - region.start).toFixed(3)}s (${formatTimestamp(region.start)}~${formatTimestamp(region.end)})` : '';\n      mark.appendChild(title);\n      region.title = title;\n      region.role = role;\n      segments[videoIndex][segmentIndex].splice(lineIndex, 0, region);\n      segments[videoIndex][segmentIndex].filter(line => !!(line === null || line === void 0 ? void 0 : line.element)).forEach((line, index, array) => {\n        const height = 100 / array.length;\n        const top = height * index;\n        line.element.style.height = `${height}%`;\n        line.element.style.top = `${top}%`;\n      });\n      return region;\n    };\n    this.renderSegments = () => {\n      const {\n        videos,\n        results\n      } = this.props;\n      this.regions = {\n        segments: [],\n        anchors: []\n      };\n      videos.forEach((v, i) => {\n        if (v.ready) {\n          this.wavesurfers[i].clearRegions();\n          this.initRegion(i, results[i]);\n          if (i === this.current.videoIndex) {\n            this.setNewVideo();\n            this.setSelectedSegment(this.current.segments[0][0]);\n          }\n        }\n      });\n    };\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null,\n      // Minimap container\n      waveform: null,\n      // Waveform container\n      timeline: null,\n      // Timeline container\n      audioContainer: null,\n      // Cursor container\n      videoContainer: null // Video container\n    };\n    this.regions = {\n      segments: [],\n      anchors: []\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      segments: null,\n      anchors: null,\n      segmentSelected: null,\n      anchorSelected: null,\n      undoList: null,\n      redoList: null,\n      undoLock: false,\n      redoLock: false\n    };\n    this.state = {\n      cursorTime: 0 // seconds\n    };\n  }\n  get currentSegments() {\n    return this.props.results[this.current.videoIndex];\n  }\n  shouldComponentUpdate(nextProps) {\n    return nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n  componentDidUpdate() {\n    this.initWaveSurfer();\n  }\n  clearAll() {\n    Modal.confirm({\n      className: 'modal-root',\n      title: i18n.translate('COMMON_CLAER_CONFIRM_TITLE'),\n      content: i18n.translate('COMMON_CLAER_CONFIRM_DESC'),\n      autoFocusButton: null,\n      okText: i18n.translate('COMMON_CLAER_CONFIRM_SURE'),\n      okType: 'danger',\n      cancelText: i18n.translate('COMMON_CLAER_CONFIRM_CANCEL'),\n      onOk: () => {\n        const {\n          currentSegment\n        } = this.props;\n        const {\n          videoIndex\n        } = this.current;\n        const segments = cloneDeep(this.currentSegments);\n        const afterSegments = [{\n          id: uuid(),\n          start: 0,\n          end: segments[segments.length - 1].end,\n          attributes: {},\n          content: [{\n            role: 'none',\n            text: '',\n            attributes: {}\n          }],\n          qaChecked: undefined,\n          qaComment: '',\n          qaReason: null\n        }];\n        this.props.setSegments({\n          videoIndex,\n          segments: afterSegments\n        });\n        this.wavesurfers[videoIndex].clearRegions();\n        this.regions.segments[videoIndex] = [];\n        this.regions.anchors[videoIndex] = [];\n        this.current = {\n          ...this.current,\n          anchorSelected: null,\n          anchors: null,\n          segmentSelected: null,\n          segments: null,\n          videoIndex: 0\n        };\n        const currentSegments = this.parseSegments(videoIndex, afterSegments);\n        this.initRegion(videoIndex, currentSegments);\n        this.current.segments = this.regions.segments[videoIndex];\n        this.current.anchors = this.regions.anchors[videoIndex];\n        this.addHistory('clear_all', {\n          after: {\n            videoIndex,\n            currentIndex: 0,\n            segments: afterSegments\n          },\n          before: {\n            videoIndex,\n            currentIndex: currentSegment,\n            segments\n          }\n        });\n      }\n    });\n  }\n  addHistory(type, data) {\n    const {\n      undoList,\n      undoLock,\n      redoLock,\n      redoList\n    } = this.current;\n    let recallList;\n    if (undoLock) recallList = redoList;else if (redoLock) recallList = undoList;else {\n      recallList = undoList;\n      this.current.redoList = [];\n    }\n    if (type === 'trimAnchor' && recallList.length) {\n      const prev = recallList[recallList.length - 1];\n      if (prev.type === 'trimAnchor' && prev.data.trimAnchor === data.trimAnchor) return;\n    }\n    recallList.push({\n      type,\n      data\n    });\n    if (recallList.length > 50) recallList.shift();\n  }\n  recallHistory(action) {\n    const {\n      undoList,\n      redoList,\n      anchors\n    } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) return;\n    if (action === 'undo') this.current.undoLock = true; // lock\n    if (action === 'redo') this.current.redoLock = true;\n    const recallItem = recallList.pop();\n    const {\n      type,\n      data\n    } = recallItem;\n    switch (type) {\n      case 'singleLination-recall':\n        this.singleLination(data.sec); // addHistory inside\n        break;\n      case 'doubleLination-recall':\n        this.doubleLination(data.start, data.end); // addHistory inside\n        break;\n      case 'singleLination-adjust':\n        {\n          const {\n            nearbyAnchorIndex,\n            prevStart\n          } = data;\n          const nearbyAnchor = anchors[nearbyAnchorIndex];\n          const sec = nearbyAnchor.start;\n          nearbyAnchor.update({\n            start: prevStart\n          });\n          this.handleAnchorDrag(nearbyAnchor);\n          this.addHistory('singleLination-recall', {\n            sec\n          });\n        }\n        break;\n      case 'singleLination-split':\n        {\n          const {\n            splitAnchorIndex\n          } = data;\n          const splitAnchor = anchors[splitAnchorIndex];\n          const sec = splitAnchor.start;\n          this.mergeSegment(splitAnchor);\n          this.addHistory('singleLination-recall', {\n            sec\n          });\n        }\n        break;\n      case 'doubleLination-adjust-adjust':\n        {\n          const {\n            nearbyLeftAnchorIndex,\n            prevLeftStart,\n            nearbyRightAnchorIndex,\n            prevRightStart\n          } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const {\n            start\n          } = nearbyLeftAnchor;\n          const end = nearbyRightAnchor.start;\n          nearbyLeftAnchor.update({\n            start: prevLeftStart\n          });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          nearbyRightAnchor.update({\n            start: prevRightStart\n          });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'doubleLination-adjust-split':\n        {\n          const {\n            nearbyLeftAnchorIndex,\n            prevLeftStart,\n            splitRightAnchorIndex\n          } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const {\n            start\n          } = nearbyLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          nearbyLeftAnchor.update({\n            start: prevLeftStart\n          });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'doubleLination-split-adjust':\n        {\n          const {\n            splitLeftAnchorIndex,\n            nearbyRightAnchorIndex,\n            prevRightStart\n          } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const {\n            start\n          } = splitLeftAnchor.start;\n          const end = nearbyRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          nearbyRightAnchor.update({\n            start: prevRightStart\n          });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'doubleLination-split-split':\n        {\n          const {\n            splitLeftAnchorIndex,\n            splitRightAnchorIndex\n          } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const {\n            start\n          } = splitLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', {\n            start,\n            end\n          });\n        }\n        break;\n      case 'pushLine':\n        this.props.deleteLine(data); // addHistory inside\n        break;\n      case 'deleteLine':\n        this.props.pushLine(data); // addHistory inside\n        break;\n      case 'dragAnchor':\n        {\n          const {\n            dragAnchorIndex,\n            prevStart\n          } = data;\n          const dragAnchor = anchors[dragAnchorIndex];\n          const {\n            start\n          } = dragAnchor;\n          dragAnchor.update({\n            start: prevStart\n          });\n          this.handleAnchorDrag(dragAnchor);\n          this.addHistory('dragAnchor', {\n            dragAnchorIndex,\n            prevStart: start\n          });\n        }\n        break;\n      case 'trimAnchor':\n        {\n          const {\n            trimAnchorIndex,\n            prevStart\n          } = data;\n          const trimAnchor = anchors[trimAnchorIndex];\n          const {\n            start\n          } = trimAnchor;\n          trimAnchor.update({\n            start: prevStart\n          });\n          this.handleAnchorDrag(trimAnchor);\n          this.addHistory('trimAnchor', {\n            trimAnchorIndex,\n            prevStart: start\n          });\n        }\n        break;\n      case 'mergeSegment':\n        {\n          const {\n            mergeSec,\n            prevRules,\n            nextRules\n          } = data;\n          const splitSegment = this.getSegmentByTime(mergeSec);\n          this.splitSegment(splitSegment, mergeSec, prevRules, nextRules);\n        }\n        break;\n      case 'setLineColor':\n        this.props.setLineRole(data); // addHistory inside\n        break;\n      case 'bulkMovement':\n        {\n          const {\n            step\n          } = data;\n          const bulkMovementDirection = action === 'redo' ? 1 : -1;\n          this.moveRegionsInBatch(bulkMovementDirection * step);\n          this.addHistory('bulkMovement', {\n            step: -bulkMovementDirection * step\n          });\n          break;\n        }\n      case 'clear_all':\n        {\n          const {\n            before,\n            after\n          } = data;\n          const {\n            videoIndex,\n            currentIndex,\n            segments\n          } = action === 'undo' ? before : after;\n          this.wavesurfers[videoIndex].clearRegions();\n          this.props.setSegments({\n            videoIndex,\n            segments\n          });\n          this.regions = {\n            segments: [],\n            anchors: []\n          };\n          this.regions.segments[videoIndex] = [];\n          this.regions.anchors[videoIndex] = [];\n          this.current = {\n            ...this.current,\n            anchorSelected: null,\n            anchors: null,\n            segmentSelected: null,\n            segments: null,\n            videoIndex: 0\n          };\n          const currentSegments = this.parseSegments(videoIndex, segments);\n          this.initRegion(videoIndex, currentSegments);\n          this.current.segments = this.regions.segments[videoIndex];\n          this.current.anchors = this.regions.anchors[videoIndex];\n          this.props.setCurrentSegment({\n            index: currentIndex\n          });\n          break;\n        }\n      default:\n        break;\n    }\n    if (action === 'undo') this.current.undoLock = false; // lock\n    if (action === 'redo') this.current.redoLock = false;\n  }\n\n  // Called after currentVideo change\n  setNewVideo() {\n    const {\n      videoIndex\n    } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.segments = this.regions.segments[videoIndex];\n    this.current.anchors = this.regions.anchors[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n  setCurrentVideo(newVideoIndex) {\n    const {\n      videoIndex\n    } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.removeSelectedSegment();\n    this.removeSelectedAnchor();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n  removeSelectedAnchor() {\n    const {\n      anchorSelected\n    } = this.current;\n    if (!anchorSelected) return;\n    anchorSelected.mark.classList.remove('anchor-mark-selected');\n    this.current.anchorSelected = null;\n  }\n  setCurrentZoom(newZoom) {\n    if (newZoom) this.current.zoom = newZoom;\n    const {\n      zoom,\n      videoIndex,\n      wavesurfer\n    } = this.current;\n    const duration = this.wavesurfers[videoIndex].getDuration();\n    const cursorTime = this.getCursorTime();\n    const currentTime = wavesurfer.getCurrentTime();\n    const {\n      offsetWidth\n    } = wavesurfer.container;\n    const {\n      offsetLeft\n    } = wavesurfer.cursor.cursor;\n    const totalWidth = offsetWidth * zoom;\n    const pxPerSec = totalWidth / duration;\n    wavesurfer.zoom(pxPerSec);\n    this.setCurrentScroll(cursorTime < 0 ? currentTime : cursorTime, cursorTime < 0 ? offsetWidth / 2 : offsetLeft, false);\n  }\n  componentDidMount() {\n    // Record currentTime and locate currentCursor\n    setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const {\n        wavesurfer\n      } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n  }\n  componentWillUnmount() {\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach(c => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n  setCurrentScroll(destTime, offsetLeft, boundaryCheck) {\n    offsetLeft = offsetLeft || 0;\n    destTime = destTime || 0;\n    const {\n      wavesurfer\n    } = this.current;\n    const {\n      scrollLeft\n    } = wavesurfer.container.lastChild;\n    const {\n      offsetWidth\n    } = wavesurfer.container;\n    const {\n      minPxPerSec\n    } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) wavesurfer.drawer.recenter(scrollTime / duration);else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) wavesurfer.drawer.recenter(scrollTime / duration);\n    }\n  }\n  insertSegment(data) {\n    const {\n      start,\n      end,\n      segmentIndex\n    } = data;\n    let {\n      videoIndex\n    } = data;\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    const {\n      segments\n    } = this.regions;\n    if (!segments[videoIndex]) segments[videoIndex] = [];\n    segments[videoIndex].splice(segmentIndex, 0, []);\n    this.insertLine({\n      start,\n      end,\n      videoIndex,\n      segmentIndex\n    });\n    return segments[videoIndex][segmentIndex];\n  }\n  insertTempAnchor(data) {\n    const {\n      segmentSelected\n    } = this.current;\n    const {\n      start,\n      end\n    } = data;\n    const items = [{\n      start,\n      resize: false,\n      drag: true,\n      data: {\n        type: 'tempAnchor',\n        prevStart: start\n      },\n      formatTimeCallback: () => ''\n    }, {\n      start: end,\n      resize: false,\n      drag: true,\n      data: {\n        type: 'tempAnchor',\n        prevStart: end\n      }\n    }];\n    const {\n      wavesurfer\n    } = this.current;\n    const regions = new Array(2);\n    regions[0] = wavesurfer.addRegion(items[0]);\n    regions[1] = wavesurfer.addRegion(items[1]);\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.leftTempAnchor = regions[0];\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.rightTempAnchor = regions[1];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const region of regions) {\n      region.element.classList.add('anchor-region');\n      const handle = document.createElement('div');\n      handle.className = 'anchor-handle';\n      ReactDOM.render( /*#__PURE__*/React.createElement(HandleIcon, {\n        style: {\n          height: '100%',\n          width: '100%'\n        },\n        viewBox: \"0, 10, 16, 16\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 507,\n          columnNumber: 24\n        }\n      }), handle);\n      region.element.appendChild(handle);\n      region.hanlde = handle;\n      const mark = document.createElement('div');\n      mark.className = 'anchor-mark-temp';\n      region.element.appendChild(mark);\n      region.mark = mark;\n    }\n  }\n  insertAnchor(data) {\n    // eslint-disable-next-line prefer-const\n    let {\n      start,\n      videoIndex,\n      segmentIndex\n    } = data;\n    const {\n      toolMode\n    } = this.props;\n    const {\n      anchors\n    } = this.regions;\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    if (segmentIndex === 0) return;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const item = {\n      start,\n      resize: false,\n      drag: !isAnnotationReadonly(toolMode),\n      // toolMode !== 'QA_RO',\n      data: {\n        type: 'anchor',\n        prevStart: start\n      },\n      formatTimeCallback: () => ''\n    };\n    const region = wavesurfer.addRegion(item);\n    anchors[videoIndex].splice(segmentIndex - 1, 0, region);\n    region.element.classList.add('anchor-region');\n    const handle = document.createElement('div');\n    handle.className = 'anchor-handle';\n    if (isAnnotationReadonly(toolMode)) handle.classList.add('anchor-handle-lock');\n    ReactDOM.render( /*#__PURE__*/React.createElement(HandleIcon, {\n      style: {\n        height: '100%',\n        width: '100%'\n      },\n      viewBox: \"0, 10, 16, 16\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 541,\n        columnNumber: 22\n      }\n    }), handle);\n    region.element.appendChild(handle);\n    region.hanlde = handle;\n    const mark = document.createElement('div');\n    mark.className = 'anchor-mark';\n    region.element.appendChild(mark);\n    region.mark = mark;\n    return region;\n  }\n  removeSelectedSegment() {\n    const {\n      segmentSelected,\n      anchorSelected\n    } = this.current;\n    if (anchorSelected && anchorSelected.data.type === 'tempAnchor') this.removeSelectedAnchor();\n    if (segmentSelected && segmentSelected.data.type === 'temp') {\n      segmentSelected.remove();\n      if (segmentSelected.leftTempAnchor) segmentSelected.leftTempAnchor.remove();\n      if (segmentSelected.rightTempAnchor) segmentSelected.rightTempAnchor.remove();\n    }\n    this.current.segmentSelected = null;\n  }\n  setSelectedSegment(region) {\n    this.removeSelectedSegment();\n    if (region.data.type === 'line') this.current.wavesurfer.frame.update({\n      start: region.start,\n      end: region.end\n    });\n    this.current.segmentSelected = region;\n  }\n  setCurrentSegment(currentSegment, start) {\n    var _this$current$segment, _this$current$segment2;\n    const {\n      currentPlayMode\n    } = this.props;\n    const {\n      wavesurfer\n    } = this.current;\n    const region = (_this$current$segment = this.current.segments) === null || _this$current$segment === void 0 ? void 0 : (_this$current$segment2 = _this$current$segment[currentSegment]) === null || _this$current$segment2 === void 0 ? void 0 : _this$current$segment2[0];\n    start = start || (region === null || region === void 0 ? void 0 : region.start);\n    this.setSelectedSegment(region);\n    this.seekCurrentAudio(start);\n    this.setCurrentScroll(start, 0, true);\n    if (currentPlayMode !== 'overallLoop') {\n      wavesurfer.play();\n    }\n  }\n  setLineColor(videoIndex, segmentIndex, lineIndex, role) {\n    try {\n      var _styleConfig$groups2;\n      const {\n        results,\n        styleConfig\n      } = this.props;\n      const segment = results[videoIndex][segmentIndex];\n      const line = this.regions.segments[videoIndex][segmentIndex][lineIndex];\n      const prevRole = line.role;\n      let color = '';\n      if ((styleConfig === null || styleConfig === void 0 ? void 0 : (_styleConfig$groups2 = styleConfig.groups) === null || _styleConfig$groups2 === void 0 ? void 0 : _styleConfig$groups2.length) > 0) {\n        const attributes = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.mode) === StyleConfigMode.line ? line.attributes : segment.attributes;\n        color = getConfigColor(attributes, styleConfig.groups);\n      }\n      if (!color) {\n        color = this.props.ontology.get(role);\n      }\n      line.update({\n        color: hexToRgba(color, !color ? 0 : defaultColor.defaultAlpha)\n      });\n      line.role = role;\n      this.addHistory('setLineColor', {\n        videoIndex,\n        segmentIndex,\n        lineIndex,\n        role: prevRole\n      });\n    } catch (e) {\n      console.error('Line region not found');\n    }\n  }\n  setSegmentColor(videoIndex, segmentIndex, lines, color) {\n    const segment = this.regions.segments[videoIndex][segmentIndex];\n    for (let i = 0; i < lines.length; i += 1) {\n      const lineIndex = lines[i];\n      const line = segment[lineIndex];\n      const roleColor = this.props.ontology.get(line.role);\n      const rgba = hexToRgba(color || roleColor || defaultColor.defaultWhite, !color && line.role === 'none' ? 0 : defaultColor.defaultAlpha);\n      if (line && rgba !== line.color) {\n        line.update({\n          color: rgba\n        });\n      }\n    }\n  }\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) this.initWaveSurfer();\n  }\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) this.initWaveSurfer();\n  }\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n  playVideo() {\n    const {\n      wavesurfer,\n      segmentSelected\n    } = this.current;\n    if (segmentSelected && wavesurfer.getCurrentTime() > segmentSelected.end - ANCHOR_MOVEMENT_STEP) {\n      this.seekCurrentAudio(segmentSelected.start);\n      this.setCurrentScroll(segmentSelected.start, 0, true);\n    }\n    wavesurfer.play();\n  }\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n  parseSegments(videoIndex, segs) {\n    const {\n      results,\n      ontology,\n      lineConfig,\n      keyAttribute,\n      segmentConfig\n    } = this.props;\n    const segments = Array.isArray(segs) ? segs : results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map(value => value.name);\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map(value => value.name);\n    const {\n      updatedValues: updateLineValues\n    } = triggerForm(lineConfig, {});\n    const {\n      updatedValues: updateSegmentValues\n    } = triggerForm(segmentConfig, {});\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start\n      if (!segment.start && segment.start !== 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_NULL')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end === null || segment.end === undefined) {\n        segment.end = duration;\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      segment.attributes = {\n        ...updateSegmentValues,\n        ...segment.attributes\n      };\n      Object.keys(segment.attributes).forEach(key => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = {\n          ...updateLineValues,\n          ...line.attributes\n        };\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach(key => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n    }\n    // segments = segments.filter(segment => segment.isValid);\n    const MIN_LENGTH = this.props.minSegmentLength;\n    segments.sort((a, b) => {\n      if (a.start < b.start + MIN_LENGTH && a.start > b.start - MIN_LENGTH) {\n        if (a.end == null) return -1;\n        if (b.end == null) return 1;\n        return a.end - b.end;\n      }\n      return a.start - b.start;\n    });\n    let currentEnd = 0;\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      if (segment.end - segment.start <= MIN_LENGTH && i < segments.length - 1) {\n        segments[i + 1].start = segment.start;\n        segments.splice(i, 1);\n        i -= 1;\n      } else if (segment.start > currentEnd - MIN_LENGTH && segment.start < currentEnd + MIN_LENGTH && (segment.end > currentEnd || !segment.end)) {\n        segments[i].start = currentEnd;\n        currentEnd = segment.end;\n      } else if (segment.start < currentEnd - MIN_LENGTH || currentEnd == null) {\n        // throw new Error(`${translate('PAYLOAD_ERROR_OVERLAP_SEGMENT')} ${JSON.stringify(segment)} start=${segment.start} currentEnd=${currentEnd} min=${MIN_LENGTH}`);\n        segments.splice(i, 1);\n        i -= 1;\n      } else if (segment.start > currentEnd + MIN_LENGTH) {\n        segments.splice(i, 0, createSegment(currentEnd, segment.start, segmentConfig, lineConfig));\n        currentEnd = segment.end;\n        i += 1;\n      }\n      if (i === segments.length - 1) {\n        if (segment.end < duration) {\n          if (duration - segment.end <= MIN_LENGTH) {\n            segment.end = duration;\n          } else {\n            segments.push(createSegment(segment.end, duration, segmentConfig, lineConfig));\n          }\n        }\n      }\n    }\n    // videoIndex, segments\n    this.props.parseSegments({\n      videoIndex,\n      segments\n    });\n    return segments;\n  }\n  initRegion(videoIndex, segments) {\n    const wavesurfer = this.wavesurfers[videoIndex];\n    wavesurfer.frame = wavesurfer.addRegion({\n      start: segments[0].start,\n      end: segments[0].end,\n      color: 'rgba(0,0,0,0)',\n      resize: false,\n      drag: false\n    });\n    wavesurfer.frame.element.classList.add('segment-frame');\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      segment.content.forEach((line, lineIndex) => {\n        var _this$props$styleConf;\n        const attributes = ((_this$props$styleConf = this.props.styleConfig) === null || _this$props$styleConf === void 0 ? void 0 : _this$props$styleConf.mode) === StyleConfigMode.segment ? segment.attributes : line.attributes;\n        this.insertLine({\n          videoIndex,\n          segmentIndex,\n          lineIndex,\n          role: line.role,\n          start: segment.start,\n          end: segment.end,\n          attributes\n        });\n      });\n      this.insertAnchor({\n        videoIndex,\n        segmentIndex,\n        start: segment.start\n      });\n    }\n  }\n  getSegmentByRegion(region) {\n    let segmentIndex = -1;\n    const {\n      segments\n    } = this.current;\n    segments.forEach((segment, index) => {\n      if (segment.indexOf(region) >= 0) segmentIndex = index;\n    });\n    return segmentIndex;\n  }\n  seekCurrentAudio(currentTime = 0) {\n    const {\n      wavesurfer\n    } = this.current;\n    const duration = wavesurfer.getDuration();\n    /*\n    currentTime = currentTime || 0;\n    let rate = currentTime / duration;\n    if (rate > 1) rate = 1;\n    if (rate < 0) rate = 0;\n    wavesurfer.seekTo(rate);\n    */\n    // Skip function wavesurfer.seekTo(progress), use wavesurfer.backend.seekTo(time) instead.\n    // Fireevent seek will be ignored\n    if (currentTime < 0) currentTime = 0;\n    if (currentTime > duration) currentTime = duration;\n    wavesurfer.backend.seekTo(currentTime);\n  }\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const {\n      currentPlayMode\n    } = this.props;\n    if (region.data.type === 'temp') {\n      this.setCurrentScroll(region.start, 0, true);\n      region.play();\n    } else if (region.data.type === 'line') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const cursorTime = this.getCursorTime();\n      const start = cursorTime > 0 && (e.altKey || e.ctrlKey) || currentPlayMode === 'overallLoop' ? cursorTime : null;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({\n        index: segmentIndex,\n        start\n      });\n    } else if (region.data.type === 'anchor' || region.data.type === 'tempAnchor') {\n      const {\n        anchorSelected\n      } = this.current;\n      if (region !== anchorSelected) this.setSelectedAnchor(region);else this.removeSelectedAnchor();\n    }\n  }\n  setSelectedAnchor(region) {\n    this.removeSelectedAnchor();\n    region.mark.classList.add('anchor-mark-selected');\n    this.current.anchorSelected = region;\n  }\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n  setCurrentSpeed(speed) {\n    var _this$current$wavesur;\n    (_this$current$wavesur = this.current.wavesurfer) === null || _this$current$wavesur === void 0 ? void 0 : _this$current$wavesur.setPlaybackRate(speed);\n  }\n  resetRegionTitle() {\n    const {\n      segments\n    } = this.current;\n    segments.forEach((segment, segmentIndex) => {\n      segment.forEach((line, lineIndex) => {\n        line.title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(line.end - line.start).toFixed(3)} [${formatTimestamp(line.start)}~${formatTimestamp(line.end)}]` : '';\n      });\n    });\n  }\n  moveRegionsInBatch(step) {\n    const {\n      wavesurfer,\n      anchors,\n      segmentSelected\n    } = this.current;\n    const min = 0;\n    const max = wavesurfer.getDuration();\n    Object.keys(wavesurfer.regions.list).forEach(id => {\n      const region = wavesurfer.regions.list[id];\n      if (region.data.type !== 'line') {\n        return;\n      }\n      this.__moveRegion(region, step, min, max);\n      if (segmentSelected === region) {\n        wavesurfer.frame.update({\n          start: region.start,\n          end: region.end\n        });\n      }\n    });\n    anchors.forEach(anchor => {\n      this.__moveRegion(anchor, step, min, max);\n    });\n    this.props.moveSegmentInBatch({\n      step,\n      min,\n      max\n    });\n    this.resetRegionTitle();\n  }\n  __moveRegion(region, step, min, max) {\n    if (region.start > min || region.end < max) {\n      if (region.start > min) {\n        region.start = region.start + step < min ? min : region.start + step;\n      }\n      if (region.end < max) {\n        region.end = region.end + step > max ? max : region.end + step;\n      }\n      region.update({\n        start: region.start,\n        end: region.end\n      });\n    }\n  }\n  handleAnchorDrag(region) {\n    const {\n      wavesurfer,\n      anchors,\n      segments,\n      segmentSelected\n    } = this.current;\n    const {\n      minSegmentLength,\n      toolMode\n    } = this.props;\n    const i = anchors.indexOf(region);\n    if (i < 0) return false;\n    const leftBoundary = i === 0 ? 0 : anchors[i - 1].start;\n    const rightBoundary = i === anchors.length - 1 ? wavesurfer.getDuration() : anchors[i + 1].start;\n    if (region.start < rightBoundary - minSegmentLength && region.start > leftBoundary + minSegmentLength && !isAnnotationReadonly(toolMode)) {\n      region.data.prevStart = region.start;\n      const prevSegment = segments[i];\n      const nextSegment = segments[i + 1];\n      prevSegment.forEach(line => {\n        line.update({\n          end: region.start\n        });\n      });\n      nextSegment.forEach(line => {\n        line.update({\n          start: region.start\n        });\n      });\n      this.props.setSegmentTimestamp({\n        segmentIndex: i,\n        end: region.start\n      });\n      this.props.setSegmentTimestamp({\n        segmentIndex: i + 1,\n        start: region.start\n      });\n      this.resetRegionTitle();\n      if (segmentSelected === prevSegment[0]) {\n        wavesurfer.frame.update({\n          start: prevSegment[0].start,\n          end: prevSegment[0].end\n        });\n      }\n      if (segmentSelected === nextSegment[0]) {\n        wavesurfer.frame.update({\n          start: nextSegment[0].start,\n          end: nextSegment[0].end\n        });\n      }\n      return true;\n    }\n    region.update({\n      start: region.data.prevStart,\n      end: region.data.prevStart\n    });\n    return false;\n  }\n  handleRegionUpdate(region, e) {\n    const {\n      type\n    } = region.data;\n    const {\n      segmentSelected\n    } = this.current;\n    if (type === 'temp' && region !== segmentSelected) {\n      this.setSelectedSegment(region);\n      region.element.classList.add('line-region');\n    }\n  }\n  handleRegionEdit(region) {\n    const {\n      type\n    } = region.data;\n    const {\n      wavesurfer\n    } = this.current;\n    if (type === 'temp') {\n      if (region.end - region.start < this.props.minSegmentLength || this.props.currentPlayMode === 'overallLoop') {\n        this.removeSelectedSegment();\n      } else {\n        region.play();\n        this.insertTempAnchor({\n          start: region.start,\n          end: region.end\n        });\n        wavesurfer.frame.update({\n          start: region.start,\n          end: region.end\n        });\n      }\n    } else if (type === 'anchor') {\n      const {\n        prevStart\n      } = region.data;\n      const {\n        anchors\n      } = this.current;\n      const result = this.handleAnchorDrag(region);\n      if (result === false) return;\n      const dragAnchorIndex = anchors.indexOf(region);\n      this.addHistory('dragAnchor', {\n        dragAnchorIndex,\n        prevStart\n      });\n      this.setSelectedAnchor(region);\n    } else if (type === 'tempAnchor') {\n      this.setTempSegment();\n    }\n  }\n  setTempSegment() {\n    const {\n      segmentSelected,\n      wavesurfer\n    } = this.current;\n    const {\n      leftTempAnchor,\n      rightTempAnchor\n    } = segmentSelected;\n    if (leftTempAnchor.start > rightTempAnchor.start - this.props.minSegmentLength) {\n      leftTempAnchor.update({\n        start: leftTempAnchor.data.prevStart\n      });\n      rightTempAnchor.update({\n        start: rightTempAnchor.data.prevStart\n      });\n    } else {\n      leftTempAnchor.data.prevStart = leftTempAnchor.start;\n      rightTempAnchor.data.prevStart = rightTempAnchor.start;\n      segmentSelected.update({\n        start: leftTempAnchor.start,\n        end: rightTempAnchor.start\n      });\n      wavesurfer.frame.update({\n        start: segmentSelected.start,\n        end: segmentSelected.end\n      });\n    }\n  }\n  handleRegionOut(region) {\n    const {\n      currentPlayMode\n    } = this.props;\n    const {\n      segmentSelected,\n      wavesurfer\n    } = this.current;\n    const {\n      type\n    } = region.data;\n    if (type !== 'line' && type !== 'temp') return;\n    if (segmentSelected === region && currentPlayMode === 'regionLoop') {\n      this.seekCurrentAudio(region.start);\n      this.setCurrentScroll(region.start, 0, true);\n    } else if (segmentSelected === region && currentPlayMode === 'regionPlay') {\n      wavesurfer.pause();\n      this.seekCurrentAudio(region.end);\n    }\n  }\n  handlePlayPause() {\n    this.props.setPlayingState({\n      isPlaying: this.current.wavesurfer.isPlaying()\n    });\n  }\n  handleRegionContextmenu(region, e) {\n    e.preventDefault();\n    if (region.data.type === 'anchor') {\n      const {\n        anchors,\n        segments\n      } = this.current;\n      const i = anchors.indexOf(region);\n      const nextSegment = segments[i + 1];\n      const prevSegment = segments[i];\n      const nextRules = [];\n      const prevRules = [];\n      prevSegment.forEach((line, index) => {\n        prevRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i,\n          lineIndex: index\n        });\n      });\n      nextSegment.forEach((line, index) => {\n        nextRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i + 1,\n          lineIndex: index\n        });\n      });\n      this.mergeSegment(region);\n      const mergeSec = region.start;\n      this.addHistory('mergeSegment', {\n        mergeSec,\n        prevRules,\n        nextRules\n      });\n    }\n  }\n  mergeSegment(region) {\n    const {\n      anchors,\n      segments,\n      anchorSelected,\n      segmentSelected,\n      wavesurfer\n    } = this.current;\n    const i = anchors.indexOf(region);\n    const nextSegment = segments[i + 1];\n    const prevSegment = segments[i];\n    const {\n      start\n    } = prevSegment[0];\n    const {\n      end\n    } = nextSegment[0];\n    const prevRules = [];\n    if (anchorSelected === region) this.removeSelectedAnchor();\n    region.remove();\n    anchors.splice(i, 1);\n    this.props.setSegmentTimestamp({\n      segmentIndex: i,\n      end\n    });\n    prevSegment.forEach((line, index) => {\n      prevRules.push(line.role);\n      line.update({\n        end\n      });\n    });\n    this.props.setCurrentSegment({\n      index: i\n    });\n    this.props.mergeSegmentBackward({\n      segmentIndex: i + 1\n    });\n    nextSegment.forEach(line => {\n      if (prevRules.indexOf(line.role) < 0 && line.role !== 'none') {\n        this.insertLine({\n          start,\n          end,\n          role: line.role,\n          segmentIndex: i,\n          lineIndex: prevSegment.length\n        });\n      }\n      line.remove();\n    });\n    segments.splice(i + 1, 1);\n    if (segmentSelected === prevSegment[0]) {\n      wavesurfer.frame.update({\n        start: prevSegment[0].start,\n        end: prevSegment[0].end\n      });\n    }\n    this.resetRegionTitle();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  setPlayMode(mode) {\n    // none\n  }\n  checkNearbyAnchor(sec) {\n    const {\n      anchors\n    } = this.current;\n    const {\n      minSegmentLength\n    } = this.props;\n    let invalidAnchor = null;\n    let minDistance = null;\n    anchors.forEach(value => {\n      const distance = Math.abs(value.start - sec);\n      if (distance < minSegmentLength) {\n        if (!invalidAnchor || minDistance > distance) {\n          invalidAnchor = value;\n          minDistance = distance;\n        }\n      }\n    });\n    return invalidAnchor;\n  }\n  singleLination(sec) {\n    const {\n      minSegmentLength,\n      annotateDisabled\n    } = this.props;\n    const {\n      wavesurfer,\n      anchors\n    } = this.current;\n    if (sec < minSegmentLength || annotateDisabled) return;\n    if (sec > wavesurfer.getDuration() - minSegmentLength) return;\n    const nearbyAnchor = this.checkNearbyAnchor(sec);\n    if (nearbyAnchor) {\n      const prevStart = nearbyAnchor.start;\n      nearbyAnchor.update({\n        start: sec\n      });\n      this.handleAnchorDrag(nearbyAnchor);\n      const nearbyAnchorIndex = anchors.indexOf(nearbyAnchor);\n      this.addHistory('singleLination-adjust', {\n        nearbyAnchorIndex,\n        prevStart\n      });\n    } else {\n      const splitSegment = this.getSegmentByTime(sec);\n      const splitAnchor = this.splitSegment(splitSegment, sec);\n      const splitAnchorIndex = anchors.indexOf(splitAnchor);\n      this.addHistory('singleLination-split', {\n        splitAnchorIndex\n      });\n    }\n  }\n  getSegmentByTime(sec) {\n    const {\n      segments\n    } = this.current;\n    // eslint-disable-next-line no-restricted-syntax\n    for (const value of segments) {\n      const line = value[0];\n      if (line.start <= sec && line.end >= sec) return value;\n    }\n    return null;\n  }\n  splitSegment(segment, sec, prevRules, nextRules, focusPrevSegment) {\n    const {\n      segments,\n      anchors\n    } = this.current;\n    if (!segment) return;\n    const {\n      end\n    } = segment[0];\n    const i = segments.indexOf(segment);\n    const anchor = this.insertAnchor({\n      start: sec,\n      segmentIndex: i + 1\n    });\n    this.insertSegment({\n      start: sec,\n      end,\n      segmentIndex: i + 1\n    });\n    segment.forEach(line => {\n      line.update({\n        end: sec\n      });\n    });\n    if (prevRules && nextRules) {\n      const arr = [];\n      prevRules.forEach(rule => {\n        arr.push(rule.role);\n      });\n      segment.forEach((line, index) => {\n        if (arr.indexOf(line.role) < 0) this.deleteLine({\n          lineIndex: index,\n          segmentIndex: i\n        });\n      });\n      this.deleteLine({\n        lineIndex: 0,\n        segmentIndex: i + 1\n      });\n      nextRules.forEach(role => {\n        this.insertLine(role);\n      });\n      const splitAnchorIndex = anchors.indexOf(anchor);\n      this.addHistory('singleLination-split', {\n        splitAnchorIndex\n      });\n    }\n    this.props.setSegmentTimestamp({\n      segmentIndex: i,\n      end: sec\n    });\n    this.props.splitSegmentForward({\n      segmentIndex: i,\n      start: sec,\n      end,\n      prevRules,\n      nextRules\n    });\n    this.removeSelectedSegment();\n    this.resetRegionTitle();\n    this.props.setCurrentSegment({\n      index: focusPrevSegment ? i : i + 1\n    });\n    return anchor;\n  }\n  deleteLine(data) {\n    const {\n      segments\n    } = this.current;\n    const {\n      segmentIndex,\n      lineIndex\n    } = data;\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    data.start = line.start;\n    data.end = line.end;\n    data.role = line.role;\n    line.remove();\n    segment.splice(lineIndex, 1);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n  toppingLine(data) {\n    const {\n      segments\n    } = this.current;\n    const {\n      segmentIndex,\n      lineIndex\n    } = data;\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    segment.splice(lineIndex, 1);\n    segment.unshift(line);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n  doubleLination(start, end) {\n    const {\n      minSegmentLength,\n      annotateDisabled\n    } = this.props;\n    const {\n      anchors,\n      segmentSelected\n    } = this.current;\n    if (!start || Number.isNaN(start)) start = segmentSelected.start;\n    if (!end || Number.isNaN(end)) end = segmentSelected.end;\n    if (end - start <= minSegmentLength || annotateDisabled) return;\n    const nearbyLeftAnchor = this.checkNearbyAnchor(start);\n    const nearbyRightAnchor = this.checkNearbyAnchor(end);\n    const prevLeftStart = nearbyLeftAnchor ? nearbyLeftAnchor.start : -1;\n    const prevRightStart = nearbyRightAnchor ? nearbyRightAnchor.start : -1;\n    if (start < minSegmentLength) return;\n    if (end > this.current.wavesurfer.getDuration() - minSegmentLength) return;\n    if (nearbyLeftAnchor && nearbyRightAnchor) {\n      nearbyLeftAnchor.update({\n        start\n      });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      nearbyRightAnchor.update({\n        start: end\n      });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-adjust-adjust', {\n        nearbyLeftAnchorIndex,\n        prevLeftStart,\n        nearbyRightAnchorIndex,\n        prevRightStart\n      });\n    } else if (!nearbyLeftAnchor && nearbyRightAnchor) {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      nearbyRightAnchor.update({\n        start: end\n      });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-split-adjust', {\n        splitLeftAnchorIndex,\n        nearbyRightAnchorIndex,\n        prevRightStart\n      });\n    } else if (nearbyLeftAnchor && !nearbyRightAnchor) {\n      nearbyLeftAnchor.update({\n        start\n      });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      this.addHistory('doubleLination-adjust-split', {\n        nearbyLeftAnchorIndex,\n        prevLeftStart,\n        splitRightAnchorIndex\n      });\n    } else {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end, null, null, true);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      this.addHistory('doubleLination-split-split', {\n        splitLeftAnchorIndex,\n        splitRightAnchorIndex\n      });\n    }\n  }\n  handleKeyDown(e) {\n    if (window.disableLongAudioHotKeys) return;\n    if (isInput()) return;\n    if (isAnnotationReadonly(this.props.toolMode)) return;\n    // if (this.props.toolMode === 'QA_RO') return;\n    if (e.keyCode === 83) {\n      // s\n      const sec = this.getCursorTime();\n      if (sec < 0) return;\n      this.singleLination(sec);\n    } else if (e.keyCode === 68) {\n      // d\n      const {\n        segmentSelected\n      } = this.current;\n      if (segmentSelected && segmentSelected.data.type === 'temp') this.doubleLination();\n    } else if (e.keyCode === 188) {\n      // , || <\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(-ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', {\n          step: -ANCHOR_MOVEMENT_STEP\n        });\n      } else {\n        this.forwardAnchor();\n      }\n    } else if (e.keyCode === 190) {\n      // . | >\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', {\n          step: ANCHOR_MOVEMENT_STEP\n        });\n      } else {\n        this.backwardAnchor();\n      }\n    } else if (e.ctrlKey && e.keyCode === 90) {\n      // z\n      this.recallHistory('undo');\n    } else if (e.ctrlKey && e.keyCode === 89) {\n      // y\n      this.recallHistory('redo');\n    } else if ((e.keyCode === 8 || e.keyCode === 46) && e.ctrlKey) {\n      // ctrl + delete/backspace\n      this.clearAll();\n    }\n  }\n  backwardAnchor() {\n    const {\n      anchorSelected,\n      wavesurfer,\n      anchors\n    } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start + ANCHOR_MOVEMENT_STEP >= wavesurfer.getDuration()) return;\n    anchorSelected.update({\n      start: anchorSelected.start + ANCHOR_MOVEMENT_STEP\n    });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', {\n        trimAnchorIndex,\n        prevStart: anchorSelected.start - ANCHOR_MOVEMENT_STEP\n      });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n  forwardAnchor() {\n    const {\n      anchorSelected,\n      anchors\n    } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start - ANCHOR_MOVEMENT_STEP <= 0) return;\n    anchorSelected.update({\n      start: anchorSelected.start - ANCHOR_MOVEMENT_STEP\n    });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', {\n        trimAnchorIndex,\n        prevStart: anchorSelected.start + ANCHOR_MOVEMENT_STEP\n      });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n  handleRegionIn(region) {\n    const {\n      currentPlayMode,\n      currentSegment\n    } = this.props;\n    const {\n      wavesurfer\n    } = this.current;\n    const {\n      type\n    } = region.data;\n    if (type !== 'line') return;\n    if (currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const currentTime = wavesurfer.getCurrentTime();\n      if (segmentIndex === currentSegment) return;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({\n        index: segmentIndex,\n        start: currentTime\n      });\n    }\n  }\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          // partialRender: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [RegionsPlugin.create(), CursorPlugin.create({\n            width: '1px',\n            height: '10px',\n            container: this.container.audioContainer[i],\n            color: defaultColor.defaultGreen,\n            showTime: true,\n            opacity: 1,\n            customShowTimeStyle: {\n              color: defaultColor.defaultGreen,\n              fontSize: '14px',\n              paddingLeft: '5px',\n              position: 'absolute',\n              bottom: '3px'\n            },\n            formatTimeCallback: sec => {\n              this.setState({\n                cursorTime: sec\n              });\n              return formatTimestamp(sec);\n            }\n          }), TimelinePlugin.create({\n            container: this.container.timeline[i],\n            primaryFontColor: defaultColor.defaultWhite,\n            secondaryFontColor: defaultColor.defaultWhite,\n            primaryColor: defaultColor.defaultWhite,\n            secondaryColor: defaultColor.defaultWhite,\n            fontSize: '10',\n            notchPercentHeight: 30,\n            timeInterval,\n            primaryLabelInterval,\n            secondaryLabelInterval,\n            formatTimeCallback\n          }), MinimapPlugin.create({\n            container: this.container.minimap[i]\n          })]\n        });\n        urls[i] = this.container.videoContainer[i];\n        this.wavesurfers[i].on('ready', () => {\n          this.wavesurfers[i].pause();\n          this.wavesurfers[i].enableDragSelection({\n            color: hexToRgba(defaultColor.defaultRed, defaultColor.defaultAlpha),\n            drag: false,\n            resize: false,\n            data: {\n              type: 'temp'\n            },\n            formatTimeCallback: () => ''\n          });\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            console.log('Error', e);\n            this.props.setErrorMsg({\n              errorMsg: e === null || e === void 0 ? void 0 : e.toString()\n            });\n            return;\n          }\n          this.props.setLoading(false);\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (!i) {\n            this.setNewVideo();\n            this.setSelectedSegment(this.current.segments[0][0]);\n          }\n          if (i === 0) this.addWindowEvent();\n          this.wavesurfers[i].on('play', e => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', e => this.handlePlayPause());\n          this.wavesurfers[i].on('region-updated', (region, e) => this.handleRegionUpdate(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (region, e) => this.handleRegionContextmenu(region, e));\n          this.wavesurfers[i].on('region-update-end', (region, e) => this.handleRegionEdit(region));\n          this.wavesurfers[i].on('region-out', (region, e) => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', (region, e) => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.wavesurfers[i].on('redraw', this.props.setXScroll);\n          this.props.setVideoValid({\n            index: i\n          });\n          this.props.updateVideoInfo({\n            index: i,\n            duration: this.wavesurfers[i].getDuration()\n          });\n        });\n        this.wavesurfers[i].on('error', error => {\n          notification.error({\n            message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}`\n          });\n          this.props.setAudioErrorMsg({\n            index: i,\n            errorMsg: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1} ${urls[i].src} ${error}`\n          });\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.wavesurfers[i].destroy();\n          if (i === size - 1) {\n            this.props.setLoading(false);\n          }\n        });\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const {\n          zoom,\n          wavesurfer\n        } = this.current;\n        if (!cursorHelper) {\n          var _wavesurfer$cursor;\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer === null || wavesurfer === void 0 ? void 0 : (_wavesurfer$cursor = wavesurfer.cursor) === null || _wavesurfer$cursor === void 0 ? void 0 : _wavesurfer$cursor.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const {\n          offsetWidth\n        } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = totalWidth / duration * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n  addWindowEvent() {\n    window.addEventListener('keydown', e => this.handleKeyDown(e));\n    window.addEventListener('resize', e => this.setCurrentZoom());\n  }\n\n  // eslint-disable-next-line react/no-deprecated\n  componentWillMount() {\n    this.props.getWavesurfers({\n      wavesurfers: this\n    });\n  }\n  render() {\n    return null;\n  }\n}\nconst mapStateToProps = state => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  keyAttribute: state.keyAttribute,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw,\n  styleConfig: state.styleConfig\n});\nconst mapDispatchToProps = {\n  debug,\n  getWavesurfers,\n  setPlayingState,\n  setSegmentTimestamp,\n  mergeSegmentBackward,\n  splitSegmentForward,\n  setVideoValid,\n  setVideoZoom,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  removeSegment,\n  setSegments,\n  parseSegments,\n  setErrorMsg,\n  setAudioErrorMsg,\n  moveSegmentInBatch,\n  updateVideoInfo,\n  setLoading\n};\nexport default connect(mapStateToProps, mapDispatchToProps, null, {\n  forwardRef: true\n})(WavesurferComp);","map":{"version":3,"names":["React","ReactDOM","hexToRgba","notification","Modal","cloneDeep","WaveSurfer","TimelinePlugin","RegionsPlugin","CursorPlugin","MinimapPlugin","connect","v4","uuid","defaultColor","formatTimestamp","translate","triggerForm","StyleConfigMode","getConfigColor","HandleIcon","debug","getWavesurfers","mergeSegmentBackward","setPlayingState","setSegmentTimestamp","splitSegmentForward","setVideoValid","setVideoZoom","deleteLine","pushLine","setLineRole","removeSegment","setSegments","parseSegments","setErrorMsg","setAudioErrorMsg","moveSegmentInBatch","updateVideoInfo","setLoading","createLine","createSegment","isInput","isAnnotationReadonly","timeInterval","primaryLabelInterval","secondaryLabelInterval","formatTimeCallback","i18n","ANCHOR_MOVEMENT_STEP","WavesurferComp","Component","constructor","insertLine","data","_styleConfig$groups","start","end","role","videoIndex","segmentIndex","lineIndex","attributes","segments","regions","ontology","styleConfig","props","Number","isNaN","parseInt","current","wavesurfer","wavesurfers","parseFloat","getDuration","configColor","groups","length","color","get","defaultWhite","defaultAlpha","item","resize","drag","type","region","addRegion","element","classList","add","mark","document","createElement","className","appendChild","title","innerText","toFixed","splice","filter","line","forEach","index","array","height","top","style","renderSegments","videos","results","anchors","v","i","ready","clearRegions","initRegion","setNewVideo","setSelectedSegment","undoList","redoList","container","minimap","waveform","timeline","audioContainer","videoContainer","zoom","segmentSelected","anchorSelected","undoLock","redoLock","state","cursorTime","currentSegments","shouldComponentUpdate","nextProps","isLoadedAlaw","componentDidUpdate","initWaveSurfer","clearAll","confirm","content","autoFocusButton","okText","okType","cancelText","onOk","currentSegment","afterSegments","id","text","qaChecked","undefined","qaComment","qaReason","addHistory","after","currentIndex","before","recallList","prev","trimAnchor","push","shift","recallHistory","action","recallItem","pop","singleLination","sec","doubleLination","nearbyAnchorIndex","prevStart","nearbyAnchor","update","handleAnchorDrag","splitAnchorIndex","splitAnchor","mergeSegment","nearbyLeftAnchorIndex","prevLeftStart","nearbyRightAnchorIndex","prevRightStart","nearbyLeftAnchor","nearbyRightAnchor","splitRightAnchorIndex","splitRightAnchor","splitLeftAnchorIndex","splitLeftAnchor","dragAnchorIndex","dragAnchor","trimAnchorIndex","mergeSec","prevRules","nextRules","splitSegment","getSegmentByTime","step","bulkMovementDirection","moveRegionsInBatch","setCurrentSegment","isDestroyed","console","error","setCurrentZoom","setCurrentVideo","newVideoIndex","pause","removeSelectedSegment","removeSelectedAnchor","remove","newZoom","duration","getCursorTime","currentTime","getCurrentTime","offsetWidth","offsetLeft","cursor","totalWidth","pxPerSec","setCurrentScroll","componentDidMount","setInterval","isPlaying","timestamp","componentWillUnmount","Array","isArray","c","removeEventListener","updateMeasurement","destTime","boundaryCheck","scrollLeft","lastChild","minPxPerSec","params","scrollTime","drawer","recenter","rightBoundaryTime","leftBoundaryTime","insertSegment","insertTempAnchor","items","leftTempAnchor","rightTempAnchor","handle","render","width","viewBox","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","hanlde","insertAnchor","toolMode","frame","_this$current$segment","_this$current$segment2","currentPlayMode","seekCurrentAudio","play","setLineColor","_styleConfig$groups2","segment","prevRole","mode","e","setSegmentColor","lines","roleColor","rgba","getAudioContainer","getVideoContainer","pauseVideo","playVideo","forwardVideo","skipForward","backwardVideo","skipBackward","segs","lineConfig","keyAttribute","segmentConfig","segmentConfigValidKeys","fields","map","value","name","lineConfigValidKeys","updatedValues","updateLineValues","updateSegmentValues","ontologyValidKeys","key","startNum","Error","JSON","stringify","endNum","log","Object","keys","indexOf","arr","MIN_LENGTH","minSegmentLength","sort","a","b","currentEnd","_this$props$styleConf","getSegmentByRegion","backend","seekTo","handleRegionClick","stopPropagation","altKey","ctrlKey","setSelectedAnchor","setCurrentSpeed","speed","_this$current$wavesur","setPlaybackRate","resetRegionTitle","min","max","list","__moveRegion","anchor","leftBoundary","rightBoundary","prevSegment","nextSegment","handleRegionUpdate","handleRegionEdit","result","setTempSegment","handleRegionOut","handlePlayPause","handleRegionContextmenu","preventDefault","setPlayMode","checkNearbyAnchor","invalidAnchor","minDistance","distance","Math","abs","annotateDisabled","focusPrevSegment","rule","li","toppingLine","unshift","splitLeftSegment","splitRightSegment","handleKeyDown","window","disableLongAudioHotKeys","keyCode","forwardAnchor","backwardAnchor","handleRegionIn","initMiniMap","wave","getElementsByTagName","size","urls","loaded","create","autoCenter","normalize","loopSelection","scrollParent","backgroundColor","defaultGray","waveColor","darkGray","progressColor","cursorColor","defaultRed","pixelRatio","maxCanvasWidth","plugins","defaultGreen","showTime","opacity","customShowTimeStyle","fontSize","paddingLeft","position","bottom","setState","primaryFontColor","secondaryFontColor","primaryColor","secondaryColor","notchPercentHeight","on","enableDragSelection","errorMsg","toString","addWindowEvent","un","setXScroll","message","src","destroy","addEventListener","load","cursorHelper","getElementsByClassName","selectedMeasurement","_wavesurfer$cursor","left","componentWillMount","mapStateToProps","currentVideo","spaceLine","mapDispatchToProps","forwardRef"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/WavesurferComp/WavesurferComp.jsx"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport hexToRgba from 'hex-to-rgba';\nimport { notification, Modal } from 'antd';\nimport { cloneDeep } from 'lodash';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { defaultColor, formatTimestamp, translate, triggerForm, StyleConfigMode, getConfigColor } from '../../constants';\nimport HandleIcon from '../common/Icons/HandleIcon';\nimport {\n  debug,\n  getWavesurfers,\n  mergeSegmentBackward,\n  setPlayingState,\n  setSegmentTimestamp,\n  splitSegmentForward,\n  setVideoValid,\n  setVideoZoom,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  removeSegment,\n  setSegments,\n  parseSegments,\n  setErrorMsg,\n  setAudioErrorMsg,\n  moveSegmentInBatch,\n  updateVideoInfo,\n  setLoading,\n} from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { timeInterval, primaryLabelInterval, secondaryLabelInterval, formatTimeCallback } from '../utils/TimelineUtil';\nimport i18n from '../../locales';\n\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\n\nclass WavesurferComp extends React.Component {\n  constructor() {\n    super();\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null, // Minimap container\n      waveform: null, // Waveform container\n      timeline: null, // Timeline container\n      audioContainer: null, // Cursor container\n      videoContainer: null, // Video container\n    };\n    this.regions = {\n      segments: [],\n      anchors: [],\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      segments: null,\n      anchors: null,\n      segmentSelected: null,\n      anchorSelected: null,\n      undoList: null,\n      redoList: null,\n      undoLock: false,\n      redoLock: false,\n    };\n    this.state = {\n      cursorTime: 0, // seconds\n    };\n  }\n\n  get currentSegments() {\n    return this.props.results[this.current.videoIndex];\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n\n  componentDidUpdate() {\n    this.initWaveSurfer();\n  }\n\n  clearAll() {\n    Modal.confirm({\n      className: 'modal-root',\n      title: i18n.translate('COMMON_CLAER_CONFIRM_TITLE'),\n      content: i18n.translate('COMMON_CLAER_CONFIRM_DESC'),\n      autoFocusButton: null,\n      okText: i18n.translate('COMMON_CLAER_CONFIRM_SURE'),\n      okType: 'danger',\n      cancelText: i18n.translate('COMMON_CLAER_CONFIRM_CANCEL'),\n      onOk: () => {\n        const { currentSegment } = this.props;\n        const { videoIndex } = this.current;\n        const segments = cloneDeep(this.currentSegments);\n        const afterSegments = [{\n          id: uuid(),\n          start: 0,\n          end: segments[segments.length - 1].end,\n          attributes: {},\n          content: [{ role: 'none', text: '', attributes: {} }],\n          qaChecked: undefined,\n          qaComment: '',\n          qaReason: null,\n        }];\n        this.props.setSegments({ videoIndex, segments: afterSegments });\n        this.wavesurfers[videoIndex].clearRegions();\n        this.regions.segments[videoIndex] = [];\n        this.regions.anchors[videoIndex] = [];\n        this.current = {\n          ...this.current,\n          anchorSelected: null,\n          anchors: null,\n          segmentSelected: null,\n          segments: null,\n          videoIndex: 0,\n        };\n        const currentSegments = this.parseSegments(videoIndex, afterSegments);\n        this.initRegion(videoIndex, currentSegments);\n        this.current.segments = this.regions.segments[videoIndex];\n        this.current.anchors = this.regions.anchors[videoIndex];\n        this.addHistory('clear_all', {\n          after: {\n            videoIndex,\n            currentIndex: 0,\n            segments: afterSegments\n          },\n          before: {\n            videoIndex,\n            currentIndex: currentSegment,\n            segments\n          },\n        });\n      },\n    });\n  }\n\n  addHistory(type, data) {\n    const { undoList, undoLock, redoLock, redoList } = this.current;\n    let recallList;\n    if (undoLock) recallList = redoList;\n    else if (redoLock) recallList = undoList;\n    else {\n      recallList = undoList;\n      this.current.redoList = [];\n    }\n    if (type === 'trimAnchor' && recallList.length) {\n      const prev = recallList[recallList.length - 1];\n      if (prev.type === 'trimAnchor' && prev.data.trimAnchor === data.trimAnchor) return;\n    }\n    recallList.push({ type, data });\n    if (recallList.length > 50) recallList.shift();\n  }\n\n  recallHistory(action) {\n    const { undoList, redoList, anchors } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) return;\n    if (action === 'undo') this.current.undoLock = true; // lock\n    if (action === 'redo') this.current.redoLock = true;\n    const recallItem = recallList.pop();\n    const { type, data } = recallItem;\n    switch (type) {\n      case 'singleLination-recall':\n        this.singleLination(data.sec); // addHistory inside\n        break;\n      case 'doubleLination-recall':\n        this.doubleLination(data.start, data.end); // addHistory inside\n        break;\n      case 'singleLination-adjust':\n        {\n          const { nearbyAnchorIndex, prevStart } = data;\n          const nearbyAnchor = anchors[nearbyAnchorIndex];\n          const sec = nearbyAnchor.start;\n          nearbyAnchor.update({ start: prevStart });\n          this.handleAnchorDrag(nearbyAnchor);\n          this.addHistory('singleLination-recall', { sec });\n        }\n        break;\n      case 'singleLination-split':\n        {\n          const { splitAnchorIndex } = data;\n          const splitAnchor = anchors[splitAnchorIndex];\n          const sec = splitAnchor.start;\n          this.mergeSegment(splitAnchor);\n          this.addHistory('singleLination-recall', { sec });\n        }\n        break;\n      case 'doubleLination-adjust-adjust':\n        {\n          const { nearbyLeftAnchorIndex, prevLeftStart, nearbyRightAnchorIndex, prevRightStart } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const { start } = nearbyLeftAnchor;\n          const end = nearbyRightAnchor.start;\n          nearbyLeftAnchor.update({ start: prevLeftStart });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          nearbyRightAnchor.update({ start: prevRightStart });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'doubleLination-adjust-split':\n        {\n          const { nearbyLeftAnchorIndex, prevLeftStart, splitRightAnchorIndex } = data;\n          const nearbyLeftAnchor = anchors[nearbyLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const { start } = nearbyLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          nearbyLeftAnchor.update({ start: prevLeftStart });\n          this.handleAnchorDrag(nearbyLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'doubleLination-split-adjust':\n        {\n          const { splitLeftAnchorIndex, nearbyRightAnchorIndex, prevRightStart } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const nearbyRightAnchor = anchors[nearbyRightAnchorIndex];\n          const { start } = splitLeftAnchor.start;\n          const end = nearbyRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          nearbyRightAnchor.update({ start: prevRightStart });\n          this.handleAnchorDrag(nearbyRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'doubleLination-split-split':\n        {\n          const { splitLeftAnchorIndex, splitRightAnchorIndex } = data;\n          const splitLeftAnchor = anchors[splitLeftAnchorIndex];\n          const splitRightAnchor = anchors[splitRightAnchorIndex];\n          const { start } = splitLeftAnchor.start;\n          const end = splitRightAnchor.start;\n          this.mergeSegment(splitLeftAnchor);\n          this.mergeSegment(splitRightAnchor);\n          this.addHistory('doubleLination-recall', { start, end });\n        }\n        break;\n      case 'pushLine':\n        this.props.deleteLine(data); // addHistory inside\n        break;\n      case 'deleteLine':\n        this.props.pushLine(data); // addHistory inside\n        break;\n      case 'dragAnchor':\n        {\n          const { dragAnchorIndex, prevStart } = data;\n          const dragAnchor = anchors[dragAnchorIndex];\n          const { start } = dragAnchor;\n          dragAnchor.update({ start: prevStart });\n          this.handleAnchorDrag(dragAnchor);\n          this.addHistory('dragAnchor', { dragAnchorIndex, prevStart: start });\n        }\n        break;\n      case 'trimAnchor':\n        {\n          const { trimAnchorIndex, prevStart } = data;\n          const trimAnchor = anchors[trimAnchorIndex];\n          const { start } = trimAnchor;\n          trimAnchor.update({ start: prevStart });\n          this.handleAnchorDrag(trimAnchor);\n          this.addHistory('trimAnchor', { trimAnchorIndex, prevStart: start });\n        }\n        break;\n      case 'mergeSegment':\n        {\n          const { mergeSec, prevRules, nextRules } = data;\n          const splitSegment = this.getSegmentByTime(mergeSec);\n          this.splitSegment(splitSegment, mergeSec, prevRules, nextRules);\n        }\n        break;\n      case 'setLineColor':\n        this.props.setLineRole(data); // addHistory inside\n        break;\n      case 'bulkMovement': {\n        const { step } = data;\n        const bulkMovementDirection = action === 'redo' ? 1 : -1;\n        this.moveRegionsInBatch(bulkMovementDirection * step);\n        this.addHistory('bulkMovement', { step: -bulkMovementDirection * step });\n        break;\n      }\n      case 'clear_all': {\n        const { before, after } = data;\n        const { videoIndex, currentIndex, segments } = action === 'undo' ? before : after;\n        this.wavesurfers[videoIndex].clearRegions();\n        this.props.setSegments({ videoIndex, segments });\n        this.regions = {\n          segments: [],\n          anchors: [],\n        };\n\n        this.regions.segments[videoIndex] = [];\n        this.regions.anchors[videoIndex] = [];\n        this.current = {\n          ...this.current,\n          anchorSelected: null,\n          anchors: null,\n          segmentSelected: null,\n          segments: null,\n          videoIndex: 0,\n        };\n        const currentSegments = this.parseSegments(videoIndex, segments);\n        this.initRegion(videoIndex, currentSegments);\n        this.current.segments = this.regions.segments[videoIndex];\n        this.current.anchors = this.regions.anchors[videoIndex];\n        this.props.setCurrentSegment({ index: currentIndex });\n        break;\n      }\n      default:\n        break;\n    }\n    if (action === 'undo') this.current.undoLock = false; // lock\n    if (action === 'redo') this.current.redoLock = false;\n  }\n\n  // Called after currentVideo change\n  setNewVideo() {\n    const { videoIndex } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.segments = this.regions.segments[videoIndex];\n    this.current.anchors = this.regions.anchors[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n\n  setCurrentVideo(newVideoIndex) {\n    const { videoIndex } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.removeSelectedSegment();\n    this.removeSelectedAnchor();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n\n  removeSelectedAnchor() {\n    const { anchorSelected } = this.current;\n    if (!anchorSelected) return;\n    anchorSelected.mark.classList.remove('anchor-mark-selected');\n    this.current.anchorSelected = null;\n  }\n\n  setCurrentZoom(newZoom) {\n    if (newZoom) this.current.zoom = newZoom;\n    const { zoom, videoIndex, wavesurfer } = this.current;\n    const duration = this.wavesurfers[videoIndex].getDuration();\n    const cursorTime = this.getCursorTime();\n    const currentTime = wavesurfer.getCurrentTime();\n    const { offsetWidth } = wavesurfer.container;\n    const { offsetLeft } = wavesurfer.cursor.cursor;\n    const totalWidth = offsetWidth * zoom;\n    const pxPerSec = totalWidth / duration;\n    wavesurfer.zoom(pxPerSec);\n    this.setCurrentScroll(\n      cursorTime < 0 ? currentTime : cursorTime,\n      cursorTime < 0 ? offsetWidth / 2 : offsetLeft,\n      false,\n    );\n  }\n\n  componentDidMount() {\n    // Record currentTime and locate currentCursor\n    setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const { wavesurfer } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n  }\n\n  componentWillUnmount() {\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach((c) => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n\n  setCurrentScroll(destTime, offsetLeft, boundaryCheck) {\n    offsetLeft = offsetLeft || 0;\n    destTime = destTime || 0;\n    const { wavesurfer } = this.current;\n    const { scrollLeft } = wavesurfer.container.lastChild;\n    const { offsetWidth } = wavesurfer.container;\n    const { minPxPerSec } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) wavesurfer.drawer.recenter(scrollTime / duration);\n    else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) wavesurfer.drawer.recenter(scrollTime / duration);\n    }\n  }\n\n  insertLine = (data) => {\n    // eslint-disable-next-line prefer-const\n    let { start, end, role, videoIndex, segmentIndex, lineIndex, attributes } = data;\n    const { segments } = this.regions;\n    const { ontology, styleConfig } = this.props;\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    const wavesurfer = this.wavesurfers[videoIndex];\n    lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? 0 : lineIndex;\n    end = Number.isNaN(parseFloat(end)) ? wavesurfer.getDuration() : end;\n    if (!segments[videoIndex]) segments[videoIndex] = [];\n    if (!segments[videoIndex][segmentIndex]) segments[videoIndex][segmentIndex] = [];\n    role = role || 'none';\n    let configColor = '';\n    if (attributes && styleConfig?.groups?.length > 0) {\n      configColor = getConfigColor(attributes, styleConfig.groups);\n    }\n    const color = hexToRgba(\n      configColor || ontology.get(role) || defaultColor.defaultWhite,\n      (role === 'none' && !configColor) ? 0 : defaultColor.defaultAlpha\n    );\n    const item = {\n      start,\n      end,\n      color,\n      resize: false,\n      drag: false,\n      data: { type: 'line' },\n      formatTimeCallback: () => '',\n    };\n    const region = wavesurfer.addRegion(item);\n    region.element.classList.add('line-region');\n    const mark = document.createElement('div');\n    mark.className = 'line-mark';\n    region.element.appendChild(mark);\n    const title = document.createElement('div');\n    title.className = 'line-title';\n    title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(region.end - region.start).toFixed(3)}s (${formatTimestamp(region.start)}~${formatTimestamp(region.end)})` : '';\n    mark.appendChild(title);\n    region.title = title;\n    region.role = role;\n    segments[videoIndex][segmentIndex].splice(lineIndex, 0, region);\n    segments[videoIndex][segmentIndex].filter((line) => !!line?.element).forEach((line, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      line.element.style.height = `${height}%`;\n      line.element.style.top = `${top}%`;\n    });\n    return region;\n  };\n\n  insertSegment(data) {\n    const { start, end, segmentIndex } = data;\n    let { videoIndex } = data;\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    const { segments } = this.regions;\n    if (!segments[videoIndex]) segments[videoIndex] = [];\n    segments[videoIndex].splice(segmentIndex, 0, []);\n    this.insertLine({ start, end, videoIndex, segmentIndex });\n    return segments[videoIndex][segmentIndex];\n  }\n\n  insertTempAnchor(data) {\n    const { segmentSelected } = this.current;\n    const { start, end } = data;\n    const items = [{\n      start,\n      resize: false,\n      drag: true,\n      data: { type: 'tempAnchor', prevStart: start },\n      formatTimeCallback: () => '',\n    }, {\n      start: end,\n      resize: false,\n      drag: true,\n      data: { type: 'tempAnchor', prevStart: end },\n    }];\n    const { wavesurfer } = this.current;\n    const regions = new Array(2);\n    regions[0] = wavesurfer.addRegion(items[0]);\n    regions[1] = wavesurfer.addRegion(items[1]);\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.leftTempAnchor = regions[0];\n    // eslint-disable-next-line prefer-destructuring\n    segmentSelected.rightTempAnchor = regions[1];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const region of regions) {\n      region.element.classList.add('anchor-region');\n      const handle = document.createElement('div');\n      handle.className = 'anchor-handle';\n      ReactDOM.render((<HandleIcon style={{ height: '100%', width: '100%' }} viewBox=\"0, 10, 16, 16\" />), handle);\n      region.element.appendChild(handle);\n      region.hanlde = handle;\n      const mark = document.createElement('div');\n      mark.className = 'anchor-mark-temp';\n      region.element.appendChild(mark);\n      region.mark = mark;\n    }\n  }\n\n  insertAnchor(data) {\n    // eslint-disable-next-line prefer-const\n    let { start, videoIndex, segmentIndex } = data;\n    const { toolMode } = this.props;\n    const { anchors } = this.regions;\n\n    videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? this.current.videoIndex : videoIndex;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    if (segmentIndex === 0) return;\n    if (!anchors[videoIndex]) anchors[videoIndex] = [];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const item = {\n      start,\n      resize: false,\n      drag: !isAnnotationReadonly(toolMode), // toolMode !== 'QA_RO',\n      data: { type: 'anchor', prevStart: start },\n      formatTimeCallback: () => '',\n    };\n    const region = wavesurfer.addRegion(item);\n    anchors[videoIndex].splice(segmentIndex - 1, 0, region);\n    region.element.classList.add('anchor-region');\n    const handle = document.createElement('div');\n    handle.className = 'anchor-handle';\n    if (isAnnotationReadonly(toolMode)) handle.classList.add('anchor-handle-lock');\n    ReactDOM.render((<HandleIcon style={{ height: '100%', width: '100%' }} viewBox=\"0, 10, 16, 16\" />), handle);\n    region.element.appendChild(handle);\n    region.hanlde = handle;\n    const mark = document.createElement('div');\n    mark.className = 'anchor-mark';\n    region.element.appendChild(mark);\n    region.mark = mark;\n    return region;\n  }\n\n  removeSelectedSegment() {\n    const { segmentSelected, anchorSelected } = this.current;\n    if (anchorSelected && anchorSelected.data.type === 'tempAnchor') this.removeSelectedAnchor();\n    if (segmentSelected && segmentSelected.data.type === 'temp') {\n      segmentSelected.remove();\n      if (segmentSelected.leftTempAnchor) segmentSelected.leftTempAnchor.remove();\n      if (segmentSelected.rightTempAnchor) segmentSelected.rightTempAnchor.remove();\n    }\n    this.current.segmentSelected = null;\n  }\n\n  setSelectedSegment(region) {\n    this.removeSelectedSegment();\n    if (region.data.type === 'line') this.current.wavesurfer.frame.update({ start: region.start, end: region.end });\n    this.current.segmentSelected = region;\n  }\n\n  setCurrentSegment(currentSegment, start) {\n    const { currentPlayMode } = this.props;\n    const { wavesurfer } = this.current;\n    const region = this.current.segments?.[currentSegment]?.[0];\n    start = start || region?.start;\n    this.setSelectedSegment(region);\n    this.seekCurrentAudio(start);\n    this.setCurrentScroll(start, 0, true);\n    if (currentPlayMode !== 'overallLoop') {\n      wavesurfer.play();\n    }\n  }\n\n  setLineColor(videoIndex, segmentIndex, lineIndex, role) {\n    try {\n      const { results, styleConfig } = this.props;\n      const segment = results[videoIndex][segmentIndex];\n      const line = this.regions.segments[videoIndex][segmentIndex][lineIndex];\n      const prevRole = line.role;\n      let color = '';\n      if (styleConfig?.groups?.length > 0) {\n        const attributes = styleConfig?.mode === StyleConfigMode.line ? line.attributes : segment.attributes;\n        color = getConfigColor(attributes, styleConfig.groups);\n      }\n      if (!color) {\n        color = this.props.ontology.get(role);\n      }\n\n      line.update({ color: hexToRgba(color, !color ? 0 : defaultColor.defaultAlpha) });\n      line.role = role;\n      this.addHistory('setLineColor', { videoIndex, segmentIndex, lineIndex, role: prevRole });\n    } catch (e) { console.error('Line region not found'); }\n  }\n\n  setSegmentColor(videoIndex, segmentIndex, lines, color) {\n    const segment = this.regions.segments[videoIndex][segmentIndex];\n    for (let i = 0; i < lines.length; i += 1) {\n      const lineIndex = lines[i];\n      const line = segment[lineIndex];\n      const roleColor = this.props.ontology.get(line.role);\n      const rgba = hexToRgba(\n        color || roleColor || defaultColor.defaultWhite,\n        !color && line.role === 'none' ? 0 : defaultColor.defaultAlpha\n      );\n      if (line && rgba !== line.color) {\n        line.update({ color: rgba });\n      }\n    }\n  }\n\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) this.initWaveSurfer();\n  }\n\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) this.initWaveSurfer();\n  }\n\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n\n  playVideo() {\n    const { wavesurfer, segmentSelected } = this.current;\n    if (segmentSelected && wavesurfer.getCurrentTime() > segmentSelected.end - ANCHOR_MOVEMENT_STEP) {\n      this.seekCurrentAudio(segmentSelected.start);\n      this.setCurrentScroll(segmentSelected.start, 0, true);\n    }\n    wavesurfer.play();\n  }\n\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n\n  parseSegments(videoIndex, segs) {\n    const { results, ontology, lineConfig, keyAttribute, segmentConfig } = this.props;\n    const segments = Array.isArray(segs) ? segs : results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map((value) => value.name);\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map((value) => value.name);\n    const { updatedValues: updateLineValues } = triggerForm(lineConfig, {});\n    const { updatedValues: updateSegmentValues } = triggerForm(segmentConfig, {});\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start\n      if (!segment.start && segment.start !== 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_NULL')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end === null || segment.end === undefined) {\n        segment.end = duration;\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      segment.attributes = {\n        ...updateSegmentValues,\n        ...segment.attributes,\n      };\n      Object.keys(segment.attributes).forEach((key) => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = {\n          ...updateLineValues,\n          ...line.attributes,\n        };\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach((key) => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n    }\n    // segments = segments.filter(segment => segment.isValid);\n    const MIN_LENGTH = this.props.minSegmentLength;\n    segments.sort((a, b) => {\n      if (a.start < b.start + MIN_LENGTH && a.start > b.start - MIN_LENGTH) {\n        if (a.end == null) return -1;\n        if (b.end == null) return 1;\n        return a.end - b.end;\n      }\n      return a.start - b.start;\n    });\n    let currentEnd = 0;\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      if (segment.end - segment.start <= MIN_LENGTH && i < segments.length - 1) {\n        segments[i + 1].start = segment.start;\n        segments.splice(i, 1);\n        i -= 1;\n      } else if ((segment.start > currentEnd - MIN_LENGTH) && (segment.start < currentEnd + MIN_LENGTH) && (segment.end > currentEnd || !segment.end)) {\n        segments[i].start = currentEnd;\n        currentEnd = segment.end;\n      } else if (segment.start < currentEnd - MIN_LENGTH || currentEnd == null) {\n        // throw new Error(`${translate('PAYLOAD_ERROR_OVERLAP_SEGMENT')} ${JSON.stringify(segment)} start=${segment.start} currentEnd=${currentEnd} min=${MIN_LENGTH}`);\n        segments.splice(i, 1);\n        i -= 1;\n      } else if (segment.start > currentEnd + MIN_LENGTH) {\n        segments.splice(i, 0, createSegment(currentEnd, segment.start, segmentConfig, lineConfig));\n        currentEnd = segment.end;\n        i += 1;\n      }\n      if (i === segments.length - 1) {\n        if (segment.end < duration) {\n          if (duration - segment.end <= MIN_LENGTH) {\n            segment.end = duration;\n          } else {\n            segments.push(createSegment(segment.end, duration, segmentConfig, lineConfig));\n          }\n        }\n      }\n    }\n    // videoIndex, segments\n    this.props.parseSegments({\n      videoIndex,\n      segments,\n    });\n    return segments;\n  }\n\n  initRegion(videoIndex, segments) {\n    const wavesurfer = this.wavesurfers[videoIndex];\n    wavesurfer.frame = wavesurfer.addRegion({\n      start: segments[0].start,\n      end: segments[0].end,\n      color: 'rgba(0,0,0,0)',\n      resize: false,\n      drag: false,\n    });\n    wavesurfer.frame.element.classList.add('segment-frame');\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      segment.content.forEach((line, lineIndex) => {\n        const attributes = this.props.styleConfig?.mode === StyleConfigMode.segment ? segment.attributes : line.attributes;\n        this.insertLine({\n          videoIndex,\n          segmentIndex,\n          lineIndex,\n          role: line.role,\n          start: segment.start,\n          end: segment.end,\n          attributes,\n        });\n      });\n      this.insertAnchor({\n        videoIndex,\n        segmentIndex,\n        start: segment.start,\n      });\n    }\n  }\n\n  getSegmentByRegion(region) {\n    let segmentIndex = -1;\n    const { segments } = this.current;\n    segments.forEach((segment, index) => {\n      if (segment.indexOf(region) >= 0) segmentIndex = index;\n    });\n    return segmentIndex;\n  }\n\n  seekCurrentAudio(currentTime = 0) {\n    const { wavesurfer } = this.current;\n    const duration = wavesurfer.getDuration();\n    /*\n    currentTime = currentTime || 0;\n    let rate = currentTime / duration;\n    if (rate > 1) rate = 1;\n    if (rate < 0) rate = 0;\n    wavesurfer.seekTo(rate);\n    */\n    // Skip function wavesurfer.seekTo(progress), use wavesurfer.backend.seekTo(time) instead.\n    // Fireevent seek will be ignored\n    if (currentTime < 0) currentTime = 0;\n    if (currentTime > duration) currentTime = duration;\n    wavesurfer.backend.seekTo(currentTime);\n  }\n\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const { currentPlayMode } = this.props;\n    if (region.data.type === 'temp') {\n      this.setCurrentScroll(region.start, 0, true);\n      region.play();\n    } else if (region.data.type === 'line') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const cursorTime = this.getCursorTime();\n      const start = ((cursorTime > 0 && (e.altKey || e.ctrlKey)) || currentPlayMode === 'overallLoop') ? cursorTime : null;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({ index: segmentIndex, start });\n    } else if (region.data.type === 'anchor' || region.data.type === 'tempAnchor') {\n      const { anchorSelected } = this.current;\n      if (region !== anchorSelected) this.setSelectedAnchor(region);\n      else this.removeSelectedAnchor();\n    }\n  }\n\n  setSelectedAnchor(region) {\n    this.removeSelectedAnchor();\n    region.mark.classList.add('anchor-mark-selected');\n    this.current.anchorSelected = region;\n  }\n\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n\n  setCurrentSpeed(speed) {\n    this.current.wavesurfer?.setPlaybackRate(speed);\n  }\n\n  resetRegionTitle() {\n    const { segments } = this.current;\n    segments.forEach((segment, segmentIndex) => {\n      segment.forEach((line, lineIndex) => {\n        line.title.innerText = lineIndex === 0 ? `${segmentIndex + 1}\\n${(line.end - line.start).toFixed(3)} [${formatTimestamp(line.start)}~${formatTimestamp(line.end)}]` : '';\n      });\n    });\n  }\n\n  moveRegionsInBatch(step) {\n    const { wavesurfer, anchors, segmentSelected } = this.current;\n    const min = 0;\n    const max = wavesurfer.getDuration();\n    Object.keys(wavesurfer.regions.list).forEach((id) => {\n      const region = wavesurfer.regions.list[id];\n      if (region.data.type !== 'line') {\n        return;\n      }\n      this.__moveRegion(region, step, min, max);\n      if (segmentSelected === region) { wavesurfer.frame.update({ start: region.start, end: region.end }); }\n    });\n    anchors.forEach((anchor) => {\n      this.__moveRegion(anchor, step, min, max);\n    });\n    this.props.moveSegmentInBatch({ step, min, max });\n    this.resetRegionTitle();\n  }\n\n  __moveRegion(region, step, min, max) {\n    if (region.start > min || region.end < max) {\n      if (region.start > min) {\n        region.start = region.start + step < min ? min : region.start + step;\n      }\n      if (region.end < max) {\n        region.end = region.end + step > max ? max : region.end + step;\n      }\n      region.update({ start: region.start, end: region.end });\n    }\n  }\n\n  handleAnchorDrag(region) {\n    const { wavesurfer, anchors, segments, segmentSelected } = this.current;\n    const { minSegmentLength, toolMode } = this.props;\n    const i = anchors.indexOf(region);\n    if (i < 0) return false;\n    const leftBoundary = (i === 0) ? 0 : anchors[i - 1].start;\n    const rightBoundary = (i === anchors.length - 1) ? wavesurfer.getDuration() : anchors[i + 1].start;\n    if (region.start < rightBoundary - minSegmentLength && region.start > leftBoundary + minSegmentLength && !isAnnotationReadonly(toolMode)) {\n      region.data.prevStart = region.start;\n      const prevSegment = segments[i];\n      const nextSegment = segments[i + 1];\n      prevSegment.forEach((line) => {\n        line.update({ end: region.start });\n      });\n      nextSegment.forEach((line) => {\n        line.update({ start: region.start });\n      });\n      this.props.setSegmentTimestamp({ segmentIndex: i, end: region.start });\n      this.props.setSegmentTimestamp({ segmentIndex: i + 1, start: region.start });\n      this.resetRegionTitle();\n      if (segmentSelected === prevSegment[0]) { wavesurfer.frame.update({ start: prevSegment[0].start, end: prevSegment[0].end }); }\n      if (segmentSelected === nextSegment[0]) { wavesurfer.frame.update({ start: nextSegment[0].start, end: nextSegment[0].end }); }\n      return true;\n    }\n    region.update({ start: region.data.prevStart, end: region.data.prevStart });\n    return false;\n  }\n\n  handleRegionUpdate(region, e) {\n    const { type } = region.data;\n    const { segmentSelected } = this.current;\n    if (type === 'temp' && region !== segmentSelected) {\n      this.setSelectedSegment(region);\n      region.element.classList.add('line-region');\n    }\n  }\n\n  handleRegionEdit(region) {\n    const { type } = region.data;\n    const { wavesurfer } = this.current;\n    if (type === 'temp') {\n      if ((region.end - region.start < this.props.minSegmentLength) || this.props.currentPlayMode === 'overallLoop') {\n        this.removeSelectedSegment();\n      } else {\n        region.play();\n        this.insertTempAnchor({ start: region.start, end: region.end });\n        wavesurfer.frame.update({ start: region.start, end: region.end });\n      }\n    } else if (type === 'anchor') {\n      const { prevStart } = region.data;\n      const { anchors } = this.current;\n      const result = this.handleAnchorDrag(region);\n      if (result === false) return;\n      const dragAnchorIndex = anchors.indexOf(region);\n      this.addHistory('dragAnchor', { dragAnchorIndex, prevStart });\n      this.setSelectedAnchor(region);\n    } else if (type === 'tempAnchor') {\n      this.setTempSegment();\n    }\n  }\n\n  setTempSegment() {\n    const { segmentSelected, wavesurfer } = this.current;\n    const { leftTempAnchor, rightTempAnchor } = segmentSelected;\n    if (leftTempAnchor.start > rightTempAnchor.start - this.props.minSegmentLength) {\n      leftTempAnchor.update({ start: leftTempAnchor.data.prevStart });\n      rightTempAnchor.update({ start: rightTempAnchor.data.prevStart });\n    } else {\n      leftTempAnchor.data.prevStart = leftTempAnchor.start;\n      rightTempAnchor.data.prevStart = rightTempAnchor.start;\n      segmentSelected.update({ start: leftTempAnchor.start, end: rightTempAnchor.start });\n      wavesurfer.frame.update({ start: segmentSelected.start, end: segmentSelected.end });\n    }\n  }\n\n  handleRegionOut(region) {\n    const { currentPlayMode } = this.props;\n    const { segmentSelected, wavesurfer } = this.current;\n    const { type } = region.data;\n    if (type !== 'line' && type !== 'temp') return;\n    if (segmentSelected === region && currentPlayMode === 'regionLoop') {\n      this.seekCurrentAudio(region.start);\n      this.setCurrentScroll(region.start, 0, true);\n    } else if (segmentSelected === region && currentPlayMode === 'regionPlay') {\n      wavesurfer.pause();\n      this.seekCurrentAudio(region.end);\n    }\n  }\n\n  handlePlayPause() {\n    this.props.setPlayingState({ isPlaying: this.current.wavesurfer.isPlaying() });\n  }\n\n  handleRegionContextmenu(region, e) {\n    e.preventDefault();\n    if (region.data.type === 'anchor') {\n      const { anchors, segments } = this.current;\n      const i = anchors.indexOf(region);\n      const nextSegment = segments[i + 1];\n      const prevSegment = segments[i];\n      const nextRules = [];\n      const prevRules = [];\n      prevSegment.forEach((line, index) => {\n        prevRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i,\n          lineIndex: index,\n        });\n      });\n      nextSegment.forEach((line, index) => {\n        nextRules.push({\n          role: line.role,\n          start: line.start,\n          end: line.end,\n          segmentIndex: i + 1,\n          lineIndex: index,\n        });\n      });\n      this.mergeSegment(region);\n      const mergeSec = region.start;\n      this.addHistory('mergeSegment', { mergeSec, prevRules, nextRules });\n    }\n  }\n\n  mergeSegment(region) {\n    const { anchors, segments, anchorSelected, segmentSelected, wavesurfer } = this.current;\n    const i = anchors.indexOf(region);\n    const nextSegment = segments[i + 1];\n    const prevSegment = segments[i];\n    const { start } = prevSegment[0];\n    const { end } = nextSegment[0];\n    const prevRules = [];\n    if (anchorSelected === region) this.removeSelectedAnchor();\n    region.remove();\n    anchors.splice(i, 1);\n    this.props.setSegmentTimestamp({ segmentIndex: i, end });\n    prevSegment.forEach((line, index) => {\n      prevRules.push(line.role);\n      line.update({ end });\n    });\n    this.props.setCurrentSegment({ index: i });\n    this.props.mergeSegmentBackward({ segmentIndex: i + 1 });\n    nextSegment.forEach((line) => {\n      if (prevRules.indexOf(line.role) < 0 && line.role !== 'none') {\n        this.insertLine({\n          start,\n          end,\n          role: line.role,\n          segmentIndex: i,\n          lineIndex: prevSegment.length,\n        });\n      }\n      line.remove();\n    });\n    segments.splice(i + 1, 1);\n    if (segmentSelected === prevSegment[0]) { wavesurfer.frame.update({ start: prevSegment[0].start, end: prevSegment[0].end }); }\n    this.resetRegionTitle();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  setPlayMode(mode) {\n    // none\n  }\n\n  checkNearbyAnchor(sec) {\n    const { anchors } = this.current;\n    const { minSegmentLength } = this.props;\n    let invalidAnchor = null;\n    let minDistance = null;\n    anchors.forEach((value) => {\n      const distance = Math.abs(value.start - sec);\n      if (distance < minSegmentLength) {\n        if (!invalidAnchor || minDistance > distance) {\n          invalidAnchor = value;\n          minDistance = distance;\n        }\n      }\n    });\n    return invalidAnchor;\n  }\n\n  singleLination(sec) {\n    const { minSegmentLength, annotateDisabled } = this.props;\n    const { wavesurfer, anchors } = this.current;\n    if (sec < minSegmentLength ||  annotateDisabled) return;\n    if (sec > wavesurfer.getDuration() - minSegmentLength) return;\n    const nearbyAnchor = this.checkNearbyAnchor(sec);\n    if (nearbyAnchor) {\n      const prevStart = nearbyAnchor.start;\n      nearbyAnchor.update({ start: sec });\n      this.handleAnchorDrag(nearbyAnchor);\n      const nearbyAnchorIndex = anchors.indexOf(nearbyAnchor);\n      this.addHistory('singleLination-adjust', { nearbyAnchorIndex, prevStart });\n    } else {\n      const splitSegment = this.getSegmentByTime(sec);\n      const splitAnchor = this.splitSegment(splitSegment, sec);\n      const splitAnchorIndex = anchors.indexOf(splitAnchor);\n      this.addHistory('singleLination-split', { splitAnchorIndex });\n    }\n  }\n\n  getSegmentByTime(sec) {\n    const { segments } = this.current;\n    // eslint-disable-next-line no-restricted-syntax\n    for (const value of segments) {\n      const line = value[0];\n      if (line.start <= sec && line.end >= sec) return value;\n    }\n    return null;\n  }\n\n  splitSegment(segment, sec, prevRules, nextRules, focusPrevSegment) {\n    const { segments, anchors } = this.current;\n    if (!segment) return;\n    const { end } = segment[0];\n    const i = segments.indexOf(segment);\n    const anchor = this.insertAnchor({ start: sec, segmentIndex: i + 1 });\n    this.insertSegment({ start: sec, end, segmentIndex: i + 1 });\n    segment.forEach((line) => { line.update({ end: sec }); });\n    if (prevRules && nextRules) {\n      const arr = [];\n      prevRules.forEach((rule) => { arr.push(rule.role); });\n      segment.forEach((line, index) => {\n        if (arr.indexOf(line.role) < 0) this.deleteLine({ lineIndex: index, segmentIndex: i });\n      });\n      this.deleteLine({ lineIndex: 0, segmentIndex: i + 1 });\n      nextRules.forEach((role) => { this.insertLine(role); });\n      const splitAnchorIndex = anchors.indexOf(anchor);\n      this.addHistory('singleLination-split', { splitAnchorIndex });\n    }\n    this.props.setSegmentTimestamp({ segmentIndex: i, end: sec });\n    this.props.splitSegmentForward({ segmentIndex: i, start: sec, end, prevRules, nextRules });\n    this.removeSelectedSegment();\n    this.resetRegionTitle();\n    this.props.setCurrentSegment({ index: focusPrevSegment ? i : i + 1 });\n    return anchor;\n  }\n\n  deleteLine(data) {\n    const { segments } = this.current;\n    const { segmentIndex, lineIndex } = data;\n\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    data.start = line.start;\n    data.end = line.end;\n    data.role = line.role;\n    line.remove();\n    segment.splice(lineIndex, 1);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n\n  toppingLine(data) {\n    const { segments } = this.current;\n    const { segmentIndex, lineIndex } = data;\n\n    const segment = segments[segmentIndex];\n    const line = segment[lineIndex];\n    segment.splice(lineIndex, 1);\n    segment.unshift(line);\n    // eslint-disable-next-line no-shadow\n    segment.forEach((li, index, array) => {\n      const height = 100 / array.length;\n      const top = height * index;\n      li.element.style.height = `${height}%`;\n      li.element.style.top = `${top}%`;\n    });\n    this.resetRegionTitle();\n  }\n\n  doubleLination(start, end) {\n    const { minSegmentLength, annotateDisabled } = this.props;\n    const { anchors, segmentSelected } = this.current;\n    if (!start || Number.isNaN(start)) start = segmentSelected.start;\n    if (!end || Number.isNaN(end)) end = segmentSelected.end;\n    if (end - start <= minSegmentLength || annotateDisabled) return;\n    const nearbyLeftAnchor = this.checkNearbyAnchor(start);\n    const nearbyRightAnchor = this.checkNearbyAnchor(end);\n    const prevLeftStart = nearbyLeftAnchor ? nearbyLeftAnchor.start : -1;\n    const prevRightStart = nearbyRightAnchor ? nearbyRightAnchor.start : -1;\n    if (start < minSegmentLength) return;\n    if (end > this.current.wavesurfer.getDuration() - minSegmentLength) return;\n\n    if (nearbyLeftAnchor && nearbyRightAnchor) {\n      nearbyLeftAnchor.update({ start });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      nearbyRightAnchor.update({ start: end });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-adjust-adjust', { nearbyLeftAnchorIndex, prevLeftStart, nearbyRightAnchorIndex, prevRightStart });\n    } else if (!nearbyLeftAnchor && nearbyRightAnchor) {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      nearbyRightAnchor.update({ start: end });\n      this.handleAnchorDrag(nearbyRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      const nearbyRightAnchorIndex = anchors.indexOf(nearbyRightAnchor);\n      this.addHistory('doubleLination-split-adjust', { splitLeftAnchorIndex, nearbyRightAnchorIndex, prevRightStart });\n    } else if (nearbyLeftAnchor && !nearbyRightAnchor) {\n      nearbyLeftAnchor.update({ start });\n      this.handleAnchorDrag(nearbyLeftAnchor);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const nearbyLeftAnchorIndex = anchors.indexOf(nearbyLeftAnchor);\n      this.addHistory('doubleLination-adjust-split', { nearbyLeftAnchorIndex, prevLeftStart, splitRightAnchorIndex });\n    } else {\n      const splitLeftSegment = this.getSegmentByTime(start);\n      const splitLeftAnchor = this.splitSegment(splitLeftSegment, start);\n      const splitRightSegment = this.getSegmentByTime(end);\n      const splitRightAnchor = this.splitSegment(splitRightSegment, end, null, null, true);\n      const splitRightAnchorIndex = anchors.indexOf(splitRightAnchor);\n      const splitLeftAnchorIndex = anchors.indexOf(splitLeftAnchor);\n      this.addHistory('doubleLination-split-split', { splitLeftAnchorIndex, splitRightAnchorIndex });\n    }\n  }\n\n  handleKeyDown(e) {\n    if (window.disableLongAudioHotKeys) return;\n    if (isInput()) return;\n    if (isAnnotationReadonly(this.props.toolMode)) return;\n    // if (this.props.toolMode === 'QA_RO') return;\n    if (e.keyCode === 83) { // s\n      const sec = this.getCursorTime();\n      if (sec < 0) return;\n      this.singleLination(sec);\n    } else if (e.keyCode === 68) { // d\n      const { segmentSelected } = this.current;\n      if (segmentSelected && segmentSelected.data.type === 'temp') this.doubleLination();\n    } else if (e.keyCode === 188) { // , || <\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(-ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', { step: -ANCHOR_MOVEMENT_STEP });\n      } else {\n        this.forwardAnchor();\n      }\n    } else if (e.keyCode === 190) { // . | >\n      if (e.ctrlKey) {\n        this.moveRegionsInBatch(ANCHOR_MOVEMENT_STEP);\n        this.addHistory('bulkMovement', { step: ANCHOR_MOVEMENT_STEP });\n      } else {\n        this.backwardAnchor();\n      }\n    } else if (e.ctrlKey && e.keyCode === 90) { // z\n      this.recallHistory('undo');\n    } else if (e.ctrlKey && e.keyCode === 89) { // y\n      this.recallHistory('redo');\n    } else if ((e.keyCode === 8 || e.keyCode === 46) && e.ctrlKey) { // ctrl + delete/backspace\n      this.clearAll();\n    }\n  }\n\n  backwardAnchor() {\n    const { anchorSelected, wavesurfer, anchors } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start + ANCHOR_MOVEMENT_STEP >= wavesurfer.getDuration()) return;\n    anchorSelected.update({ start: anchorSelected.start + ANCHOR_MOVEMENT_STEP });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', { trimAnchorIndex, prevStart: anchorSelected.start - ANCHOR_MOVEMENT_STEP });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n\n  forwardAnchor() {\n    const { anchorSelected, anchors } = this.current;\n    if (!anchorSelected) return;\n    if (anchorSelected.start - ANCHOR_MOVEMENT_STEP <= 0) return;\n    anchorSelected.update({ start: anchorSelected.start - ANCHOR_MOVEMENT_STEP });\n    if (anchorSelected.data.type === 'anchor') {\n      this.handleAnchorDrag(anchorSelected);\n      const trimAnchorIndex = anchors.indexOf(anchorSelected);\n      this.addHistory('trimAnchor', { trimAnchorIndex, prevStart: anchorSelected.start + ANCHOR_MOVEMENT_STEP });\n    } else if (anchorSelected.data.type === 'tempAnchor') this.setTempSegment();\n  }\n\n  handleRegionIn(region) {\n    const { currentPlayMode, currentSegment } = this.props;\n    const { wavesurfer } = this.current;\n    const { type } = region.data;\n    if (type !== 'line') return;\n    if (currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentByRegion(region);\n      const currentTime = wavesurfer.getCurrentTime();\n      if (segmentIndex === currentSegment) return;\n      if (segmentIndex >= 0) this.props.setCurrentSegment({ index: segmentIndex, start: currentTime });\n    }\n  }\n\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          // partialRender: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [\n            RegionsPlugin.create(),\n            CursorPlugin.create({\n              width: '1px',\n              height: '10px',\n              container: this.container.audioContainer[i],\n              color: defaultColor.defaultGreen,\n              showTime: true,\n              opacity: 1,\n              customShowTimeStyle: {\n                color: defaultColor.defaultGreen,\n                fontSize: '14px',\n                paddingLeft: '5px',\n                position: 'absolute',\n                bottom: '3px',\n              },\n              formatTimeCallback: (sec) => {\n                this.setState({ cursorTime: sec });\n                return formatTimestamp(sec);\n              },\n            }),\n            TimelinePlugin.create({\n              container: this.container.timeline[i],\n              primaryFontColor: defaultColor.defaultWhite,\n              secondaryFontColor: defaultColor.defaultWhite,\n              primaryColor: defaultColor.defaultWhite,\n              secondaryColor: defaultColor.defaultWhite,\n              fontSize: '10',\n              notchPercentHeight: 30,\n              timeInterval,\n              primaryLabelInterval,\n              secondaryLabelInterval,\n              formatTimeCallback,\n            }),\n            MinimapPlugin.create({\n              container: this.container.minimap[i],\n            }),\n          ],\n        });\n        urls[i] = this.container.videoContainer[i];\n        this.wavesurfers[i].on('ready', () => {\n          this.wavesurfers[i].pause();\n          this.wavesurfers[i].enableDragSelection({\n            color: hexToRgba(defaultColor.defaultRed, defaultColor.defaultAlpha),\n            drag: false,\n            resize: false,\n            data: { type: 'temp' },\n            formatTimeCallback: () => '',\n          });\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            console.log('Error', e);\n            this.props.setErrorMsg({ errorMsg: e?.toString() });\n            return;\n          }\n          this.props.setLoading(false);\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (!i) {\n            this.setNewVideo();\n            this.setSelectedSegment(this.current.segments[0][0]);\n          }\n          if (i === 0) this.addWindowEvent();\n          this.wavesurfers[i].on('play', (e) => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', (e) => this.handlePlayPause());\n          this.wavesurfers[i].on('region-updated', (region, e) => this.handleRegionUpdate(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (region, e) => this.handleRegionContextmenu(region, e));\n          this.wavesurfers[i].on('region-update-end', (region, e) => this.handleRegionEdit(region));\n          this.wavesurfers[i].on('region-out', (region, e) => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', (region, e) => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.wavesurfers[i].on('redraw', this.props.setXScroll);\n          this.props.setVideoValid({ index: i });\n          this.props.updateVideoInfo({ index: i, duration: this.wavesurfers[i].getDuration() });\n        });\n        this.wavesurfers[i].on('error', (error) => {\n          notification.error({ message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}` });\n          this.props.setAudioErrorMsg({\n            index: i,\n            errorMsg: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1} ${urls[i].src} ${error}`\n          });\n          this.wavesurfers[i].un('ready');\n          this.wavesurfers[i].un('error');\n          this.wavesurfers[i].destroy();\n          if (i === size - 1) {\n            this.props.setLoading(false);\n          }\n        });\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const { zoom, wavesurfer } = this.current;\n        if (!cursorHelper) {\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer?.cursor?.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const { offsetWidth } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = (totalWidth / duration) * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n\n  addWindowEvent() {\n    window.addEventListener('keydown', (e) => this.handleKeyDown(e));\n    window.addEventListener('resize', (e) => this.setCurrentZoom());\n  }\n\n  // eslint-disable-next-line react/no-deprecated\n  componentWillMount() {\n    this.props.getWavesurfers({ wavesurfers: this });\n  }\n\n  renderSegments = () => {\n    const { videos, results } = this.props;\n    this.regions = { segments: [], anchors: [] };\n    videos.forEach((v, i) => {\n      if (v.ready) {\n        this.wavesurfers[i].clearRegions();\n        this.initRegion(i, results[i]);\n        if (i === this.current.videoIndex) {\n          this.setNewVideo();\n          this.setSelectedSegment(this.current.segments[0][0]);\n        }\n      }\n    });\n  };\n\n  render() { return null; }\n}\n\nconst mapStateToProps = (state) => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  keyAttribute: state.keyAttribute,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw,\n  styleConfig: state.styleConfig,\n});\nconst mapDispatchToProps = {\n  debug,\n  getWavesurfers,\n  setPlayingState,\n  setSegmentTimestamp,\n  mergeSegmentBackward,\n  splitSegmentForward,\n  setVideoValid,\n  setVideoZoom,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  removeSegment,\n  setSegments,\n  parseSegments,\n  setErrorMsg,\n  setAudioErrorMsg,\n  moveSegmentInBatch,\n  updateVideoInfo,\n  setLoading,\n};\nexport default connect(mapStateToProps, mapDispatchToProps, null, { forwardRef: true })(WavesurferComp);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}