{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx\";\nimport React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport { toJS } from 'mobx';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Attributes from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { LandmarkEditType, DELETETYPE, ReviewResult } from './types';\nimport { fetchResultByUrl } from './request';\nimport loader from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport { initInstances, loadInstancesFromResult, getFrameShapes, parseFramesByPaylod, getInstanceFrames } from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nimport Missing from './components/QualityControl/Missing';\nnotification.config({\n  top: 60\n});\nvar CANVASSTATUS = /*#__PURE__*/function (CANVASSTATUS) {\n  CANVASSTATUS[\"INITIAL\"] = \"initial\";\n  CANVASSTATUS[\"LANDMARK\"] = \"landmark\";\n  return CANVASSTATUS;\n}(CANVASSTATUS || {});\nconst LandmarkAnnotation = forwardRef((props, ref) => {\n  const store = useLocalObservable(() => rootStore);\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState(78);\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState('');\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState({});\n  const [updatedCategories, setUpdatedCategories] = useAsyncState([]);\n  const [defaultInstances, setDefaultInstances] = useAsyncState({});\n  const [instances, setInstances] = useAsyncState({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n  const [loading, setLoading] = useState(false);\n  const [formConfig, setFormConfig] = useState(null);\n  const [formValues, setFormValues] = useState(null);\n  const [imageSize, setImageSize] = useState({\n    width: 0,\n    height: 0\n  });\n  const [editFormObject, setEditFormObject] = useState(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState({});\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef(null);\n  const canvas = useRef(null);\n  const isDrawMode = useMemo(() => store.review.drawMode, [store.review.drawMode]);\n  const displayedInstances = useMemo(() => isReview ? initialInstances : instances, [isReview, initialInstances, instances]);\n  const instanceIds = useMemo(() => Object.keys(displayedInstances), [displayedInstances]);\n  const instanceList = useMemo(() => Object.values(displayedInstances).filter(v => !!v), [displayedInstances]);\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap = {};\n    instanceList.forEach(({\n      category,\n      id,\n      number\n    }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n  const displayedCategoryInstancesMap = useMemo(() => isReview ? initialCategoryInstancesMap : categoryInstancesMap, [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n  const displayedCategoryPathShapes = useMemo(() => isReview ? initialCategoryPathShapes : categoryPathShapes, [isReview, initialCategoryPathShapes, categoryPathShapes]);\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    return ontologyItem;\n  });\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find(group => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n  const categories = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.categories) || [], [ontologyGroup]);\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.id;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ? categories.findIndex(c => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) : -1;\n  }, [selectedShapeStatus, categories]);\n  const instancesFrames = useMemo(() => {\n    const items = {};\n    instanceList.forEach(instance => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n  const shapes = useMemo(() => {\n    var _selectedInstance$chi;\n    const group = selectedInstance === null || selectedInstance === void 0 ? void 0 : (_selectedInstance$chi = selectedInstance.children.find(g => g.name === selectedOntologyGroup)) === null || _selectedInstance$chi === void 0 ? void 0 : _selectedInstance$chi.frames[currentFrame];\n    return group && group.shapes || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n  const selectedShapeInfo = useMemo(() => {\n    let info = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        displayColor: (selectedOntology === null || selectedOntology === void 0 ? void 0 : selectedOntology.display_color) || ''\n      };\n      if ((ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        var _categories$selectedC;\n        info = {\n          ...info,\n          pointCategory: (_categories$selectedC = categories[selectedCategoryIndex]) === null || _categories$selectedC === void 0 ? void 0 : _categories$selectedC.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n  const annotatedPointOrShapeCount = useMemo(() => Object.entries(shapes).filter(([, v]) => v !== undefined).length, [shapes]);\n  const totalPointCount = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.count) || 0, [ontologyGroup]);\n  const instancesReviewsMap = useObserver(() => {\n    const map = {};\n    store.review.reviews.forEach(review => {\n      var _instances$instanceId;\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        shapeIds,\n        result\n      } = review;\n      const category = (_instances$instanceId = instances[instanceId]) === null || _instances$instanceId === void 0 ? void 0 : _instances$instanceId.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0\n        };\n      }\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n  useEffect(() => {\n    onLoad();\n  }, []);\n  useEffect(() => {\n    if (selectedShapeInfo === null || selectedShapeInfo === void 0 ? void 0 : selectedShapeInfo.instanceId) {\n      store.review.setSelectedMissingReview();\n    }\n  }, [selectedShapeInfo]);\n  const getInstance = instanceId => displayedInstances[instanceId];\n  const getGroup = (instanceId, groupName, frameIndex = currentFrame) => {\n    var _instance$children$fi;\n    const instance = getInstance(instanceId);\n    const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[frameIndex];\n    return group;\n  };\n  const getShape = (instanceId, groupName, id, frameIndex = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? group.shapes[id] : group.shapes[id]);\n  };\n  const setInstance = (id, instance) => {\n    setInstances({\n      ...instances,\n      [id]: instance\n    });\n  };\n  const setShape = (frameIndex, instanceId, groupName, id, shapeType, shape) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      var _group;\n      let group = instance.children.find(g => g.name === groupName);\n      let currentGroup = (_group = group) === null || _group === void 0 ? void 0 : _group.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = currentGroup.shapes[id];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = currentGroup.shapes[id];\n      }\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete currentGroup.shapes[id];\n        } else {\n          delete currentGroup.shapes[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n        }\n        currentGroup.shapes = {\n          ...currentGroup.shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === groupInfo.count && !currentGroup.attributes) {\n        handleFormConfig(groupInfo.label_config, {}, {\n          instanceId,\n          category: instance.category,\n          groupName\n        });\n      }\n    }\n  };\n  const updateStatus = async (curr, prev) => {\n    let newUpdatedShapes = [];\n    let newUpdatedCategories = [];\n    let updatedHandles = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const {\n          frameIndex,\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        let keyObj;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = {\n            index\n          };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = {\n            id\n          };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({\n            ...frameGroup,\n            ...keyObj,\n            shapeType\n          });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          const {\n            updateShapes\n          } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          const instanceIndex = instanceIds.findIndex(v => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          frameIndex,\n          groupName,\n          attributes\n        } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n          if (newInstance && newGroup) {\n            newGroup.frames[frameIndex].attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const {\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType,\n          shape,\n          frameIndex\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape;\n            const {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              attributes\n            } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex(p => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: {\n                  ...point.position\n                }\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                index,\n                shape: updateShape,\n                shapeType\n              });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape;\n            const {\n              displayColor,\n              visible,\n              x,\n              y,\n              width,\n              height\n            } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible\n            };\n            const updateIndex = newUpdatedShapes.findIndex(rect => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                id,\n                shape: updateRectangle,\n                shapeType\n              });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const {\n          frameIndex,\n          pointCategory,\n          shape\n        } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3]\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const {\n            updateShapes,\n            updatedCategories: newCategories\n          } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          newUpdatedCategories = [...newUpdatedCategories, ...newCategories];\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          groupName,\n          attributes,\n          frameIndex\n        } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach(id => {\n            var _canvas$current;\n            const attrLayer = (_canvas$current = canvas.current) === null || _canvas$current === void 0 ? void 0 : _canvas$current.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              var _canvas$current2;\n              (_canvas$current2 = canvas.current) === null || _canvas$current2 === void 0 ? void 0 : _canvas$current2.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          newGroup.frames[frameIndex].attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({\n          message: 'Undo successfully.'\n        });\n      }\n    }\n  };\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({\n          message: 'Redo successfully.'\n        });\n      }\n    }\n  };\n  const handleChangeDrawMode = mode => {\n    if (store.review.isEditable) {\n      var _canvas$current3;\n      (_canvas$current3 = canvas.current) === null || _canvas$current3 === void 0 ? void 0 : _canvas$current3.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(undefined, {\n          instanceId,\n          category,\n          groupName\n        });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n  const loadInitialData = async () => {\n    let data;\n    const {\n      initial_result: initialResult\n    } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n  const addInstance = async ontologyName => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter(v => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n      const children = ontologyItem.children.map(v => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({\n        [id]: instance\n      });\n      await handleInstanceChange({\n        [id]: instance\n      });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, {\n          category: ontologyName,\n          shapeType: ontologyItem.children[0].type\n        });\n      }\n    }\n  };\n  const addInstanceInFrame = (instanceId, groupName) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex(group => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame;\n          Object.keys(newInstance.children[groupIdx].frames).forEach(i => {\n            const index = Number(i);\n            const frame = {\n              ...newInstance.children[groupIdx].frames[index]\n            };\n            frame.shapes = {\n              ...frame.shapes\n            };\n            if ((frame === null || frame === void 0 ? void 0 : frame.count) && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx;\n        Object.keys(instancesFrames[instanceId]).forEach(i => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach(group => {\n            const copyFrame = {\n              ...group.frames[copyFrameIdx]\n            };\n            copyFrame.shapes = {\n              ...copyFrame.shapes\n            };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const {\n        updateShapes,\n        updatedCategories: newUpdatedCategories\n      } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n  const removeInstanceFrames = (type, instance, name) => {\n    if (instance) {\n      let delShapes = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance, frameIndex) => {\n        updateInstance.children.forEach(group => {\n          if (name && name === group.name || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= group.frames[frameIndex].count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const {\n          updateShapes\n        } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({\n          length: frames.length - diffFrame\n        }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const {\n            updateShapes\n          } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [...delShapes, ...updateShapes];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter(v => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({\n        [newInstance.id]: newInstance\n      });\n    }\n  };\n  const handleInstanceChange = async (newInstances, status) => {\n    const ids = Object.keys(newInstances);\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async id => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach(child => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance\n          }\n        });\n        after.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n  const onLoad = async () => {\n    var _result, _saverRef$current;\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n    let result;\n    let initialData;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({\n        message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({\n      frames: props.image,\n      imageData: (_result = result) === null || _result === void 0 ? void 0 : _result.images\n    });\n    // preload image\n    setImagePreloader(loader(framesData.map(v => v.url)));\n    // set frame images\n    setFrames(framesData);\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes = {};\n        result.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData = {};\n        initialData.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const {\n        newInstances,\n        categoryInstancesMap: newCategoryInstancesMap\n      } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const {\n        newInstances\n      } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    (_saverRef$current = saverRef.current) === null || _saverRef$current === void 0 ? void 0 : _saverRef$current.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex, currentInstances = instances, type) => {\n    var _canvas$current4, _canvas$current5;\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    store.review.cancelUnfinishMissingReview();\n    const currentInstanceList = Object.values(currentInstances);\n    (_canvas$current4 = canvas.current) === null || _canvas$current4 === void 0 ? void 0 : _canvas$current4.cleanLayer();\n    (_canvas$current5 = canvas.current) === null || _canvas$current5 === void 0 ? void 0 : _canvas$current5.setMultiShapesUnselected();\n    imagePreloader === null || imagePreloader === void 0 ? void 0 : imagePreloader.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const {\n        id,\n        category,\n        children: [{\n          name\n        }]\n      } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group === null || group === void 0 ? void 0 : group.type\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const {\n      updateShapes,\n      updatedCategories: updatedCategoriesData\n    } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n  const onSave = async (submit = true) => {\n    var _saverRef$current2, _canvas$current6, _canvas$current6$imag, _canvas$current7, _canvas$current7$imag;\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({\n        message: loadError\n      });\n      throw new Error(loadError);\n    }\n    (_saverRef$current2 = saverRef.current) === null || _saverRef$current2 === void 0 ? void 0 : _saverRef$current2.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances = instanceList.filter(v => v && v.notEmpty).map(instance => {\n      const {\n        id,\n        category,\n        number,\n        displayColor,\n        children\n      } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map(group => {\n          const {\n            frames: groupFrames\n          } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter(v => !!v && v.count > 0).map(frameGroup => {\n              if (frameGroup) {\n                const {\n                  frameIndex,\n                  count,\n                  shapes: groupShapes\n                } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach(key => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point = groupShapes && groupShapes[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        newShapes.push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle = groupShapes && groupShapes[key];\n                      if (rectangle) newShapes.push(rectangle);\n                    }\n                  });\n                }\n                if (checkMissingPoints && frames[frameIndex].valid !== false && groupInfo && newShapes.length < groupInfo.count) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.display_name) || (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.class_name),\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({\n                    message: errMsg\n                  });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: ((_canvas$current6 = canvas.current) === null || _canvas$current6 === void 0 ? void 0 : (_canvas$current6$imag = _canvas$current6.imageCanvas) === null || _canvas$current6$imag === void 0 ? void 0 : _canvas$current6$imag.width) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.width),\n      height: ((_canvas$current7 = canvas.current) === null || _canvas$current7 === void 0 ? void 0 : (_canvas$current7$imag = _canvas$current7.imageCanvas) === null || _canvas$current7$imag === void 0 ? void 0 : _canvas$current7$imag.height) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.height),\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map(pointCategory => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory]\n      })),\n      images: frames,\n      statistics\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0\n    };\n    const reviews = store.review.reviews.filter(r => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter(r => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find(r => r.shapeIds.indexOf(shapeId) >= 0);\n            if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return {\n      objects,\n      shapes: statShapes\n    };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const {\n      ontology\n    } = store.ontology;\n    const data = {\n      elements: [],\n      categories: ontology.map(({\n        class_name: className\n      }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set()\n    };\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const {\n        id,\n        category,\n        children\n      } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(...frameShapes.map(s => ({\n              instance: id,\n              shape,\n              frame: frame.frameIndex + 1,\n              category,\n              id: s.id || s.index\n            })));\n          }\n        }\n      }\n    }\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({\n        category,\n        shape,\n        count,\n        distinctCount\n      }) => ({\n        category,\n        shape,\n        count,\n        distinctCount\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size\n    };\n  };\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n  const saveReviews = (type = 'submit') => {\n    var _saverRef$current3;\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find(review => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    (_saverRef$current3 = saverRef.current) === null || _saverRef$current3 === void 0 ? void 0 : _saverRef$current3.disableLeaveCheck();\n    const missingReviews = toJS(store.review.missingReviews).map(r => ({\n      ...r,\n      label: 'Missed'\n    }));\n    return props.jobProxy.saveReviews([...missingReviews], type === 'submit');\n  };\n  const handleSave = async () => {\n    const {\n      toolMode\n    } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n    try {\n      console.log('handleSave');\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({\n        message: formatMessage('SAVE_SUCCESS')\n      });\n    } catch (e) {\n      notification.error({\n        message: formatMessage('SAVE_FAIL')\n      });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const {\n        hasCustomError,\n        blockSubmitErrors\n      } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n  const setSelectedShape = (id, groupData) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        shapeType\n      } = groupData;\n      if (instanceId !== (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.id)) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        groupName\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n  const setNextEmptyShape = (shapeStatus = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let {\n        id\n      } = shapeStatus;\n      const {\n        instanceId,\n        groupName,\n        shapeType\n      } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const {\n            range = []\n          } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            id += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n  const handleShapesChange = (newShapes, groupsAttributes, status) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    const {\n      instanceId,\n      groupName\n    } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData((newInstance === null || newInstance === void 0 ? void 0 : newInstance.category) || '', groupName);\n    newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          };\n        }\n        ;\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const {\n            id,\n            frameIndex,\n            index,\n            shape\n          } = newShapes[i];\n          let oldShape;\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = child.frames[frameIndex].shapes[index];\n            child.frames[frameIndex].shapes[index] = {\n              ...oldShape,\n              ...shape\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = child.frames[frameIndex].shapes[id];\n            child.frames[frameIndex].shapes[id] = {\n              ...oldShape,\n              ...shape\n            };\n          }\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        }\n        ;\n        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.count) && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, {\n            instanceId,\n            category: newInstance.category,\n            groupName\n          });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({\n        instanceId: id,\n        name,\n        category,\n        attributes\n      }) => {\n        const frameGroup = {\n          frameIndex: currentFrame,\n          instanceId: id,\n          category,\n          groupName: name\n        };\n        before.push({\n          type: 'group',\n          status: {\n            ...frameGroup\n          }\n        });\n        after.push({\n          type: 'group',\n          status: {\n            ...frameGroup,\n            attributes\n          }\n        });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({\n        [instanceId]: newInstance\n      }, {\n        before,\n        after\n      });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n  const handleShapesRemove = removeShapes => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n    const changeInstances = {};\n    const {\n      instanceId,\n      groupName\n    } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({\n            id,\n            frameIndex,\n            index\n          }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete child.frames[frameIndex].shapes[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete child.frames[frameIndex].shapes[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n    }\n  };\n  const togglePointsVisibility = points => {\n    const list = [];\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: {\n            ...point,\n            visible: !point.visible\n          }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n  const setCategoryPathShape = (categoryKey, shapeType, _updatedShapes) => {\n    const before = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: categoryPathShapes[categoryKey]\n      }\n    }];\n    const after = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: shapeType\n      }\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, {\n        before,\n        after\n      });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n  const selectGroup = (id, groupName, isFit = true, groupData) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: (groupData === null || groupData === void 0 ? void 0 : groupData.category) || selectedShapeStatus.category,\n      groupName,\n      shapeType: (groupData === null || groupData === void 0 ? void 0 : groupData.shapeType) || undefined,\n      id: undefined\n    };\n    if (instance) {\n      var _canvas$current8;\n      const ontologyItem = store.ontology.ontology.find(v => v.class_name === instance.category);\n      const group = ontologyItem === null || ontologyItem === void 0 ? void 0 : ontologyItem.children.find(v => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = (group === null || group === void 0 ? void 0 : group.type) || undefined;\n      if (isDrawMode) {\n        if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.KEYPOINT) {\n          const index = group.categories && group.categories[0] && group.categories[0].range[0] || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach(child => {\n            var _child$frames$current;\n            if (child.name === groupName && ((_child$frames$current = child.frames[currentFrame]) === null || _child$frames$current === void 0 ? void 0 : _child$frames$current.shapes)) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      (_canvas$current8 = canvas.current) === null || _canvas$current8 === void 0 ? void 0 : _canvas$current8.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        var _canvas$current9;\n        (_canvas$current9 = canvas.current) === null || _canvas$current9 === void 0 ? void 0 : _canvas$current9.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n  const editShapeForm = () => {\n    const {\n      instanceId,\n      groupName,\n      shapeType,\n      id,\n      category\n    } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, id);\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.point_label_config)) {\n        handleFormConfig(currentOntologyGroup.point_label_config, point.attributes || {}, {\n          instanceId,\n          category,\n          groupName\n        }, id, point);\n      }\n    }\n  };\n  const editGroupForm = () => {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.label_config)) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, {\n        instanceId,\n        category,\n        groupName\n      });\n    }\n  };\n  const handleFormConfig = (config, values, group, index, point) => {\n    var _attributesRef$curren;\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    (_attributesRef$curren = attributesRef.current) === null || _attributesRef$curren === void 0 ? void 0 : _attributesRef$curren.showModal(title);\n  };\n  const getShapeLabel = (instanceId, category, groupName) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', {\n          values: {\n            frameIndex: currentFrame + 1\n          }\n        })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n  const setAttributes = values => {\n    if (editFormObject) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        index,\n        point\n      } = editFormObject;\n      const before = [];\n      const after = [];\n      const frameGroup = {\n        frameIndex: currentFrame,\n        instanceId,\n        category,\n        groupName\n      };\n      if ((index || index === 0) && point) {\n        var _canvas$current10;\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = {\n          ...oldPoint,\n          ...point,\n          attributes: values\n        };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: oldPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        after.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: newPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        (_canvas$current10 = canvas.current) === null || _canvas$current10 === void 0 ? void 0 : _canvas$current10.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        var _newInstance$children;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : (_newInstance$children = newInstance.children.find(v => v.name === groupName)) === null || _newInstance$children === void 0 ? void 0 : _newInstance$children.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: oldAttrs\n            }\n          });\n          after.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: values\n            }\n          });\n          if (oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach(id => {\n                var _canvas$current11;\n                (_canvas$current11 = canvas.current) === null || _canvas$current11 === void 0 ? void 0 : _canvas$current11.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode, type = 'object') => {\n    var _canvas$current12;\n    (_canvas$current12 = canvas.current) === null || _canvas$current12 === void 0 ? void 0 : _canvas$current12.updatelabelVisible(activeMode, type);\n  };\n  const onSizeChange = () => {\n    var _canvas$current13;\n    (_canvas$current13 = canvas.current) === null || _canvas$current13 === void 0 ? void 0 : _canvas$current13.resizeShapes();\n  };\n  const onFilterChange = () => {\n    var _canvas$current14;\n    (_canvas$current14 = canvas.current) === null || _canvas$current14 === void 0 ? void 0 : _canvas$current14.updateFilters();\n  };\n  const onLabelModeChange = () => {\n    var _canvas$current15;\n    if ((_canvas$current15 = canvas.current) === null || _canvas$current15 === void 0 ? void 0 : _canvas$current15.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n  const onGridVisibleChange = () => {\n    var _canvas$current16;\n    if ((_canvas$current16 = canvas.current) === null || _canvas$current16 === void 0 ? void 0 : _canvas$current16.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n  const setFrameValid = (frame, valid) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics\n  }));\n  return /*#__PURE__*/React.createElement(Observer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 1580,\n      columnNumber: 5\n    }\n  }, () => {\n    var _frames$currentFrame, _frames$currentFrame2;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"landmark-annotation-app\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1582,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(AutoSaver, {\n      ref: saverRef,\n      leaveCheck: true,\n      data: {\n        instance: instances,\n        reviews: store.review.qaWarnings\n      },\n      save: handleSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1583,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(Toolbar, {\n      readonly: readonly || loading || isReview,\n      isReview: isReview,\n      isPreview: readonly,\n      initialDataLength: Object.keys(initialInstances).length,\n      onAttributesModeChanges: onAttributesModeChanges,\n      onSizeChange: onSizeChange,\n      onFilterChange: onFilterChange,\n      onLabelModeChange: onLabelModeChange,\n      onGridVisibleChange: onGridVisibleChange,\n      onSave: handleSave,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1589,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"container\",\n      style: {\n        height: `calc(100% - ${frames.length > 1 && currentFrame >= 0 ? `${frameControlHeight + 35}px` : '35px'})`,\n        transition: 'height 0.15s'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1605,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(TabMenu, {\n      tabs: [{\n        title: formatMessage('MENU_INSTANCE'),\n        key: 'instance',\n        count: 0,\n        content: /*#__PURE__*/React.createElement(SideMenus, {\n          canvas: canvas.current,\n          readonly: readonly || loading || isReview || !isDrawMode,\n          loading: loading,\n          instances: instanceList,\n          currentFrame: currentFrame,\n          instancesFrames: instancesFrames,\n          selectedInstance: selectedInstance,\n          selectedOntologyGroup: selectedOntologyGroup,\n          instancesReviewsMap: instancesReviewsMap,\n          addInstance: addInstance,\n          selectGroup: selectGroup,\n          addInstanceInFrame: addInstanceInFrame,\n          removeInstanceFrames: removeInstanceFrames,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1619,\n            columnNumber: 21\n          }\n        })\n      }\n      // {\n      //   title: formatMessage('MENU_WARNING'),\n      //   key: 'validator',\n      //   count: store.review.warnings.length,\n      //   content: (\n      //     <Validator\n      //       canvas={canvas.current}\n      //       ref={validatorRef}\n      //       instances={instances}\n      //       jobProxy={props.jobProxy}\n      //       getScriptResult={getScriptResult}\n      //       warnings={store.review.warnings || []}\n      //       setFrame={setFrame}\n      //       setSelectedShape={setSelectedShape}\n      //       selectGroup={selectGroup}\n      //       getInstance={getInstance}\n      //       saveResult={() => onSave(false)}\n      //     />\n      //   )\n      // }\n      ],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1612,\n        columnNumber: 13\n      }\n    }), selectedInstance && ontologyGroup && !isReview && /*#__PURE__*/React.createElement(Board, {\n      categories: categories,\n      categoryPathShapes: displayedCategoryPathShapes,\n      points: shapes,\n      ontologyGroup: ontologyGroup,\n      selectedShapeStatus: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      drawMode: isDrawMode,\n      setSelectedShape: id => {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(id, {\n          instanceId,\n          category,\n          groupName\n        });\n      },\n      frameControlHeight: frameControlHeight,\n      readonly: loading,\n      instanceReviewsMap: store.review.frameReviewsMap[currentFrame],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1659,\n        columnNumber: 15\n      }\n    }), /*#__PURE__*/React.createElement(Canvas, {\n      ref: canvas,\n      readonly: readonly,\n      loading: loading,\n      isReview: isReview,\n      currentFrame: currentFrame,\n      image: (_frames$currentFrame = frames[currentFrame]) === null || _frames$currentFrame === void 0 ? void 0 : _frames$currentFrame.url,\n      categories: categories,\n      selectedInstance: selectedInstance,\n      selectedGroupName: selectedOntologyGroup,\n      ontologyGroup: ontologyGroup,\n      annotatedPointOrShapeCount: annotatedPointOrShapeCount,\n      updatedCategories: updatedCategories,\n      defaultInstances: defaultInstances,\n      selectedShapeStatus: selectedShapeStatus,\n      selectedShapeInfo: selectedShapeInfo,\n      changeLoading: setLoading,\n      selectGroup: selectGroup,\n      setSelectedShape: setSelectedShape,\n      handleShapesChange: handleShapesChange,\n      onCategoriesUpdated: onCategoriesUpdated,\n      handleShapesRemove: handleShapesRemove,\n      togglePointsVisibility: togglePointsVisibility,\n      setNextEmptyShape: setNextEmptyShape,\n      editShapeForm: editShapeForm,\n      editGroupForm: editGroupForm,\n      onSave: handleSave,\n      getInstance: getInstance,\n      categoryPathShapes: displayedCategoryPathShapes,\n      setCategoryPathShape: setCategoryPathShape,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1677,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"arributes-panel\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1712,\n        columnNumber: 13\n      }\n    }, selectedShapeStatus.groupName && /*#__PURE__*/React.createElement(Information, {\n      pointCategory: (categories[selectedCategoryIndex] || {}).name,\n      point: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1714,\n        columnNumber: 17\n      }\n    }), ((_frames$currentFrame2 = frames[currentFrame]) === null || _frames$currentFrame2 === void 0 ? void 0 : _frames$currentFrame2.url) && /*#__PURE__*/React.createElement(FrameAttributes, {\n      currentFrame: currentFrame,\n      currentFrameValid: frames[currentFrame].valid,\n      setFrameValid: setFrameValid,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1722,\n        columnNumber: 17\n      }\n    })), /*#__PURE__*/React.createElement(Attributes, {\n      ref: attributesRef,\n      readonly: readonly || isReview || !isDrawMode,\n      config: formConfig,\n      values: formValues,\n      onValuesChange: setAttributes,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1729,\n        columnNumber: 13\n      }\n    })), frames.length > 1 && currentFrame >= 0 && /*#__PURE__*/React.createElement(FrameControl, {\n      frames: frames,\n      frameLoading: loading,\n      currentFrame: currentFrame,\n      categoryInstancesMap: displayedCategoryInstancesMap,\n      instancesReviewsMap: instancesReviewsMap,\n      instances: displayedInstances,\n      selectedInstance: selectedInstance,\n      selectedInstanceGroup: selectedOntologyGroup,\n      selectGroup: selectGroup,\n      setFrame: setFrame,\n      onHeightChange: setFrameControlHeight,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1738,\n        columnNumber: 13\n      }\n    }), store.review.selectedReview && /*#__PURE__*/React.createElement(QualityControl, {\n      review: store.review.selectedReview,\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      selectedShapeStatus: selectedShapeStatus,\n      getShapeLabel: getShapeLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1753,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Missing, {\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1761,\n        columnNumber: 11\n      }\n    }));\n  });\n});\nexport default LandmarkAnnotation;","map":{"version":3,"names":["React","useState","useRef","useMemo","useEffect","forwardRef","useImperativeHandle","Observer","useLocalObservable","useObserver","cloneDeep","notification","v4","uuid","toJS","TabMenu","AutoSaver","Toolbar","SideMenus","Board","Canvas","FrameControl","Attributes","QualityControl","Information","FrameAttributes","formatMessage","i18n","LandmarkEditType","DELETETYPE","ReviewResult","fetchResultByUrl","loader","isPreview","isAnnotationReadonly","initInstances","loadInstancesFromResult","getFrameShapes","parseFramesByPaylod","getInstanceFrames","rootStore","useAsyncState","Missing","config","top","CANVASSTATUS","LandmarkAnnotation","props","ref","store","readonly","setReadOnly","frames","setFrames","currentFrame","setCurrentFrame","frameControlHeight","setFrameControlHeight","selectedOntologyGroup","setSelectedOntologyGroup","categoryPathShapes","setCategoryPathShapes","updatedCategories","setUpdatedCategories","defaultInstances","setDefaultInstances","instances","setInstances","imagePreloader","setImagePreloader","selectedShapeStatus","setSelectedShapeStatus","frameIndex","category","instanceId","groupName","shapeType","undefined","id","loading","setLoading","formConfig","setFormConfig","formValues","setFormValues","imageSize","setImageSize","width","height","editFormObject","setEditFormObject","isReview","setIsReview","initialInstances","setInitialInstances","initialCategoryInstancesMap","setInitialCategoryInstancesMap","initialCategoryPathShapes","setInitialCategoryPathShapes","attributesRef","saverRef","validatorRef","canvas","isDrawMode","review","drawMode","displayedInstances","instanceIds","Object","keys","instanceList","values","filter","v","selectedInstance","categoryInstancesMap","newCategoryInstancesMap","forEach","number","displayedCategoryInstancesMap","displayedCategoryPathShapes","selectedOntology","ontologyItem","ontology","find","class_name","ontologyGroup","groupItem","children","group","name","categories","selectedCategoryIndex","KEYPOINT","findIndex","c","range","length","instancesFrames","items","instance","shapes","_selectedInstance$chi","g","selectedShapeInfo","info","type","displayColor","display_color","_categories$selectedC","pointCategory","isKeyPoint","includes","annotatedPointOrShapeCount","entries","totalPointCount","count","instancesReviewsMap","map","reviews","_instances$instanceId","shapeIds","result","approveCount","REJECT","SUSPEND","APPROVE","len","ontologyCount","ontologyMap","onLoad","setSelectedMissingReview","getInstance","getGroup","_instance$children$fi","getShape","setInstance","setShape","shape","_group","currentGroup","push","oldShape","RECTANGLE","notEmpty","groupInfo","getGroupData","label_config","attributes","handleFormConfig","updateStatus","curr","prev","newUpdatedShapes","newUpdatedCategories","updatedHandles","newCategoryPathShapes","m","item","index","status","frameGroup","keyObj","updateShapes","instanceIndex","selectedIndex","newInstance","selectGroup","newGroup","setInitialData","n","point","visible","updateIndex","p","updateShape","position","rectangle","x","y","updateRectangle","rect","split","newCategories","_canvas$current","attrLayer","current","getAttrLabelByKey","_canvas$current2","updateAttributeLabel","setUpdatedShapes","handle","setUpdatedHandles","handleUndo","undo","undoDisabled","before","after","success","message","handleRedo","redoDisabled","redo","handleChangeDrawMode","mode","isEditable","_canvas$current3","clearHits","setNextEmptyShape","setSelectedShape","setDrawMode","loadInitialData","data","initial_result","initialResult","e","console","log","addInstance","ontologyName","sameOntologyInstances","reverse","handleInstanceChange","addInstanceInFrame","groupIdx","copyFrame","i","Number","frame","copyFrameIdx","removeInstanceFrames","delShapes","update","updateInstance","CURRENT","FOLLOW","ALL","diffFrame","Array","from","_","newInstances","ids","oldInstance","isRemove","child","saveStatus","_result","_saverRef$current","jobProxy","toolMode","setLocale","locale","init","initialData","initInstancesData","loadResult","error","duration","framesData","image","imageData","images","url","isArray","auditId","setAuditId","points","initialCategoryPathShapesData","initialInstancesData","currentInstances","setFrame","setTempSaved","renderComplete","_canvas$current4","_canvas$current5","INITIAL","cancelUnfinishMissingReview","currentInstanceList","cleanLayer","setMultiShapesUnselected","preload","currentShapeStatus","updatedCategoriesData","changeFrame","setReview","newIsReview","displayInstances","onSave","submit","_saverRef$current2","_canvas$current6","_canvas$current6$imag","_canvas$current7","_canvas$current7$imag","loadError","Error","disableLeaveCheck","setting","submitCheck","passed","triggerValidation","checkMissingPoints","check_missing_points","ontologyInfo","getOntologyInfo","groupFrames","groupShapes","newShapes","key","pointIndex","parseInt","valid","errMsg","display_name","annotated","total","statData","getInstanceStatistics","statistics","saveResultStat","handles","getHandles","saveResult","imageCanvas","getStatistics","statShapes","objects","approved","rejected","suspended","missed","r","instancesList","j","itemFrames","k","frameReviews","frameShapes","l","shapeId","indexOf","elements","className","Set","summary","frameCount","annotatedFrames","add","distinctCount","shapeCount","s","annotatedFrameCount","size","loadReviews","saveReviews","_saverRef$current3","hasSuspend","missingReviews","label","handleSave","isEnabled","hasCustomError","blockSubmitErrors","handleSync","groupData","newSelectedShapeStatus","shapeStatus","categoryScannedCount","categoryIndex","onCategoriesUpdated","handleShapesChange","groupsAttributes","handleShapesRemove","removeShapes","changeInstances","togglePointsVisibility","list","setCategoryPathShape","categoryKey","_updatedShapes","isFit","_canvas$current8","_child$frames$current","rectangles","updateGroupBox","_canvas$current9","fitSelected","editShapeForm","currentOntologyGroup","point_label_config","editGroupForm","_attributesRef$curren","title","getShapeLabel","showModal","class_display_name","setAttributes","_canvas$current10","oldPoint","newPoint","_newInstance$children","oldGroup","ontologyChild","oldAttrs","_canvas$current11","onAttributesModeChanges","activeMode","_canvas$current12","updatelabelVisible","onSizeChange","_canvas$current13","resizeShapes","onFilterChange","_canvas$current14","updateFilters","onLabelModeChange","_canvas$current15","labelLayer","labelMode","onGridVisibleChange","_canvas$current16","gridLayer","isGridVisible","setFrameValid","newFramesData","createElement","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","_frames$currentFrame","_frames$currentFrame2","leaveCheck","qaWarnings","save","initialDataLength","style","transition","tabs","content","instanceReviewsMap","frameReviewsMap","selectedGroupName","changeLoading","currentFrameValid","onValuesChange","frameLoading","selectedInstanceGroup","onHeightChange","selectedReview"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx"],"sourcesContent":["import React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport { toJS } from 'mobx';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes, { AttributesHandle } from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { Status } from './store/UndoStore';\nimport { AttributesMode } from './store/SettingsStore';\nimport {\n  LandmarkEditType, InstanceListItem, CategoryPathShape, Point, PointListItem, PointStatus, FrameGroup,\n  ShapeInfo, PointInfo, Group, InstanceAct, Rectangle, GroupInfo, FormConfig, ObjectInfo, UpdatedShape,\n  Points, CurrentShapes, CategoryInstancesMap, KeypointCategoryProps, DELETETYPE, Frame, ReviewResult,\n  Payload, Statistic, Image, HandleStatus\n} from './types';\nimport { fetchResultByUrl } from './request';\nimport loader, { ImagePreloader } from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport {\n  initInstances,\n  loadInstancesFromResult,\n  getFrameShapes,\n  parseFramesByPaylod,\n  getInstanceFrames,\n} from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nimport Missing from './components/QualityControl/Missing';\n\nnotification.config({ top: 60 });\n\nenum CANVASSTATUS {\n  INITIAL = 'initial',\n  LANDMARK = 'landmark',\n}\n\nexport interface GroupReviewsMap {\n  [groupName: string]: {\n    approveCount: number;\n    result?: ReviewResult;\n  }\n}\n\nexport interface InstancesReviewsMap {\n  [instanceId: string]: {\n    [frameIndex: number]: {\n      approveCount: number;\n      result?: ReviewResult;\n      children: GroupReviewsMap\n    }\n  }\n}\n\nconst LandmarkAnnotation = forwardRef((props: Payload, ref) => {\n  const store = useLocalObservable(() => rootStore);\n\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState<Image[]>([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState<number>(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState<number>(78);\n\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState<string>('');\n\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState<{ [categoryKey: string]: CategoryPathShape }>({});\n\n  const [updatedCategories, setUpdatedCategories] = useAsyncState<KeypointCategoryProps[]>([]);\n\n  const [defaultInstances, setDefaultInstances] = useAsyncState<{ [id: string]: InstanceAct }>({});\n\n  const [instances, setInstances] = useAsyncState<{ [id: string]: InstanceAct }>({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState<ImagePreloader | null>(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState<ShapeInfo>({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const [formConfig, setFormConfig] = useState<FormConfig | null>(null);\n\n  const [formValues, setFormValues] = useState<{ [attr: string]: any; } | null>(null);\n\n  const [imageSize, setImageSize] = useState<{ width: number, height: number } | undefined>({ width: 0, height: 0 });\n\n  const [editFormObject, setEditFormObject] = useState<ObjectInfo | null>(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState<boolean>(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState<{ [id: string]: InstanceAct }>({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState<CategoryInstancesMap>({});\n\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState<{ [categoryKey: string]: CategoryPathShape }>({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef<AttributesHandle>(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef<AutoSaver>(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef<Validator>(null);\n\n  const canvas = useRef<Canvas>(null);\n\n  const isDrawMode = useMemo(() => (\n    store.review.drawMode\n  ), [store.review.drawMode]);\n\n  const displayedInstances = useMemo(() => (\n    isReview ? initialInstances : instances\n  ), [isReview, initialInstances, instances]);\n\n  const instanceIds = useMemo(() => (\n    Object.keys(displayedInstances)\n  ), [displayedInstances]);\n\n  const instanceList = useMemo(() => (\n    Object.values(displayedInstances).filter((v) => !!v)\n  ), [displayedInstances]);\n\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus?.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap: CategoryInstancesMap = {};\n    instanceList.forEach(({ category, id, number }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n\n  const displayedCategoryInstancesMap = useMemo(() => (\n    isReview ? initialCategoryInstancesMap : categoryInstancesMap\n  ), [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n\n  const displayedCategoryPathShapes = useMemo(() => (\n    isReview ? initialCategoryPathShapes : categoryPathShapes\n  ), [isReview, initialCategoryPathShapes, categoryPathShapes]);\n\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    return ontologyItem;\n  });\n\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find((group) => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n\n  const categories = useMemo(() => (\n    ontologyGroup?.categories || []\n  ), [ontologyGroup]);\n\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus?.id as number;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ?\n      categories.findIndex((c) => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) :\n      -1;\n  }, [selectedShapeStatus, categories]);\n\n  const instancesFrames = useMemo(() => {\n    const items: {\n      [id: string]: {\n        [frameIndex: number]: boolean;\n      }\n    } = {};\n    instanceList.forEach((instance) => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n\n  const shapes = useMemo(() => {\n    const group = selectedInstance?.children.find((g) => g.name === selectedOntologyGroup)?.frames[currentFrame];\n    return (group && group.shapes) || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n\n  const selectedShapeInfo = useMemo(() => {\n    let info: PointInfo | GroupInfo | null = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: ontologyGroup?.type || undefined,\n        displayColor: selectedOntology?.display_color || ''\n      };\n      if (ontologyGroup?.type === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        info = {\n          ...info,\n          pointCategory: categories[selectedCategoryIndex]?.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id as number)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n\n  const annotatedPointOrShapeCount = useMemo(() => (\n    Object.entries(shapes).filter(([, v]) => v !== undefined).length\n  ), [shapes]);\n\n  const totalPointCount = useMemo(() => (\n    ontologyGroup?.count || 0\n  ), [ontologyGroup]);\n\n  const instancesReviewsMap = useObserver(() => {\n    const map: InstancesReviewsMap = {};\n    store.review.reviews.forEach((review) => {\n      const { frameIndex, instanceId, groupName, shapeIds, result } = review;\n      const category = instances[instanceId]?.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0,\n        };\n      }\n\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n\n  useEffect(() => {\n    onLoad();\n  }, []);\n\n  useEffect(() => {\n    if (selectedShapeInfo?.instanceId) {\n      store.review.setSelectedMissingReview();\n    }\n  }, [selectedShapeInfo]);\n\n  const getInstance = (instanceId: string) => displayedInstances[instanceId];\n\n  const getGroup = (instanceId: string, groupName: string, frameIndex: number = currentFrame) => {\n    const instance = getInstance(instanceId);\n    const group = instance?.children.find((g) => g.name === groupName)?.frames[frameIndex];\n    return group;\n  };\n\n  const getShape = (instanceId: string, groupName: string, id: string | number, frameIndex: number = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? (group.shapes as Points)[id] : (group.shapes as CurrentShapes)[id]);\n  };\n\n  const setInstance = (id: string, instance?: InstanceAct) => {\n    setInstances({\n      ...instances,\n      [id]: instance!\n    });\n  };\n\n  const setShape = (frameIndex: number, instanceId: string, groupName: string, id: number | string, shapeType: LandmarkEditType, shape?: Point | Rectangle) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      let group = instance.children.find((g) => g.name === groupName);\n      let currentGroup = group?.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape: Point | Rectangle | undefined;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = ((currentGroup as Frame).shapes as Points)[id as number];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = ((currentGroup as Frame).shapes as CurrentShapes)[id];\n      }\n\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete ((currentGroup as Frame).shapes as Points)[id as number];\n        } else {\n          delete ((currentGroup as Frame).shapes as CurrentShapes)[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count + 1 : 1;\n        }\n        (currentGroup as Frame).shapes = {\n          ...(currentGroup as Frame).shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if (groupInfo?.label_config && (currentGroup as Frame).count === groupInfo.count && !(currentGroup as Frame).attributes) {\n        handleFormConfig(groupInfo.label_config, {}, { instanceId, category: instance.category, groupName });\n      }\n    }\n  };\n\n  const updateStatus = async (curr: Status[], prev: Status[]) => {\n    let newUpdatedShapes: UpdatedShape[] = [];\n    let newUpdatedCategories: KeypointCategoryProps[] = [];\n    let updatedHandles: HandleStatus[] = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const { frameIndex, instanceId, groupName, category, index, id, shapeType } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        let keyObj: { id: string } | { index: number } | undefined;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = { index };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = { id };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({ ...frameGroup, ...keyObj, shapeType });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          const instanceIndex = instanceIds.findIndex((v) => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, frameIndex, groupName, attributes } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance?.children.find((v) => v.name === groupName);\n          if (newInstance && newGroup) {\n            (newGroup.frames[frameIndex] as Frame).attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const { instanceId, groupName, category, index, id, shapeType, shape, frameIndex } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape as Point;\n            const { pointCategory, isKeyPoint, visible, attributes } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex((p) => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape: Point = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: { ...point.position },\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, index, shape: updateShape, shapeType });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape as Rectangle;\n            const { displayColor, visible, x, y, width, height } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle: Rectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible,\n            };\n            const updateIndex = newUpdatedShapes.findIndex((rect) => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, id, shape: updateRectangle, shapeType });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const { frameIndex, pointCategory, shape } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3],\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const { updateShapes, updatedCategories: newCategories } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          newUpdatedCategories = [\n            ...newUpdatedCategories,\n            ...newCategories\n          ];\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, groupName, attributes, frameIndex } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach((id) => {\n            const attrLayer = canvas.current?.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              canvas.current?.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          (newGroup.frames[frameIndex] as Frame).attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({ message: 'Undo successfully.' });\n      }\n    }\n  };\n\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({ message: 'Redo successfully.' });\n      }\n    }\n  };\n\n  const handleChangeDrawMode = (mode: boolean) => {\n    if (store.review.isEditable) {\n      canvas.current?.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const { instanceId, category, groupName } = selectedShapeStatus;\n        setSelectedShape(undefined, { instanceId, category, groupName });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n\n  const loadInitialData = async () => {\n    let data;\n    const { initial_result: initialResult } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n\n  const addInstance = async (ontologyName: string) => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter((v) => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n\n      const children = ontologyItem.children.map((v) => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({ [id]: instance });\n      await handleInstanceChange({ [id]: instance });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, { category: ontologyName, shapeType: ontologyItem.children[0].type });\n      }\n    }\n  };\n\n  const addInstanceInFrame = (instanceId: string, groupName?: string) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex((group) => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame: Frame | undefined;\n          Object.keys(newInstance.children[groupIdx].frames).forEach((i) => {\n            const index = Number(i);\n            const frame = { ...newInstance.children[groupIdx].frames[index] };\n            frame.shapes = { ...frame.shapes };\n            if (frame?.count && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx: number | undefined;\n        Object.keys(instancesFrames[instanceId]).forEach((i) => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach((group) => {\n            const copyFrame = { ...group.frames[copyFrameIdx as number] };\n            copyFrame.shapes = { ...copyFrame.shapes };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const { updateShapes, updatedCategories: newUpdatedCategories } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({ [instanceId]: newInstance });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n\n  const removeInstanceFrames = (type: DELETETYPE, instance: InstanceAct, name?: string) => {\n    if (instance) {\n      let delShapes: UpdatedShape[] = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance: InstanceAct, frameIndex: number) => {\n        updateInstance.children.forEach((group) => {\n          if ((name && name === group.name) || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= (group.frames[frameIndex] as Frame).count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({ length: frames.length - diffFrame }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const { updateShapes } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [\n            ...delShapes,\n            ...updateShapes\n          ];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter((v) => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({ [newInstance.id]: newInstance });\n    }\n  };\n\n  const handleInstanceChange = async (\n    newInstances: { [id: string]: InstanceAct },\n    status?: { before: Status[], after: Status[] }\n  ) => {\n    const ids = Object.keys(newInstances);\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async (id) => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach((child) => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance,\n          }\n        });\n        after.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n\n  const onLoad = async () => {\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n\n    let result;\n    let initialData: any;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({ message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({ frames: props.image, imageData: result?.images as Image[] });\n    // preload image\n    setImagePreloader(loader(framesData.map((v) => v.url)));\n    // set frame images\n    setFrames(framesData);\n\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes: { [categoryKey: string]: CategoryPathShape } = {};\n        result.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height,\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData: { [key: string]: CategoryPathShape } = {};\n        initialData.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const { newInstances, categoryInstancesMap: newCategoryInstancesMap } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances: { [id: string]: InstanceAct } = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const { newInstances } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    saverRef.current?.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex: number, currentInstances: { [id: string]: InstanceAct } | undefined = instances, type?: CANVASSTATUS) => {\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    store.review.cancelUnfinishMissingReview();\n    const currentInstanceList = Object.values(currentInstances);\n    canvas.current?.cleanLayer();\n    canvas.current?.setMultiShapesUnselected();\n    imagePreloader?.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex,\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const { id, category, children: [{ name }] } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group?.type,\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const { updateShapes, updatedCategories: updatedCategoriesData } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n\n  const onSave = async (submit = true) => {\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({ message: loadError });\n      throw new Error(loadError);\n    }\n\n    saverRef.current?.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances: InstanceListItem[] = instanceList.filter((v) => v && v.notEmpty).map((instance) => {\n      const { id, category, number, displayColor, children } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map((group) => {\n          const { frames: groupFrames } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter((v) => !!v && v.count > 0).map((frameGroup) => {\n              if (frameGroup) {\n                const { frameIndex, count, shapes: groupShapes } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes: PointListItem[] | Rectangle[] = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach((key) => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point: PointListItem | undefined = groupShapes && (groupShapes as Points)[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        (newShapes as PointListItem[]).push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle: Rectangle | undefined = groupShapes && (groupShapes as CurrentShapes)[key];\n                      if (rectangle) (newShapes as Rectangle[]).push(rectangle);\n                    }\n                  });\n                }\n                if (\n                  checkMissingPoints &&\n                  frames[frameIndex].valid !== false &&\n                  groupInfo &&\n                  newShapes.length < groupInfo.count\n                ) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: ontologyInfo?.display_name || ontologyInfo?.class_name,\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({ message: errMsg });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: canvas.current?.imageCanvas?.width || imageSize?.width,\n      height: canvas.current?.imageCanvas?.height || imageSize?.height,\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map((pointCategory) => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory],\n      })),\n      images: frames,\n      statistics,\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes: {\n      [shape: string]: { rejected: number; approved: number, suspended: number, missed: number, total: number };\n    } = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0,\n    };\n    const reviews = store.review.reviews.filter((r) => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter((r) => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find((r) => r.shapeIds.indexOf(shapeId) >= 0);\n            if (review?.result === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if (review?.result === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return { objects, shapes: statShapes };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const { ontology } = store.ontology;\n    const data: Statistic = {\n      elements: [],\n      categories: ontology.map(({ class_name: className }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set(),\n    };\n\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, category, children } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0,\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(\n              ...frameShapes.map((s) => ({\n                instance: id,\n                shape,\n                frame: frame.frameIndex + 1,\n                category,\n                id: s.id || s.index,\n              }))\n            );\n          }\n        }\n      }\n    }\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({ category, shape, count, distinctCount }) => ({\n        category,\n        shape,\n        count,\n        distinctCount,\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size,\n    };\n  };\n\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n\n  const saveReviews = (type = 'submit') => {\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find((review) => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    saverRef.current?.disableLeaveCheck();\n    const missingReviews = toJS(store.review.missingReviews).map((r) => ({\n      ...r,\n      label: 'Missed',\n    }));\n    return props.jobProxy.saveReviews([...missingReviews], type === 'submit');\n  };\n\n  const handleSave = async () => {\n    const { toolMode } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n\n    try {\n      console.log('handleSave')\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({ message: formatMessage('SAVE_SUCCESS') });\n    } catch (e) {\n      notification.error({ message: formatMessage('SAVE_FAIL') });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const { hasCustomError, blockSubmitErrors } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n\n  const setSelectedShape = (id?: number | string, groupData?: Group) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const { instanceId, category, groupName, shapeType } = groupData;\n      if (instanceId !== selectedInstance?.id) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || ontologyGroup?.type || undefined,\n        groupName,\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n\n  const setNextEmptyShape = (shapeStatus: ShapeInfo = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let { id } = shapeStatus;\n      const { instanceId, groupName, shapeType } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const { range = [] } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            (id as number) += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id!) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n\n  const handleShapesChange = (\n    newShapes: UpdatedShape[],\n    groupsAttributes?: { instanceId: string, category: string, name: string, attributes: any }[],\n    status?: { before: Status[], after: Status[] }\n  ) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    const { instanceId, groupName } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData(newInstance?.category || '', groupName);\n    newInstance?.children.forEach((child) => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {},\n          };\n        };\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const { id, frameIndex, index, shape } = newShapes[i];\n          let oldShape;\n\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = (child.frames[frameIndex].shapes as Points)[index];\n            (child.frames[frameIndex].shapes as Points)[index] = {\n              ...oldShape,\n              ...shape as Point\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            (child.frames[frameIndex].shapes as CurrentShapes)[id] = {\n              ...oldShape,\n              ...shape as Rectangle\n            };\n          }\n\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        };\n        if (groupInfo?.label_config && currentGroup.count === groupInfo?.count && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, { instanceId, category: newInstance.category, groupName });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({ instanceId: id, name, category, attributes }) => {\n        const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId: id, category, groupName: name };\n        before.push({ type: 'group', status: { ...frameGroup } });\n        after.push({ type: 'group', status: { ...frameGroup, attributes } });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({ [instanceId]: newInstance }, { before, after });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n\n  const handleShapesRemove = (removeShapes: UpdatedShape[]) => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n\n    const changeInstances: { [id: string]: InstanceAct } = {};\n    const { instanceId, groupName } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance?.children.forEach((child) => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({ id, frameIndex, index }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete (child.frames[frameIndex].shapes as Points)[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({ [instanceId]: newInstance });\n    }\n  };\n\n  const togglePointsVisibility = (points: PointStatus[]) => {\n    const list: UpdatedShape[] = [];\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: { ...point, visible: !point.visible }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n\n  const setCategoryPathShape = (categoryKey: string, shapeType?: CategoryPathShape, _updatedShapes?: UpdatedShape[]) => {\n    const before: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: categoryPathShapes[categoryKey] },\n    }];\n    const after: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: shapeType },\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, { before, after });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n\n  const selectGroup = (id: string, groupName: string, isFit = true, groupData?: { category: string, shapeType: LandmarkEditType }) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus: ShapeInfo = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: groupData?.category || selectedShapeStatus.category,\n      groupName,\n      shapeType: groupData?.shapeType || undefined,\n      id: undefined\n    };\n    if (instance) {\n      const ontologyItem = store.ontology.ontology.find((v) => v.class_name === instance.category);\n      const group = ontologyItem?.children.find((v) => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = group?.type || undefined;\n      if (isDrawMode) {\n        if (group?.type === LandmarkEditType.KEYPOINT) {\n          const index = (group.categories && group.categories[0] && group.categories[0].range[0]) || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if (group?.type === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach((child) => {\n            if (child.name === groupName && child.frames[currentFrame]?.shapes) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      canvas.current?.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        canvas.current?.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n\n  const editShapeForm = () => {\n    const { instanceId, groupName, shapeType, id, category } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, (id as number));\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && currentOntologyGroup?.point_label_config) {\n        handleFormConfig(currentOntologyGroup.point_label_config, (point as Point).attributes || {}, { instanceId, category, groupName }, (id as number), point);\n      }\n    }\n  };\n\n  const editGroupForm = () => {\n    const { instanceId, groupName, category } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && currentOntologyGroup?.label_config) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, { instanceId, category, groupName });\n    }\n  };\n\n  const handleFormConfig = (config: FormConfig, values: { [attr: string]: any; }, group: Group, index?: number, point?: Point) => {\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point,\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    attributesRef.current?.showModal(title);\n  };\n\n  const getShapeLabel = (instanceId: string, category: string, groupName: string) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', { values: { frameIndex: currentFrame + 1 } })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n\n  const setAttributes = (values: any) => {\n    if (editFormObject) {\n      const { instanceId, category, groupName, index, point } = editFormObject;\n      const before: Status[] = [];\n      const after: Status[] = [];\n      const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId, category, groupName };\n      if ((index || index === 0) && point) {\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = { ...oldPoint, ...point, attributes: values };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({ type: 'shape', status: { ...frameGroup, index, shape: oldPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        after.push({ type: 'shape', status: { ...frameGroup, index, shape: newPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        canvas.current?.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName)?.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup?.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({ type: 'group', status: { ...frameGroup, attributes: oldAttrs } });\n          after.push({ type: 'group', status: { ...frameGroup, attributes: values } });\n          if (oldGroup?.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach((id) => {\n                canvas.current?.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode: AttributesMode, type = 'object') => {\n    canvas.current?.updatelabelVisible(activeMode, type);\n  };\n\n  const onSizeChange = () => {\n    canvas.current?.resizeShapes();\n  };\n\n  const onFilterChange = () => {\n    canvas.current?.updateFilters();\n  };\n\n  const onLabelModeChange = () => {\n    if (canvas.current?.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n\n  const onGridVisibleChange = () => {\n    if (canvas.current?.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n\n  const setFrameValid = (frame: number, valid: boolean) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics,\n  }));\n\n  return (\n    <Observer>\n      {() => (\n        <div className=\"landmark-annotation-app\">\n          <AutoSaver\n            ref={saverRef}\n            leaveCheck\n            data={{ instance: instances, reviews: store.review.qaWarnings }}\n            save={handleSave}\n          />\n          <Toolbar\n            readonly={readonly || loading || isReview}\n            isReview={isReview}\n            isPreview={readonly}\n            initialDataLength={Object.keys(initialInstances).length}\n            onAttributesModeChanges={onAttributesModeChanges}\n            onSizeChange={onSizeChange}\n            onFilterChange={onFilterChange}\n            onLabelModeChange={onLabelModeChange}\n            onGridVisibleChange={onGridVisibleChange}\n            onSave={handleSave}\n            handleUndo={handleUndo}\n            handleRedo={handleRedo}\n            setReview={setReview}\n            handleChangeDrawMode={handleChangeDrawMode}\n          />\n          <div\n            className=\"container\"\n            style={{\n              height: `calc(100% - ${(frames.length > 1 && currentFrame >= 0) ? `${frameControlHeight + 35}px` : '35px'})`,\n              transition: 'height 0.15s',\n            }}\n          >\n            <TabMenu\n              tabs={[\n                {\n                  title: formatMessage('MENU_INSTANCE'),\n                  key: 'instance',\n                  count: 0,\n                  content: (\n                    <SideMenus\n                      canvas={canvas.current}\n                      readonly={readonly || loading || isReview || !isDrawMode}\n                      loading={loading}\n                      instances={instanceList}\n                      currentFrame={currentFrame}\n                      instancesFrames={instancesFrames}\n                      selectedInstance={selectedInstance}\n                      selectedOntologyGroup={selectedOntologyGroup}\n                      instancesReviewsMap={instancesReviewsMap}\n                      addInstance={addInstance}\n                      selectGroup={selectGroup}\n                      addInstanceInFrame={addInstanceInFrame}\n                      removeInstanceFrames={removeInstanceFrames}\n                    />\n                  )\n                },\n                // {\n                //   title: formatMessage('MENU_WARNING'),\n                //   key: 'validator',\n                //   count: store.review.warnings.length,\n                //   content: (\n                //     <Validator\n                //       canvas={canvas.current}\n                //       ref={validatorRef}\n                //       instances={instances}\n                //       jobProxy={props.jobProxy}\n                //       getScriptResult={getScriptResult}\n                //       warnings={store.review.warnings || []}\n                //       setFrame={setFrame}\n                //       setSelectedShape={setSelectedShape}\n                //       selectGroup={selectGroup}\n                //       getInstance={getInstance}\n                //       saveResult={() => onSave(false)}\n                //     />\n                //   )\n                // }\n              ]}\n            />\n            {selectedInstance && ontologyGroup && !isReview && (\n              <Board\n                categories={categories}\n                categoryPathShapes={displayedCategoryPathShapes}\n                points={shapes}\n                ontologyGroup={ontologyGroup}\n                selectedShapeStatus={selectedShapeStatus}\n                annotated={annotatedPointOrShapeCount}\n                total={totalPointCount}\n                drawMode={isDrawMode}\n                setSelectedShape={(id) => {\n                  const { instanceId, category, groupName } = selectedShapeStatus;\n                  setSelectedShape(id, { instanceId, category, groupName });\n                }}\n                frameControlHeight={frameControlHeight}\n                readonly={loading}\n                instanceReviewsMap={store.review.frameReviewsMap[currentFrame]}\n              />\n            )}\n            <Canvas\n              ref={canvas}\n              readonly={readonly}\n              loading={loading}\n              isReview={isReview}\n              currentFrame={currentFrame}\n              image={frames[currentFrame]?.url}\n              categories={categories}\n              selectedInstance={selectedInstance}\n              selectedGroupName={selectedOntologyGroup}\n              ontologyGroup={ontologyGroup}\n              annotatedPointOrShapeCount={annotatedPointOrShapeCount}\n              updatedCategories={updatedCategories}\n              defaultInstances={defaultInstances}\n              selectedShapeStatus={selectedShapeStatus}\n              selectedShapeInfo={selectedShapeInfo}\n              changeLoading={setLoading}\n              selectGroup={selectGroup}\n              setSelectedShape={setSelectedShape}\n              handleShapesChange={handleShapesChange}\n              onCategoriesUpdated={onCategoriesUpdated}\n              handleShapesRemove={handleShapesRemove}\n              togglePointsVisibility={togglePointsVisibility}\n              setNextEmptyShape={setNextEmptyShape}\n              editShapeForm={editShapeForm}\n              editGroupForm={editGroupForm}\n              onSave={handleSave}\n              getInstance={getInstance}\n              categoryPathShapes={displayedCategoryPathShapes}\n              setCategoryPathShape={setCategoryPathShape}\n              handleUndo={handleUndo}\n              handleRedo={handleRedo}\n              setReview={setReview}\n              handleChangeDrawMode={handleChangeDrawMode}\n            />\n            <div className=\"arributes-panel\">\n              {selectedShapeStatus.groupName && (\n                <Information\n                  pointCategory={(categories[selectedCategoryIndex] || {}).name}\n                  point={selectedShapeStatus}\n                  annotated={annotatedPointOrShapeCount}\n                  total={totalPointCount}\n                />\n              )}\n              {frames[currentFrame]?.url && (\n                <FrameAttributes\n                  currentFrame={currentFrame}\n                  currentFrameValid={frames[currentFrame].valid}\n                  setFrameValid={setFrameValid}\n                />\n              )}\n            </div>\n            <Attributes\n              ref={attributesRef}\n              readonly={readonly || isReview || !isDrawMode}\n              config={formConfig}\n              values={formValues}\n              onValuesChange={setAttributes}\n            />\n          </div>\n          {(frames.length > 1 && currentFrame >= 0) && (\n            <FrameControl\n              frames={frames}\n              frameLoading={loading}\n              currentFrame={currentFrame}\n              categoryInstancesMap={displayedCategoryInstancesMap}\n              instancesReviewsMap={instancesReviewsMap}\n              instances={displayedInstances}\n              selectedInstance={selectedInstance}\n              selectedInstanceGroup={selectedOntologyGroup}\n              selectGroup={selectGroup}\n              setFrame={setFrame}\n              onHeightChange={setFrameControlHeight}\n            />\n          )}\n          {store.review.selectedReview && (\n            <QualityControl\n              review={store.review.selectedReview}\n              readonly={readonly || isDrawMode}\n              jobProxy={props.jobProxy}\n              selectedShapeStatus={selectedShapeStatus}\n              getShapeLabel={getShapeLabel}\n            />\n          )}\n          <Missing\n            readonly={readonly || isDrawMode}\n            jobProxy={props.jobProxy}\n          />\n        </div>\n      )}\n    </Observer>\n  );\n});\n\nexport default LandmarkAnnotation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}