{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/components/Attributes/index.tsx\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport { observer } from 'mobx-react';\nimport { Input, notification, Tooltip } from 'antd';\nimport { isEqual } from 'lodash';\nimport cx from 'classnames';\nimport EasyForm from '@appen-china/easy-form';\nimport { FieldControlType, OptionType } from '@appen-china/easy-form/es/types';\nimport store from '../../store/RootStore';\nimport { TagType } from '../../types';\nimport i18n from '../../locales';\nimport { triggerForm, bufferToWave } from '../../utils';\nimport { Robot, InsertTag, WrapTag } from '../../../common/icons';\nimport { APIForwardType } from '../../../../libs/JobProxy';\nimport { store as storage, wordCount, containsRTLLanguage } from '../../../../utils';\nimport './index.scss';\nwindow.translateDutationLimit = 2;\nconst {\n  TextArea\n} = Input;\nconst namespace = 'multi-audio-transcription';\nconst catchKey = 'hist';\nconst Attributes = ({\n  instance\n}) => {\n  const [fields, setFields] = useState([]);\n  const [inTranscribe, setInTranscribe] = useState(false);\n  const [attributes, setAttributes] = useState({});\n  const [text, setText] = useState('');\n  const textRef = useRef(null);\n  const {\n    ontology: {\n      segmentConfig\n    },\n    waveform: {\n      tagGroups,\n      wordTimestamps\n    },\n    setting: {\n      autoTranscription,\n      autoTranscriptionLanguage,\n      autoTranscriptionEndpoint\n    }\n  } = store;\n  useEffect(() => {\n    if (!isEqual(instance === null || instance === void 0 ? void 0 : instance.attributes, attributes) || fields.length === 0 && segmentConfig || !store.review.drawMode) {\n      setAttributes((instance === null || instance === void 0 ? void 0 : instance.attributes) || {});\n      const {\n        updatedFields\n      } = triggerForm(segmentConfig || {\n        fields: []\n      }, instance === null || instance === void 0 ? void 0 : instance.attributes);\n      const newFields = updatedFields.map(field => field.type === FieldControlType.CHECKBOX || field.type === FieldControlType.RADIO ? {\n        ...field,\n        optionType: OptionType.BUTTON,\n        readonly: !store.review.drawMode || field.readonly\n      } : field);\n      setFields(newFields);\n    }\n    if ((instance === null || instance === void 0 ? void 0 : instance.text) !== text) {\n      setText((instance === null || instance === void 0 ? void 0 : instance.text) || '');\n    }\n  }, [instance, store.review.drawMode]);\n  const changeSegment = values => {\n    const {\n      setUpdatedInstances\n    } = store.instance;\n    const newAttributes = {\n      ...instance.attributes,\n      ...values\n    };\n    setAttributes(newAttributes);\n    const newInstance = {\n      [instance.id]: {\n        ...instance,\n        attributes: newAttributes\n      }\n    };\n    setUpdatedInstances(newInstance);\n  };\n\n  // input text\n  const handleChangeValue = e => {\n    e.persist();\n    const {\n      value\n    } = e.target;\n    updateText(value);\n  };\n  const updateText = str => {\n    if (instance) {\n      const {\n        setUpdatedInstances\n      } = store.instance;\n      const newInstance = {\n        [instance.id]: {\n          ...instance,\n          text: str\n        }\n      };\n      setText(str);\n      setUpdatedInstances(newInstance);\n    }\n  };\n  const increaseCallHist = duration => {\n    try {\n      const count = storage.getStorage(namespace, catchKey) || 0;\n      storage.setStorage(namespace, catchKey, count + duration);\n      storage.cleanExpiredStorage(namespace);\n    } catch (e) {\n      // do nothing\n    }\n  };\n  const isCallLimitExceeded = () => {\n    const limit = store.waveform.duration * window.translateDutationLimit;\n    const count = storage.getStorage(namespace, catchKey) || 0;\n    return count > limit;\n  };\n  const handleAutoTranscribe = async () => {\n    try {\n      const {\n        channelIndex\n      } = instance;\n      let transcribed = false;\n      if (hasWordTimestamps(channelIndex)) {\n        transcribed = transcribeWithWordTimestamps();\n      }\n      if (!transcribed && autoTranscription && autoTranscriptionLanguage) {\n        if (isCallLimitExceeded()) {\n          notification.error({\n            message: i18n.translate('AUTO_TRANSCRIBE_EXCEEDS_LIMIT')\n          });\n        } else {\n          transcribed = await transcribe();\n        }\n      }\n      if (!transcribed) {\n        notification.error({\n          message: i18n.translate('AUTO_TRANSCRIBE_FAILURE')\n        });\n      }\n    } catch (e) {\n      console.log(e);\n      notification.error({\n        message: `${i18n.translate('AUTO_TRANSCRIBE_FAILURE')} error: ${e}`\n      });\n    }\n  };\n  const hasWordTimestamps = channelIndex => {\n    var _wordTimestamps$words, _wordTimestamps$words2;\n    return ((wordTimestamps === null || wordTimestamps === void 0 ? void 0 : (_wordTimestamps$words = wordTimestamps.words) === null || _wordTimestamps$words === void 0 ? void 0 : (_wordTimestamps$words2 = _wordTimestamps$words[channelIndex]) === null || _wordTimestamps$words2 === void 0 ? void 0 : _wordTimestamps$words2.length) || 0) > 0;\n  };\n  const transcribeWithWordTimestamps = () => {\n    const {\n      start,\n      end,\n      channelIndex\n    } = instance;\n    if (wordTimestamps) {\n      const words = [];\n      for (let i = 0; i < wordTimestamps.words[channelIndex].length; i += 1) {\n        const w = wordTimestamps.words[channelIndex][i];\n        if (w.start >= start && w.end <= end || w.start <= start && w.end >= start || w.start <= end && w.end >= end) {\n          words.push(w.word);\n        }\n        if (w.end > end) {\n          break;\n        }\n      }\n      const str = words.join(wordTimestamps.separator);\n      if (str === null || str === void 0 ? void 0 : str.trim()) {\n        updateText(str);\n        return true;\n      }\n    }\n    return false;\n  };\n  const transcribe = async () => {\n    let transcribed = false;\n    if (store.waveform.audioBuffer && autoTranscription && !inTranscribe) {\n      try {\n        var _store$jobProxy;\n        const {\n          audioBuffer\n        } = store.waveform;\n        const {\n          sampleRate,\n          numberOfChannels\n        } = audioBuffer;\n        const duration = instance.end - instance.start;\n        if (duration > 100) {\n          notification.error({\n            message: i18n.translate('AUTO_TRANSCRIBE_TOO_LONG')\n          });\n          return transcribed;\n        }\n        setInTranscribe(true);\n        notification.info({\n          message: i18n.translate('AUTO_TRANSCRIBE_START')\n        });\n        const frameCount = Math.ceil(sampleRate * duration);\n        const segmentBuffer = new AudioBuffer({\n          numberOfChannels,\n          sampleRate,\n          length: frameCount\n        });\n        const originChannelBuffer = audioBuffer.getChannelData(instance.channelIndex);\n        const segmentChannelBuffer = segmentBuffer.getChannelData(instance.channelIndex);\n        const startFrame = Math.floor(instance.start * sampleRate);\n        const endFrame = Math.min(startFrame + segmentChannelBuffer.length, originChannelBuffer.length);\n        const bufferArray = originChannelBuffer.subarray(startFrame, endFrame);\n        segmentChannelBuffer.set(bufferArray);\n        segmentBuffer.copyToChannel(segmentChannelBuffer, instance.channelIndex, 0);\n        const blob = bufferToWave(segmentBuffer, 0, segmentBuffer.length);\n        const formData = new FormData();\n        formData.append('file', blob);\n        formData.append('job_id', ((_store$jobProxy = store.jobProxy) === null || _store$jobProxy === void 0 ? void 0 : _store$jobProxy.jobId) || '');\n        formData.append('language', autoTranscriptionLanguage);\n        formData.append('duration', `${duration}`);\n        formData.append('endpoint', autoTranscriptionEndpoint);\n        const {\n          status,\n          data,\n          message = ''\n        } = await store.jobProxy.forwardAPI(APIForwardType.SPEECH_RECOGNIZE, formData);\n        setInTranscribe(false);\n        if (status === 200) {\n          updateText(data);\n          transcribed = true;\n          notification.success({\n            message: i18n.translate('AUTO_TRANSCRIBE_SUCCESS')\n          });\n        } else if (status === 500) {\n          notification.warn({\n            message: i18n.translate('AUTO_TRANSCRIBE_NO_MATCH')\n          });\n        } else {\n          notification.warn({\n            message: `${i18n.translate('AUTO_TRANSCRIBE_FAILURE')} message=${message}`\n          });\n        }\n        increaseCallHist(duration);\n      } catch (error) {\n        setInTranscribe(false);\n        console.log('Error:', error);\n        notification.error({\n          message: i18n.translate('AUTO_TRANSCRIBE_FAILURE')\n        });\n      }\n    }\n    return transcribed;\n  };\n  const handleStandaloneTag = (tag, type) => {\n    if (!store.review.drawMode || !textRef.current) return;\n    const domTextArea = textRef.current.resizableTextArea.textArea;\n    const txt = domTextArea.value;\n    const before = txt.substring(0, domTextArea.selectionStart);\n    const selected = txt.substring(domTextArea.selectionStart, domTextArea.selectionEnd);\n    const after = txt.substring(domTextArea.selectionEnd);\n    let newTxt = domTextArea.value;\n    let newSelection = before === null || before === void 0 ? void 0 : before.length;\n    if (type === TagType.STANDALONE) {\n      newSelection += tag.text.length;\n      newTxt = `${before}${tag.text}${after}`;\n    } else if (type === TagType.TAG) {\n      var _suffix;\n      newSelection += tag.prefix.length + (selected === null || selected === void 0 ? void 0 : selected.length) + (selected.length === 0 ? 0 : (_suffix = tag.suffix) === null || _suffix === void 0 ? void 0 : _suffix.length);\n      newTxt = `${before}${tag.prefix}${selected}${tag.suffix}${after}`;\n    }\n    updateText(newTxt);\n    const timer = setTimeout(() => {\n      clearTimeout(timer);\n      domTextArea.focus();\n      domTextArea.setSelectionRange(newSelection, newSelection);\n    }, 0);\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"attributes-pannel\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 246,\n      columnNumber: 5\n    }\n  }, fields && fields.length ? /*#__PURE__*/React.createElement(EasyForm, {\n    theme: \"dark\",\n    autoFocus: false,\n    footerVisible: false,\n    fields: fields,\n    conditions: segmentConfig === null || segmentConfig === void 0 ? void 0 : segmentConfig.conditions,\n    effects: segmentConfig === null || segmentConfig === void 0 ? void 0 : segmentConfig.effects,\n    rules: segmentConfig === null || segmentConfig === void 0 ? void 0 : segmentConfig.rules,\n    onChange: changeSegment,\n    onSubmit: () => {},\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 248,\n      columnNumber: 9\n    }\n  }) : null, /*#__PURE__*/React.createElement(\"div\", {\n    className: cx('attributes-label', {\n      required: instance.isTranslationRequired\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 260,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      marginRight: 5\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 265,\n      columnNumber: 9\n    }\n  }, i18n.translate('TRANSCRIPTION', {\n    values: {\n      count: text.length\n    }\n  })), i18n.translate('TRANSCRIPTION_WORDS', {\n    values: {\n      count: wordCount(text, store.config.wordCountItems)\n    }\n  }), (autoTranscription && autoTranscriptionLanguage || hasWordTimestamps(instance.channelIndex)) && /*#__PURE__*/React.createElement(\"span\", {\n    className: cx('transcribe', {\n      disabled: inTranscribe\n    }),\n    onClick: handleAutoTranscribe,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 273,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(Robot, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 279,\n      columnNumber: 13\n    }\n  }))), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"attributes-value\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 283,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(TextArea, {\n    ref: textRef,\n    value: text,\n    disabled: !store.review.drawMode,\n    onChange: handleChangeValue,\n    dir: containsRTLLanguage(text) ? 'rtl' : 'ltr',\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 284,\n      columnNumber: 9\n    }\n  })), tagGroups.length && store.review.drawMode ? /*#__PURE__*/React.createElement(\"div\", {\n    className: \"attributes-tags\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 293,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"attributes-tags-label\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 294,\n      columnNumber: 11\n    }\n  }, i18n.translate('TRANSCRIPTION_LABEL')), tagGroups.map((group, i) =>\n  /*#__PURE__*/\n  // eslint-disable-next-line react/no-array-index-key\n  React.createElement(\"div\", {\n    className: \"tags-group\",\n    key: `${group.name}_${i}`,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 298,\n      columnNumber: 15\n    }\n  }, /*#__PURE__*/React.createElement(Tooltip, {\n    title: group.name,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 299,\n      columnNumber: 17\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"tag-icon\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 300,\n      columnNumber: 19\n    }\n  }, group.type === TagType.STANDALONE ? /*#__PURE__*/React.createElement(InsertTag, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 301,\n      columnNumber: 58\n    }\n  }) : /*#__PURE__*/React.createElement(WrapTag, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 301,\n      columnNumber: 74\n    }\n  }))), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"tags\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 304,\n      columnNumber: 17\n    }\n  }, group.tags.map((tag, j) =>\n  /*#__PURE__*/\n  // eslint-disable-next-line react/no-array-index-key\n  React.createElement(Tooltip, {\n    title: tag.name,\n    key: `${group.name}_${i}_${j}`,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 308,\n      columnNumber: 23\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    className: cx('tag', {\n      standalone: group.type === TagType.STANDALONE,\n      disabled: !store.review.drawMode\n    }),\n    onClick: () => {\n      handleStandaloneTag(tag, group.type);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 309,\n      columnNumber: 25\n    }\n  }, tag.name))))))) : null);\n};\nexport default observer(Attributes);","map":{"version":3,"names":["React","useState","useEffect","useRef","observer","Input","notification","Tooltip","isEqual","cx","EasyForm","FieldControlType","OptionType","store","TagType","i18n","triggerForm","bufferToWave","Robot","InsertTag","WrapTag","APIForwardType","storage","wordCount","containsRTLLanguage","window","translateDutationLimit","TextArea","namespace","catchKey","Attributes","instance","fields","setFields","inTranscribe","setInTranscribe","attributes","setAttributes","text","setText","textRef","ontology","segmentConfig","waveform","tagGroups","wordTimestamps","setting","autoTranscription","autoTranscriptionLanguage","autoTranscriptionEndpoint","length","review","drawMode","updatedFields","newFields","map","field","type","CHECKBOX","RADIO","optionType","BUTTON","readonly","changeSegment","values","setUpdatedInstances","newAttributes","newInstance","id","handleChangeValue","e","persist","value","target","updateText","str","increaseCallHist","duration","count","getStorage","setStorage","cleanExpiredStorage","isCallLimitExceeded","limit","handleAutoTranscribe","channelIndex","transcribed","hasWordTimestamps","transcribeWithWordTimestamps","error","message","translate","transcribe","console","log","_wordTimestamps$words","_wordTimestamps$words2","words","start","end","i","w","push","word","join","separator","trim","audioBuffer","_store$jobProxy","sampleRate","numberOfChannels","info","frameCount","Math","ceil","segmentBuffer","AudioBuffer","originChannelBuffer","getChannelData","segmentChannelBuffer","startFrame","floor","endFrame","min","bufferArray","subarray","set","copyToChannel","blob","formData","FormData","append","jobProxy","jobId","status","data","forwardAPI","SPEECH_RECOGNIZE","success","warn","handleStandaloneTag","tag","current","domTextArea","resizableTextArea","textArea","txt","before","substring","selectionStart","selected","selectionEnd","after","newTxt","newSelection","STANDALONE","TAG","_suffix","prefix","suffix","timer","setTimeout","clearTimeout","focus","setSelectionRange","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","theme","autoFocus","footerVisible","conditions","effects","rules","onChange","onSubmit","required","isTranslationRequired","style","marginRight","config","wordCountItems","disabled","onClick","ref","dir","group","key","name","title","tags","j","standalone"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/components/Attributes/index.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { observer } from 'mobx-react';\nimport { Input, notification, Tooltip } from 'antd';\nimport { isEqual } from 'lodash';\nimport cx from 'classnames';\nimport EasyForm from '@appen-china/easy-form';\nimport { Field, FieldControlType, OptionType } from '@appen-china/easy-form/es/types';\nimport store from '../../store/RootStore';\nimport { Instance, TagType, Standalone, Tag } from '../../types';\nimport i18n from '../../locales';\nimport { triggerForm, bufferToWave } from '../../utils';\nimport { Robot, InsertTag, WrapTag } from '../../../common/icons';\nimport { APIForwardType } from '../../../../libs/JobProxy';\nimport { store as storage, wordCount, containsRTLLanguage } from '../../../../utils';\nimport './index.scss';\n\n(window as any).translateDutationLimit = 2;\nconst { TextArea } = Input;\n\ninterface AttributesProps {\n  instance: Instance;\n}\n\nconst namespace = 'multi-audio-transcription';\nconst catchKey = 'hist';\n\nconst Attributes = ({ instance }: AttributesProps) => {\n  const [fields, setFields] = useState<Field[]>([]);\n  const [inTranscribe, setInTranscribe] = useState(false);\n  const [attributes, setAttributes] = useState<{[key: string]: any}>({});\n  const [text, setText] = useState('');\n  const textRef = useRef<HTMLTextAreaElement>(null);\n  const {\n    ontology: { segmentConfig },\n    waveform: {\n      tagGroups,\n      wordTimestamps,\n    },\n    setting: {\n      autoTranscription,\n      autoTranscriptionLanguage,\n      autoTranscriptionEndpoint,\n    },\n  } = store;\n\n  useEffect(() => {\n    if (\n      !isEqual(instance?.attributes, attributes)\n      || (fields.length === 0 && segmentConfig)\n      || !store.review.drawMode\n    ) {\n      setAttributes(instance?.attributes || {});\n      const { updatedFields } = triggerForm(segmentConfig || { fields: [] }, instance?.attributes);\n      const newFields = updatedFields.map((field) => (field.type === FieldControlType.CHECKBOX || field.type === FieldControlType.RADIO ? {\n        ...field,\n        optionType: OptionType.BUTTON,\n        readonly: !store.review.drawMode || field.readonly,\n      } : field));\n      setFields(newFields);\n    }\n    if (instance?.text !== text) {\n      setText(instance?.text || '');\n    }\n  }, [instance, store.review.drawMode]);\n\n  const changeSegment = (values: any) => {\n    const { setUpdatedInstances } = store.instance;\n    const newAttributes = {\n      ...instance.attributes,\n      ...values,\n    };\n    setAttributes(newAttributes);\n    const newInstance: {[id:string]: Instance} = {\n      [instance.id]: {\n        ...instance,\n        attributes: newAttributes,\n      }\n    };\n    setUpdatedInstances(newInstance);\n  };\n\n  // input text\n  const handleChangeValue = (e: any) => {\n    e.persist();\n    const { value } = e.target;\n    updateText(value);\n  };\n\n  const updateText = (str: string) => {\n    if (instance) {\n      const { setUpdatedInstances } = store.instance;\n      const newInstance: {[id:string]: Instance} = {\n        [instance.id]: {\n          ...instance,\n          text: str,\n        }\n      };\n      setText(str);\n      setUpdatedInstances(newInstance);\n    }\n  };\n\n  const increaseCallHist = (duration: number) => {\n    try {\n      const count = storage.getStorage(namespace, catchKey) || 0;\n      storage.setStorage(namespace, catchKey, count + duration);\n      storage.cleanExpiredStorage(namespace);\n    } catch (e) {\n      // do nothing\n    }\n  };\n\n  const isCallLimitExceeded = () => {\n    const limit = store.waveform.duration * (window as any).translateDutationLimit;\n    const count = storage.getStorage(namespace, catchKey) || 0;\n    return count > limit;\n  };\n\n  const handleAutoTranscribe = async () => {\n    try {\n      const { channelIndex } = instance;\n      let transcribed = false;\n      if (hasWordTimestamps(channelIndex)) {\n        transcribed = transcribeWithWordTimestamps();\n      }\n      if (!transcribed && autoTranscription && autoTranscriptionLanguage) {\n        if (isCallLimitExceeded()) {\n          notification.error({ message: i18n.translate('AUTO_TRANSCRIBE_EXCEEDS_LIMIT') });\n        } else {\n          transcribed = await transcribe();\n        }\n      }\n      if (!transcribed) {\n        notification.error({ message: i18n.translate('AUTO_TRANSCRIBE_FAILURE') });\n      }\n    } catch (e) {\n      console.log(e);\n      notification.error({ message: `${i18n.translate('AUTO_TRANSCRIBE_FAILURE')} error: ${e}` });\n    }\n  };\n\n  const hasWordTimestamps = (channelIndex: number) => (wordTimestamps?.words?.[channelIndex]?.length || 0) > 0;\n\n  const transcribeWithWordTimestamps = () => {\n    const { start, end, channelIndex } = instance;\n    if (wordTimestamps) {\n      const words = [];\n      for (let i = 0; i < wordTimestamps.words[channelIndex].length; i += 1) {\n        const w = wordTimestamps.words[channelIndex][i];\n        if ((w.start >= start && w.end <= end) || (w.start <= start && w.end >= start) || (w.start <= end && w.end >= end)) {\n          words.push(w.word);\n        }\n        if (w.end > end) {\n          break;\n        }\n      }\n      const str = words.join(wordTimestamps.separator);\n      if (str?.trim()) {\n        updateText(str);\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const transcribe = async () => {\n    let transcribed = false;\n    if (store.waveform.audioBuffer && autoTranscription && !inTranscribe) {\n      try {\n        const { audioBuffer } = store.waveform;\n        const { sampleRate, numberOfChannels } = audioBuffer;\n        const duration = instance.end - instance.start;\n        if (duration > 100) {\n          notification.error({ message: i18n.translate('AUTO_TRANSCRIBE_TOO_LONG') });\n          return transcribed;\n        }\n        setInTranscribe(true);\n        notification.info({ message: i18n.translate('AUTO_TRANSCRIBE_START') });\n        const frameCount = Math.ceil(sampleRate * duration);\n        const segmentBuffer = new AudioBuffer({\n          numberOfChannels,\n          sampleRate,\n          length: frameCount,\n        });\n        const originChannelBuffer = audioBuffer.getChannelData(instance.channelIndex);\n        const segmentChannelBuffer = segmentBuffer.getChannelData(instance.channelIndex);\n        const startFrame = Math.floor(instance.start * sampleRate);\n        const endFrame = Math.min(startFrame + segmentChannelBuffer.length, originChannelBuffer.length);\n        const bufferArray = originChannelBuffer.subarray(startFrame, endFrame);\n        segmentChannelBuffer.set(bufferArray);\n        segmentBuffer.copyToChannel(segmentChannelBuffer, instance.channelIndex, 0);\n        const blob = bufferToWave(segmentBuffer, 0, segmentBuffer.length);\n\n        const formData = new FormData();\n        formData.append('file', blob);\n        formData.append('job_id', store.jobProxy?.jobId || '');\n        formData.append('language', autoTranscriptionLanguage!);\n        formData.append('duration', `${duration}`);\n        formData.append('endpoint', autoTranscriptionEndpoint);\n        const { status, data, message = '' } = await store.jobProxy!.forwardAPI(APIForwardType.SPEECH_RECOGNIZE, formData);\n        setInTranscribe(false);\n        if (status === 200) {\n          updateText(data);\n          transcribed = true;\n          notification.success({ message: i18n.translate('AUTO_TRANSCRIBE_SUCCESS') });\n        } else if (status === 500) {\n          notification.warn({ message: i18n.translate('AUTO_TRANSCRIBE_NO_MATCH') });\n        } else {\n          notification.warn({ message: `${i18n.translate('AUTO_TRANSCRIBE_FAILURE')} message=${message}` });\n        }\n        increaseCallHist(duration);\n      } catch (error) {\n        setInTranscribe(false);\n        console.log('Error:', error);\n        notification.error({ message: i18n.translate('AUTO_TRANSCRIBE_FAILURE') });\n      }\n    }\n    return transcribed;\n  };\n\n  const handleStandaloneTag = (tag: Tag | Standalone, type: TagType) => {\n    if (!store.review.drawMode || !textRef.current) return;\n    const domTextArea = (textRef.current as any).resizableTextArea.textArea as HTMLTextAreaElement;\n    const txt = domTextArea.value;\n    const before = txt.substring(0, domTextArea.selectionStart);\n    const selected = txt.substring(domTextArea.selectionStart, domTextArea.selectionEnd);\n    const after = txt.substring(domTextArea.selectionEnd);\n    let newTxt = domTextArea.value;\n    let newSelection = before?.length;\n    if (type === TagType.STANDALONE) {\n      newSelection += (tag as Standalone).text.length;\n      newTxt = `${before}${(tag as Standalone).text}${after}`;\n    } else if (type === TagType.TAG) {\n      newSelection += (tag as Tag).prefix.length + selected?.length + (selected.length === 0 ? 0 : (tag as Tag).suffix?.length);\n      newTxt = `${before}${(tag as Tag).prefix}${selected}${(tag as Tag).suffix}${after}`;\n    }\n    updateText(newTxt);\n    const timer = setTimeout(() => {\n      clearTimeout(timer);\n      domTextArea.focus();\n      domTextArea.setSelectionRange(newSelection, newSelection);\n    }, 0);\n  };\n\n  return (\n    <div className=\"attributes-pannel\">\n      {(fields && fields.length) ? (\n        <EasyForm\n          theme=\"dark\"\n          autoFocus={false}\n          footerVisible={false}\n          fields={fields}\n          conditions={segmentConfig?.conditions}\n          effects={segmentConfig?.effects}\n          rules={segmentConfig?.rules}\n          onChange={changeSegment}\n          onSubmit={() => {}}\n        />\n      ) : null}\n      <div\n        className={cx('attributes-label', {\n          required: instance.isTranslationRequired,\n        })}\n      >\n        <span style={{ marginRight: 5 }}>\n          {i18n.translate('TRANSCRIPTION', { values: { count: text.length } })}\n        </span>\n        {i18n.translate('TRANSCRIPTION_WORDS', { values: { count: wordCount(text, store.config.wordCountItems) } })}\n        {(\n          (autoTranscription && autoTranscriptionLanguage)\n          || hasWordTimestamps(instance.channelIndex)\n        ) && (\n          <span\n            className={cx('transcribe', {\n              disabled: inTranscribe,\n            })}\n            onClick={handleAutoTranscribe}\n          >\n            <Robot />\n          </span>\n        )}\n      </div>\n      <div className=\"attributes-value\">\n        <TextArea\n          ref={textRef}\n          value={text}\n          disabled={!store.review.drawMode}\n          onChange={handleChangeValue}\n          dir={containsRTLLanguage(text) ? 'rtl' : 'ltr'}\n        />\n      </div>\n      {(tagGroups.length && store.review.drawMode) ? (\n        <div className=\"attributes-tags\">\n          <div className=\"attributes-tags-label\">{i18n.translate('TRANSCRIPTION_LABEL')}</div>\n          {\n            tagGroups.map((group, i) => (\n              // eslint-disable-next-line react/no-array-index-key\n              <div className=\"tags-group\" key={`${group.name}_${i}`}>\n                <Tooltip title={group.name}>\n                  <div className=\"tag-icon\">\n                    {group.type === TagType.STANDALONE ? <InsertTag /> : <WrapTag />}\n                  </div>\n                </Tooltip>\n                <div className=\"tags\">\n                  {\n                    (group.tags as any[]).map((tag, j) => (\n                      // eslint-disable-next-line react/no-array-index-key\n                      <Tooltip title={tag.name} key={`${group.name}_${i}_${j}`}>\n                        <span\n                          className={cx('tag', {\n                            standalone: group.type === TagType.STANDALONE,\n                            disabled: !store.review.drawMode\n                          })}\n                          onClick={() => { handleStandaloneTag(tag, group.type); }}\n                        >\n                          {tag.name}\n                        </span>\n                      </Tooltip>\n                    ))\n                  }\n                </div>\n              </div>\n            ))\n          }\n        </div>\n      ) : null}\n    </div>\n  );\n};\n\nexport default observer(Attributes);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}