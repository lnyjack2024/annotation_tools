{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx\";\nimport React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport { toJS } from 'mobx';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { LandmarkEditType, DELETETYPE, ReviewResult } from './types';\nimport { fetchResultByUrl } from './request';\nimport loader from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport { initInstances, loadInstancesFromResult, getFrameShapes, parseFramesByPaylod, getInstanceFrames } from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nimport Missing from './components/QualityControl/Missing';\nnotification.config({\n  top: 60\n});\nvar CANVASSTATUS = /*#__PURE__*/function (CANVASSTATUS) {\n  CANVASSTATUS[\"INITIAL\"] = \"initial\";\n  CANVASSTATUS[\"LANDMARK\"] = \"landmark\";\n  return CANVASSTATUS;\n}(CANVASSTATUS || {});\nconst LandmarkAnnotation = forwardRef((props, ref) => {\n  const store = useLocalObservable(() => rootStore);\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState(78);\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState('');\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState({});\n  const [updatedCategories, setUpdatedCategories] = useAsyncState([]);\n  const [defaultInstances, setDefaultInstances] = useAsyncState({});\n  const [instances, setInstances] = useAsyncState({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n  const [loading, setLoading] = useState(false);\n  const [formConfig, setFormConfig] = useState(null);\n  const [formValues, setFormValues] = useState(null);\n  const [imageSize, setImageSize] = useState({\n    width: 0,\n    height: 0\n  });\n  const [editFormObject, setEditFormObject] = useState(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState({});\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef(null);\n  const canvas = useRef(null);\n  const isDrawMode = useMemo(() => store.review.drawMode, [store.review.drawMode]);\n  const displayedInstances = useMemo(() => isReview ? initialInstances : instances, [isReview, initialInstances, instances]);\n  const instanceIds = useMemo(() => Object.keys(displayedInstances), [displayedInstances]);\n  const instanceList = useMemo(() => Object.values(displayedInstances).filter(v => !!v), [displayedInstances]);\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap = {};\n    instanceList.forEach(({\n      category,\n      id,\n      number\n    }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n  const displayedCategoryInstancesMap = useMemo(() => isReview ? initialCategoryInstancesMap : categoryInstancesMap, [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n  const displayedCategoryPathShapes = useMemo(() => isReview ? initialCategoryPathShapes : categoryPathShapes, [isReview, initialCategoryPathShapes, categoryPathShapes]);\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    return ontologyItem;\n  });\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find(group => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n  const categories = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.categories) || [], [ontologyGroup]);\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.id;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ? categories.findIndex(c => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) : -1;\n  }, [selectedShapeStatus, categories]);\n  const instancesFrames = useMemo(() => {\n    const items = {};\n    instanceList.forEach(instance => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n  const shapes = useMemo(() => {\n    var _selectedInstance$chi;\n    const group = selectedInstance === null || selectedInstance === void 0 ? void 0 : (_selectedInstance$chi = selectedInstance.children.find(g => g.name === selectedOntologyGroup)) === null || _selectedInstance$chi === void 0 ? void 0 : _selectedInstance$chi.frames[currentFrame];\n    return group && group.shapes || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n  const selectedShapeInfo = useMemo(() => {\n    let info = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        displayColor: (selectedOntology === null || selectedOntology === void 0 ? void 0 : selectedOntology.display_color) || ''\n      };\n      if ((ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        var _categories$selectedC;\n        info = {\n          ...info,\n          pointCategory: (_categories$selectedC = categories[selectedCategoryIndex]) === null || _categories$selectedC === void 0 ? void 0 : _categories$selectedC.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n  const annotatedPointOrShapeCount = useMemo(() => Object.entries(shapes).filter(([, v]) => v !== undefined).length, [shapes]);\n  const totalPointCount = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.count) || 0, [ontologyGroup]);\n  const instancesReviewsMap = useObserver(() => {\n    const map = {};\n    store.review.reviews.forEach(review => {\n      var _instances$instanceId;\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        shapeIds,\n        result\n      } = review;\n      const category = (_instances$instanceId = instances[instanceId]) === null || _instances$instanceId === void 0 ? void 0 : _instances$instanceId.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0\n        };\n      }\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n  useEffect(() => {\n    onLoad();\n  }, []);\n  useEffect(() => {\n    if (selectedShapeInfo === null || selectedShapeInfo === void 0 ? void 0 : selectedShapeInfo.instanceId) {\n      store.review.setSelectedMissingReview();\n    }\n  }, [selectedShapeInfo]);\n  const getInstance = instanceId => displayedInstances[instanceId];\n  const getGroup = (instanceId, groupName, frameIndex = currentFrame) => {\n    var _instance$children$fi;\n    const instance = getInstance(instanceId);\n    const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[frameIndex];\n    return group;\n  };\n  const getShape = (instanceId, groupName, id, frameIndex = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? group.shapes[id] : group.shapes[id]);\n  };\n  const setInstance = (id, instance) => {\n    setInstances({\n      ...instances,\n      [id]: instance\n    });\n  };\n  const setShape = (frameIndex, instanceId, groupName, id, shapeType, shape) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      var _group;\n      let group = instance.children.find(g => g.name === groupName);\n      let currentGroup = (_group = group) === null || _group === void 0 ? void 0 : _group.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = currentGroup.shapes[id];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = currentGroup.shapes[id];\n      }\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete currentGroup.shapes[id];\n        } else {\n          delete currentGroup.shapes[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n        }\n        currentGroup.shapes = {\n          ...currentGroup.shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === groupInfo.count && !currentGroup.attributes) {\n        handleFormConfig(groupInfo.label_config, {}, {\n          instanceId,\n          category: instance.category,\n          groupName\n        });\n      }\n    }\n  };\n  const updateStatus = async (curr, prev) => {\n    let newUpdatedShapes = [];\n    let newUpdatedCategories = [];\n    let updatedHandles = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const {\n          frameIndex,\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        let keyObj;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = {\n            index\n          };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = {\n            id\n          };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({\n            ...frameGroup,\n            ...keyObj,\n            shapeType\n          });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          const {\n            updateShapes\n          } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          const instanceIndex = instanceIds.findIndex(v => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          frameIndex,\n          groupName,\n          attributes\n        } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n          if (newInstance && newGroup) {\n            newGroup.frames[frameIndex].attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const {\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType,\n          shape,\n          frameIndex\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape;\n            const {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              attributes\n            } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex(p => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: {\n                  ...point.position\n                }\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                index,\n                shape: updateShape,\n                shapeType\n              });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape;\n            const {\n              displayColor,\n              visible,\n              x,\n              y,\n              width,\n              height\n            } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible\n            };\n            const updateIndex = newUpdatedShapes.findIndex(rect => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                id,\n                shape: updateRectangle,\n                shapeType\n              });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const {\n          frameIndex,\n          pointCategory,\n          shape\n        } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3]\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const {\n            updateShapes,\n            updatedCategories: newCategories\n          } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          newUpdatedCategories = [...newUpdatedCategories, ...newCategories];\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          groupName,\n          attributes,\n          frameIndex\n        } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach(id => {\n            var _canvas$current;\n            const attrLayer = (_canvas$current = canvas.current) === null || _canvas$current === void 0 ? void 0 : _canvas$current.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              var _canvas$current2;\n              (_canvas$current2 = canvas.current) === null || _canvas$current2 === void 0 ? void 0 : _canvas$current2.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          newGroup.frames[frameIndex].attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({\n          message: 'Undo successfully.'\n        });\n      }\n    }\n  };\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({\n          message: 'Redo successfully.'\n        });\n      }\n    }\n  };\n  const handleChangeDrawMode = mode => {\n    if (store.review.isEditable) {\n      var _canvas$current3;\n      (_canvas$current3 = canvas.current) === null || _canvas$current3 === void 0 ? void 0 : _canvas$current3.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(undefined, {\n          instanceId,\n          category,\n          groupName\n        });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n  const loadInitialData = async () => {\n    let data;\n    const {\n      initial_result: initialResult\n    } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n  const addInstance = async ontologyName => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter(v => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n      const children = ontologyItem.children.map(v => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({\n        [id]: instance\n      });\n      await handleInstanceChange({\n        [id]: instance\n      });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, {\n          category: ontologyName,\n          shapeType: ontologyItem.children[0].type\n        });\n      }\n    }\n  };\n  const addInstanceInFrame = (instanceId, groupName) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex(group => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame;\n          Object.keys(newInstance.children[groupIdx].frames).forEach(i => {\n            const index = Number(i);\n            const frame = {\n              ...newInstance.children[groupIdx].frames[index]\n            };\n            frame.shapes = {\n              ...frame.shapes\n            };\n            if ((frame === null || frame === void 0 ? void 0 : frame.count) && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx;\n        Object.keys(instancesFrames[instanceId]).forEach(i => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach(group => {\n            const copyFrame = {\n              ...group.frames[copyFrameIdx]\n            };\n            copyFrame.shapes = {\n              ...copyFrame.shapes\n            };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const {\n        updateShapes,\n        updatedCategories: newUpdatedCategories\n      } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n  const removeInstanceFrames = (type, instance, name) => {\n    if (instance) {\n      let delShapes = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance, frameIndex) => {\n        updateInstance.children.forEach(group => {\n          if (name && name === group.name || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= group.frames[frameIndex].count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const {\n          updateShapes\n        } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({\n          length: frames.length - diffFrame\n        }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const {\n            updateShapes\n          } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [...delShapes, ...updateShapes];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter(v => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({\n        [newInstance.id]: newInstance\n      });\n    }\n  };\n  const handleInstanceChange = async (newInstances, status) => {\n    const ids = Object.keys(newInstances);\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async id => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach(child => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance\n          }\n        });\n        after.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n  const onLoad = async () => {\n    var _result, _saverRef$current;\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n    let result;\n    let initialData;\n    let initInstancesData;\n    try {\n      result = {\n        \"auditId\": \"8561.29.audit\",\n        \"width\": 830,\n        \"height\": 788,\n        \"instances\": [{\n          \"id\": \"1d209f11-f04d-4658-b3ce-2e54856174dd\",\n          \"category\": \"object\",\n          \"number\": 1,\n          \"displayColor\": \"#96dd4f\",\n          \"children\": [{\n            \"name\": \"person\",\n            \"shapeType\": \"rectangle\",\n            \"count\": 1,\n            \"frames\": [{\n              \"frameIndex\": 0,\n              \"count\": 1,\n              \"shapes\": [{\n                \"x\": 261.10877843960554,\n                \"y\": 356.2325283969725,\n                \"width\": 62.838915470494385,\n                \"height\": 135.93724571168195,\n                \"displayColor\": \"#96dd4f\",\n                \"id\": \"4e0b62bd-ac96-4d48-832d-23b26b84b203\",\n                \"visible\": true\n              }],\n              \"attributes\": {}\n            }]\n          }, {\n            \"name\": \"body\",\n            \"shapeType\": \"rectangle\",\n            \"count\": 1,\n            \"frames\": [{\n              \"frameIndex\": 0,\n              \"count\": 1,\n              \"shapes\": [{\n                \"x\": 473.2221788236826,\n                \"y\": 376.62952729011516,\n                \"width\": 71.94414607948454,\n                \"height\": 122.72824919441462,\n                \"displayColor\": \"#96dd4f\",\n                \"id\": \"a7ac1ff9-4e8c-4b50-90ad-c445115d7780\",\n                \"visible\": true\n              }],\n              \"attributes\": {\n                \"ignored\": \"micro_objcet\"\n              }\n            }]\n          }, {\n            \"name\": \"Keypoint\",\n            \"shapeType\": \"keypoint\",\n            \"count\": 17,\n            \"frames\": [{\n              \"frameIndex\": 0,\n              \"count\": 17,\n              \"shapes\": [{\n                \"pointCategory\": \"鼻尖\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 363.18995540800046,\n                  \"y\": 369.57617963526366\n                },\n                \"visible\": true,\n                \"index\": 0\n              }, {\n                \"pointCategory\": \"左眼中心\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 399.867363213228,\n                  \"y\": 375.21885775914484\n                },\n                \"visible\": true,\n                \"index\": 1\n              }, {\n                \"pointCategory\": \"右眼中心\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 82.22305764411037,\n                  \"y\": 372.07114095718606\n                },\n                \"visible\": true,\n                \"index\": 2\n              }, {\n                \"pointCategory\": \"右肩\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 723.1094619666052,\n                  \"y\": 522.3968939131655\n                },\n                \"visible\": true,\n                \"index\": 6\n              }, {\n                \"pointCategory\": \"左手腕\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 682.0718028838332,\n                  \"y\": 440.32157574762186\n                },\n                \"visible\": true,\n                \"index\": 9\n              }, {\n                \"pointCategory\": \"脸框的顶端（人脸框的顶部中点）\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 356.0083650685155,\n                  \"y\": 490.31025420305224\n                },\n                \"visible\": true,\n                \"index\": 18\n              }, {\n                \"pointCategory\": \"左眉毛中点\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 412.4351463073268,\n                  \"y\": 644.2014757634466\n                },\n                \"visible\": true,\n                \"index\": 19\n              }, {\n                \"pointCategory\": \"右眉毛中点\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 417.5648536926733,\n                  \"y\": 510.8290837444381\n                },\n                \"visible\": true,\n                \"index\": 20\n              }, {\n                \"pointCategory\": \"左嘴角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 548.3723920190087,\n                  \"y\": 705.7579643876045\n                },\n                \"visible\": true,\n                \"index\": 21\n              }, {\n                \"pointCategory\": \"右嘴角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 427.82426846336625,\n                  \"y\": 690.368842231565\n                },\n                \"visible\": true,\n                \"index\": 22\n              }, {\n                \"pointCategory\": \"头框的底端（正面对应下巴位置，背面对应颈部上端位置）\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 294.4518764443577,\n                  \"y\": 615.9880851440411\n                },\n                \"visible\": true,\n                \"index\": 23\n              }, {\n                \"pointCategory\": \"左眼左角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 804.8577612863328,\n                  \"y\": 669.8500126901791\n                },\n                \"visible\": true,\n                \"index\": 24\n              }, {\n                \"pointCategory\": \"左眼右角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 539.9853204439672,\n                  \"y\": 114.48288460201236\n                },\n                \"visible\": true,\n                \"index\": 25\n              }, {\n                \"pointCategory\": \"左眼上角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 497.76395177946284,\n                  \"y\": 520.4184299497925\n                },\n                \"visible\": true,\n                \"index\": 26\n              }, {\n                \"pointCategory\": \"左眼下角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 499.0463786257995,\n                  \"y\": 565.3033695715744\n                },\n                \"visible\": true,\n                \"index\": 27\n              }, {\n                \"pointCategory\": \"右眼左角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 630.7747290303682,\n                  \"y\": 435.19186836227533\n                },\n                \"visible\": true,\n                \"index\": 28\n              }, {\n                \"pointCategory\": \"右眼右角\",\n                \"isKeyPoint\": false,\n                \"position\": {\n                  \"x\": 340.946261758292,\n                  \"y\": 657.0517127785108\n                },\n                \"visible\": true,\n                \"index\": 29\n              }]\n            }]\n          }]\n        }],\n        \"handles\": [],\n        \"categoryPathShapes\": [],\n        \"images\": [{\n          \"url\": \"https://appen-tool-test.oss-cn-zhangjiakou.aliyuncs.com/sample-data/image-2D/person1.png\",\n          \"valid\": true,\n          \"index\": 0\n        }],\n        \"statistics\": \"https://onpremise-test.appendata.com/api-gw/oss/onpremise-test/8592/8592.786310_2025-06-05T102232Z.29.result.stat.json\"\n      };\n      // result = await props.jobProxy.loadResult();\n      // initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({\n        message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({\n      frames: props.image,\n      imageData: (_result = result) === null || _result === void 0 ? void 0 : _result.images\n    });\n    // preload image\n    setImagePreloader(loader(framesData.map(v => v.url)));\n    // set frame images\n    setFrames(framesData);\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      }\n      // else if (result.points) {\n      //   initInstancesData = initInstances(result.points, framesData.length);\n      // }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes = {};\n        result.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData = {};\n        initialData.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const {\n        newInstances,\n        categoryInstancesMap: newCategoryInstancesMap\n      } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const {\n        newInstances\n      } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    (_saverRef$current = saverRef.current) === null || _saverRef$current === void 0 ? void 0 : _saverRef$current.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex, currentInstances = instances, type) => {\n    var _canvas$current4, _canvas$current5;\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    store.review.cancelUnfinishMissingReview();\n    const currentInstanceList = Object.values(currentInstances);\n    (_canvas$current4 = canvas.current) === null || _canvas$current4 === void 0 ? void 0 : _canvas$current4.cleanLayer();\n    (_canvas$current5 = canvas.current) === null || _canvas$current5 === void 0 ? void 0 : _canvas$current5.setMultiShapesUnselected();\n    imagePreloader === null || imagePreloader === void 0 ? void 0 : imagePreloader.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const {\n        id,\n        category,\n        children: [{\n          name\n        }]\n      } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group === null || group === void 0 ? void 0 : group.type\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const {\n      updateShapes,\n      updatedCategories: updatedCategoriesData\n    } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n  const onSave = async (submit = true) => {\n    var _saverRef$current2, _canvas$current6, _canvas$current6$imag, _canvas$current7, _canvas$current7$imag;\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({\n        message: loadError\n      });\n      throw new Error(loadError);\n    }\n    (_saverRef$current2 = saverRef.current) === null || _saverRef$current2 === void 0 ? void 0 : _saverRef$current2.disableLeaveCheck();\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances = instanceList.filter(v => v && v.notEmpty).map(instance => {\n      const {\n        id,\n        category,\n        number,\n        displayColor,\n        children\n      } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map(group => {\n          const {\n            frames: groupFrames\n          } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter(v => !!v && v.count > 0).map(frameGroup => {\n              if (frameGroup) {\n                const {\n                  frameIndex,\n                  count,\n                  shapes: groupShapes\n                } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach(key => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point = groupShapes && groupShapes[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        newShapes.push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle = groupShapes && groupShapes[key];\n                      if (rectangle) newShapes.push(rectangle);\n                    }\n                  });\n                }\n                if (checkMissingPoints && frames[frameIndex].valid !== false && groupInfo && newShapes.length < groupInfo.count) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.display_name) || (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.class_name),\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({\n                    message: errMsg\n                  });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: ((_canvas$current6 = canvas.current) === null || _canvas$current6 === void 0 ? void 0 : (_canvas$current6$imag = _canvas$current6.imageCanvas) === null || _canvas$current6$imag === void 0 ? void 0 : _canvas$current6$imag.width) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.width),\n      height: ((_canvas$current7 = canvas.current) === null || _canvas$current7 === void 0 ? void 0 : (_canvas$current7$imag = _canvas$current7.imageCanvas) === null || _canvas$current7$imag === void 0 ? void 0 : _canvas$current7$imag.height) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.height),\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map(pointCategory => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory]\n      })),\n      images: frames,\n      statistics\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0\n    };\n    const reviews = store.review.reviews.filter(r => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter(r => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find(r => r.shapeIds.indexOf(shapeId) >= 0);\n            if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return {\n      objects,\n      shapes: statShapes\n    };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const {\n      ontology\n    } = store.ontology;\n    const data = {\n      elements: [],\n      categories: ontology.map(({\n        class_name: className\n      }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set()\n    };\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const {\n        id,\n        category,\n        children\n      } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(...frameShapes.map(s => ({\n              instance: id,\n              shape,\n              frame: frame.frameIndex + 1,\n              category,\n              id: s.id || s.index\n            })));\n          }\n        }\n      }\n    }\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({\n        category,\n        shape,\n        count,\n        distinctCount\n      }) => ({\n        category,\n        shape,\n        count,\n        distinctCount\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size\n    };\n  };\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n  const saveReviews = (type = 'submit') => {\n    var _saverRef$current3;\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find(review => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    (_saverRef$current3 = saverRef.current) === null || _saverRef$current3 === void 0 ? void 0 : _saverRef$current3.disableLeaveCheck();\n    const missingReviews = toJS(store.review.missingReviews).map(r => ({\n      ...r,\n      label: 'Missed'\n    }));\n    return props.jobProxy.saveReviews([...missingReviews], type === 'submit');\n  };\n  const handleSave = async () => {\n    const {\n      toolMode\n    } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n    try {\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({\n        message: formatMessage('SAVE_SUCCESS')\n      });\n    } catch (e) {\n      notification.error({\n        message: formatMessage('SAVE_FAIL')\n      });\n    }\n  };\n  const setSelectedShape = (id, groupData) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        shapeType\n      } = groupData;\n      if (instanceId !== (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.id)) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        groupName\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n  const setNextEmptyShape = (shapeStatus = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let {\n        id\n      } = shapeStatus;\n      const {\n        instanceId,\n        groupName,\n        shapeType\n      } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const {\n            range = []\n          } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            id += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n  const handleShapesChange = (newShapes, groupsAttributes, status) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    const {\n      instanceId,\n      groupName\n    } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData((newInstance === null || newInstance === void 0 ? void 0 : newInstance.category) || '', groupName);\n    newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          };\n        }\n        ;\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const {\n            id,\n            frameIndex,\n            index,\n            shape\n          } = newShapes[i];\n          let oldShape;\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = child.frames[frameIndex].shapes[index];\n            child.frames[frameIndex].shapes[index] = {\n              ...oldShape,\n              ...shape\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = child.frames[frameIndex].shapes[id];\n            child.frames[frameIndex].shapes[id] = {\n              ...oldShape,\n              ...shape\n            };\n          }\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        }\n        ;\n        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.count) && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, {\n            instanceId,\n            category: newInstance.category,\n            groupName\n          });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({\n        instanceId: id,\n        name,\n        category,\n        attributes\n      }) => {\n        const frameGroup = {\n          frameIndex: currentFrame,\n          instanceId: id,\n          category,\n          groupName: name\n        };\n        before.push({\n          type: 'group',\n          status: {\n            ...frameGroup\n          }\n        });\n        after.push({\n          type: 'group',\n          status: {\n            ...frameGroup,\n            attributes\n          }\n        });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({\n        [instanceId]: newInstance\n      }, {\n        before,\n        after\n      });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n  const handleShapesRemove = removeShapes => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n    const changeInstances = {};\n    const {\n      instanceId,\n      groupName\n    } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({\n            id,\n            frameIndex,\n            index\n          }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete child.frames[frameIndex].shapes[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete child.frames[frameIndex].shapes[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n    }\n  };\n  const togglePointsVisibility = points => {\n    const list = [];\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: {\n            ...point,\n            visible: !point.visible\n          }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n  const setCategoryPathShape = (categoryKey, shapeType, _updatedShapes) => {\n    const before = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: categoryPathShapes[categoryKey]\n      }\n    }];\n    const after = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: shapeType\n      }\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, {\n        before,\n        after\n      });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n  const selectGroup = (id, groupName, isFit = true, groupData) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: (groupData === null || groupData === void 0 ? void 0 : groupData.category) || selectedShapeStatus.category,\n      groupName,\n      shapeType: (groupData === null || groupData === void 0 ? void 0 : groupData.shapeType) || undefined,\n      id: undefined\n    };\n    if (instance) {\n      var _canvas$current8;\n      const ontologyItem = store.ontology.ontology.find(v => v.class_name === instance.category);\n      const group = ontologyItem === null || ontologyItem === void 0 ? void 0 : ontologyItem.children.find(v => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = (group === null || group === void 0 ? void 0 : group.type) || undefined;\n      if (isDrawMode) {\n        if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.KEYPOINT) {\n          const index = group.categories && group.categories[0] && group.categories[0].range[0] || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach(child => {\n            var _child$frames$current;\n            if (child.name === groupName && ((_child$frames$current = child.frames[currentFrame]) === null || _child$frames$current === void 0 ? void 0 : _child$frames$current.shapes)) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      (_canvas$current8 = canvas.current) === null || _canvas$current8 === void 0 ? void 0 : _canvas$current8.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        var _canvas$current9;\n        (_canvas$current9 = canvas.current) === null || _canvas$current9 === void 0 ? void 0 : _canvas$current9.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n  const editShapeForm = () => {\n    const {\n      instanceId,\n      groupName,\n      shapeType,\n      id,\n      category\n    } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, id);\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.point_label_config)) {\n        handleFormConfig(currentOntologyGroup.point_label_config, point.attributes || {}, {\n          instanceId,\n          category,\n          groupName\n        }, id, point);\n      }\n    }\n  };\n  const editGroupForm = () => {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.label_config)) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, {\n        instanceId,\n        category,\n        groupName\n      });\n    }\n  };\n  const handleFormConfig = (config, values, group, index, point) => {\n    var _attributesRef$curren;\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    (_attributesRef$curren = attributesRef.current) === null || _attributesRef$curren === void 0 ? void 0 : _attributesRef$curren.showModal(title);\n  };\n  const getShapeLabel = (instanceId, category, groupName) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', {\n          values: {\n            frameIndex: currentFrame + 1\n          }\n        })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n  const setAttributes = values => {\n    if (editFormObject) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        index,\n        point\n      } = editFormObject;\n      const before = [];\n      const after = [];\n      const frameGroup = {\n        frameIndex: currentFrame,\n        instanceId,\n        category,\n        groupName\n      };\n      if ((index || index === 0) && point) {\n        var _canvas$current10;\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = {\n          ...oldPoint,\n          ...point,\n          attributes: values\n        };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: oldPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        after.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: newPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        (_canvas$current10 = canvas.current) === null || _canvas$current10 === void 0 ? void 0 : _canvas$current10.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        var _newInstance$children;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : (_newInstance$children = newInstance.children.find(v => v.name === groupName)) === null || _newInstance$children === void 0 ? void 0 : _newInstance$children.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: oldAttrs\n            }\n          });\n          after.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: values\n            }\n          });\n          if (oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach(id => {\n                var _canvas$current11;\n                (_canvas$current11 = canvas.current) === null || _canvas$current11 === void 0 ? void 0 : _canvas$current11.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode, type = 'object') => {\n    var _canvas$current12;\n    (_canvas$current12 = canvas.current) === null || _canvas$current12 === void 0 ? void 0 : _canvas$current12.updatelabelVisible(activeMode, type);\n  };\n  const onSizeChange = () => {\n    var _canvas$current13;\n    (_canvas$current13 = canvas.current) === null || _canvas$current13 === void 0 ? void 0 : _canvas$current13.resizeShapes();\n  };\n  const onFilterChange = () => {\n    var _canvas$current14;\n    (_canvas$current14 = canvas.current) === null || _canvas$current14 === void 0 ? void 0 : _canvas$current14.updateFilters();\n  };\n  const onLabelModeChange = () => {\n    var _canvas$current15;\n    if ((_canvas$current15 = canvas.current) === null || _canvas$current15 === void 0 ? void 0 : _canvas$current15.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n  const onGridVisibleChange = () => {\n    var _canvas$current16;\n    if ((_canvas$current16 = canvas.current) === null || _canvas$current16 === void 0 ? void 0 : _canvas$current16.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n  const setFrameValid = (frame, valid) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics\n  }));\n  return /*#__PURE__*/React.createElement(Observer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 1817,\n      columnNumber: 5\n    }\n  }, () => {\n    var _frames$currentFrame, _frames$currentFrame2;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"landmark-annotation-app\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1819,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(AutoSaver, {\n      ref: saverRef,\n      leaveCheck: true,\n      data: {\n        instance: instances,\n        reviews: store.review.qaWarnings\n      },\n      save: handleSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1820,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(Toolbar, {\n      readonly: readonly || loading || isReview,\n      isReview: isReview,\n      isPreview: readonly,\n      initialDataLength: Object.keys(initialInstances).length,\n      onAttributesModeChanges: onAttributesModeChanges,\n      onSizeChange: onSizeChange,\n      onFilterChange: onFilterChange,\n      onLabelModeChange: onLabelModeChange,\n      onGridVisibleChange: onGridVisibleChange,\n      onSave: handleSave,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1826,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"container\",\n      style: {\n        height: `calc(100% - ${frames.length > 1 && currentFrame >= 0 ? `${frameControlHeight + 35}px` : '35px'})`,\n        transition: 'height 0.15s'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1842,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(TabMenu, {\n      tabs: [{\n        title: formatMessage('MENU_INSTANCE'),\n        key: 'instance',\n        count: 0,\n        content: /*#__PURE__*/React.createElement(SideMenus, {\n          canvas: canvas.current,\n          readonly: readonly || loading || isReview || !isDrawMode,\n          loading: loading,\n          instances: instanceList,\n          currentFrame: currentFrame,\n          instancesFrames: instancesFrames,\n          selectedInstance: selectedInstance,\n          selectedOntologyGroup: selectedOntologyGroup,\n          instancesReviewsMap: instancesReviewsMap,\n          addInstance: addInstance,\n          selectGroup: selectGroup,\n          addInstanceInFrame: addInstanceInFrame,\n          removeInstanceFrames: removeInstanceFrames,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1856,\n            columnNumber: 21\n          }\n        })\n      }, {\n        title: formatMessage('MENU_WARNING'),\n        key: 'validator',\n        count: store.review.warnings.length,\n        content: /*#__PURE__*/React.createElement(Validator, {\n          canvas: canvas.current,\n          ref: validatorRef,\n          instances: instances,\n          jobProxy: props.jobProxy,\n          warnings: store.review.warnings || [],\n          setFrame: setFrame,\n          setSelectedShape: setSelectedShape,\n          selectGroup: selectGroup,\n          getInstance: getInstance,\n          saveResult: () => onSave(false),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1878,\n            columnNumber: 21\n          }\n        })\n      }],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1849,\n        columnNumber: 13\n      }\n    }), selectedInstance && ontologyGroup && !isReview && /*#__PURE__*/React.createElement(Board, {\n      categories: categories,\n      categoryPathShapes: displayedCategoryPathShapes,\n      points: shapes,\n      ontologyGroup: ontologyGroup,\n      selectedShapeStatus: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      drawMode: isDrawMode,\n      setSelectedShape: id => {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(id, {\n          instanceId,\n          category,\n          groupName\n        });\n      },\n      frameControlHeight: frameControlHeight,\n      readonly: loading,\n      instanceReviewsMap: store.review.frameReviewsMap[currentFrame],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1895,\n        columnNumber: 15\n      }\n    }), /*#__PURE__*/React.createElement(Canvas, {\n      ref: canvas,\n      readonly: readonly,\n      loading: loading,\n      isReview: isReview,\n      currentFrame: currentFrame,\n      image: (_frames$currentFrame = frames[currentFrame]) === null || _frames$currentFrame === void 0 ? void 0 : _frames$currentFrame.url,\n      categories: categories,\n      selectedInstance: selectedInstance,\n      selectedGroupName: selectedOntologyGroup,\n      ontologyGroup: ontologyGroup,\n      annotatedPointOrShapeCount: annotatedPointOrShapeCount,\n      updatedCategories: updatedCategories,\n      defaultInstances: defaultInstances,\n      selectedShapeStatus: selectedShapeStatus,\n      selectedShapeInfo: selectedShapeInfo,\n      changeLoading: setLoading,\n      selectGroup: selectGroup,\n      setSelectedShape: setSelectedShape,\n      handleShapesChange: handleShapesChange,\n      onCategoriesUpdated: onCategoriesUpdated,\n      handleShapesRemove: handleShapesRemove,\n      togglePointsVisibility: togglePointsVisibility,\n      setNextEmptyShape: setNextEmptyShape,\n      editShapeForm: editShapeForm,\n      editGroupForm: editGroupForm,\n      onSave: handleSave,\n      getInstance: getInstance,\n      categoryPathShapes: displayedCategoryPathShapes,\n      setCategoryPathShape: setCategoryPathShape,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1913,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"arributes-panel\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1948,\n        columnNumber: 13\n      }\n    }, selectedShapeStatus.groupName && /*#__PURE__*/React.createElement(Information, {\n      pointCategory: (categories[selectedCategoryIndex] || {}).name,\n      point: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1950,\n        columnNumber: 17\n      }\n    }), ((_frames$currentFrame2 = frames[currentFrame]) === null || _frames$currentFrame2 === void 0 ? void 0 : _frames$currentFrame2.url) && /*#__PURE__*/React.createElement(FrameAttributes, {\n      currentFrame: currentFrame,\n      currentFrameValid: frames[currentFrame].valid,\n      setFrameValid: setFrameValid,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1958,\n        columnNumber: 17\n      }\n    })), /*#__PURE__*/React.createElement(Attributes, {\n      ref: attributesRef,\n      readonly: readonly || isReview || !isDrawMode,\n      config: formConfig,\n      values: formValues,\n      onValuesChange: setAttributes,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1965,\n        columnNumber: 13\n      }\n    })), frames.length > 1 && currentFrame >= 0 && /*#__PURE__*/React.createElement(FrameControl, {\n      frames: frames,\n      frameLoading: loading,\n      currentFrame: currentFrame,\n      categoryInstancesMap: displayedCategoryInstancesMap,\n      instancesReviewsMap: instancesReviewsMap,\n      instances: displayedInstances,\n      selectedInstance: selectedInstance,\n      selectedInstanceGroup: selectedOntologyGroup,\n      selectGroup: selectGroup,\n      setFrame: setFrame,\n      onHeightChange: setFrameControlHeight,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1974,\n        columnNumber: 13\n      }\n    }), store.review.selectedReview && /*#__PURE__*/React.createElement(QualityControl, {\n      review: store.review.selectedReview,\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      selectedShapeStatus: selectedShapeStatus,\n      getShapeLabel: getShapeLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1989,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Missing, {\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1997,\n        columnNumber: 11\n      }\n    }));\n  });\n});\nexport default LandmarkAnnotation;","map":{"version":3,"names":["React","useState","useRef","useMemo","useEffect","forwardRef","useImperativeHandle","Observer","useLocalObservable","useObserver","cloneDeep","notification","v4","uuid","toJS","TabMenu","AutoSaver","Toolbar","SideMenus","Board","Canvas","FrameControl","Validator","Attributes","QualityControl","Information","FrameAttributes","formatMessage","i18n","LandmarkEditType","DELETETYPE","ReviewResult","fetchResultByUrl","loader","isPreview","isAnnotationReadonly","initInstances","loadInstancesFromResult","getFrameShapes","parseFramesByPaylod","getInstanceFrames","rootStore","useAsyncState","Missing","config","top","CANVASSTATUS","LandmarkAnnotation","props","ref","store","readonly","setReadOnly","frames","setFrames","currentFrame","setCurrentFrame","frameControlHeight","setFrameControlHeight","selectedOntologyGroup","setSelectedOntologyGroup","categoryPathShapes","setCategoryPathShapes","updatedCategories","setUpdatedCategories","defaultInstances","setDefaultInstances","instances","setInstances","imagePreloader","setImagePreloader","selectedShapeStatus","setSelectedShapeStatus","frameIndex","category","instanceId","groupName","shapeType","undefined","id","loading","setLoading","formConfig","setFormConfig","formValues","setFormValues","imageSize","setImageSize","width","height","editFormObject","setEditFormObject","isReview","setIsReview","initialInstances","setInitialInstances","initialCategoryInstancesMap","setInitialCategoryInstancesMap","initialCategoryPathShapes","setInitialCategoryPathShapes","attributesRef","saverRef","validatorRef","canvas","isDrawMode","review","drawMode","displayedInstances","instanceIds","Object","keys","instanceList","values","filter","v","selectedInstance","categoryInstancesMap","newCategoryInstancesMap","forEach","number","displayedCategoryInstancesMap","displayedCategoryPathShapes","selectedOntology","ontologyItem","ontology","find","class_name","ontologyGroup","groupItem","children","group","name","categories","selectedCategoryIndex","KEYPOINT","findIndex","c","range","length","instancesFrames","items","instance","shapes","_selectedInstance$chi","g","selectedShapeInfo","info","type","displayColor","display_color","_categories$selectedC","pointCategory","isKeyPoint","includes","annotatedPointOrShapeCount","entries","totalPointCount","count","instancesReviewsMap","map","reviews","_instances$instanceId","shapeIds","result","approveCount","REJECT","SUSPEND","APPROVE","len","ontologyCount","ontologyMap","onLoad","setSelectedMissingReview","getInstance","getGroup","_instance$children$fi","getShape","setInstance","setShape","shape","_group","currentGroup","push","oldShape","RECTANGLE","notEmpty","groupInfo","getGroupData","label_config","attributes","handleFormConfig","updateStatus","curr","prev","newUpdatedShapes","newUpdatedCategories","updatedHandles","newCategoryPathShapes","m","item","index","status","frameGroup","keyObj","updateShapes","instanceIndex","selectedIndex","newInstance","selectGroup","newGroup","setInitialData","n","point","visible","updateIndex","p","updateShape","position","rectangle","x","y","updateRectangle","rect","split","newCategories","_canvas$current","attrLayer","current","getAttrLabelByKey","_canvas$current2","updateAttributeLabel","setUpdatedShapes","handle","setUpdatedHandles","handleUndo","undo","undoDisabled","before","after","success","message","handleRedo","redoDisabled","redo","handleChangeDrawMode","mode","isEditable","_canvas$current3","clearHits","setNextEmptyShape","setSelectedShape","setDrawMode","loadInitialData","data","initial_result","initialResult","e","console","log","addInstance","ontologyName","sameOntologyInstances","reverse","handleInstanceChange","addInstanceInFrame","groupIdx","copyFrame","i","Number","frame","copyFrameIdx","removeInstanceFrames","delShapes","update","updateInstance","CURRENT","FOLLOW","ALL","diffFrame","Array","from","_","newInstances","ids","oldInstance","isRemove","child","saveStatus","_result","_saverRef$current","jobProxy","toolMode","setLocale","locale","init","initialData","initInstancesData","error","duration","framesData","image","imageData","images","url","isArray","auditId","setAuditId","initialCategoryPathShapesData","initialInstancesData","points","currentInstances","setFrame","setTempSaved","renderComplete","_canvas$current4","_canvas$current5","INITIAL","cancelUnfinishMissingReview","currentInstanceList","cleanLayer","setMultiShapesUnselected","preload","currentShapeStatus","updatedCategoriesData","changeFrame","setReview","newIsReview","displayInstances","onSave","submit","_saverRef$current2","_canvas$current6","_canvas$current6$imag","_canvas$current7","_canvas$current7$imag","loadError","Error","disableLeaveCheck","checkMissingPoints","check_missing_points","ontologyInfo","getOntologyInfo","groupFrames","groupShapes","newShapes","key","pointIndex","parseInt","valid","errMsg","display_name","annotated","total","statData","getInstanceStatistics","statistics","saveResultStat","handles","getHandles","saveResult","imageCanvas","getStatistics","statShapes","objects","approved","rejected","suspended","missed","r","instancesList","j","itemFrames","k","frameReviews","frameShapes","l","shapeId","indexOf","elements","className","Set","summary","frameCount","annotatedFrames","add","distinctCount","shapeCount","s","annotatedFrameCount","size","loadReviews","saveReviews","_saverRef$current3","hasSuspend","missingReviews","label","handleSave","isEnabled","groupData","newSelectedShapeStatus","shapeStatus","categoryScannedCount","categoryIndex","onCategoriesUpdated","handleShapesChange","groupsAttributes","handleShapesRemove","removeShapes","changeInstances","togglePointsVisibility","list","setCategoryPathShape","categoryKey","_updatedShapes","isFit","_canvas$current8","_child$frames$current","rectangles","updateGroupBox","_canvas$current9","fitSelected","editShapeForm","currentOntologyGroup","point_label_config","editGroupForm","_attributesRef$curren","title","getShapeLabel","showModal","class_display_name","setAttributes","_canvas$current10","oldPoint","newPoint","_newInstance$children","oldGroup","ontologyChild","oldAttrs","_canvas$current11","onAttributesModeChanges","activeMode","_canvas$current12","updatelabelVisible","onSizeChange","_canvas$current13","resizeShapes","onFilterChange","_canvas$current14","updateFilters","onLabelModeChange","_canvas$current15","labelLayer","setting","labelMode","onGridVisibleChange","_canvas$current16","gridLayer","isGridVisible","setFrameValid","newFramesData","createElement","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","_frames$currentFrame","_frames$currentFrame2","leaveCheck","qaWarnings","save","initialDataLength","style","transition","tabs","content","warnings","instanceReviewsMap","frameReviewsMap","selectedGroupName","changeLoading","currentFrameValid","onValuesChange","frameLoading","selectedInstanceGroup","onHeightChange","selectedReview"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx"],"sourcesContent":["import React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport { toJS } from 'mobx';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes, { AttributesHandle } from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { Status } from './store/UndoStore';\nimport { AttributesMode } from './store/SettingsStore';\nimport {\n  LandmarkEditType, InstanceListItem, CategoryPathShape, Point, PointListItem, PointStatus, FrameGroup,\n  ShapeInfo, PointInfo, Group, InstanceAct, Rectangle, GroupInfo, FormConfig, ObjectInfo, UpdatedShape,\n  Points, CurrentShapes, CategoryInstancesMap, KeypointCategoryProps, DELETETYPE, Frame, ReviewResult,\n  Payload, Statistic, Image, HandleStatus\n} from './types';\nimport { fetchResultByUrl } from './request';\nimport loader, { ImagePreloader } from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport {\n  initInstances,\n  loadInstancesFromResult,\n  getFrameShapes,\n  parseFramesByPaylod,\n  getInstanceFrames,\n} from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nimport Missing from './components/QualityControl/Missing';\n\nnotification.config({ top: 60 });\n\nenum CANVASSTATUS {\n  INITIAL = 'initial',\n  LANDMARK = 'landmark',\n}\n\nexport interface GroupReviewsMap {\n  [groupName: string]: {\n    approveCount: number;\n    result?: ReviewResult;\n  }\n}\n\nexport interface InstancesReviewsMap {\n  [instanceId: string]: {\n    [frameIndex: number]: {\n      approveCount: number;\n      result?: ReviewResult;\n      children: GroupReviewsMap\n    }\n  }\n}\n\nconst LandmarkAnnotation = forwardRef((props: Payload, ref) => {\n  const store = useLocalObservable(() => rootStore);\n\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState<Image[]>([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState<number>(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState<number>(78);\n\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState<string>('');\n\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState<{ [categoryKey: string]: CategoryPathShape }>({});\n\n  const [updatedCategories, setUpdatedCategories] = useAsyncState<KeypointCategoryProps[]>([]);\n\n  const [defaultInstances, setDefaultInstances] = useAsyncState<{ [id: string]: InstanceAct }>({});\n\n  const [instances, setInstances] = useAsyncState<{ [id: string]: InstanceAct }>({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState<ImagePreloader | null>(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState<ShapeInfo>({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const [formConfig, setFormConfig] = useState<FormConfig | null>(null);\n\n  const [formValues, setFormValues] = useState<{ [attr: string]: any; } | null>(null);\n\n  const [imageSize, setImageSize] = useState<{ width: number, height: number } | undefined>({ width: 0, height: 0 });\n\n  const [editFormObject, setEditFormObject] = useState<ObjectInfo | null>(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState<boolean>(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState<{ [id: string]: InstanceAct }>({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState<CategoryInstancesMap>({});\n\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState<{ [categoryKey: string]: CategoryPathShape }>({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef<AttributesHandle>(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef<AutoSaver>(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef<Validator>(null);\n\n  const canvas = useRef<Canvas>(null);\n\n  const isDrawMode = useMemo(() => (\n    store.review.drawMode\n  ), [store.review.drawMode]);\n\n  const displayedInstances = useMemo(() => (\n    isReview ? initialInstances : instances\n  ), [isReview, initialInstances, instances]);\n\n  const instanceIds = useMemo(() => (\n    Object.keys(displayedInstances)\n  ), [displayedInstances]);\n\n  const instanceList = useMemo(() => (\n    Object.values(displayedInstances).filter((v) => !!v)\n  ), [displayedInstances]);\n\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus?.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap: CategoryInstancesMap = {};\n    instanceList.forEach(({ category, id, number }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n\n  const displayedCategoryInstancesMap = useMemo(() => (\n    isReview ? initialCategoryInstancesMap : categoryInstancesMap\n  ), [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n\n  const displayedCategoryPathShapes = useMemo(() => (\n    isReview ? initialCategoryPathShapes : categoryPathShapes\n  ), [isReview, initialCategoryPathShapes, categoryPathShapes]);\n\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    return ontologyItem;\n  });\n\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find((group) => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n\n  const categories = useMemo(() => (\n    ontologyGroup?.categories || []\n  ), [ontologyGroup]);\n\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus?.id as number;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ?\n      categories.findIndex((c) => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) :\n      -1;\n  }, [selectedShapeStatus, categories]);\n\n  const instancesFrames = useMemo(() => {\n    const items: {\n      [id: string]: {\n        [frameIndex: number]: boolean;\n      }\n    } = {};\n    instanceList.forEach((instance) => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n\n  const shapes = useMemo(() => {\n    const group = selectedInstance?.children.find((g) => g.name === selectedOntologyGroup)?.frames[currentFrame];\n    return (group && group.shapes) || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n\n  const selectedShapeInfo = useMemo(() => {\n    let info: PointInfo | GroupInfo | null = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: ontologyGroup?.type || undefined,\n        displayColor: selectedOntology?.display_color || ''\n      };\n      if (ontologyGroup?.type === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        info = {\n          ...info,\n          pointCategory: categories[selectedCategoryIndex]?.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id as number)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n\n  const annotatedPointOrShapeCount = useMemo(() => (\n    Object.entries(shapes).filter(([, v]) => v !== undefined).length\n  ), [shapes]);\n\n  const totalPointCount = useMemo(() => (\n    ontologyGroup?.count || 0\n  ), [ontologyGroup]);\n\n  const instancesReviewsMap = useObserver(() => {\n    const map: InstancesReviewsMap = {};\n    store.review.reviews.forEach((review) => {\n      const { frameIndex, instanceId, groupName, shapeIds, result } = review;\n      const category = instances[instanceId]?.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0,\n        };\n      }\n\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n\n  useEffect(() => {\n    onLoad();\n  }, []);\n\n  useEffect(() => {\n    if (selectedShapeInfo?.instanceId) {\n      store.review.setSelectedMissingReview();\n    }\n  }, [selectedShapeInfo]);\n\n  const getInstance = (instanceId: string) => displayedInstances[instanceId];\n\n  const getGroup = (instanceId: string, groupName: string, frameIndex: number = currentFrame) => {\n    const instance = getInstance(instanceId);\n    const group = instance?.children.find((g) => g.name === groupName)?.frames[frameIndex];\n    return group;\n  };\n\n  const getShape = (instanceId: string, groupName: string, id: string | number, frameIndex: number = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? (group.shapes as Points)[id] : (group.shapes as CurrentShapes)[id]);\n  };\n\n  const setInstance = (id: string, instance?: InstanceAct) => {\n    setInstances({\n      ...instances,\n      [id]: instance!\n    });\n  };\n\n  const setShape = (frameIndex: number, instanceId: string, groupName: string, id: number | string, shapeType: LandmarkEditType, shape?: Point | Rectangle) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      let group = instance.children.find((g) => g.name === groupName);\n      let currentGroup = group?.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape: Point | Rectangle | undefined;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = ((currentGroup as Frame).shapes as Points)[id as number];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = ((currentGroup as Frame).shapes as CurrentShapes)[id];\n      }\n\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete ((currentGroup as Frame).shapes as Points)[id as number];\n        } else {\n          delete ((currentGroup as Frame).shapes as CurrentShapes)[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count + 1 : 1;\n        }\n        (currentGroup as Frame).shapes = {\n          ...(currentGroup as Frame).shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if (groupInfo?.label_config && (currentGroup as Frame).count === groupInfo.count && !(currentGroup as Frame).attributes) {\n        handleFormConfig(groupInfo.label_config, {}, { instanceId, category: instance.category, groupName });\n      }\n    }\n  };\n\n  const updateStatus = async (curr: Status[], prev: Status[]) => {\n    let newUpdatedShapes: UpdatedShape[] = [];\n    let newUpdatedCategories: KeypointCategoryProps[] = [];\n    let updatedHandles: HandleStatus[] = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const { frameIndex, instanceId, groupName, category, index, id, shapeType } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        let keyObj: { id: string } | { index: number } | undefined;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = { index };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = { id };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({ ...frameGroup, ...keyObj, shapeType });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          const instanceIndex = instanceIds.findIndex((v) => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, frameIndex, groupName, attributes } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance?.children.find((v) => v.name === groupName);\n          if (newInstance && newGroup) {\n            (newGroup.frames[frameIndex] as Frame).attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const { instanceId, groupName, category, index, id, shapeType, shape, frameIndex } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape as Point;\n            const { pointCategory, isKeyPoint, visible, attributes } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex((p) => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape: Point = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: { ...point.position },\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, index, shape: updateShape, shapeType });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape as Rectangle;\n            const { displayColor, visible, x, y, width, height } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle: Rectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible,\n            };\n            const updateIndex = newUpdatedShapes.findIndex((rect) => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, id, shape: updateRectangle, shapeType });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const { frameIndex, pointCategory, shape } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3],\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const { updateShapes, updatedCategories: newCategories } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          newUpdatedCategories = [\n            ...newUpdatedCategories,\n            ...newCategories\n          ];\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, groupName, attributes, frameIndex } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach((id) => {\n            const attrLayer = canvas.current?.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              canvas.current?.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          (newGroup.frames[frameIndex] as Frame).attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({ message: 'Undo successfully.' });\n      }\n    }\n  };\n\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({ message: 'Redo successfully.' });\n      }\n    }\n  };\n\n  const handleChangeDrawMode = (mode: boolean) => {\n    if (store.review.isEditable) {\n      canvas.current?.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const { instanceId, category, groupName } = selectedShapeStatus;\n        setSelectedShape(undefined, { instanceId, category, groupName });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n\n  const loadInitialData = async () => {\n    let data;\n    const { initial_result: initialResult } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n\n  const addInstance = async (ontologyName: string) => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter((v) => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n\n      const children = ontologyItem.children.map((v) => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({ [id]: instance });\n      await handleInstanceChange({ [id]: instance });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, { category: ontologyName, shapeType: ontologyItem.children[0].type });\n      }\n    }\n  };\n\n  const addInstanceInFrame = (instanceId: string, groupName?: string) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex((group) => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame: Frame | undefined;\n          Object.keys(newInstance.children[groupIdx].frames).forEach((i) => {\n            const index = Number(i);\n            const frame = { ...newInstance.children[groupIdx].frames[index] };\n            frame.shapes = { ...frame.shapes };\n            if (frame?.count && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx: number | undefined;\n        Object.keys(instancesFrames[instanceId]).forEach((i) => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach((group) => {\n            const copyFrame = { ...group.frames[copyFrameIdx as number] };\n            copyFrame.shapes = { ...copyFrame.shapes };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const { updateShapes, updatedCategories: newUpdatedCategories } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({ [instanceId]: newInstance });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n\n  const removeInstanceFrames = (type: DELETETYPE, instance: InstanceAct, name?: string) => {\n    if (instance) {\n      let delShapes: UpdatedShape[] = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance: InstanceAct, frameIndex: number) => {\n        updateInstance.children.forEach((group) => {\n          if ((name && name === group.name) || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= (group.frames[frameIndex] as Frame).count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({ length: frames.length - diffFrame }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const { updateShapes } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [\n            ...delShapes,\n            ...updateShapes\n          ];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter((v) => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({ [newInstance.id]: newInstance });\n    }\n  };\n\n  const handleInstanceChange = async (\n    newInstances: { [id: string]: InstanceAct },\n    status?: { before: Status[], after: Status[] }\n  ) => {\n    const ids = Object.keys(newInstances);\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async (id) => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach((child) => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance,\n          }\n        });\n        after.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n\n  const onLoad = async () => {\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n\n    let result;\n    let initialData: any;\n    let initInstancesData;\n    try {\n      result = {\n    \"auditId\": \"8561.29.audit\",\n    \"width\": 830,\n    \"height\": 788,\n    \"instances\": [\n        {\n            \"id\": \"1d209f11-f04d-4658-b3ce-2e54856174dd\",\n            \"category\": \"object\",\n            \"number\": 1,\n            \"displayColor\": \"#96dd4f\",\n            \"children\": [\n                {\n                    \"name\": \"person\",\n                    \"shapeType\": \"rectangle\",\n                    \"count\": 1,\n                    \"frames\": [\n                        {\n                            \"frameIndex\": 0,\n                            \"count\": 1,\n                            \"shapes\": [\n                                {\n                                    \"x\": 261.10877843960554,\n                                    \"y\": 356.2325283969725,\n                                    \"width\": 62.838915470494385,\n                                    \"height\": 135.93724571168195,\n                                    \"displayColor\": \"#96dd4f\",\n                                    \"id\": \"4e0b62bd-ac96-4d48-832d-23b26b84b203\",\n                                    \"visible\": true\n                                }\n                            ],\n                            \"attributes\": {}\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"body\",\n                    \"shapeType\": \"rectangle\",\n                    \"count\": 1,\n                    \"frames\": [\n                        {\n                            \"frameIndex\": 0,\n                            \"count\": 1,\n                            \"shapes\": [\n                                {\n                                    \"x\": 473.2221788236826,\n                                    \"y\": 376.62952729011516,\n                                    \"width\": 71.94414607948454,\n                                    \"height\": 122.72824919441462,\n                                    \"displayColor\": \"#96dd4f\",\n                                    \"id\": \"a7ac1ff9-4e8c-4b50-90ad-c445115d7780\",\n                                    \"visible\": true\n                                }\n                            ],\n                            \"attributes\": {\n                                \"ignored\": \"micro_objcet\"\n                            }\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"Keypoint\",\n                    \"shapeType\": \"keypoint\",\n                    \"count\": 17,\n                    \"frames\": [\n                        {\n                            \"frameIndex\": 0,\n                            \"count\": 17,\n                            \"shapes\": [\n                                {\n                                    \"pointCategory\": \"鼻尖\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 363.18995540800046,\n                                        \"y\": 369.57617963526366\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 0\n                                },\n                                {\n                                    \"pointCategory\": \"左眼中心\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 399.867363213228,\n                                        \"y\": 375.21885775914484\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 1\n                                },\n                                {\n                                    \"pointCategory\": \"右眼中心\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 82.22305764411037,\n                                        \"y\": 372.07114095718606\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 2\n                                },\n                                {\n                                    \"pointCategory\": \"右肩\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 723.1094619666052,\n                                        \"y\": 522.3968939131655\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 6\n                                },\n                                {\n                                    \"pointCategory\": \"左手腕\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 682.0718028838332,\n                                        \"y\": 440.32157574762186\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 9\n                                },\n                                {\n                                    \"pointCategory\": \"脸框的顶端（人脸框的顶部中点）\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 356.0083650685155,\n                                        \"y\": 490.31025420305224\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 18\n                                },\n                                {\n                                    \"pointCategory\": \"左眉毛中点\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 412.4351463073268,\n                                        \"y\": 644.2014757634466\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 19\n                                },\n                                {\n                                    \"pointCategory\": \"右眉毛中点\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 417.5648536926733,\n                                        \"y\": 510.8290837444381\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 20\n                                },\n                                {\n                                    \"pointCategory\": \"左嘴角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 548.3723920190087,\n                                        \"y\": 705.7579643876045\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 21\n                                },\n                                {\n                                    \"pointCategory\": \"右嘴角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 427.82426846336625,\n                                        \"y\": 690.368842231565\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 22\n                                },\n                                {\n                                    \"pointCategory\": \"头框的底端（正面对应下巴位置，背面对应颈部上端位置）\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 294.4518764443577,\n                                        \"y\": 615.9880851440411\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 23\n                                },\n                                {\n                                    \"pointCategory\": \"左眼左角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 804.8577612863328,\n                                        \"y\": 669.8500126901791\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 24\n                                },\n                                {\n                                    \"pointCategory\": \"左眼右角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 539.9853204439672,\n                                        \"y\": 114.48288460201236\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 25\n                                },\n                                {\n                                    \"pointCategory\": \"左眼上角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 497.76395177946284,\n                                        \"y\": 520.4184299497925\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 26\n                                },\n                                {\n                                    \"pointCategory\": \"左眼下角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 499.0463786257995,\n                                        \"y\": 565.3033695715744\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 27\n                                },\n                                {\n                                    \"pointCategory\": \"右眼左角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 630.7747290303682,\n                                        \"y\": 435.19186836227533\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 28\n                                },\n                                {\n                                    \"pointCategory\": \"右眼右角\",\n                                    \"isKeyPoint\": false,\n                                    \"position\": {\n                                        \"x\": 340.946261758292,\n                                        \"y\": 657.0517127785108\n                                    },\n                                    \"visible\": true,\n                                    \"index\": 29\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \"handles\": [],\n    \"categoryPathShapes\": [],\n    \"images\": [\n        {\n            \"url\": \"https://appen-tool-test.oss-cn-zhangjiakou.aliyuncs.com/sample-data/image-2D/person1.png\",\n            \"valid\": true,\n            \"index\": 0\n        }\n    ],\n    \"statistics\": \"https://onpremise-test.appendata.com/api-gw/oss/onpremise-test/8592/8592.786310_2025-06-05T102232Z.29.result.stat.json\"\n}\n      // result = await props.jobProxy.loadResult();\n      // initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({ message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({ frames: props.image, imageData: result?.images as Image[] });\n    // preload image\n    setImagePreloader(loader(framesData.map((v) => v.url)));\n    // set frame images\n    setFrames(framesData);\n\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      }\n      // else if (result.points) {\n      //   initInstancesData = initInstances(result.points, framesData.length);\n      // }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes: { [categoryKey: string]: CategoryPathShape } = {};\n        result.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height,\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData: { [key: string]: CategoryPathShape } = {};\n        initialData.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const { newInstances, categoryInstancesMap: newCategoryInstancesMap } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances: { [id: string]: InstanceAct } = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const { newInstances } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    saverRef.current?.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex: number, currentInstances: { [id: string]: InstanceAct } | undefined = instances, type?: CANVASSTATUS) => {\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    store.review.cancelUnfinishMissingReview();\n    const currentInstanceList = Object.values(currentInstances);\n    canvas.current?.cleanLayer();\n    canvas.current?.setMultiShapesUnselected();\n    imagePreloader?.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex,\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const { id, category, children: [{ name }] } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group?.type,\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const { updateShapes, updatedCategories: updatedCategoriesData } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n\n  const onSave = async (submit = true) => {\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({ message: loadError });\n      throw new Error(loadError);\n    }\n\n    saverRef.current?.disableLeaveCheck();\n\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances: InstanceListItem[] = instanceList.filter((v) => v && v.notEmpty).map((instance) => {\n      const { id, category, number, displayColor, children } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map((group) => {\n          const { frames: groupFrames } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter((v) => !!v && v.count > 0).map((frameGroup) => {\n              if (frameGroup) {\n                const { frameIndex, count, shapes: groupShapes } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes: PointListItem[] | Rectangle[] = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach((key) => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point: PointListItem | undefined = groupShapes && (groupShapes as Points)[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        (newShapes as PointListItem[]).push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle: Rectangle | undefined = groupShapes && (groupShapes as CurrentShapes)[key];\n                      if (rectangle) (newShapes as Rectangle[]).push(rectangle);\n                    }\n                  });\n                }\n                if (\n                  checkMissingPoints &&\n                  frames[frameIndex].valid !== false &&\n                  groupInfo &&\n                  newShapes.length < groupInfo.count\n                ) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: ontologyInfo?.display_name || ontologyInfo?.class_name,\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({ message: errMsg });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: canvas.current?.imageCanvas?.width || imageSize?.width,\n      height: canvas.current?.imageCanvas?.height || imageSize?.height,\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map((pointCategory) => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory],\n      })),\n      images: frames,\n      statistics,\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes: {\n      [shape: string]: { rejected: number; approved: number, suspended: number, missed: number, total: number };\n    } = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0,\n    };\n    const reviews = store.review.reviews.filter((r) => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter((r) => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find((r) => r.shapeIds.indexOf(shapeId) >= 0);\n            if (review?.result === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if (review?.result === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return { objects, shapes: statShapes };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const { ontology } = store.ontology;\n    const data: Statistic = {\n      elements: [],\n      categories: ontology.map(({ class_name: className }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set(),\n    };\n\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, category, children } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0,\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(\n              ...frameShapes.map((s) => ({\n                instance: id,\n                shape,\n                frame: frame.frameIndex + 1,\n                category,\n                id: s.id || s.index,\n              }))\n            );\n          }\n        }\n      }\n    }\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({ category, shape, count, distinctCount }) => ({\n        category,\n        shape,\n        count,\n        distinctCount,\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size,\n    };\n  };\n\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n\n  const saveReviews = (type = 'submit') => {\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find((review) => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    saverRef.current?.disableLeaveCheck();\n    const missingReviews = toJS(store.review.missingReviews).map((r) => ({\n      ...r,\n      label: 'Missed',\n    }));\n    return props.jobProxy.saveReviews([...missingReviews], type === 'submit');\n  };\n\n  const handleSave = async () => {\n    const { toolMode } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n\n    try {\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({ message: formatMessage('SAVE_SUCCESS') });\n    } catch (e) {\n      notification.error({ message: formatMessage('SAVE_FAIL') });\n    }\n  };\n\n  const setSelectedShape = (id?: number | string, groupData?: Group) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const { instanceId, category, groupName, shapeType } = groupData;\n      if (instanceId !== selectedInstance?.id) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || ontologyGroup?.type || undefined,\n        groupName,\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n\n  const setNextEmptyShape = (shapeStatus: ShapeInfo = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let { id } = shapeStatus;\n      const { instanceId, groupName, shapeType } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const { range = [] } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            (id as number) += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id!) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n\n  const handleShapesChange = (\n    newShapes: UpdatedShape[],\n    groupsAttributes?: { instanceId: string, category: string, name: string, attributes: any }[],\n    status?: { before: Status[], after: Status[] }\n  ) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    const { instanceId, groupName } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData(newInstance?.category || '', groupName);\n    newInstance?.children.forEach((child) => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {},\n          };\n        };\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const { id, frameIndex, index, shape } = newShapes[i];\n          let oldShape;\n\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = (child.frames[frameIndex].shapes as Points)[index];\n            (child.frames[frameIndex].shapes as Points)[index] = {\n              ...oldShape,\n              ...shape as Point\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            (child.frames[frameIndex].shapes as CurrentShapes)[id] = {\n              ...oldShape,\n              ...shape as Rectangle\n            };\n          }\n\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        };\n        if (groupInfo?.label_config && currentGroup.count === groupInfo?.count && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, { instanceId, category: newInstance.category, groupName });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({ instanceId: id, name, category, attributes }) => {\n        const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId: id, category, groupName: name };\n        before.push({ type: 'group', status: { ...frameGroup } });\n        after.push({ type: 'group', status: { ...frameGroup, attributes } });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({ [instanceId]: newInstance }, { before, after });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n\n  const handleShapesRemove = (removeShapes: UpdatedShape[]) => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n\n    const changeInstances: { [id: string]: InstanceAct } = {};\n    const { instanceId, groupName } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance?.children.forEach((child) => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({ id, frameIndex, index }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete (child.frames[frameIndex].shapes as Points)[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({ [instanceId]: newInstance });\n    }\n  };\n\n  const togglePointsVisibility = (points: PointStatus[]) => {\n    const list: UpdatedShape[] = [];\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: { ...point, visible: !point.visible }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n\n  const setCategoryPathShape = (categoryKey: string, shapeType?: CategoryPathShape, _updatedShapes?: UpdatedShape[]) => {\n    const before: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: categoryPathShapes[categoryKey] },\n    }];\n    const after: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: shapeType },\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, { before, after });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n\n  const selectGroup = (id: string, groupName: string, isFit = true, groupData?: { category: string, shapeType: LandmarkEditType }) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus: ShapeInfo = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: groupData?.category || selectedShapeStatus.category,\n      groupName,\n      shapeType: groupData?.shapeType || undefined,\n      id: undefined\n    };\n    if (instance) {\n      const ontologyItem = store.ontology.ontology.find((v) => v.class_name === instance.category);\n      const group = ontologyItem?.children.find((v) => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = group?.type || undefined;\n      if (isDrawMode) {\n        if (group?.type === LandmarkEditType.KEYPOINT) {\n          const index = (group.categories && group.categories[0] && group.categories[0].range[0]) || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if (group?.type === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach((child) => {\n            if (child.name === groupName && child.frames[currentFrame]?.shapes) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      canvas.current?.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        canvas.current?.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n\n  const editShapeForm = () => {\n    const { instanceId, groupName, shapeType, id, category } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, (id as number));\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && currentOntologyGroup?.point_label_config) {\n        handleFormConfig(currentOntologyGroup.point_label_config, (point as Point).attributes || {}, { instanceId, category, groupName }, (id as number), point);\n      }\n    }\n  };\n\n  const editGroupForm = () => {\n    const { instanceId, groupName, category } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && currentOntologyGroup?.label_config) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, { instanceId, category, groupName });\n    }\n  };\n\n  const handleFormConfig = (config: FormConfig, values: { [attr: string]: any; }, group: Group, index?: number, point?: Point) => {\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point,\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    attributesRef.current?.showModal(title);\n  };\n\n  const getShapeLabel = (instanceId: string, category: string, groupName: string) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', { values: { frameIndex: currentFrame + 1 } })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n\n  const setAttributes = (values: any) => {\n    if (editFormObject) {\n      const { instanceId, category, groupName, index, point } = editFormObject;\n      const before: Status[] = [];\n      const after: Status[] = [];\n      const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId, category, groupName };\n      if ((index || index === 0) && point) {\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = { ...oldPoint, ...point, attributes: values };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({ type: 'shape', status: { ...frameGroup, index, shape: oldPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        after.push({ type: 'shape', status: { ...frameGroup, index, shape: newPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        canvas.current?.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName)?.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup?.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({ type: 'group', status: { ...frameGroup, attributes: oldAttrs } });\n          after.push({ type: 'group', status: { ...frameGroup, attributes: values } });\n          if (oldGroup?.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach((id) => {\n                canvas.current?.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode: AttributesMode, type = 'object') => {\n    canvas.current?.updatelabelVisible(activeMode, type);\n  };\n\n  const onSizeChange = () => {\n    canvas.current?.resizeShapes();\n  };\n\n  const onFilterChange = () => {\n    canvas.current?.updateFilters();\n  };\n\n  const onLabelModeChange = () => {\n    if (canvas.current?.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n\n  const onGridVisibleChange = () => {\n    if (canvas.current?.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n\n  const setFrameValid = (frame: number, valid: boolean) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics,\n  }));\n\n  return (\n    <Observer>\n      {() => (\n        <div className=\"landmark-annotation-app\">\n          <AutoSaver\n            ref={saverRef}\n            leaveCheck\n            data={{ instance: instances, reviews: store.review.qaWarnings }}\n            save={handleSave}\n          />\n          <Toolbar\n            readonly={readonly || loading || isReview}\n            isReview={isReview}\n            isPreview={readonly}\n            initialDataLength={Object.keys(initialInstances).length}\n            onAttributesModeChanges={onAttributesModeChanges}\n            onSizeChange={onSizeChange}\n            onFilterChange={onFilterChange}\n            onLabelModeChange={onLabelModeChange}\n            onGridVisibleChange={onGridVisibleChange}\n            onSave={handleSave}\n            handleUndo={handleUndo}\n            handleRedo={handleRedo}\n            setReview={setReview}\n            handleChangeDrawMode={handleChangeDrawMode}\n          />\n          <div\n            className=\"container\"\n            style={{\n              height: `calc(100% - ${(frames.length > 1 && currentFrame >= 0) ? `${frameControlHeight + 35}px` : '35px'})`,\n              transition: 'height 0.15s',\n            }}\n          >\n            <TabMenu\n              tabs={[\n                {\n                  title: formatMessage('MENU_INSTANCE'),\n                  key: 'instance',\n                  count: 0,\n                  content: (\n                    <SideMenus\n                      canvas={canvas.current}\n                      readonly={readonly || loading || isReview || !isDrawMode}\n                      loading={loading}\n                      instances={instanceList}\n                      currentFrame={currentFrame}\n                      instancesFrames={instancesFrames}\n                      selectedInstance={selectedInstance}\n                      selectedOntologyGroup={selectedOntologyGroup}\n                      instancesReviewsMap={instancesReviewsMap}\n                      addInstance={addInstance}\n                      selectGroup={selectGroup}\n                      addInstanceInFrame={addInstanceInFrame}\n                      removeInstanceFrames={removeInstanceFrames}\n                    />\n                  )\n                },\n                {\n                  title: formatMessage('MENU_WARNING'),\n                  key: 'validator',\n                  count: store.review.warnings.length,\n                  content: (\n                    <Validator\n                      canvas={canvas.current}\n                      ref={validatorRef}\n                      instances={instances}\n                      jobProxy={props.jobProxy}\n                      warnings={store.review.warnings || []}\n                      setFrame={setFrame}\n                      setSelectedShape={setSelectedShape}\n                      selectGroup={selectGroup}\n                      getInstance={getInstance}\n                      saveResult={() => onSave(false)}\n                    />\n                  )\n                }\n              ]}\n            />\n            {selectedInstance && ontologyGroup && !isReview && (\n              <Board\n                categories={categories}\n                categoryPathShapes={displayedCategoryPathShapes}\n                points={shapes}\n                ontologyGroup={ontologyGroup}\n                selectedShapeStatus={selectedShapeStatus}\n                annotated={annotatedPointOrShapeCount}\n                total={totalPointCount}\n                drawMode={isDrawMode}\n                setSelectedShape={(id) => {\n                  const { instanceId, category, groupName } = selectedShapeStatus;\n                  setSelectedShape(id, { instanceId, category, groupName });\n                }}\n                frameControlHeight={frameControlHeight}\n                readonly={loading}\n                instanceReviewsMap={store.review.frameReviewsMap[currentFrame]}\n              />\n            )}\n            <Canvas\n              ref={canvas}\n              readonly={readonly}\n              loading={loading}\n              isReview={isReview}\n              currentFrame={currentFrame}\n              image={frames[currentFrame]?.url}\n              categories={categories}\n              selectedInstance={selectedInstance}\n              selectedGroupName={selectedOntologyGroup}\n              ontologyGroup={ontologyGroup}\n              annotatedPointOrShapeCount={annotatedPointOrShapeCount}\n              updatedCategories={updatedCategories}\n              defaultInstances={defaultInstances}\n              selectedShapeStatus={selectedShapeStatus}\n              selectedShapeInfo={selectedShapeInfo}\n              changeLoading={setLoading}\n              selectGroup={selectGroup}\n              setSelectedShape={setSelectedShape}\n              handleShapesChange={handleShapesChange}\n              onCategoriesUpdated={onCategoriesUpdated}\n              handleShapesRemove={handleShapesRemove}\n              togglePointsVisibility={togglePointsVisibility}\n              setNextEmptyShape={setNextEmptyShape}\n              editShapeForm={editShapeForm}\n              editGroupForm={editGroupForm}\n              onSave={handleSave}\n              getInstance={getInstance}\n              categoryPathShapes={displayedCategoryPathShapes}\n              setCategoryPathShape={setCategoryPathShape}\n              handleUndo={handleUndo}\n              handleRedo={handleRedo}\n              setReview={setReview}\n              handleChangeDrawMode={handleChangeDrawMode}\n            />\n            <div className=\"arributes-panel\">\n              {selectedShapeStatus.groupName && (\n                <Information\n                  pointCategory={(categories[selectedCategoryIndex] || {}).name}\n                  point={selectedShapeStatus}\n                  annotated={annotatedPointOrShapeCount}\n                  total={totalPointCount}\n                />\n              )}\n              {frames[currentFrame]?.url && (\n                <FrameAttributes\n                  currentFrame={currentFrame}\n                  currentFrameValid={frames[currentFrame].valid}\n                  setFrameValid={setFrameValid}\n                />\n              )}\n            </div>\n            <Attributes\n              ref={attributesRef}\n              readonly={readonly || isReview || !isDrawMode}\n              config={formConfig}\n              values={formValues}\n              onValuesChange={setAttributes}\n            />\n          </div>\n          {(frames.length > 1 && currentFrame >= 0) && (\n            <FrameControl\n              frames={frames}\n              frameLoading={loading}\n              currentFrame={currentFrame}\n              categoryInstancesMap={displayedCategoryInstancesMap}\n              instancesReviewsMap={instancesReviewsMap}\n              instances={displayedInstances}\n              selectedInstance={selectedInstance}\n              selectedInstanceGroup={selectedOntologyGroup}\n              selectGroup={selectGroup}\n              setFrame={setFrame}\n              onHeightChange={setFrameControlHeight}\n            />\n          )}\n          {store.review.selectedReview && (\n            <QualityControl\n              review={store.review.selectedReview}\n              readonly={readonly || isDrawMode}\n              jobProxy={props.jobProxy}\n              selectedShapeStatus={selectedShapeStatus}\n              getShapeLabel={getShapeLabel}\n            />\n          )}\n          <Missing\n            readonly={readonly || isDrawMode}\n            jobProxy={props.jobProxy}\n          />\n        </div>\n      )}\n    </Observer>\n  );\n});\n\nexport default LandmarkAnnotation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}