{"ast":null,"code":"import { makeAutoObservable, toJS } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AnnotationType, UpdateType } from '../types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map = {};\n    this.allInstances.forEach(instance => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({\n      className\n    }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.start - b.start);\n      }\n    });\n    return map;\n  }\n  /**\n   * selected instance\n   */\n  get selectedInstance() {\n    return this.selectedInstanceId ? toJS(this.instances[this.selectedInstanceId]) : null;\n  }\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    return Object.values(this.instances);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * all instances\n     */\n    this.instances = {};\n    /**\n     * selected instances\n     */\n    this.selectedInstanceId = null;\n    /**\n     * selected number\n     */\n    this.selectedNumber = null;\n    /**\n     * update instances\n     */\n    this.updatedInstances = {};\n    this.updateInstances = instances => {\n      this.instances = {\n        ...toJS(this.instances),\n        ...instances\n      };\n      if (this.selectedInstance) {\n        const {\n          start,\n          end,\n          category\n        } = this.selectedInstance;\n        if (Object.keys(this.rootStore.ontology.canAddTiers).filter(k => k !== category).length === 0) {\n          if (start !== undefined && end !== undefined) {\n            this.rootStore.analyse.setSelectedRegion({\n              start,\n              end\n            });\n          } else {\n            this.rootStore.analyse.setSelectedTime(start);\n          }\n        }\n      }\n    };\n    makeAutoObservable(this, {\n      rootStore: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(list) {\n    if (list.length) {\n      const {\n        ontology: {\n          categories,\n          categoryMap\n        },\n        analyse: {\n          placement: {\n            duration\n          }\n        }\n      } = this.rootStore;\n      const instances = {};\n      const map = {};\n      list.forEach(instance => {\n        if (!map[instance.category]) {\n          map[instance.category] = [];\n        }\n        map[instance.category].push(instance);\n      });\n      categories.forEach(({\n        className\n      }) => {\n        if (!map[className]) {\n          map[className] = [];\n        } else {\n          map[className].sort((a, b) => a.start - b.start);\n        }\n      });\n      Object.keys(map).forEach(key => {\n        var _categoryMap$key;\n        const ins = map[key];\n        if (((_categoryMap$key = categoryMap[key]) === null || _categoryMap$key === void 0 ? void 0 : _categoryMap$key.type) === AnnotationType.SEGMENT) {\n          let prevEnd = 0;\n          ins.forEach((instance, i) => {\n            if (instance.end > prevEnd) {\n              instances[instance.id] = {\n                ...instance,\n                start: prevEnd,\n                ...(i === ins.length - 1 && {\n                  end: duration\n                })\n              };\n              prevEnd = instance.end;\n            }\n          });\n        } else {\n          ins.forEach(instance => {\n            instances[instance.id] = instance;\n          });\n        }\n      });\n      this.instances = instances;\n      this.setUpdatedInstances(instances, UpdateType.INIT);\n    }\n  }\n  createDefaultInstances() {\n    const {\n      categories\n    } = this.rootStore.ontology;\n    if (Object.keys(this.instances).length === 0 && categories.length) {\n      const {\n        duration\n      } = this.rootStore.analyse.placement;\n      const instances = {};\n      categories.forEach((category, i) => {\n        if (category.type === AnnotationType.SEGMENT) {\n          const id = uuidv4();\n          instances[id] = {\n            id,\n            start: 0,\n            end: duration,\n            shapeType: category.type,\n            category: category.className,\n            categoryIndex: i\n          };\n        }\n      });\n      this.instances = instances;\n      this.setUpdatedInstances(this.instances, UpdateType.INIT);\n    }\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  setInstance(instance) {\n    this.instances[instance.id] = instance;\n  }\n\n  /**\n   * delete instance\n   * @param id\n   */\n  deleteInstance(id) {\n    if (this.instances[id]) {\n      const updatedInstances = {};\n      const instance = toJS(this.instances[id]);\n      const {\n        shapeType,\n        category,\n        categoryIndex,\n        start,\n        end\n      } = instance;\n      updatedInstances[id] = null;\n      if (start === 0) {\n        const nextInstance = shapeType === AnnotationType.SEGMENT ? this.getNextInstance(start, category) : undefined;\n        if (nextInstance) {\n          const updatedPrevInstance = {\n            ...nextInstance,\n            start\n          };\n          updatedInstances[nextInstance.id] = updatedPrevInstance;\n        }\n      } else {\n        const prevInstance = shapeType === AnnotationType.SEGMENT ? this.getCurrentSplitInstance(category, start) : undefined;\n        if (prevInstance) {\n          const updatedPrevInstance = {\n            ...prevInstance,\n            end\n          };\n          updatedInstances[prevInstance.id] = updatedPrevInstance;\n        }\n      }\n      if (start === this.rootStore.analyse.selectedTime) {\n        const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n        this.rootStore.ontology.setCanAddTiers({\n          ...canAddTiers,\n          [category]: {\n            index: categoryIndex,\n            first: true,\n            second: true,\n            type: shapeType,\n            ...(shapeType === AnnotationType.SEGMENT && {\n              size: {\n                start,\n                end: end\n              }\n            })\n          }\n        });\n      }\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n\n  /**\n   * handle add shape\n   * @param className category\n   */\n  addInstance(className, time) {\n    const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n    const canAddTier = canAddTiers[className];\n    if (className && canAddTier !== undefined) {\n      const categoryIndex = canAddTier.index;\n      const category = this.rootStore.ontology.getCategory(className);\n      const updatedInstances = {};\n      const shapeType = category.type;\n      const isSegment = shapeType === AnnotationType.SEGMENT;\n      let instance;\n      let selectedId = '';\n      const add = startTime => {\n        var _prevInstance;\n        let endTime;\n        let prevInstance;\n        const id = uuidv4();\n        if (instance) {\n          prevInstance = isSegment ? instance : undefined;\n        } else {\n          prevInstance = isSegment ? this.getCurrentSplitInstance(className, startTime) : undefined;\n        }\n        selectedId = ((_prevInstance = prevInstance) === null || _prevInstance === void 0 ? void 0 : _prevInstance.id) || id;\n        if (prevInstance) {\n          const updatePrevInstance = {\n            ...prevInstance,\n            ...(isSegment && {\n              end: startTime\n            })\n          };\n          updatedInstances[prevInstance.id] = updatePrevInstance;\n          endTime = prevInstance.end;\n        } else if (isSegment) {\n          const {\n            duration\n          } = this.rootStore.analyse.placement;\n          endTime = duration;\n        }\n        instance = {\n          id,\n          start: startTime,\n          ...(isSegment && {\n            end: endTime\n          }),\n          shapeType,\n          category: className,\n          categoryIndex\n        };\n        updatedInstances[instance.id] = instance;\n      };\n      if (Array.isArray(time)) {\n        Array.from(new Set(time)).sort((a, b) => a - b).forEach(start => {\n          add(start);\n        });\n      } else {\n        add(time);\n      }\n      this.setSelectedInstance(updatedInstances[selectedId]);\n      this.setUpdatedInstances(updatedInstances);\n      if (this.rootStore.analyse.isPlaying) {\n        this.rootStore.analyse.handlePlay();\n      }\n    }\n  }\n  getCurrentSplitInstance(category, start) {\n    const categoryInstances = this.categoryInstancesMap[category];\n    if (categoryInstances.length === 1) {\n      if (categoryInstances[0].start !== start) {\n        return toJS(categoryInstances[0]);\n      }\n      return undefined;\n    }\n    let prevIndex = -1;\n    for (let i = 0; i < categoryInstances.length; i += 1) {\n      const instance = categoryInstances[i];\n      if (instance.end && start <= instance.end && start > instance.start) {\n        prevIndex = i;\n        break;\n      } else if (!instance.end && start > instance.start) {\n        prevIndex = i;\n        break;\n      }\n    }\n    return categoryInstances[prevIndex] ? toJS(categoryInstances[prevIndex]) : undefined;\n  }\n  getAdjoinInstances(category, start) {\n    const categoryInstances = this.categoryInstancesMap[category];\n    if (categoryInstances.length === 1 && this.rootStore.ontology.categories[categoryInstances[0].categoryIndex].type !== AnnotationType.TIMING) {\n      return {\n        prevInstance: toJS(categoryInstances[0]),\n        nextInstance: undefined\n      };\n    }\n    const index = categoryInstances.findIndex(instance => instance.start === start);\n    const adjoinInstances = {\n      prevInstance: categoryInstances[index - 1] ? toJS(categoryInstances[index - 1]) : undefined,\n      nextInstance: categoryInstances[index + 1] ? toJS(categoryInstances[index + 1]) : undefined\n    };\n    return adjoinInstances;\n  }\n  getPrevInstance(start, category) {\n    const instances = category ? this.categoryInstancesMap[category] : this.allInstances.sort((a, b) => a.start - b.start);\n    return instances.find(i => i.start < start && (i.end === undefined || i.end >= start));\n  }\n  getNextInstance(start, category) {\n    const instances = category ? this.categoryInstancesMap[category] : this.allInstances.sort((a, b) => a.start - b.start);\n    return instances.find(i => i.start > start);\n  }\n\n  /**\n   * set updated instances\n   */\n  setUpdatedInstances(instances, type) {\n    const ids = Object.keys(instances);\n    if (ids.length === 0) {\n      return;\n    }\n    if (type !== UpdateType.INIT) {\n      const updatedInstances = {};\n      const oldInstances = {};\n      ids.forEach(id => {\n        const oldInstance = this.instances[id];\n        oldInstances[id] = oldInstance ? toJS(oldInstance) : null;\n        const instance = instances[id];\n        if (instance) {\n          updatedInstances[id] = instance;\n        } else {\n          var _this$selectedInstanc;\n          delete this.instances[id];\n          if (((_this$selectedInstanc = this.selectedInstance) === null || _this$selectedInstanc === void 0 ? void 0 : _this$selectedInstanc.id) === id) {\n            this.selectedInstanceId = null;\n          }\n        }\n      });\n      if (type !== UpdateType.UNDOREDO) {\n        this.changeUndo(oldInstances, instances);\n      }\n      this.updateInstances(updatedInstances);\n    }\n    this.updatedInstances = instances;\n  }\n  changeUndo(oldInstances, updatedInstances) {\n    const before = [];\n    const after = [];\n    before.push({\n      type: 'instance',\n      status: {\n        ...oldInstances\n      }\n    });\n    after.push({\n      type: 'instance',\n      status: {\n        ...updatedInstances\n      }\n    });\n    this.rootStore.undo.saveStatus(before, after);\n  }\n\n  /**\n   * set selected instance\n   */\n  setSelectedInstance(instance) {\n    if (instance) {\n      const {\n        id,\n        category,\n        start\n      } = instance;\n      if (this.selectedInstanceId === id) return;\n      const categoryInstances = this.categoryInstancesMap[category];\n      const prevInstance = this.getCurrentSplitInstance(category, start);\n      if (prevInstance) {\n        const index = categoryInstances.findIndex(i => i.start === prevInstance.start);\n        this.selectedNumber = index + 2;\n      } else {\n        this.selectedNumber = 1;\n      }\n      this.rootStore.ontology.selectCategory(category);\n    } else {\n      this.selectedNumber = null;\n    }\n    this.selectedInstanceId = instance ? instance.id : null;\n  }\n}","map":{"version":3,"names":["makeAutoObservable","toJS","v4","uuidv4","AnnotationType","UpdateType","InstanceStore","categoryInstancesMap","map","allInstances","forEach","instance","category","push","rootStore","ontology","categories","className","sort","a","b","start","selectedInstance","selectedInstanceId","instances","Object","values","constructor","selectedNumber","updatedInstances","updateInstances","end","keys","canAddTiers","filter","k","length","undefined","analyse","setSelectedRegion","setSelectedTime","autoBind","init","list","categoryMap","placement","duration","key","_categoryMap$key","ins","type","SEGMENT","prevEnd","i","id","setUpdatedInstances","INIT","createDefaultInstances","shapeType","categoryIndex","getInstanceById","instanceId","setInstance","deleteInstance","nextInstance","getNextInstance","updatedPrevInstance","prevInstance","getCurrentSplitInstance","selectedTime","setCanAddTiers","index","first","second","size","addInstance","time","canAddTier","getCategory","isSegment","selectedId","add","startTime","_prevInstance","endTime","updatePrevInstance","Array","isArray","from","Set","setSelectedInstance","isPlaying","handlePlay","categoryInstances","prevIndex","getAdjoinInstances","TIMING","findIndex","adjoinInstances","getPrevInstance","find","ids","oldInstances","oldInstance","_this$selectedInstanc","UNDOREDO","changeUndo","before","after","status","undo","saveStatus","selectCategory"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/store/InstanceStore.ts"],"sourcesContent":["import { makeAutoObservable, toJS } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport RootStore from './RootStore';\nimport { Status } from './UndoStore';\nimport { Instance, AnnotationType, UpdateType } from '../types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * all instances\n   */\n  instances: { [instanceId: string]: Instance } = {};\n\n  /**\n   * selected instances\n   */\n  selectedInstanceId: string | null = null;\n\n  /**\n   * selected number\n   */\n  selectedNumber: number | null = null;\n\n  /**\n   * update instances\n   */\n  updatedInstances: { [id: string]: Instance | null } = {};\n\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map: { [categoryName: string]: Instance[] } = {};\n    this.allInstances.forEach((instance) => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({ className }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.start - b.start);\n      }\n    });\n    return map;\n  };\n\n  /**\n   * selected instance\n   */\n  get selectedInstance() {\n    return this.selectedInstanceId ? toJS(this.instances[this.selectedInstanceId]) : null;\n  }\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    return Object.values(this.instances);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(list: Instance[]) {\n    if (list.length) {\n      const {\n        ontology: { categories, categoryMap },\n        analyse: { placement: { duration } },\n      } = this.rootStore;\n\n      const instances: {[id: string]: Instance} = {};\n      const map: { [categoryName: string]: Instance[] } = {};\n      list.forEach((instance) => {\n        if (!map[instance.category]) {\n          map[instance.category] = [];\n        }\n        map[instance.category].push(instance);\n      });\n      categories.forEach(({ className }) => {\n        if (!map[className]) {\n          map[className] = [];\n        } else {\n          map[className].sort((a, b) => a.start - b.start);\n        }\n      });\n      Object.keys(map).forEach((key) => {\n        const ins = map[key];\n        if (categoryMap[key]?.type === AnnotationType.SEGMENT) {\n          let prevEnd = 0;\n          ins.forEach((instance, i) => {\n            if (instance.end! > prevEnd) {\n              instances[instance.id] = {\n                ...instance,\n                start: prevEnd,\n                ...i === ins.length - 1 && {\n                  end: duration\n                }\n              };\n              prevEnd = instance.end!;\n            }\n          });\n        } else {\n          ins.forEach((instance) => {\n            instances[instance.id] = instance;\n          });\n        }\n      });\n\n      this.instances = instances;\n      this.setUpdatedInstances(instances, UpdateType.INIT);\n    }\n  }\n\n  createDefaultInstances() {\n    const { categories } = this.rootStore.ontology;\n    if (Object.keys(this.instances).length === 0 && categories.length) {\n      const { duration } = this.rootStore.analyse.placement;\n      const instances: {[id: string]: Instance} = {};\n      categories.forEach((category, i) => {\n        if (category.type === AnnotationType.SEGMENT) {\n          const id = uuidv4();\n          instances[id] = {\n            id,\n            start: 0,\n            end: duration,\n            shapeType: category.type,\n            category: category.className,\n            categoryIndex: i,\n          };\n        }\n      });\n      this.instances = instances;\n      this.setUpdatedInstances(this.instances, UpdateType.INIT);\n    }\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId: string) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  setInstance(instance: Instance) {\n    this.instances[instance.id] = instance;\n  }\n\n  /**\n   * delete instance\n   * @param id\n   */\n  deleteInstance(id: string) {\n    if (this.instances[id]) {\n      const updatedInstances: { [id: string]: Instance | null; } = {};\n      const instance = toJS(this.instances[id]);\n      const { shapeType, category, categoryIndex, start, end } = instance;\n      updatedInstances[id] = null;\n      if (start === 0) {\n        const nextInstance = shapeType === AnnotationType.SEGMENT ? this.getNextInstance(start, category) : undefined;\n        if (nextInstance) {\n          const updatedPrevInstance: Instance = {\n            ...nextInstance,\n            start,\n          };\n          updatedInstances[nextInstance.id] = updatedPrevInstance;\n        }\n      } else {\n        const prevInstance = shapeType === AnnotationType.SEGMENT ? this.getCurrentSplitInstance(category, start) : undefined;\n        if (prevInstance) {\n          const updatedPrevInstance: Instance = {\n            ...prevInstance,\n            end,\n          };\n          updatedInstances[prevInstance.id] = updatedPrevInstance;\n        }\n      }\n      if (start === this.rootStore.analyse.selectedTime) {\n        const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n        this.rootStore.ontology.setCanAddTiers({\n          ...canAddTiers,\n          [category]: {\n            index: categoryIndex,\n            first: true,\n            second: true,\n            type: shapeType,\n            ...shapeType === AnnotationType.SEGMENT && {\n              size: { start, end: end! }\n            }\n          }\n        });\n      }\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n\n  /**\n   * handle add shape\n   * @param className category\n   */\n  addInstance(className: string, time: number | number[]) {\n    const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n    const canAddTier = canAddTiers[className];\n    if (className && canAddTier !== undefined) {\n      const categoryIndex = canAddTier.index;\n      const category = this.rootStore.ontology.getCategory(className)!;\n      const updatedInstances: { [id: string]: Instance } = {};\n      const shapeType = category.type;\n      const isSegment = shapeType === AnnotationType.SEGMENT;\n      let instance: Instance | undefined;\n      let selectedId = '';\n      const add = (startTime: number) => {\n        let endTime;\n        let prevInstance: Instance | undefined;\n        const id = uuidv4();\n        if (instance) {\n          prevInstance = isSegment ? instance : undefined;\n        } else {\n          prevInstance = isSegment ? this.getCurrentSplitInstance(className, startTime) : undefined;\n        }\n        selectedId = prevInstance?.id || id;\n        if (prevInstance) {\n          const updatePrevInstance = {\n            ...prevInstance,\n            ...isSegment && {\n              end: startTime,\n            },\n          };\n          updatedInstances[prevInstance.id] = updatePrevInstance;\n          endTime = prevInstance.end;\n        } else if (isSegment) {\n          const { duration } = this.rootStore.analyse.placement;\n          endTime = duration;\n        }\n        instance = {\n          id,\n          start: startTime,\n          ...isSegment && {\n            end: endTime,\n          },\n          shapeType,\n          category: className,\n          categoryIndex\n        };\n        updatedInstances[instance.id] = instance;\n      };\n      if (Array.isArray(time)) {\n        Array.from(new Set(time)).sort((a, b) => a - b).forEach((start) => { add(start); });\n      } else {\n        add(time);\n      }\n      this.setSelectedInstance(updatedInstances[selectedId]);\n      this.setUpdatedInstances(updatedInstances);\n\n      if (this.rootStore.analyse.isPlaying) {\n        this.rootStore.analyse.handlePlay();\n      }\n    }\n  }\n\n  updateInstances = (instances: { [id: string]: Instance }) => {\n    this.instances = {\n      ...toJS(this.instances),\n      ...instances\n    };\n\n    if (this.selectedInstance) {\n      const { start, end, category } = this.selectedInstance;\n      if (Object.keys(this.rootStore.ontology.canAddTiers).filter((k) => k !== category).length === 0) {\n        if (start !== undefined && end !== undefined) {\n          this.rootStore.analyse.setSelectedRegion({ start, end });\n        } else {\n          this.rootStore.analyse.setSelectedTime(start);\n        }\n      }\n    }\n  };\n\n  getCurrentSplitInstance(category: string, start: number) {\n    const categoryInstances = this.categoryInstancesMap[category];\n\n    if (categoryInstances.length === 1) {\n      if (categoryInstances[0].start !== start) {\n        return toJS(categoryInstances[0]);\n      }\n      return undefined;\n    }\n    let prevIndex = -1;\n    for (let i = 0; i < categoryInstances.length; i += 1) {\n      const instance = categoryInstances[i];\n      if (instance.end && (start <= instance.end && start > instance.start)) {\n        prevIndex = i;\n        break;\n      } else if (!instance.end && start > instance.start) {\n        prevIndex = i;\n        break;\n      }\n    }\n\n    return categoryInstances[prevIndex] ? toJS(categoryInstances[prevIndex]) : undefined;\n  }\n\n  getAdjoinInstances(category: string, start: number) {\n    const categoryInstances = this.categoryInstancesMap[category];\n\n    if (categoryInstances.length === 1 && this.rootStore.ontology.categories[categoryInstances[0].categoryIndex].type !== AnnotationType.TIMING) {\n      return {\n        prevInstance: toJS(categoryInstances[0]),\n        nextInstance: undefined,\n      };\n    }\n    const index = categoryInstances.findIndex((instance) => instance.start === start);\n    const adjoinInstances = {\n      prevInstance: categoryInstances[index - 1] ? toJS(categoryInstances[index - 1]) : undefined,\n      nextInstance: categoryInstances[index + 1] ? toJS(categoryInstances[index + 1]) : undefined,\n    };\n    return adjoinInstances;\n  }\n\n  getPrevInstance(start: number, category?: string) {\n    const instances = category ? this.categoryInstancesMap[category] : this.allInstances.sort((a, b) => a.start - b.start);\n    return instances.find((i) => i.start < start && (i.end === undefined || i.end >= start));\n  }\n\n  getNextInstance(start: number, category?: string) {\n    const instances = category ? this.categoryInstancesMap[category] : this.allInstances.sort((a, b) => a.start - b.start);\n    return instances.find((i) => i.start > start);\n  }\n\n  /**\n   * set updated instances\n   */\n  setUpdatedInstances(instances: { [id: string]: Instance | null }, type?: string) {\n    const ids = Object.keys(instances);\n    if (ids.length === 0) {\n      return;\n    }\n    if (type !== UpdateType.INIT) {\n      const updatedInstances: { [id: string]: Instance } = {};\n      const oldInstances: { [id: string]: Instance | null } = {};\n      ids.forEach((id) => {\n        const oldInstance = this.instances[id];\n        oldInstances[id] = oldInstance ? toJS(oldInstance) : null;\n        const instance = instances[id];\n        if (instance) {\n          updatedInstances[id] = instance;\n        } else {\n          delete this.instances[id];\n          if (this.selectedInstance?.id === id) {\n            this.selectedInstanceId = null;\n          }\n        }\n      });\n      if (type !== UpdateType.UNDOREDO) {\n        this.changeUndo(oldInstances, instances);\n      }\n      this.updateInstances(updatedInstances);\n    }\n    this.updatedInstances = instances;\n  }\n\n  changeUndo(\n    oldInstances: { [id: string]: Instance | null },\n    updatedInstances: { [id: string]: Instance | null }\n  ) {\n    const before: Status[] = [];\n    const after: Status[] = [];\n    before.push({ type: 'instance',\n      status: {\n        ...oldInstances,\n      }\n    });\n    after.push({ type: 'instance',\n      status: {\n        ...updatedInstances,\n      }\n    });\n    this.rootStore.undo.saveStatus(before, after);\n  }\n\n  /**\n   * set selected instance\n   */\n  setSelectedInstance(instance: Instance | null) {\n    if (instance) {\n      const { id, category, start } = instance;\n      if (this.selectedInstanceId === id) return;\n      const categoryInstances = this.categoryInstancesMap[category];\n      const prevInstance = this.getCurrentSplitInstance(category, start);\n      if (prevInstance) {\n        const index = categoryInstances.findIndex((i) => i.start === prevInstance.start);\n        this.selectedNumber = index + 2;\n      } else {\n        this.selectedNumber = 1;\n      }\n      this.rootStore.ontology.selectCategory(category);\n    } else {\n      this.selectedNumber = null;\n    }\n    this.selectedInstanceId = instance ? instance.id : null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}