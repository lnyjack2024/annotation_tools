{"ast":null,"code":"import { notification } from 'antd';\nimport { toJS, makeAutoObservable } from 'mobx';\nimport { SegmentMode, OverlapMode } from '../components/Wave/types';\nimport { MediaModes, TimeAction } from '../types';\nimport i18n from '../locales';\nclass AtlasStore {\n  constructor(rootStore) {\n    this.rootStore = void 0;\n    this.duration = 0;\n    // audio duration\n    /**\n     * audiobuffer\n     */\n    this.audioBuffer = void 0;\n    /**\n     * draw atlas end\n     */\n    this.isDrawAtlasEnd = false;\n    /**\n     * waveform display range/precent\n     */\n    this.displayRange = {\n      start: 0,\n      end: 1\n    };\n    /**\n     * play duration\n     */\n    this.seekStep = 0;\n    /**\n     * cursor time\n     */\n    this.cursorTime = 0;\n    /**\n     * current time\n     */\n    this.currentTime = 0;\n    this.channelsOptions = [];\n    this.hideChannels = [];\n    this.playMode = MediaModes.REGION_PLAY;\n    this.isPlaying = false;\n    this.playAction = 0;\n    this.speed = 1;\n    this.overallOffset = 0;\n    this.channelOffset = [];\n    this.deviation = 0;\n    this.segmentMode = SegmentMode.INDIVIDUAL;\n    this.segmentOverlap = OverlapMode.OVERLAP;\n    this.channelCount = 0;\n    this.setDisplayRange = range => {\n      this.displayRange = range;\n    };\n    this.setAudioBuffer = buffer => {\n      this.audioBuffer = buffer;\n    };\n    this.setDuration = duration => {\n      this.duration = duration;\n    };\n    this.setIsDrawAtlasEnd = end => {\n      this.isDrawAtlasEnd = end;\n    };\n    makeAutoObservable(this, {\n      rootStore: false,\n      audioBuffer: false,\n      cursorTime: false,\n      deviation: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n  /**\n   * init by payload\n   * @param payload\n   */\n  init(payload, audioBuffer) {\n    const deviation = Number(payload.deviation);\n    if (!Number.isNaN(deviation)) {\n      this.deviation = deviation;\n    }\n    if (audioBuffer) {\n      this.setAudioBuffer(audioBuffer);\n    }\n    this.segmentMode = Object.values(SegmentMode).includes(payload.segment_mode) ? payload.segment_mode : SegmentMode.INDIVIDUAL;\n    this.segmentOverlap = Object.values(OverlapMode).includes(payload.segment_overlap) ? payload.segment_overlap : OverlapMode.OVERLAP;\n  }\n  /**\n   * set seekto\n   */\n  setSeekDuration(type) {\n    let step = this.seekStep + (type === TimeAction.FORWARD ? 1 : -1);\n    if (type === TimeAction.BACKWARD && this.seekStep > 0) {\n      step = -1;\n    } else if (type === TimeAction.FORWARD && this.seekStep < 0) {\n      step = 1;\n    }\n    this.seekStep = step;\n  }\n\n  /**\n   * set cursor time\n   */\n  setCursorTime(time) {\n    this.cursorTime = time;\n  }\n\n  /**\n   * set current time\n   */\n  setCurrentTime(time) {\n    this.currentTime = time;\n  }\n  initChannelOptions(channelCount) {\n    const options = [];\n    for (let i = 0; i < channelCount; i += 1) {\n      options.push({\n        index: i,\n        mute: false,\n        volume: 1\n      });\n    }\n    if (this.channelOffset.length === 0) {\n      this.channelOffset = new Array(channelCount).fill(0);\n    }\n    this.setChannelOptions(options);\n    this.channelCount = channelCount;\n  }\n  setChannelOptions(options) {\n    this.channelsOptions = options;\n  }\n  sethideChannels(hideChannels) {\n    this.hideChannels = hideChannels;\n  }\n  setPlayMode(mode) {\n    this.playMode = mode;\n  }\n  setIsPlaying(isplay) {\n    this.isPlaying = isplay;\n  }\n  handlePlay() {\n    this.playAction += 1;\n  }\n  setSpeed(speed) {\n    this.speed = speed;\n  }\n  resetOverallOffset() {\n    this.overallOffset = 0;\n  }\n  setOverallOffset(offset) {\n    const currentOffset = offset - this.overallOffset;\n    const newChannelOffset = toJS(this.channelOffset).map(v => v + currentOffset);\n    const isOvertime = newChannelOffset.find(v => Math.abs(v) > this.duration / 2);\n    if (!isOvertime) {\n      this.setChannelOffsets(newChannelOffset);\n      this.overallOffset = offset;\n    }\n  }\n  setChannelOffsets(channelOffset) {\n    this.channelOffset = channelOffset.map(v => Math.round(v * 100) / 100);\n  }\n  setChannelOffset(offset, index) {\n    if (Math.abs(offset) <= this.duration / 2) {\n      const newChannelOffset = toJS(this.channelOffset);\n      newChannelOffset[index] = offset;\n      this.setChannelOffsets(newChannelOffset);\n    } else {\n      notification.error({\n        message: i18n.translate('CONTROL_OFFSET_OUT_ERROR')\n      });\n    }\n  }\n}\nexport default AtlasStore;","map":{"version":3,"names":["notification","toJS","makeAutoObservable","SegmentMode","OverlapMode","MediaModes","TimeAction","i18n","AtlasStore","constructor","rootStore","duration","audioBuffer","isDrawAtlasEnd","displayRange","start","end","seekStep","cursorTime","currentTime","channelsOptions","hideChannels","playMode","REGION_PLAY","isPlaying","playAction","speed","overallOffset","channelOffset","deviation","segmentMode","INDIVIDUAL","segmentOverlap","OVERLAP","channelCount","setDisplayRange","range","setAudioBuffer","buffer","setDuration","setIsDrawAtlasEnd","autoBind","init","payload","Number","isNaN","Object","values","includes","segment_mode","segment_overlap","setSeekDuration","type","step","FORWARD","BACKWARD","setCursorTime","time","setCurrentTime","initChannelOptions","options","i","push","index","mute","volume","length","Array","fill","setChannelOptions","sethideChannels","setPlayMode","mode","setIsPlaying","isplay","handlePlay","setSpeed","resetOverallOffset","setOverallOffset","offset","currentOffset","newChannelOffset","map","v","isOvertime","find","Math","abs","setChannelOffsets","round","setChannelOffset","error","message","translate"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/store/WaveStore.ts"],"sourcesContent":["import { notification } from 'antd';\nimport { toJS, makeAutoObservable } from 'mobx';\nimport { RootStoreType } from './RootStore';\nimport { CustomChannelOptions, SegmentMode, OverlapMode } from '../components/Wave/types';\nimport { Range, MediaModes, TimeAction, Payload } from '../types';\nimport i18n from '../locales';\n\nclass AtlasStore {\n  rootStore: RootStoreType;\n\n  duration = 0; // audio duration\n\n  /**\n   * audiobuffer\n   */\n  audioBuffer?: AudioBuffer;\n\n  /**\n   * draw atlas end\n   */\n  isDrawAtlasEnd = false;\n\n  /**\n   * waveform display range/precent\n   */\n  displayRange: Range = {\n    start: 0,\n    end: 1,\n  };\n\n  /**\n   * play duration\n   */\n  seekStep = 0;\n\n  /**\n   * cursor time\n   */\n  cursorTime = 0;\n\n  /**\n   * current time\n   */\n  currentTime = 0;\n\n  channelsOptions: CustomChannelOptions[] = [];\n\n  hideChannels: number[] = [];\n\n  playMode: MediaModes = MediaModes.REGION_PLAY;\n\n  isPlaying = false;\n\n  playAction = 0;\n\n  speed = 1;\n\n  overallOffset = 0;\n\n  channelOffset: number[] = [];\n\n  deviation = 0;\n\n  segmentMode = SegmentMode.INDIVIDUAL;\n\n  segmentOverlap = OverlapMode.OVERLAP;\n\n  channelCount = 0;\n\n  constructor(rootStore: RootStoreType) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      audioBuffer: false,\n      cursorTime: false,\n      deviation: false,\n    }, {\n      autoBind: true,\n    });\n    this.rootStore = rootStore;\n  };\n\n  /**\n   * init by payload\n   * @param payload\n   */\n  init(payload: Payload, audioBuffer?: AudioBuffer) {\n    const deviation = Number(payload.deviation);\n    if (!Number.isNaN(deviation)) {\n      this.deviation = deviation;\n    }\n    if (audioBuffer) {\n      this.setAudioBuffer(audioBuffer);\n    }\n\n    this.segmentMode = Object.values(SegmentMode).includes(payload.segment_mode as SegmentMode) ?\n      payload.segment_mode as SegmentMode :\n      SegmentMode.INDIVIDUAL;\n\n    this.segmentOverlap = Object.values(OverlapMode).includes(payload.segment_overlap as OverlapMode) ?\n      payload.segment_overlap as OverlapMode :\n      OverlapMode.OVERLAP;\n  }\n\n  setDisplayRange = (range: Range) => {\n    this.displayRange = range;\n  };\n\n  setAudioBuffer = (buffer: AudioBuffer) => {\n    this.audioBuffer = buffer;\n  };\n\n  setDuration = (duration: number) => {\n    this.duration = duration;\n  };\n\n  setIsDrawAtlasEnd = (end: boolean) => {\n    this.isDrawAtlasEnd = end;\n  };\n\n  /**\n   * set seekto\n   */\n  setSeekDuration(type: TimeAction) {\n    let step = this.seekStep + (type === TimeAction.FORWARD ? 1 : -1);\n    if (type === TimeAction.BACKWARD && this.seekStep > 0) {\n      step = -1;\n    } else if (type === TimeAction.FORWARD && this.seekStep < 0) {\n      step = 1;\n    }\n    this.seekStep = step;\n  }\n\n  /**\n   * set cursor time\n   */\n  setCursorTime(time: number) {\n    this.cursorTime = time;\n  }\n\n  /**\n   * set current time\n   */\n  setCurrentTime(time: number) {\n    this.currentTime = time;\n  }\n\n  initChannelOptions(channelCount: number) {\n    const options:CustomChannelOptions[] = [];\n    for (let i = 0; i < channelCount; i += 1) {\n      options.push({\n        index: i,\n        mute: false,\n        volume: 1,\n      });\n    }\n    if (this.channelOffset.length === 0) {\n      this.channelOffset = new Array(channelCount).fill(0);\n    }\n    this.setChannelOptions(options);\n    this.channelCount = channelCount;\n  }\n\n  setChannelOptions(options: CustomChannelOptions[]) {\n    this.channelsOptions = options;\n  }\n\n  sethideChannels(hideChannels: number[]) {\n    this.hideChannels = hideChannels;\n  }\n\n  setPlayMode(mode: MediaModes) {\n    this.playMode = mode;\n  }\n\n  setIsPlaying(isplay: boolean) {\n    this.isPlaying = isplay;\n  }\n\n  handlePlay() {\n    this.playAction += 1;\n  }\n\n  setSpeed(speed: number) {\n    this.speed = speed;\n  }\n\n  resetOverallOffset() {\n    this.overallOffset = 0;\n  }\n\n  setOverallOffset(offset: number) {\n    const currentOffset = offset - this.overallOffset;\n    const newChannelOffset = toJS(this.channelOffset).map((v) => v + currentOffset);\n    const isOvertime = newChannelOffset.find((v) => Math.abs(v) > this.duration / 2);\n    if (!isOvertime) {\n      this.setChannelOffsets(newChannelOffset);\n      this.overallOffset = offset;\n    }\n  }\n\n  setChannelOffsets(channelOffset: number[]) {\n    this.channelOffset = channelOffset.map((v) => Math.round(v * 100) / 100);\n  }\n\n  setChannelOffset(offset: number, index: number) {\n    if (Math.abs(offset) <= this.duration / 2) {\n      const newChannelOffset = toJS(this.channelOffset);\n      newChannelOffset[index] = offset;\n      this.setChannelOffsets(newChannelOffset);\n    } else {\n      notification.error({ message: i18n.translate('CONTROL_OFFSET_OUT_ERROR') });\n    }\n  }\n}\n\nexport default AtlasStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}