{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/TextAnnotationApp.jsx\";\n/* eslint-disable no-nested-ternary */\n/* eslint-disable react/no-access-state-in-setstate */\n/* eslint-disable no-undef */\n/* eslint-disable no-underscore-dangle */\nimport React, { createContext } from 'react';\nimport { Editor, EditorState, convertFromRaw, getDefaultKeyBinding } from 'draft-js';\nimport { notification, message } from 'antd';\nimport { uniq } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport localMessage, { setLocale } from './locale';\nimport { LabelTag, InsertionTag, ConnectionTag } from './components/tag';\nimport { isAnnotationReadonly, isRework, isReviewEditable, isPreview } from '../../utils/tool-mode';\nimport Sidebar from './components/sidebar';\nimport { genTagMap, renderTagMap, genDisplayLabels } from './utils/tagMapUtil';\nimport LabelsDisplay from './components/labelsDisplay';\nimport FindAndReplace from './components/findAndReplace';\nimport ReviewForm from './components/reviewForm';\nimport UndoRedo from './components/UndoRedo';\nimport ReviewMode from './components/ReviewMode';\nimport Save from './components/Save';\nimport LabelScan from './components/LabelScan';\nimport { isAppenCloud } from '../../utils';\nimport AppenLogo from '../common/AppenLogo';\nimport store from './store/RootStore';\nimport './TextAnnotationApp.scss';\nimport 'draft-js/dist/Draft.css';\nimport { FIND_BLOCK, FIND_BLOCK_SELECTED, FOCUS_COLOR, DEFAULT_COLOR, FONT_COLOR, BASE_COLOR, HISTORY_SIZE, FONT_SIZE, TAG_HEIGHT, LINE_HEIGHT, EDITOR_PADDING, COMPOSITION, SELECTION, ACTION, KEY_COMMAND, RECALL_TYPE, HOVER_COLOR, FONT_SPACE, FOCUS_TYPE, HOVER_ALPHA, ACTIVE_ALPHA, DEFAULT_ALPHA } from './store/constant';\nimport { isArabic, convertArrayToColor, convertColorToArray, getSliceHead, setSelection, closeSelection, getTextByInsertion, getTargetWrapperDataSet, isElementInViewport, escapeCharacter, getConfigByKeys, getPositionWithUnicode } from './utils/helper';\nimport { isLabel, isInsertion, isConnection, isQATag } from './store/tag_mode';\nimport { ReviewItemResult, TAG, ReviewMode as ReviewModeType } from './types';\nimport TagInfoMap from './utils/TagInfoMap';\nimport Automation from './components/automation/Automation';\nimport { Guide } from './components/guide';\nconst storageKey = 'text-annotation-label-content';\nlet defaultLabelsDrawerFlag = false;\ntry {\n  const s = localStorage.getItem(storageKey);\n  defaultLabelsDrawerFlag = s === 'true';\n} catch (e) {\n  // get error\n}\nexport const TextToolContext = createContext();\nexport default class TextAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.addHistory = (type, data) => {\n      let targetList;\n      if (this.undoLock) {\n        // Add history to redo list\n        targetList = this.redoList;\n      } else if (this.redoLock) {\n        // Add history back to undo list\n        targetList = this.undoList;\n        // Clear redo list\n      } else {\n        // Add history to redo list\n        targetList = this.undoList;\n        this.redoList = [];\n      }\n      let {\n        length\n      } = targetList;\n      if (length > HISTORY_SIZE) {\n        targetList.shift();\n        length -= 1;\n      }\n      if (type === ACTION.EDIT_SINGLE_ADD && length >= 1) {\n        const prev = targetList[length - 1];\n        if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_ADD) && prev.data.prevSlice === '' && prev.data.end === data.prevStart) {\n          targetList.pop();\n          targetList.push({\n            type: ACTION.EDIT_DEFAULT,\n            data: {\n              prevSlice: '',\n              slice: prev.data.slice + data.slice,\n              prevStart: prev.data.prevStart,\n              prevEnd: prev.data.prevEnd,\n              start: data.start,\n              end: data.end\n            }\n          });\n        } else targetList.push({\n          type,\n          data\n        });\n      } else if (type === ACTION.EDIT_SINGLE_DEL && length >= 1) {\n        const prev = targetList[length - 1];\n        if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_DEL) && prev.data.slice === '' && data.prevEnd === prev.data.start) {\n          targetList.pop();\n          targetList.push({\n            type: ACTION.EDIT_DEFAULT,\n            data: {\n              slice: '',\n              prevSlice: data.prevSlice + prev.data.prevSlice,\n              prevStart: data.end,\n              prevEnd: prev.data.prevEnd,\n              start: data.start,\n              end: data.end\n            }\n          });\n        } else targetList.push({\n          type,\n          data\n        });\n      } else targetList.push({\n        type,\n        data\n      });\n    };\n    this.executeHistory = recallType => {\n      // Execute history\n      let targetList;\n      if (recallType === RECALL_TYPE.UNDO) {\n        // Get from undo list\n        this.undoLock = true;\n        targetList = this.undoList;\n      } else if (recallType === RECALL_TYPE.REDO) {\n        // Get from redo list\n        this.redoLock = true;\n        targetList = this.redoList;\n      }\n      if (targetList.length === 0) {\n        this.undoLock = false;\n        this.redoLock = false;\n        return;\n      }\n      const item = targetList.pop();\n      const {\n        data\n      } = item;\n      let nextEditorState = this.state.editorState;\n      switch (item.type) {\n        case ACTION.EDIT_SINGLE_ADD:\n        case ACTION.EDIT_SINGLE_DEL:\n        case ACTION.EDIT_DEFAULT:\n        case ACTION.EDIT_REPLACE:\n          {\n            const newData = {\n              prevSlice: data.slice,\n              slice: data.prevSlice,\n              start: data.prevEnd,\n              end: data.prevEnd,\n              prevStart: data.prevStart,\n              prevEnd: data.end,\n              ...(item.type === ACTION.EDIT_REPLACE && {\n                tags: data.prevTags,\n                prevTags: data.tags\n              })\n            };\n            // nextEditorState = this.onContentChange(nextEditorState, newData);\n            nextEditorState = setSelection(this.onContentChange(nextEditorState, newData, item.type), newData.start, newData.end);\n            break;\n          }\n        case ACTION.ADD_INSERTION:\n          {\n            const {\n              type,\n              id\n            } = data.insertion;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.ADD_LABEL:\n          {\n            const {\n              type,\n              id\n            } = data.label;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.ADD_LABELS:\n          {\n            nextEditorState = this.deleteLabels(data);\n            break;\n          }\n        case ACTION.ADD_MISSING_REVIEW:\n          {\n            const {\n              preReview,\n              id\n            } = data;\n            if (preReview) {\n              const {\n                editorState\n              } = this.addReview(nextEditorState, id, {\n                ...preReview\n              });\n              nextEditorState = editorState;\n            } else {\n              const {\n                editorState\n              } = this.deleteQATag(id);\n              nextEditorState = editorState;\n            }\n            break;\n          }\n        case ACTION.ADD_CONNECTION:\n          {\n            const {\n              type,\n              id\n            } = data;\n            nextEditorState = this.deleteTag(type, id);\n            break;\n          }\n        case ACTION.DEL_LABELS:\n          {\n            nextEditorState = this.addLabels(nextEditorState, data.labels);\n            break;\n          }\n        case ACTION.DEL_LABEL:\n          {\n            const {\n              relatedConnections,\n              label\n            } = data;\n            nextEditorState = this.addLabel(nextEditorState, label, relatedConnections);\n            break;\n          }\n        case ACTION.DEL_MISSING_REVIEW:\n          {\n            const {\n              label,\n              review\n            } = data;\n            const {\n              editorState\n            } = this.addQALabel(nextEditorState, label, {\n              ...review\n            });\n            nextEditorState = editorState;\n            break;\n          }\n        case ACTION.DEL_INSERTION:\n          {\n            const {\n              relatedConnections,\n              insertion\n            } = data;\n            nextEditorState = this.addInsertion(nextEditorState, insertion, relatedConnections);\n            break;\n          }\n        case ACTION.DEL_CONNECTION:\n          {\n            const {\n              connection\n            } = data;\n            nextEditorState = this.addConnection(nextEditorState, connection);\n            break;\n          }\n        case ACTION.EDIT_REPLACE_ALL:\n          {\n            const {\n              text: currentText,\n              prevText,\n              prevResults,\n              results\n            } = data;\n            store.ontology.updateText(prevText);\n            store.ontology.setResults(prevResults);\n            this.raw = this.renderTextArea(prevText);\n            nextEditorState = EditorState.set(nextEditorState, {\n              currentContent: convertFromRaw(this.raw)\n            });\n            this.addHistory(ACTION.EDIT_REPLACE_ALL, {\n              text: prevText,\n              prevText: currentText,\n              prevResults: results,\n              results: prevResults\n            });\n            break;\n          }\n        case ACTION.ADD_REVIEW:\n          {\n            const {\n              preReview,\n              id\n            } = data;\n            if (preReview) {\n              const {\n                editorState\n              } = this.addReview(nextEditorState, id, {\n                ...preReview\n              });\n              nextEditorState = editorState;\n            } else {\n              const {\n                editorState\n              } = this.deleteReview(id);\n              nextEditorState = editorState;\n            }\n            break;\n          }\n        case ACTION.DELETE_REVIEW:\n          {\n            const {\n              review,\n              id\n            } = data;\n            const {\n              editorState\n            } = this.addReview(nextEditorState, id, {\n              ...review\n            });\n            nextEditorState = editorState;\n            break;\n          }\n        case ACTION.ADD_REVIEWS:\n          {\n            nextEditorState = this.deleteReviewItems(data);\n            break;\n          }\n        case ACTION.DELETE_REVIEWS:\n          {\n            nextEditorState = this.addReviewItems(nextEditorState, data);\n            break;\n          }\n        default:\n          break;\n      }\n      this.renderAndSave(nextEditorState);\n      this.undoLock = false;\n      this.redoLock = false;\n      const {\n        findStr,\n        findPanelVisible,\n        selectedIndex\n      } = this.state;\n      if (findStr && findPanelVisible && [ACTION.EDIT_REPLACE, ACTION.EDIT_REPLACE_ALL].includes(item.type)) {\n        this.onFind(findStr, selectedIndex || 1);\n      }\n    };\n    this.renderAndSave = (_editorState, shouldRenderTags = true, shouldResetCurrentState = false, shouldSaveURL = false) => {\n      const editorState = _editorState || this.state.editorState;\n      const {\n        hasFocus\n      } = editorState.getSelection();\n      const top = this.editorWrapper.scrollTop;\n      // window.ew = this.editorWrapper;\n      return new Promise(resolve => {\n        if (shouldResetCurrentState) {\n          this.resetCurrentFrom();\n        }\n        this.setState({\n          editorState\n        });\n        if (shouldSaveURL) {\n          this.exportResult();\n        }\n        resolve();\n      }).then(() => {\n        if (shouldRenderTags) {\n          const {\n            nextEditorState,\n            tagMap\n          } = this.measureTags(editorState);\n          return new Promise(resolve => {\n            this.setState({\n              editorState: nextEditorState,\n              tagMap,\n              editorWidth: this.editorWrapper.offsetWidth - EDITOR_PADDING * 2,\n              editorHeight: this.editorWrapper.scrollHeight - EDITOR_PADDING * 2\n            }, () => {\n              store.ontology.updateOntologiesStatusMap();\n            });\n            this.renderTags(tagMap);\n            resolve();\n          });\n        }\n      }).then(() => {\n        if (hasFocus) {\n          // move back to current selection after composition end\n          if (this.compositionTop >= 0) {\n            this.editor.focus({\n              y: this.compositionTop\n            });\n            this.compositionTop = -1;\n          } else this.editor.focus({\n            y: top\n          });\n        }\n        return new Promise(resolve => resolve());\n      }).then(() => {\n        const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n        this.setState({\n          displayLabels\n        });\n      });\n    };\n    this.updateEditorAndRender = options => {\n      let {\n        editorState\n      } = this.state;\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      if (options && typeof options[Symbol.iterator] === 'function') {\n        return this.renderAndSave(editorState, ...options);\n      }\n      return this.renderAndSave(editorState);\n    };\n    this.isEditorEditMode = () => {\n      const {\n        currentBrush,\n        inputEnable\n      } = this.state;\n      return currentBrush === null && inputEnable;\n    };\n    this.onChange = editorState => {\n      // ignore composition operation\n      if (this.compositionFlag === COMPOSITION.ENABLED) return;\n      // get operation type ( handled operation not included )\n      const prevEditorState = this.state.editorState;\n      const prevText = store.ontology.text;\n      const text = editorState.getCurrentContent().getPlainText();\n      let prevStart = prevEditorState.getSelection().getStartOffset();\n      const prevEnd = prevEditorState.getSelection().getEndOffset();\n      const start = editorState.getSelection().getStartOffset();\n      const end = editorState.getSelection().getEndOffset();\n      const {\n        hasFocus\n      } = editorState.getSelection();\n      const {\n        hasFocus: prevFocus\n      } = prevEditorState.getSelection();\n      if (hasFocus !== prevFocus) {\n        // when focus change update new editor state and return without doing anything\n        const nextEditorState = EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        });\n        this.renderAndSave(nextEditorState, null, false);\n        return;\n      }\n      if (this.inputFlag || this.pasteFlag || this.compositionFlag === COMPOSITION.PENDING || prevText !== text) {\n        /* text changed:\n         * 1. deleted by delete key\n         * 2. deleted by drag + delete key\n         * 3. deleted by drag + cut operation\n         * 4. insert/replace by (drag) + simply typing\n         * 5. insert/replace by (drag) + composition typing\n         * 6. insert/replace by (drag) + paste operation\n         * 7. redo && undo\n         */\n        if (prevStart === prevEnd && start === prevStart - 1) prevStart -= 1;\n        const prevSlice = prevText.slice(prevStart, prevEnd);\n        const slice = text.slice(prevStart, end);\n        const data = {\n          prevSlice,\n          slice,\n          prevStart,\n          prevEnd,\n          start,\n          end\n        };\n        const nextEditorState = this.onContentChange(editorState, data);\n        // reset flag\n        this.inputFlag = false;\n        this.pasteFlag = false;\n        this.compositionFlag = COMPOSITION.DISABLED;\n        this.renderAndSave(nextEditorState);\n      } else {\n        /* selection changed\n         * 1. simply select\n         * 2. click select: add insertion\n         * 3. drag select: add label\n         */\n        const data = {\n          start,\n          end\n        };\n        const {\n          nextEditorState,\n          type\n        } = this.onSelectionChange(editorState, data);\n        const shouldRender = type !== SELECTION.MOVE;\n        this.renderAndSave(nextEditorState, shouldRender, shouldRender);\n      }\n    };\n    this.renderTags = tagMap => {\n      const spanMap = this.getAnchorElementsByHeads();\n      renderTagMap(tagMap, spanMap);\n    };\n    this.onSave = async () => {\n      if (isPreview(this.toolMode)) return;\n      try {\n        if (!isAnnotationReadonly(this.toolMode)) {\n          await this.exportResult();\n        }\n        if (isReviewEditable(this.toolMode)) {\n          await this.submitReviews(false);\n        }\n        message.success(localMessage('saveSuccess'));\n      } catch (e) {\n        message.warning(localMessage('saveFail'));\n      }\n    };\n    this.onSubmit = async params => {\n      const invalid = params && params.validityFlag === 'false';\n      if (store.config.submitCheck && (!invalid || !store.config.skipCheckForInvalidData)) {\n        // validate before submit\n        await store.validation.defaultSync();\n        if (store.validation.blocked) {\n          throw new Error(localMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n      return this.exportResult(true);\n    };\n    this.exportResult = (isSubmit = false) => {\n      if (isAnnotationReadonly(this.toolMode)) return;\n      return store.saveResult(isSubmit);\n    };\n    this.measureTags = editorState => {\n      const {\n        raw\n      } = this;\n      const {\n        text\n      } = store.ontology;\n      const {\n        labels,\n        insertions\n      } = store.ontology.getResults();\n      const spanMap = this.getAnchorElementsByHeads();\n      const offsetTops = uniq(labels.map(label => {\n        var _spanMap$get;\n        return (_spanMap$get = spanMap.get(label.start)) === null || _spanMap$get === void 0 ? void 0 : _spanMap$get.offsetTop;\n      }).concat(insertions.map(insertion => {\n        var _spanMap$get2;\n        return (_spanMap$get2 = spanMap.get(insertion.at)) === null || _spanMap$get2 === void 0 ? void 0 : _spanMap$get2.offsetTop;\n      })));\n      const occupyMap = new Map();\n      offsetTops.forEach(offsetTop => {\n        occupyMap.set(offsetTop, []);\n      });\n\n      // get label offsets\n      const tagMap = genTagMap(store.ontology.getResults(), store.ontology.ontologyConfigMap, spanMap, occupyMap, text);\n      const ranges = raw.blocks[0].inlineStyleRanges;\n      const style = {\n        ...this.state.style\n      };\n      ranges.filter(item => item.style.slice(0, 6) === 'ANCHOR').forEach(item => {\n        const span = this.getAnchorElementByHead(item.offset);\n        if (span) {\n          const occupyList = occupyMap.get(span.offsetTop);\n          const lineHeight = occupyList.map(it => it.top > 0 ? it.top - FONT_SIZE + TAG_HEIGHT : -it.top).sort((a, b) => a - b).pop() * 2 + LINE_HEIGHT;\n          style[`LINEHEIGHT_${lineHeight}`] = {\n            lineHeight: `${lineHeight}px`\n          };\n          ranges.push({\n            offset: item.offset,\n            length: item.length,\n            style: `LINEHEIGHT_${lineHeight}`\n          });\n        }\n      });\n      this.setState({\n        style\n      });\n      const nextEditorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      return {\n        nextEditorState,\n        tagMap\n      };\n    };\n    this.onSelectionChange = (editorState, data) => {\n      const {\n        start,\n        end\n      } = data;\n      const {\n        currentBrush\n      } = this.state;\n      if (!this.mouseFlag) {\n        return {\n          nextEditorState: editorState,\n          type: SELECTION.MOVE\n        };\n      }\n      if (start === end && isInsertion(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n        const fbAt = strlen(store.ontology.text.slice(0, start));\n        const nextEditorState = this.addInsertion(editorState, {\n          at: fbAt,\n          value: currentBrush.text,\n          keys: currentBrush.keys,\n          type: TAG.INSERTION\n        });\n        return {\n          nextEditorState,\n          type: SELECTION.CLICK\n        };\n      }\n      if (start !== end && isLabel(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n        const fbStart = strlen(store.ontology.text.slice(0, start));\n        const fbEnd = strlen(store.ontology.text.slice(0, end));\n        if (isQATag(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) {\n          const {\n            editorState: nextEditorState\n          } = this.addQALabel(editorState, {\n            start: fbStart,\n            end: fbEnd,\n            value: currentBrush.text,\n            keys: currentBrush.keys,\n            type: currentBrush.type\n          }, {\n            result: ReviewItemResult.MISSING\n          }, true, true);\n          return {\n            nextEditorState,\n            type: SELECTION.DRAG\n          };\n        }\n        const nextEditorState = this.addLabel(editorState, {\n          start: fbStart,\n          end: fbEnd,\n          value: currentBrush.text,\n          keys: currentBrush.keys,\n          type: currentBrush.type\n        });\n        return {\n          nextEditorState,\n          type: SELECTION.DRAG\n        };\n      }\n      return {\n        nextEditorState: editorState,\n        type: SELECTION.MOVE\n      };\n    };\n    this.onApplyAutomationLabels = (editorState, labels) => {\n      const formattedLabels = store.ontology.applyAutomationLabels(labels);\n      const newEditorState = this.addLabels(editorState, formattedLabels);\n      this.renderAndSave(newEditorState);\n    };\n    this.addLabels = (editorState, labels) => {\n      store.ontology.addLabels(labels);\n      this.addHistory(ACTION.ADD_LABELS, labels);\n      this.raw = this.renderTextArea();\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return editorState;\n    };\n    this.deleteLabels = data => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      const operation = store.ontology.deleteLabels(data);\n      this.addHistory(ACTION.DEL_LABELS, operation);\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.deleteTag = (type, id) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (isQATag(type) && store.config.reviewMode !== ReviewModeType.REVIEW) {\n        return editorState;\n      }\n      if (!isQATag(type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n        return;\n      }\n      if (isAnnotationReadonly(this.toolMode)) {\n        return editorState;\n      }\n      const operation = store.ontology.deleteTag(type, id);\n      switch (true) {\n        case isLabel(type):\n          this.addHistory(ACTION.DEL_LABEL, operation);\n          break;\n        case isConnection(type):\n          this.addHistory(ACTION.DEL_CONNECTION, operation);\n          break;\n        case isInsertion(type):\n          this.addHistory(ACTION.DEL_INSERTION, operation);\n          break;\n        default:\n          break;\n      }\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.addInsertion = (editorState, {\n      at,\n      value,\n      id,\n      keys,\n      type\n    }, relatedConnections = []) => {\n      const {\n        state: {\n          currentBrush\n        },\n        toolMode\n      } = this;\n      const {\n        text\n      } = store.ontology;\n      if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n      if (at === strlen(text)) return editorState; // prevent insert to the end of content\n      // eslint-disable-next-line no-restricted-syntax\n      for (const item of store.ontology.results.insertions) {\n        if (item.at === at && item.value === currentBrush.text) return editorState;\n      }\n      if (!id) id = uuidv4();\n      const arabic = isArabic(substr(text, at));\n      if (arabic && at) at -= 1;\n      const newItem = {\n        type,\n        at,\n        value,\n        id,\n        text: getTextByInsertion(store.ontology.text, {\n          at,\n          value\n        }),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_INSERTION, {\n        insertion: newItem,\n        relatedConnections\n      });\n      store.ontology.addResultItem(newItem, relatedConnections);\n      this.raw = this.renderTextArea();\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return editorState;\n    };\n    this.addConnection = (editorState, {\n      fromId,\n      fromType,\n      toId,\n      toType,\n      value,\n      id,\n      keys,\n      type\n    }) => {\n      const {\n        state: {\n          currentBrush\n        },\n        toolMode\n      } = this;\n      if (isAnnotationReadonly(toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n      if (fromId === toId) return editorState;\n      if (isQATag(fromType) || isQATag(toType)) return editorState; // can't add connection for qa tool\n\n      if (store.ontology.results.connections.some(item => item.fromId === fromId && item.toId === toId && item.value === currentBrush.text)) return editorState;\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        fromId,\n        fromType,\n        toId,\n        toType,\n        value,\n        id,\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_CONNECTION, newItem);\n      store.ontology.addResultItem(newItem);\n      this.raw = this.renderTextArea();\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      return editorState;\n    };\n    this.addLabel = (editorState, {\n      start,\n      end,\n      value,\n      id,\n      keys,\n      type\n    }, relatedConnections = []) => {\n      const {\n        toolMode\n      } = this;\n      const {\n        ontology,\n        config\n      } = store;\n      const {\n        text\n      } = store.ontology;\n      if (config.reviewMode === ReviewModeType.REVIEW && !isQATag(type)) return editorState;\n      if (isAnnotationReadonly(this.toolMode) && !isQATag(type)) return editorState;\n      if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return editorState; // qa mode can only use qa tool, work mode can only use normal tool\n\n      // slice should not begin with \\n\n      if (substr(text, start, 1) === '\\n') return editorState;\n      if (ontology.results.labels.some(item => item.start === start && item.end === end && item.value === value)) return editorState;\n\n      // generate new label\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        start,\n        end,\n        value,\n        id,\n        text: substr(text, start, end - start),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      this.addHistory(ACTION.ADD_LABEL, {\n        label: newItem,\n        relatedConnections\n      });\n      ontology.addResultItem(newItem, relatedConnections);\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return editorState;\n    };\n    this.addQALabel = (editorState, {\n      start,\n      end,\n      value,\n      id,\n      keys,\n      type\n    }, reviewInfo, needUnRedo = true, needOpenReview = false) => {\n      const {\n        toolMode\n      } = this;\n      const {\n        ontology,\n        review\n      } = store;\n      const {\n        text\n      } = ontology;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n\n      // slice should not begin with \\n\n      if (substr(text, start, 1) === '\\n') return {\n        editorState,\n        operation: null\n      };\n      if (review.reviews.missing.some(item => item.start === start && item.end === end && item.value === value)) return {\n        editorState,\n        operation: null\n      };\n\n      // generate new label\n      if (!id) id = uuidv4();\n      const newItem = {\n        type,\n        start,\n        end,\n        value,\n        id,\n        text: substr(text, start, end - start),\n        isReview: isReviewEditable(toolMode),\n        keys\n      };\n      if (needOpenReview) {\n        this.setState({\n          tagOpenReview: {\n            ...newItem\n          }\n        });\n      }\n      const operation = review.addMissingReview(newItem, id, {\n        ...reviewInfo\n      });\n      if (needUnRedo) {\n        this.addHistory(ACTION.ADD_MISSING_REVIEW, operation);\n      }\n\n      // update rawDraftContentState, using new results\n      this.raw = this.renderTextArea();\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      editorState = closeSelection(editorState);\n      return {\n        editorState,\n        operation\n      };\n    };\n    this.deleteQATag = (id, needUnRedo = true) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      const operation = store.review.deleteMissingReview(id);\n      if (needUnRedo) {\n        this.addHistory(ACTION.DEL_MISSING_REVIEW, operation);\n        this.raw = this.renderTextArea();\n        return {\n          editorState: EditorState.set(editorState, {\n            currentContent: convertFromRaw(this.raw)\n          }),\n          operation\n        };\n      }\n      return {\n        editorState,\n        operation\n      };\n    };\n    this.deleteReview = (reviewId, needUnRedo = true) => {\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState,\n          operation: null\n        };\n      }\n      const operation = store.review.deleteReview(reviewId);\n      if (needUnRedo) {\n        this.addHistory(ACTION.DELETE_REVIEW, operation);\n        this.raw = this.renderTextArea();\n        return {\n          editorState: EditorState.set(editorState, {\n            currentContent: convertFromRaw(this.raw)\n          }),\n          operation\n        };\n      }\n      return {\n        editorState,\n        operation\n      };\n    };\n    this.addReview = (editorState, reviewId, review, needUnRedo = true) => {\n      const {\n        state: {\n          editorState: currEditorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return {\n          editorState: currEditorState,\n          operation: null\n        };\n      }\n      const operation = store.review.setReview(reviewId, {\n        ...review\n      });\n      if (needUnRedo) {\n        this.addHistory(ACTION.ADD_REVIEW, operation);\n      }\n      return {\n        editorState,\n        operation\n      };\n    };\n    this.deleteReviewItemById = reviewId => {\n      if (reviewId) {\n        let nextEditorState = this.state.editorState;\n        const reviewItem = store.ontology.getItemById(reviewId);\n        if (reviewItem && isQATag(reviewItem.type)) {\n          const {\n            editorState\n          } = this.deleteQATag(reviewItem.id);\n          nextEditorState = editorState;\n        } else {\n          const {\n            editorState\n          } = this.deleteReview(reviewId);\n          nextEditorState = editorState;\n        }\n        this.renderAndSave(nextEditorState);\n      }\n    };\n    this.deleteReviewItemsById = reviewIds => {\n      const operations = [];\n      reviewIds === null || reviewIds === void 0 ? void 0 : reviewIds.forEach(reviewId => {\n        if (reviewId) {\n          const reviewItem = store.ontology.getItemById(reviewId);\n          if (reviewItem && isQATag(reviewItem.type)) {\n            const {\n              operation\n            } = this.deleteQATag(reviewItem.id, false);\n            if (operation) {\n              operations.push(operation);\n            }\n          } else {\n            const {\n              operation\n            } = this.deleteReview(reviewId, false);\n            if (operation) {\n              operations.push(operation);\n            }\n          }\n        }\n      });\n      this.addHistory(ACTION.DELETE_REVIEWS, operations);\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      this.raw = this.renderTextArea();\n      const nextEditorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      this.renderAndSave(nextEditorState);\n    };\n    this.deleteReviewItems = reviewItems => {\n      const operations = [];\n      const {\n        state: {\n          editorState\n        }\n      } = this;\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return editorState;\n      }\n      reviewItems === null || reviewItems === void 0 ? void 0 : reviewItems.forEach(reviewItem => {\n        const {\n          review,\n          id\n        } = reviewItem;\n        if (review.result === ReviewItemResult.MISSING) {\n          const {\n            operation\n          } = this.deleteQATag(id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const {\n            operation\n          } = this.deleteReview(id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      });\n      this.addHistory(ACTION.DELETE_REVIEWS, operations);\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.addReviewItems = (editorState, reviewItems) => {\n      const operations = [];\n      if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n        return editorState;\n      }\n      reviewItems === null || reviewItems === void 0 ? void 0 : reviewItems.forEach(reviewItem => {\n        const {\n          review,\n          id\n        } = reviewItem;\n        if (review.result === ReviewItemResult.MISSING) {\n          const {\n            operation\n          } = this.addQALabel(editorState, reviewItem.label, {\n            ...review\n          }, false, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const {\n            operation\n          } = this.addReview(editorState, id, {\n            ...review\n          }, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      });\n      this.addHistory(ACTION.ADD_REVIEWS, operations);\n      this.raw = this.renderTextArea();\n      return EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n    };\n    this.deleteReviewHandle = reviewItem => {\n      if (reviewItem) {\n        let nextEditorState = this.state.editorState;\n        if (isQATag(reviewItem.type)) {\n          const {\n            editorState\n          } = this.deleteQATag(reviewItem.id);\n          nextEditorState = editorState;\n        } else {\n          const {\n            editorState\n          } = this.deleteReview(reviewItem.id);\n          nextEditorState = editorState;\n        }\n        this.renderAndSave(nextEditorState);\n      }\n    };\n    this.onDeleteReview = () => {\n      const {\n        tagOpenReview\n      } = this.state;\n      this.deleteReviewHandle(tagOpenReview);\n    };\n    // create new RawDraftContentState and update customeStyleMap\n    // update: raw, style, sliceMap\n    this.renderTextArea = _text => {\n      const {\n        ontology\n      } = store;\n      const {\n        ontologyConfigMap\n      } = ontology;\n      const {\n        currentClick,\n        currentHover,\n        foundTags,\n        foundTagSelectedIndex,\n        needJumpFound\n      } = this.state;\n      const style = {\n        ...this.state.style\n      };\n      const text = _text || store.ontology.text;\n      const {\n        labels,\n        insertions\n      } = ontology.getResults();\n      // render missing labels as normal labels\n\n      // slice text to segments\n      const slices = uniq(labels.map(label => label.start).concat(labels.map(label => label.end)).concat(insertions.map(insertion => insertion.at)).concat(foundTags.map(t => t.start)).concat(foundTags.map(t => t.end)).concat([0, text.length]).sort((a, b) => a - b));\n      const labelHeads = uniq(labels.map(label => label.start));\n      const insertionHeads = uniq(insertions.map(insertion => insertion.at));\n      const foundTagHeads = uniq(foundTags.map(tag => tag.start));\n\n      // .concat(insertions.map((insertion) => insertion.at)));\n      const raw = {\n        blocks: [{\n          text,\n          key: 'span-wrapper',\n          type: 'unstyled',\n          depth: 0,\n          inlineStyleRanges: [{\n            offset: 0,\n            length: text.length,\n            style: 'DEFAULT_STYLE'\n          }],\n          children: [],\n          entityRanges: [],\n          data: {}\n        }],\n        entityMap: {}\n      };\n      let sliceCount = 0;\n      // 对重叠的tag进行背景色叠加\n      const ranges = raw.blocks[0].inlineStyleRanges;\n      this.sliceMap = new Map();\n      slices.forEach((anchor, index, array) => {\n        // set slice\n        if (!index) return;\n        const {\n          prev,\n          next\n        } = {\n          prev: array[index - 1],\n          next: anchor\n        };\n        const match = labels.filter(label => label.start <= prev && label.end > prev);\n        let currentRGB = [0, 0, 0];\n        let currentAlpha = 0;\n        let nextAlpha = DEFAULT_ALPHA;\n        let isCoverbyQa = false;\n        let keepRGB = null;\n        match.some(label => {\n          const labelItem = getConfigByKeys(ontologyConfigMap, label.keys);\n          const tempRGB = convertColorToArray(labelItem.color);\n          if (!keepRGB) isCoverbyQa = isQATag(label.type);\n          // render clicked tag in priority\n          if (currentClick.id === label.id || currentClick.fromId === label.id || currentClick.toId === label.id) {\n            keepRGB = tempRGB.map((value, i) => value * ACTIVE_ALPHA);\n            isCoverbyQa = isQATag(label.type);\n            return true;\n          }\n          if (!keepRGB && currentHover.id === label.id || currentHover.fromId === label.id || currentHover.toId === label.id) {\n            keepRGB = tempRGB.map(v => v * HOVER_ALPHA);\n          }\n          if (!keepRGB) {\n            currentRGB = currentRGB.map((value, i) => value + tempRGB[i] * nextAlpha);\n            currentAlpha += nextAlpha;\n            nextAlpha = DEFAULT_ALPHA * (1 - currentAlpha) * (1 - currentAlpha);\n          }\n          return false;\n        });\n        // background of found tag\n        foundTags.filter(tag => tag.start <= prev && tag.end > prev).some(tag => {\n          const tagIndex = foundTags.findIndex(f => f.start === tag.start);\n          if (tagIndex !== undefined) {\n            keepRGB = foundTagSelectedIndex === tagIndex && !needJumpFound ? [255, 230, 0] : [255, 169, 64, 0.20];\n            return true;\n          }\n          return false;\n        });\n        const baseRGB = convertColorToArray(BASE_COLOR);\n        currentRGB = keepRGB || currentRGB.map((value, i) => Math.min(255, value + baseRGB[i] * (1 - currentAlpha)));\n        const currentColor = convertArrayToColor(currentRGB);\n        if (!style[`BACKGROUND_${currentColor}`]) style[`BACKGROUND_${currentColor}`] = {\n          backgroundColor: currentColor\n        };\n        if (isCoverbyQa) ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: 'MISSING_STYLE'\n        });\n        ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: `BACKGROUND_${currentColor}`\n        });\n        ranges.push({\n          offset: prev,\n          length: next - prev,\n          style: `SLICE_${prev}_${next}`\n        });\n        // set slice head if for label/insertion slice\n        if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0) {\n          const slice = substr(text, prev, next - prev);\n          const head = getSliceHead(slice);\n          ranges.push({\n            offset: prev,\n            length: strlen(head),\n            style: `ANCHOR_${prev}`\n          });\n        }\n        if (foundTagHeads.indexOf(prev) >= 0) {\n          const tagIndex = foundTags.findIndex(f => f.start === prev);\n          if (tagIndex !== undefined) {\n            const tag = foundTags[tagIndex];\n            ranges.push({\n              offset: prev,\n              length: tag.end - tag.start,\n              style: foundTagSelectedIndex === tagIndex && !needJumpFound ? 'FIND_BLOCK_SELECTED' : 'FIND_BLOCK'\n            });\n          }\n        }\n        if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0 || foundTagHeads.indexOf(prev) >= 0) {\n          const slice = substr(text, prev, next - prev);\n          const head = getSliceHead(slice);\n          // set sliceMap\n          this.sliceMap.set(prev, sliceCount);\n          if (head !== slice) sliceCount += 1;\n        }\n        sliceCount += 1;\n      });\n      // update new style\n      this.setState({\n        style\n      });\n      return raw;\n    };\n    this.onMouseMove = e => {\n      const box = this.svg.getBoundingClientRect();\n      this.setState({\n        currentMouse: {\n          left: e.clientX - box.x,\n          top: e.clientY - box.y\n        }\n      });\n    };\n    this.moveFocusToTag = tag => {\n      let currentClick = {\n        ...this.state.currentClick\n      };\n      const {\n        tagMap\n      } = this.state;\n      if (tag == null) return;\n      currentClick = {\n        id: tag.id,\n        fromId: tag.fromId,\n        toId: tag.toId,\n        fromType: tag.fromType,\n        toType: tag.toType\n      };\n      const {\n        top\n      } = tagMap.getItem(tag.id, tag.type);\n      const {\n        clientHeight,\n        scrollTop\n      } = this.editorWrapper;\n      if (top < scrollTop || top > clientHeight + scrollTop) {\n        this.editor.focus({\n          y: top\n        });\n      }\n      this.setState({\n        currentClick\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    };\n    this.onKeyDown = e => {\n      if (window.disableTextHotKeys) {\n        return;\n      }\n      const {\n        currentClick,\n        editorState,\n        findPanelVisible\n      } = this.state;\n      const {\n        keyCode,\n        ctrlKey,\n        altKey\n      } = e;\n      if (!this.isEditorEditMode() && !findPanelVisible) {\n        // select ontologyItem\n        const success = this.selectOntologyByHotkey(e);\n        if (success) {\n          e.stopImmediatePropagation();\n          return;\n        }\n      }\n      if (ctrlKey) {\n        switch (true) {\n          case keyCode === 90:\n            e.preventDefault();\n            this.executeHistory(RECALL_TYPE.UNDO);\n            break;\n          // Z\n          case keyCode === 89:\n            e.preventDefault();\n            this.executeHistory(RECALL_TYPE.REDO);\n            break;\n          // Y\n          case keyCode === 83:\n            e.preventDefault();\n            this.onSave();\n            break;\n          // S\n          case keyCode === 82:\n            {\n              // R move in qa tag\n              e.preventDefault();\n              const nTag = store.ontology.moveToTagByStep(currentClick.id, 1, true);\n              this.moveFocusToTag(nTag);\n              break;\n            }\n          case keyCode === 81:\n            {\n              // Q\n              e.preventDefault();\n              if (currentClick.id == null) break;\n              let nxtTag;\n              if (altKey) {\n                // move in current category\n                nxtTag = store.ontology.stepToTag(currentClick.id, -1);\n              } else {\n                // move in all tag\n                nxtTag = store.ontology.moveToTagByStep(currentClick.id, -1);\n              }\n              this.moveFocusToTag(nxtTag);\n              break;\n            }\n          case keyCode === 69:\n            {\n              // E\n              e.preventDefault();\n              if (currentClick.id == null) break;\n              let nextTag;\n              if (altKey) {\n                nextTag = store.ontology.stepToTag(currentClick.id, 1);\n              } else {\n                nextTag = store.ontology.moveToTagByStep(currentClick.id, 1);\n              }\n              this.moveFocusToTag(nextTag);\n              break;\n            }\n          default:\n            break;\n        }\n      } else if (!this.isEditorEditMode()) {\n        switch (keyCode) {\n          case 8:\n            // Delete\n            if (currentClick.id && !this.state.findPanelVisible) {\n              e.preventDefault();\n              e.stopPropagation();\n              this.onDeleteTag(currentClick.id, currentClick.type);\n            }\n            break;\n          default:\n            break;\n        }\n      } else if ((currentClick === null || currentClick === void 0 ? void 0 : currentClick.id) !== null && isReviewEditable(this.toolMode) && !isQATag(currentClick.type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n        switch (keyCode) {\n          case 49:\n            // 1\n            e.preventDefault();\n            e.stopPropagation();\n            this.addReview(editorState, currentClick.id, {\n              result: 'pass'\n            });\n            break;\n          // 2\n          case 50:\n            {\n              e.preventDefault();\n              e.stopPropagation();\n              let tagReviewInfo = store.review.getReview(currentClick.id);\n              if (!tagReviewInfo || tagReviewInfo.result !== ReviewItemResult.REJECT) {\n                tagReviewInfo = {\n                  result: 'reject',\n                  id: currentClick.id,\n                  type: []\n                };\n              }\n              const item = store.ontology.getItem(currentClick.type, currentClick.id);\n              this.setState({\n                tagOpenReview: item,\n                tagReviewInfo\n              });\n              this.editor.blur();\n              break;\n            }\n          default:\n            break;\n        }\n      }\n    };\n    // update text\n    this.onContentChange = (editorState, data, type) => {\n      const {\n        currentBrush,\n        editorState: preState,\n        findPanelVisible,\n        inputEnable\n      } = this.state;\n      if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW || (currentBrush || findPanelVisible || !inputEnable) && type === undefined || this.props.read_only) {\n        return preState;\n      }\n      const {\n        slice,\n        prevSlice,\n        tags,\n        prevTags\n      } = data;\n      let {\n        prevStart,\n        prevEnd\n      } = data;\n      if (prevSlice.length === 1 && slice.length === 0) this.addHistory(ACTION.EDIT_SINGLE_DEL, data);else if (prevSlice.length === 0 && slice.length === 1) this.addHistory(ACTION.EDIT_SINGLE_ADD, data);else if (type === ACTION.EDIT_REPLACE) this.addHistory(ACTION.EDIT_REPLACE, data);else this.addHistory(ACTION.EDIT_DEFAULT, data);\n      prevStart = strlen(store.ontology.text.slice(0, data.prevStart));\n      prevEnd = strlen(store.ontology.text.slice(0, data.prevEnd));\n      store.ontology.text = store.ontology.text.slice(0, data.prevStart) + data.slice + store.ontology.text.slice(data.prevEnd);\n      // update labels and insertions\n      const offset = slice.length - prevSlice.length;\n      if (type === ACTION.EDIT_REPLACE && prevTags) {\n        const {\n          insertions = [],\n          labels = [],\n          connections = []\n        } = prevTags;\n        [...insertions, ...labels, ...connections].forEach(t => {\n          store.ontology.deleteTag(t.type, t.id);\n        });\n      }\n      store.ontology.tagMove(prevStart, prevEnd, offset);\n      if (type === ACTION.EDIT_REPLACE && tags) {\n        const {\n          insertions = [],\n          labels = [],\n          connections = []\n        } = tags;\n        [...insertions, ...labels, ...connections].forEach(t => {\n          store.ontology.addResultItem(t);\n        });\n      }\n\n      // update rawDraftContentState, using new text and results\n      // this.updateFindTags();\n      this.raw = this.renderTextArea();\n\n      // update editorState, using new rawDraftContentState\n      editorState = EditorState.set(editorState, {\n        currentContent: convertFromRaw(this.raw)\n      });\n      return editorState;\n    };\n    this.resetCurrentFocus = (attribute = 'currentClick', shouldUpdate) => new Promise(resolve => {\n      this.setState({\n        [`${attribute}`]: {\n          id: null,\n          from: null,\n          to: null\n        }\n      }, () => resolve('state updated'));\n    }).then(() => {\n      if (shouldUpdate) {\n        return this.updateEditorAndRender();\n      }\n    });\n    this.resetCurrentFrom = () => {\n      this.setState({\n        currentFrom: {\n          type: null,\n          id: null,\n          offset: null\n        }\n      });\n    };\n    // to status for tag: connection mode and other mode\n    this.onTagClick = (e, type, id) => {\n      const {\n        currentFrom,\n        currentBrush,\n        editorState,\n        tagMap\n      } = this.state;\n      const offset = tagMap.getItem(id, type);\n      this.editor.blur();\n      if (!isConnection(currentBrush === null || currentBrush === void 0 ? void 0 : currentBrush.type)) return;\n\n      // connecting mode only applys to label and insertion\n      if (isLabel(type) || isInsertion(type)) {\n        // if there is no starting point, setup the starting point\n        if (!currentFrom.type) {\n          this.setState({\n            currentFrom: {\n              type,\n              id,\n              offset\n            }\n          });\n        } else {\n          const nextEditorState = this.addConnection(editorState, {\n            fromId: currentFrom.id,\n            fromType: currentFrom.type,\n            toId: id,\n            toType: type,\n            type: TAG.CONNECTION,\n            value: currentBrush.text,\n            keys: currentBrush.keys\n          });\n          this.renderAndSave(nextEditorState, true, true);\n        }\n      }\n    };\n    this.onTagDoubleClick = e => {\n      // only work in qa mode\n      if (!store.reviewable && !store.isRework) {\n        return;\n      }\n      const {\n        id,\n        type\n      } = getTargetWrapperDataSet(e);\n      const item = store.ontology.getItem(type, id);\n      const tagReviewInfo = store.review.getReview(id);\n      this.setState({\n        tagOpenReview: item,\n        tagReviewInfo\n      });\n      this.editor.blur();\n    };\n    // mouseEvent includes: mouse enter, mouse leave, mouse click, mouse context menu\n    this.TagMouseEvent = (e, type, id, focusType, active) => {\n      if (this.isEditorEditMode()) {\n        return;\n      }\n      const {\n        currentClick: {\n          id: currId\n        }\n      } = this.state;\n      const tag = store.ontology.getItem(type, id);\n      if (!tag) {\n        return;\n      }\n      let attribute = '';\n      if (focusType === FOCUS_TYPE.HOVER) {\n        if (currId === tag.id && active) return;\n        attribute = 'currentHover';\n      } else if (focusType === FOCUS_TYPE.CLICK) {\n        attribute = 'currentClick';\n        this.editor.blur();\n      }\n\n      // active status: mouse enter | mouse click\n      if (active) {\n        if (focusType === FOCUS_TYPE.CLICK) {\n          this.onTagClick(e, type, id);\n        }\n        // ranges.push({ offset: label.start, length: label.end - label.start, style: `${focusType}_STYLE_${color}` });\n        this.setState({\n          [`${attribute}`]: {\n            id: tag.id,\n            fromId: tag === null || tag === void 0 ? void 0 : tag.fromId,\n            toId: tag === null || tag === void 0 ? void 0 : tag.toId,\n            fromType: tag === null || tag === void 0 ? void 0 : tag.fromType,\n            toType: tag === null || tag === void 0 ? void 0 : tag.toType,\n            type: tag === null || tag === void 0 ? void 0 : tag.type\n          }\n        }, () => {\n          this.updateEditorAndRender();\n        });\n      } else {\n        // unactive status: mouse leave | mouse context menu\n        const tagType = type;\n        this.resetCurrentFocus(attribute, true).then(() => {\n          if (focusType === FOCUS_TYPE.CLICK) {\n            this.onDeleteTag(tag.id, tagType);\n          }\n        });\n      }\n    };\n    this.onDeleteTag = (id, type) => {\n      let nextEditorState;\n      switch (type) {\n        case TAG.LABEL:\n        case TAG.CONNECTION:\n        case TAG.INSERTION:\n          nextEditorState = this.deleteTag(type, id);\n          break;\n        default:\n          return;\n      }\n      this.renderAndSave(nextEditorState);\n    };\n    this.toggleLabelsDrawer = () => {\n      if (!this.state.labelsDrawerOpen) {\n        const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n        this.setState({\n          displayLabels\n        });\n      }\n      this.setState({\n        labelsDrawerOpen: !this.state.labelsDrawerOpen\n      }, () => {\n        this.updateEditorAndRender();\n        localStorage.setItem(storageKey, this.state.labelsDrawerOpen);\n      });\n    };\n    this.toggleFindPanelVisible = visible => {\n      this.setState({\n        findPanelVisible: visible,\n        inputEnable: false,\n        currentBrush: null\n      });\n      if (visible) {\n        this.onFind(this.state.findStr);\n      } else {\n        this.setState({\n          foundTags: [],\n          needJumpFound: false,\n          foundTagSelectedIndex: 0\n        }, () => {\n          this.updateEditorAndRender();\n        });\n      }\n    };\n    this.jumpToFindTag = async (offset, findString) => {\n      const {\n        findStr\n      } = this.state;\n      if (!findStr) {\n        this.onFind(findString);\n        return;\n      }\n      const {\n        foundTagSelectedIndex,\n        foundTags\n      } = this.state;\n      if (foundTags.length === 0) {\n        this.updateEditorAndRender();\n        return;\n      }\n      let newFindTagSelectedIndex = foundTagSelectedIndex + offset;\n      if (newFindTagSelectedIndex < 0) {\n        newFindTagSelectedIndex = foundTags.length - 1;\n      }\n      if (newFindTagSelectedIndex > foundTags.length - 1) {\n        newFindTagSelectedIndex = 0;\n      }\n      this.setState({\n        needJumpFound: false,\n        foundTagSelectedIndex: newFindTagSelectedIndex\n      }, () => {\n        this.focusSelectedFoundTag();\n      });\n    };\n    this.focusSelectedFoundTag = () => {\n      this.updateEditorAndRender();\n      const {\n        foundTags,\n        foundTagSelectedIndex\n      } = this.state;\n      const selectedTag = foundTags[foundTagSelectedIndex];\n      if (selectedTag) {\n        const span = this.getAnchorElementByHead(selectedTag.start);\n        if (span && this.editorWrapper && !isElementInViewport(span, this.editorWrapper)) {\n          const {\n            top\n          } = span.getBoundingClientRect();\n          const offsetHeight = this.editorWrapper.clientHeight / 2;\n          const scrollTop = this.editorWrapper.scrollTop + top - offsetHeight;\n          this.editorWrapper.scroll(0, scrollTop);\n        }\n      }\n    };\n    this.updateFindTags = () => new Promise(resolve => {\n      const {\n        findStr\n      } = this.state;\n      const str = store.ontology.text;\n      const reg = new RegExp(escapeCharacter(findStr), 'g');\n      const ans = [];\n      if (findStr) {\n        let matched = null;\n        let i = 0;\n        // eslint-disable-next-line no-cond-assign\n        while ((matched = reg.exec(str)) !== null) {\n          const start = getPositionWithUnicode(store.ontology.surrogatePairsPosition, matched.index);\n          const temp = {\n            start,\n            end: start + strlen(findStr),\n            id: i\n          };\n          ans.push(temp);\n          i += 1;\n        }\n      }\n      this.setState({\n        foundTags: ans,\n        foundTagSelectedIndex: -1\n      }, () => {\n        resolve();\n      });\n    });\n    this.onFind = (_findStr, selectedIndex) => {\n      const {\n        findStr,\n        foundTags\n      } = this.state;\n      if (findStr && _findStr === findStr && foundTags.length > 0 && selectedIndex === undefined) {\n        this.jumpToFindTag(1, findStr);\n      } else if (_findStr) {\n        this.setState({\n          findStr: _findStr\n        }, async () => {\n          await this.updateFindTags();\n          this.jumpToFindTag(selectedIndex || 1, findStr);\n        });\n      } else {\n        this.setState({\n          findStr: '',\n          foundTags: [],\n          foundTagSelectedIndex: -1\n        }, () => {\n          this.updateEditorAndRender();\n        });\n      }\n    };\n    this.onReplace = (all = false, findStr, replaceStr = '') => {\n      if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return;\n      const {\n        foundTagSelectedIndex,\n        foundTags,\n        editorState,\n        needJumpFound\n      } = this.state;\n      const tag = foundTags[foundTagSelectedIndex];\n      if (needJumpFound) {\n        this.jumpToFindTag(1, findStr);\n        return;\n      }\n      if (!tag || findStr === replaceStr) return;\n      let newFoundTags = [...foundTags];\n      let newSelectedIndex = foundTagSelectedIndex;\n      let newText = store.ontology.text;\n      let replaceData;\n      if (all) {\n        newText = newText.replaceAll(findStr, replaceStr);\n        newFoundTags = [];\n        newSelectedIndex = -1;\n        replaceData = {\n          text: newText,\n          prevText: store.ontology.text,\n          prevResults: store.ontology.results,\n          results: JSON.parse(JSON.stringify(store.ontology.results))\n        };\n        const offset = strlen(replaceStr) - strlen(findStr);\n        foundTags.forEach((t, i) => {\n          t.start += offset * i;\n          t.end += offset * i;\n          replaceData.results.insertions = replaceData.results.insertions.filter(insert => insert.at <= t.start || insert.at >= t.end).map(insert => insert.at > t.start ? {\n            ...insert,\n            at: insert.at + offset\n          } : insert);\n          replaceData.results.labels = replaceData.results.labels.filter(l => !(l.start > t.start && l.start < t.end) && !(l.end > t.start && l.end < t.end)).map(l => l.start > t.start ? {\n            ...l,\n            start: l.start + offset,\n            end: l.end + offset\n          } : l);\n          replaceData.results.connections = replaceData.results.connections.filter(c => !!replaceData.results.labels.find(l => [c.fromId, c.toId].includes(l.id)));\n        });\n      } else {\n        newText = newText.slice(0, tag.start) + replaceStr + newText.slice(tag.end);\n        newFoundTags.splice(foundTagSelectedIndex, 1);\n        const insertions = store.ontology.results.insertions.filter(i => i.at > tag.start && i.at < tag.end);\n        const labels = store.ontology.results.labels.filter(i => i.start > tag.start && i.start < tag.end || i.end > tag.start && i.end < tag.end);\n        const connections = store.ontology.results.connections.filter(c => !!labels.find(l => [c.fromId, c.toId].includes(l.id)));\n        replaceData = {\n          start: tag.start,\n          end: tag.start + strlen(replaceStr),\n          slice: replaceStr,\n          prevSlice: findStr,\n          prevStart: tag.start,\n          prevEnd: tag.end,\n          prevTags: {\n            insertions,\n            labels,\n            connections\n          },\n          tags: {}\n        };\n      }\n      let nextEditorState;\n      if (all) {\n        store.ontology.updateText(newText);\n        store.ontology.setResults(replaceData.results);\n        this.raw = this.renderTextArea(newText);\n        nextEditorState = EditorState.set(editorState, {\n          currentContent: convertFromRaw(this.raw)\n        });\n        this.addHistory(ACTION.EDIT_REPLACE_ALL, replaceData);\n      } else {\n        nextEditorState = this.onContentChange(editorState, replaceData, ACTION.EDIT_REPLACE);\n      }\n      this.setState({\n        editorState: nextEditorState,\n        foundTags: newFoundTags,\n        foundTagSelectedIndex: newSelectedIndex,\n        needJumpFound: newFoundTags.length > 0\n      }, () => {\n        if (newFoundTags.length > 1) {\n          this.onFind(findStr, newSelectedIndex + 1);\n        } else {\n          this.updateEditorAndRender();\n        }\n        message.success(localMessage('REPLACE_SUCCESS'));\n      });\n    };\n    this.setCurrentBrush = (item, input = false) => {\n      this.setState({\n        currentBrush: item,\n        inputEnable: input\n      });\n    };\n    this.setFormVisible = () => {\n      this.setState({\n        tagOpenReview: null,\n        tagReviewInfo: null\n      });\n    };\n    this.genKeyCommand = e => {\n      if (e.metaKey || e.altKey) return KEY_COMMAND.INVALID_KEY;\n      switch (e.keyCode) {\n        case 90:\n          // prevent default undo Z\n          e.preventDefault();\n          if (e.ctrlKey) return KEY_COMMAND.HANDLE_UNDO;\n          return getDefaultKeyBinding(e);\n        case 89:\n          // prevent default redo Y\n          e.preventDefault();\n          if (e.ctrlKey) return KEY_COMMAND.HANDLE_REDO;\n          return getDefaultKeyBinding(e);\n        case 13:\n          e.preventDefault();\n          return KEY_COMMAND.HANDLE_RETURN;\n        default:\n          return getDefaultKeyBinding(e);\n      }\n    };\n    this.handleKeyCommand = command => {\n      const {\n        editorState\n      } = this.state;\n      switch (command) {\n        case KEY_COMMAND.INVALID_KEY:\n          return 'handled';\n        case KEY_COMMAND.HANDLE_RETURN:\n          {\n            const start = editorState.getSelection().getStartOffset();\n            const end = editorState.getSelection().getEndOffset();\n            const nextEditorState = setSelection(this.onContentChange(editorState, {\n              slice: '\\n',\n              prevSlice: store.ontology.text.slice(start, end),\n              prevStart: start,\n              prevEnd: end,\n              start: start + 1,\n              end: start + 1\n            }), start + 1, start + 1);\n            this.renderAndSave(nextEditorState);\n            return 'handled';\n          }\n        case KEY_COMMAND.HANDLE_UNDO:\n          return 'handled';\n        case KEY_COMMAND.HANDLE_REDO:\n          return 'handled';\n        default:\n          return 'not-handled';\n      }\n    };\n    // Get one anchor by slice head\n    this.getAnchorElementByHead = at => {\n      const {\n        sliceMap\n      } = this;\n      const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n      const id = `span-wrapper-0-${sliceMap.get(at)}`;\n      const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n      return span;\n    };\n    // Get all anchors at one time\n    this.getAnchorElementsByHeads = () => {\n      const {\n        sliceMap\n      } = this;\n      const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n      const spanMap = new Map();\n      sliceMap.forEach((value, key) => {\n        const id = `span-wrapper-0-${sliceMap.get(key)}`;\n        const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n        spanMap.set(key, span);\n      });\n      return spanMap;\n    };\n    this.onMouseDown = e => {\n      if (e.which === 1) {\n        this.mouseFlag = true;\n      }\n      const onMouseUp = () => {\n        this.mouseFlag = false;\n        window.removeEventListener('mouseup', onMouseUp);\n      };\n      window.addEventListener('mouseup', onMouseUp);\n    };\n    this.onCompositionEnd = () => {\n      this.compositionFlag = COMPOSITION.PENDING;\n    };\n    this.onCompositionStart = () => {\n      this.compositionFlag = COMPOSITION.ENABLED;\n      this.compositionTop = this.editorWrapper.scrollTop;\n    };\n    this.handleBeforeInput = () => {\n      this.inputFlag = true;\n      return 'not-handled';\n    };\n    this.handlePastedText = () => {\n      this.pasteFlag = true;\n      return 'not-handled';\n    };\n    setLocale(props.locale);\n    this.raw = {\n      blocks: [],\n      entityMap: {}\n    };\n    this.sliceMap = new Map();\n    this.state = {\n      findStr: '',\n      foundTags: [],\n      needJumpFound: false,\n      foundTagSelectedIndex: 0,\n      findPanelVisible: false,\n      displayLabels: [],\n      labelsDrawerOpen: defaultLabelsDrawerFlag,\n      style: {\n        FIND_BLOCK,\n        FIND_BLOCK_SELECTED,\n        DEFAULT_STYLE: {\n          color: this.fontColor,\n          fontSize: `${FONT_SIZE}px`,\n          lineHeight: `${LINE_HEIGHT}px`,\n          letterSpacing: `${FONT_SPACE}px`\n        },\n        MISSING_STYLE: {\n          color: '#000000'\n        }\n      },\n      tagOpenReview: null,\n      tagReviewInfo: null,\n      editorState: EditorState.createEmpty(),\n      currentBrush: null,\n      editorHeight: null,\n      editorWidth: null,\n      tagMap: new TagInfoMap(),\n      currentClick: {\n        id: null,\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null\n      },\n      currentHover: {\n        id: '',\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null\n      },\n      currentFrom: {\n        type: null,\n        id: null,\n        offset: null\n      },\n      currentMouse: {\n        left: 0,\n        top: 0\n      },\n      inputEnable: false\n    };\n    this.compositionTop = -1;\n    this.compositionFlag = COMPOSITION.DISABLED;\n    this.inputFlag = false;\n    this.mouseFlag = false;\n    this.pasteFlag = false;\n    this.undoLock = false;\n    this.redoLock = false;\n    this.redoList = [];\n    this.undoList = [];\n\n    // user setting\n    this.fontColor = FONT_COLOR;\n    this.toolMode = this.props.jobProxy.toolMode || this.props.mode;\n    store.jobProxy = this.props.jobProxy;\n  }\n  submitReviews(isSubmit = true) {\n    return store.saveReviews(isSubmit);\n  }\n  getReviews() {\n    return this.submitReviews();\n  }\n  getStatistics() {\n    return store.getAuditStatistics();\n  }\n  async componentDidMount() {\n    this.toolMode = this.props.jobProxy.toolMode;\n    let {\n      content\n    } = this.props;\n    let results;\n\n    // insert qa tool's label\n    try {\n      const resultRes = await this.props.jobProxy.loadResult();\n      if ((resultRes === null || resultRes === void 0 ? void 0 : resultRes.results) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.content)) {\n        content = resultRes.content;\n        results = resultRes.results;\n      } else if ((resultRes === null || resultRes === void 0 ? void 0 : resultRes.labels) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.connections) && (resultRes === null || resultRes === void 0 ? void 0 : resultRes.insertions)) {\n        results = resultRes;\n      }\n    } catch (e) {\n      notification.error({\n        message: localMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // init store\n    try {\n      await store.init({\n        ...this.props,\n        content: content || ''\n      });\n    } catch (e) {\n      notification.error({\n        message: e.message,\n        duration: null\n      });\n      return;\n    }\n\n    // initialize results\n    store.ontology.parseResults(results);\n    const reviewRes = await this.props.jobProxy.loadReviews();\n    if (reviewRes) {\n      store.review.parseReview(reviewRes.reviews || {});\n    }\n\n    // initialize raw\n    this.raw = this.renderTextArea();\n    // apply composition lock\n    if (this.state.labelsDrawerOpen) {\n      const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n      this.setState({\n        displayLabels\n      });\n    }\n    this.editorWrapper.addEventListener('compositionstart', this.onCompositionStart);\n    this.editorWrapper.addEventListener('compositionend', this.onCompositionEnd);\n    this.editorWrapper.addEventListener('mousedown', this.onMouseDown);\n    this.editorWrapper.addEventListener('dragstart', e => e.preventDefault());\n    this.editorWrapper.addEventListener('contextmenu', e => {\n      e.preventDefault();\n      this.resetCurrentFrom();\n      this.resetCurrentFocus('currentClick', true);\n    });\n    this.editorWrapper.addEventListener('mousemove', this.onMouseMove);\n    window.addEventListener('keydown', this.onKeyDown);\n    window.addEventListener('resize', () => this.renderAndSave(null, true, false, false));\n\n    // use url file backup to replace content, results, and reviews information\n    // use local storage backup to replace text, results, and reviews information\n    // save every 5 minutes\n    setInterval(() => {\n      this.onSave();\n    }, 1000 * 60 * 5);\n    if (this.props.renderComplete) {\n      this.props.renderComplete();\n    }\n    const editorState = EditorState.createWithContent(convertFromRaw(this.raw));\n    this.renderAndSave(editorState, true, true, false);\n    const {\n      nextEditorState,\n      tagMap\n    } = this.measureTags(editorState);\n    this.renderTags(tagMap);\n    this.setState({\n      editorState: nextEditorState,\n      tagMap\n    });\n  }\n  /**\n   * select ontology by hotkey\n   * @param event\n   */\n  selectOntologyByHotkey(event) {\n    const config = store.ontology.getOntologyByHotkey(event);\n    if (config) {\n      this.setCurrentBrush(config);\n      store.ontology.updateOntologiesCollapseStatus(config.keys, false);\n      return true;\n    }\n    return false;\n  }\n  render() {\n    var _currentFrom$offset, _currentFrom$offset2;\n    const {\n      editorState,\n      style,\n      currentBrush,\n      editorWidth,\n      editorHeight,\n      currentClick,\n      currentHover,\n      currentMouse,\n      currentFrom,\n      tagMap,\n      tagOpenReview,\n      tagReviewInfo,\n      labelsDrawerOpen,\n      displayLabels,\n      foundTags,\n      inputEnable\n    } = this.state;\n    const {\n      config\n    } = store;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"app-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1676,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-wrapper\",\n      onClick: () => {\n        this.editorOnFocus = false;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1677,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-left-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1678,\n        columnNumber: 11\n      }\n    }, isAppenCloud() && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"logo\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1680,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(AppenLogo, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1681,\n        columnNumber: 15\n      }\n    })), /*#__PURE__*/React.createElement(ReviewMode, {\n      onToggleReviewMode: () => {\n        this.setCurrentBrush(null, false);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1684,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"divider\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1688,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(UndoRedo, {\n      undoHandle: () => this.executeHistory(RECALL_TYPE.UNDO),\n      redoHandle: () => this.executeHistory(RECALL_TYPE.REDO),\n      undoList: this.undoList,\n      redoList: this.redoList,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1689,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Guide, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1695,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"divider\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1696,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(FindAndReplace, {\n      onVisibleChange: this.toggleFindPanelVisible,\n      onFind: this.onFind,\n      onReplace: this.onReplace,\n      resultNumber: foundTags ? foundTags.length : 0,\n      jumpTo: this.jumpToFindTag,\n      readonly: isAnnotationReadonly(this.toolMode) || this.props.read_only || config.reviewMode === ReviewModeType.REVIEW,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1697,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Automation, {\n      applyAutomationLabels: results => {\n        this.onApplyAutomationLabels(editorState, results);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1705,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Save, {\n      onSave: this.onSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1709,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"topbar-right-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1711,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(LabelScan, {\n      onToggle: this.toggleLabelsDrawer,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1712,\n        columnNumber: 13\n      }\n    }))), /*#__PURE__*/React.createElement(TextToolContext.Provider, {\n      value: {\n        moveFocusToTag: this.moveFocusToTag,\n        deleteReviewItemById: this.deleteReviewItemById,\n        deleteReviewItemsById: this.deleteReviewItemsById\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1715,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Sidebar, {\n      showReview: isRework(this.toolMode) || isReviewEditable(this.toolMode),\n      onClick: () => {\n        this.editorOnFocus = false;\n      },\n      currentBrush: currentBrush,\n      inputEnable: inputEnable,\n      setCurrentBrush: this.setCurrentBrush,\n      items: tagMap,\n      contentReadyOnly: this.props.read_only,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1716,\n        columnNumber: 11\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"right-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1726,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"editor-wrapper\",\n      ref: r => {\n        this.editorWrapper = r;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1727,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"svg-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1731,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"svg\", {\n      ref: r => {\n        this.svg = r;\n      },\n      style: {\n        height: `${editorHeight}px`,\n        width: `${editorWidth}px`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1732,\n        columnNumber: 15\n      }\n    }, Object.entries(tagMap.connections).map(([id, connect]) => /*#__PURE__*/React.createElement(\"g\", {\n      key: id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1734,\n        columnNumber: 19\n      }\n    }, /*#__PURE__*/React.createElement(\"path\", {\n      d: connect.path,\n      stroke: currentHover.id === id ? HOVER_COLOR : currentClick.id === id ? FOCUS_COLOR : DEFAULT_COLOR,\n      fill: \"#00000000\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1735,\n        columnNumber: 21\n      }\n    }))), currentFrom.type ? /*#__PURE__*/React.createElement(\"path\", {\n      d: `M ${(_currentFrom$offset = currentFrom.offset) === null || _currentFrom$offset === void 0 ? void 0 : _currentFrom$offset.left} ${(_currentFrom$offset2 = currentFrom.offset) === null || _currentFrom$offset2 === void 0 ? void 0 : _currentFrom$offset2.top} L ${currentMouse.left} ${currentMouse.top}`,\n      stroke: FOCUS_COLOR,\n      fill: \"#00000000\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1743,\n        columnNumber: 19\n      }\n    }) : null)), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tags-wrapper\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1747,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tags-panel\",\n      style: {\n        height: `${editorHeight}px`,\n        width: `${editorWidth}px`\n      },\n      onDoubleClick: this.onTagDoubleClick,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1748,\n        columnNumber: 15\n      }\n    }, Object.entries(tagMap.labels).map(([id, label]) => {\n      var _store$review$getRevi;\n      return /*#__PURE__*/React.createElement(LabelTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi = store.review.getReview(id)) === null || _store$review$getRevi === void 0 ? void 0 : _store$review$getRevi.result,\n        label: label,\n        isHover: currentHover.id === id || currentHover.fromId === id || currentHover.toId === id,\n        isClick: currentClick.id === id || currentClick.fromId === id || currentClick.toId === id,\n        labelMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1754,\n          columnNumber: 19\n        }\n      });\n    }), Object.entries(tagMap.insertions).map(([id, insertion]) => {\n      var _store$review$getRevi2;\n      return /*#__PURE__*/React.createElement(InsertionTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi2 = store.review.getReview(id)) === null || _store$review$getRevi2 === void 0 ? void 0 : _store$review$getRevi2.result,\n        insertion: insertion,\n        isHover: currentHover.id === id || currentHover.fromId === id || currentHover.toId === id,\n        isClick: currentClick.id === id || currentClick.fromId === id || currentClick.toId === id,\n        insertionMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1772,\n          columnNumber: 19\n        }\n      });\n    }), Object.entries(tagMap.connections).map(([id, connection]) => {\n      var _store$review$getRevi3;\n      return /*#__PURE__*/React.createElement(ConnectionTag, {\n        key: id,\n        reviewResult: (_store$review$getRevi3 = store.review.getReview(id)) === null || _store$review$getRevi3 === void 0 ? void 0 : _store$review$getRevi3.result,\n        connection: connection,\n        isHover: currentHover.id === id,\n        isClick: currentClick.id === id,\n        connectionMouseEvent: this.TagMouseEvent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1790,\n          columnNumber: 19\n        }\n      });\n    }))), /*#__PURE__*/React.createElement(\"div\", {\n      onClick: () => {\n        this.editor.focus();\n        this.resetCurrentFocus('currentClick', true);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1801,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(Editor, {\n      ref: r => {\n        this.editor = r;\n      },\n      editorState: editorState,\n      customStyleMap: style,\n      onChange: this.onChange,\n      handlePastedText: this.handlePastedText,\n      handleBeforeInput: this.handleBeforeInput,\n      handleKeyCommand: this.handleKeyCommand,\n      keyBindingFn: this.genKeyCommand,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1807,\n        columnNumber: 15\n      }\n    }))), labelsDrawerOpen && /*#__PURE__*/React.createElement(LabelsDisplay, {\n      title: localMessage('LABEL_CONTENT'),\n      labelsDrawerOpen: labelsDrawerOpen,\n      displayLabels: displayLabels,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1820,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(ReviewForm, {\n      toolMode: this.toolMode,\n      tagReviewInfo: tagReviewInfo,\n      tagOpenReview: tagOpenReview,\n      issueTypes: this.props.issue_types,\n      setFormVisible: this.setFormVisible,\n      onConfirm: review => {\n        this.addReview(editorState, tagOpenReview === null || tagOpenReview === void 0 ? void 0 : tagOpenReview.id, review);\n        store.ontology.updateOntologiesStatusMap();\n      },\n      onDelete: this.onDeleteReview,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1827,\n        columnNumber: 9\n      }\n    }));\n  }\n}","map":{"version":3,"names":["React","createContext","Editor","EditorState","convertFromRaw","getDefaultKeyBinding","notification","message","uniq","substr","strlen","v4","uuidv4","localMessage","setLocale","LabelTag","InsertionTag","ConnectionTag","isAnnotationReadonly","isRework","isReviewEditable","isPreview","Sidebar","genTagMap","renderTagMap","genDisplayLabels","LabelsDisplay","FindAndReplace","ReviewForm","UndoRedo","ReviewMode","Save","LabelScan","isAppenCloud","AppenLogo","store","FIND_BLOCK","FIND_BLOCK_SELECTED","FOCUS_COLOR","DEFAULT_COLOR","FONT_COLOR","BASE_COLOR","HISTORY_SIZE","FONT_SIZE","TAG_HEIGHT","LINE_HEIGHT","EDITOR_PADDING","COMPOSITION","SELECTION","ACTION","KEY_COMMAND","RECALL_TYPE","HOVER_COLOR","FONT_SPACE","FOCUS_TYPE","HOVER_ALPHA","ACTIVE_ALPHA","DEFAULT_ALPHA","isArabic","convertArrayToColor","convertColorToArray","getSliceHead","setSelection","closeSelection","getTextByInsertion","getTargetWrapperDataSet","isElementInViewport","escapeCharacter","getConfigByKeys","getPositionWithUnicode","isLabel","isInsertion","isConnection","isQATag","ReviewItemResult","TAG","ReviewModeType","TagInfoMap","Automation","Guide","storageKey","defaultLabelsDrawerFlag","s","localStorage","getItem","e","TextToolContext","TextAnnotationApp","Component","constructor","props","addHistory","type","data","targetList","undoLock","redoList","redoLock","undoList","length","shift","EDIT_SINGLE_ADD","prev","EDIT_DEFAULT","prevSlice","end","prevStart","pop","push","slice","prevEnd","start","EDIT_SINGLE_DEL","executeHistory","recallType","UNDO","REDO","item","nextEditorState","state","editorState","EDIT_REPLACE","newData","tags","prevTags","onContentChange","ADD_INSERTION","id","insertion","deleteTag","ADD_LABEL","label","ADD_LABELS","deleteLabels","ADD_MISSING_REVIEW","preReview","addReview","deleteQATag","ADD_CONNECTION","DEL_LABELS","addLabels","labels","DEL_LABEL","relatedConnections","addLabel","DEL_MISSING_REVIEW","review","addQALabel","DEL_INSERTION","addInsertion","DEL_CONNECTION","connection","addConnection","EDIT_REPLACE_ALL","text","currentText","prevText","prevResults","results","ontology","updateText","setResults","raw","renderTextArea","set","currentContent","ADD_REVIEW","deleteReview","DELETE_REVIEW","ADD_REVIEWS","deleteReviewItems","DELETE_REVIEWS","addReviewItems","renderAndSave","findStr","findPanelVisible","selectedIndex","includes","onFind","_editorState","shouldRenderTags","shouldResetCurrentState","shouldSaveURL","hasFocus","getSelection","top","editorWrapper","scrollTop","Promise","resolve","resetCurrentFrom","setState","exportResult","then","tagMap","measureTags","editorWidth","offsetWidth","editorHeight","scrollHeight","updateOntologiesStatusMap","renderTags","compositionTop","editor","focus","y","displayLabels","ontologyConfigMap","updateEditorAndRender","options","Symbol","iterator","isEditorEditMode","currentBrush","inputEnable","onChange","compositionFlag","ENABLED","prevEditorState","getCurrentContent","getPlainText","getStartOffset","getEndOffset","prevFocus","inputFlag","pasteFlag","PENDING","DISABLED","onSelectionChange","shouldRender","MOVE","spanMap","getAnchorElementsByHeads","onSave","toolMode","submitReviews","success","warning","onSubmit","params","invalid","validityFlag","config","submitCheck","skipCheckForInvalidData","validation","defaultSync","blocked","Error","isSubmit","saveResult","insertions","getResults","offsetTops","map","_spanMap$get","get","offsetTop","concat","_spanMap$get2","at","occupyMap","Map","forEach","ranges","blocks","inlineStyleRanges","style","filter","span","getAnchorElementByHead","offset","occupyList","lineHeight","it","sort","a","b","mouseFlag","fbAt","value","keys","INSERTION","CLICK","fbStart","fbEnd","result","MISSING","DRAG","onApplyAutomationLabels","formattedLabels","applyAutomationLabels","newEditorState","operation","reviewMode","REVIEW","arabic","newItem","isReview","addResultItem","fromId","fromType","toId","toType","connections","some","LABELING","reviewInfo","needUnRedo","needOpenReview","reviews","missing","tagOpenReview","addMissingReview","deleteMissingReview","reviewId","currEditorState","setReview","deleteReviewItemById","reviewItem","getItemById","deleteReviewItemsById","reviewIds","operations","reviewItems","deleteReviewHandle","onDeleteReview","_text","currentClick","currentHover","foundTags","foundTagSelectedIndex","needJumpFound","slices","t","labelHeads","insertionHeads","foundTagHeads","tag","key","depth","children","entityRanges","entityMap","sliceCount","sliceMap","anchor","index","array","next","match","currentRGB","currentAlpha","nextAlpha","isCoverbyQa","keepRGB","labelItem","tempRGB","color","i","v","tagIndex","findIndex","f","undefined","baseRGB","Math","min","currentColor","backgroundColor","indexOf","head","onMouseMove","box","svg","getBoundingClientRect","currentMouse","left","clientX","x","clientY","moveFocusToTag","clientHeight","onKeyDown","window","disableTextHotKeys","keyCode","ctrlKey","altKey","selectOntologyByHotkey","stopImmediatePropagation","preventDefault","nTag","moveToTagByStep","nxtTag","stepToTag","nextTag","stopPropagation","onDeleteTag","tagReviewInfo","getReview","REJECT","blur","preState","read_only","tagMove","resetCurrentFocus","attribute","shouldUpdate","from","to","currentFrom","onTagClick","CONNECTION","onTagDoubleClick","reviewable","TagMouseEvent","focusType","active","currId","HOVER","tagType","LABEL","toggleLabelsDrawer","labelsDrawerOpen","setItem","toggleFindPanelVisible","visible","jumpToFindTag","findString","newFindTagSelectedIndex","focusSelectedFoundTag","selectedTag","offsetHeight","scroll","updateFindTags","str","reg","RegExp","ans","matched","exec","surrogatePairsPosition","temp","_findStr","onReplace","all","replaceStr","newFoundTags","newSelectedIndex","newText","replaceData","replaceAll","JSON","parse","stringify","insert","l","c","find","splice","setCurrentBrush","input","setFormVisible","genKeyCommand","metaKey","INVALID_KEY","HANDLE_UNDO","HANDLE_REDO","HANDLE_RETURN","handleKeyCommand","command","wrapper","querySelector","onMouseDown","which","onMouseUp","removeEventListener","addEventListener","onCompositionEnd","onCompositionStart","handleBeforeInput","handlePastedText","locale","DEFAULT_STYLE","fontColor","fontSize","letterSpacing","MISSING_STYLE","createEmpty","jobProxy","mode","saveReviews","getReviews","getStatistics","getAuditStatistics","componentDidMount","content","resultRes","loadResult","error","duration","init","parseResults","reviewRes","loadReviews","parseReview","setInterval","renderComplete","createWithContent","event","getOntologyByHotkey","updateOntologiesCollapseStatus","render","_currentFrom$offset","_currentFrom$offset2","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","onClick","editorOnFocus","onToggleReviewMode","undoHandle","redoHandle","onVisibleChange","resultNumber","jumpTo","readonly","onToggle","Provider","showReview","items","contentReadyOnly","ref","r","height","width","Object","entries","connect","d","path","stroke","fill","onDoubleClick","_store$review$getRevi","reviewResult","isHover","isClick","labelMouseEvent","_store$review$getRevi2","insertionMouseEvent","_store$review$getRevi3","connectionMouseEvent","customStyleMap","keyBindingFn","title","issueTypes","issue_types","onConfirm","onDelete"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/TextAnnotationApp.jsx"],"sourcesContent":["/* eslint-disable no-nested-ternary */\n/* eslint-disable react/no-access-state-in-setstate */\n/* eslint-disable no-undef */\n/* eslint-disable no-underscore-dangle */\nimport React, { createContext } from 'react';\nimport { Editor, EditorState, convertFromRaw, getDefaultKeyBinding } from 'draft-js';\nimport { notification, message } from 'antd';\nimport { uniq } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport localMessage, { setLocale } from './locale';\nimport { LabelTag, InsertionTag, ConnectionTag } from './components/tag';\nimport { isAnnotationReadonly, isRework, isReviewEditable, isPreview } from '../../utils/tool-mode';\nimport Sidebar from './components/sidebar';\nimport { genTagMap, renderTagMap, genDisplayLabels } from './utils/tagMapUtil';\nimport LabelsDisplay from './components/labelsDisplay';\nimport FindAndReplace from './components/findAndReplace';\nimport ReviewForm from './components/reviewForm';\nimport UndoRedo from './components/UndoRedo';\nimport ReviewMode from './components/ReviewMode';\nimport Save from './components/Save';\nimport LabelScan from './components/LabelScan';\nimport { isAppenCloud } from '../../utils';\nimport AppenLogo from '../common/AppenLogo';\nimport store from './store/RootStore';\nimport './TextAnnotationApp.scss';\nimport 'draft-js/dist/Draft.css';\nimport {\n  FIND_BLOCK,\n  FIND_BLOCK_SELECTED,\n  FOCUS_COLOR, DEFAULT_COLOR,\n  FONT_COLOR, BASE_COLOR, HISTORY_SIZE,\n  FONT_SIZE, TAG_HEIGHT,\n  LINE_HEIGHT, EDITOR_PADDING,\n  COMPOSITION, SELECTION, ACTION, KEY_COMMAND,\n  RECALL_TYPE,\n  HOVER_COLOR,\n  FONT_SPACE, FOCUS_TYPE,\n  HOVER_ALPHA,\n  ACTIVE_ALPHA,\n  DEFAULT_ALPHA,\n} from './store/constant';\nimport {\n  isArabic,\n  convertArrayToColor,\n  convertColorToArray,\n  getSliceHead,\n  setSelection,\n  closeSelection,\n  getTextByInsertion,\n  getTargetWrapperDataSet,\n  isElementInViewport,\n  escapeCharacter,\n  getConfigByKeys,\n  getPositionWithUnicode,\n} from './utils/helper';\nimport {\n  isLabel,\n  isInsertion,\n  isConnection,\n  isQATag,\n} from './store/tag_mode';\nimport { ReviewItemResult, TAG, ReviewMode as ReviewModeType } from './types';\nimport TagInfoMap from './utils/TagInfoMap';\nimport Automation from './components/automation/Automation';\nimport { Guide } from './components/guide';\n\nconst storageKey = 'text-annotation-label-content';\nlet defaultLabelsDrawerFlag = false;\ntry {\n  const s = localStorage.getItem(storageKey);\n  defaultLabelsDrawerFlag = s === 'true';\n} catch (e) {\n  // get error\n}\n\nexport const TextToolContext = createContext();\nexport default class TextAnnotationApp extends React.Component {\n  constructor(props) {\n    super(props);\n    setLocale(props.locale);\n    this.raw = { blocks: [], entityMap: {} };\n    this.sliceMap = new Map();\n    this.state = {\n      findStr: '',\n      foundTags: [],\n      needJumpFound: false,\n      foundTagSelectedIndex: 0,\n      findPanelVisible: false,\n      displayLabels: [],\n      labelsDrawerOpen: defaultLabelsDrawerFlag,\n      style: {\n        FIND_BLOCK,\n        FIND_BLOCK_SELECTED,\n        DEFAULT_STYLE: {\n          color: this.fontColor,\n          fontSize: `${FONT_SIZE}px`,\n          lineHeight: `${LINE_HEIGHT}px`,\n          letterSpacing: `${FONT_SPACE}px`,\n        },\n        MISSING_STYLE: {\n          color: '#000000',\n        }\n      },\n      tagOpenReview: null,\n      tagReviewInfo: null,\n      editorState: EditorState.createEmpty(),\n      currentBrush: null,\n      editorHeight: null,\n      editorWidth: null,\n      tagMap: new TagInfoMap(),\n      currentClick: {\n        id: null,\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null,\n      },\n      currentHover: {\n        id: '',\n        fromId: null,\n        toId: null,\n        fromType: null,\n        toType: null,\n      },\n      currentFrom: {\n        type: null,\n        id: null,\n        offset: null,\n      },\n      currentMouse: {\n        left: 0,\n        top: 0,\n      },\n      inputEnable: false,\n    };\n\n    this.compositionTop = -1;\n    this.compositionFlag = COMPOSITION.DISABLED;\n    this.inputFlag = false;\n    this.mouseFlag = false;\n    this.pasteFlag = false;\n    this.undoLock = false;\n    this.redoLock = false;\n    this.redoList = [];\n    this.undoList = [];\n\n    // user setting\n    this.fontColor = FONT_COLOR;\n    this.toolMode = this.props.jobProxy.toolMode || this.props.mode;\n    store.jobProxy = this.props.jobProxy;\n  };\n\n  addHistory = (type, data) => {\n    let targetList;\n    if (this.undoLock) {\n      // Add history to redo list\n      targetList = this.redoList;\n    } else if (this.redoLock) {\n      // Add history back to undo list\n      targetList = this.undoList;\n      // Clear redo list\n    } else {\n      // Add history to redo list\n      targetList = this.undoList;\n      this.redoList = [];\n    }\n    let { length } = targetList;\n    if (length > HISTORY_SIZE) {\n      targetList.shift();\n      length -= 1;\n    }\n    if (type === ACTION.EDIT_SINGLE_ADD && length >= 1) {\n      const prev = targetList[length - 1];\n      if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_ADD) && (prev.data.prevSlice === '' && prev.data.end === data.prevStart)) {\n        targetList.pop();\n        targetList.push({\n          type: ACTION.EDIT_DEFAULT,\n          data: {\n            prevSlice: '',\n            slice: prev.data.slice + data.slice,\n            prevStart: prev.data.prevStart,\n            prevEnd: prev.data.prevEnd,\n            start: data.start,\n            end: data.end,\n          }\n        });\n      } else targetList.push({ type, data });\n    } else if (type === ACTION.EDIT_SINGLE_DEL && length >= 1) {\n      const prev = targetList[length - 1];\n      if ((prev.type === ACTION.EDIT_DEFAULT || prev.type === ACTION.EDIT_SINGLE_DEL) && (prev.data.slice === '' && data.prevEnd === prev.data.start)) {\n        targetList.pop();\n        targetList.push({\n          type: ACTION.EDIT_DEFAULT,\n          data: {\n            slice: '',\n            prevSlice: data.prevSlice + prev.data.prevSlice,\n            prevStart: data.end,\n            prevEnd: prev.data.prevEnd,\n            start: data.start,\n            end: data.end,\n          }\n        });\n      } else targetList.push({ type, data });\n    } else targetList.push({ type, data });\n  };\n\n  executeHistory = (recallType) => {\n    // Execute history\n    let targetList;\n    if (recallType === RECALL_TYPE.UNDO) {\n      // Get from undo list\n      this.undoLock = true;\n      targetList = this.undoList;\n    } else if (recallType === RECALL_TYPE.REDO) {\n      // Get from redo list\n      this.redoLock = true;\n      targetList = this.redoList;\n    }\n    if (targetList.length === 0) {\n      this.undoLock = false;\n      this.redoLock = false;\n      return;\n    }\n    const item = targetList.pop();\n    const { data } = item;\n    let nextEditorState = this.state.editorState;\n    switch (item.type) {\n      case ACTION.EDIT_SINGLE_ADD:\n      case ACTION.EDIT_SINGLE_DEL:\n      case ACTION.EDIT_DEFAULT:\n      case ACTION.EDIT_REPLACE:\n      {\n        const newData = {\n          prevSlice: data.slice,\n          slice: data.prevSlice,\n          start: data.prevEnd,\n          end: data.prevEnd,\n          prevStart: data.prevStart,\n          prevEnd: data.end,\n          ...item.type === ACTION.EDIT_REPLACE && {\n            tags: data.prevTags,\n            prevTags: data.tags,\n          }\n        };\n        // nextEditorState = this.onContentChange(nextEditorState, newData);\n        nextEditorState = setSelection(this.onContentChange(nextEditorState, newData, item.type), newData.start, newData.end);\n        break;\n      }\n      case ACTION.ADD_INSERTION:\n      {\n        const { type, id } = data.insertion;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.ADD_LABEL:\n      {\n        const { type, id } = data.label;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.ADD_LABELS:\n      {\n        nextEditorState = this.deleteLabels(data);\n        break;\n      }\n      case ACTION.ADD_MISSING_REVIEW:\n      {\n        const { preReview, id } = data;\n        if (preReview) {\n          const { editorState } = this.addReview(nextEditorState, id, { ...preReview });\n          nextEditorState = editorState;\n        } else {\n          const { editorState } = this.deleteQATag(id);\n          nextEditorState = editorState;\n        }\n        break;\n      }\n      case ACTION.ADD_CONNECTION:\n      {\n        const { type, id } = data;\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      }\n      case ACTION.DEL_LABELS: {\n        nextEditorState = this.addLabels(nextEditorState, data.labels);\n        break;\n      }\n      case ACTION.DEL_LABEL:\n      {\n        const { relatedConnections, label } = data;\n        nextEditorState = this.addLabel(nextEditorState, label, relatedConnections);\n        break;\n      }\n      case ACTION.DEL_MISSING_REVIEW:\n      {\n        const { label, review } = data;\n        const { editorState } = this.addQALabel(nextEditorState, label, { ...review });\n        nextEditorState = editorState;\n\n        break;\n      }\n      case ACTION.DEL_INSERTION:\n      {\n        const { relatedConnections, insertion } = data;\n\n        nextEditorState = this.addInsertion(nextEditorState, insertion, relatedConnections);\n        break;\n      }\n      case ACTION.DEL_CONNECTION:\n      {\n        const { connection } = data;\n        nextEditorState = this.addConnection(nextEditorState, connection);\n        break;\n      }\n      case ACTION.EDIT_REPLACE_ALL:\n      {\n        const { text: currentText, prevText, prevResults, results } = data;\n        store.ontology.updateText(prevText);\n        store.ontology.setResults(prevResults);\n        this.raw = this.renderTextArea(prevText);\n        nextEditorState = EditorState.set(nextEditorState, { currentContent: convertFromRaw(this.raw) });\n        this.addHistory(ACTION.EDIT_REPLACE_ALL, {\n          text: prevText,\n          prevText: currentText,\n          prevResults: results,\n          results: prevResults,\n        });\n        break;\n      }\n      case ACTION.ADD_REVIEW: {\n        const { preReview, id } = data;\n        if (preReview) {\n          const { editorState } = this.addReview(nextEditorState, id, { ...preReview });\n          nextEditorState = editorState;\n        } else {\n          const { editorState } = this.deleteReview(id);\n          nextEditorState = editorState;\n        }\n        break;\n      }\n      case ACTION.DELETE_REVIEW: {\n        const { review, id } = data;\n        const { editorState } = this.addReview(nextEditorState, id, { ...review });\n        nextEditorState = editorState;\n        break;\n      }\n      case ACTION.ADD_REVIEWS: {\n        nextEditorState = this.deleteReviewItems(data);\n        break;\n      }\n      case ACTION.DELETE_REVIEWS: {\n        nextEditorState = this.addReviewItems(nextEditorState, data);\n        break;\n      }\n      default:\n        break;\n    }\n\n    this.renderAndSave(nextEditorState);\n    this.undoLock = false;\n    this.redoLock = false;\n    const { findStr, findPanelVisible, selectedIndex } = this.state;\n    if (findStr && findPanelVisible && [ACTION.EDIT_REPLACE, ACTION.EDIT_REPLACE_ALL].includes(item.type)) {\n      this.onFind(findStr, selectedIndex || 1);\n    }\n  };\n\n  renderAndSave = (\n    _editorState,\n    shouldRenderTags = true,\n    shouldResetCurrentState = false,\n    shouldSaveURL = false,\n  ) => {\n    const editorState = _editorState || this.state.editorState;\n    const { hasFocus } = editorState.getSelection();\n    const top = this.editorWrapper.scrollTop;\n    // window.ew = this.editorWrapper;\n    return new Promise((resolve) => {\n      if (shouldResetCurrentState) {\n        this.resetCurrentFrom();\n      }\n      this.setState({ editorState });\n      if (shouldSaveURL) {\n        this.exportResult();\n      }\n      resolve();\n    }).then(() => {\n      if (shouldRenderTags) {\n        const { nextEditorState, tagMap } = this.measureTags(editorState);\n        return new Promise((resolve) => {\n          this.setState({\n            editorState: nextEditorState,\n            tagMap,\n            editorWidth: this.editorWrapper.offsetWidth - EDITOR_PADDING * 2,\n            editorHeight: this.editorWrapper.scrollHeight - EDITOR_PADDING * 2,\n          }, () => {\n            store.ontology.updateOntologiesStatusMap();\n          });\n          this.renderTags(tagMap);\n          resolve();\n        });\n      }\n    }).then(() => {\n      if (hasFocus) {\n        // move back to current selection after composition end\n        if (this.compositionTop >= 0) {\n          this.editor.focus({ y: this.compositionTop });\n          this.compositionTop = -1;\n        } else this.editor.focus({ y: top });\n      }\n      return new Promise((resolve) => resolve());\n    })\n      .then(() => {\n        const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n        this.setState({ displayLabels });\n      });\n  };\n\n  updateEditorAndRender = (options) => {\n    let { editorState } = this.state;\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    if (options && typeof options[Symbol.iterator] === 'function') {\n      return this.renderAndSave(editorState, ...options);\n    }\n\n    return this.renderAndSave(editorState);\n  };\n\n  isEditorEditMode = () => {\n    const { currentBrush, inputEnable } = this.state;\n    return currentBrush === null && inputEnable;\n  };\n\n  onChange = (editorState) => {\n    // ignore composition operation\n    if (this.compositionFlag === COMPOSITION.ENABLED) return;\n    // get operation type ( handled operation not included )\n    const prevEditorState = this.state.editorState;\n    const prevText = store.ontology.text;\n    const text = editorState.getCurrentContent().getPlainText();\n    let prevStart = prevEditorState.getSelection().getStartOffset();\n    const prevEnd = prevEditorState.getSelection().getEndOffset();\n    const start = editorState.getSelection().getStartOffset();\n    const end = editorState.getSelection().getEndOffset();\n    const { hasFocus } = editorState.getSelection();\n    const { hasFocus: prevFocus } = prevEditorState.getSelection();\n\n    if (hasFocus !== prevFocus) { // when focus change update new editor state and return without doing anything\n      const nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n      this.renderAndSave(nextEditorState, null, false);\n      return;\n    }\n\n    if (this.inputFlag || this.pasteFlag || this.compositionFlag === COMPOSITION.PENDING || prevText !== text) {\n      /* text changed:\n       * 1. deleted by delete key\n       * 2. deleted by drag + delete key\n       * 3. deleted by drag + cut operation\n       * 4. insert/replace by (drag) + simply typing\n       * 5. insert/replace by (drag) + composition typing\n       * 6. insert/replace by (drag) + paste operation\n       * 7. redo && undo\n       */\n      if (prevStart === prevEnd && start === prevStart - 1) prevStart -= 1;\n      const prevSlice = prevText.slice(prevStart, prevEnd);\n      const slice = text.slice(prevStart, end);\n      const data = { prevSlice, slice, prevStart, prevEnd, start, end };\n      const nextEditorState = this.onContentChange(editorState, data);\n      // reset flag\n      this.inputFlag = false;\n      this.pasteFlag = false;\n      this.compositionFlag = COMPOSITION.DISABLED;\n      this.renderAndSave(nextEditorState);\n    } else {\n      /* selection changed\n       * 1. simply select\n       * 2. click select: add insertion\n       * 3. drag select: add label\n       */\n      const data = { start, end };\n      const { nextEditorState, type } = this.onSelectionChange(editorState, data);\n      const shouldRender = type !== SELECTION.MOVE;\n      this.renderAndSave(nextEditorState, shouldRender, shouldRender);\n    }\n  };\n\n  renderTags = (tagMap) => {\n    const spanMap = this.getAnchorElementsByHeads();\n    renderTagMap(tagMap, spanMap);\n  };\n\n  onSave = async () => {\n    if (isPreview(this.toolMode)) return;\n    try {\n      if (!isAnnotationReadonly(this.toolMode)) {\n        await this.exportResult();\n      }\n      if (isReviewEditable(this.toolMode)) {\n        await this.submitReviews(false);\n      }\n      message.success(localMessage('saveSuccess'));\n    } catch (e) {\n      message.warning(localMessage('saveFail'));\n    }\n  };\n\n  onSubmit = async (params) => {\n    const invalid = params && params.validityFlag === 'false';\n    if (store.config.submitCheck && (\n      !invalid || !store.config.skipCheckForInvalidData\n    )) {\n      // validate before submit\n      await store.validation.defaultSync();\n      if (store.validation.blocked) {\n        throw new Error(localMessage('SUBMIT_CHECK_FAIL'));\n      }\n    }\n    return this.exportResult(true);\n  };\n\n  exportResult = (isSubmit = false) => {\n    if (isAnnotationReadonly(this.toolMode)) return;\n    return store.saveResult(isSubmit);\n  };\n\n  submitReviews(isSubmit = true) {\n    return store.saveReviews(isSubmit);\n  }\n\n  getReviews() {\n    return this.submitReviews();\n  }\n\n  getStatistics() {\n    return store.getAuditStatistics();\n  }\n\n  measureTags = (editorState) => {\n    const { raw } = this;\n    const { text } = store.ontology;\n    const { labels, insertions } = store.ontology.getResults();\n\n    const spanMap = this.getAnchorElementsByHeads();\n    const offsetTops = uniq((labels.map((label) => spanMap.get(label.start)?.offsetTop))\n      .concat(insertions.map((insertion) => spanMap.get(insertion.at)?.offsetTop)));\n    const occupyMap = new Map();\n    offsetTops.forEach((offsetTop) => { occupyMap.set(offsetTop, []); });\n\n    // get label offsets\n    const tagMap = genTagMap(store.ontology.getResults(), store.ontology.ontologyConfigMap, spanMap, occupyMap, text);\n\n    const ranges = raw.blocks[0].inlineStyleRanges;\n    const style = { ...this.state.style };\n    ranges.filter((item) => item.style.slice(0, 6) === 'ANCHOR').forEach((item) => {\n      const span = this.getAnchorElementByHead(item.offset);\n      if (span) {\n        const occupyList = occupyMap.get(span.offsetTop);\n        const lineHeight = occupyList.map((it) => (it.top > 0 ? it.top - FONT_SIZE + TAG_HEIGHT : -it.top))\n          .sort((a, b) => (a - b)).pop() * 2 + LINE_HEIGHT;\n        style[`LINEHEIGHT_${lineHeight}`] = { lineHeight: `${lineHeight}px` };\n        ranges.push({ offset: item.offset, length: item.length, style: `LINEHEIGHT_${lineHeight}` });\n      }\n    });\n    this.setState({ style });\n    const nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    return { nextEditorState, tagMap };\n  };\n\n  onSelectionChange = (editorState, data) => {\n    const { start, end } = data;\n    const { currentBrush } = this.state;\n    if (!this.mouseFlag) {\n      return { nextEditorState: editorState, type: SELECTION.MOVE };\n    } if (start === end && isInsertion(currentBrush?.type)) {\n      const fbAt = strlen(store.ontology.text.slice(0, start));\n      const nextEditorState = this.addInsertion(editorState, { at: fbAt, value: currentBrush.text, keys: currentBrush.keys, type: TAG.INSERTION });\n      return { nextEditorState, type: SELECTION.CLICK };\n    } if (start !== end && isLabel(currentBrush?.type)) {\n      const fbStart = strlen(store.ontology.text.slice(0, start));\n      const fbEnd = strlen(store.ontology.text.slice(0, end));\n      if (isQATag(currentBrush?.type)) {\n        const { editorState: nextEditorState } = this.addQALabel(editorState, { start: fbStart, end: fbEnd, value: currentBrush.text, keys: currentBrush.keys, type: currentBrush.type }, { result: ReviewItemResult.MISSING }, true, true);\n        return { nextEditorState, type: SELECTION.DRAG };\n      }\n      const nextEditorState = this.addLabel(editorState, { start: fbStart, end: fbEnd, value: currentBrush.text, keys: currentBrush.keys, type: currentBrush.type });\n      return { nextEditorState, type: SELECTION.DRAG };\n    }\n    return { nextEditorState: editorState, type: SELECTION.MOVE };\n  };\n\n  onApplyAutomationLabels = (editorState, labels) => {\n    const formattedLabels = store.ontology.applyAutomationLabels(labels);\n    const newEditorState = this.addLabels(editorState, formattedLabels);\n    this.renderAndSave(newEditorState);\n  };\n\n  addLabels = (editorState, labels) => {\n    store.ontology.addLabels(labels);\n    this.addHistory(ACTION.ADD_LABELS, labels);\n    this.raw = this.renderTextArea();\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return editorState;\n  };\n\n  deleteLabels = (data) => {\n    const { state: { editorState } } = this;\n    const operation = store.ontology.deleteLabels(data);\n    this.addHistory(ACTION.DEL_LABELS, operation);\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  deleteTag = (type, id) => {\n    const { state: { editorState } } = this;\n    if (isQATag(type) && store.config.reviewMode !== ReviewModeType.REVIEW) {\n      return editorState;\n    }\n    if (!isQATag(type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n      return;\n    }\n    if (isAnnotationReadonly(this.toolMode)) {\n      return editorState;\n    }\n\n    const operation = store.ontology.deleteTag(type, id);\n    switch (true) {\n      case (isLabel(type)): this.addHistory(ACTION.DEL_LABEL, operation); break;\n      case (isConnection(type)): this.addHistory(ACTION.DEL_CONNECTION, operation); break;\n      case (isInsertion(type)): this.addHistory(ACTION.DEL_INSERTION, operation); break;\n      default: break;\n    }\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  addInsertion = (editorState, { at, value, id, keys, type }, relatedConnections = []) => {\n    const { state: { currentBrush }, toolMode } = this;\n    const { text } = store.ontology;\n    if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n    if (at === strlen(text)) return editorState; // prevent insert to the end of content\n    // eslint-disable-next-line no-restricted-syntax\n    for (const item of store.ontology.results.insertions) {\n      if (item.at === at && item.value === currentBrush.text) return editorState;\n    }\n    if (!id) id = uuidv4();\n    const arabic = isArabic(substr(text, at));\n    if (arabic && at) at -= 1;\n    const newItem = {\n      type,\n      at,\n      value,\n      id,\n      text: getTextByInsertion(store.ontology.text, { at, value }),\n      isReview: isReviewEditable(toolMode),\n      keys,\n    };\n\n    this.addHistory(ACTION.ADD_INSERTION, {\n      insertion: newItem,\n      relatedConnections,\n    });\n\n    store.ontology.addResultItem(newItem, relatedConnections);\n\n    this.raw = this.renderTextArea();\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return editorState;\n  };\n\n  addConnection = (editorState, { fromId, fromType, toId, toType, value, id, keys, type }) => {\n    const { state: { currentBrush }, toolMode } = this;\n    if (isAnnotationReadonly(toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return editorState;\n    if (fromId === toId) return editorState;\n    if (isQATag(fromType) || isQATag(toType)) return editorState; // can't add connection for qa tool\n\n    if (store.ontology.results.connections.some((item) => item.fromId === fromId && item.toId === toId && item.value === currentBrush.text)) return editorState;\n\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      fromId,\n      fromType,\n      toId,\n      toType,\n      value,\n      id,\n      isReview: isReviewEditable(toolMode),\n      keys,\n    };\n    this.addHistory(ACTION.ADD_CONNECTION, newItem);\n    store.ontology.addResultItem(newItem);\n\n    this.raw = this.renderTextArea();\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    return editorState;\n  };\n\n  addLabel = (editorState, { start, end, value, id, keys, type }, relatedConnections = []) => {\n    const { toolMode } = this;\n    const { ontology, config } = store;\n    const { text } = store.ontology;\n\n    if (config.reviewMode === ReviewModeType.REVIEW && (!isQATag(type))) return editorState;\n    if (isAnnotationReadonly(this.toolMode) && (!isQATag(type))) return editorState;\n    if (isQATag(type) && (!isReviewEditable(this.toolMode) || config.reviewMode === ReviewModeType.LABELING)) return editorState; // qa mode can only use qa tool, work mode can only use normal tool\n\n    // slice should not begin with \\n\n    if (substr(text, start, 1) === '\\n') return editorState;\n\n    if (ontology.results.labels.some((item) => item.start === start && item.end === end && item.value === value)) return editorState;\n\n    // generate new label\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      start,\n      end,\n      value,\n      id,\n      text: substr(text, start, end - start),\n      isReview: isReviewEditable(toolMode),\n      keys\n    };\n\n    this.addHistory(ACTION.ADD_LABEL, {\n      label: newItem,\n      relatedConnections,\n    });\n\n    ontology.addResultItem(newItem, relatedConnections);\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return editorState;\n  };\n\n  addQALabel = (editorState, { start, end, value, id, keys, type }, reviewInfo, needUnRedo = true, needOpenReview = false) => {\n    const { toolMode } = this;\n    const { ontology, review } = store;\n    const { text } = ontology;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState, operation: null };\n    }\n\n    // slice should not begin with \\n\n    if (substr(text, start, 1) === '\\n') return { editorState, operation: null };\n\n    if (review.reviews.missing.some((item) => item.start === start && item.end === end && item.value === value)) return { editorState, operation: null };\n\n    // generate new label\n    if (!id) id = uuidv4();\n    const newItem = {\n      type,\n      start,\n      end,\n      value,\n      id,\n      text: substr(text, start, end - start),\n      isReview: isReviewEditable(toolMode),\n      keys\n    };\n    if (needOpenReview) {\n      this.setState({ tagOpenReview: { ...newItem } });\n    }\n\n    const operation = review.addMissingReview(newItem, id, { ...reviewInfo });\n    if (needUnRedo) {\n      this.addHistory(ACTION.ADD_MISSING_REVIEW, operation);\n    }\n\n    // update rawDraftContentState, using new results\n    this.raw = this.renderTextArea();\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    editorState = closeSelection(editorState);\n    return { editorState, operation };\n  };\n\n  deleteQATag = (id, needUnRedo = true) => {\n    const { state: { editorState } } = this;\n\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState, operation: null };\n    }\n    const operation = store.review.deleteMissingReview(id);\n    if (needUnRedo) {\n      this.addHistory(ACTION.DEL_MISSING_REVIEW, operation);\n      this.raw = this.renderTextArea();\n      return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n    }\n    return { editorState, operation };\n  };\n\n  deleteReview = (reviewId, needUnRedo = true) => {\n    const { state: { editorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState, operation: null };\n    }\n    const operation = store.review.deleteReview(reviewId);\n    if (needUnRedo) {\n      this.addHistory(ACTION.DELETE_REVIEW, operation);\n      this.raw = this.renderTextArea();\n      return { editorState: EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) }), operation };\n    }\n    return { editorState, operation };\n  };\n\n  addReview = (editorState, reviewId, review, needUnRedo = true) => {\n    const { state: { editorState: currEditorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return { editorState: currEditorState, operation: null };\n    }\n    const operation = store.review.setReview(reviewId, {\n      ...review\n    });\n    if (needUnRedo) {\n      this.addHistory(ACTION.ADD_REVIEW, operation);\n    }\n    return { editorState, operation };\n  };\n\n  deleteReviewItemById = (reviewId) => {\n    if (reviewId) {\n      let nextEditorState = this.state.editorState;\n      const reviewItem = store.ontology.getItemById(reviewId);\n      if (reviewItem && isQATag(reviewItem.type)) {\n        const { editorState } = this.deleteQATag(reviewItem.id);\n        nextEditorState = editorState;\n      } else {\n        const { editorState } = this.deleteReview(reviewId);\n        nextEditorState = editorState;\n      }\n      this.renderAndSave(nextEditorState);\n    }\n  };\n\n  deleteReviewItemsById = (reviewIds) => {\n    const operations = [];\n    reviewIds?.forEach((reviewId) => {\n      if (reviewId) {\n        const reviewItem = store.ontology.getItemById(reviewId);\n        if (reviewItem && isQATag(reviewItem.type)) {\n          const { operation } = this.deleteQATag(reviewItem.id, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        } else {\n          const { operation } = this.deleteReview(reviewId, false);\n          if (operation) {\n            operations.push(operation);\n          }\n        }\n      }\n    });\n    this.addHistory(ACTION.DELETE_REVIEWS, operations);\n    const { state: { editorState } } = this;\n\n    this.raw = this.renderTextArea();\n    const nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    this.renderAndSave(nextEditorState);\n  };\n\n  deleteReviewItems = (reviewItems) => {\n    const operations = [];\n    const { state: { editorState } } = this;\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return editorState;\n    }\n    reviewItems?.forEach((reviewItem) => {\n      const { review, id } = reviewItem;\n      if (review.result === ReviewItemResult.MISSING) {\n        const { operation } = this.deleteQATag(id, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      } else {\n        const { operation } = this.deleteReview(id, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      }\n    });\n    this.addHistory(ACTION.DELETE_REVIEWS, operations);\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  addReviewItems = (editorState, reviewItems) => {\n    const operations = [];\n    if (!(isReviewEditable(this.toolMode) && store.config.reviewMode === ReviewModeType.REVIEW)) {\n      return editorState;\n    }\n    reviewItems?.forEach((reviewItem) => {\n      const { review, id } = reviewItem;\n      if (review.result === ReviewItemResult.MISSING) {\n        const { operation } = this.addQALabel(editorState, reviewItem.label, { ...review }, false, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      } else {\n        const { operation } = this.addReview(editorState, id, { ...review }, false);\n        if (operation) {\n          operations.push(operation);\n        }\n      }\n    });\n    this.addHistory(ACTION.ADD_REVIEWS, operations);\n    this.raw = this.renderTextArea();\n    return EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n  };\n\n  deleteReviewHandle = (reviewItem) => {\n    if (reviewItem) {\n      let nextEditorState = this.state.editorState;\n      if (isQATag(reviewItem.type)) {\n        const { editorState } = this.deleteQATag(reviewItem.id);\n        nextEditorState = editorState;\n      } else {\n        const { editorState } = this.deleteReview(reviewItem.id);\n        nextEditorState = editorState;\n      }\n      this.renderAndSave(nextEditorState);\n    }\n  };\n\n  onDeleteReview = () => {\n    const { tagOpenReview } = this.state;\n    this.deleteReviewHandle(tagOpenReview);\n  };\n\n  // create new RawDraftContentState and update customeStyleMap\n  // update: raw, style, sliceMap\n  renderTextArea = (_text) => {\n    const { ontology } = store;\n    const { ontologyConfigMap } = ontology;\n    const {\n      currentClick, currentHover,\n      foundTags, foundTagSelectedIndex, needJumpFound,\n    } = this.state;\n    const style = { ...this.state.style };\n    const text = _text || store.ontology.text;\n    const { labels, insertions } = ontology.getResults();\n    // render missing labels as normal labels\n\n    // slice text to segments\n    const slices = uniq(\n      (labels.map((label) => label.start))\n        .concat(labels.map((label) => label.end))\n        .concat(insertions.map((insertion) => insertion.at))\n        .concat(foundTags.map((t) => t.start))\n        .concat(foundTags.map((t) => t.end))\n        .concat([0, text.length])\n        .sort((a, b) => a - b)\n    );\n    const labelHeads = uniq((labels.map((label) => label.start)));\n    const insertionHeads = uniq((insertions.map((insertion) => insertion.at)));\n    const foundTagHeads = uniq((foundTags.map((tag) => tag.start)));\n\n    // .concat(insertions.map((insertion) => insertion.at)));\n    const raw = {\n      blocks: [{\n        text,\n        key: 'span-wrapper',\n        type: 'unstyled',\n        depth: 0,\n        inlineStyleRanges: [\n          { offset: 0, length: text.length, style: 'DEFAULT_STYLE' }],\n        children: [],\n        entityRanges: [],\n        data: {},\n      }],\n      entityMap: {}\n    };\n    let sliceCount = 0;\n    // 对重叠的tag进行背景色叠加\n    const ranges = raw.blocks[0].inlineStyleRanges;\n    this.sliceMap = new Map();\n    slices.forEach((anchor, index, array) => {\n      // set slice\n      if (!index) return;\n      const { prev, next } = { prev: array[index - 1], next: anchor };\n      const match = labels.filter((label) => (label.start <= prev && label.end > prev));\n      let currentRGB = [0, 0, 0];\n      let currentAlpha = 0;\n      let nextAlpha = DEFAULT_ALPHA;\n      let isCoverbyQa = false;\n      let keepRGB = null;\n      match.some((label) => {\n        const labelItem = getConfigByKeys(ontologyConfigMap, label.keys);\n        const tempRGB = convertColorToArray(labelItem.color);\n        if (!keepRGB) isCoverbyQa = isQATag(label.type);\n        // render clicked tag in priority\n        if (currentClick.id === label.id || currentClick.fromId === label.id || currentClick.toId === label.id) {\n          keepRGB = tempRGB.map((value, i) => value * ACTIVE_ALPHA);\n          isCoverbyQa = isQATag(label.type);\n          return true;\n        }\n\n        if ((!keepRGB && currentHover.id === label.id) || currentHover.fromId === label.id || currentHover.toId === label.id) {\n          keepRGB = tempRGB.map((v) => v * HOVER_ALPHA);\n        }\n\n        if (!keepRGB) {\n          currentRGB = currentRGB.map((value, i) => value + tempRGB[i] * nextAlpha);\n          currentAlpha += nextAlpha;\n          nextAlpha = DEFAULT_ALPHA * (1 - currentAlpha) * (1 - currentAlpha);\n        }\n        return false;\n      });\n      // background of found tag\n      foundTags\n        .filter((tag) => (tag.start <= prev && tag.end > prev))\n        .some((tag) => {\n          const tagIndex = foundTags.findIndex((f) => f.start === tag.start);\n          if (tagIndex !== undefined) {\n            keepRGB = foundTagSelectedIndex === tagIndex && !needJumpFound ? [255, 230, 0] : [255, 169, 64, 0.20];\n            return true;\n          }\n          return false;\n        });\n      const baseRGB = convertColorToArray(BASE_COLOR);\n      currentRGB = keepRGB || currentRGB.map((value, i) => Math.min(255, value + baseRGB[i] * (1 - currentAlpha)));\n      const currentColor = convertArrayToColor(currentRGB);\n\n      if (!style[`BACKGROUND_${currentColor}`]) style[`BACKGROUND_${currentColor}`] = { backgroundColor: currentColor };\n\n      if (isCoverbyQa) ranges.push({ offset: prev, length: next - prev, style: 'MISSING_STYLE' });\n      ranges.push({ offset: prev, length: next - prev, style: `BACKGROUND_${currentColor}` });\n      ranges.push({ offset: prev, length: next - prev, style: `SLICE_${prev}_${next}` });\n      // set slice head if for label/insertion slice\n      if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0) {\n        const slice = substr(text, prev, next - prev);\n        const head = getSliceHead(slice);\n        ranges.push({ offset: prev, length: strlen(head), style: `ANCHOR_${prev}` });\n      }\n      if (foundTagHeads.indexOf(prev) >= 0) {\n        const tagIndex = foundTags.findIndex((f) => f.start === prev);\n        if (tagIndex !== undefined) {\n          const tag = foundTags[tagIndex];\n          ranges.push({\n            offset: prev,\n            length: tag.end - tag.start,\n            style: foundTagSelectedIndex === tagIndex && !needJumpFound ? 'FIND_BLOCK_SELECTED' : 'FIND_BLOCK',\n          });\n        }\n      }\n\n      if (labelHeads.indexOf(prev) >= 0 || insertionHeads.indexOf(prev) >= 0 || foundTagHeads.indexOf(prev) >= 0) {\n        const slice = substr(text, prev, next - prev);\n        const head = getSliceHead(slice);\n        // set sliceMap\n        this.sliceMap.set(prev, sliceCount);\n        if (head !== slice) sliceCount += 1;\n      }\n      sliceCount += 1;\n    });\n    // update new style\n    this.setState({ style });\n    return raw;\n  };\n\n  async componentDidMount() {\n    this.toolMode = this.props.jobProxy.toolMode;\n    let { content } = this.props;\n    let results;\n\n    // insert qa tool's label\n    try {\n      const resultRes = await this.props.jobProxy.loadResult();\n      if (resultRes?.results && resultRes?.content) {\n        content = resultRes.content;\n        results = resultRes.results;\n      } else if (resultRes?.labels && resultRes?.connections && resultRes?.insertions) {\n        results = resultRes;\n      }\n    } catch (e) {\n      notification.error({ message: localMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // init store\n    try {\n      await store.init({ ...this.props, content: content || '' });\n    } catch (e) {\n      notification.error({ message: e.message, duration: null });\n      return;\n    }\n\n    // initialize results\n    store.ontology.parseResults(results);\n\n    const reviewRes = await this.props.jobProxy.loadReviews();\n    if (reviewRes) {\n      store.review.parseReview(reviewRes.reviews || {});\n    }\n\n    // initialize raw\n    this.raw = this.renderTextArea();\n    // apply composition lock\n    if (this.state.labelsDrawerOpen) {\n      const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n      this.setState({ displayLabels });\n    }\n    this.editorWrapper.addEventListener('compositionstart', this.onCompositionStart);\n    this.editorWrapper.addEventListener('compositionend', this.onCompositionEnd);\n\n    this.editorWrapper.addEventListener('mousedown', this.onMouseDown);\n    this.editorWrapper.addEventListener('dragstart', (e) => e.preventDefault());\n    this.editorWrapper.addEventListener('contextmenu', (e) => {\n      e.preventDefault();\n      this.resetCurrentFrom();\n      this.resetCurrentFocus('currentClick', true);\n    });\n    this.editorWrapper.addEventListener('mousemove', this.onMouseMove);\n\n    window.addEventListener('keydown', this.onKeyDown);\n    window.addEventListener('resize', () => this.renderAndSave(null, true, false, false));\n\n    // use url file backup to replace content, results, and reviews information\n    // use local storage backup to replace text, results, and reviews information\n    // save every 5 minutes\n    setInterval(() => {\n      this.onSave();\n    }, 1000 * 60 * 5);\n    if (this.props.renderComplete) {\n      this.props.renderComplete();\n    }\n    const editorState = EditorState.createWithContent(convertFromRaw(this.raw));\n    this.renderAndSave(editorState, true, true, false);\n\n    const { nextEditorState, tagMap } = this.measureTags(editorState);\n    this.renderTags(tagMap);\n    this.setState({ editorState: nextEditorState, tagMap });\n  }\n\n  onMouseMove = (e) => {\n    const box = this.svg.getBoundingClientRect();\n    this.setState({\n      currentMouse: {\n        left: e.clientX - box.x,\n        top: e.clientY - box.y,\n      }\n    });\n  };\n\n  moveFocusToTag = (tag) => {\n    let currentClick = { ...this.state.currentClick };\n    const { tagMap } = this.state;\n    if (tag == null) return;\n    currentClick = {\n      id: tag.id,\n      fromId: tag.fromId,\n      toId: tag.toId,\n      fromType: tag.fromType,\n      toType: tag.toType,\n    };\n    const { top } = tagMap.getItem(tag.id, tag.type);\n    const { clientHeight, scrollTop } = this.editorWrapper;\n    if (top < scrollTop || top > clientHeight + scrollTop) {\n      this.editor.focus({ y: top });\n    }\n\n    this.setState({ currentClick }, () => {\n      this.updateEditorAndRender();\n    });\n  };\n\n  /**\n   * select ontology by hotkey\n   * @param event\n   */\n  selectOntologyByHotkey(event) {\n    const config = store.ontology.getOntologyByHotkey(event);\n    if (config) {\n      this.setCurrentBrush(config);\n      store.ontology.updateOntologiesCollapseStatus(config.keys, false);\n      return true;\n    }\n    return false;\n  }\n\n  onKeyDown = (e) => {\n    if (window.disableTextHotKeys) {\n      return;\n    }\n    const { currentClick, editorState, findPanelVisible } = this.state;\n    const { keyCode, ctrlKey, altKey } = e;\n    if (!this.isEditorEditMode() && !findPanelVisible) {\n      // select ontologyItem\n      const success = this.selectOntologyByHotkey(e);\n      if (success) {\n        e.stopImmediatePropagation();\n        return;\n      }\n    }\n    if (ctrlKey) {\n      switch (true) {\n        case (keyCode === 90): e.preventDefault(); this.executeHistory(RECALL_TYPE.UNDO); break; // Z\n        case (keyCode === 89): e.preventDefault(); this.executeHistory(RECALL_TYPE.REDO); break; // Y\n        case (keyCode === 83): e.preventDefault(); this.onSave(); break; // S\n        case (keyCode === 82): { // R move in qa tag\n          e.preventDefault();\n          const nTag = store.ontology.moveToTagByStep(currentClick.id, 1, true);\n          this.moveFocusToTag(nTag);\n          break;\n        }\n        case (keyCode === 81): { // Q\n          e.preventDefault();\n          if (currentClick.id == null) break;\n          let nxtTag;\n          if (altKey) {\n            // move in current category\n            nxtTag = store.ontology.stepToTag(currentClick.id, -1);\n          } else {\n            // move in all tag\n            nxtTag = store.ontology.moveToTagByStep(currentClick.id, -1);\n          }\n          this.moveFocusToTag(nxtTag);\n          break;\n        }\n        case (keyCode === 69): { // E\n          e.preventDefault();\n          if (currentClick.id == null) break;\n          let nextTag;\n          if (altKey) {\n            nextTag = store.ontology.stepToTag(currentClick.id, 1);\n          } else {\n            nextTag = store.ontology.moveToTagByStep(currentClick.id, 1);\n          }\n          this.moveFocusToTag(nextTag);\n          break;\n        }\n        default: break;\n      }\n    } else if (!this.isEditorEditMode()) {\n      switch (keyCode) {\n        case 8: // Delete\n          if (currentClick.id && !this.state.findPanelVisible) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.onDeleteTag(currentClick.id, currentClick.type);\n          }\n          break;\n        default:\n          break;\n      }\n    } else if (currentClick?.id !== null && isReviewEditable(this.toolMode) && !isQATag(currentClick.type) && store.config.reviewMode === ReviewModeType.REVIEW) {\n      switch (keyCode) {\n        case 49: // 1\n          e.preventDefault();\n          e.stopPropagation();\n          this.addReview(editorState, currentClick.id, {\n            result: 'pass',\n          });\n          break;\n        // 2\n        case 50: {\n          e.preventDefault();\n          e.stopPropagation();\n          let tagReviewInfo = store.review.getReview(currentClick.id);\n          if (!tagReviewInfo || tagReviewInfo.result !== ReviewItemResult.REJECT) {\n            tagReviewInfo = { result: 'reject', id: currentClick.id, type: [] };\n          }\n          const item = store.ontology.getItem(currentClick.type, currentClick.id);\n\n          this.setState({ tagOpenReview: item, tagReviewInfo });\n          this.editor.blur();\n          break;\n        }\n        default: break;\n      }\n    }\n  };\n\n  // update text\n  onContentChange = (editorState, data, type) => {\n    const { currentBrush, editorState: preState, findPanelVisible, inputEnable } = this.state;\n\n    if (\n      (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW)\n      || ((currentBrush || findPanelVisible || !inputEnable) && type === undefined)\n      || this.props.read_only\n    ) {\n      return preState;\n    }\n    const { slice, prevSlice, tags, prevTags } = data;\n    let { prevStart, prevEnd } = data;\n\n    if (prevSlice.length === 1 && slice.length === 0) this.addHistory(ACTION.EDIT_SINGLE_DEL, data);\n    else if (prevSlice.length === 0 && slice.length === 1) this.addHistory(ACTION.EDIT_SINGLE_ADD, data);\n    else if (type === ACTION.EDIT_REPLACE) this.addHistory(ACTION.EDIT_REPLACE, data);\n    else this.addHistory(ACTION.EDIT_DEFAULT, data);\n\n    prevStart = strlen(store.ontology.text.slice(0, data.prevStart));\n    prevEnd = strlen(store.ontology.text.slice(0, data.prevEnd));\n    store.ontology.text = store.ontology.text.slice(0, data.prevStart) + data.slice + store.ontology.text.slice(data.prevEnd);\n    // update labels and insertions\n    const offset = slice.length - prevSlice.length;\n\n    if (type === ACTION.EDIT_REPLACE && prevTags) {\n      const { insertions = [], labels = [], connections = [] } = prevTags;\n      [...insertions, ...labels, ...connections].forEach((t) => {\n        store.ontology.deleteTag(t.type, t.id);\n      });\n    }\n    store.ontology.tagMove(prevStart, prevEnd, offset);\n    if (type === ACTION.EDIT_REPLACE && tags) {\n      const { insertions = [], labels = [], connections = [] } = tags;\n      [...insertions, ...labels, ...connections].forEach((t) => {\n        store.ontology.addResultItem(t);\n      });\n    }\n\n    // update rawDraftContentState, using new text and results\n    // this.updateFindTags();\n    this.raw = this.renderTextArea();\n\n    // update editorState, using new rawDraftContentState\n    editorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n    return editorState;\n  };\n\n  resetCurrentFocus = (attribute = 'currentClick', shouldUpdate) => new Promise((resolve) => {\n    this.setState({\n      [`${attribute}`]: { id: null, from: null, to: null },\n    }, () => resolve('state updated'));\n  }).then(() => {\n    if (shouldUpdate) {\n      return this.updateEditorAndRender();\n    }\n  });\n\n  resetCurrentFrom = () => {\n    this.setState({\n      currentFrom: { type: null, id: null, offset: null },\n    });\n  };\n\n  // to status for tag: connection mode and other mode\n  onTagClick = (e, type, id) => {\n    const { currentFrom, currentBrush, editorState, tagMap } = this.state;\n    const offset = tagMap.getItem(id, type);\n    this.editor.blur();\n    if (!isConnection(currentBrush?.type)) return;\n\n    // connecting mode only applys to label and insertion\n    if (isLabel(type) || isInsertion(type)) {\n      // if there is no starting point, setup the starting point\n      if (!currentFrom.type) {\n        this.setState({\n          currentFrom: {\n            type,\n            id,\n            offset,\n          }\n        });\n      } else {\n        const nextEditorState = this.addConnection(editorState, { fromId: currentFrom.id, fromType: currentFrom.type, toId: id, toType: type, type: TAG.CONNECTION, value: currentBrush.text, keys: currentBrush.keys });\n        this.renderAndSave(nextEditorState, true, true);\n      }\n    }\n  };\n\n  onTagDoubleClick = (e) => {\n    // only work in qa mode\n    if (!store.reviewable && !store.isRework) {\n      return;\n    }\n    const { id, type } = getTargetWrapperDataSet(e);\n    const item = store.ontology.getItem(type, id);\n    const tagReviewInfo = store.review.getReview(id);\n    this.setState({ tagOpenReview: item, tagReviewInfo });\n    this.editor.blur();\n  };\n\n  // mouseEvent includes: mouse enter, mouse leave, mouse click, mouse context menu\n  TagMouseEvent = (e, type, id, focusType, active) => {\n    if (this.isEditorEditMode()) {\n      return;\n    }\n    const { currentClick: { id: currId } } = this.state;\n    const tag = store.ontology.getItem(type, id);\n    if (!tag) {\n      return;\n    }\n\n    let attribute = '';\n    if (focusType === FOCUS_TYPE.HOVER) {\n      if (currId === tag.id && active) return;\n      attribute = 'currentHover';\n    } else if (focusType === FOCUS_TYPE.CLICK) {\n      attribute = 'currentClick';\n      this.editor.blur();\n    }\n\n    // active status: mouse enter | mouse click\n    if (active) {\n      if (focusType === FOCUS_TYPE.CLICK) {\n        this.onTagClick(e, type, id);\n      }\n      // ranges.push({ offset: label.start, length: label.end - label.start, style: `${focusType}_STYLE_${color}` });\n      this.setState({\n        [`${attribute}`]: {\n          id: tag.id,\n          fromId: tag?.fromId,\n          toId: tag?.toId,\n          fromType: tag?.fromType,\n          toType: tag?.toType,\n          type: tag?.type,\n        }\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    } else { // unactive status: mouse leave | mouse context menu\n      const tagType = type;\n      this.resetCurrentFocus(attribute, true).then(() => {\n        if (focusType === FOCUS_TYPE.CLICK) {\n          this.onDeleteTag(tag.id, tagType);\n        }\n      });\n    }\n  };\n\n  onDeleteTag = (id, type) => {\n    let nextEditorState;\n    switch (type) {\n      case TAG.LABEL:\n      case TAG.CONNECTION:\n      case TAG.INSERTION:\n        nextEditorState = this.deleteTag(type, id);\n        break;\n      default: return;\n    }\n    this.renderAndSave(nextEditorState);\n  };\n\n  toggleLabelsDrawer = () => {\n    if (!this.state.labelsDrawerOpen) {\n      const displayLabels = genDisplayLabels(store.ontology.results.labels, store.ontology.ontologyConfigMap);\n      this.setState({ displayLabels });\n    }\n    this.setState({ labelsDrawerOpen: !this.state.labelsDrawerOpen }, () => {\n      this.updateEditorAndRender();\n      localStorage.setItem(storageKey, this.state.labelsDrawerOpen);\n    });\n  };\n\n  toggleFindPanelVisible = (visible) => {\n    this.setState({\n      findPanelVisible: visible,\n      inputEnable: false,\n      currentBrush: null,\n    });\n    if (visible) {\n      this.onFind(this.state.findStr);\n    } else {\n      this.setState({\n        foundTags: [],\n        needJumpFound: false,\n        foundTagSelectedIndex: 0,\n      }, () => {\n        this.updateEditorAndRender();\n      });\n    }\n  };\n\n  jumpToFindTag = async (offset, findString) => {\n    const { findStr } = this.state;\n    if (!findStr) {\n      this.onFind(findString);\n      return;\n    }\n    const { foundTagSelectedIndex, foundTags } = this.state;\n    if (foundTags.length === 0) {\n      this.updateEditorAndRender();\n      return;\n    }\n    let newFindTagSelectedIndex = foundTagSelectedIndex + offset;\n    if (newFindTagSelectedIndex < 0) {\n      newFindTagSelectedIndex = foundTags.length - 1;\n    }\n    if (newFindTagSelectedIndex > foundTags.length - 1) {\n      newFindTagSelectedIndex = 0;\n    }\n    this.setState({\n      needJumpFound: false,\n      foundTagSelectedIndex: newFindTagSelectedIndex,\n    }, () => {\n      this.focusSelectedFoundTag();\n    });\n  };\n\n  focusSelectedFoundTag = () => {\n    this.updateEditorAndRender();\n    const { foundTags, foundTagSelectedIndex } = this.state;\n    const selectedTag = foundTags[foundTagSelectedIndex];\n    if (selectedTag) {\n      const span = this.getAnchorElementByHead(selectedTag.start);\n      if (span && this.editorWrapper && !isElementInViewport(span, this.editorWrapper)) {\n        const { top } = span.getBoundingClientRect();\n        const offsetHeight = this.editorWrapper.clientHeight / 2;\n        const scrollTop = this.editorWrapper.scrollTop + top - offsetHeight;\n        this.editorWrapper.scroll(0, scrollTop);\n      }\n    }\n  };\n\n  updateFindTags = () => new Promise((resolve) => {\n    const { findStr } = this.state;\n    const str = store.ontology.text;\n    const reg = new RegExp(escapeCharacter(findStr), 'g');\n    const ans = [];\n    if (findStr) {\n      let matched = null;\n      let i = 0;\n      // eslint-disable-next-line no-cond-assign\n      while ((matched = reg.exec(str)) !== null) {\n        const start = getPositionWithUnicode(store.ontology.surrogatePairsPosition, matched.index);\n        const temp = {\n          start,\n          end: start + strlen(findStr),\n          id: i,\n        };\n        ans.push(temp);\n        i += 1;\n      }\n    }\n    this.setState({ foundTags: ans, foundTagSelectedIndex: -1 }, () => {\n      resolve();\n    });\n  });\n\n  onFind = (_findStr, selectedIndex) => {\n    const { findStr, foundTags } = this.state;\n    if (findStr && _findStr === findStr && foundTags.length > 0 && selectedIndex === undefined) {\n      this.jumpToFindTag(1, findStr);\n    } else if (_findStr) {\n      this.setState({ findStr: _findStr }, async () => {\n        await this.updateFindTags();\n        this.jumpToFindTag(selectedIndex || 1, findStr);\n      });\n    } else {\n      this.setState({ findStr: '', foundTags: [], foundTagSelectedIndex: -1 }, () => {\n        this.updateEditorAndRender();\n      });\n    }\n  };\n\n  onReplace = (all = false, findStr, replaceStr = '') => {\n    if (isAnnotationReadonly(this.toolMode) || store.config.reviewMode === ReviewModeType.REVIEW) return;\n    const { foundTagSelectedIndex, foundTags, editorState, needJumpFound } = this.state;\n    const tag = foundTags[foundTagSelectedIndex];\n    if (needJumpFound) {\n      this.jumpToFindTag(1, findStr);\n      return;\n    }\n    if (!tag || findStr === replaceStr) return;\n    let newFoundTags = [...foundTags];\n    let newSelectedIndex = foundTagSelectedIndex;\n    let newText = store.ontology.text;\n    let replaceData;\n    if (all) {\n      newText = newText.replaceAll(findStr, replaceStr);\n      newFoundTags = [];\n      newSelectedIndex = -1;\n      replaceData = {\n        text: newText,\n        prevText: store.ontology.text,\n        prevResults: store.ontology.results,\n        results: JSON.parse(JSON.stringify(store.ontology.results)),\n      };\n      const offset = (strlen(replaceStr) - strlen(findStr));\n      foundTags.forEach((t, i) => {\n        t.start += (offset * i);\n        t.end += (offset * i);\n        replaceData.results.insertions = replaceData.results.insertions\n          .filter((insert) => insert.at <= t.start || insert.at >= t.end)\n          .map((insert) => (insert.at > t.start ? {\n            ...insert,\n            at: insert.at + offset,\n          } : insert));\n        replaceData.results.labels = replaceData.results.labels\n          .filter((l) => (\n            !(l.start > t.start && l.start < t.end)\n            && !(l.end > t.start && l.end < t.end)\n          ))\n          .map((l) => (\n            l.start > t.start ? {\n              ...l,\n              start: l.start + offset,\n              end: l.end + offset,\n            } : l\n          ));\n        replaceData.results.connections = replaceData.results.connections.filter((c) => !!replaceData.results.labels.find((l) => [c.fromId, c.toId].includes(l.id)));\n      });\n    } else {\n      newText = newText.slice(0, tag.start) + replaceStr + newText.slice(tag.end);\n      newFoundTags.splice(foundTagSelectedIndex, 1);\n      const insertions = store.ontology.results.insertions.filter((i) => i.at > tag.start && i.at < tag.end);\n      const labels = store.ontology.results.labels.filter((i) => (\n        (i.start > tag.start && i.start < tag.end)\n        || (i.end > tag.start && i.end < tag.end)\n      ));\n      const connections = store.ontology.results.connections.filter((c) => !!labels.find((l) => [c.fromId, c.toId].includes(l.id)));\n\n      replaceData = {\n        start: tag.start,\n        end: tag.start + strlen(replaceStr),\n        slice: replaceStr,\n        prevSlice: findStr,\n        prevStart: tag.start,\n        prevEnd: tag.end,\n        prevTags: {\n          insertions,\n          labels,\n          connections,\n        },\n        tags: {},\n      };\n    }\n\n    let nextEditorState;\n    if (all) {\n      store.ontology.updateText(newText);\n      store.ontology.setResults(replaceData.results);\n      this.raw = this.renderTextArea(newText);\n      nextEditorState = EditorState.set(editorState, { currentContent: convertFromRaw(this.raw) });\n      this.addHistory(ACTION.EDIT_REPLACE_ALL, replaceData);\n    } else {\n      nextEditorState = this.onContentChange(editorState, replaceData, ACTION.EDIT_REPLACE);\n    }\n    this.setState({\n      editorState: nextEditorState,\n      foundTags: newFoundTags,\n      foundTagSelectedIndex: newSelectedIndex,\n      needJumpFound: newFoundTags.length > 0,\n    }, () => {\n      if (newFoundTags.length > 1) {\n        this.onFind(findStr, newSelectedIndex + 1);\n      } else {\n        this.updateEditorAndRender();\n      }\n      message.success(localMessage('REPLACE_SUCCESS'));\n    });\n  };\n\n  render() {\n    const {\n      editorState,\n      style,\n      currentBrush,\n      editorWidth,\n      editorHeight,\n      currentClick,\n      currentHover,\n      currentMouse,\n      currentFrom,\n      tagMap,\n      tagOpenReview,\n      tagReviewInfo,\n      labelsDrawerOpen,\n      displayLabels,\n      foundTags,\n      inputEnable,\n    } = this.state;\n    const { config } = store;\n    return (\n      <div className=\"app-wrapper\">\n        <div className=\"topbar-wrapper\" onClick={() => { this.editorOnFocus = false; }}>\n          <div className=\"topbar-left-wrapper\">\n            {isAppenCloud() && (\n            <div className=\"logo\">\n              <AppenLogo />\n            </div>\n            )}\n            <ReviewMode onToggleReviewMode={() => {\n              this.setCurrentBrush(null, false);\n            }}\n            />\n            <div className=\"divider\" />\n            <UndoRedo\n              undoHandle={() => this.executeHistory(RECALL_TYPE.UNDO)}\n              redoHandle={() => this.executeHistory(RECALL_TYPE.REDO)}\n              undoList={this.undoList}\n              redoList={this.redoList}\n            />\n            <Guide />\n            <div className=\"divider\" />\n            <FindAndReplace\n              onVisibleChange={this.toggleFindPanelVisible}\n              onFind={this.onFind}\n              onReplace={this.onReplace}\n              resultNumber={foundTags ? foundTags.length : 0}\n              jumpTo={this.jumpToFindTag}\n              readonly={isAnnotationReadonly(this.toolMode) || this.props.read_only || config.reviewMode === ReviewModeType.REVIEW}\n            />\n            <Automation applyAutomationLabels={(results) => {\n              this.onApplyAutomationLabels(editorState, results);\n            }}\n            />\n            <Save onSave={this.onSave} />\n          </div>\n          <div className=\"topbar-right-wrapper\">\n            <LabelScan onToggle={this.toggleLabelsDrawer} />\n          </div>\n        </div>\n        <TextToolContext.Provider value={{ moveFocusToTag: this.moveFocusToTag, deleteReviewItemById: this.deleteReviewItemById, deleteReviewItemsById: this.deleteReviewItemsById }}>\n          <Sidebar\n            showReview={isRework(this.toolMode) || isReviewEditable(this.toolMode)}\n            onClick={() => { this.editorOnFocus = false; }}\n            currentBrush={currentBrush}\n            inputEnable={inputEnable}\n            setCurrentBrush={this.setCurrentBrush}\n            items={tagMap}\n            contentReadyOnly={this.props.read_only}\n          />\n        </TextToolContext.Provider>\n        <div className=\"right-wrapper\">\n          <div\n            className=\"editor-wrapper\"\n            ref={(r) => { this.editorWrapper = r; }}\n          >\n            <div className=\"svg-wrapper\">\n              <svg ref={(r) => { this.svg = r; }} style={{ height: `${editorHeight}px`, width: `${editorWidth}px` }}>\n                {Object.entries(tagMap.connections).map(([id, connect]) => (\n                  <g key={id}>\n                    <path\n                      d={connect.path}\n                      stroke={currentHover.id === id ? HOVER_COLOR : currentClick.id === id ? FOCUS_COLOR : DEFAULT_COLOR}\n                      fill=\"#00000000\"\n                    />\n                  </g>\n                ))}\n                {currentFrom.type ?\n                  <path d={`M ${currentFrom.offset?.left} ${currentFrom.offset?.top} L ${currentMouse.left} ${currentMouse.top}`} stroke={FOCUS_COLOR} fill=\"#00000000\" /> :\n                  null}\n              </svg>\n            </div>\n            <div className=\"tags-wrapper\">\n              <div\n                className=\"tags-panel\"\n                style={{ height: `${editorHeight}px`, width: `${editorWidth}px` }}\n                onDoubleClick={this.onTagDoubleClick}\n              >\n                {Object.entries(tagMap.labels).map(([id, label]) => (\n                  <LabelTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    label={label}\n                    isHover={\n                      (currentHover.id === id) ||\n                      currentHover.fromId === id ||\n                      currentHover.toId === id\n                    }\n                    isClick={\n                      (currentClick.id === id) ||\n                      currentClick.fromId === id ||\n                      currentClick.toId === id\n                    }\n                    labelMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n                {Object.entries(tagMap.insertions).map(([id, insertion]) => (\n                  <InsertionTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    insertion={insertion}\n                    isHover={\n                      (currentHover.id === id) ||\n                      currentHover.fromId === id ||\n                      currentHover.toId === id\n                    }\n                    isClick={\n                      (currentClick.id === id) ||\n                      currentClick.fromId === id ||\n                      currentClick.toId === id\n                    }\n                    insertionMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n                {Object.entries(tagMap.connections).map(([id, connection]) => (\n                  <ConnectionTag\n                    key={id}\n                    reviewResult={store.review.getReview(id)?.result}\n                    connection={connection}\n                    isHover={currentHover.id === id}\n                    isClick={currentClick.id === id}\n                    connectionMouseEvent={this.TagMouseEvent}\n                  />\n                ))}\n              </div>\n            </div>\n            <div\n              onClick={() => {\n                this.editor.focus();\n                this.resetCurrentFocus('currentClick', true);\n              }}\n            >\n              <Editor\n                ref={(r) => { this.editor = r; }}\n                editorState={editorState}\n                customStyleMap={style}\n                onChange={this.onChange}\n                handlePastedText={this.handlePastedText}\n                handleBeforeInput={this.handleBeforeInput}\n                handleKeyCommand={this.handleKeyCommand}\n                keyBindingFn={this.genKeyCommand}\n              />\n            </div>\n          </div>\n          {labelsDrawerOpen && (\n            <LabelsDisplay\n              title={localMessage('LABEL_CONTENT')}\n              labelsDrawerOpen={labelsDrawerOpen}\n              displayLabels={displayLabels}\n            />\n          )}\n        </div>\n        <ReviewForm\n          toolMode={this.toolMode}\n          tagReviewInfo={tagReviewInfo}\n          tagOpenReview={tagOpenReview}\n          issueTypes={this.props.issue_types}\n          setFormVisible={this.setFormVisible}\n          onConfirm={(review) => {\n            this.addReview(editorState, tagOpenReview?.id, review);\n            store.ontology.updateOntologiesStatusMap();\n          }}\n          onDelete={this.onDeleteReview}\n        />\n      </div>\n    );\n  };\n\n  setCurrentBrush = (item, input = false) => {\n    this.setState({ currentBrush: item, inputEnable: input });\n  };\n\n  setFormVisible = () => {\n    this.setState({ tagOpenReview: null, tagReviewInfo: null });\n  };\n\n  genKeyCommand = (e) => {\n    if (e.metaKey || e.altKey) return KEY_COMMAND.INVALID_KEY;\n    switch (e.keyCode) {\n      case 90:\n        // prevent default undo Z\n        e.preventDefault();\n        if (e.ctrlKey) return KEY_COMMAND.HANDLE_UNDO;\n        return getDefaultKeyBinding(e);\n      case 89:\n        // prevent default redo Y\n        e.preventDefault();\n        if (e.ctrlKey) return KEY_COMMAND.HANDLE_REDO;\n        return getDefaultKeyBinding(e);\n      case 13:\n        e.preventDefault();\n        return KEY_COMMAND.HANDLE_RETURN;\n      default:\n        return getDefaultKeyBinding(e);\n    }\n  };\n\n  handleKeyCommand = (command) => {\n    const { editorState } = this.state;\n    switch (command) {\n      case KEY_COMMAND.INVALID_KEY: return 'handled';\n      case KEY_COMMAND.HANDLE_RETURN:\n      {\n        const start = editorState.getSelection().getStartOffset();\n        const end = editorState.getSelection().getEndOffset();\n        const nextEditorState = setSelection(this.onContentChange(editorState, {\n          slice: '\\n',\n          prevSlice: store.ontology.text.slice(start, end),\n          prevStart: start,\n          prevEnd: end,\n          start: start + 1,\n          end: start + 1,\n        }), start + 1, start + 1);\n        this.renderAndSave(nextEditorState);\n        return 'handled';\n      }\n      case KEY_COMMAND.HANDLE_UNDO: return 'handled';\n      case KEY_COMMAND.HANDLE_REDO: return 'handled';\n      default: return 'not-handled';\n    }\n  };\n\n  // Get one anchor by slice head\n  getAnchorElementByHead = (at) => {\n    const { sliceMap } = this;\n    const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n    const id = `span-wrapper-0-${sliceMap.get(at)}`;\n    const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n    return span;\n  };\n\n  // Get all anchors at one time\n  getAnchorElementsByHeads = () => {\n    const { sliceMap } = this;\n    const wrapper = this.editorWrapper.querySelector('.public-DraftStyleDefault-block');\n    const spanMap = new Map();\n    sliceMap.forEach((value, key) => {\n      const id = `span-wrapper-0-${sliceMap.get(key)}`;\n      const span = wrapper.querySelector(`[data-offset-key='${id}']`);\n      spanMap.set(key, span);\n    });\n    return spanMap;\n  };\n\n  onMouseDown = (e) => {\n    if (e.which === 1) {\n      this.mouseFlag = true;\n    }\n    const onMouseUp = () => {\n      this.mouseFlag = false;\n      window.removeEventListener('mouseup', onMouseUp);\n    };\n    window.addEventListener('mouseup', onMouseUp);\n  };\n\n  onCompositionEnd = () => {\n    this.compositionFlag = COMPOSITION.PENDING;\n  };\n\n  onCompositionStart = () => {\n    this.compositionFlag = COMPOSITION.ENABLED;\n    this.compositionTop = this.editorWrapper.scrollTop;\n  };\n\n  handleBeforeInput = () => { this.inputFlag = true; return 'not-handled'; };\n\n  handlePastedText = () => { this.pasteFlag = true; return 'not-handled'; };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}