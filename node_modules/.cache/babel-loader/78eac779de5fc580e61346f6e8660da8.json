{"ast":null,"code":"import { Base64 } from 'js-base64';\nimport { cloneDeep, isEqual } from 'lodash';\nimport * as toWav from 'audiobuffer-to-wav';\nimport { notification } from 'antd';\nimport { createSegment } from './segmentController';\nimport { defaultColor, translate, tagType, SegmentMode, ValidDurationMode, StyleConfigMode } from '../../constants';\nimport { store, lawToWav, getFileExtension } from '../../../../utils';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nconst decode = str => {\n  try {\n    return JSON.parse(Base64.decode(str));\n  } catch (e) {\n    return null;\n  }\n};\nconst AUDIO_KEY_ATTRIBUTE = 'audio_key_attribute';\nconst AUDIO_ROLE_ATTRIBUTE = 'role';\nexport const handleLawToWav = (alawUrl, tail, index) => new Promise(async (resolve, reject) => {\n  try {\n    const buffer = await fetch(alawUrl).then(res => res.arrayBuffer());\n    const audioBuffer = lawToWav(buffer, tail);\n    const wav = toWav(audioBuffer);\n    const blob = new Blob([wav], {\n      type: 'audio/wav'\n    });\n    resolve(window.URL.createObjectURL(blob));\n  } catch (error) {\n    notification.error({\n      message: `${translate('AUDIO_ERROR')} ${index + 1}`\n    });\n    return false;\n  }\n});\nconst parseVideos = (audio, result) => new Promise(async (resolve, reject) => {\n  const {\n    audios = []\n  } = result || {};\n  const array = audio.split(',');\n  const videos = [];\n  const videoTypes = 'asf,avi,wmv,mkv,mp4,mov,rm,3gp,flv,mpg,rmvb,mpeg'.split(',');\n  for (let index = 0; index < array.length; index += 1) {\n    const src = array[index];\n    let video = src;\n    if (video) {\n      const tail = getFileExtension(video);\n      if ((tail === 'alaw' || tail === 'ulaw') && index === 0) {\n        video = await handleLawToWav(src, tail, index);\n      }\n      if (video) {\n        const savedAudio = audios[index];\n        videos.push({\n          url: video,\n          source: src,\n          loaded: tail !== 'alaw' && tail !== 'ulaw' ? true : index === 0,\n          ready: false,\n          zoom: 1,\n          speed: 1,\n          checked: !index,\n          type: videoTypes.indexOf(tail) < 0 ? 'none-video' : 'video',\n          ...(savedAudio && savedAudio.duration && {\n            duration: savedAudio.duration\n          }),\n          ...(savedAudio && savedAudio.attributes !== undefined && {\n            attributes: cloneDeep(savedAudio.attributes),\n            originAttributes: cloneDeep(savedAudio.attributes) // save original saved attributes\n          })\n        });\n      }\n    }\n  }\n  resolve(videos);\n});\nconst parseLableConfig = labelConfig => {\n  try {\n    const keys = [AUDIO_KEY_ATTRIBUTE, AUDIO_ROLE_ATTRIBUTE];\n    const obj = decode(labelConfig) || {\n      fields: []\n    };\n    obj.fields = obj.fields || [];\n    obj.fields.forEach(value => {\n      // if (value.type.toUpperCase() !== 'RADIO'\n      //     && value.type.toUpperCase() !== 'TEXTAREA'\n      //     && value.type.toUpperCase() !== 'TEXT') {\n      //   throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE_TYPE')}: ${value.type}`);\n      // }\n      if (value.name && keys.indexOf(value.name.toLowerCase()) >= 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ATTRIBUTE_NAME')}: ${value.name}`);\n      }\n      keys.push(value.name.toLowerCase());\n    });\n    return obj;\n  } catch (error) {\n    notification.error({\n      message: error.message\n    });\n    return {\n      fields: []\n    };\n  }\n};\nconst parseOntology = (ontology = []) => {\n  try {\n    const newOntology = new Map();\n    newOntology.set('none', defaultColor.darkGray);\n    ontology.forEach((value, index) => {\n      if (!newOntology.has(value.class_name)) newOntology.set(value.class_name, value.display_color);else throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ONTOLOGY')}: ${value.class_name}`);\n    });\n    return newOntology;\n  } catch (error) {\n    notification.error({\n      message: error.message\n    });\n    return new Map();\n  }\n};\nconst parseResults = (results, unitId, videos, ontology, lineConfig, segmentConfig, segmentMode) => {\n  // eslint-disable-next-line no-param-reassign\n  // console.log(store.getStorage('long-audio', 'review_from'));\n  const cache = store.getStorage('long-audio', unitId);\n  results = cache && cache.results ? cache.results : results;\n  if (!results || !results.length) results = [];\n  videos.forEach((video, index) => {\n    if (!results[index] || !results[index].length) {\n      if (segmentMode === SegmentMode.individual) {\n        results[index] = [];\n      } else {\n        results[index] = [createSegment(0, null, segmentConfig, lineConfig)];\n      }\n    }\n  });\n  return results;\n};\nconst parseKeyAttribute = config => {\n  const options = [];\n  if (config && typeof config === 'string') {\n    try {\n      // e.g. valid:a,b,c|invalid:x,y,z\n      const splits = config.split('|');\n      splits.forEach(s => {\n        const parts = s.split(':');\n        if (parts.length !== 2) {\n          throw new Error('invalid config');\n        }\n        const part1 = parts[0].toLowerCase();\n        const part2 = parts[1];\n        if (part1 === 'valid' || part1 === 'invalid') {\n          const values = part2.split(',').filter(p => p.trim().length > 0);\n          values.forEach(v => {\n            options.push({\n              value: v,\n              label: v,\n              isValid: part1 === 'valid'\n            });\n          });\n        } else {\n          throw new Error('invalid config');\n        }\n      });\n    } catch (e) {\n      notification.error({\n        message: `${translate('PAYLOAD_ERROR_INVALID_KEY_ATTRIBUTE')} ${config}`\n      });\n    }\n  }\n  return {\n    name: AUDIO_KEY_ATTRIBUTE,\n    label: `${translate('KEY_ATTRIBUTE_FILED_NAME')}`,\n    type: 'RADIO',\n    options\n  };\n};\nconst parseMinLength = length => {\n  const min = Number.parseFloat(length);\n  return Number.isNaN(min) ? 0.05 : min;\n};\nexport const parseSegments = (state, data) => {\n  const {\n    videoIndex,\n    segments\n  } = data;\n  const results = [...state.results];\n  results[videoIndex] = segments;\n  return {\n    ...state,\n    results\n  };\n};\nexport const parseTagGroup = data => {\n  try {\n    const tagGroup = decode(data) || [];\n    const shortcuts = {};\n    tagGroup.forEach(group => {\n      if (!group.tags) {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(group)}`);\n      }\n      if (group.type === tagType.tag) {\n        group.tags.forEach(tag => {\n          if (typeof tag.prefix !== 'string' || typeof tag.suffix !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else if (group.type === tagType.standalone) {\n        group.tags.forEach(tag => {\n          if (typeof tag.text !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_TYPE')} ${group.type}`);\n      }\n    });\n    return tagGroup;\n  } catch (error) {\n    notification.error({\n      message: error.message\n    });\n    return [];\n  }\n};\nexport const setWordTimestamps = (state, data) => ({\n  ...state,\n  wordTimestamps: data.wordTimestamps\n});\nexport const initPayload = (state, data) => new Promise(async (resolve, reject) => {\n  var _data$word_timestamps, _data$jobProxy;\n  const videos = await parseVideos(data.audio, data.result);\n  const ontology = parseOntology(data.ontology);\n  const globalConfig = parseLableConfig(data.global_config);\n  if (globalConfig && Array.isArray(globalConfig.fields) && globalConfig.fields.length > 0) {\n    const defaultValues = {};\n    globalConfig.fields.forEach(f => {\n      if (f.defaultValue !== undefined) {\n        defaultValues[f.name] = f.defaultValue;\n      }\n    });\n    if (Object.keys(defaultValues).length > 0) {\n      // has default values\n      videos.forEach(video => {\n        video.defaultAttributes = cloneDeep(defaultValues); // save default attributes\n        if (!isAnnotationReadonly(data.mode)) {\n          // update attributes if not readonly\n          if (!video.attributes) {\n            video.attributes = {};\n          }\n          Object.keys(defaultValues).forEach(key => {\n            if (video.attributes[key] === undefined) {\n              video.attributes[key] = defaultValues[key];\n            }\n          });\n        }\n      });\n    }\n  }\n  const invalidAnnotatable = data.invalid_annotatable !== 'false' && data.invalid_annotatable !== false;\n  const annotateDisabled = !invalidAnnotatable && videos[state.currentVideo].attributes && videos[state.currentVideo].attributes.is_valid === 'invalid';\n  const segmentConfig = parseLableConfig(data.label_config_segment);\n  const lineConfig = parseLableConfig(data.label_config);\n  const segmentFieldMap = {};\n  const lineFieldMap = {};\n  segmentConfig.fields.forEach(s => {\n    segmentFieldMap[s.name] = s;\n  });\n  lineConfig.fields.forEach(s => {\n    lineFieldMap[s.name] = s;\n  });\n  const issueTypes = data.issue_types ? data.issue_types.split(',') : ['issue type'];\n  const segmentMode = Object.values(SegmentMode).includes(data.segment_mode) ? data.segment_mode : SegmentMode.continuous;\n  const results = parseResults(data.review_from, data.unit_id, videos, ontology, lineConfig, segmentConfig, segmentMode);\n  const tagGroup = parseTagGroup(data.tag_group);\n  const jobId = data.job_id;\n  const overlap = data.overlap === 'true' || data.overlap === true;\n  const keyAttribute = parseKeyAttribute(data.key_attribute);\n  const client = data.client || '';\n  const wordTimestampUrls = ((_data$word_timestamps = data.word_timestamps) === null || _data$word_timestamps === void 0 ? void 0 : _data$word_timestamps.split(',')) || [];\n  const minLength = parseMinLength(data.min_length);\n  let spaceLine = 0;\n  if (data.space_line) {\n    const num = Number(data.space_line);\n    if (!Number.isNaN(num) && num > 0) {\n      spaceLine = num;\n    }\n  }\n  const measurements = [];\n  if (data.measurement_box) {\n    data.measurement_box.split(',').forEach(item => {\n      const size = Number(item);\n      if (!Number.isNaN(size) && size > 0 && !measurements.includes(size)) {\n        measurements.push(size);\n      }\n    });\n  }\n  const segmentOverlap = data.segment_overlap !== 'false' && data.segment_overlap !== false;\n  const adjustmentStep = 0.1;\n\n  // parse style config\n  const styleConfig = decode(data.style_config) || {\n    mode: StyleConfigMode.segment,\n    groups: []\n  };\n  const scriptCheck = data.script_check === 'true' || data.script_check === true;\n  const submitCheck = data.submit_check !== 'false' && data.submit_check !== false;\n  const validDuration = Object.values(ValidDurationMode).includes(data.valid_duration) ? data.valid_duration : ValidDurationMode.attributes;\n  const lastResults = JSON.parse(JSON.stringify(results)).map(v => {\n    const map = {};\n    (v || []).forEach(item => {\n      delete item.qaChecked;\n      delete item.qaComment;\n      delete item.qaReason;\n      delete item.qaWorkerName;\n      map[item.id] = item;\n    });\n    return map;\n  });\n  const newState = {\n    videos,\n    ontology,\n    results,\n    lastResults,\n    globalConfig,\n    invalidAnnotatable,\n    annotateDisabled,\n    segmentConfig,\n    lineConfig,\n    issueTypes,\n    unitId: data.unit_id,\n    toolMode: data.mode,\n    reviews: data._reviews,\n    tagGroup,\n    jobId,\n    overlap,\n    keyAttribute,\n    client,\n    wordTimestampUrls,\n    minSegmentLength: minLength,\n    segmentMode,\n    currentSegment: segmentMode === SegmentMode.individual ? -1 : 0,\n    spaceLine,\n    measurements,\n    selectedMeasurement: measurements[0] || -1,\n    segmentOverlap,\n    adjustmentStep,\n    scriptCheck,\n    submitCheck,\n    validDuration,\n    segmentFieldMap,\n    lineFieldMap,\n    styleConfig,\n    jobProxy: data.jobProxy,\n    workerName: (_data$jobProxy = data.jobProxy) === null || _data$jobProxy === void 0 ? void 0 : _data$jobProxy.advanceWorkerName\n  };\n  resolve(newState);\n});\nexport const initPayloadState = (state, data) => ({\n  ...state,\n  ...data\n});\nexport const saveData = state => {\n  const data = {\n    results: state.results,\n    videos: state.videos\n  };\n  store.setStorage('long-audio', state.unitId, data);\n};\nexport const setVideoLoaded = (state, data) => {\n  const videos = [...state.videos];\n  videos.forEach((v, i) => {\n    v.url = data.videos[i].url;\n    v.loaded = true;\n  });\n  return {\n    ...state,\n    videos,\n    isLoadedAlaw: true\n  };\n};\nexport const setLoading = (state, data) => ({\n  ...state,\n  loading: data\n});\nexport const setVideoValid = (state, data) => {\n  const {\n    index\n  } = data;\n  const videos = [...state.videos];\n  videos[index] = {\n    ...state.videos[index]\n  };\n  videos[index].ready = true;\n  return {\n    ...state,\n    videos\n  };\n};\nexport const setVideoAttributes = (state, data) => {\n  const {\n    index,\n    attributes\n  } = data;\n  const {\n    videos\n  } = state;\n  videos[index].attributes = {\n    ...videos[index].attributes,\n    ...attributes\n  };\n  return {\n    ...state,\n    annotateDisabled: !state.invalidAnnotatable && videos[index].attributes && videos[index].attributes.is_valid === 'invalid'\n  };\n};\nexport const setAttributeFocusInfo = (state, data = {}) => {\n  if (!isEqual(state.focusAttribute, data)) {\n    return {\n      ...state,\n      focusAttribute: {\n        ...data,\n        videoIndex: state.currentVideo\n      }\n    };\n  }\n  return state;\n};\nexport const setLoadReviewEnabled = (state, enabled) => ({\n  ...state,\n  loadReviewEnabled: enabled\n});\nexport const setResults = (state, data) => ({\n  ...state,\n  results: data.results\n});","map":{"version":3,"names":["Base64","cloneDeep","isEqual","toWav","notification","createSegment","defaultColor","translate","tagType","SegmentMode","ValidDurationMode","StyleConfigMode","store","lawToWav","getFileExtension","isAnnotationReadonly","decode","str","JSON","parse","e","AUDIO_KEY_ATTRIBUTE","AUDIO_ROLE_ATTRIBUTE","handleLawToWav","alawUrl","tail","index","Promise","resolve","reject","buffer","fetch","then","res","arrayBuffer","audioBuffer","wav","blob","Blob","type","window","URL","createObjectURL","error","message","parseVideos","audio","result","audios","array","split","videos","videoTypes","length","src","video","savedAudio","push","url","source","loaded","ready","zoom","speed","checked","indexOf","duration","attributes","undefined","originAttributes","parseLableConfig","labelConfig","keys","obj","fields","forEach","value","name","toLowerCase","Error","parseOntology","ontology","newOntology","Map","set","darkGray","has","class_name","display_color","parseResults","results","unitId","lineConfig","segmentConfig","segmentMode","cache","getStorage","individual","parseKeyAttribute","config","options","splits","s","parts","part1","part2","values","filter","p","trim","v","label","isValid","parseMinLength","min","Number","parseFloat","isNaN","parseSegments","state","data","videoIndex","segments","parseTagGroup","tagGroup","shortcuts","group","tags","stringify","tag","prefix","suffix","shortcut","standalone","text","setWordTimestamps","wordTimestamps","initPayload","_data$word_timestamps","_data$jobProxy","globalConfig","global_config","Array","isArray","defaultValues","f","defaultValue","Object","defaultAttributes","mode","key","invalidAnnotatable","invalid_annotatable","annotateDisabled","currentVideo","is_valid","label_config_segment","label_config","segmentFieldMap","lineFieldMap","issueTypes","issue_types","includes","segment_mode","continuous","review_from","unit_id","tag_group","jobId","job_id","overlap","keyAttribute","key_attribute","client","wordTimestampUrls","word_timestamps","minLength","min_length","spaceLine","space_line","num","measurements","measurement_box","item","size","segmentOverlap","segment_overlap","adjustmentStep","styleConfig","style_config","segment","groups","scriptCheck","script_check","submitCheck","submit_check","validDuration","valid_duration","lastResults","map","qaChecked","qaComment","qaReason","qaWorkerName","id","newState","toolMode","reviews","_reviews","minSegmentLength","currentSegment","selectedMeasurement","jobProxy","workerName","advanceWorkerName","initPayloadState","saveData","setStorage","setVideoLoaded","i","isLoadedAlaw","setLoading","loading","setVideoValid","setVideoAttributes","setAttributeFocusInfo","focusAttribute","setLoadReviewEnabled","enabled","loadReviewEnabled","setResults"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/redux/reducer/connectController.js"],"sourcesContent":["import { Base64 } from 'js-base64';\nimport { cloneDeep, isEqual } from 'lodash';\nimport * as toWav from 'audiobuffer-to-wav';\nimport { notification } from 'antd';\nimport { createSegment } from './segmentController';\nimport { defaultColor, translate, tagType, SegmentMode, ValidDurationMode, StyleConfigMode } from '../../constants';\nimport { store, lawToWav, getFileExtension } from '../../../../utils';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\n\nconst decode = (str) => {\n  try { return JSON.parse(Base64.decode(str)); } catch (e) { return null; }\n};\n\nconst AUDIO_KEY_ATTRIBUTE = 'audio_key_attribute';\nconst AUDIO_ROLE_ATTRIBUTE = 'role';\n\nexport const handleLawToWav = (alawUrl, tail, index) => new Promise(async (resolve, reject) => {\n  try {\n    const buffer = await fetch(alawUrl).then((res) => res.arrayBuffer());\n    const audioBuffer = lawToWav(buffer, tail);\n    const wav = toWav(audioBuffer);\n    const blob = new Blob([wav], { type: 'audio/wav' });\n    resolve(window.URL.createObjectURL(blob));\n  } catch (error) {\n    notification.error({ message: `${translate('AUDIO_ERROR')} ${index + 1}` });\n    return false;\n  }\n});\n\nconst parseVideos = (audio, result) => new Promise(async (resolve, reject) => {\n  const { audios = [] } = result || {};\n  const array = audio.split(',');\n  const videos = [];\n  const videoTypes = 'asf,avi,wmv,mkv,mp4,mov,rm,3gp,flv,mpg,rmvb,mpeg'.split(',');\n  for (let index = 0; index < array.length; index += 1) {\n    const src = array[index];\n    let video = src;\n    if (video) {\n      const tail = getFileExtension(video);\n      if ((tail === 'alaw' || tail === 'ulaw') && index === 0) {\n        video = await handleLawToWav(src, tail, index);\n      }\n      if (video) {\n        const savedAudio = audios[index];\n        videos.push({\n          url: video,\n          source: src,\n          loaded: (tail !== 'alaw' && tail !== 'ulaw') ? true : index === 0,\n          ready: false,\n          zoom: 1,\n          speed: 1,\n          checked: !index,\n          type: videoTypes.indexOf(tail) < 0 ? 'none-video' : 'video',\n          ...savedAudio && savedAudio.duration && {\n            duration: savedAudio.duration\n          },\n          ...savedAudio && savedAudio.attributes !== undefined && {\n            attributes: cloneDeep(savedAudio.attributes),\n            originAttributes: cloneDeep(savedAudio.attributes), // save original saved attributes\n          },\n        });\n      }\n    }\n  }\n  resolve(videos);\n});\n\nconst parseLableConfig = (labelConfig) => {\n  try {\n    const keys = [AUDIO_KEY_ATTRIBUTE, AUDIO_ROLE_ATTRIBUTE];\n    const obj = decode(labelConfig) || { fields: [] };\n    obj.fields = obj.fields || [];\n    obj.fields.forEach((value) => {\n      // if (value.type.toUpperCase() !== 'RADIO'\n      //     && value.type.toUpperCase() !== 'TEXTAREA'\n      //     && value.type.toUpperCase() !== 'TEXT') {\n      //   throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE_TYPE')}: ${value.type}`);\n      // }\n      if (value.name && keys.indexOf(value.name.toLowerCase()) >= 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ATTRIBUTE_NAME')}: ${value.name}`);\n      }\n      keys.push(value.name.toLowerCase());\n    });\n    return obj;\n  } catch (error) {\n    notification.error({ message: error.message });\n    return { fields: [] };\n  }\n};\n\nconst parseOntology = (ontology = []) => {\n  try {\n    const newOntology = new Map();\n    newOntology.set('none', defaultColor.darkGray);\n    ontology.forEach((value, index) => {\n      if (!newOntology.has(value.class_name)) newOntology.set(value.class_name, value.display_color);\n      else throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ONTOLOGY')}: ${value.class_name}`);\n    });\n    return newOntology;\n  } catch (error) {\n    notification.error({ message: error.message });\n    return new Map();\n  }\n};\n\nconst parseResults = (results, unitId, videos, ontology, lineConfig, segmentConfig, segmentMode) => {\n  // eslint-disable-next-line no-param-reassign\n  // console.log(store.getStorage('long-audio', 'review_from'));\n  const cache = store.getStorage('long-audio', unitId);\n  results = cache && cache.results ? cache.results : results;\n  if (!results || !results.length) results = [];\n  videos.forEach((video, index) => {\n    if (!results[index] || !results[index].length) {\n      if (segmentMode === SegmentMode.individual) {\n        results[index] = [];\n      } else {\n        results[index] = [createSegment(0, null, segmentConfig, lineConfig)];\n      }\n    }\n  });\n  return results;\n};\n\nconst parseKeyAttribute = (config) => {\n  const options = [];\n  if (config && typeof config === 'string') {\n    try {\n      // e.g. valid:a,b,c|invalid:x,y,z\n      const splits = config.split('|');\n      splits.forEach((s) => {\n        const parts = s.split(':');\n        if (parts.length !== 2) {\n          throw new Error('invalid config');\n        }\n        const part1 = parts[0].toLowerCase();\n        const part2 = parts[1];\n        if (part1 === 'valid' || part1 === 'invalid') {\n          const values = part2.split(',').filter((p) => p.trim().length > 0);\n          values.forEach((v) => {\n            options.push({\n              value: v,\n              label: v,\n              isValid: part1 === 'valid'\n            });\n          });\n        } else {\n          throw new Error('invalid config');\n        }\n      });\n    } catch (e) {\n      notification.error({ message: `${translate('PAYLOAD_ERROR_INVALID_KEY_ATTRIBUTE')} ${config}` });\n    }\n  }\n\n  return {\n    name: AUDIO_KEY_ATTRIBUTE,\n    label: `${translate('KEY_ATTRIBUTE_FILED_NAME')}`,\n    type: 'RADIO',\n    options,\n  };\n};\n\nconst parseMinLength = (length) => {\n  const min = Number.parseFloat(length);\n  return Number.isNaN(min) ? 0.05 : min;\n};\n\nexport const parseSegments = (state, data) => {\n  const { videoIndex, segments } = data;\n  const results = [...state.results];\n  results[videoIndex] = segments;\n  return {\n    ...state,\n    results,\n  };\n};\n\nexport const parseTagGroup = (data) => {\n  try {\n    const tagGroup = decode(data) || [];\n    const shortcuts = {};\n    tagGroup.forEach((group) => {\n      if (!group.tags) {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(group)}`);\n      }\n      if (group.type === tagType.tag) {\n        group.tags.forEach((tag) => {\n          if (typeof tag.prefix !== 'string' || typeof tag.suffix !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else if (group.type === tagType.standalone) {\n        group.tags.forEach((tag) => {\n          if (typeof tag.text !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_TYPE')} ${group.type}`);\n      }\n    });\n    return tagGroup;\n  } catch (error) {\n    notification.error({ message: error.message });\n    return [];\n  }\n};\n\nexport const setWordTimestamps = (state, data) => ({\n  ...state,\n  wordTimestamps: data.wordTimestamps,\n});\n\nexport const initPayload = (state, data) => new Promise(async (resolve, reject) => {\n  const videos = await parseVideos(data.audio, data.result);\n  const ontology = parseOntology(data.ontology);\n  const globalConfig = parseLableConfig(data.global_config);\n  if (globalConfig && Array.isArray(globalConfig.fields) && globalConfig.fields.length > 0) {\n    const defaultValues = {};\n    globalConfig.fields.forEach((f) => {\n      if (f.defaultValue !== undefined) {\n        defaultValues[f.name] = f.defaultValue;\n      }\n    });\n    if (Object.keys(defaultValues).length > 0) { // has default values\n      videos.forEach((video) => {\n        video.defaultAttributes = cloneDeep(defaultValues); // save default attributes\n        if (!isAnnotationReadonly(data.mode)) {\n          // update attributes if not readonly\n          if (!video.attributes) {\n            video.attributes = {};\n          }\n          Object.keys(defaultValues).forEach((key) => {\n            if (video.attributes[key] === undefined) {\n              video.attributes[key] = defaultValues[key];\n            }\n          });\n        }\n      });\n    }\n  }\n  const invalidAnnotatable = data.invalid_annotatable !== 'false' && data.invalid_annotatable !== false;\n  const annotateDisabled = !invalidAnnotatable && videos[state.currentVideo].attributes && videos[state.currentVideo].attributes.is_valid === 'invalid';\n  const segmentConfig = parseLableConfig(data.label_config_segment);\n  const lineConfig = parseLableConfig(data.label_config);\n  const segmentFieldMap = {};\n  const lineFieldMap = {};\n  segmentConfig.fields\n    .forEach((s) => {\n      segmentFieldMap[s.name] = s;\n    });\n  lineConfig.fields\n    .forEach((s) => {\n      lineFieldMap[s.name] = s;\n    });\n\n  const issueTypes = data.issue_types ? data.issue_types.split(',') : ['issue type'];\n  const segmentMode = Object.values(SegmentMode).includes(data.segment_mode) ? data.segment_mode : SegmentMode.continuous;\n  const results = parseResults(data.review_from, data.unit_id, videos, ontology, lineConfig, segmentConfig, segmentMode);\n  const tagGroup = parseTagGroup(data.tag_group);\n  const jobId = data.job_id;\n  const overlap = data.overlap === 'true' || data.overlap === true;\n  const keyAttribute = parseKeyAttribute(data.key_attribute);\n  const client = data.client || '';\n  const wordTimestampUrls = data.word_timestamps?.split(',') || [];\n  const minLength = parseMinLength(data.min_length);\n  let spaceLine = 0;\n  if (data.space_line) {\n    const num = Number(data.space_line);\n    if (!Number.isNaN(num) && num > 0) {\n      spaceLine = num;\n    }\n  }\n  const measurements = [];\n  if (data.measurement_box) {\n    data.measurement_box.split(',').forEach((item) => {\n      const size = Number(item);\n      if (!Number.isNaN(size) && size > 0 && !measurements.includes(size)) {\n        measurements.push(size);\n      }\n    });\n  }\n  const segmentOverlap = data.segment_overlap !== 'false' && data.segment_overlap !== false;\n  const adjustmentStep = 0.1;\n\n  // parse style config\n  const styleConfig = decode(data.style_config) || {\n    mode: StyleConfigMode.segment,\n    groups: [],\n  };\n\n  const scriptCheck = data.script_check === 'true' || data.script_check === true;\n  const submitCheck = data.submit_check !== 'false' && data.submit_check !== false;\n  const validDuration = Object.values(ValidDurationMode).includes(data.valid_duration) ? data.valid_duration : ValidDurationMode.attributes;\n  const lastResults = JSON.parse(JSON.stringify(results)).map((v) => {\n    const map = {};\n    (v || []).forEach((item) => {\n      delete item.qaChecked;\n      delete item.qaComment;\n      delete item.qaReason;\n      delete item.qaWorkerName;\n      map[item.id] = item;\n    });\n    return map;\n  });\n  const newState = {\n    videos,\n    ontology,\n    results,\n    lastResults,\n    globalConfig,\n    invalidAnnotatable,\n    annotateDisabled,\n    segmentConfig,\n    lineConfig,\n    issueTypes,\n    unitId: data.unit_id,\n    toolMode: data.mode,\n    reviews: data._reviews,\n    tagGroup,\n    jobId,\n    overlap,\n    keyAttribute,\n    client,\n    wordTimestampUrls,\n    minSegmentLength: minLength,\n    segmentMode,\n    currentSegment: segmentMode === SegmentMode.individual ? -1 : 0,\n    spaceLine,\n    measurements,\n    selectedMeasurement: measurements[0] || -1,\n    segmentOverlap,\n    adjustmentStep,\n    scriptCheck,\n    submitCheck,\n    validDuration,\n    segmentFieldMap,\n    lineFieldMap,\n    styleConfig,\n    jobProxy: data.jobProxy,\n    workerName: data.jobProxy?.advanceWorkerName\n  };\n  resolve(newState);\n});\n\nexport const initPayloadState = (state, data) => ({\n  ...state,\n  ...data,\n});\n\nexport const saveData = (state) => {\n  const data = {\n    results: state.results,\n    videos: state.videos,\n  };\n  store.setStorage('long-audio', state.unitId, data);\n};\n\nexport const setVideoLoaded = (state, data) => {\n  const videos = [...state.videos];\n  videos.forEach((v, i) => {\n    v.url = data.videos[i].url;\n    v.loaded = true;\n  });\n  return {\n    ...state,\n    videos,\n    isLoadedAlaw: true,\n  };\n};\n\nexport const setLoading = (state, data) => ({\n  ...state,\n  loading: data,\n});\n\nexport const setVideoValid = (state, data) => {\n  const { index } = data;\n  const videos = [...state.videos];\n  videos[index] = { ...state.videos[index] };\n  videos[index].ready = true;\n  return {\n    ...state,\n    videos,\n  };\n};\n\nexport const setVideoAttributes = (state, data) => {\n  const { index, attributes } = data;\n  const { videos } = state;\n  videos[index].attributes = { ...videos[index].attributes, ...attributes };\n\n  return {\n    ...state,\n    annotateDisabled: !state.invalidAnnotatable && videos[index].attributes && videos[index].attributes.is_valid === 'invalid',\n  };\n};\n\nexport const setAttributeFocusInfo = (state, data = {}) => {\n  if (!isEqual(state.focusAttribute, data)) {\n    return { ...state, focusAttribute: { ...data, videoIndex: state.currentVideo } };\n  }\n  return state;\n};\n\nexport const setLoadReviewEnabled = (state, enabled) => ({\n  ...state,\n  loadReviewEnabled: enabled,\n});\n\nexport const setResults = (state, data) => ({\n  ...state,\n  results: data.results,\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}