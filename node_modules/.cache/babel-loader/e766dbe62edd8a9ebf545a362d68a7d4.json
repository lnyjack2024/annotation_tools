{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx\";\nimport React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport CanvasContainer from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { LandmarkEditType, DELETETYPE, ReviewResult } from './types';\nimport { fetchResultByUrl } from './request';\nimport loader from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport { initInstances, loadInstancesFromResult, getFrameShapes, parseFramesByPaylod, getInstanceFrames, validate } from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nimport advanceJob, { AdvanceMessage } from '../../libs/advanceJob';\nimport cache from './utils-storage';\nimport MultiAttributes from './components/MultiAttributes';\nimport Missing from './components/QualityControl/Missing';\nnotification.config({\n  top: 60\n});\nvar CANVASSTATUS = /*#__PURE__*/function (CANVASSTATUS) {\n  CANVASSTATUS[\"INITIAL\"] = \"initial\";\n  CANVASSTATUS[\"LANDMARK\"] = \"landmark\";\n  return CANVASSTATUS;\n}(CANVASSTATUS || {});\nlet renderInstances = {};\nconst LandmarkAnnotation = forwardRef((props, ref) => {\n  const store = useLocalObservable(() => rootStore);\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState(78);\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState('');\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState({});\n  const [updatedCategories, setUpdatedCategories] = useAsyncState([]);\n  const [defaultInstances, setDefaultInstances] = useAsyncState({});\n  const [instances, setInstances] = useAsyncState({});\n\n  /**\n   * image preloader\n   */\n  const imagePreloader = useRef();\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n  const [selectedGroups, setSelectedGroups] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [formConfig, setFormConfig] = useState(null);\n  const [formValues, setFormValues] = useState(null);\n  const [imageSize, setImageSize] = useState({\n    width: 0,\n    height: 0\n  });\n  const [editFormObject, setEditFormObject] = useState(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState({});\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState({});\n  const [multiAttrModalVisible, setMultiAttrModalVisible] = useState(false);\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef(null);\n  const canvas = useRef(null);\n  const isDrawMode = useObserver(() => store.review.drawMode);\n  const displayedInstances = useMemo(() => isReview ? initialInstances : instances, [isReview, initialInstances, instances]);\n  const instanceIds = useMemo(() => Object.keys(displayedInstances), [displayedInstances]);\n  const instanceList = useMemo(() => Object.values(displayedInstances).filter(v => !!v), [displayedInstances]);\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap = {};\n    instanceList.forEach(({\n      category,\n      id,\n      number\n    }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n  const displayedCategoryInstancesMap = useMemo(() => isReview ? initialCategoryInstancesMap : categoryInstancesMap, [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n  const displayedCategoryPathShapes = useMemo(() => isReview ? initialCategoryPathShapes : categoryPathShapes, [isReview, initialCategoryPathShapes, categoryPathShapes]);\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    return ontologyItem;\n  });\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find(group => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n  const categories = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.categories) || [], [ontologyGroup]);\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.id;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ? categories.findIndex(c => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) : -1;\n  }, [selectedShapeStatus, categories]);\n  const instancesFrames = useMemo(() => {\n    const items = {};\n    instanceList.forEach(instance => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n  const shapes = useMemo(() => {\n    var _selectedInstance$chi;\n    const group = selectedInstance === null || selectedInstance === void 0 ? void 0 : (_selectedInstance$chi = selectedInstance.children.find(g => g.name === selectedOntologyGroup)) === null || _selectedInstance$chi === void 0 ? void 0 : _selectedInstance$chi.frames[currentFrame];\n    return group && group.shapes || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n  const selectedShapeInfo = useMemo(() => {\n    let info = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        displayColor: (selectedOntology === null || selectedOntology === void 0 ? void 0 : selectedOntology.display_color) || ''\n      };\n      if ((ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        var _categories$selectedC;\n        info = {\n          ...info,\n          pointCategory: (_categories$selectedC = categories[selectedCategoryIndex]) === null || _categories$selectedC === void 0 ? void 0 : _categories$selectedC.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n  const annotatedPointOrShapeCount = useMemo(() => Object.entries(shapes).filter(([, v]) => v !== undefined).length, [shapes]);\n  const totalPointCount = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.count) || 0, [ontologyGroup]);\n  const instancesReviewsMap = useObserver(() => {\n    const map = {};\n    store.review.reviews.forEach(review => {\n      var _instances$instanceId;\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        shapeIds,\n        result\n      } = review;\n      const category = (_instances$instanceId = instances[instanceId]) === null || _instances$instanceId === void 0 ? void 0 : _instances$instanceId.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0\n        };\n      }\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n  useEffect(() => {\n    // set props\n    store.jobProxy = props.jobProxy;\n    onLoad();\n  }, []);\n  useEffect(() => {\n    if (selectedShapeInfo === null || selectedShapeInfo === void 0 ? void 0 : selectedShapeInfo.instanceId) {\n      store.review.setSelectedMissingReview();\n    }\n  }, [selectedShapeInfo]);\n  const getInstance = instanceId => displayedInstances[instanceId];\n  const getGroup = (instanceId, groupName, frameIndex = currentFrame) => {\n    var _instance$children$fi;\n    const instance = getInstance(instanceId);\n    const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[frameIndex];\n    return group;\n  };\n  const getShape = (instanceId, groupName, id, frameIndex = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? group.shapes[id] : group.shapes[id]);\n  };\n  const setInstance = (id, instance) => {\n    renderInstances = {\n      ...instances,\n      [id]: instance\n    };\n    if (instance === undefined) {\n      delete renderInstances[id];\n    }\n    setInstances(renderInstances);\n  };\n  const setShape = (frameIndex, instanceId, groupName, id, shapeType, shape) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      var _group;\n      let group = instance.children.find(g => g.name === groupName);\n      let currentGroup = (_group = group) === null || _group === void 0 ? void 0 : _group.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = currentGroup.shapes[id];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = currentGroup.shapes[id];\n      }\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete currentGroup.shapes[id];\n        } else {\n          delete currentGroup.shapes[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n        }\n        currentGroup.shapes = {\n          ...currentGroup.shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === groupInfo.count && !currentGroup.attributes) {\n        handleFormConfig(groupInfo.label_config, {}, {\n          instanceId,\n          category: instance.category,\n          groupName\n        });\n      }\n    }\n  };\n  const updateStatus = async (curr, prev) => {\n    let newUpdatedShapes = [];\n    let newUpdatedCategories = [];\n    let updatedHandles = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const {\n          frameIndex,\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        let keyObj;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = {\n            index\n          };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = {\n            id\n          };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({\n            ...frameGroup,\n            ...keyObj,\n            shapeType\n          });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          const {\n            updateShapes\n          } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          const instanceIndex = instanceIds.findIndex(v => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          frameIndex,\n          groupName,\n          attributes\n        } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n          if (newInstance && newGroup) {\n            newGroup.frames[frameIndex].attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const {\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType,\n          shape,\n          frameIndex\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape;\n            const {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              attributes\n            } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex(p => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: {\n                  ...point.position\n                }\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                index,\n                shape: updateShape,\n                shapeType\n              });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape;\n            const {\n              displayColor,\n              visible,\n              x,\n              y,\n              width,\n              height\n            } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible\n            };\n            const updateIndex = newUpdatedShapes.findIndex(rect => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                id,\n                shape: updateRectangle,\n                shapeType\n              });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const {\n          frameIndex,\n          pointCategory,\n          shape\n        } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3]\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const {\n            updateShapes,\n            updatedCategories: newCategories\n          } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          newUpdatedCategories = [...newUpdatedCategories, ...newCategories];\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          groupName,\n          attributes,\n          frameIndex\n        } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach(id => {\n            var _canvas$current;\n            const attrLayer = (_canvas$current = canvas.current) === null || _canvas$current === void 0 ? void 0 : _canvas$current.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              var _canvas$current2;\n              (_canvas$current2 = canvas.current) === null || _canvas$current2 === void 0 ? void 0 : _canvas$current2.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes, newInstance.number);\n            }\n          });\n          newGroup.frames[frameIndex].attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({\n          message: 'Undo successfully.'\n        });\n      }\n    }\n  };\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({\n          message: 'Redo successfully.'\n        });\n      }\n    }\n  };\n  const handleChangeDrawMode = mode => {\n    if (store.review.isEditable) {\n      var _canvas$current3;\n      (_canvas$current3 = canvas.current) === null || _canvas$current3 === void 0 ? void 0 : _canvas$current3.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(undefined, {\n          instanceId,\n          category,\n          groupName\n        });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n  const loadInitialData = async () => {\n    let data;\n    const {\n      initial_result: initialResult\n    } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n  const addInstance = async ontologyName => {\n    var _rootStore$ontology$o;\n    const oName = ontologyName || (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category) || ((_rootStore$ontology$o = rootStore.ontology.ontology[0]) === null || _rootStore$ontology$o === void 0 ? void 0 : _rootStore$ontology$o.class_name);\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === oName);\n    if (ontologyItem) {\n      const ontologyInstances = instanceList.filter(instance => instance.category === ontologyItem.class_name);\n      const canAdd = ontologyInstances.filter(instance => !instance.notEmpty).length <= 0;\n      if (!canAdd) {\n        return;\n      }\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter(v => v.category === oName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n      const children = ontologyItem.children.map(v => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({\n        [id]: instance\n      });\n      await handleInstanceChange({\n        [id]: instance\n      });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, {\n          category: ontologyItem.class_name,\n          shapeType: ontologyItem.children[0].type\n        });\n      }\n    }\n  };\n  const addInstanceInFrame = async (instanceId, groupName) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex(group => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame;\n          Object.keys(newInstance.children[groupIdx].frames).forEach(i => {\n            const index = Number(i);\n            const frame = {\n              ...newInstance.children[groupIdx].frames[index]\n            };\n            frame.shapes = {\n              ...frame.shapes\n            };\n            if ((frame === null || frame === void 0 ? void 0 : frame.count) && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count || 0;\n            newInstance.notEmpty += copyFrame.count || 0;\n          }\n        }\n      } else {\n        let copyFrameIdx;\n        Object.keys(instancesFrames[instanceId]).forEach(i => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach(group => {\n            const copyFrame = {\n              ...group.frames[copyFrameIdx]\n            };\n            copyFrame.shapes = {\n              ...copyFrame.shapes\n            };\n            if (copyFrame) {\n              group.count += copyFrame.count || 0;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const {\n        updateShapes,\n        updatedCategories: newUpdatedCategories\n      } = getFrameShapes([newInstance], currentFrame);\n      await handleInstanceChange({\n        [instanceId]: newInstance\n      });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n  const removeInstanceFrames = (type, instance, name) => {\n    if (instance) {\n      let delShapes = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance, frameIndex) => {\n        updateInstance.children.forEach(group => {\n          if (name && name === group.name || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= group.frames[frameIndex].count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const {\n          updateShapes\n        } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({\n          length: frames.length - diffFrame\n        }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const {\n            updateShapes\n          } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [...delShapes, ...updateShapes];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter(v => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({\n        [newInstance.id]: newInstance\n      });\n    }\n  };\n  const handleInstanceChange = async (newInstances, status) => {\n    const ids = Object.keys(newInstances);\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async id => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach(child => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance\n          }\n        });\n        after.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n  const onLoad = async () => {\n    var _result, _saverRef$current;\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // setup storage\n    cache.setCurrentProject(props.jobProxy.projectId);\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n    let result;\n    let initialData;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({\n        message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({\n      frames: props.image,\n      imageData: (_result = result) === null || _result === void 0 ? void 0 : _result.images\n    });\n    // preload image\n    imagePreloader.current = loader(framesData.map(v => v.url));\n    // set frame images\n    setFrames(framesData);\n    store.setting.initAllVisibleStatusList(framesData.length);\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes = {};\n        result.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData = {};\n        initialData.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const {\n        newInstances,\n        categoryInstancesMap: newCategoryInstancesMap\n      } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const {\n        newInstances\n      } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      renderInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, renderInstances);\n    (_saverRef$current = saverRef.current) === null || _saverRef$current === void 0 ? void 0 : _saverRef$current.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n\n    // advancejob listener\n    advanceJob.on(AdvanceMessage.UPDATE_RESULT, loadAdvanceJobData);\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex, currentInstances = instances, type) => {\n    var _canvas$current4, _canvas$current5, _imagePreloader$curre;\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    store.review.cancelUnfinishMissingReview();\n    const currentInstanceList = Object.values(currentInstances);\n    (_canvas$current4 = canvas.current) === null || _canvas$current4 === void 0 ? void 0 : _canvas$current4.cleanLayer();\n    (_canvas$current5 = canvas.current) === null || _canvas$current5 === void 0 ? void 0 : _canvas$current5.setMultiShapesUnselected();\n    (_imagePreloader$curre = imagePreloader.current) === null || _imagePreloader$curre === void 0 ? void 0 : _imagePreloader$curre.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const {\n        id,\n        category,\n        children: [{\n          name\n        }]\n      } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group === null || group === void 0 ? void 0 : group.type\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const {\n      updateShapes,\n      updatedCategories: updatedCategoriesData\n    } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n  const onSave = async (submit = true) => {\n    var _saverRef$current2, _canvas$current6, _canvas$current6$imag, _canvas$current7, _canvas$current7$imag;\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({\n        message: loadError\n      });\n      throw new Error(loadError);\n    }\n    (_saverRef$current2 = saverRef.current) === null || _saverRef$current2 === void 0 ? void 0 : _saverRef$current2.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances = instanceList.filter(v => v && v.notEmpty).map(instance => {\n      const {\n        id,\n        category,\n        number,\n        displayColor,\n        children\n      } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map(group => {\n          const {\n            frames: groupFrames\n          } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter(v => !!v && v.count > 0).map(frameGroup => {\n              if (frameGroup) {\n                const {\n                  frameIndex,\n                  count,\n                  shapes: groupShapes\n                } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach(key => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point = groupShapes && groupShapes[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        newShapes.push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle = groupShapes && groupShapes[key];\n                      if (rectangle) newShapes.push(rectangle);\n                    }\n                  });\n                }\n                if (checkMissingPoints && frames[frameIndex].valid !== false && groupInfo && newShapes.length < groupInfo.count) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.display_name,\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({\n                    message: errMsg\n                  });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditFileId,\n      width: ((_canvas$current6 = canvas.current) === null || _canvas$current6 === void 0 ? void 0 : (_canvas$current6$imag = _canvas$current6.imageCanvas) === null || _canvas$current6$imag === void 0 ? void 0 : _canvas$current6$imag.width) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.width),\n      height: ((_canvas$current7 = canvas.current) === null || _canvas$current7 === void 0 ? void 0 : (_canvas$current7$imag = _canvas$current7.imageCanvas) === null || _canvas$current7$imag === void 0 ? void 0 : _canvas$current7$imag.height) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.height),\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map(pointCategory => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory]\n      })),\n      images: frames,\n      statistics,\n      annotatedFrameCount: statData.annotatedFrameCount\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0\n    };\n    const reviews = store.review.reviews.filter(r => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter(r => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find(r => r.shapeIds.indexOf(shapeId) >= 0);\n            if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return {\n      objects,\n      shapes: statShapes\n    };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const {\n      ontology\n    } = store.ontology;\n    const data = {\n      elements: [],\n      categories: ontology.map(({\n        class_name: className\n      }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set()\n    };\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const {\n        id,\n        category,\n        children\n      } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(...frameShapes.map(s => ({\n              instance: id,\n              shape,\n              frame: frame.frameIndex + 1,\n              category,\n              id: s.id || s.index\n            })));\n          }\n        }\n      }\n    }\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({\n        category,\n        shape,\n        count,\n        distinctCount\n      }) => ({\n        category,\n        shape,\n        count,\n        distinctCount\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size\n    };\n  };\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n  const saveReviews = (type = 'submit') => {\n    var _saverRef$current3;\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find(review => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    (_saverRef$current3 = saverRef.current) === null || _saverRef$current3 === void 0 ? void 0 : _saverRef$current3.disableLeaveCheck();\n    const reviews = toJS(store.review.reviews).map(r => {\n      const {\n        instanceId: id,\n        groupName,\n        shapeIds\n      } = r;\n      const instance = getInstance(id);\n      const ontologyItem = store.ontology.getOntologyInfo(instance === null || instance === void 0 ? void 0 : instance.category);\n      const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find(group => group.name === groupName);\n      const label = ontologyItem && instance ? `${ontologyItem.display_name || ''}${instance.number}${groupItem ? `-${groupItem.display_name}` : ''}${shapeIds && shapeIds.length && typeof shapeIds[0] === 'number' ? `[${shapeIds.join(',')}]` : ''}` : 'Deleted';\n      return {\n        ...r,\n        label\n      };\n    });\n    const missingReviews = toJS(store.review.missingReviews).map(r => ({\n      ...r,\n      label: 'Missed'\n    }));\n    return props.jobProxy.saveReviews([...reviews, ...missingReviews], type === 'submit');\n  };\n  const handleSave = async () => {\n    const {\n      toolMode\n    } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n    try {\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({\n        message: formatMessage('SAVE_SUCCESS')\n      });\n    } catch (e) {\n      notification.error({\n        message: formatMessage('SAVE_FAIL')\n      });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const {\n        hasCustomError,\n        blockSubmitErrors\n      } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n  const setSelectedShape = (id, groupData) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        shapeType\n      } = groupData;\n      if (instanceId !== (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.id)) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        groupName\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n  const setNextEmptyShape = (shapeStatus = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let emptyShapeFound = false;\n      let {\n        id\n      } = shapeStatus;\n      const {\n        instanceId,\n        groupName,\n        shapeType\n      } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const {\n            range = []\n          } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            id += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id) === undefined) {\n            emptyShapeFound = true;\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n        emptyShapeFound = true;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n      return emptyShapeFound;\n    }\n    return false;\n  };\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n  const handleShapesChange = (newShapes, groupsAttributes, status) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    const {\n      instanceId,\n      groupName\n    } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData((newInstance === null || newInstance === void 0 ? void 0 : newInstance.category) || '', groupName);\n    newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          };\n        }\n        ;\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const {\n            id,\n            frameIndex,\n            index,\n            shape\n          } = newShapes[i];\n          let oldShape;\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = child.frames[frameIndex].shapes[index];\n            child.frames[frameIndex].shapes[index] = {\n              ...oldShape,\n              ...shape\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = child.frames[frameIndex].shapes[id];\n            child.frames[frameIndex].shapes[id] = {\n              ...oldShape,\n              ...shape\n            };\n          }\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        }\n        ;\n        if (store.setting.preferences.autoOpenAttributesModal && (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.count) && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, {\n            instanceId,\n            category: newInstance.category,\n            groupName\n          });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({\n        instanceId: id,\n        name,\n        category,\n        attributes\n      }) => {\n        const frameGroup = {\n          frameIndex: currentFrame,\n          instanceId: id,\n          category,\n          groupName: name\n        };\n        before.push({\n          type: 'group',\n          status: {\n            ...frameGroup\n          }\n        });\n        after.push({\n          type: 'group',\n          status: {\n            ...frameGroup,\n            attributes\n          }\n        });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({\n        [instanceId]: newInstance\n      }, {\n        before,\n        after\n      });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n  const toggleInstancesVisible = (frame = currentFrame) => {\n    var _canvas$current8;\n    store.setting.toggleHideAll(frame);\n    (_canvas$current8 = canvas.current) === null || _canvas$current8 === void 0 ? void 0 : _canvas$current8.updateInstancesVisible();\n  };\n  const handleShapesRemove = removeShapes => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n    const changeInstances = {};\n    const {\n      instanceId,\n      groupName\n    } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n        if (child.name === groupName && child.count > 0) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({\n            id,\n            frameIndex,\n            index\n          }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete child.frames[frameIndex].shapes[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete child.frames[frameIndex].shapes[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n    }\n  };\n  const togglePointsVisibility = points => {\n    const list = [];\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: {\n            ...point,\n            visible: !point.visible\n          }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n  const setCategoryPathShape = (categoryKey, shapeType, _updatedShapes) => {\n    const before = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: categoryPathShapes[categoryKey]\n      }\n    }];\n    const after = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: shapeType\n      }\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, {\n        before,\n        after\n      });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n  const selectInstance = (id, isFit = true) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    if (instance) {\n      if (isFit) {\n        var _canvas$current9;\n        (_canvas$current9 = canvas.current) === null || _canvas$current9 === void 0 ? void 0 : _canvas$current9.fitSelected(id);\n      }\n      setSelectedShapeStatus({\n        frameIndex: currentFrame,\n        category: instance.category,\n        instanceId: id,\n        groupName: '',\n        shapeType: undefined,\n        id: undefined\n      });\n      setSelectedOntologyGroup('');\n    }\n  };\n  const selectGroup = (id, groupName, isFit = true, groupData) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: (groupData === null || groupData === void 0 ? void 0 : groupData.category) || selectedShapeStatus.category,\n      groupName,\n      shapeType: (groupData === null || groupData === void 0 ? void 0 : groupData.shapeType) || undefined,\n      id: undefined\n    };\n    if (instance) {\n      var _canvas$current0;\n      const ontologyItem = store.ontology.ontology.find(v => v.class_name === instance.category);\n      const group = ontologyItem === null || ontologyItem === void 0 ? void 0 : ontologyItem.children.find(v => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = (group === null || group === void 0 ? void 0 : group.type) || undefined;\n      if (isDrawMode) {\n        if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.KEYPOINT) {\n          const index = group.categories && group.categories[0] && group.categories[0].range[0] || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach(child => {\n            var _child$frames$current;\n            if (child.name === groupName && ((_child$frames$current = child.frames[currentFrame]) === null || _child$frames$current === void 0 ? void 0 : _child$frames$current.shapes)) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      (_canvas$current0 = canvas.current) === null || _canvas$current0 === void 0 ? void 0 : _canvas$current0.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        var _canvas$current1;\n        (_canvas$current1 = canvas.current) === null || _canvas$current1 === void 0 ? void 0 : _canvas$current1.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n  const switchSelection = () => {\n    var _attributesRef$curren;\n    if ((_attributesRef$curren = attributesRef.current) === null || _attributesRef$curren === void 0 ? void 0 : _attributesRef$curren.modalVisible) {\n      return;\n    }\n    // default switch between instances\n    let searchClassName = '.instance-label';\n    if (selectedShapeInfo === null || selectedShapeInfo === void 0 ? void 0 : selectedShapeInfo.groupName) {\n      searchClassName = '.instance-group-item';\n    }\n    const sidebarContainer = document.getElementsByClassName('side-menus-box')[0];\n    if (!sidebarContainer) {\n      return;\n    }\n    const nodes = Array.from(sidebarContainer.querySelectorAll(searchClassName));\n    const selectedIndex = nodes.findIndex(i => i.classList.contains('selected'));\n    const nextIndex = selectedIndex === nodes.length - 1 ? 0 : selectedIndex + 1;\n    const nextNodes = nodes.slice(nextIndex).filter(i => !i.classList.contains('empty'));\n    const nextNode = nextNodes.length > 0 ? nextNodes[0] : nodes.find(i => !i.classList.contains('empty'));\n    if (nextNode) {\n      ['click'].forEach(eventName => {\n        nextNode.dispatchEvent(new MouseEvent(eventName, {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n          buttons: 1\n        }));\n      });\n    }\n  };\n  const editShapeForm = () => {\n    const {\n      instanceId,\n      groupName,\n      shapeType,\n      id,\n      category\n    } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, id);\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.point_label_config)) {\n        handleFormConfig(currentOntologyGroup.point_label_config, point.attributes || {}, {\n          instanceId,\n          category,\n          groupName\n        }, id, point);\n      }\n    }\n  };\n  const editGroupForm = () => {\n    const selectedInstanceIds = Object.keys(selectedGroups);\n    const selectedSize = selectedInstanceIds.reduce((acc, curr) => acc + selectedGroups[curr].size, 0);\n    if (selectedSize > 1) {\n      // multi selected\n      if (!readonly) {\n        // open modal\n        setMultiAttrModalVisible(true);\n      }\n      return;\n    }\n    const {\n      instanceId,\n      groupName,\n      category\n    } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.label_config)) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, {\n        instanceId,\n        category,\n        groupName\n      });\n    }\n  };\n  const handleFormConfig = (config, values, group, index, point) => {\n    var _attributesRef$curren2;\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    (_attributesRef$curren2 = attributesRef.current) === null || _attributesRef$curren2 === void 0 ? void 0 : _attributesRef$curren2.showModal(title);\n  };\n  const handleHotkey = hotkey => {\n    if (readonly || loading || isReview) {\n      return;\n    }\n    const pointHotkeyItems = store.ontology.pointHotkeyMap[hotkey];\n    if (pointHotkeyItems.length > 0) {\n      const {\n        instanceId,\n        id,\n        category,\n        groupName\n      } = selectedShapeStatus;\n      const instance = cloneDeep(instances[instanceId]);\n      const group = instance === null || instance === void 0 ? void 0 : instance.children.find(g => g.name === groupName);\n      const currentGroup = group === null || group === void 0 ? void 0 : group.frames[currentFrame];\n      if ((group === null || group === void 0 ? void 0 : group.shapeType) === LandmarkEditType.KEYPOINT && currentGroup) {\n        const groupShapes = currentGroup.shapes;\n        const frameGroup = {\n          frameIndex: currentFrame,\n          instanceId,\n          category,\n          groupName\n        };\n        const before = [];\n        const after = [];\n        const indexList = id !== undefined ? [id] : store.shape.selectedShapes;\n        for (let i = 0; i < indexList.length; i += 1) {\n          const index = indexList[i];\n          const point = groupShapes[index];\n          if (point) {\n            var _canvas$current10, _canvas$current11;\n            before.push({\n              type: 'shape',\n              status: {\n                ...frameGroup,\n                index,\n                shape: cloneDeep(point),\n                shapeType: LandmarkEditType.KEYPOINT\n              }\n            });\n            pointHotkeyItems.forEach(({\n              type,\n              attributes\n            }) => {\n              if (type === 'overwrite') {\n                point.attributes = {\n                  ...attributes\n                };\n              } else {\n                point.attributes = {\n                  ...point.attributes,\n                  ...attributes\n                };\n              }\n            });\n            after.push({\n              type: 'shape',\n              status: {\n                ...frameGroup,\n                index,\n                shape: cloneDeep(point),\n                shapeType: LandmarkEditType.KEYPOINT\n              }\n            });\n            (_canvas$current10 = canvas.current) === null || _canvas$current10 === void 0 ? void 0 : _canvas$current10.changePointAttributes(instanceId, groupName, index, point.attributes);\n            (_canvas$current11 = canvas.current) === null || _canvas$current11 === void 0 ? void 0 : _canvas$current11.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n        }\n        if (after.length > 0) {\n          setInstance(instanceId, instance);\n          store.undo.saveStatus(before, after);\n        }\n      }\n    }\n  };\n  const getShapeLabel = (instanceId, category, groupName) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', {\n          values: {\n            frameIndex: currentFrame + 1\n          }\n        })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name}`;\n      }\n    }\n    return title;\n  };\n  const setAttributes = values => {\n    if (editFormObject) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        index,\n        point\n      } = editFormObject;\n      const before = [];\n      const after = [];\n      const frameGroup = {\n        frameIndex: currentFrame,\n        instanceId,\n        category,\n        groupName\n      };\n      if ((index || index === 0) && point) {\n        var _canvas$current12, _canvas$current13;\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = {\n          ...oldPoint,\n          ...point,\n          attributes: values\n        };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: oldPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        after.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: newPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        (_canvas$current12 = canvas.current) === null || _canvas$current12 === void 0 ? void 0 : _canvas$current12.changePointAttributes(instanceId, groupName, index, values);\n        (_canvas$current13 = canvas.current) === null || _canvas$current13 === void 0 ? void 0 : _canvas$current13.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        var _newInstance$children;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : (_newInstance$children = newInstance.children.find(v => v.name === groupName)) === null || _newInstance$children === void 0 ? void 0 : _newInstance$children.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: oldAttrs\n            }\n          });\n          after.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: values\n            }\n          });\n          if (oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach(id => {\n                var _canvas$current14;\n                (_canvas$current14 = canvas.current) === null || _canvas$current14 === void 0 ? void 0 : _canvas$current14.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode, type = 'object') => {\n    var _canvas$current15;\n    (_canvas$current15 = canvas.current) === null || _canvas$current15 === void 0 ? void 0 : _canvas$current15.updatelabelVisible(activeMode, type);\n  };\n  const onSizeChange = () => {\n    var _canvas$current16;\n    (_canvas$current16 = canvas.current) === null || _canvas$current16 === void 0 ? void 0 : _canvas$current16.resizeShapes();\n  };\n  const onFilterChange = () => {\n    var _canvas$current17;\n    (_canvas$current17 = canvas.current) === null || _canvas$current17 === void 0 ? void 0 : _canvas$current17.updateFilters();\n  };\n  const onLabelModeChange = () => {\n    var _canvas$current18, _canvas$current19;\n    if ((_canvas$current18 = canvas.current) === null || _canvas$current18 === void 0 ? void 0 : _canvas$current18.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n    (_canvas$current19 = canvas.current) === null || _canvas$current19 === void 0 ? void 0 : _canvas$current19.resizeShapes();\n  };\n  const setFrameValid = (frame, valid) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n  const setFrameAttributes = ({\n    frame,\n    attrs\n  }) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].attributes = attrs;\n    setFrames(newFramesData);\n  };\n  const getScriptResult = async () => {\n    let resultLink = '';\n    if (store.setting.customCheck.length > 0 || store.setting.scriptCheck) {\n      if (typeof props.jobProxy.reviewFrom === 'string') {\n        resultLink = props.jobProxy.reviewFrom;\n      }\n      if (!isAnnotationReadonly(props.jobProxy.toolMode)) {\n        try {\n          resultLink = await onSave(false);\n        } catch (e) {\n          resultLink = '';\n        }\n      }\n    }\n    const [result] = await Promise.all([validate(store.setting.customCheck, {\n      resultLink,\n      flowData: props.jobProxy.flowData\n    }, store.setting.scriptCheck, props.jobProxy.validateContent), new Promise(resolve => {\n      setTimeout(resolve, 300);\n    })]);\n    if (result) {\n      store.review.setScriptResult(result);\n    }\n  };\n  const loadAdvanceJobData = async e => {\n    var _e$result;\n    let needRender = false;\n    // load instance\n    if ((_e$result = e.result) === null || _e$result === void 0 ? void 0 : _e$result.instances) {\n      var _e$result2;\n      needRender = true;\n      const {\n        newInstances\n      } = loadInstancesFromResult((_e$result2 = e.result) === null || _e$result2 === void 0 ? void 0 : _e$result2.instances);\n      setDefaultInstances(newInstances);\n      setInstances(newInstances);\n      renderInstances = newInstances;\n    }\n\n    // load reviews\n    if (typeof e.reviews === 'object') {\n      var _e$reviews;\n      needRender = true;\n      if (Array.isArray(e.reviews)) {\n        store.review.setInitialData(e.reviews);\n      } else if ((_e$reviews = e.reviews) === null || _e$reviews === void 0 ? void 0 : _e$reviews.updateTime) {\n        delete e.reviews.updateTime;\n        store.review.setInitialData(Object.values(e.reviews));\n      }\n    }\n\n    // render\n    if (needRender) {\n      setFrame(0, renderInstances, CANVASSTATUS.INITIAL);\n    }\n  };\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics\n  }));\n  return /*#__PURE__*/React.createElement(Observer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 1799,\n      columnNumber: 5\n    }\n  }, () => {\n    var _frames$currentFrame, _frames$currentFrame2;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"landmark-annotation-app\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1801,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(AutoSaver, {\n      ref: saverRef,\n      leaveCheck: true,\n      data: {\n        instance: instances,\n        reviews: store.review.qaWarnings\n      },\n      save: handleSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1802,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(Toolbar, {\n      readonly: readonly || loading || isReview,\n      isReview: isReview,\n      isPreview: readonly,\n      initialDataLength: Object.keys(initialInstances).length,\n      onAttributesModeChanges: onAttributesModeChanges,\n      onSizeChange: onSizeChange,\n      onFilterChange: onFilterChange,\n      onLabelModeChange: onLabelModeChange,\n      onSave: handleSave,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1808,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"container\",\n      style: {\n        height: `calc(100% - ${frames.length > 1 && currentFrame >= 0 ? `${frameControlHeight + 35}px` : '35px'})`,\n        transition: 'height 0.15s'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1823,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(TabMenu, {\n      tabs: [{\n        title: formatMessage('MENU_INSTANCE'),\n        key: 'instance',\n        count: 0,\n        content: /*#__PURE__*/React.createElement(SideMenus, {\n          canvas: canvas.current,\n          readonly: readonly || loading || isReview || !isDrawMode,\n          loading: loading,\n          instances: instanceList,\n          currentFrame: currentFrame,\n          frameCount: frames.length,\n          instancesFrames: instancesFrames,\n          selectedInstance: selectedInstance,\n          selectedOntologyGroup: selectedOntologyGroup,\n          instancesReviewsMap: instancesReviewsMap,\n          instanceVisibile: store.setting.getVisibleStatusByFrame(currentFrame),\n          inexistentGraphicsCardVisibility: store.setting.inexistentGraphicsCardVisibility,\n          updateInexistentGraphicsCardVisibility: store.setting.updateInexistentGraphicsCardVisibility,\n          addInstance: addInstance,\n          selectInstance: selectInstance,\n          selectGroup: selectGroup,\n          addInstanceInFrame: addInstanceInFrame,\n          removeInstanceFrames: removeInstanceFrames,\n          toggleInstancesVisible: () => toggleInstancesVisible(currentFrame),\n          selectedGroups: selectedGroups,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1837,\n            columnNumber: 21\n          }\n        })\n      }, {\n        title: formatMessage('MENU_WARNING'),\n        key: 'validator',\n        count: store.review.warnings.length,\n        content: /*#__PURE__*/React.createElement(Validator, {\n          ref: validatorRef,\n          canvas: canvas.current,\n          instances: instances,\n          jobProxy: props.jobProxy,\n          getScriptResult: getScriptResult,\n          warnings: store.review.warnings || [],\n          setFrame: setFrame,\n          setSelectedShape: setSelectedShape,\n          selectGroup: selectGroup,\n          getInstance: getInstance,\n          saveResult: () => onSave(false),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1866,\n            columnNumber: 21\n          }\n        })\n      }],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1830,\n        columnNumber: 13\n      }\n    }), selectedInstance && ontologyGroup && !isReview && /*#__PURE__*/React.createElement(Board, {\n      categories: categories,\n      categoryPathShapes: displayedCategoryPathShapes,\n      points: shapes,\n      ontologyGroup: ontologyGroup,\n      selectedShapeStatus: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      drawMode: isDrawMode,\n      setSelectedShape: id => {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(id, {\n          instanceId,\n          category,\n          groupName\n        });\n      },\n      frameControlHeight: frameControlHeight,\n      readonly: loading,\n      instanceReviewsMap: store.review.frameReviewsMap[currentFrame],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1884,\n        columnNumber: 15\n      }\n    }), /*#__PURE__*/React.createElement(CanvasContainer, {\n      ref: canvas,\n      readonly: readonly,\n      loading: loading,\n      isReview: isReview,\n      currentFrame: currentFrame,\n      image: (_frames$currentFrame = frames[currentFrame]) === null || _frames$currentFrame === void 0 ? void 0 : _frames$currentFrame.url,\n      categories: categories,\n      selectedInstance: selectedInstance,\n      selectedGroupName: selectedOntologyGroup,\n      ontologyGroup: ontologyGroup,\n      annotatedPointOrShapeCount: annotatedPointOrShapeCount,\n      updatedCategories: updatedCategories,\n      defaultInstances: defaultInstances,\n      selectedShapeStatus: selectedShapeStatus,\n      selectedShapeInfo: selectedShapeInfo,\n      changeLoading: setLoading,\n      selectGroup: selectGroup,\n      setSelectedShape: setSelectedShape,\n      handleShapesChange: handleShapesChange,\n      onCategoriesUpdated: onCategoriesUpdated,\n      handleShapesRemove: handleShapesRemove,\n      togglePointsVisibility: togglePointsVisibility,\n      setNextEmptyShape: setNextEmptyShape,\n      editShapeForm: editShapeForm,\n      editGroupForm: editGroupForm,\n      handleHotkey: handleHotkey,\n      onSave: handleSave,\n      getInstance: getInstance,\n      categoryPathShapes: displayedCategoryPathShapes,\n      setCategoryPathShape: setCategoryPathShape,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      toggleInstancesVisible: toggleInstancesVisible,\n      switchSelection: switchSelection,\n      addInstance: addInstance,\n      setSelectedGroups: setSelectedGroups,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1902,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"arributes-panel\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1942,\n        columnNumber: 13\n      }\n    }, selectedShapeStatus.groupName && /*#__PURE__*/React.createElement(Information, {\n      pointCategory: (categories[selectedCategoryIndex] || {}).name,\n      point: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1944,\n        columnNumber: 17\n      }\n    }), ((_frames$currentFrame2 = frames[currentFrame]) === null || _frames$currentFrame2 === void 0 ? void 0 : _frames$currentFrame2.url) && /*#__PURE__*/React.createElement(FrameAttributes, {\n      currentFrame: currentFrame,\n      currentFrameValid: frames[currentFrame].valid,\n      setFrameValid: setFrameValid,\n      currentFrameAttrs: frames[currentFrame].attributes,\n      setFrameAttributes: setFrameAttributes,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1952,\n        columnNumber: 17\n      }\n    })), /*#__PURE__*/React.createElement(Attributes, {\n      ref: attributesRef,\n      readonly: readonly || isReview || !isDrawMode,\n      config: formConfig,\n      values: formValues,\n      onValuesChange: setAttributes,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1961,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(MultiAttributes, {\n      modalVisible: multiAttrModalVisible,\n      currentFrame: currentFrame,\n      selectedGroups: selectedGroups,\n      getInstance: getInstance,\n      onCancel: () => {\n        setMultiAttrModalVisible(false);\n      },\n      onSubmit: (updatedInstances, {\n        before,\n        after\n      }) => {\n        after.forEach(({\n          status\n        }) => {\n          const {\n            instanceId,\n            category,\n            groupName,\n            attributes\n          } = status;\n          const group = getGroup(instanceId, groupName, currentFrame);\n          if (group === null || group === void 0 ? void 0 : group.shapes) {\n            Object.keys(group.shapes).forEach(id => {\n              var _canvas$current20, _updatedInstances$ins;\n              (_canvas$current20 = canvas.current) === null || _canvas$current20 === void 0 ? void 0 : _canvas$current20.updateAttributeLabel(instanceId, category, groupName, id, attributes, (_updatedInstances$ins = updatedInstances[instanceId]) === null || _updatedInstances$ins === void 0 ? void 0 : _updatedInstances$ins.number);\n            });\n          }\n        });\n        store.undo.saveStatus(before, after);\n        setInstances({\n          ...instances,\n          ...updatedInstances\n        });\n        setMultiAttrModalVisible(false);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1968,\n        columnNumber: 13\n      }\n    })), frames.length > 1 && currentFrame >= 0 && /*#__PURE__*/React.createElement(FrameControl, {\n      frames: frames,\n      frameLoading: loading,\n      currentFrame: currentFrame,\n      categoryInstancesMap: displayedCategoryInstancesMap,\n      instancesReviewsMap: instancesReviewsMap,\n      instances: displayedInstances,\n      selectedInstance: selectedInstance,\n      selectedInstanceGroup: selectedOntologyGroup,\n      selectGroup: selectGroup,\n      setFrame: setFrame,\n      onHeightChange: setFrameControlHeight,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1996,\n        columnNumber: 13\n      }\n    }), store.review.selectedReview && /*#__PURE__*/React.createElement(QualityControl, {\n      review: store.review.selectedReview,\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      selectedShapeStatus: selectedShapeStatus,\n      getShapeLabel: getShapeLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2011,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(Missing, {\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2019,\n        columnNumber: 11\n      }\n    }));\n  });\n});\nexport default LandmarkAnnotation;","map":{"version":3,"names":["React","useState","useRef","useMemo","useEffect","forwardRef","useImperativeHandle","Observer","useLocalObservable","useObserver","toJS","cloneDeep","notification","v4","uuid","TabMenu","AutoSaver","Toolbar","SideMenus","Board","CanvasContainer","FrameControl","Validator","Attributes","QualityControl","Information","FrameAttributes","formatMessage","i18n","LandmarkEditType","DELETETYPE","ReviewResult","fetchResultByUrl","loader","isPreview","isAnnotationReadonly","initInstances","loadInstancesFromResult","getFrameShapes","parseFramesByPaylod","getInstanceFrames","validate","rootStore","useAsyncState","advanceJob","AdvanceMessage","cache","MultiAttributes","Missing","config","top","CANVASSTATUS","renderInstances","LandmarkAnnotation","props","ref","store","readonly","setReadOnly","frames","setFrames","currentFrame","setCurrentFrame","frameControlHeight","setFrameControlHeight","selectedOntologyGroup","setSelectedOntologyGroup","categoryPathShapes","setCategoryPathShapes","updatedCategories","setUpdatedCategories","defaultInstances","setDefaultInstances","instances","setInstances","imagePreloader","selectedShapeStatus","setSelectedShapeStatus","frameIndex","category","instanceId","groupName","shapeType","undefined","id","selectedGroups","setSelectedGroups","loading","setLoading","formConfig","setFormConfig","formValues","setFormValues","imageSize","setImageSize","width","height","editFormObject","setEditFormObject","isReview","setIsReview","initialInstances","setInitialInstances","initialCategoryInstancesMap","setInitialCategoryInstancesMap","initialCategoryPathShapes","setInitialCategoryPathShapes","multiAttrModalVisible","setMultiAttrModalVisible","attributesRef","saverRef","validatorRef","canvas","isDrawMode","review","drawMode","displayedInstances","instanceIds","Object","keys","instanceList","values","filter","v","selectedInstance","categoryInstancesMap","newCategoryInstancesMap","forEach","number","displayedCategoryInstancesMap","displayedCategoryPathShapes","selectedOntology","ontologyItem","ontology","find","class_name","ontologyGroup","groupItem","children","group","name","categories","selectedCategoryIndex","KEYPOINT","findIndex","c","range","length","instancesFrames","items","instance","shapes","_selectedInstance$chi","g","selectedShapeInfo","info","type","displayColor","display_color","_categories$selectedC","pointCategory","isKeyPoint","includes","annotatedPointOrShapeCount","entries","totalPointCount","count","instancesReviewsMap","map","reviews","_instances$instanceId","shapeIds","result","approveCount","REJECT","SUSPEND","APPROVE","len","ontologyCount","ontologyMap","jobProxy","onLoad","setSelectedMissingReview","getInstance","getGroup","_instance$children$fi","getShape","setInstance","setShape","shape","_group","currentGroup","push","oldShape","RECTANGLE","notEmpty","groupInfo","getGroupData","label_config","attributes","handleFormConfig","updateStatus","curr","prev","newUpdatedShapes","newUpdatedCategories","updatedHandles","newCategoryPathShapes","m","item","index","status","frameGroup","keyObj","updateShapes","instanceIndex","selectedIndex","newInstance","selectGroup","newGroup","setInitialData","n","point","visible","updateIndex","p","updateShape","position","rectangle","x","y","updateRectangle","rect","split","newCategories","_canvas$current","attrLayer","current","getAttrLabelByKey","_canvas$current2","updateAttributeLabel","setUpdatedShapes","handle","setUpdatedHandles","handleUndo","undo","undoDisabled","before","after","success","message","handleRedo","redoDisabled","redo","handleChangeDrawMode","mode","isEditable","_canvas$current3","clearHits","setNextEmptyShape","setSelectedShape","setDrawMode","loadInitialData","data","initial_result","initialResult","e","console","log","addInstance","ontologyName","_rootStore$ontology$o","oName","ontologyInstances","canAdd","sameOntologyInstances","reverse","handleInstanceChange","addInstanceInFrame","groupIdx","copyFrame","i","Number","frame","copyFrameIdx","removeInstanceFrames","delShapes","update","updateInstance","CURRENT","FOLLOW","ALL","diffFrame","Array","from","_","newInstances","ids","oldInstance","isRemove","child","saveStatus","_result","_saverRef$current","toolMode","setCurrentProject","projectId","setLocale","locale","init","initialData","initInstancesData","loadResult","error","duration","framesData","image","imageData","images","url","setting","initAllVisibleStatusList","isArray","auditId","setAuditId","points","initialCategoryPathShapesData","initialInstancesData","setFrame","setTempSaved","renderComplete","on","UPDATE_RESULT","loadAdvanceJobData","currentInstances","_canvas$current4","_canvas$current5","_imagePreloader$curre","INITIAL","cancelUnfinishMissingReview","currentInstanceList","cleanLayer","setMultiShapesUnselected","preload","currentShapeStatus","updatedCategoriesData","changeFrame","setReview","newIsReview","displayInstances","onSave","submit","_saverRef$current2","_canvas$current6","_canvas$current6$imag","_canvas$current7","_canvas$current7$imag","loadError","Error","disableLeaveCheck","submitCheck","passed","triggerValidation","checkMissingPoints","check_missing_points","ontologyInfo","getOntologyInfo","groupFrames","groupShapes","newShapes","key","pointIndex","parseInt","valid","errMsg","display_name","annotated","total","statData","getInstanceStatistics","statistics","saveResultStat","handles","getHandles","saveResult","auditFileId","imageCanvas","annotatedFrameCount","getStatistics","statShapes","objects","approved","rejected","suspended","missed","r","instancesList","j","itemFrames","k","frameReviews","frameShapes","l","shapeId","indexOf","elements","className","Set","summary","frameCount","annotatedFrames","add","distinctCount","shapeCount","s","size","loadReviews","saveReviews","_saverRef$current3","hasSuspend","label","join","missingReviews","handleSave","isEnabled","hasCustomError","blockSubmitErrors","handleSync","groupData","newSelectedShapeStatus","shapeStatus","emptyShapeFound","categoryScannedCount","categoryIndex","onCategoriesUpdated","handleShapesChange","groupsAttributes","preferences","autoOpenAttributesModal","toggleInstancesVisible","_canvas$current8","toggleHideAll","updateInstancesVisible","handleShapesRemove","removeShapes","changeInstances","togglePointsVisibility","list","setCategoryPathShape","categoryKey","_updatedShapes","selectInstance","isFit","_canvas$current9","fitSelected","_canvas$current0","_child$frames$current","rectangles","updateGroupBox","_canvas$current1","switchSelection","_attributesRef$curren","modalVisible","searchClassName","sidebarContainer","document","getElementsByClassName","nodes","querySelectorAll","classList","contains","nextIndex","nextNodes","slice","nextNode","eventName","dispatchEvent","MouseEvent","view","window","bubbles","cancelable","buttons","editShapeForm","currentOntologyGroup","point_label_config","editGroupForm","selectedInstanceIds","selectedSize","reduce","acc","_attributesRef$curren2","title","getShapeLabel","showModal","handleHotkey","hotkey","pointHotkeyItems","pointHotkeyMap","indexList","selectedShapes","_canvas$current10","_canvas$current11","changePointAttributes","class_display_name","setAttributes","_canvas$current12","_canvas$current13","oldPoint","newPoint","_newInstance$children","oldGroup","ontologyChild","oldAttrs","_canvas$current14","onAttributesModeChanges","activeMode","_canvas$current15","updatelabelVisible","onSizeChange","_canvas$current16","resizeShapes","onFilterChange","_canvas$current17","updateFilters","onLabelModeChange","_canvas$current18","_canvas$current19","labelLayer","labelMode","setFrameValid","newFramesData","setFrameAttributes","attrs","getScriptResult","resultLink","customCheck","scriptCheck","reviewFrom","Promise","all","flowData","validateContent","resolve","setTimeout","setScriptResult","_e$result","needRender","_e$result2","_e$reviews","updateTime","createElement","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","_frames$currentFrame","_frames$currentFrame2","leaveCheck","qaWarnings","save","initialDataLength","style","transition","tabs","content","instanceVisibile","getVisibleStatusByFrame","inexistentGraphicsCardVisibility","updateInexistentGraphicsCardVisibility","warnings","instanceReviewsMap","frameReviewsMap","selectedGroupName","changeLoading","currentFrameValid","currentFrameAttrs","onValuesChange","onCancel","onSubmit","updatedInstances","_canvas$current20","_updatedInstances$ins","frameLoading","selectedInstanceGroup","onHeightChange","selectedReview"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx"],"sourcesContent":["import React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport CanvasContainer, { Canvas } from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes, { AttributesHandle } from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { Status } from './store/UndoStore';\nimport { AttributesMode } from './store/SettingsStore';\nimport { IWarning } from '../common/tabs-menu/Validator';\nimport {\n  LandmarkEditType, InstanceListItem, CategoryPathShape, Point, PointListItem, PointStatus, FrameGroup,\n  ShapeInfo, PointInfo, Group, InstanceAct, Rectangle, GroupInfo, FormConfig, ObjectInfo, UpdatedShape,\n  Points, CurrentShapes, CategoryInstancesMap, KeypointCategoryProps, DELETETYPE, Frame, ReviewResult,\n  Payload, Statistic, Image, HandleStatus,\n  GroupStatus\n} from './types';\nimport { fetchResultByUrl } from './request';\nimport loader, { ImagePreloader } from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport {\n  initInstances,\n  loadInstancesFromResult,\n  getFrameShapes,\n  parseFramesByPaylod,\n  getInstanceFrames,\n  validate\n} from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nimport advanceJob, { AdvanceMessage } from '../../libs/advanceJob';\nimport cache from './utils-storage';\nimport MultiAttributes from './components/MultiAttributes';\nimport Missing from './components/QualityControl/Missing';\n\nnotification.config({ top: 60 });\n\nenum CANVASSTATUS {\n  INITIAL = 'initial',\n  LANDMARK = 'landmark',\n}\n\nexport interface GroupReviewsMap {\n  [groupName: string]: {\n    approveCount: number;\n    result?: ReviewResult;\n  }\n}\n\nexport interface InstancesReviewsMap {\n  [instanceId: string]: {\n    [frameIndex: number]: {\n      approveCount: number;\n      result?: ReviewResult;\n      children: GroupReviewsMap\n    }\n  }\n}\n\nlet renderInstances: {[id: string]: InstanceAct} = {};\n\nconst LandmarkAnnotation = forwardRef((props: Payload, ref) => {\n  const store = useLocalObservable(() => rootStore);\n\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState<Image[]>([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState<number>(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState<number>(78);\n\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState<string>('');\n\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState<{ [categoryKey: string]: CategoryPathShape }>({});\n\n  const [updatedCategories, setUpdatedCategories] = useAsyncState<KeypointCategoryProps[]>([]);\n\n  const [defaultInstances, setDefaultInstances] = useAsyncState<{[id: string]: InstanceAct}>({});\n\n  const [instances, setInstances] = useAsyncState<{[id: string]: InstanceAct}>({});\n\n  /**\n   * image preloader\n   */\n  const imagePreloader = useRef<ImagePreloader>();\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState<ShapeInfo>({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n\n  const [selectedGroups, setSelectedGroups] = useState<Record<string, Set<string>>>({});\n\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const [formConfig, setFormConfig] = useState<FormConfig | null>(null);\n\n  const [formValues, setFormValues] = useState<{[attr: string]: any;} | null>(null);\n\n  const [imageSize, setImageSize] = useState<{width: number, height: number} | undefined>({ width: 0, height: 0 });\n\n  const [editFormObject, setEditFormObject] = useState<ObjectInfo | null>(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState<boolean>(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState<{[id: string]: InstanceAct}>({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState<CategoryInstancesMap>({});\n\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState<{[categoryKey: string]: CategoryPathShape}>({});\n\n  const [multiAttrModalVisible, setMultiAttrModalVisible] = useState(false);\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef<AttributesHandle>(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef<AutoSaver>(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef<Validator>(null);\n\n  const canvas = useRef<Canvas>(null);\n\n  const isDrawMode = useObserver(() => (\n    store.review.drawMode\n  ));\n\n  const displayedInstances = useMemo(() => (\n    isReview ? initialInstances : instances\n  ), [isReview, initialInstances, instances]);\n\n  const instanceIds = useMemo(() => (\n    Object.keys(displayedInstances)\n  ), [displayedInstances]);\n\n  const instanceList = useMemo(() => (\n    Object.values(displayedInstances).filter((v) => !!v)\n  ), [displayedInstances]);\n\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus?.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap: CategoryInstancesMap = {};\n    instanceList.forEach(({ category, id, number }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n\n  const displayedCategoryInstancesMap = useMemo(() => (\n    isReview ? initialCategoryInstancesMap : categoryInstancesMap\n  ), [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n\n  const displayedCategoryPathShapes = useMemo(() => (\n    isReview ? initialCategoryPathShapes : categoryPathShapes\n  ), [isReview, initialCategoryPathShapes, categoryPathShapes]);\n\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    return ontologyItem;\n  });\n\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find((group) => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n\n  const categories = useMemo(() => (\n    ontologyGroup?.categories || []\n  ), [ontologyGroup]);\n\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus?.id as number;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ?\n      categories.findIndex((c) => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) :\n      -1;\n  }, [selectedShapeStatus, categories]);\n\n  const instancesFrames = useMemo(() => {\n    const items: { [id: string]: {\n      [frameIndex: number]: boolean;\n    } } = {};\n    instanceList.forEach((instance) => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n\n  const shapes = useMemo(() => {\n    const group = selectedInstance?.children.find((g) => g.name === selectedOntologyGroup)?.frames[currentFrame];\n    return (group && group.shapes) || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n\n  const selectedShapeInfo = useMemo(() => {\n    let info: PointInfo | GroupInfo | null = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: ontologyGroup?.type || undefined,\n        displayColor: selectedOntology?.display_color || ''\n      };\n      if (ontologyGroup?.type === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        info = {\n          ...info,\n          pointCategory: categories[selectedCategoryIndex]?.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id as number)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n\n  const annotatedPointOrShapeCount = useMemo(() => (\n    Object.entries(shapes).filter(([, v]) => v !== undefined).length\n  ), [shapes]);\n\n  const totalPointCount = useMemo(() => (\n    ontologyGroup?.count || 0\n  ), [ontologyGroup]);\n\n  const instancesReviewsMap = useObserver(() => {\n    const map: InstancesReviewsMap = {};\n    store.review.reviews.forEach((review) => {\n      const { frameIndex, instanceId, groupName, shapeIds, result } = review;\n      const category = instances[instanceId]?.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0,\n        };\n      }\n\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n\n  useEffect(() => {\n    // set props\n    store.jobProxy = props.jobProxy;\n    onLoad();\n  }, []);\n\n  useEffect(() => {\n    if (selectedShapeInfo?.instanceId) {\n      store.review.setSelectedMissingReview();\n    }\n  }, [selectedShapeInfo]);\n\n  const getInstance = (instanceId: string) => displayedInstances[instanceId];\n\n  const getGroup = (instanceId: string, groupName: string, frameIndex: number = currentFrame) => {\n    const instance = getInstance(instanceId);\n    const group = instance?.children.find((g) => g.name === groupName)?.frames[frameIndex];\n    return group;\n  };\n\n  const getShape = (instanceId: string, groupName: string, id: string | number, frameIndex: number = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? (group.shapes as Points)[id] : (group.shapes as CurrentShapes)[id]);\n  };\n\n  const setInstance = (id: string, instance?: InstanceAct) => {\n    renderInstances = {\n      ...instances,\n      [id]: instance!\n    };\n    if (instance === undefined) {\n      delete renderInstances[id];\n    }\n    setInstances(renderInstances);\n  };\n\n  const setShape = (frameIndex: number, instanceId: string, groupName: string, id: number | string, shapeType: LandmarkEditType, shape?: Point | Rectangle) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      let group = instance.children.find((g) => g.name === groupName);\n      let currentGroup = group?.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape: Point | Rectangle | undefined;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = ((currentGroup as Frame).shapes as Points)[id as number];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = ((currentGroup as Frame).shapes as CurrentShapes)[id];\n      }\n\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete ((currentGroup as Frame).shapes as Points)[id as number];\n        } else {\n          delete ((currentGroup as Frame).shapes as CurrentShapes)[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count + 1 : 1;\n        }\n        (currentGroup as Frame).shapes = {\n          ...(currentGroup as Frame).shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if (groupInfo?.label_config && (currentGroup as Frame).count === groupInfo.count && !(currentGroup as Frame).attributes) {\n        handleFormConfig(groupInfo.label_config, {}, { instanceId, category: instance.category, groupName });\n      }\n    }\n  };\n\n  const updateStatus = async (curr: Status[], prev: Status[]) => {\n    let newUpdatedShapes: UpdatedShape[] = [];\n    let newUpdatedCategories: KeypointCategoryProps[] = [];\n    let updatedHandles: HandleStatus[] = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const { frameIndex, instanceId, groupName, category, index, id, shapeType } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        let keyObj: { id: string } | { index: number } | undefined;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = { index };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = { id };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({ ...frameGroup, ...keyObj, shapeType });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          const instanceIndex = instanceIds.findIndex((v) => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, frameIndex, groupName, attributes } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance?.children.find((v) => v.name === groupName);\n          if (newInstance && newGroup) {\n            (newGroup.frames[frameIndex] as Frame).attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const { instanceId, groupName, category, index, id, shapeType, shape, frameIndex } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape as Point;\n            const { pointCategory, isKeyPoint, visible, attributes } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex((p) => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape: Point = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: { ...point.position },\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, index, shape: updateShape, shapeType });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape as Rectangle;\n            const { displayColor, visible, x, y, width, height } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle: Rectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible,\n            };\n            const updateIndex = newUpdatedShapes.findIndex((rect) => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, id, shape: updateRectangle, shapeType });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const { frameIndex, pointCategory, shape } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3],\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const { updateShapes, updatedCategories: newCategories } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          newUpdatedCategories = [\n            ...newUpdatedCategories,\n            ...newCategories\n          ];\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, groupName, attributes, frameIndex } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach((id) => {\n            const attrLayer = canvas.current?.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              canvas.current?.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes, newInstance.number);\n            }\n          });\n          (newGroup.frames[frameIndex] as Frame).attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({ message: 'Undo successfully.' });\n      }\n    }\n  };\n\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({ message: 'Redo successfully.' });\n      }\n    }\n  };\n\n  const handleChangeDrawMode = (mode: boolean) => {\n    if (store.review.isEditable) {\n      canvas.current?.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const { instanceId, category, groupName } = selectedShapeStatus;\n        setSelectedShape(undefined, { instanceId, category, groupName });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n\n  const loadInitialData = async () => {\n    let data;\n    const { initial_result: initialResult } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n\n  const addInstance = async (ontologyName?: string) => {\n    const oName = ontologyName || selectedInstance?.category || rootStore.ontology.ontology[0]?.class_name;\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === oName);\n    if (ontologyItem) {\n      const ontologyInstances = instanceList.filter((instance) => instance.category === ontologyItem.class_name);\n      const canAdd = ontologyInstances.filter((instance) => !instance.notEmpty).length <= 0;\n      if (!canAdd) {\n        return;\n      }\n\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter((v) => v.category === oName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n\n      const children = ontologyItem.children.map((v) => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({ [id]: instance });\n      await handleInstanceChange({ [id]: instance });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, { category: ontologyItem.class_name, shapeType: ontologyItem.children[0].type });\n      }\n    }\n  };\n\n  const addInstanceInFrame = async (instanceId: string, groupName?: string) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex((group) => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame: Frame | undefined;\n          Object.keys(newInstance.children[groupIdx].frames).forEach((i) => {\n            const index = Number(i);\n            const frame = { ...newInstance.children[groupIdx].frames[index] };\n            frame.shapes = { ...frame.shapes };\n            if (frame?.count && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += (copyFrame.count || 0);\n            newInstance.notEmpty += (copyFrame.count || 0);\n          }\n        }\n      } else {\n        let copyFrameIdx: number | undefined;\n        Object.keys(instancesFrames[instanceId]).forEach((i) => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach((group) => {\n            const copyFrame = { ...group.frames[copyFrameIdx as number] };\n            copyFrame.shapes = { ...copyFrame.shapes };\n            if (copyFrame) {\n              group.count += (copyFrame.count || 0);\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const { updateShapes, updatedCategories: newUpdatedCategories } = getFrameShapes([newInstance], currentFrame);\n      await handleInstanceChange({ [instanceId]: newInstance });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n\n  const removeInstanceFrames = (type: DELETETYPE, instance: InstanceAct, name?: string) => {\n    if (instance) {\n      let delShapes: UpdatedShape[] = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance: InstanceAct, frameIndex: number) => {\n        updateInstance.children.forEach((group) => {\n          if ((name && name === group.name) || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= (group.frames[frameIndex] as Frame).count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({ length: frames.length - diffFrame }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const { updateShapes } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [\n            ...delShapes,\n            ...updateShapes\n          ];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter((v) => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({ [newInstance.id]: newInstance });\n    }\n  };\n\n  const handleInstanceChange = async (\n    newInstances: {[id: string] : InstanceAct},\n    status?: {before: Status[], after: Status[]}\n  ) => {\n    const ids = Object.keys(newInstances);\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async (id) => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach((child) => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({ type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance,\n          }\n        });\n        after.push({ type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n\n  const onLoad = async () => {\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // setup storage\n    cache.setCurrentProject(props.jobProxy.projectId);\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n\n    let result;\n    let initialData: any;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({ message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({ frames: props.image, imageData: result?.images as Image[] });\n    // preload image\n    imagePreloader.current = loader(framesData.map((v) => v.url));\n    // set frame images\n    setFrames(framesData);\n    store.setting.initAllVisibleStatusList(framesData.length);\n\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes: { [categoryKey: string]: CategoryPathShape } = {};\n        result.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height,\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData: { [key: string]: CategoryPathShape } = {};\n        initialData.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const { newInstances, categoryInstancesMap: newCategoryInstancesMap } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const { newInstances } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      renderInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, renderInstances);\n    saverRef.current?.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n\n    // advancejob listener\n    advanceJob.on(AdvanceMessage.UPDATE_RESULT, loadAdvanceJobData);\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex: number, currentInstances: {[id: string]: InstanceAct} | undefined = instances, type?: CANVASSTATUS) => {\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    store.review.cancelUnfinishMissingReview();\n    const currentInstanceList = Object.values(currentInstances);\n    canvas.current?.cleanLayer();\n    canvas.current?.setMultiShapesUnselected();\n    imagePreloader.current?.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex,\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const { id, category, children: [{ name }] } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group?.type,\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const { updateShapes, updatedCategories: updatedCategoriesData } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n\n  const onSave = async (submit = true) => {\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({ message: loadError });\n      throw new Error(loadError);\n    }\n\n    saverRef.current?.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances: InstanceListItem[] = instanceList.filter((v) => v && v.notEmpty).map((instance) => {\n      const { id, category, number, displayColor, children } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map((group) => {\n          const { frames: groupFrames } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter((v) => !!v && v.count > 0).map((frameGroup) => {\n              if (frameGroup) {\n                const { frameIndex, count, shapes: groupShapes } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes: PointListItem[] | Rectangle[] = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach((key) => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point: PointListItem | undefined = groupShapes && (groupShapes as Points)[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        (newShapes as PointListItem[]).push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle: Rectangle | undefined = groupShapes && (groupShapes as CurrentShapes)[key];\n                      if (rectangle) (newShapes as Rectangle[]).push(rectangle);\n                    }\n                  });\n                }\n                if (\n                  checkMissingPoints &&\n                  frames[frameIndex].valid !== false &&\n                  groupInfo &&\n                  newShapes.length < groupInfo.count\n                ) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: ontologyInfo?.display_name,\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({ message: errMsg });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditFileId,\n      width: canvas.current?.imageCanvas?.width || imageSize?.width,\n      height: canvas.current?.imageCanvas?.height || imageSize?.height,\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map((pointCategory) => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory],\n      })),\n      images: frames,\n      statistics,\n      annotatedFrameCount: statData.annotatedFrameCount,\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes: {\n      [shape: string]: { rejected: number; approved: number, suspended: number, missed: number, total: number };\n    } = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0,\n    };\n    const reviews = store.review.reviews.filter((r) => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter((r) => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find((r) => r.shapeIds.indexOf(shapeId) >= 0);\n            if (review?.result === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if (review?.result === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return { objects, shapes: statShapes };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const { ontology } = store.ontology;\n    const data: Statistic = {\n      elements: [],\n      categories: ontology.map(({ class_name: className }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set(),\n    };\n\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, category, children } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0,\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(\n              ...frameShapes.map((s) => ({\n                instance: id,\n                shape,\n                frame: frame.frameIndex + 1,\n                category,\n                id: s.id || s.index,\n              }))\n            );\n          }\n        }\n      }\n    }\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({ category, shape, count, distinctCount }) => ({\n        category,\n        shape,\n        count,\n        distinctCount,\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size,\n    };\n  };\n\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n\n  const saveReviews = (type = 'submit') => {\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find((review) => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    saverRef.current?.disableLeaveCheck();\n    const reviews = toJS(store.review.reviews).map((r) => {\n      const { instanceId: id, groupName, shapeIds } = r;\n      const instance = getInstance(id);\n      const ontologyItem = store.ontology.getOntologyInfo(instance?.category);\n      const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find((group) => group.name === groupName);\n      const label = ontologyItem && instance ?\n        `${ontologyItem.display_name || ''}${instance.number}${groupItem ? `-${groupItem.display_name}` : ''}${shapeIds && shapeIds.length && (typeof shapeIds[0] === 'number') ? `[${shapeIds.join(',')}]` : ''}` :\n        'Deleted';\n      return { ...r, label };\n    });\n    const missingReviews = toJS(store.review.missingReviews).map((r) => ({\n      ...r,\n      label: 'Missed',\n    }));\n    return props.jobProxy.saveReviews([...reviews, ...missingReviews], type === 'submit');\n  };\n\n  const handleSave = async () => {\n    const { toolMode } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n\n    try {\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({ message: formatMessage('SAVE_SUCCESS') });\n    } catch (e) {\n      notification.error({ message: formatMessage('SAVE_FAIL') });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const { hasCustomError, blockSubmitErrors } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n\n  const setSelectedShape = (id?: number | string, groupData?: Group) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const { instanceId, category, groupName, shapeType } = groupData;\n      if (instanceId !== selectedInstance?.id) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || ontologyGroup?.type || undefined,\n        groupName,\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n\n  const setNextEmptyShape = (shapeStatus: ShapeInfo = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let emptyShapeFound = false;\n      let { id } = shapeStatus;\n      const { instanceId, groupName, shapeType } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const { range = [] } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            (id as number) += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id!) === undefined) {\n            emptyShapeFound = true;\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n        emptyShapeFound = true;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n      return emptyShapeFound;\n    }\n    return false;\n  };\n\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n\n  const handleShapesChange = (\n    newShapes: UpdatedShape[],\n    groupsAttributes?: { instanceId: string, category: string, name: string, attributes: any }[],\n    status?: {before: Status[], after: Status[]}\n  ) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    const { instanceId, groupName } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData(newInstance?.category || '', groupName);\n    newInstance?.children.forEach((child) => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {},\n          };\n        };\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const { id, frameIndex, index, shape } = newShapes[i];\n          let oldShape;\n\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = (child.frames[frameIndex].shapes as Points)[index];\n            (child.frames[frameIndex].shapes as Points)[index] = {\n              ...oldShape,\n              ...shape as Point\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            (child.frames[frameIndex].shapes as CurrentShapes)[id] = {\n              ...oldShape,\n              ...shape as Rectangle\n            };\n          }\n\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        };\n        if (store.setting.preferences.autoOpenAttributesModal && groupInfo?.label_config && currentGroup.count === groupInfo?.count && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, { instanceId, category: newInstance.category, groupName });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({ instanceId: id, name, category, attributes }) => {\n        const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId: id, category, groupName: name };\n        before.push({ type: 'group', status: { ...frameGroup } });\n        after.push({ type: 'group', status: { ...frameGroup, attributes } });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({ [instanceId]: newInstance }, { before, after });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n\n  const toggleInstancesVisible = (frame: number = currentFrame) => {\n    store.setting.toggleHideAll(frame);\n    canvas.current?.updateInstancesVisible();\n  };\n\n  const handleShapesRemove = (removeShapes: UpdatedShape[]) => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n\n    const changeInstances: { [id: string]: InstanceAct } = {};\n    const { instanceId, groupName } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance?.children.forEach((child) => {\n        if (child.name === groupName && child.count > 0) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({ id, frameIndex, index }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete (child.frames[frameIndex].shapes as Points)[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({ [instanceId]: newInstance });\n    }\n  };\n\n  const togglePointsVisibility = (points: PointStatus[]) => {\n    const list: UpdatedShape[] = [];\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: { ...point, visible: !point.visible }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n\n  const setCategoryPathShape = (categoryKey: string, shapeType?: CategoryPathShape, _updatedShapes?: UpdatedShape[]) => {\n    const before: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: categoryPathShapes[categoryKey] },\n    }];\n    const after: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: shapeType },\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, { before, after });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n\n  const selectInstance = (id: string, isFit = true) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    if (instance) {\n      if (isFit) {\n        canvas.current?.fitSelected(id);\n      }\n      setSelectedShapeStatus({\n        frameIndex: currentFrame,\n        category: instance.category,\n        instanceId: id,\n        groupName: '',\n        shapeType: undefined,\n        id: undefined,\n      });\n      setSelectedOntologyGroup('');\n    }\n  };\n\n  const selectGroup = (id: string, groupName: string, isFit = true, groupData?: { category: string, shapeType: LandmarkEditType }) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus:ShapeInfo = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: groupData?.category || selectedShapeStatus.category,\n      groupName,\n      shapeType: groupData?.shapeType || undefined,\n      id: undefined\n    };\n    if (instance) {\n      const ontologyItem = store.ontology.ontology.find((v) => v.class_name === instance.category);\n      const group = ontologyItem?.children.find((v) => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = group?.type || undefined;\n      if (isDrawMode) {\n        if (group?.type === LandmarkEditType.KEYPOINT) {\n          const index = (group.categories && group.categories[0] && group.categories[0].range[0]) || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if (group?.type === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach((child) => {\n            if (child.name === groupName && child.frames[currentFrame]?.shapes) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      canvas.current?.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        canvas.current?.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n\n  const switchSelection = () => {\n    if (attributesRef.current?.modalVisible) {\n      return;\n    }\n    // default switch between instances\n    let searchClassName = '.instance-label';\n    if (selectedShapeInfo?.groupName) {\n      searchClassName = '.instance-group-item';\n    }\n    const sidebarContainer = document.getElementsByClassName('side-menus-box')[0];\n    if (!sidebarContainer) {\n      return;\n    }\n    const nodes = Array.from(sidebarContainer.querySelectorAll(searchClassName));\n    const selectedIndex = nodes.findIndex((i) => i.classList.contains('selected'));\n    const nextIndex = selectedIndex === nodes.length - 1 ? 0 : selectedIndex + 1;\n    const nextNodes = nodes.slice(nextIndex).filter((i) => !i.classList.contains('empty'));\n    const nextNode = nextNodes.length > 0 ? nextNodes[0] : nodes.find((i) => !i.classList.contains('empty'));\n    if (nextNode) {\n      ['click'].forEach((eventName) => {\n        nextNode.dispatchEvent(new MouseEvent(eventName, {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n          buttons: 1,\n        }));\n      });\n    }\n  };\n\n  const editShapeForm = () => {\n    const { instanceId, groupName, shapeType, id, category } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, (id as number));\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && currentOntologyGroup?.point_label_config) {\n        handleFormConfig(currentOntologyGroup.point_label_config, (point as Point).attributes || {}, { instanceId, category, groupName }, (id as number), point);\n      }\n    }\n  };\n\n  const editGroupForm = () => {\n    const selectedInstanceIds = Object.keys(selectedGroups);\n    const selectedSize = selectedInstanceIds.reduce((acc, curr) => acc + selectedGroups[curr].size, 0);\n    if (selectedSize > 1) {\n      // multi selected\n      if (!readonly) {\n        // open modal\n        setMultiAttrModalVisible(true);\n      }\n      return;\n    }\n    const { instanceId, groupName, category } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && currentOntologyGroup?.label_config) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, { instanceId, category, groupName });\n    }\n  };\n\n  const handleFormConfig = (config: FormConfig, values: {[attr: string]: any;}, group: Group, index?: number, point?: Point) => {\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point,\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    attributesRef.current?.showModal(title);\n  };\n\n  const handleHotkey = (hotkey: string) => {\n    if (readonly || loading || isReview) {\n      return;\n    }\n    const pointHotkeyItems = store.ontology.pointHotkeyMap[hotkey];\n    if (pointHotkeyItems.length > 0) {\n      const { instanceId, id, category, groupName } = selectedShapeStatus;\n      const instance = cloneDeep(instances[instanceId]);\n      const group = instance?.children.find((g) => g.name === groupName);\n      const currentGroup = group?.frames[currentFrame];\n      if (group?.shapeType === LandmarkEditType.KEYPOINT && currentGroup) {\n        const groupShapes = currentGroup.shapes as Points;\n        const frameGroup = { frameIndex: currentFrame, instanceId, category, groupName };\n        const before: Status[] = [];\n        const after: Status[] = [];\n\n        const indexList = id !== undefined ? [id] : store.shape.selectedShapes;\n        for (let i = 0; i < indexList.length; i += 1) {\n          const index = indexList[i] as number;\n          const point = groupShapes[index];\n\n          if (point) {\n            before.push({\n              type: 'shape',\n              status: { ...frameGroup, index, shape: cloneDeep(point), shapeType: LandmarkEditType.KEYPOINT },\n            });\n            pointHotkeyItems.forEach(({ type, attributes }) => {\n              if (type === 'overwrite') {\n                point.attributes = { ...attributes };\n              } else {\n                point.attributes = { ...point.attributes, ...attributes };\n              }\n            });\n            after.push({\n              type: 'shape',\n              status: { ...frameGroup, index, shape: cloneDeep(point), shapeType: LandmarkEditType.KEYPOINT },\n            });\n            canvas.current?.changePointAttributes(instanceId, groupName, index, point.attributes);\n            canvas.current?.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n        }\n\n        if (after.length > 0) {\n          setInstance(instanceId, instance);\n          store.undo.saveStatus(before, after);\n        }\n      }\n    }\n  };\n\n  const getShapeLabel = (instanceId: string, category: string, groupName: string) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', { values: { frameIndex: currentFrame + 1 } })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name}`;\n      }\n    }\n    return title;\n  };\n\n  const setAttributes = (values: any) => {\n    if (editFormObject) {\n      const { instanceId, category, groupName, index, point } = editFormObject;\n      const before: Status[] = [];\n      const after: Status[] = [];\n      const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId, category, groupName };\n      if ((index || index === 0) && point) {\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = { ...oldPoint, ...point, attributes: values };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({ type: 'shape', status: { ...frameGroup, index, shape: oldPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        after.push({ type: 'shape', status: { ...frameGroup, index, shape: newPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        canvas.current?.changePointAttributes(instanceId, groupName, index, values);\n        canvas.current?.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName)?.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup?.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({ type: 'group', status: { ...frameGroup, attributes: oldAttrs } });\n          after.push({ type: 'group', status: { ...frameGroup, attributes: values } });\n          if (oldGroup?.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach((id) => {\n                canvas.current?.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode: AttributesMode, type = 'object') => {\n    canvas.current?.updatelabelVisible(activeMode, type);\n  };\n\n  const onSizeChange = () => {\n    canvas.current?.resizeShapes();\n  };\n\n  const onFilterChange = () => {\n    canvas.current?.updateFilters();\n  };\n\n  const onLabelModeChange = () => {\n    if (canvas.current?.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n    canvas.current?.resizeShapes();\n  };\n\n  const setFrameValid = (frame: number, valid: boolean) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n\n  const setFrameAttributes = ({ frame, attrs }: {frame: number, attrs: any}) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].attributes = attrs;\n    setFrames(newFramesData);\n  };\n\n  const getScriptResult = async () => {\n    let resultLink = '';\n    if (store.setting.customCheck.length > 0 || store.setting.scriptCheck) {\n      if (typeof props.jobProxy.reviewFrom === 'string') {\n        resultLink = props.jobProxy.reviewFrom;\n      }\n      if (!isAnnotationReadonly(props.jobProxy.toolMode)) {\n        try {\n          resultLink = await onSave(false);\n        } catch (e) {\n          resultLink = '';\n        }\n      }\n    }\n\n    const [result] = await Promise.all([\n      validate(\n        store.setting.customCheck,\n        {\n          resultLink,\n          flowData: props.jobProxy.flowData,\n        },\n        store.setting.scriptCheck,\n        props.jobProxy.validateContent,\n      ),\n      new Promise((resolve) => {\n        setTimeout(resolve, 300);\n      })\n    ]);\n    if (result) {\n      store.review.setScriptResult(result as {results: IWarning[]; hasCustomError: boolean});\n    }\n  };\n\n  const loadAdvanceJobData = async (e:any) => {\n    let needRender = false;\n    // load instance\n    if (e.result?.instances) {\n      needRender = true;\n      const { newInstances } = loadInstancesFromResult(e.result?.instances);\n      setDefaultInstances(newInstances);\n      setInstances(newInstances);\n      renderInstances = newInstances;\n    }\n\n    // load reviews\n    if (typeof e.reviews === 'object') {\n      needRender = true;\n      if (Array.isArray(e.reviews)) {\n        store.review.setInitialData(e.reviews);\n      } else if (e.reviews?.updateTime) {\n        delete e.reviews.updateTime;\n        store.review.setInitialData(Object.values(e.reviews));\n      }\n    }\n\n    // render\n    if (needRender) {\n      setFrame(0, renderInstances, CANVASSTATUS.INITIAL);\n    }\n  };\n\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics,\n  }));\n\n  return (\n    <Observer>\n      {() => (\n        <div className=\"landmark-annotation-app\">\n          <AutoSaver\n            ref={saverRef}\n            leaveCheck\n            data={{ instance: instances, reviews: store.review.qaWarnings }}\n            save={handleSave}\n          />\n          <Toolbar\n            readonly={readonly || loading || isReview}\n            isReview={isReview}\n            isPreview={readonly}\n            initialDataLength={Object.keys(initialInstances).length}\n            onAttributesModeChanges={onAttributesModeChanges}\n            onSizeChange={onSizeChange}\n            onFilterChange={onFilterChange}\n            onLabelModeChange={onLabelModeChange}\n            onSave={handleSave}\n            handleUndo={handleUndo}\n            handleRedo={handleRedo}\n            setReview={setReview}\n            handleChangeDrawMode={handleChangeDrawMode}\n          />\n          <div\n            className=\"container\"\n            style={{\n              height: `calc(100% - ${(frames.length > 1 && currentFrame >= 0) ? `${frameControlHeight + 35}px` : '35px'})`,\n              transition: 'height 0.15s',\n            }}\n          >\n            <TabMenu\n              tabs={[\n                {\n                  title: formatMessage('MENU_INSTANCE'),\n                  key: 'instance',\n                  count: 0,\n                  content: (\n                    <SideMenus\n                      canvas={canvas.current}\n                      readonly={readonly || loading || isReview || !isDrawMode}\n                      loading={loading}\n                      instances={instanceList}\n                      currentFrame={currentFrame}\n                      frameCount={frames.length}\n                      instancesFrames={instancesFrames}\n                      selectedInstance={selectedInstance}\n                      selectedOntologyGroup={selectedOntologyGroup}\n                      instancesReviewsMap={instancesReviewsMap}\n                      instanceVisibile={store.setting.getVisibleStatusByFrame(currentFrame)}\n                      inexistentGraphicsCardVisibility={store.setting.inexistentGraphicsCardVisibility}\n                      updateInexistentGraphicsCardVisibility={store.setting.updateInexistentGraphicsCardVisibility}\n                      addInstance={addInstance}\n                      selectInstance={selectInstance}\n                      selectGroup={selectGroup}\n                      addInstanceInFrame={addInstanceInFrame}\n                      removeInstanceFrames={removeInstanceFrames}\n                      toggleInstancesVisible={() => toggleInstancesVisible(currentFrame)}\n                      selectedGroups={selectedGroups}\n                    />\n                  )\n                },\n                {\n                  title: formatMessage('MENU_WARNING'),\n                  key: 'validator',\n                  count: store.review.warnings.length,\n                  content: (\n                    <Validator\n                      ref={validatorRef}\n                      canvas={canvas.current}\n                      instances={instances}\n                      jobProxy={props.jobProxy}\n                      getScriptResult={getScriptResult}\n                      warnings={store.review.warnings || []}\n                      setFrame={setFrame}\n                      setSelectedShape={setSelectedShape}\n                      selectGroup={selectGroup}\n                      getInstance={getInstance}\n                      saveResult={() => onSave(false)}\n                    />\n                  )\n                }\n              ]}\n            />\n            {selectedInstance && ontologyGroup && !isReview && (\n              <Board\n                categories={categories}\n                categoryPathShapes={displayedCategoryPathShapes}\n                points={shapes}\n                ontologyGroup={ontologyGroup}\n                selectedShapeStatus={selectedShapeStatus}\n                annotated={annotatedPointOrShapeCount}\n                total={totalPointCount}\n                drawMode={isDrawMode}\n                setSelectedShape={(id) => {\n                  const { instanceId, category, groupName } = selectedShapeStatus;\n                  setSelectedShape(id, { instanceId, category, groupName });\n                }}\n                frameControlHeight={frameControlHeight}\n                readonly={loading}\n                instanceReviewsMap={store.review.frameReviewsMap[currentFrame]}\n              />\n            )}\n            <CanvasContainer\n              ref={canvas}\n              readonly={readonly}\n              loading={loading}\n              isReview={isReview}\n              currentFrame={currentFrame}\n              image={frames[currentFrame]?.url}\n              categories={categories}\n              selectedInstance={selectedInstance}\n              selectedGroupName={selectedOntologyGroup}\n              ontologyGroup={ontologyGroup}\n              annotatedPointOrShapeCount={annotatedPointOrShapeCount}\n              updatedCategories={updatedCategories}\n              defaultInstances={defaultInstances}\n              selectedShapeStatus={selectedShapeStatus}\n              selectedShapeInfo={selectedShapeInfo}\n              changeLoading={setLoading}\n              selectGroup={selectGroup}\n              setSelectedShape={setSelectedShape}\n              handleShapesChange={handleShapesChange}\n              onCategoriesUpdated={onCategoriesUpdated}\n              handleShapesRemove={handleShapesRemove}\n              togglePointsVisibility={togglePointsVisibility}\n              setNextEmptyShape={setNextEmptyShape}\n              editShapeForm={editShapeForm}\n              editGroupForm={editGroupForm}\n              handleHotkey={handleHotkey}\n              onSave={handleSave}\n              getInstance={getInstance}\n              categoryPathShapes={displayedCategoryPathShapes}\n              setCategoryPathShape={setCategoryPathShape}\n              handleUndo={handleUndo}\n              handleRedo={handleRedo}\n              setReview={setReview}\n              handleChangeDrawMode={handleChangeDrawMode}\n              toggleInstancesVisible={toggleInstancesVisible}\n              switchSelection={switchSelection}\n              addInstance={addInstance}\n              setSelectedGroups={setSelectedGroups}\n            />\n            <div className=\"arributes-panel\">\n              {selectedShapeStatus.groupName && (\n                <Information\n                  pointCategory={(categories[selectedCategoryIndex] || {}).name}\n                  point={selectedShapeStatus}\n                  annotated={annotatedPointOrShapeCount}\n                  total={totalPointCount}\n                />\n              )}\n              {frames[currentFrame]?.url && (\n                <FrameAttributes\n                  currentFrame={currentFrame}\n                  currentFrameValid={frames[currentFrame].valid}\n                  setFrameValid={setFrameValid}\n                  currentFrameAttrs={frames[currentFrame].attributes}\n                  setFrameAttributes={setFrameAttributes}\n                />\n              )}\n            </div>\n            <Attributes\n              ref={attributesRef}\n              readonly={readonly || isReview || !isDrawMode}\n              config={formConfig}\n              values={formValues}\n              onValuesChange={setAttributes}\n            />\n            <MultiAttributes\n              modalVisible={multiAttrModalVisible}\n              currentFrame={currentFrame}\n              selectedGroups={selectedGroups}\n              getInstance={getInstance}\n              onCancel={() => {\n                setMultiAttrModalVisible(false);\n              }}\n              onSubmit={(updatedInstances, { before, after }) => {\n                after.forEach(({ status }) => {\n                  const { instanceId, category, groupName, attributes } = status as GroupStatus;\n                  const group = getGroup(instanceId, groupName, currentFrame);\n                  if (group?.shapes) {\n                    Object.keys(group.shapes).forEach((id) => {\n                      canvas.current?.updateAttributeLabel(instanceId, category, groupName, id, attributes, updatedInstances[instanceId]?.number);\n                    });\n                  }\n                });\n                store.undo.saveStatus(before, after);\n                setInstances({\n                  ...instances,\n                  ...updatedInstances,\n                });\n                setMultiAttrModalVisible(false);\n              }}\n            />\n          </div>\n          {(frames.length > 1 && currentFrame >= 0) && (\n            <FrameControl\n              frames={frames}\n              frameLoading={loading}\n              currentFrame={currentFrame}\n              categoryInstancesMap={displayedCategoryInstancesMap}\n              instancesReviewsMap={instancesReviewsMap}\n              instances={displayedInstances}\n              selectedInstance={selectedInstance}\n              selectedInstanceGroup={selectedOntologyGroup}\n              selectGroup={selectGroup}\n              setFrame={setFrame}\n              onHeightChange={setFrameControlHeight}\n            />\n          )}\n          {store.review.selectedReview && (\n            <QualityControl\n              review={store.review.selectedReview}\n              readonly={readonly || isDrawMode}\n              jobProxy={props.jobProxy}\n              selectedShapeStatus={selectedShapeStatus}\n              getShapeLabel={getShapeLabel}\n            />\n          )}\n          <Missing\n            readonly={readonly || isDrawMode}\n            jobProxy={props.jobProxy}\n          />\n        </div>\n      )}\n    </Observer>\n  );\n});\n\nexport default LandmarkAnnotation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}