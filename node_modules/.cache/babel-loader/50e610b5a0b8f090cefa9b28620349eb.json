{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/canvas/Canvas.tsx\";\nimport React from 'react';\nimport { Container, Sprite, Loader, Point, utils, Graphics, Polygon as PPolygon, LoaderResource } from 'pixi.js';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport Layer from '../Layer';\nimport { ShapeType } from '../types';\nimport ShapeGraphics from '../ShapeGraphics';\nimport Assistant from '../assists/Assistant';\nimport { hitTesting, findIntersections } from '../utils';\nimport './Canvas.css';\nconst ZOOM_MIN = 0.25;\nconst ZOOM_MAX = 100;\nexport default class Canvas extends React.Component {\n  /**\n   * get scale of the stage\n   * @getter\n   */\n  get scale() {\n    return this.props.app.stage.scale.x;\n  }\n\n  /**\n   * set scale of the stage\n   * @setter\n   */\n  set scale(scale) {\n    this.props.app.stage.scale.set(scale);\n    // update children scale\n    const setChildrenScale = children => {\n      children.forEach(child => {\n        if (child instanceof ShapeGraphics) {\n          // eslint-disable-next-line no-param-reassign\n          child.shape.scale = scale;\n        } else if (child instanceof Container) {\n          setChildrenScale(child.children);\n        }\n      });\n    };\n    setChildrenScale(this.props.app.stage.children);\n    this.setState({\n      scale\n    });\n    if (this.props.onScaleChange) {\n      this.props.onScaleChange(scale);\n    }\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      scale: 1,\n      loadError: false\n    };\n    /**\n     * application dom container\n     */\n    this.container = void 0;\n    /**\n     * selector path\n     */\n    this.selectorPath = new Graphics();\n    /**\n     * points in selector path\n     */\n    this.selectorPathPoints = [];\n    /**\n     * hovered shape\n     */\n    this.hoveredShape = void 0;\n    /**\n     * image sprite instance\n     */\n    this.image = new Sprite();\n    /**\n     * first image loaded\n     */\n    this.firstLoaded = false;\n    /**\n     * zoom level, default is 1 when image fits the canvas\n     */\n    this.zoomLevel = 1;\n    /**\n     * cancellable image loader\n     */\n    this.cancellableLoader = null;\n    /**\n     * is stage clicked\n     * @private\n     */\n    this._stageClicked = false;\n    /**\n     * is right button clicked\n     * @private\n     */\n    this._rightClicked = false;\n    /**\n     * click position when right button clicked\n     * @private\n     */\n    this._rightClickPoint = null;\n    /**\n     * stage position when right button clicked\n     * @private\n     */\n    this._rightClickPosition = null;\n    /**\n     * is selecting\n     * @private\n     */\n    this._selecting = false;\n    /**\n     * load image from image url\n     */\n    this.loadImage = () => {\n      this.setState({\n        loadError: false\n      });\n      const {\n        imageUrl\n      } = this.props;\n      if (imageUrl) {\n        if (this.cancellableLoader) {\n          this.cancellableLoader.cancel();\n        }\n        this.cancellableLoader = {\n          cancelled: false,\n          cancel() {\n            this.cancelled = true;\n          },\n          load() {\n            return new Promise((resove, reject) => {\n              Loader.shared.reset().add({\n                url: imageUrl,\n                loadType: LoaderResource.LOAD_TYPE.IMAGE,\n                xhrType: LoaderResource.XHR_RESPONSE_TYPE.BLOB\n              }).load(() => {\n                utils.clearTextureCache();\n                if (!this.cancelled && Loader.shared.resources[imageUrl]) {\n                  resove(Loader.shared.resources[imageUrl].texture);\n                } else {\n                  reject();\n                }\n              });\n            });\n          }\n        };\n        this.cancellableLoader.load().then(texture => {\n          this.image.texture.destroy(true);\n          this.image.texture = texture;\n          if (this.state.loadError) {\n            if (this.props.onImageLoadError) {\n              this.props.onImageLoadError(imageUrl);\n            }\n            return;\n          }\n          this.rotate();\n          if (!this.firstLoaded) {\n            this.firstLoaded = true;\n            this.fitImageToView();\n          } else if (this.props.keepZoom === false) {\n            this.fitImageToView();\n          }\n          if (this.props.onImageLoaded) {\n            // tell parent which image specific loaded\n            this.props.onImageLoaded(imageUrl, this.image);\n          }\n        }).catch(() => {\n          // cancelled loader\n        });\n      } else {\n        this.setState({\n          loadError: true\n        });\n        if (this.props.onImageLoadError) {\n          this.props.onImageLoadError(imageUrl);\n        }\n      }\n    };\n    /**\n     * resize\n     */\n    this.resize = () => {\n      const {\n        width,\n        height\n      } = this.getContainerSize();\n      this.props.app.renderer.resize(width, height);\n      this.props.app.render();\n      // this.fitImageToView();\n    };\n    /**\n     * rotate\n     */\n    this.rotate = () => {\n      if (this.image) {\n        // set pivot\n        const {\n          width,\n          height\n        } = this.image;\n        this.image.pivot.set(width / 2, height / 2);\n\n        // set position\n        let px = width / 2;\n        let py = height / 2;\n        if (this.props.rotation && this.props.rotation % Math.PI !== 0) {\n          px = height / 2;\n          py = width / 2;\n        }\n        const {\n          x: ox,\n          y: oy\n        } = this.image.position;\n        this.image.position.set(px, py);\n        const offsetX = px - ox;\n        const offsetY = py - oy;\n\n        // set rotation\n        this.image.rotation = this.props.rotation || 0;\n\n        // update stage position\n        const {\n          x,\n          y\n        } = this.getStagePosition();\n        this.setStagePosition(x - offsetX * this.scale, y - offsetY * this.scale);\n      }\n    };\n    /**\n     * zoom\n     * @param event zoom event\n     */\n    this.zoom = event => {\n      if (this.state.loadError) {\n        return;\n      }\n      event.stopPropagation();\n      const {\n        maxZoom = ZOOM_MAX,\n        minZoom = ZOOM_MIN\n      } = this.props;\n      const zoomPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      let newZoom = event.deltaY > 0 ? this.zoomLevel / 1.1 : this.zoomLevel * 1.1;\n      newZoom = Math.max(Math.min(newZoom, maxZoom), minZoom);\n      const zoomScale = newZoom / this.zoomLevel;\n      const {\n        x,\n        y\n      } = this.getStagePosition();\n      this.setStagePosition(zoomPoint.x - (zoomPoint.x - x) * zoomScale, zoomPoint.y - (zoomPoint.y - y) * zoomScale);\n      this.zoomLevel = newZoom;\n      this.scale *= zoomScale;\n    };\n    /**\n     * zoom to provided scale\n     * @param scale\n     */\n    this.zoomTo = scale => {\n      if (this.state.loadError) {\n        return;\n      }\n      if (this.container.current) {\n        var _this$container$curre;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = (_this$container$curre = this.container.current) === null || _this$container$curre === void 0 ? void 0 : _this$container$curre.getBoundingClientRect();\n        const center = this.mapScreenToStagePosition(left + width / 2, top + height / 2);\n        const {\n          maxZoom = ZOOM_MAX,\n          minZoom = ZOOM_MIN\n        } = this.props;\n        let newZoom = this.zoomLevel * (scale / this.scale);\n        newZoom = Math.max(Math.min(newZoom, maxZoom), minZoom);\n        const zoomScale = newZoom / this.zoomLevel;\n        const {\n          x,\n          y\n        } = this.getStagePosition();\n        this.setStagePosition(center.x - (center.x - x) * zoomScale, center.y - (center.y - y) * zoomScale);\n        this.zoomLevel = newZoom;\n        this.scale *= zoomScale;\n      }\n    };\n    /**\n     * fit image to canvas\n     */\n    this.fitImageToView = () => {\n      if (this.state.loadError) {\n        return;\n      }\n      if (this.image) {\n        const {\n          width: viewWidth,\n          height: viewHeight\n        } = this.getViewSize();\n        let {\n          width: imageWidth,\n          height: imageHeight\n        } = this.image;\n        if (this.props.rotation && this.props.rotation % Math.PI !== 0) {\n          const w = imageWidth;\n          imageWidth = imageHeight;\n          imageHeight = w;\n        }\n        const viewRatio = viewWidth / viewHeight;\n        const imgRatio = imageWidth / imageHeight;\n        const scale = (viewRatio < imgRatio ? viewWidth / imageWidth : viewHeight / imageHeight) * 0.98;\n        this.setStagePosition((viewWidth - scale * imageWidth) / 2, (viewHeight - scale * imageHeight) / 2);\n        this.scale = scale;\n\n        // when fits canvas, zoom level should be 1\n        this.zoomLevel = 1;\n      }\n    };\n    /**\n     * fit shape to canvas\n     * @param bbox\n     * @param percentage\n     */\n    this.fitShapeToView = (bbox, percentage = 0.98) => {\n      if (this.state.loadError) {\n        return;\n      }\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = bbox;\n      const width = right - left;\n      const height = bottom - top;\n      if (width !== 0 && height !== 0) {\n        const {\n          maxZoom = ZOOM_MAX,\n          minZoom = ZOOM_MIN\n        } = this.props;\n        const oldViewScale = this.scale;\n        const {\n          width: viewWidth,\n          height: viewHeight\n        } = this.getViewSize();\n        const viewRatio = viewWidth / viewHeight;\n        const ratio = width / height;\n        let scale = (viewRatio < ratio ? viewWidth / width : viewHeight / height) * percentage;\n        let zoomScale = scale / oldViewScale;\n        let zoomLevel = Math.max(Math.min(this.zoomLevel * zoomScale, maxZoom), minZoom);\n        if (zoomLevel < 1) {\n          zoomLevel = 1;\n          zoomScale = zoomLevel / this.zoomLevel;\n          scale = zoomScale * oldViewScale;\n        }\n        this.scale = scale;\n        this.setStagePosition(viewWidth / 2 - this.scale * (left + width / 2), viewHeight / 2 - this.scale * (top + height / 2));\n        this.zoomLevel *= zoomScale;\n      }\n    };\n    /**\n     * start select\n     */\n    this.startSelect = () => {\n      this._selecting = true;\n      this.props.app.stage.addChild(this.selectorPath);\n    };\n    /**\n     * canvas dom mouse down\n     * @param event\n     */\n    this.handleMouseDown = event => {\n      if (this.state.loadError) {\n        return;\n      }\n      const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      if (event.button === 2) {\n        const currentPosistion = this.getStagePosition();\n        this._rightClickPosition = new Point(currentPosistion.x, currentPosistion.y);\n        this._rightClickPoint = point;\n        this._rightClicked = true;\n        return;\n      }\n\n      // if click outside of the image\n      if (!this.isPointInStage(point) && !this._stageClicked && this.props.onBlankClick) {\n        this.props.onBlankClick();\n      }\n\n      // canvas mouse down\n      const localPoint = this.mapStageToLocalPosition(point);\n      if (this.props.onClick) {\n        this.props.onClick(localPoint);\n      }\n      this._stageClicked = false;\n    };\n    /**\n     * canvas dom mouse move\n     * @param event\n     */\n    this.handleMouseMove = event => {\n      if (this.state.loadError) {\n        return;\n      }\n      const currentPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this.mapStageToLocalPosition(currentPoint);\n      if (this.props.onMouseMove) {\n        this.props.onMouseMove(localPoint);\n      }\n      if (this._rightClicked && this._rightClickPoint && this._rightClickPosition) {\n        const offsetX = currentPoint.x - this._rightClickPoint.x;\n        const offsetY = currentPoint.y - this._rightClickPoint.y;\n        const x = this._rightClickPosition.x + offsetX;\n        const y = this._rightClickPosition.y + offsetY;\n        this.setStagePosition(x, y);\n        return;\n      }\n      if (this._selecting) {\n        this.selectorPathPoints.push(localPoint);\n        this.drawSelectorPath();\n        return;\n      }\n      if (!event.ctrlKey) {\n        const {\n          intersection,\n          snappingPoint\n        } = hitTesting(currentPoint, localPoint, this.props.app.stage.children);\n        this.setHoveredShape(intersection);\n        this.setSnappingPoint(snappingPoint);\n      } else {\n        this.setHoveredShape();\n        this.setSnappingPoint(null);\n      }\n    };\n    /**\n     * canvas dom mouse up\n     */\n    this.handleMouseUp = () => {\n      this.finishSelect();\n      this._rightClickPosition = null;\n      this._rightClickPoint = null;\n      this._rightClicked = false;\n    };\n    /**\n     * canvas dom mouse leave\n     */\n    this.handleMouseLeave = () => {\n      this.handleMouseUp();\n      this.setHoveredShape();\n    };\n    this.container = React.createRef();\n    // set interactive\n    this.props.app.stage.interactive = this.props.interactive !== false;\n    this.props.app.stage.on('pointerdown', () => {\n      this._stageClicked = true;\n    });\n    // set image\n    this.image.interactive = true;\n    if (this.props.onBlankClick) {\n      this.image.on('mousedown', this.props.onBlankClick);\n    }\n    // add image to stage, always add to root\n    this.props.app.stage.addChildAt(this.image, 0);\n  }\n  componentDidMount() {\n    if (this.container.current) {\n      new ResizeObserver(this.resize).observe(this.container.current);\n      this.props.app.renderer.on('resolution-changed', this.resize);\n\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n      this.resize();\n\n      // load image\n      Loader.shared.onError.add(() => {\n        this.setState({\n          loadError: true\n        });\n      });\n      this.loadImage();\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.imageUrl !== prevProps.imageUrl) {\n      // reload image\n      this.loadImage();\n    } else if (this.props.rotation !== prevProps.rotation) {\n      // rotation changes\n      this.rotate();\n    }\n    if (this.props.interactive !== prevProps.interactive) {\n      // interactive changes\n      const interactive = this.props.interactive !== false;\n      this.props.app.stage.interactive = interactive;\n      this.image.interactive = interactive;\n      const setChildrenInteractive = children => {\n        children.forEach(child => {\n          if (child instanceof ShapeGraphics) {\n            // eslint-disable-next-line no-param-reassign\n            child.shape.interactive = interactive;\n          } else if (child instanceof Container) {\n            setChildrenInteractive(child.children);\n          }\n        });\n      };\n      setChildrenInteractive(this.props.app.stage.children);\n    }\n  }\n  componentWillUnmount() {\n    if (this.props.onMouseMove) {\n      this.props.onMouseMove(null);\n    }\n    if (this.image) {\n      this.image.destroy({\n        children: true,\n        texture: true,\n        baseTexture: true\n      });\n    }\n    // reset stage\n    this.props.app.stage.removeChildren();\n    this.props.app.stage.scale.set(1);\n    this.props.app.stage.position.set(0, 0);\n    // remove listeners\n    this.props.app.renderer.off('resolution-changed', this.resize);\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x, y) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point) {\n    return this.props.app.stage.toLocal(point);\n  }\n\n  /**\n   * get container's size, defualt is 800 * 600\n   */\n  getContainerSize() {\n    // default size is 800 * 600\n    const size = {\n      width: 800,\n      height: 600\n    };\n    if (this.container.current) {\n      size.width = this.container.current.clientWidth;\n      size.height = this.container.current.clientHeight;\n    }\n    return size;\n  }\n\n  /**\n   * get renderer size\n   */\n  getViewSize() {\n    return {\n      width: this.props.app.renderer.width / window.devicePixelRatio,\n      height: this.props.app.renderer.height / window.devicePixelRatio\n    };\n  }\n\n  /**\n   * get stage size\n   */\n  getStageSize() {\n    return {\n      width: this.props.app.stage.width,\n      height: this.props.app.stage.height\n    };\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.props.app.stage.x,\n      y: this.props.app.stage.y\n    };\n  }\n\n  /**\n   * set stage posistion\n   * @param x\n   * @param y\n   */\n  setStagePosition(x, y) {\n    this.props.app.stage.x = x;\n    this.props.app.stage.y = y;\n    if (this.props.onPositionChange) {\n      this.props.onPositionChange({\n        x,\n        y\n      });\n    }\n  }\n\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape && !this.hoveredShape.destroyed) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n\n  /**\n   * set snapping point\n   * @param point\n   */\n  setSnappingPoint(point) {\n    Layer.prototype.setSnappingPoint.call(this.props.app.stage, point);\n  }\n\n  /**\n   * get all shapes in stage\n   */\n  getAllShapes() {\n    const getShapes = children => {\n      let shapes = [];\n      for (let i = 0; i < children.length; i += 1) {\n        const child = children[i];\n        if (child.visible) {\n          if (child instanceof ShapeGraphics) {\n            if (child.shape.finished) {\n              shapes.push(child.shape);\n            }\n          } else if (child instanceof Container) {\n            shapes = [...shapes, ...getShapes(child.children)];\n          }\n        }\n      }\n      return shapes;\n    };\n    return getShapes(this.props.app.stage.children);\n  }\n\n  /**\n   * check if the point is in the stage\n   * @param point\n   */\n  isPointInStage(point) {\n    const {\n      x,\n      y\n    } = this.getStagePosition();\n    const {\n      width,\n      height\n    } = this.getStageSize();\n    return point.x >= x && point.x <= x + width && point.y >= y && point.y <= y + height;\n  }\n  /**\n   * finish select\n   */\n  finishSelect() {\n    if (this._selecting && this.selectorPathPoints.length > 0) {\n      // check selected\n      const selectorPathData = [[[...this.selectorPathPoints].map(p => [p.x, p.y])]];\n      const selectorPathBounds = this.selectorPath.getLocalBounds();\n      const allShapes = this.getAllShapes();\n      const intersections = findIntersections(selectorPathData, selectorPathBounds, ShapeType.POLYGON, allShapes);\n      if (this.props.onShapesSelect) {\n        this.props.onShapesSelect(intersections.map(i => i.uid));\n      }\n      const shapePointsMap = {};\n      for (let i = 0; i < intersections.length; i += 1) {\n        const intersection = intersections[i];\n        if (intersection.shapeType === ShapeType.POLYGON || intersection.shapeType === ShapeType.LINE || intersection.shapeType === ShapeType.ARROW) {\n          // check points selected\n          const selectorPathArea = new PPolygon(this.selectorPathPoints);\n          const {\n            points\n          } = intersection;\n          const selectedPointsIndex = [];\n          for (let j = 0; j < points.length; j += 1) {\n            if (selectorPathArea.contains(points[j].x, points[j].y)) {\n              selectedPointsIndex.push(j);\n            }\n          }\n          if (selectedPointsIndex.length > 0) {\n            shapePointsMap[intersection.uid] = selectedPointsIndex;\n          }\n        }\n      }\n      if (Object.keys(shapePointsMap).length > 0 && this.props.onPointsSelect) {\n        this.props.onPointsSelect(shapePointsMap);\n      }\n    }\n    this._selecting = false;\n    this.props.app.stage.removeChild(this.selectorPath);\n    this.selectorPathPoints = [];\n    this.drawSelectorPath();\n  }\n\n  /**\n   * draw path\n   */\n  drawSelectorPath() {\n    this.selectorPath.clear();\n    if (this.selectorPathPoints.length > 0) {\n      this.selectorPath.lineStyle(2 / this.scale, 0xFF0000);\n      this.selectorPath.moveTo(this.selectorPathPoints[0].x, this.selectorPathPoints[0].y);\n      for (let i = 1; i < this.selectorPathPoints.length; i += 1) {\n        this.selectorPath.lineTo(this.selectorPathPoints[i].x, this.selectorPathPoints[i].y);\n      }\n    }\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"canvas-container\",\n      ref: this.container,\n      style: {\n        ...this.props.style,\n        width: '100%',\n        height: '100%'\n      },\n      onWheel: this.zoom,\n      onMouseDown: this.handleMouseDown,\n      onMouseMove: this.handleMouseMove,\n      onMouseUp: this.handleMouseUp,\n      onMouseLeave: this.handleMouseLeave,\n      onContextMenu: e => e.preventDefault(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 751,\n        columnNumber: 9\n      }\n    }), this.state.loadError && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"canvas-error\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 763,\n        columnNumber: 11\n      }\n    }, this.props.imageLoadErrorMsg || 'Failed to load image'), /*#__PURE__*/React.createElement(Assistant, {\n      element: \".canvas-container\",\n      scale: this.state.scale,\n      crossline: this.props.crossline,\n      measurementBox: this.props.measurementBox,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 767,\n        columnNumber: 9\n      }\n    }));\n  }\n}","map":{"version":3,"names":["React","Container","Sprite","Loader","Point","utils","Graphics","Polygon","PPolygon","LoaderResource","ResizeObserver","Layer","ShapeType","ShapeGraphics","Assistant","hitTesting","findIntersections","ZOOM_MIN","ZOOM_MAX","Canvas","Component","scale","props","app","stage","x","set","setChildrenScale","children","forEach","child","shape","setState","onScaleChange","constructor","state","loadError","container","selectorPath","selectorPathPoints","hoveredShape","image","firstLoaded","zoomLevel","cancellableLoader","_stageClicked","_rightClicked","_rightClickPoint","_rightClickPosition","_selecting","loadImage","imageUrl","cancel","cancelled","load","Promise","resove","reject","shared","reset","add","url","loadType","LOAD_TYPE","IMAGE","xhrType","XHR_RESPONSE_TYPE","BLOB","clearTextureCache","resources","texture","then","destroy","onImageLoadError","rotate","fitImageToView","keepZoom","onImageLoaded","catch","resize","width","height","getContainerSize","renderer","render","pivot","px","py","rotation","Math","PI","ox","y","oy","position","offsetX","offsetY","getStagePosition","setStagePosition","zoom","event","stopPropagation","maxZoom","minZoom","zoomPoint","mapScreenToStagePosition","clientX","clientY","newZoom","deltaY","max","min","zoomScale","zoomTo","current","_this$container$curre","left","top","getBoundingClientRect","center","viewWidth","viewHeight","getViewSize","imageWidth","imageHeight","w","viewRatio","imgRatio","fitShapeToView","bbox","percentage","right","bottom","oldViewScale","ratio","startSelect","addChild","handleMouseDown","point","button","currentPosistion","isPointInStage","onBlankClick","localPoint","mapStageToLocalPosition","onClick","handleMouseMove","currentPoint","onMouseMove","push","drawSelectorPath","ctrlKey","intersection","snappingPoint","setHoveredShape","setSnappingPoint","handleMouseUp","finishSelect","handleMouseLeave","createRef","interactive","on","addChildAt","componentDidMount","observe","appendChild","view","onError","componentDidUpdate","prevProps","setChildrenInteractive","componentWillUnmount","baseTexture","removeChildren","off","plugins","interaction","mapPositionToPoint","toLocal","size","clientWidth","clientHeight","window","devicePixelRatio","getStageSize","onPositionChange","destroyed","hovered","prototype","call","getAllShapes","getShapes","shapes","i","length","visible","finished","selectorPathData","map","p","selectorPathBounds","getLocalBounds","allShapes","intersections","POLYGON","onShapesSelect","uid","shapePointsMap","shapeType","LINE","ARROW","selectorPathArea","points","selectedPointsIndex","j","contains","Object","keys","onPointsSelect","removeChild","clear","lineStyle","moveTo","lineTo","createElement","Fragment","className","ref","style","onWheel","onMouseDown","onMouseUp","onMouseLeave","onContextMenu","e","preventDefault","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","imageLoadErrorMsg","element","crossline","measurementBox"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/canvas/Canvas.tsx"],"sourcesContent":["import React from 'react';\nimport { Application, Container, DisplayObject, Sprite, Loader, Point, utils, Texture, Graphics, Polygon as PPolygon, LoaderResource } from 'pixi.js';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport Layer from '../Layer';\nimport { ShapeData, ShapeType } from '../types';\nimport ShapeGraphics from '../ShapeGraphics';\nimport Shape from '../Shape';\nimport type Polygon from '../Polygon';\nimport type Line from '../Line';\nimport Assistant from '../assists/Assistant';\nimport { hitTesting, findIntersections } from '../utils';\nimport './Canvas.css';\n\nconst ZOOM_MIN = 0.25;\nconst ZOOM_MAX = 100;\n\ninterface CancellableLoader {\n  cancelled: boolean;\n  cancel: () => void;\n  load: () => Promise<Texture>;\n}\n\ninterface CanvasProps {\n  style?: React.CSSProperties;\n  app: Application;\n  imageUrl: string;\n  rotation?: number;\n  interactive?: boolean;\n  minZoom?: number;\n  maxZoom?: number;\n  keepZoom?: boolean;\n  crossline?: boolean;\n  measurementBox?: number[];\n  imageLoadErrorMsg?: string;\n  onImageLoadError?: (imageUrl: string) => void;\n  onImageLoaded?: (imageUrl: string, image: Sprite) => void;\n  onScaleChange?: (scale: number) => void;\n  onPositionChange?: (position: { x: number; y: number }) => void;\n  onClick?: (point: Point) => void; // canvas click\n  onBlankClick?: () => void; // canvas blank area click, not click on any shapes\n  onMouseMove?: (point: Point | null) => void;\n  onPointsSelect?: (shapePointsMap: { [shapeId: string]: number[] }) => void;\n  onShapesSelect?: (shapeIds: string[]) => void;\n}\n\ninterface CanvasState {\n  scale: number;\n  loadError: boolean;\n}\n\nexport default class Canvas extends React.Component<CanvasProps, CanvasState> {\n  state = {\n    scale: 1,\n    loadError: false,\n  };\n\n  /**\n   * application dom container\n   */\n  container: React.RefObject<HTMLDivElement>;\n\n  /**\n   * selector path\n   */\n  selectorPath = new Graphics();\n\n  /**\n   * points in selector path\n   */\n  selectorPathPoints: Point[] = [];\n\n  /**\n   * hovered shape\n   */\n  hoveredShape?: Shape<unknown>;\n\n  /**\n   * image sprite instance\n   */\n  image: Sprite = new Sprite();\n\n  /**\n   * first image loaded\n   */\n  firstLoaded = false;\n\n  /**\n   * zoom level, default is 1 when image fits the canvas\n   */\n  zoomLevel = 1;\n\n  /**\n   * cancellable image loader\n   */\n  cancellableLoader: CancellableLoader | null = null;\n\n  /**\n   * is stage clicked\n   * @private\n   */\n  private _stageClicked = false;\n\n  /**\n   * is right button clicked\n   * @private\n   */\n  private _rightClicked = false;\n\n  /**\n   * click position when right button clicked\n   * @private\n   */\n  private _rightClickPoint: Point | null = null;\n\n  /**\n   * stage position when right button clicked\n   * @private\n   */\n  private _rightClickPosition: Point | null = null;\n\n  /**\n   * is selecting\n   * @private\n   */\n  private _selecting = false;\n\n  /**\n   * get scale of the stage\n   * @getter\n   */\n  get scale() {\n    return this.props.app.stage.scale.x;\n  }\n\n  /**\n   * set scale of the stage\n   * @setter\n   */\n  set scale(scale: number) {\n    this.props.app.stage.scale.set(scale);\n    // update children scale\n    const setChildrenScale = (children: DisplayObject[]) => {\n      children.forEach((child) => {\n        if (child instanceof ShapeGraphics) {\n          // eslint-disable-next-line no-param-reassign\n          child.shape.scale = scale;\n        } else if (child instanceof Container) {\n          setChildrenScale(child.children);\n        }\n      });\n    };\n    setChildrenScale(this.props.app.stage.children);\n\n    this.setState({ scale });\n    if (this.props.onScaleChange) {\n      this.props.onScaleChange(scale);\n    }\n  }\n\n  constructor(props: CanvasProps) {\n    super(props);\n    this.container = React.createRef();\n    // set interactive\n    this.props.app.stage.interactive = this.props.interactive !== false;\n    this.props.app.stage.on('pointerdown', () => {\n      this._stageClicked = true;\n    });\n    // set image\n    this.image.interactive = true;\n    if (this.props.onBlankClick) {\n      this.image.on('mousedown', this.props.onBlankClick);\n    }\n    // add image to stage, always add to root\n    this.props.app.stage.addChildAt(this.image, 0);\n  }\n\n  componentDidMount() {\n    if (this.container.current) {\n      new ResizeObserver(this.resize).observe(this.container.current);\n      this.props.app.renderer.on('resolution-changed', this.resize);\n\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n      this.resize();\n\n      // load image\n      Loader.shared.onError.add(() => {\n        this.setState({ loadError: true });\n      });\n      this.loadImage();\n    }\n  }\n\n  componentDidUpdate(prevProps: CanvasProps) {\n    if (this.props.imageUrl !== prevProps.imageUrl) {\n      // reload image\n      this.loadImage();\n    } else if (this.props.rotation !== prevProps.rotation) {\n      // rotation changes\n      this.rotate();\n    }\n\n    if (this.props.interactive !== prevProps.interactive) {\n      // interactive changes\n      const interactive = this.props.interactive !== false;\n      this.props.app.stage.interactive = interactive;\n      this.image.interactive = interactive;\n      const setChildrenInteractive = (children: DisplayObject[]) => {\n        children.forEach((child) => {\n          if (child instanceof ShapeGraphics) {\n            // eslint-disable-next-line no-param-reassign\n            child.shape.interactive = interactive;\n          } else if (child instanceof Container) {\n            setChildrenInteractive(child.children);\n          }\n        });\n      };\n      setChildrenInteractive(this.props.app.stage.children);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.props.onMouseMove) {\n      this.props.onMouseMove(null);\n    }\n    if (this.image) {\n      this.image.destroy({\n        children: true,\n        texture: true,\n        baseTexture: true,\n      });\n    }\n    // reset stage\n    this.props.app.stage.removeChildren();\n    this.props.app.stage.scale.set(1);\n    this.props.app.stage.position.set(0, 0);\n    // remove listeners\n    this.props.app.renderer.off('resolution-changed', this.resize);\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x: number, y: number) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point: Point) {\n    return this.props.app.stage.toLocal(point);\n  }\n\n  /**\n   * get container's size, defualt is 800 * 600\n   */\n  getContainerSize() {\n    // default size is 800 * 600\n    const size = {\n      width: 800,\n      height: 600,\n    };\n    if (this.container.current) {\n      size.width = this.container.current.clientWidth;\n      size.height = this.container.current.clientHeight;\n    }\n    return size;\n  }\n\n  /**\n   * get renderer size\n   */\n  getViewSize() {\n    return {\n      width: this.props.app.renderer.width / window.devicePixelRatio,\n      height: this.props.app.renderer.height / window.devicePixelRatio,\n    };\n  }\n\n  /**\n   * get stage size\n   */\n  getStageSize() {\n    return {\n      width: this.props.app.stage.width,\n      height: this.props.app.stage.height,\n    };\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.props.app.stage.x,\n      y: this.props.app.stage.y,\n    };\n  }\n\n  /**\n   * set stage posistion\n   * @param x\n   * @param y\n   */\n  setStagePosition(x: number, y: number) {\n    this.props.app.stage.x = x;\n    this.props.app.stage.y = y;\n    if (this.props.onPositionChange) {\n      this.props.onPositionChange({ x, y });\n    }\n  }\n\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape?: Shape<unknown>) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape && !this.hoveredShape.destroyed) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n\n  /**\n   * set snapping point\n   * @param point\n   */\n  setSnappingPoint(point: Point | null) {\n    Layer.prototype.setSnappingPoint.call(this.props.app.stage, point);\n  }\n\n  /**\n   * get all shapes in stage\n   */\n  getAllShapes() {\n    const getShapes = (children: DisplayObject[]) => {\n      let shapes: Shape<ShapeData>[] = [];\n      for (let i = 0; i < children.length; i += 1) {\n        const child = children[i];\n        if (child.visible) {\n          if (child instanceof ShapeGraphics) {\n            if (child.shape.finished) {\n              shapes.push(child.shape);\n            }\n          } else if (child instanceof Container) {\n            shapes = [...shapes, ...getShapes(child.children)];\n          }\n        }\n      }\n      return shapes;\n    };\n    return getShapes(this.props.app.stage.children);\n  }\n\n  /**\n   * check if the point is in the stage\n   * @param point\n   */\n  isPointInStage(point: Point) {\n    const { x, y } = this.getStagePosition();\n    const { width, height } = this.getStageSize();\n    return point.x >= x && point.x <= x + width && point.y >= y && point.y <= y + height;\n  }\n\n  /**\n   * load image from image url\n   */\n  loadImage = () => {\n    this.setState({ loadError: false });\n\n    const { imageUrl } = this.props;\n    if (imageUrl) {\n      if (this.cancellableLoader) {\n        this.cancellableLoader.cancel();\n      }\n\n      this.cancellableLoader = {\n        cancelled: false,\n        cancel() {\n          this.cancelled = true;\n        },\n        load() {\n          return new Promise<Texture>((resove, reject) => {\n            Loader.shared\n              .reset()\n              .add({\n                url: imageUrl,\n                loadType: LoaderResource.LOAD_TYPE.IMAGE,\n                xhrType: LoaderResource.XHR_RESPONSE_TYPE.BLOB,\n              })\n              .load(() => {\n                utils.clearTextureCache();\n                if (!this.cancelled && Loader.shared.resources[imageUrl]) {\n                  resove(Loader.shared.resources[imageUrl].texture!);\n                } else {\n                  reject();\n                }\n              });\n          });\n        }\n      };\n\n      this.cancellableLoader\n        .load()\n        .then((texture: Texture) => {\n          this.image.texture.destroy(true);\n          this.image.texture = texture;\n          if (this.state.loadError) {\n            if (this.props.onImageLoadError) {\n              this.props.onImageLoadError(imageUrl);\n            }\n            return;\n          }\n\n          this.rotate();\n\n          if (!this.firstLoaded) {\n            this.firstLoaded = true;\n            this.fitImageToView();\n          } else if (this.props.keepZoom === false) {\n            this.fitImageToView();\n          }\n\n          if (this.props.onImageLoaded) {\n            // tell parent which image specific loaded\n            this.props.onImageLoaded(imageUrl, this.image);\n          }\n        })\n        .catch(() => {\n          // cancelled loader\n        });\n    } else {\n      this.setState({ loadError: true });\n      if (this.props.onImageLoadError) {\n        this.props.onImageLoadError(imageUrl);\n      }\n    }\n  };\n\n  /**\n   * resize\n   */\n  resize = () => {\n    const { width, height } = this.getContainerSize();\n    this.props.app.renderer.resize(width, height);\n    this.props.app.render();\n    // this.fitImageToView();\n  };\n\n  /**\n   * rotate\n   */\n  rotate = () => {\n    if (this.image) {\n      // set pivot\n      const { width, height } = this.image;\n      this.image.pivot.set(width / 2, height / 2);\n\n      // set position\n      let px = width / 2;\n      let py = height / 2;\n      if (this.props.rotation && this.props.rotation % Math.PI !== 0) {\n        px = height / 2;\n        py = width / 2;\n      }\n      const { x: ox, y: oy } = this.image.position;\n      this.image.position.set(px, py);\n      const offsetX = px - ox;\n      const offsetY = py - oy;\n\n      // set rotation\n      this.image.rotation = this.props.rotation || 0;\n\n      // update stage position\n      const { x, y } = this.getStagePosition();\n      this.setStagePosition(x - offsetX * this.scale, y - offsetY * this.scale);\n    }\n  };\n\n  /**\n   * zoom\n   * @param event zoom event\n   */\n  zoom = (event: React.WheelEvent) => {\n    if (this.state.loadError) {\n      return;\n    }\n\n    event.stopPropagation();\n    const { maxZoom = ZOOM_MAX, minZoom = ZOOM_MIN } = this.props;\n    const zoomPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n    let newZoom = event.deltaY > 0 ? this.zoomLevel / 1.1 : this.zoomLevel * 1.1;\n    newZoom = Math.max(Math.min(newZoom, maxZoom), minZoom);\n    const zoomScale = newZoom / this.zoomLevel;\n    const { x, y } = this.getStagePosition();\n    this.setStagePosition(zoomPoint.x - (zoomPoint.x - x) * zoomScale, zoomPoint.y - (zoomPoint.y - y) * zoomScale);\n    this.zoomLevel = newZoom;\n    this.scale *= zoomScale;\n  };\n\n  /**\n   * zoom to provided scale\n   * @param scale\n   */\n  zoomTo = (scale: number) => {\n    if (this.state.loadError) {\n      return;\n    }\n    if (this.container.current) {\n      const { left, top, width, height } = this.container.current?.getBoundingClientRect();\n      const center = this.mapScreenToStagePosition(left + width / 2, top + height / 2);\n      const { maxZoom = ZOOM_MAX, minZoom = ZOOM_MIN } = this.props;\n      let newZoom = this.zoomLevel * (scale / this.scale);\n      newZoom = Math.max(Math.min(newZoom, maxZoom), minZoom);\n      const zoomScale = newZoom / this.zoomLevel;\n      const { x, y } = this.getStagePosition();\n      this.setStagePosition(center.x - (center.x - x) * zoomScale, center.y - (center.y - y) * zoomScale);\n      this.zoomLevel = newZoom;\n      this.scale *= zoomScale;\n    }\n  };\n\n  /**\n   * fit image to canvas\n   */\n  fitImageToView = () => {\n    if (this.state.loadError) {\n      return;\n    }\n    if (this.image) {\n      const { width: viewWidth, height: viewHeight } = this.getViewSize();\n      let { width: imageWidth, height: imageHeight } = this.image;\n      if (this.props.rotation && this.props.rotation % Math.PI !== 0) {\n        const w = imageWidth;\n        imageWidth = imageHeight;\n        imageHeight = w;\n      }\n      const viewRatio = viewWidth / viewHeight;\n      const imgRatio = imageWidth / imageHeight;\n      const scale = (viewRatio < imgRatio ? viewWidth / imageWidth : viewHeight / imageHeight) * 0.98;\n      this.setStagePosition((viewWidth - scale * imageWidth) / 2, (viewHeight - scale * imageHeight) / 2);\n      this.scale = scale;\n\n      // when fits canvas, zoom level should be 1\n      this.zoomLevel = 1;\n    }\n  };\n\n  /**\n   * fit shape to canvas\n   * @param bbox\n   * @param percentage\n   */\n  fitShapeToView = (bbox: { left: number; top: number; right: number; bottom: number }, percentage = 0.98) => {\n    if (this.state.loadError) {\n      return;\n    }\n    const { left, top, right, bottom } = bbox;\n    const width = right - left;\n    const height = bottom - top;\n    if (width !== 0 && height !== 0) {\n      const { maxZoom = ZOOM_MAX, minZoom = ZOOM_MIN } = this.props;\n      const oldViewScale = this.scale;\n      const { width: viewWidth, height: viewHeight } = this.getViewSize();\n      const viewRatio = viewWidth / viewHeight;\n      const ratio = width / height;\n      let scale = (viewRatio < ratio ? viewWidth / width : viewHeight / height) * percentage;\n      let zoomScale = scale / oldViewScale;\n      let zoomLevel = Math.max(Math.min(this.zoomLevel * zoomScale, maxZoom), minZoom);\n      if (zoomLevel < 1) {\n        zoomLevel = 1;\n        zoomScale = zoomLevel / this.zoomLevel;\n        scale = zoomScale * oldViewScale;\n      }\n      this.scale = scale;\n      this.setStagePosition(viewWidth / 2 - this.scale * (left + width / 2), viewHeight / 2 - this.scale * (top + height / 2));\n      this.zoomLevel *= zoomScale;\n    }\n  };\n\n  /**\n   * start select\n   */\n  startSelect = () => {\n    this._selecting = true;\n    this.props.app.stage.addChild(this.selectorPath);\n  };\n\n  /**\n   * finish select\n   */\n  finishSelect() {\n    if (this._selecting && this.selectorPathPoints.length > 0) {\n      // check selected\n      const selectorPathData = [[[...this.selectorPathPoints].map((p) => [p.x, p.y] as [number, number])]];\n      const selectorPathBounds = this.selectorPath.getLocalBounds();\n      const allShapes = this.getAllShapes();\n      const intersections = findIntersections(selectorPathData, selectorPathBounds, ShapeType.POLYGON, allShapes);\n      if (this.props.onShapesSelect) {\n        this.props.onShapesSelect(intersections.map((i) => i.uid));\n      }\n\n      const shapePointsMap: { [shapeId: string]: number[] } = {};\n      for (let i = 0; i < intersections.length; i += 1) {\n        const intersection = intersections[i];\n        if (intersection.shapeType === ShapeType.POLYGON || intersection.shapeType === ShapeType.LINE || intersection.shapeType === ShapeType.ARROW) {\n          // check points selected\n          const selectorPathArea = new PPolygon(this.selectorPathPoints);\n          const { points } = (intersection as Polygon | Line);\n          const selectedPointsIndex = [];\n          for (let j = 0; j < points.length; j += 1) {\n            if (selectorPathArea.contains(points[j].x, points[j].y)) {\n              selectedPointsIndex.push(j);\n            }\n          }\n          if (selectedPointsIndex.length > 0) {\n            shapePointsMap[intersection.uid] = selectedPointsIndex;\n          }\n        }\n      }\n      if (Object.keys(shapePointsMap).length > 0 && this.props.onPointsSelect) {\n        this.props.onPointsSelect(shapePointsMap);\n      }\n    }\n    this._selecting = false;\n    this.props.app.stage.removeChild(this.selectorPath);\n    this.selectorPathPoints = [];\n    this.drawSelectorPath();\n  }\n\n  /**\n   * draw path\n   */\n  drawSelectorPath() {\n    this.selectorPath.clear();\n    if (this.selectorPathPoints.length > 0) {\n      this.selectorPath.lineStyle(2 / this.scale, 0xFF0000);\n      this.selectorPath.moveTo(this.selectorPathPoints[0].x, this.selectorPathPoints[0].y);\n      for (let i = 1; i < this.selectorPathPoints.length; i += 1) {\n        this.selectorPath.lineTo(this.selectorPathPoints[i].x, this.selectorPathPoints[i].y);\n      }\n    }\n  }\n\n  /**\n   * canvas dom mouse down\n   * @param event\n   */\n  handleMouseDown = (event: React.MouseEvent) => {\n    if (this.state.loadError) {\n      return;\n    }\n\n    const point = this.mapScreenToStagePosition(event.clientX, event.clientY);\n\n    if (event.button === 2) {\n      const currentPosistion = this.getStagePosition();\n      this._rightClickPosition = new Point(currentPosistion.x, currentPosistion.y);\n      this._rightClickPoint = point;\n      this._rightClicked = true;\n      return;\n    }\n\n    // if click outside of the image\n    if (!this.isPointInStage(point) && !this._stageClicked && this.props.onBlankClick) {\n      this.props.onBlankClick();\n    }\n\n    // canvas mouse down\n    const localPoint = this.mapStageToLocalPosition(point);\n    if (this.props.onClick) {\n      this.props.onClick(localPoint);\n    }\n\n    this._stageClicked = false;\n  };\n\n  /**\n   * canvas dom mouse move\n   * @param event\n   */\n  handleMouseMove = (event: React.MouseEvent) => {\n    if (this.state.loadError) {\n      return;\n    }\n\n    const currentPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n    const localPoint = this.mapStageToLocalPosition(currentPoint);\n    if (this.props.onMouseMove) {\n      this.props.onMouseMove(localPoint);\n    }\n\n    if (this._rightClicked && this._rightClickPoint && this._rightClickPosition) {\n      const offsetX = currentPoint.x - this._rightClickPoint.x;\n      const offsetY = currentPoint.y - this._rightClickPoint.y;\n      const x = this._rightClickPosition.x + offsetX;\n      const y = this._rightClickPosition.y + offsetY;\n      this.setStagePosition(x, y);\n      return;\n    }\n\n    if (this._selecting) {\n      this.selectorPathPoints.push(localPoint);\n      this.drawSelectorPath();\n      return;\n    }\n\n    if (!event.ctrlKey) {\n      const { intersection, snappingPoint } = hitTesting(currentPoint, localPoint, this.props.app.stage.children);\n      this.setHoveredShape(intersection);\n      this.setSnappingPoint(snappingPoint);\n    } else {\n      this.setHoveredShape();\n      this.setSnappingPoint(null);\n    }\n  };\n\n  /**\n   * canvas dom mouse up\n   */\n  handleMouseUp = () => {\n    this.finishSelect();\n    this._rightClickPosition = null;\n    this._rightClickPoint = null;\n    this._rightClicked = false;\n  };\n\n  /**\n   * canvas dom mouse leave\n   */\n  handleMouseLeave = () => {\n    this.handleMouseUp();\n    this.setHoveredShape();\n  };\n\n  render() {\n    return (\n      <>\n        <div\n          className=\"canvas-container\"\n          ref={this.container}\n          style={{ ...this.props.style, width: '100%', height: '100%' }}\n          onWheel={this.zoom}\n          onMouseDown={this.handleMouseDown}\n          onMouseMove={this.handleMouseMove}\n          onMouseUp={this.handleMouseUp}\n          onMouseLeave={this.handleMouseLeave}\n          onContextMenu={(e) => e.preventDefault()}\n        />\n        {this.state.loadError && (\n          <div className=\"canvas-error\">\n            {this.props.imageLoadErrorMsg || 'Failed to load image'}\n          </div>\n        )}\n        <Assistant\n          element=\".canvas-container\"\n          scale={this.state.scale}\n          crossline={this.props.crossline}\n          measurementBox={this.props.measurementBox}\n        />\n      </>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}