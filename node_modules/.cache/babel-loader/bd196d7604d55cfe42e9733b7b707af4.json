{"ast":null,"code":"import { v4 as uuid } from 'uuid';\nimport { notification } from 'antd';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { translate, triggerForm } from '../../constants';\nexport const createSegment = (start, end, segmentConfig, lineConfig) => {\n  start = Number.isNaN(parseFloat(start)) ? 0 : start;\n  end = Number.isNaN(parseFloat(end)) ? null : end;\n  const defaultValues = {};\n  segmentConfig.fields.forEach(value => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    id: uuid(),\n    start,\n    end,\n    qaChecked: undefined,\n    qaComment: '',\n    qaReason: null,\n    attributes: defaultValues,\n    content: [createLine('none', lineConfig)]\n  };\n};\nexport const createLine = (role, lineConfig) => {\n  const defaultValues = {};\n  lineConfig.fields.forEach(value => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    role: role || 'none',\n    text: '',\n    attributes: defaultValues\n  };\n};\nexport const getVideoContainer = (state, data) => {\n  const {\n    videoContainer\n  } = data;\n  const {\n    wavesurfers\n  } = state;\n  wavesurfers.getVideoContainer(videoContainer);\n  return state;\n};\nexport const getAudioContainer = (state, data) => {\n  const {\n    waveform,\n    timeline,\n    audioContainer,\n    minimap\n  } = data;\n  const {\n    wavesurfers\n  } = state;\n  wavesurfers.getAudioContainer(waveform, timeline, audioContainer, minimap);\n  return state;\n};\nexport const segmentDeepClone = (results, videoIndex, segmentIndex) => {\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments[segmentIndex] = {\n    ...segments[segmentIndex]\n  };\n  const segment = segments[segmentIndex];\n  return segment;\n};\nconst lineDeepClone = (results, videoIndex, segmentIndex, lineIndex) => {\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const {\n    content\n  } = segment;\n  content[lineIndex] = {\n    ...content[lineIndex]\n  };\n  const line = content[lineIndex];\n  return line;\n};\nexport const setLineText = (state, data) => {\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    lineIndex,\n    text\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.text = text;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setLineRole = (state, data) => {\n  const {\n    lineIndex,\n    role\n  } = data;\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment,\n    wavesurfers\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map(value => value.role);\n  if (roles.indexOf(role) >= 0) return state;\n  const prevRole = line.role;\n  line.role = role;\n  wavesurfers.setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole);\n  return {\n    ...state,\n    results\n  };\n};\nexport const setLineCategory = (state, data) => {\n  const {\n    lineIndex,\n    key,\n    value\n  } = data;\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.attributes = {\n    ...line.attributes\n  };\n  const {\n    attributes\n  } = line;\n  attributes[key] = value;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentType = (state, data) => {\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    value\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.type = value;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentCategory = (state, data) => {\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    key,\n    value\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.attributes = {\n    ...segment.attributes\n  };\n  const {\n    attributes\n  } = segment;\n  attributes[key] = value;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentTimestamp = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let {\n    videoIndex,\n    segmentIndex,\n    start,\n    end\n  } = data;\n  const {\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  if (start !== undefined && start !== null) segment.start = start;\n  if (end !== undefined && end !== null) segment.end = end;\n  return {\n    ...state,\n    results\n  };\n};\nexport const moveSegmentInBatch = (state, data) => {\n  let {\n    videoIndex\n  } = data;\n  const {\n    min,\n    max,\n    step\n  } = data;\n  const {\n    currentVideo /* , results */\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.forEach((segment, i) => {\n    segments[i] = {\n      ...segments[i]\n    };\n    if (segments[i].start > min) {\n      segments[i].start = segments[i].start + step < min ? min : segments[i].start + step;\n    }\n    if (segments[i].end < max) {\n      segments[i].end = segments[i].end + step > max ? max : segments[i].end + step;\n    }\n  });\n  // segments[segmentIndex] = { ...segments[segmentIndex] };\n  // const segment = segments[segmentIndex];\n  // return segment;\n\n  // results[videoIndex] = results[videoIndex].map((segment) => {\n  //   const newSegment = segmentDeepClone()//deepClone(segment);\n  //   if (newSegment.start > min) {\n  //     newSegment.start = newSegment.start + step < min ? min : newSegment.start + step;\n  //   }\n  //   if (newSegment.end < max) {\n  //     newSegment.end = newSegment.end + step > max ? max : newSegment.end + step;\n  //   }\n  //   return newSegment;\n  // });\n  return {\n    ...state,\n    results\n  };\n};\nconst deepClone = item => JSON.parse(JSON.stringify(item));\nexport const mergeSegmentBackward = (state, data) => {\n  let {\n    videoIndex\n  } = data;\n  const {\n    segmentIndex\n  } = data;\n  const {\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = results[videoIndex][segmentIndex];\n  const prevSegment = results[videoIndex][segmentIndex - 1];\n  const prevRoles = [];\n  prevSegment.content.forEach(line => {\n    prevRoles.push(line.role);\n  });\n  nextSegment.content.forEach(line => {\n    if (prevRoles.indexOf(line.role) >= 0) {\n      const i = prevRoles.indexOf(line.role);\n      prevSegment.content[i].text += line.text;\n    } else if (line.role !== 'none') prevSegment.content.push(line);\n  });\n  results[videoIndex].splice(segmentIndex, 1);\n  return {\n    ...state,\n    results\n  };\n};\nexport const splitSegmentForward = (state, data) => {\n  const {\n    segmentIndex,\n    start,\n    end,\n    prevRules,\n    nextRules\n  } = data;\n  let {\n    videoIndex\n  } = data;\n  const {\n    segmentConfig,\n    lineConfig,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = createSegment(start, end, segmentConfig, lineConfig);\n  results[videoIndex].splice(segmentIndex + 1, 0, nextSegment);\n  if (prevRules && nextRules) {\n    const prevSegment = results[videoIndex][segmentIndex];\n    prevSegment.content = [];\n    nextSegment.content = [];\n    prevRules.forEach(rule => prevSegment.content.push(createLine(rule.role, lineConfig)));\n    nextRules.forEach(rule => nextSegment.content.push(createLine(rule.role, lineConfig)));\n  }\n  return {\n    ...state,\n    results\n  };\n};\nexport const pushLine = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let {\n    segmentIndex,\n    role,\n    lineIndex,\n    videoIndex\n  } = data;\n  const {\n    wavesurfers,\n    lineConfig,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const {\n    content,\n    start,\n    end\n  } = segment;\n  lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? content.length : lineIndex;\n  wavesurfers.insertLine({\n    role,\n    videoIndex,\n    segmentIndex,\n    lineIndex,\n    start,\n    end\n  });\n  data.lineIndex = lineIndex;\n  wavesurfers.addHistory('pushLine', data);\n  content.push(createLine(role, lineConfig));\n  return {\n    ...state,\n    results\n  };\n};\nexport const deleteLine = (state, data) => {\n  const {\n    segmentIndex,\n    lineIndex\n  } = data;\n  let {\n    videoIndex\n  } = data;\n  const {\n    wavesurfers,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  segment.content.splice(lineIndex, 1);\n  wavesurfers.deleteLine(data);\n  wavesurfers.addHistory('deleteLine', data);\n  return {\n    ...state,\n    results\n  };\n};\nexport const toppingLine = (state, data) => {\n  const {\n    segmentIndex,\n    lineIndex\n  } = data;\n  let {\n    videoIndex\n  } = data;\n  const {\n    wavesurfers,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const line = JSON.parse(JSON.stringify(segment.content[lineIndex]));\n  segment.content.splice(lineIndex, 1);\n  segment.content.unshift(line);\n  wavesurfers.toppingLine(data);\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentQAState = (state, data) => {\n  const {\n    qaChecked\n  } = data;\n  let {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaChecked = qaChecked;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentQAComment = (state, data) => {\n  const {\n    qaComment\n  } = data;\n  let {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaComment = qaComment;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentQAReason = (state, data) => {\n  const {\n    qaReason\n  } = data;\n  let {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaReason = qaReason;\n  return {\n    ...state,\n    results\n  };\n};\nexport const removeSegment = (state, data) => {\n  const {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.splice(segmentIndex, 1);\n  return {\n    ...state,\n    results\n  };\n};\nexport const appendSegment = (state, data) => {\n  const {\n    segment,\n    segmentIndex,\n    videoIndex: vIndex\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  if (segmentIndex !== undefined) {\n    results[videoIndex].splice(segmentIndex, 0, segment);\n  } else {\n    results[videoIndex].push(segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return {\n    ...state,\n    results,\n    currentSegment: index\n  };\n};\nexport const updateSegment = (state, data) => {\n  const {\n    segment,\n    videoIndex: vIndex\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  const segmentIndex = results[videoIndex].findIndex(seg => seg.id === segment.id);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1, segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return {\n    ...state,\n    results,\n    currentSegment: index\n  };\n};\nexport const deleteSegment = (state, data) => {\n  const {\n    segmentIndex,\n    videoIndex: vIndex\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1);\n  }\n  return {\n    ...state,\n    results\n  };\n};\nexport const updateLineRole = (state, data) => {\n  const {\n    videoIndex: vIndex,\n    segmentIndex: sIndex,\n    lineIndex,\n    role\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n  const results = deepClone(state.results);\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map(value => value.role);\n  if (roles.indexOf(role) >= 0) {\n    return state;\n  }\n  line.role = role;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentStartEnd = (state, data) => {\n  const {\n    videoIndex: vIndex,\n    segmentIndex: sIndex,\n    start,\n    end\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n  const results = deepClone(state.results);\n  const segment = results[videoIndex][segmentIndex];\n  segment.start = start;\n  segment.end = end;\n  state.wavesurfers.setSegmentStartEnd(videoIndex, segmentIndex, start, end);\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return {\n    ...state,\n    results,\n    currentSegment: index\n  };\n};\nexport const verifyCurrentForm = (state, action) => {\n  if (isAnnotationReadonly(state.toolMode)) return true;\n  const {\n    results,\n    segmentConfig,\n    currentVideo,\n    currentSegment,\n    keyAttribute,\n    lineConfig\n  } = state;\n  const currentValues = results[currentVideo][currentSegment];\n  if (currentSegment < 0) return true;\n  const updatedSegment = triggerForm({\n    ...segmentConfig,\n    fields: [...segmentConfig.fields, ...keyAttribute.options]\n  }, currentValues.attributes);\n  // add segment default values\n  currentValues.attributes = updatedSegment.updatedValues;\n  const segmentFields = updatedSegment.updatedFields;\n  const line = currentValues && currentValues.content && currentValues.content.length ? currentValues.content[0] : {};\n  const updatedLine = triggerForm(lineConfig, line.attributes);\n  // add line default values\n  line.attributes = updatedLine.updatedValues;\n  const lineFields = updatedLine.updatedFields;\n  const newFields = [...segmentFields, ...lineFields];\n  const index = newFields.findIndex(v => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  if (index < 0) return {\n    result: true,\n    data: currentValues\n  };\n  const err = `${translate('DATA_ERROR_REQUIRED')} ${newFields[index].label}. Segment ${currentSegment + 1}`;\n  if (action !== 'nohint') {\n    notification.error({\n      message: err\n    });\n  }\n  return {\n    result: false,\n    error: err\n  };\n};\nexport const isInput = () => document.activeElement.tagName === 'INPUT' && (document.activeElement.type === 'text' || document.activeElement.type === 'number') || document.activeElement.tagName === 'TEXTAREA';","map":{"version":3,"names":["v4","uuid","notification","isAnnotationReadonly","translate","triggerForm","createSegment","start","end","segmentConfig","lineConfig","Number","isNaN","parseFloat","defaultValues","fields","forEach","value","defaultValue","name","id","qaChecked","undefined","qaComment","qaReason","attributes","content","createLine","role","text","getVideoContainer","state","data","videoContainer","wavesurfers","getAudioContainer","waveform","timeline","audioContainer","minimap","segmentDeepClone","results","videoIndex","segmentIndex","segments","segment","lineDeepClone","lineIndex","line","setLineText","currentVideo","currentSegment","parseInt","setLineRole","roles","map","indexOf","prevRole","setLineColor","setLineCategory","key","setSegmentType","type","setSegmentCategory","setSegmentTimestamp","moveSegmentInBatch","min","max","step","i","deepClone","item","JSON","parse","stringify","mergeSegmentBackward","nextSegment","prevSegment","prevRoles","push","splice","splitSegmentForward","prevRules","nextRules","rule","pushLine","length","insertLine","addHistory","deleteLine","toppingLine","unshift","setSegmentQAState","setSegmentQAComment","setSegmentQAReason","removeSegment","appendSegment","vIndex","sort","a","b","index","updateSegment","findIndex","seg","deleteSegment","updateLineRole","sIndex","setSegmentStartEnd","verifyCurrentForm","action","toolMode","keyAttribute","currentValues","updatedSegment","options","updatedValues","segmentFields","updatedFields","updatedLine","lineFields","newFields","v","required","readonly","visible","result","err","label","error","message","isInput","document","activeElement","tagName"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/redux/reducer/segmentController.js"],"sourcesContent":["import { v4 as uuid } from 'uuid';\nimport { notification } from 'antd';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { translate, triggerForm } from '../../constants';\n\nexport const createSegment = (start, end, segmentConfig, lineConfig) => {\n  start = Number.isNaN(parseFloat(start)) ? 0 : start;\n  end = Number.isNaN(parseFloat(end)) ? null : end;\n  const defaultValues = {};\n  segmentConfig.fields.forEach((value) => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    id: uuid(),\n    start,\n    end,\n    qaChecked: undefined,\n    qaComment: '',\n    qaReason: null,\n    attributes: defaultValues,\n    content: [createLine('none', lineConfig)],\n  };\n};\n\nexport const createLine = (role, lineConfig) => {\n  const defaultValues = {};\n  lineConfig.fields.forEach((value) => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    role: role || 'none',\n    text: '',\n    attributes: defaultValues,\n  };\n};\n\nexport const getVideoContainer = (state, data) => {\n  const { videoContainer } = data;\n  const { wavesurfers } = state;\n  wavesurfers.getVideoContainer(videoContainer);\n  return state;\n};\n\nexport const getAudioContainer = (state, data) => {\n  const { waveform, timeline, audioContainer, minimap } = data;\n  const { wavesurfers } = state;\n  wavesurfers.getAudioContainer(waveform, timeline, audioContainer, minimap);\n  return state;\n};\n\nexport const segmentDeepClone = (results, videoIndex, segmentIndex) => {\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments[segmentIndex] = { ...segments[segmentIndex] };\n  const segment = segments[segmentIndex];\n  return segment;\n};\n\nconst lineDeepClone = (results, videoIndex, segmentIndex, lineIndex) => {\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const { content } = segment;\n  content[lineIndex] = { ...content[lineIndex] };\n  const line = content[lineIndex];\n  return line;\n};\n\nexport const setLineText = (state, data) => {\n  let { videoIndex, segmentIndex } = data;\n  const { lineIndex, text } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.text = text;\n  return { ...state, results };\n};\n\nexport const setLineRole = (state, data) => {\n  const { lineIndex, role } = data;\n  let { videoIndex, segmentIndex } = data;\n  const { currentVideo, currentSegment, wavesurfers } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map((value) => value.role);\n  if (roles.indexOf(role) >= 0) return state;\n  const prevRole = line.role;\n  line.role = role;\n  wavesurfers.setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole);\n  return { ...state, results };\n};\n\nexport const setLineCategory = (state, data) => {\n  const { lineIndex, key, value } = data;\n  let { videoIndex, segmentIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.attributes = { ...line.attributes };\n  const { attributes } = line;\n  attributes[key] = value;\n  return { ...state, results };\n};\n\nexport const setSegmentType = (state, data) => {\n  let { videoIndex, segmentIndex } = data;\n  const { value } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.type = value;\n  return { ...state, results };\n};\n\nexport const setSegmentCategory = (state, data) => {\n  let { videoIndex, segmentIndex } = data;\n  const { key, value } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.attributes = { ...segment.attributes };\n  const { attributes } = segment;\n  attributes[key] = value;\n  return { ...state, results };\n};\n\nexport const setSegmentTimestamp = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let { videoIndex, segmentIndex, start, end } = data;\n  const { currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  if (start !== undefined && start !== null) segment.start = start;\n  if (end !== undefined && end !== null) segment.end = end;\n  return { ...state, results };\n};\n\nexport const moveSegmentInBatch = (state, data) => {\n  let { videoIndex } = data;\n  const { min, max, step } = data;\n  const { currentVideo/* , results */ } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.forEach((segment, i) => {\n    segments[i] = { ...segments[i] };\n    if (segments[i].start > min) {\n      segments[i].start = segments[i].start + step < min ? min : segments[i].start + step;\n    }\n    if (segments[i].end < max) {\n      segments[i].end = segments[i].end + step > max ? max : segments[i].end + step;\n    }\n  });\n  // segments[segmentIndex] = { ...segments[segmentIndex] };\n  // const segment = segments[segmentIndex];\n  // return segment;\n\n  // results[videoIndex] = results[videoIndex].map((segment) => {\n  //   const newSegment = segmentDeepClone()//deepClone(segment);\n  //   if (newSegment.start > min) {\n  //     newSegment.start = newSegment.start + step < min ? min : newSegment.start + step;\n  //   }\n  //   if (newSegment.end < max) {\n  //     newSegment.end = newSegment.end + step > max ? max : newSegment.end + step;\n  //   }\n  //   return newSegment;\n  // });\n  return { ...state, results };\n};\n\nconst deepClone = (item) => JSON.parse(JSON.stringify(item));\n\nexport const mergeSegmentBackward = (state, data) => {\n  let { videoIndex } = data;\n  const { segmentIndex } = data;\n  const { currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = results[videoIndex][segmentIndex];\n  const prevSegment = results[videoIndex][segmentIndex - 1];\n  const prevRoles = [];\n  prevSegment.content.forEach((line) => {\n    prevRoles.push(line.role);\n  });\n  nextSegment.content.forEach((line) => {\n    if (prevRoles.indexOf(line.role) >= 0) {\n      const i = prevRoles.indexOf(line.role);\n      prevSegment.content[i].text += line.text;\n    } else if (line.role !== 'none') prevSegment.content.push(line);\n  });\n  results[videoIndex].splice(segmentIndex, 1);\n  return { ...state, results };\n};\n\nexport const splitSegmentForward = (state, data) => {\n  const { segmentIndex, start, end, prevRules, nextRules } = data;\n  let { videoIndex } = data;\n  const { segmentConfig, lineConfig, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = createSegment(start, end, segmentConfig, lineConfig);\n  results[videoIndex].splice(segmentIndex + 1, 0, nextSegment);\n  if (prevRules && nextRules) {\n    const prevSegment = results[videoIndex][segmentIndex];\n    prevSegment.content = [];\n    nextSegment.content = [];\n    prevRules.forEach((rule) => prevSegment.content.push(createLine(rule.role, lineConfig)));\n    nextRules.forEach((rule) => nextSegment.content.push(createLine(rule.role, lineConfig)));\n  }\n  return { ...state, results };\n};\n\nexport const pushLine = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let { segmentIndex, role, lineIndex, videoIndex } = data;\n  const { wavesurfers, lineConfig, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const { content, start, end } = segment;\n  lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? content.length : lineIndex;\n  wavesurfers.insertLine({ role, videoIndex, segmentIndex, lineIndex, start, end });\n  data.lineIndex = lineIndex;\n  wavesurfers.addHistory('pushLine', data);\n  content.push(createLine(role, lineConfig));\n  return { ...state, results };\n};\n\nexport const deleteLine = (state, data) => {\n  const { segmentIndex, lineIndex } = data;\n  let { videoIndex } = data;\n  const { wavesurfers, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  segment.content.splice(lineIndex, 1);\n  wavesurfers.deleteLine(data);\n  wavesurfers.addHistory('deleteLine', data);\n  return {\n    ...state,\n    results,\n  };\n};\n\nexport const toppingLine = (state, data) => {\n  const { segmentIndex, lineIndex } = data;\n  let { videoIndex } = data;\n  const { wavesurfers, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const line = JSON.parse(JSON.stringify(segment.content[lineIndex]));\n  segment.content.splice(lineIndex, 1);\n  segment.content.unshift(line);\n  wavesurfers.toppingLine(data);\n\n  return { ...state, results };\n};\n\nexport const setSegmentQAState = (state, data) => {\n  const { qaChecked } = data;\n  let { segmentIndex, videoIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaChecked = qaChecked;\n\n  return { ...state, results };\n};\n\nexport const setSegmentQAComment = (state, data) => {\n  const { qaComment } = data;\n  let { segmentIndex, videoIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaComment = qaComment;\n\n  return { ...state, results };\n};\n\nexport const setSegmentQAReason = (state, data) => {\n  const { qaReason } = data;\n  let { segmentIndex, videoIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaReason = qaReason;\n\n  return { ...state, results };\n};\n\nexport const removeSegment = (state, data) => {\n  const { segmentIndex, videoIndex } = data;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.splice(segmentIndex, 1);\n  return { ...state, results };\n};\n\nexport const appendSegment = (state, data) => {\n  const { segment, segmentIndex, videoIndex: vIndex } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  if (segmentIndex !== undefined) {\n    results[videoIndex].splice(segmentIndex, 0, segment);\n  } else {\n    results[videoIndex].push(segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return { ...state, results, currentSegment: index };\n};\n\nexport const updateSegment = (state, data) => {\n  const { segment, videoIndex: vIndex } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  const segmentIndex = results[videoIndex].findIndex((seg) => seg.id === segment.id);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1, segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return { ...state, results, currentSegment: index };\n};\n\nexport const deleteSegment = (state, data) => {\n  const { segmentIndex, videoIndex: vIndex } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1);\n  }\n  return { ...state, results };\n};\n\nexport const updateLineRole = (state, data) => {\n  const { videoIndex: vIndex, segmentIndex: sIndex, lineIndex, role } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n\n  const results = deepClone(state.results);\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map((value) => value.role);\n  if (roles.indexOf(role) >= 0) {\n    return state;\n  }\n  line.role = role;\n  return { ...state, results };\n};\n\nexport const setSegmentStartEnd = (state, data) => {\n  const { videoIndex: vIndex, segmentIndex: sIndex, start, end } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n  const results = deepClone(state.results);\n  const segment = results[videoIndex][segmentIndex];\n  segment.start = start;\n  segment.end = end;\n  state.wavesurfers.setSegmentStartEnd(videoIndex, segmentIndex, start, end);\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return { ...state, results, currentSegment: index };\n};\n\nexport const verifyCurrentForm = (state, action) => {\n  if (isAnnotationReadonly(state.toolMode)) return true;\n  const { results, segmentConfig, currentVideo, currentSegment, keyAttribute, lineConfig } = state;\n  const currentValues = results[currentVideo][currentSegment];\n  if (currentSegment < 0) return true;\n  const updatedSegment = triggerForm({\n    ...segmentConfig,\n    fields: [...segmentConfig.fields, ...keyAttribute.options]\n  }, currentValues.attributes);\n  // add segment default values\n  currentValues.attributes = updatedSegment.updatedValues;\n  const segmentFields = updatedSegment.updatedFields;\n\n  const line = currentValues && currentValues.content && currentValues.content.length ? currentValues.content[0] : {};\n  const updatedLine = triggerForm(lineConfig, line.attributes);\n  // add line default values\n  line.attributes = updatedLine.updatedValues;\n  const lineFields = updatedLine.updatedFields;\n  const newFields = [...segmentFields, ...lineFields];\n  const index = newFields.findIndex((v) => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  if (index < 0) return { result: true, data: currentValues };\n  const err = `${translate('DATA_ERROR_REQUIRED')} ${newFields[index].label}. Segment ${currentSegment + 1}`;\n  if (action !== 'nohint') {\n    notification.error({ message: err });\n  }\n  return { result: false, error: err };\n};\n\nexport const isInput = () => (document.activeElement.tagName === 'INPUT' && (document.activeElement.type === 'text' || document.activeElement.type === 'number')) || document.activeElement.tagName === 'TEXTAREA';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}