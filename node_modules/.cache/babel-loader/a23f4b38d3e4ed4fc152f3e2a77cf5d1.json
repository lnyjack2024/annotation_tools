{"ast":null,"code":"/**\n * @typedef {Object} ListenerDescriptor\n * @property {string} name The name of the event\n * @property {function} callback The callback\n * @property {function} un The function to call to remove the listener\n */\n\n/**\n * Observer class\n */\nexport default class Observer {\n  /**\n   * Instantiate Observer\n   */\n  constructor() {\n    /**\n     * @private\n     * @todo Initialise the handlers here already and remove the conditional\n     * assignment in `on()`\n     */\n    this._disabledEventEmissions = [];\n    this.handlers = null;\n  }\n\n  /**\n   * Attach a handler function for an event.\n   *\n   * @param {string} event Name of the event to listen to\n   * @param {function} fn The callback to trigger when the event is fired\n   * @return {ListenerDescriptor} The event descriptor\n   */\n  on(event, fn) {\n    if (!this.handlers) {\n      this.handlers = {};\n    }\n    let handlers = this.handlers[event];\n    if (!handlers) {\n      handlers = [];\n      this.handlers[event] = handlers;\n    }\n    handlers.push(fn);\n\n    // Return an event descriptor\n    return {\n      name: event,\n      callback: fn,\n      un: (e, call) => this.un(e, call)\n    };\n  }\n\n  /**\n     * Remove an event handler.\n     *\n     * @param {string} event Name of the event the listener that should be\n     * removed listens to\n     * @param {function} fn The callback that should be removed\n     */\n  un(event, fn) {\n    if (!this.handlers) {\n      return;\n    }\n    const handlers = this.handlers[event];\n    let i;\n    if (handlers) {\n      if (fn) {\n        for (i = handlers.length - 1; i >= 0; i -= 1) {\n          if (handlers[i] === fn) {\n            handlers.splice(i, 1);\n          }\n        }\n      } else {\n        handlers.length = 0;\n      }\n    }\n  }\n\n  /**\n     * Remove all event handlers.\n     */\n  unAll() {\n    this.handlers = null;\n  }\n\n  /**\n     * Attach a handler to an event. The handler is executed at most once per\n     * event type.\n     *\n     * @param {string} event The event to listen to\n     * @param {function} handler The callback that is only to be called once\n     * @return {ListenerDescriptor} The event descriptor\n     */\n  once(event, handler) {\n    const fn = (...args) => {\n      /*  eslint-disable no-invalid-this */\n      handler.apply(this, args);\n      /*  eslint-enable no-invalid-this */\n      setTimeout(() => {\n        this.un(event, fn);\n      }, 0);\n    };\n    return this.on(event, fn);\n  }\n\n  /**\n     * Disable firing a list of events by name. When specified, event handlers for any event type\n     * passed in here will not be called.\n     *\n     * @since 4.0.0\n     * @param {string[]} eventNames an array of event names to disable emissions for\n     * @example\n     * // disable seek and interaction events\n     * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);\n     */\n  setDisabledEventEmissions(eventNames) {\n    this._disabledEventEmissions = eventNames;\n  }\n\n  /**\n     * plugins borrow part of this class without calling the constructor,\n     * so we have to be careful about _disabledEventEmissions\n     */\n\n  _isDisabledEventEmission(event) {\n    return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);\n  }\n\n  /**\n     * Manually fire an event\n     *\n     * @param {string} event The event to fire manually\n     * @param {...any} args The arguments with which to call the listeners\n     */\n  fireEvent(event, ...args) {\n    if (!this.handlers || this._isDisabledEventEmission(event)) {\n      return;\n    }\n    const handlers = this.handlers[event];\n    if (handlers) {\n      handlers.forEach(fn => {\n        fn(...args);\n      });\n    }\n  }\n}","map":{"version":3,"names":["Observer","constructor","_disabledEventEmissions","handlers","on","event","fn","push","name","callback","un","e","call","i","length","splice","unAll","once","handler","args","apply","setTimeout","setDisabledEventEmissions","eventNames","_isDisabledEventEmission","includes","fireEvent","forEach"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/utils/observer.js"],"sourcesContent":["/**\n * @typedef {Object} ListenerDescriptor\n * @property {string} name The name of the event\n * @property {function} callback The callback\n * @property {function} un The function to call to remove the listener\n */\n\n/**\n * Observer class\n */\nexport default class Observer {\n  /**\n   * Instantiate Observer\n   */\n  constructor() {\n    /**\n     * @private\n     * @todo Initialise the handlers here already and remove the conditional\n     * assignment in `on()`\n     */\n    this._disabledEventEmissions = [];\n    this.handlers = null;\n  }\n\n  /**\n   * Attach a handler function for an event.\n   *\n   * @param {string} event Name of the event to listen to\n   * @param {function} fn The callback to trigger when the event is fired\n   * @return {ListenerDescriptor} The event descriptor\n   */\n  on(event, fn) {\n    if (!this.handlers) {\n      this.handlers = {};\n    }\n\n    let handlers = this.handlers[event];\n    if (!handlers) {\n      handlers = [];\n      this.handlers[event] = handlers;\n    }\n    handlers.push(fn);\n\n    // Return an event descriptor\n    return {\n      name: event,\n      callback: fn,\n      un: (e, call) => this.un(e, call)\n    };\n  }\n\n  /**\n     * Remove an event handler.\n     *\n     * @param {string} event Name of the event the listener that should be\n     * removed listens to\n     * @param {function} fn The callback that should be removed\n     */\n  un(event, fn) {\n    if (!this.handlers) {\n      return;\n    }\n\n    const handlers = this.handlers[event];\n    let i;\n    if (handlers) {\n      if (fn) {\n        for (i = handlers.length - 1; i >= 0; i -= 1) {\n          if (handlers[i] === fn) {\n            handlers.splice(i, 1);\n          }\n        }\n      } else {\n        handlers.length = 0;\n      }\n    }\n  }\n\n  /**\n     * Remove all event handlers.\n     */\n  unAll() {\n    this.handlers = null;\n  }\n\n  /**\n     * Attach a handler to an event. The handler is executed at most once per\n     * event type.\n     *\n     * @param {string} event The event to listen to\n     * @param {function} handler The callback that is only to be called once\n     * @return {ListenerDescriptor} The event descriptor\n     */\n  once(event, handler) {\n    const fn = (...args) => {\n      /*  eslint-disable no-invalid-this */\n      handler.apply(this, args);\n      /*  eslint-enable no-invalid-this */\n      setTimeout(() => {\n        this.un(event, fn);\n      }, 0);\n    };\n    return this.on(event, fn);\n  }\n\n  /**\n     * Disable firing a list of events by name. When specified, event handlers for any event type\n     * passed in here will not be called.\n     *\n     * @since 4.0.0\n     * @param {string[]} eventNames an array of event names to disable emissions for\n     * @example\n     * // disable seek and interaction events\n     * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);\n     */\n  setDisabledEventEmissions(eventNames) {\n    this._disabledEventEmissions = eventNames;\n  }\n\n  /**\n     * plugins borrow part of this class without calling the constructor,\n     * so we have to be careful about _disabledEventEmissions\n     */\n\n  _isDisabledEventEmission(event) {\n    return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);\n  }\n\n  /**\n     * Manually fire an event\n     *\n     * @param {string} event The event to fire manually\n     * @param {...any} args The arguments with which to call the listeners\n     */\n  fireEvent(event, ...args) {\n    if (!this.handlers || this._isDisabledEventEmission(event)) {\n      return;\n    }\n\n    const handlers = this.handlers[event];\n    if (handlers) {\n      handlers.forEach((fn) => {\n        fn(...args);\n      });\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAMA,QAAQ,CAAC;EAC5B;AACF;AACA;EACEC,WAAWA,CAAA,EAAG;IACZ;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,uBAAuB,GAAG,EAAE;IACjC,IAAI,CAACC,QAAQ,GAAG,IAAI;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,EAAEA,CAACC,KAAK,EAAEC,EAAE,EAAE;IACZ,IAAI,CAAC,IAAI,CAACH,QAAQ,EAAE;MAClB,IAAI,CAACA,QAAQ,GAAG,CAAC,CAAC;IACpB;IAEA,IAAIA,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACE,KAAK,CAAC;IACnC,IAAI,CAACF,QAAQ,EAAE;MACbA,QAAQ,GAAG,EAAE;MACb,IAAI,CAACA,QAAQ,CAACE,KAAK,CAAC,GAAGF,QAAQ;IACjC;IACAA,QAAQ,CAACI,IAAI,CAACD,EAAE,CAAC;;IAEjB;IACA,OAAO;MACLE,IAAI,EAAEH,KAAK;MACXI,QAAQ,EAAEH,EAAE;MACZI,EAAE,EAAEA,CAACC,CAAC,EAAEC,IAAI,KAAK,IAAI,CAACF,EAAE,CAACC,CAAC,EAAEC,IAAI;IAClC,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEF,EAAEA,CAACL,KAAK,EAAEC,EAAE,EAAE;IACZ,IAAI,CAAC,IAAI,CAACH,QAAQ,EAAE;MAClB;IACF;IAEA,MAAMA,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACE,KAAK,CAAC;IACrC,IAAIQ,CAAC;IACL,IAAIV,QAAQ,EAAE;MACZ,IAAIG,EAAE,EAAE;QACN,KAAKO,CAAC,GAAGV,QAAQ,CAACW,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;UAC5C,IAAIV,QAAQ,CAACU,CAAC,CAAC,KAAKP,EAAE,EAAE;YACtBH,QAAQ,CAACY,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC;UACvB;QACF;MACF,CAAC,MAAM;QACLV,QAAQ,CAACW,MAAM,GAAG,CAAC;MACrB;IACF;EACF;;EAEA;AACF;AACA;EACEE,KAAKA,CAAA,EAAG;IACN,IAAI,CAACb,QAAQ,GAAG,IAAI;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,IAAIA,CAACZ,KAAK,EAAEa,OAAO,EAAE;IACnB,MAAMZ,EAAE,GAAGA,CAAC,GAAGa,IAAI,KAAK;MACtB;MACAD,OAAO,CAACE,KAAK,CAAC,IAAI,EAAED,IAAI,CAAC;MACzB;MACAE,UAAU,CAAC,MAAM;QACf,IAAI,CAACX,EAAE,CAACL,KAAK,EAAEC,EAAE,CAAC;MACpB,CAAC,EAAE,CAAC,CAAC;IACP,CAAC;IACD,OAAO,IAAI,CAACF,EAAE,CAACC,KAAK,EAAEC,EAAE,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgB,yBAAyBA,CAACC,UAAU,EAAE;IACpC,IAAI,CAACrB,uBAAuB,GAAGqB,UAAU;EAC3C;;EAEA;AACF;AACA;AACA;;EAEEC,wBAAwBA,CAACnB,KAAK,EAAE;IAC9B,OAAO,IAAI,CAACH,uBAAuB,IAAI,IAAI,CAACA,uBAAuB,CAACuB,QAAQ,CAACpB,KAAK,CAAC;EACrF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEqB,SAASA,CAACrB,KAAK,EAAE,GAAGc,IAAI,EAAE;IACxB,IAAI,CAAC,IAAI,CAAChB,QAAQ,IAAI,IAAI,CAACqB,wBAAwB,CAACnB,KAAK,CAAC,EAAE;MAC1D;IACF;IAEA,MAAMF,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACE,KAAK,CAAC;IACrC,IAAIF,QAAQ,EAAE;MACZA,QAAQ,CAACwB,OAAO,CAAErB,EAAE,IAAK;QACvBA,EAAE,CAAC,GAAGa,IAAI,CAAC;MACb,CAAC,CAAC;IACJ;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module"}