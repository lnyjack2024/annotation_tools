{"ast":null,"code":"/* eslint-disable no-bitwise */\nimport hexToRgba from 'hex-to-rgba';\nimport { frame } from '../../utils';\nimport CanvasEntry from './canvasentry';\nimport { maxnum, absMax } from '../../utils/math';\nimport { colors } from './types';\nimport { isInput } from '../../../../utils';\nexport default class WaveDrawer {\n  constructor(options) {\n    this.wave = void 0;\n    this.container = void 0;\n    this.canvas = void 0;\n    this.canvasEntry = void 0;\n    this.ctx = void 0;\n    this.pixelRatio = void 0;\n    this.width = 0;\n    this.height = 0;\n    this.minWaveHeight = 60;\n    this.waveHeight = 0;\n    this.backgroundColor = void 0;\n    this.selectedBackgoundColor = void 0;\n    this.splitChannels = void 0;\n    this.splitChannelsOptions = void 0;\n    this.normalize = void 0;\n    this.barHeight = void 0;\n    this.halfPixel = void 0;\n    this.barRadius = 1;\n    this.entry = void 0;\n    this.hasProgressCanvas = void 0;\n    this.canvasContextAttributes = {\n      // Boolean that hints the user agent to reduce the latency\n      // by desynchronizing the canvas paint cycle from the event\n      // loop\n      desynchronized: false\n    };\n    this.defaultWaveColor = '#999';\n    this.mouse = {\n      x: 0,\n      y: 0\n    };\n    this.cursorTime = 0;\n    this.move = false;\n    this.channels = [];\n    this.drawIndex = {};\n    this.getMouseOnChannelIndex = () => {\n      const {\n        y\n      } = this.mouse;\n      let channelIndex = -1;\n      let drawCount = 0;\n      for (let i = 0; i < this.wave.channelCount; i += 1) {\n        channelIndex = i;\n        if (this.wave.hideChannels.indexOf(i) < 0) {\n          drawCount += 1;\n        }\n        if (drawCount * this.waveHeight >= y) {\n          break;\n        }\n      }\n      return channelIndex;\n    };\n    this.mouseDown = () => {\n      this.move = false;\n      const channelIndex = this.getMouseOnChannelIndex();\n      this.wave.fireEvent('mousedown', channelIndex, this.mouse);\n    };\n    this.mouseUp = e => {\n      const channelIndex = this.getMouseOnChannelIndex();\n      this.wave.fireEvent('mouseup', e, this.cursorTime, channelIndex);\n    };\n    this.mouseLeave = () => {\n      this.cursorTime = 0;\n      this.wave.fireEvent('mouseleave');\n    };\n    this.handleKeyDown = e => {\n      if (!isInput()) {\n        switch (e.key.toLowerCase()) {\n          case 's':\n            this.wave.fireEvent('split', this.cursorTime);\n            break;\n          default:\n            break;\n        }\n      }\n    };\n    this.updateCursorTime = e => {\n      if (this.canvas) {\n        this.move = true;\n        const {\n          displayRange: {\n            start,\n            end\n          }\n        } = this.wave;\n        const {\n          left,\n          top,\n          width\n        } = this.canvas.getBoundingClientRect();\n        let x = e.clientX - left;\n        let y = e.clientY - top;\n        x = x < 0 ? 0 : x;\n        y = y < 0 ? 0 : y;\n        this.mouse = {\n          x,\n          y\n        };\n        this.cursorTime = (x / width * (end - start) + start) * this.wave.getDuration();\n        const channelIndex = this.getMouseOnChannelIndex();\n        this.wave.fireEvent('mousemove', {\n          cursorTime: this.cursorTime,\n          mouse: this.mouse,\n          channelIndex\n        });\n      }\n    };\n    this.setDrawIndex = drawIndex => {\n      this.drawIndex = drawIndex;\n    };\n    const {\n      wave,\n      container,\n      pixelRatio,\n      backgroundColor,\n      selectedBackgoundColor,\n      normalize,\n      barHeight,\n      splitChannels,\n      splitChannelsOptions,\n      hasProgressCanvas,\n      channels\n    } = options;\n    this.wave = wave;\n    this.container = container;\n    this.backgroundColor = backgroundColor;\n    this.selectedBackgoundColor = selectedBackgoundColor;\n    this.pixelRatio = pixelRatio;\n    this.splitChannels = splitChannels;\n    this.splitChannelsOptions = splitChannelsOptions;\n    this.channels = channels;\n    this.normalize = normalize;\n    this.barHeight = barHeight || 1;\n    this.halfPixel = 0.5 / pixelRatio;\n    this.hasProgressCanvas = hasProgressCanvas;\n    this.canvas = document.createElement('canvas');\n    this.canvas.className = 'waveform';\n    this.ctx = this.canvas.getContext('2d');\n    container.appendChild(this.canvas);\n    this.initCanvas();\n  }\n  initCanvas() {\n    const entry = new CanvasEntry();\n    entry.canvasContextAttributes = this.canvasContextAttributes;\n    entry.hasProgressCanvas = this.hasProgressCanvas;\n    entry.halfPixel = this.halfPixel;\n\n    // wave\n    this.canvas.style.display = 'block';\n    entry.initWave(this.canvas);\n    this.canvasEntry = entry;\n    this.canvas.addEventListener('mousemove', this.updateCursorTime);\n    this.canvas.addEventListener('mousedown', this.mouseDown);\n    this.canvas.addEventListener('mouseup', this.mouseUp);\n    this.canvas.addEventListener('mouseleave', this.mouseLeave);\n    window.addEventListener('keydown', this.handleKeyDown);\n    this.wave.on('destroy', this.destroy);\n  }\n  destroy() {\n    this.canvas.removeEventListener('mousemove', this.updateCursorTime);\n    this.canvas.removeEventListener('mousedown', this.mouseDown);\n    this.canvas.removeEventListener('mouseup', this.mouseUp);\n    this.canvas.removeEventListener('mouseleave', this.mouseLeave);\n    window.removeEventListener('keydown', this.handleKeyDown);\n  }\n  initChannel(x, y, width, height, backgroundColor = this.backgroundColor) {\n    this.ctx.fillStyle = backgroundColor;\n    this.ctx.fillRect(x, y, width, height);\n  }\n  triggerSelectChannel(index, selected) {\n    const height = this.wave.visibleChannelCount > 0 ? this.height / this.wave.visibleChannelCount : this.height;\n    const y = index * height;\n    const backgroundColor = selected ? this.selectedBackgoundColor : this.backgroundColor;\n    this.initChannel(0, y, this.width, height, backgroundColor);\n  }\n\n  /**\n   * Draw peaks on the canvas\n   *\n   * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays\n   * for split channel rendering\n   * @param {number} length The width of the area that should be drawn\n   * @param {number} start The x-offset of the beginning of the area that\n   * should be rendered\n   * @param {number} end The x-offset of the end of the area that should be\n   * rendered\n   */\n  drawPeaks(peaks, width, height) {\n    this.resize(width, height);\n    this.drawWave(peaks, 0);\n  }\n\n  /**\n   * Draw a waveform\n   *\n   * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays\n   * for split channel rendering\n   * @param {number} channelIndex The index of the current channel. Normally\n   * should be 0\n   * @param {number?} start The x-offset of the beginning of the area that\n   * should be rendered (If this isn't set only a flat line is rendered)\n   * @param {number?} end The x-offset of the end of the area that should be\n   * rendered\n   * @returns {void}\n   */\n  drawWave(_peaks, _channelIndex) {\n    return this.prepareDraw(_peaks, _channelIndex, _channelIndex, ({\n      absmax,\n      offsetY,\n      halfH,\n      peaks,\n      channelIndex\n    }) => {\n      // always draw a median line\n      this.fillRect(0, halfH + offsetY - this.halfPixel, this.width * this.pixelRatio, this.halfPixel, this.barRadius, channelIndex, offsetY);\n      this.drawLine(peaks, absmax, halfH, offsetY, channelIndex);\n    });\n  }\n\n  /**\n   * Performs preparation tasks and calculations which are shared by `drawBars`\n   * and `drawWave`\n   *\n   * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for\n   * split channel rendering\n   * @param {number} channelIndex The index of the current channel. Normally\n   * should be 0\n   * @param {number?} start The x-offset of the beginning of the area that\n   * should be rendered. If this isn't set only a flat line is rendered\n   * @param {number?} end The x-offset of the end of the area that should be\n   * rendered\n   * @param {function} fn The render function to call, e.g. `drawWave`\n   * @param {number} drawIndex The index of the current channel after filtering.\n   * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined\n   * @returns {void}\n   */\n  prepareDraw(peaks, channelIndex, drawIndex, fn) {\n    const draw = (_peaks, _channelIndex, _drawIndex, normalizedMax) => {\n      var _this$splitChannelsOp;\n      // calculate maximum modulation value, either from the barHeight\n      // parameter or if normalize=true from the largest value in the peak\n      let absmax = 1 / this.barHeight;\n      if (this.normalize) {\n        absmax = normalizedMax === undefined ? absMax(peaks) : normalizedMax;\n      }\n      const height = this.waveHeight * this.pixelRatio;\n      const halfH = height / 2;\n      let offsetY = height * (_drawIndex || 0);\n\n      // Override offsetY if overlay is true\n      if ((_this$splitChannelsOp = this.splitChannelsOptions) === null || _this$splitChannelsOp === void 0 ? void 0 : _this$splitChannelsOp.overlay) {\n        offsetY = 0;\n      }\n      return fn({\n        absmax,\n        offsetY,\n        halfH,\n        peaks: _peaks,\n        channelIndex: _channelIndex\n      });\n    };\n    return frame(() => {\n      // Split channels and call this function with the channelIndex set\n      if (peaks[0] instanceof Array) {\n        const channels = peaks;\n        if (this.splitChannels) {\n          let overallAbsMax = 0;\n          const filteredChannels = channels.filter((c, i) => !this.hideChannel(i));\n          if (this.normalize) {\n            // calculate maximum peak across channels to use for normalization\n            overallAbsMax = maxnum(channels.map(channelPeaks => absMax(channelPeaks)));\n          }\n          return channels.forEach((channelPeaks, i) => draw(channelPeaks, i, filteredChannels.indexOf(channelPeaks), overallAbsMax));\n        }\n      } else {\n        draw(peaks, channelIndex, drawIndex);\n      }\n    })();\n  }\n\n  /**\n   * Set the height of the container\n   *\n   * @param {number} height The new height of the container.\n   * @return {boolean} Whether the height of the container was updated or not\n   */\n  resize(width, height) {\n    const channels = this.splitChannels ? this.wave.visibleChannelCount : 1;\n    this.width = width;\n    this.height = height;\n    this.waveHeight = height / channels;\n    if (this.waveHeight < this.minWaveHeight) {\n      const {\n        clientHeight\n      } = this.container;\n      this.waveHeight = this.minWaveHeight;\n      this.height = this.waveHeight * channels;\n      this.container.style.height = `${clientHeight + (this.height - height)}px`;\n    }\n    this.updateSize();\n    return true;\n  }\n\n  /**\n   * Adjust to the updated size by adding or removing canvases\n   */\n  updateSize() {\n    this.updateDimensions(this.width, this.height);\n    this.clearWave();\n  }\n  clearWave() {\n    frame(() => {\n      var _this$canvasEntry;\n      (_this$canvasEntry = this.canvasEntry) === null || _this$canvasEntry === void 0 ? void 0 : _this$canvasEntry.clearWave();\n    })();\n  }\n\n  /**\n   * Update the dimensions of a canvas element\n   *\n   * @param {CanvasEntry} entry Target entry\n   * @param {number} width The new width of the element\n   * @param {number} height The new height of the element\n   */\n  updateDimensions(width, height) {\n    var _this$canvasEntry2;\n    // update canvas dimensions\n    (_this$canvasEntry2 = this.canvasEntry) === null || _this$canvasEntry2 === void 0 ? void 0 : _this$canvasEntry2.updateDimensions(width, height, width * this.pixelRatio, height * this.pixelRatio);\n  }\n\n  /**\n   * Returns whether to hide the channel from being drawn based on params.\n   *\n   * @param {number} channelIndex The index of the current channel.\n   * @returns {bool} True to hide the channel, false to draw.\n   */\n  hideChannel(channelIndex) {\n    return this.splitChannels && this.wave.hideChannels.includes(channelIndex);\n  }\n  /**\n   * Tell the canvas entries to render their portion of the waveform\n   *\n   * @param {number[]} peaks Peaks data\n   * @param {number} absmax Maximum peak value (absolute)\n   * @param {number} halfH Half the height of the waveform\n   * @param {number} offsetY Offset to the top\n   * @param {channelIndex} channelIndex The channel index of the line drawn\n   */\n  drawLine(peaks, absmax, halfH, offsetY, channelIndex) {\n    var _this$canvasEntry3, _this$canvasEntry4;\n    const waveColor = this.channels[channelIndex] ? hexToRgba(this.channels[channelIndex].color, 0.5) : colors[channelIndex] || '#A1A1A1';\n    (_this$canvasEntry3 = this.canvasEntry) === null || _this$canvasEntry3 === void 0 ? void 0 : _this$canvasEntry3.setFillStyles(waveColor, waveColor);\n    (_this$canvasEntry4 = this.canvasEntry) === null || _this$canvasEntry4 === void 0 ? void 0 : _this$canvasEntry4.drawLines(peaks, absmax, halfH, offsetY);\n  }\n\n  /**\n   * Draw a rectangle on the multi-canvas\n   *\n   * @param {number} x X-position of the rectangle\n   * @param {number} y Y-position of the rectangle\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   * @param {channelIndex} channelIndex The channel index of the bar drawn\n   */\n  fillRect(x, y, width, height, radius, channelIndex, offsetY) {\n    var _this$canvasEntry5, _this$canvasEntry6, _this$canvasEntry7, _this$canvasEntry8;\n    const intersection = {\n      x1: x,\n      y1: y,\n      x2: width,\n      y2: y + height\n    };\n    const channel = this.channels[channelIndex];\n    const waveColor = colors[0];\n    (_this$canvasEntry5 = this.canvasEntry) === null || _this$canvasEntry5 === void 0 ? void 0 : _this$canvasEntry5.setFillStyles(waveColor, waveColor);\n    (_this$canvasEntry6 = this.canvasEntry) === null || _this$canvasEntry6 === void 0 ? void 0 : _this$canvasEntry6.fillRects(intersection.x1, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);\n    (_this$canvasEntry7 = this.canvasEntry) === null || _this$canvasEntry7 === void 0 ? void 0 : _this$canvasEntry7.setFillStyles('rgba(255, 255, 255, 0.6)', 'rgba(255, 255, 255, 0.6)');\n    (_this$canvasEntry8 = this.canvasEntry) === null || _this$canvasEntry8 === void 0 ? void 0 : _this$canvasEntry8.drawText((channel === null || channel === void 0 ? void 0 : channel.label) || `${channelIndex + 1}`, x, offsetY + 18 * this.pixelRatio, 12 * this.pixelRatio);\n  }\n}","map":{"version":3,"names":["hexToRgba","frame","CanvasEntry","maxnum","absMax","colors","isInput","WaveDrawer","constructor","options","wave","container","canvas","canvasEntry","ctx","pixelRatio","width","height","minWaveHeight","waveHeight","backgroundColor","selectedBackgoundColor","splitChannels","splitChannelsOptions","normalize","barHeight","halfPixel","barRadius","entry","hasProgressCanvas","canvasContextAttributes","desynchronized","defaultWaveColor","mouse","x","y","cursorTime","move","channels","drawIndex","getMouseOnChannelIndex","channelIndex","drawCount","i","channelCount","hideChannels","indexOf","mouseDown","fireEvent","mouseUp","e","mouseLeave","handleKeyDown","key","toLowerCase","updateCursorTime","displayRange","start","end","left","top","getBoundingClientRect","clientX","clientY","getDuration","setDrawIndex","document","createElement","className","getContext","appendChild","initCanvas","style","display","initWave","addEventListener","window","on","destroy","removeEventListener","initChannel","fillStyle","fillRect","triggerSelectChannel","index","selected","visibleChannelCount","drawPeaks","peaks","resize","drawWave","_peaks","_channelIndex","prepareDraw","absmax","offsetY","halfH","drawLine","fn","draw","_drawIndex","normalizedMax","_this$splitChannelsOp","undefined","overlay","Array","overallAbsMax","filteredChannels","filter","c","hideChannel","map","channelPeaks","forEach","clientHeight","updateSize","updateDimensions","clearWave","_this$canvasEntry","_this$canvasEntry2","includes","_this$canvasEntry3","_this$canvasEntry4","waveColor","color","setFillStyles","drawLines","radius","_this$canvasEntry5","_this$canvasEntry6","_this$canvasEntry7","_this$canvasEntry8","intersection","x1","y1","x2","y2","channel","fillRects","drawText","label"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/components/Wave/waveDrawer.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport hexToRgba from 'hex-to-rgba';\nimport { frame } from '../../utils';\nimport Wave from './index';\nimport CanvasEntry from './canvasentry';\nimport { maxnum, absMax } from '../../utils/math';\nimport { ChannelOptions, Channel, colors } from './types';\nimport { isInput } from '../../../../utils';\n\ninterface WaveDrawerOptions {\n  wave: Wave;\n  container: HTMLElement;\n  backgroundColor: string;\n  selectedBackgoundColor: string;\n  pixelRatio: number;\n  splitChannels: boolean;\n  splitChannelsOptions?: ChannelOptions;\n  channels: Channel[];\n  normalize?: boolean;\n  barHeight?: number;\n  hasProgressCanvas?: boolean;\n}\n\ninterface DrawData {\n  absmax: number;\n  offsetY: number;\n  halfH: number;\n  peaks: number[];\n  channelIndex: number;\n}\n\nexport default class WaveDrawer {\n  wave: Wave;\n\n  container: HTMLElement;\n\n  canvas: HTMLCanvasElement;\n\n  canvasEntry?: CanvasEntry;\n\n  ctx: CanvasRenderingContext2D;\n\n  pixelRatio: number;\n\n  width = 0;\n\n  height = 0;\n\n  minWaveHeight = 60;\n\n  waveHeight = 0;\n\n  backgroundColor: string;\n\n  selectedBackgoundColor: string;\n\n  splitChannels: boolean;\n\n  splitChannelsOptions?: ChannelOptions;\n\n  normalize?: boolean;\n\n  barHeight: number;\n\n  halfPixel: number;\n\n  barRadius = 1;\n\n  entry?: CanvasEntry;\n\n  hasProgressCanvas?: boolean;\n\n  canvasContextAttributes = {\n    // Boolean that hints the user agent to reduce the latency\n    // by desynchronizing the canvas paint cycle from the event\n    // loop\n    desynchronized: false\n  };\n\n  defaultWaveColor = '#999';\n\n  mouse = { x: 0, y: 0 };\n\n  cursorTime = 0;\n\n  move = false;\n\n  channels: Channel[] = [];\n\n  drawIndex: {[channelIndex: number]: number} = {};\n\n  constructor(options: WaveDrawerOptions) {\n    const {\n      wave, container, pixelRatio, backgroundColor, selectedBackgoundColor, normalize,\n      barHeight, splitChannels, splitChannelsOptions, hasProgressCanvas, channels,\n    } = options;\n    this.wave = wave;\n    this.container = container;\n    this.backgroundColor = backgroundColor;\n    this.selectedBackgoundColor = selectedBackgoundColor;\n    this.pixelRatio = pixelRatio;\n    this.splitChannels = splitChannels;\n    this.splitChannelsOptions = splitChannelsOptions;\n    this.channels = channels;\n    this.normalize = normalize;\n    this.barHeight = barHeight || 1;\n    this.halfPixel = 0.5 / pixelRatio;\n    this.hasProgressCanvas = hasProgressCanvas;\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.className = 'waveform';\n    this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n    container.appendChild(this.canvas);\n    this.initCanvas();\n  }\n\n  initCanvas() {\n    const entry = new CanvasEntry();\n    entry.canvasContextAttributes = this.canvasContextAttributes;\n    entry.hasProgressCanvas = this.hasProgressCanvas;\n    entry.halfPixel = this.halfPixel;\n\n    // wave\n    this.canvas.style.display = 'block';\n    entry.initWave(this.canvas);\n    this.canvasEntry = entry;\n\n    this.canvas.addEventListener('mousemove', this.updateCursorTime);\n    this.canvas.addEventListener('mousedown', this.mouseDown);\n    this.canvas.addEventListener('mouseup', this.mouseUp);\n    this.canvas.addEventListener('mouseleave', this.mouseLeave);\n    window.addEventListener('keydown', this.handleKeyDown);\n    this.wave.on('destroy', this.destroy);\n  }\n\n  destroy() {\n    this.canvas.removeEventListener('mousemove', this.updateCursorTime);\n    this.canvas.removeEventListener('mousedown', this.mouseDown);\n    this.canvas.removeEventListener('mouseup', this.mouseUp);\n    this.canvas.removeEventListener('mouseleave', this.mouseLeave);\n    window.removeEventListener('keydown', this.handleKeyDown);\n  }\n\n  getMouseOnChannelIndex = () => {\n    const { y } = this.mouse;\n    let channelIndex = -1;\n    let drawCount = 0;\n    for (let i = 0; i < this.wave.channelCount; i += 1) {\n      channelIndex = i;\n      if (this.wave.hideChannels.indexOf(i) < 0) {\n        drawCount += 1;\n      }\n      if (drawCount * this.waveHeight >= y) {\n        break;\n      }\n    }\n    return channelIndex;\n  };\n\n  mouseDown = () => {\n    this.move = false;\n    const channelIndex = this.getMouseOnChannelIndex();\n    this.wave.fireEvent('mousedown', channelIndex, this.mouse);\n  };\n\n  mouseUp = (e: MouseEvent) => {\n    const channelIndex = this.getMouseOnChannelIndex();\n    this.wave.fireEvent('mouseup', e, this.cursorTime, channelIndex);\n  };\n\n  mouseLeave = () => {\n    this.cursorTime = 0;\n    this.wave.fireEvent('mouseleave');\n  };\n\n  handleKeyDown = (e: KeyboardEvent) => {\n    if (!isInput()) {\n      switch (e.key.toLowerCase()) {\n        case 's':\n          this.wave.fireEvent('split', this.cursorTime);\n          break;\n        default:\n          break;\n      }\n    }\n  };\n\n  updateCursorTime = (e: MouseEvent) => {\n    if (this.canvas) {\n      this.move = true;\n      const { displayRange: { start, end } } = this.wave;\n      const { left, top, width } = this.canvas.getBoundingClientRect();\n      let x = e.clientX - left;\n      let y = e.clientY - top;\n      x = x < 0 ? 0 : x;\n      y = y < 0 ? 0 : y;\n      this.mouse = { x, y };\n      this.cursorTime = ((x / width) * (end - start) + start) * this.wave.getDuration();\n      const channelIndex = this.getMouseOnChannelIndex();\n      this.wave.fireEvent('mousemove', {\n        cursorTime: this.cursorTime,\n        mouse: this.mouse,\n        channelIndex,\n      });\n    }\n  };\n\n  initChannel(x: number, y: number, width: number, height: number, backgroundColor = this.backgroundColor) {\n    this.ctx.fillStyle = backgroundColor;\n    this.ctx.fillRect(x, y, width, height);\n  }\n\n  triggerSelectChannel(index: number, selected: boolean) {\n    const height = this.wave.visibleChannelCount > 0 ? this.height / this.wave.visibleChannelCount : this.height;\n    const y = index * height;\n    const backgroundColor = selected ? this.selectedBackgoundColor : this.backgroundColor;\n    this.initChannel(0, y, this.width, height, backgroundColor);\n  }\n\n  /**\n   * Draw peaks on the canvas\n   *\n   * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays\n   * for split channel rendering\n   * @param {number} length The width of the area that should be drawn\n   * @param {number} start The x-offset of the beginning of the area that\n   * should be rendered\n   * @param {number} end The x-offset of the end of the area that should be\n   * rendered\n   */\n  drawPeaks(peaks: number[]|number[][], width: number, height: number) {\n    this.resize(width, height);\n    this.drawWave(peaks, 0);\n  }\n\n  /**\n   * Draw a waveform\n   *\n   * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays\n   * for split channel rendering\n   * @param {number} channelIndex The index of the current channel. Normally\n   * should be 0\n   * @param {number?} start The x-offset of the beginning of the area that\n   * should be rendered (If this isn't set only a flat line is rendered)\n   * @param {number?} end The x-offset of the end of the area that should be\n   * rendered\n   * @returns {void}\n   */\n  drawWave(_peaks: number[] | number[][], _channelIndex: number) {\n    return this.prepareDraw(\n      _peaks,\n      _channelIndex,\n      _channelIndex,\n      ({ absmax, offsetY, halfH, peaks, channelIndex }: DrawData) => {\n        // always draw a median line\n        this.fillRect(\n          0,\n          halfH + offsetY - this.halfPixel,\n          this.width * this.pixelRatio,\n          this.halfPixel,\n          this.barRadius,\n          channelIndex,\n          offsetY\n        );\n        this.drawLine(peaks, absmax, halfH, offsetY, channelIndex);\n      }\n    );\n  }\n\n  /**\n   * Performs preparation tasks and calculations which are shared by `drawBars`\n   * and `drawWave`\n   *\n   * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for\n   * split channel rendering\n   * @param {number} channelIndex The index of the current channel. Normally\n   * should be 0\n   * @param {number?} start The x-offset of the beginning of the area that\n   * should be rendered. If this isn't set only a flat line is rendered\n   * @param {number?} end The x-offset of the end of the area that should be\n   * rendered\n   * @param {function} fn The render function to call, e.g. `drawWave`\n   * @param {number} drawIndex The index of the current channel after filtering.\n   * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined\n   * @returns {void}\n   */\n  prepareDraw(peaks: number[] | number[][], channelIndex: number, drawIndex: number, fn: (data: DrawData) => void) {\n    const draw = (_peaks: number[], _channelIndex: number, _drawIndex: number, normalizedMax?: number) => {\n      // calculate maximum modulation value, either from the barHeight\n      // parameter or if normalize=true from the largest value in the peak\n      let absmax = 1 / this.barHeight;\n      if (this.normalize) {\n        absmax = normalizedMax === undefined ? absMax(peaks as number[]) : normalizedMax;\n      }\n\n      const height = this.waveHeight * this.pixelRatio;\n      const halfH = height / 2;\n\n      let offsetY = height * (_drawIndex || 0);\n\n      // Override offsetY if overlay is true\n      if (this.splitChannelsOptions?.overlay) {\n        offsetY = 0;\n      }\n      return fn({\n        absmax,\n        offsetY,\n        halfH,\n        peaks: _peaks,\n        channelIndex: _channelIndex\n      });\n    };\n    return frame(() => {\n      // Split channels and call this function with the channelIndex set\n      if (peaks[0] instanceof Array) {\n        const channels = peaks as number[][];\n        if (this.splitChannels) {\n          let overallAbsMax = 0;\n          const filteredChannels = channels.filter((c, i) => !this.hideChannel(i));\n          if (this.normalize) {\n            // calculate maximum peak across channels to use for normalization\n            overallAbsMax = maxnum(channels.map(((channelPeaks) => absMax(channelPeaks))));\n          }\n          return channels.forEach((channelPeaks, i) => draw(channelPeaks, i, filteredChannels.indexOf(channelPeaks), overallAbsMax));\n        }\n      } else {\n        draw(peaks as number[], channelIndex, drawIndex);\n      }\n    })();\n  }\n\n  /**\n   * Set the height of the container\n   *\n   * @param {number} height The new height of the container.\n   * @return {boolean} Whether the height of the container was updated or not\n   */\n  resize(width: number, height: number) {\n    const channels = this.splitChannels ? this.wave.visibleChannelCount : 1;\n    this.width = width;\n    this.height = height;\n    this.waveHeight = height / channels;\n    if (this.waveHeight < this.minWaveHeight) {\n      const { clientHeight } = this.container;\n      this.waveHeight = this.minWaveHeight;\n      this.height = this.waveHeight * channels;\n      this.container.style.height = `${clientHeight + (this.height - height)}px`;\n    }\n    this.updateSize();\n    return true;\n  }\n\n  /**\n   * Adjust to the updated size by adding or removing canvases\n   */\n  updateSize() {\n    this.updateDimensions(this.width, this.height);\n    this.clearWave();\n  }\n\n  clearWave() {\n    frame(() => {\n      this.canvasEntry?.clearWave();\n    })();\n  }\n\n  /**\n   * Update the dimensions of a canvas element\n   *\n   * @param {CanvasEntry} entry Target entry\n   * @param {number} width The new width of the element\n   * @param {number} height The new height of the element\n   */\n  updateDimensions(width: number, height: number) {\n    // update canvas dimensions\n    this.canvasEntry?.updateDimensions(width, height, width * this.pixelRatio, height * this.pixelRatio);\n  }\n\n  /**\n   * Returns whether to hide the channel from being drawn based on params.\n   *\n   * @param {number} channelIndex The index of the current channel.\n   * @returns {bool} True to hide the channel, false to draw.\n   */\n  hideChannel(channelIndex: number) {\n    return this.splitChannels && this.wave.hideChannels.includes(channelIndex);\n  }\n\n  setDrawIndex = (drawIndex: {[channelIndex: number]: number}) => {\n    this.drawIndex = drawIndex;\n  };\n\n  /**\n   * Tell the canvas entries to render their portion of the waveform\n   *\n   * @param {number[]} peaks Peaks data\n   * @param {number} absmax Maximum peak value (absolute)\n   * @param {number} halfH Half the height of the waveform\n   * @param {number} offsetY Offset to the top\n   * @param {channelIndex} channelIndex The channel index of the line drawn\n   */\n  drawLine(peaks: number[], absmax: number, halfH: number, offsetY: number, channelIndex: number) {\n    const waveColor = this.channels[channelIndex] ? hexToRgba(this.channels[channelIndex].color, 0.5) : colors[channelIndex] || '#A1A1A1';\n    this.canvasEntry?.setFillStyles(waveColor, waveColor);\n    this.canvasEntry?.drawLines(peaks, absmax, halfH, offsetY);\n  }\n\n  /**\n   * Draw a rectangle on the multi-canvas\n   *\n   * @param {number} x X-position of the rectangle\n   * @param {number} y Y-position of the rectangle\n   * @param {number} width Width of the rectangle\n   * @param {number} height Height of the rectangle\n   * @param {number} radius Radius of the rectangle\n   * @param {channelIndex} channelIndex The channel index of the bar drawn\n   */\n  fillRect(x: number, y: number, width: number, height: number, radius: number, channelIndex: number, offsetY: number) {\n    const intersection = {\n      x1: x,\n      y1: y,\n      x2: width,\n      y2: y + height\n    };\n    const channel = this.channels[channelIndex];\n\n    const waveColor = colors[0];\n    this.canvasEntry?.setFillStyles(waveColor, waveColor);\n    this.canvasEntry?.fillRects(\n      intersection.x1,\n      intersection.y1,\n      intersection.x2 - intersection.x1,\n      intersection.y2 - intersection.y1,\n      radius\n    );\n\n    this.canvasEntry?.setFillStyles('rgba(255, 255, 255, 0.6)', 'rgba(255, 255, 255, 0.6)');\n    this.canvasEntry?.drawText(channel?.label || `${channelIndex + 1}`, x, offsetY + 18 * this.pixelRatio, 12 * this.pixelRatio);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}