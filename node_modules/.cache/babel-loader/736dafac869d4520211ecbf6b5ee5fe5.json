{"ast":null,"code":"import { makeAutoObservable, toJS } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AnnotationType, UpdateType } from '../types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map = {};\n    this.allInstances.forEach(instance => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({\n      className\n    }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.start - b.start);\n      }\n    });\n    return map;\n  }\n  /**\n   * selected instance\n   */\n  get selectedInstance() {\n    return this.selectedInstanceId ? toJS(this.instances[this.selectedInstanceId]) : null;\n  }\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    return Object.values(this.instances);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * all instances\n     */\n    this.instances = {};\n    /**\n     * selected instances\n     */\n    this.selectedInstanceId = null;\n    /**\n     * selected number\n     */\n    this.selectedNumber = null;\n    /**\n     * update instances\n     */\n    this.updatedInstances = {};\n    this.updateInstances = instances => {\n      this.instances = {\n        ...toJS(this.instances),\n        ...instances\n      };\n    };\n    makeAutoObservable(this, {\n      rootStore: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(list) {\n    if (list.length) {\n      const instances = {};\n      list.forEach(instance => {\n        instances[instance.id] = instance;\n      });\n      this.instances = instances;\n      this.setUpdatedInstances(instances, UpdateType.INIT);\n    }\n  }\n  createDefaultInstances() {\n    const {\n      categories\n    } = this.rootStore.ontology;\n    if (Object.keys(this.instances).length === 0 && categories.length) {\n      const {\n        duration\n      } = this.rootStore.analyse.placement;\n      const instances = {};\n      categories.forEach((category, i) => {\n        if (category.type === AnnotationType.SEGMENT) {\n          const id = uuidv4();\n          instances[id] = {\n            id,\n            start: 0,\n            end: duration,\n            shapeType: category.type,\n            category: category.className,\n            categoryIndex: i\n          };\n        }\n      });\n      this.instances = instances;\n      this.setUpdatedInstances(this.instances, UpdateType.INIT);\n    }\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  setInstance(instance) {\n    this.instances[instance.id] = instance;\n  }\n\n  /**\n   * delete instance\n   * @param id\n   */\n  deleteInstance(id) {\n    if (this.instances[id]) {\n      const updatedInstances = {};\n      const instance = toJS(this.instances[id]);\n      const {\n        shapeType,\n        category,\n        categoryIndex,\n        start,\n        end\n      } = instance;\n      updatedInstances[id] = null;\n      const prevInstance = shapeType === AnnotationType.SEGMENT ? this.getCurrentSplitInstance(category, start) : undefined;\n      if (prevInstance) {\n        const updatedPrevInstance = {\n          ...prevInstance,\n          end\n        };\n        updatedInstances[prevInstance.id] = updatedPrevInstance;\n      }\n      if (start === this.rootStore.analyse.selectedTime) {\n        const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n        this.rootStore.ontology.setCanAddTiers({\n          ...canAddTiers,\n          [category]: {\n            index: categoryIndex,\n            first: true,\n            second: true\n          }\n        });\n      }\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n\n  /**\n   * handle add shape\n   * @param className category\n   */\n  addInstance(className, time) {\n    const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n    const canAddTier = canAddTiers[className];\n    if (className && canAddTier !== undefined) {\n      const categoryIndex = canAddTier.index;\n      const category = this.rootStore.ontology.getCategory(className);\n      const updatedInstances = {};\n      const shapeType = category.type;\n      const isSegment = shapeType === AnnotationType.SEGMENT;\n      let instance = null;\n      let selectedId = '';\n      const add = startTime => {\n        let endTime;\n        let prevInstance;\n        const id = uuidv4();\n        if (instance) {\n          prevInstance = instance;\n        } else {\n          selectedId = id;\n          prevInstance = isSegment ? this.getCurrentSplitInstance(className, startTime) : undefined;\n        }\n        if (prevInstance) {\n          const updatePrevInstance = {\n            ...prevInstance,\n            end: startTime\n          };\n          updatedInstances[prevInstance.id] = updatePrevInstance;\n          endTime = prevInstance.end;\n        } else if (isSegment) {\n          const {\n            duration\n          } = this.rootStore.analyse.placement;\n          endTime = duration;\n        }\n        instance = {\n          id,\n          start: startTime,\n          end: endTime,\n          shapeType,\n          category: className,\n          categoryIndex\n        };\n        updatedInstances[instance.id] = instance;\n      };\n      if (Array.isArray(time)) {\n        Array.from(new Set(time)).sort((a, b) => a - b).forEach(start => {\n          add(start);\n        });\n      } else {\n        add(time);\n      }\n      delete canAddTiers[className];\n      this.rootStore.ontology.setCanAddTiers(canAddTiers);\n      this.setSelectedInstance(updatedInstances[selectedId]);\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n  getCurrentSplitInstance(category, start) {\n    const categoryInstances = this.categoryInstancesMap[category];\n    if (categoryInstances.length === 1) {\n      if (categoryInstances[0].start !== start) {\n        return toJS(categoryInstances[0]);\n      }\n      return undefined;\n    }\n    let prevIndex = -1;\n    for (let i = 0; i < categoryInstances.length; i += 1) {\n      const instance = categoryInstances[i];\n      if (instance.end && start <= instance.end && start > instance.start) {\n        prevIndex = i;\n        break;\n      } else if (!instance.end && start > instance.start) {\n        prevIndex = i;\n        break;\n      }\n    }\n    return categoryInstances[prevIndex] ? toJS(categoryInstances[prevIndex]) : undefined;\n  }\n  getAdjoinInstances(category, start) {\n    const categoryInstances = this.categoryInstancesMap[category];\n    if (categoryInstances.length === 1 && this.rootStore.ontology.categories[categoryInstances[0].categoryIndex].type !== AnnotationType.TIMING) {\n      return {\n        prevInstance: toJS(categoryInstances[0]),\n        nextInstance: undefined\n      };\n    }\n    const index = categoryInstances.findIndex(instance => instance.start === start);\n    const adjoinInstances = {\n      prevInstance: categoryInstances[index - 1] ? toJS(categoryInstances[index - 1]) : undefined,\n      nextInstance: categoryInstances[index + 1] ? toJS(categoryInstances[index + 1]) : undefined\n    };\n    return adjoinInstances;\n  }\n\n  /**\n   * set updated instances\n   */\n  setUpdatedInstances(instances, type) {\n    const ids = Object.keys(instances);\n    if (ids.length === 0) {\n      return;\n    }\n    if (type !== UpdateType.INIT) {\n      const updatedInstances = {};\n      const oldInstances = {};\n      ids.forEach(id => {\n        const oldInstance = this.instances[id];\n        oldInstances[id] = oldInstance ? toJS(oldInstance) : null;\n        const instance = instances[id];\n        if (instance) {\n          updatedInstances[id] = instance;\n        } else {\n          var _this$selectedInstanc;\n          delete this.instances[id];\n          if (((_this$selectedInstanc = this.selectedInstance) === null || _this$selectedInstanc === void 0 ? void 0 : _this$selectedInstanc.id) === id) {\n            this.selectedInstanceId = null;\n          }\n        }\n      });\n      if (type !== UpdateType.UNDOREDO) {\n        this.changeUndo(oldInstances, instances);\n      }\n      this.updateInstances(updatedInstances);\n    }\n    this.updatedInstances = instances;\n  }\n  changeUndo(oldInstances, updatedInstances) {\n    const before = [];\n    const after = [];\n    before.push({\n      type: 'instance',\n      status: {\n        ...oldInstances\n      }\n    });\n    after.push({\n      type: 'instance',\n      status: {\n        ...updatedInstances\n      }\n    });\n    this.rootStore.undo.saveStatus(before, after);\n  }\n\n  /**\n   * set selected instance\n   */\n  setSelectedInstance(instance) {\n    if (instance) {\n      if (this.selectedInstanceId === instance.id) return;\n      const categoryInstances = this.categoryInstancesMap[instance.category];\n      const prevInstance = this.getCurrentSplitInstance(instance.category, instance.start);\n      if (prevInstance) {\n        const index = categoryInstances.findIndex(i => i.start === prevInstance.start);\n        this.selectedNumber = index + 2;\n      } else {\n        this.selectedNumber = 1;\n      }\n    } else {\n      this.selectedNumber = null;\n    }\n    this.selectedInstanceId = instance ? instance.id : null;\n  }\n}","map":{"version":3,"names":["makeAutoObservable","toJS","v4","uuidv4","AnnotationType","UpdateType","InstanceStore","categoryInstancesMap","map","allInstances","forEach","instance","category","push","rootStore","ontology","categories","className","sort","a","b","start","selectedInstance","selectedInstanceId","instances","Object","values","constructor","selectedNumber","updatedInstances","updateInstances","autoBind","init","list","length","id","setUpdatedInstances","INIT","createDefaultInstances","keys","duration","analyse","placement","i","type","SEGMENT","end","shapeType","categoryIndex","getInstanceById","instanceId","setInstance","deleteInstance","prevInstance","getCurrentSplitInstance","undefined","updatedPrevInstance","selectedTime","canAddTiers","setCanAddTiers","index","first","second","addInstance","time","canAddTier","getCategory","isSegment","selectedId","add","startTime","endTime","updatePrevInstance","Array","isArray","from","Set","setSelectedInstance","categoryInstances","prevIndex","getAdjoinInstances","TIMING","nextInstance","findIndex","adjoinInstances","ids","oldInstances","oldInstance","_this$selectedInstanc","UNDOREDO","changeUndo","before","after","status","undo","saveStatus"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/store/InstanceStore.ts"],"sourcesContent":["import { makeAutoObservable, toJS } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport RootStore from './RootStore';\nimport { Status } from './UndoStore';\nimport { Instance, AnnotationType, UpdateType } from '../types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * all instances\n   */\n  instances: { [instanceId: string]: Instance } = {};\n\n  /**\n   * selected instances\n   */\n  selectedInstanceId: string | null = null;\n\n  /**\n   * selected number\n   */\n  selectedNumber: number | null = null;\n\n  /**\n   * update instances\n   */\n  updatedInstances: { [id: string]: Instance | null } = {};\n\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map: { [categoryName: string]: Instance[] } = {};\n    this.allInstances.forEach((instance) => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({ className }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.start - b.start);\n      }\n    });\n    return map;\n  };\n\n  /**\n   * selected instance\n   */\n  get selectedInstance() {\n    return this.selectedInstanceId ? toJS(this.instances[this.selectedInstanceId]) : null;\n  }\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    return Object.values(this.instances);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(list: Instance[]) {\n    if (list.length) {\n      const instances: {[id: string]: Instance} = {};\n      list.forEach((instance) => {\n        instances[instance.id] = instance;\n      });\n      this.instances = instances;\n      this.setUpdatedInstances(instances, UpdateType.INIT);\n    }\n  }\n\n  createDefaultInstances() {\n    const { categories } = this.rootStore.ontology;\n    if (Object.keys(this.instances).length === 0 && categories.length) {\n      const { duration } = this.rootStore.analyse.placement;\n      const instances: {[id: string]: Instance} = {};\n      categories.forEach((category, i) => {\n        if (category.type === AnnotationType.SEGMENT) {\n          const id = uuidv4();\n          instances[id] = {\n            id,\n            start: 0,\n            end: duration,\n            shapeType: category.type,\n            category: category.className,\n            categoryIndex: i,\n          };\n        }\n      });\n      this.instances = instances;\n      this.setUpdatedInstances(this.instances, UpdateType.INIT);\n    }\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId: string) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  setInstance(instance: Instance) {\n    this.instances[instance.id] = instance;\n  }\n\n  /**\n   * delete instance\n   * @param id\n   */\n  deleteInstance(id: string) {\n    if (this.instances[id]) {\n      const updatedInstances: { [id: string]: Instance | null; } = {};\n      const instance = toJS(this.instances[id]);\n      const { shapeType, category, categoryIndex, start, end } = instance;\n      updatedInstances[id] = null;\n      const prevInstance = shapeType === AnnotationType.SEGMENT ? this.getCurrentSplitInstance(category, start) : undefined;\n      if (prevInstance) {\n        const updatedPrevInstance: Instance = {\n          ...prevInstance,\n          end,\n        };\n        updatedInstances[prevInstance.id] = updatedPrevInstance;\n      }\n      if (start === this.rootStore.analyse.selectedTime) {\n        const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n        this.rootStore.ontology.setCanAddTiers({\n          ...canAddTiers,\n          [category]: {\n            index: categoryIndex,\n            first: true,\n            second: true,\n          }\n        });\n      }\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n\n  /**\n   * handle add shape\n   * @param className category\n   */\n  addInstance(className: string, time: number | number[]) {\n    const canAddTiers = toJS(this.rootStore.ontology.canAddTiers);\n    const canAddTier = canAddTiers[className];\n    if (className && canAddTier !== undefined) {\n      const categoryIndex = canAddTier.index;\n      const category = this.rootStore.ontology.getCategory(className)!;\n      const updatedInstances: { [id: string]: Instance } = {};\n      const shapeType = category.type;\n      const isSegment = shapeType === AnnotationType.SEGMENT;\n      let instance: Instance | null = null;\n      let selectedId = '';\n      const add = (startTime: number) => {\n        let endTime;\n        let prevInstance: Instance | undefined;\n        const id = uuidv4();\n        if (instance) {\n          prevInstance = instance;\n        } else {\n          selectedId = id;\n          prevInstance = isSegment ? this.getCurrentSplitInstance(className, startTime) : undefined;\n        }\n        if (prevInstance) {\n          const updatePrevInstance = {\n            ...prevInstance,\n            end: startTime,\n          };\n          updatedInstances[prevInstance.id] = updatePrevInstance;\n          endTime = prevInstance.end;\n        } else if (isSegment) {\n          const { duration } = this.rootStore.analyse.placement;\n          endTime = duration;\n        }\n        instance = {\n          id,\n          start: startTime,\n          end: endTime,\n          shapeType,\n          category: className,\n          categoryIndex\n        };\n        updatedInstances[instance.id] = instance;\n      };\n      if (Array.isArray(time)) {\n        Array.from(new Set(time)).sort((a, b) => a - b).forEach((start) => { add(start); });\n      } else {\n        add(time);\n      }\n      delete canAddTiers[className];\n      this.rootStore.ontology.setCanAddTiers(canAddTiers);\n      this.setSelectedInstance(updatedInstances[selectedId]);\n      this.setUpdatedInstances(updatedInstances);\n    }\n  }\n\n  updateInstances = (instances: { [id: string]: Instance }) => {\n    this.instances = {\n      ...toJS(this.instances),\n      ...instances\n    };\n  };\n\n  getCurrentSplitInstance(category: string, start: number) {\n    const categoryInstances = this.categoryInstancesMap[category];\n\n    if (categoryInstances.length === 1) {\n      if (categoryInstances[0].start !== start) {\n        return toJS(categoryInstances[0]);\n      }\n      return undefined;\n    }\n    let prevIndex = -1;\n    for (let i = 0; i < categoryInstances.length; i += 1) {\n      const instance = categoryInstances[i];\n      if (instance.end && (start <= instance.end && start > instance.start)) {\n        prevIndex = i;\n        break;\n      } else if (!instance.end && start > instance.start) {\n        prevIndex = i;\n        break;\n      }\n    }\n\n    return categoryInstances[prevIndex] ? toJS(categoryInstances[prevIndex]) : undefined;\n  }\n\n  getAdjoinInstances(category: string, start: number) {\n    const categoryInstances = this.categoryInstancesMap[category];\n\n    if (categoryInstances.length === 1 && this.rootStore.ontology.categories[categoryInstances[0].categoryIndex].type !== AnnotationType.TIMING) {\n      return {\n        prevInstance: toJS(categoryInstances[0]),\n        nextInstance: undefined,\n      };\n    }\n    const index = categoryInstances.findIndex((instance) => instance.start === start);\n    const adjoinInstances = {\n      prevInstance: categoryInstances[index - 1] ? toJS(categoryInstances[index - 1]) : undefined,\n      nextInstance: categoryInstances[index + 1] ? toJS(categoryInstances[index + 1]) : undefined,\n    };\n    return adjoinInstances;\n  }\n\n  /**\n   * set updated instances\n   */\n  setUpdatedInstances(instances: { [id: string]: Instance | null }, type?: string) {\n    const ids = Object.keys(instances);\n    if (ids.length === 0) {\n      return;\n    }\n    if (type !== UpdateType.INIT) {\n      const updatedInstances: { [id: string]: Instance } = {};\n      const oldInstances: { [id: string]: Instance | null } = {};\n      ids.forEach((id) => {\n        const oldInstance = this.instances[id];\n        oldInstances[id] = oldInstance ? toJS(oldInstance) : null;\n        const instance = instances[id];\n        if (instance) {\n          updatedInstances[id] = instance;\n        } else {\n          delete this.instances[id];\n          if (this.selectedInstance?.id === id) {\n            this.selectedInstanceId = null;\n          }\n        }\n      });\n      if (type !== UpdateType.UNDOREDO) {\n        this.changeUndo(oldInstances, instances);\n      }\n      this.updateInstances(updatedInstances);\n    }\n    this.updatedInstances = instances;\n  }\n\n  changeUndo(\n    oldInstances: { [id: string]: Instance | null },\n    updatedInstances: { [id: string]: Instance | null }\n  ) {\n    const before: Status[] = [];\n    const after: Status[] = [];\n    before.push({ type: 'instance',\n      status: {\n        ...oldInstances,\n      }\n    });\n    after.push({ type: 'instance',\n      status: {\n        ...updatedInstances,\n      }\n    });\n    this.rootStore.undo.saveStatus(before, after);\n  }\n\n  /**\n   * set selected instance\n   */\n  setSelectedInstance(instance: Instance | null) {\n    if (instance) {\n      if (this.selectedInstanceId === instance.id) return;\n      const categoryInstances = this.categoryInstancesMap[instance.category];\n      const prevInstance = this.getCurrentSplitInstance(instance.category, instance.start);\n      if (prevInstance) {\n        const index = categoryInstances.findIndex((i) => i.start === prevInstance.start);\n        this.selectedNumber = index + 2;\n      } else {\n        this.selectedNumber = 1;\n      }\n    } else {\n      this.selectedNumber = null;\n    }\n    this.selectedInstanceId = instance ? instance.id : null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}