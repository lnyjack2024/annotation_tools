{"ast":null,"code":"import { xor, findIndex } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { TAG, isLabel, isConnection, isInsertion, isQATool, toQA } from './tag_mode';\nimport { getTextByInsertion, getNextInLoopList } from '../utils/helper';\nclass DataProxy {\n  constructor() {\n    this.results = {\n      labels: [],\n      insertions: [],\n      connections: []\n    };\n    this.reviews = {\n      data: {},\n      missing: []\n    };\n  }\n  parseResults(newResult, idManager, configMap, text) {\n    idManager.clear();\n    if (!newResult) return;\n    const {\n      results\n    } = this;\n    const length = strlen(text);\n    // parse label\n    newResult.labels.forEach(label => {\n      var _configMap$get;\n      // invalid start & end\n      if (typeof label !== 'object') return;\n      if (Number.isNaN(label.start) || label.start === null || label.start < 0 || label.start >= length) {\n        label.dirty = true;\n        return;\n      }\n      if (Number.isNaN(label.end) || label.end === null || label.end < 0 || label.end >= length + 1) {\n        label.dirty = true;\n        return;\n      }\n      // invalid value\n      if (!isLabel((_configMap$get = configMap.get(label.value)) === null || _configMap$get === void 0 ? void 0 : _configMap$get.type)) {\n        label.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      label.id = idManager.checkAndInsert(label.id, TAG.LABEL);\n      // missing text\n      if (!label.text) label.text = substr(text, label.start, label.end - label.start);\n    });\n    results.labels = newResult.labels.filter(label => typeof label === 'object' && !label.dirty);\n    // parse insertion\n    newResult.insertions.forEach(insertion => {\n      var _configMap$get2;\n      // invalid start & end\n      if (typeof insertion !== 'object') return;\n      if (Number.isNaN(insertion.at) || insertion.at === null || insertion.at < 0 || insertion.at >= length) {\n        insertion.dirty = true;\n        return;\n      }\n      // invalid value\n      if (!isInsertion((_configMap$get2 = configMap.get(insertion.value)) === null || _configMap$get2 === void 0 ? void 0 : _configMap$get2.type)) {\n        insertion.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      insertion.id = idManager.checkAndInsert(insertion.id, TAG.INSERTION);\n      // missing text\n      if (!insertion.text) insertion.text = getTextByInsertion(this.text, insertion);\n    });\n    results.insertions = newResult.insertions.filter(insertion => typeof insertion === 'object' && !insertion.dirty);\n    // parse connection\n    newResult.connections.forEach(connection => {\n      var _configMap$get3;\n      // invalid start & end\n      if (typeof connection !== 'object') return;\n      // invalid value\n      if (!isConnection((_configMap$get3 = configMap.get(connection.value)) === null || _configMap$get3 === void 0 ? void 0 : _configMap$get3.type)) {\n        connection.dirty = true;\n        return;\n      }\n      // invalid from & to\n      if (findIndex(newResult.labels, {\n        id: connection.from\n      }) === -1 && findIndex(newResult.insertions, {\n        id: connection.from\n      }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      if (findIndex(newResult.labels, {\n        id: connection.to\n      }) === -1 && findIndex(newResult.insertions, {\n        id: connection.to\n      }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      connection.id = idManager.checkAndInsert(connection.id, TAG.CONNECTION);\n    });\n    results.connections = newResult.connections.filter(connection => typeof connection === 'object' && !connection.dirty);\n  }\n  parseReview(reviews, idManager, configMap, text) {\n    const length = strlen(text);\n    this.reviews.data = reviews.data;\n    this.reviews.missing = reviews.missing.filter(label => {\n      var _configMap$get4;\n      // invalid start & end\n      if (typeof label !== 'object') return false;\n      if (Number.isNaN(label.start) || label.start === null || label.start < 0 || label.start >= length) {\n        return false;\n      }\n      if (Number.isNaN(label.end) || label.end === null || label.end < 0 || label.end >= length) {\n        return false;\n      }\n      // invalid value\n      if (!isLabel((_configMap$get4 = configMap.get(label.value)) === null || _configMap$get4 === void 0 ? void 0 : _configMap$get4.type)) {\n        return false;\n      }\n      // invalid & missing id\n      label.id = idManager.checkAndInsert(label.id, toQA(TAG.LABEL));\n      // missing text\n      if (!label.text) label.text = substr(text, label.start, label.end - label.start);\n      return true;\n    });\n  }\n  getItem(id) {\n    const {\n      labels,\n      insertions,\n      connections\n    } = this.results;\n    const {\n      missing\n    } = this.reviews;\n    switch (true) {\n      case isQATool(id):\n        {\n          const index = findIndex(missing, {\n            id\n          });\n          return missing[index];\n        }\n      case isLabel(id):\n        {\n          const index = findIndex(labels, {\n            id\n          });\n          return labels[index];\n        }\n      case isConnection(id):\n        {\n          const index = findIndex(connections, {\n            id\n          });\n          return connections[index];\n        }\n      case isInsertion(id):\n        {\n          const index = findIndex(insertions, {\n            id\n          });\n          return insertions[index];\n        }\n      default:\n        return null;\n    }\n  }\n  getItemPosition(item) {\n    if (typeof item === 'object') {\n      switch (true) {\n        case isLabel(item.id):\n          return item.start;\n        case isInsertion(item.id):\n          return item.at;\n        case isConnection(item.id):\n          return this.getItemPosition(item.from);\n        default:\n          break;\n      }\n    } else {\n      switch (true) {\n        case isLabel(item):\n          return this.getItem(item).start;\n        case isInsertion(item):\n          return this.getItem(item).at;\n        case isConnection(item):\n          return this.getItemPosition(this.getItem(item));\n        default:\n          break;\n      }\n    }\n  }\n  loopNextPos(category, src) {\n    const pos = this.getItemPosition(src);\n    for (let i = 0; i < category.length; i += 1) {\n      const position = this.getItemPosition(category[i]);\n      if (category[i].id !== src && position >= pos) return {\n        tag: category[i],\n        position\n      };\n    }\n    return null;\n  }\n  moveToTagByStep(id, step, reviewOnly = false) {\n    const {\n      labels,\n      connections,\n      insertions\n    } = this.results;\n    const {\n      missing,\n      data\n    } = this.reviews;\n    if (reviewOnly) {\n      const list = Object.keys(data).map(key => this.getItem(key)).sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n      if (!data[id]) {\n        // if id is not reviewed item then start from 0\n        return list[0];\n      }\n      return getNextInLoopList(list, findIndex(list, {\n        id\n      }), step);\n    }\n    const list = missing.concat(labels).concat(connections).concat(insertions);\n    list.sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n    return getNextInLoopList(list, findIndex(list, {\n      id\n    }), step);\n  }\n  stepToTag(id, step) {\n    const {\n      labels,\n      connections,\n      insertions\n    } = this.results;\n    const {\n      missing\n    } = this.reviews;\n    let targetList;\n    switch (true) {\n      case isQATool(id):\n        targetList = missing;\n        break;\n      case isLabel(id):\n        targetList = labels;\n        break;\n      case isConnection(id):\n        targetList = connections;\n        break;\n      case isInsertion(id):\n        targetList = insertions;\n        break;\n      default:\n        break;\n    }\n    return targetList == null ? null : getNextInLoopList(targetList, findIndex(targetList, {\n      id\n    }), step);\n  }\n  getResults() {\n    const {\n      labels,\n      insertions,\n      connections\n    } = this.results;\n    const {\n      missing\n    } = this.reviews;\n    return {\n      labels: labels.concat(missing),\n      insertions,\n      connections\n    };\n  }\n  deleteTag(id) {\n    const {\n      connections,\n      labels,\n      insertions\n    } = this.results;\n    const {\n      missing,\n      data\n    } = this.reviews;\n    switch (true) {\n      case isQATool(id):\n        {\n          const index = findIndex(missing, {\n            id\n          });\n          const label = missing[index];\n          missing.splice(index, 1);\n          const delConnection = connections.filter(connection => connection.from === id || connection.to === id);\n          const nextConnections = connections.filter(connection => connection.from !== id && connection.to !== id);\n          const relatedConnections = xor(connections, nextConnections);\n          this.results.connections = nextConnections;\n          delete data[id];\n          delConnection.forEach(it => {\n            delete data[it.id];\n          });\n          return {\n            relatedConnections,\n            label\n          };\n        }\n      case isLabel(id):\n        {\n          const index = findIndex(labels, {\n            id\n          });\n          const label = labels[index];\n          labels.splice(index, 1);\n          const delConnection = connections.filter(connection => connection.from === id || connection.to === id);\n          const nextConnections = connections.filter(connection => connection.from !== id && connection.to !== id);\n          const relatedConnections = xor(connections, nextConnections);\n          this.results.connections = nextConnections;\n          // remove cooresponse review form\n          delete data[id];\n          delConnection.forEach(it => {\n            delete data[it.id];\n          });\n          return {\n            relatedConnections,\n            label\n          };\n        }\n      case isConnection(id):\n        {\n          const index = findIndex(connections, {\n            id\n          });\n          const connection = connections[index];\n          connections.splice(index, 1);\n          delete data[id];\n          return {\n            connection\n          };\n        }\n      case isInsertion(id):\n        {\n          const index = findIndex(insertions, {\n            id\n          });\n          const insertion = insertions[index];\n          insertions.splice(index, 1);\n          const delConnection = connections.filter(connection => connection.from === id || connection.to === id);\n          const nextConnections = connections.filter(connection => connection.from !== id && connection.to !== id);\n          const relatedConnections = xor(connections, nextConnections);\n          this.results.connections = nextConnections;\n\n          // remove cooresponse review form\n          delete data[id];\n          delConnection.forEach(it => {\n            delete data[it.id];\n          });\n          return {\n            relatedConnections,\n            insertion\n          };\n        }\n      default:\n        break;\n    }\n  }\n  addResultItem(id, newItem, relatedConnections = []) {\n    const {\n      insertions,\n      labels,\n      connections\n    } = this.results;\n    const {\n      missing\n    } = this.reviews;\n    switch (true) {\n      case isQATool(id):\n        {\n          missing.unshift(newItem);\n          missing.sort((a, b) => a.start - b.start);\n          relatedConnections.forEach(connection => {\n            connections.unshift(connection);\n          });\n          break;\n        }\n      case isLabel(id):\n        {\n          labels.unshift(newItem);\n          labels.sort((a, b) => a.start - b.start);\n          relatedConnections.forEach(connection => {\n            connections.unshift(connection);\n          });\n          break;\n        }\n      case isConnection(id):\n        {\n          connections.unshift(newItem);\n          break;\n        }\n      case isInsertion(id):\n        {\n          insertions.unshift(newItem);\n          insertions.sort((a, b) => a.at - b.at);\n          relatedConnections.forEach(connection => {\n            connections.unshift(connection);\n          });\n          break;\n        }\n      default:\n        break;\n    }\n  }\n  tagMove(prevStart, prevEnd, offset, text) {\n    this.results.labels = this.results.labels.map(label => {\n      const newLabel = {\n        ...label\n      };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) {\n        // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) {\n        // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) {\n        // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.map(insertion => {\n      const newInsertion = {\n        ...insertion\n      };\n      // insertions behind slice\n      if (insertion.at >= prevEnd) {\n        newInsertion.at += offset;\n      } else if (insertion.at > prevStart && insertion.at < prevEnd) newInsertion.dirty = true; // insertions contained slice\n      // insertions before slice\n      // nothing happened\n      if (insertion.at > prevStart - 5 && insertion.at < prevEnd + 5) {\n        newInsertion.text = getTextByInsertion(this.text, {\n          at: newInsertion.at,\n          value: newInsertion.value\n        });\n      }\n      return newInsertion;\n    });\n    this.reviews.missing = this.reviews.missing.map(label => {\n      const newLabel = {\n        ...label\n      };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) {\n        // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) {\n        // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) {\n        // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.filter(insertion => !insertion.dirty);\n    this.results.labels = this.results.labels.filter(label => !label.dirty);\n    this.reviews.missing = this.reviews.missing.filter(label => !label.dirty);\n  }\n  setReview(id, data) {\n    const {\n      reviews\n    } = this;\n    reviews.data[id] = data;\n  }\n  getReview(id) {\n    return this.reviews.data[id];\n  }\n}\nexport default DataProxy;","map":{"version":3,"names":["xor","findIndex","substr","strlen","TAG","isLabel","isConnection","isInsertion","isQATool","toQA","getTextByInsertion","getNextInLoopList","DataProxy","constructor","results","labels","insertions","connections","reviews","data","missing","parseResults","newResult","idManager","configMap","text","clear","length","forEach","label","_configMap$get","Number","isNaN","start","dirty","end","get","value","type","id","checkAndInsert","LABEL","filter","insertion","_configMap$get2","at","INSERTION","connection","_configMap$get3","from","to","CONNECTION","parseReview","_configMap$get4","getItem","index","getItemPosition","item","loopNextPos","category","src","pos","i","position","tag","moveToTagByStep","step","reviewOnly","list","Object","keys","map","key","sort","a","b","concat","stepToTag","targetList","getResults","deleteTag","splice","delConnection","nextConnections","relatedConnections","it","addResultItem","newItem","unshift","tagMove","prevStart","prevEnd","offset","newLabel","newInsertion","setReview","getReview"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/data/dataProxy.js"],"sourcesContent":["import { xor, findIndex } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { TAG, isLabel, isConnection, isInsertion, isQATool, toQA } from './tag_mode';\nimport { getTextByInsertion, getNextInLoopList } from '../utils/helper';\n\nclass DataProxy {\n  constructor() {\n    this.results = {\n      labels: [],\n      insertions: [],\n      connections: [],\n    };\n    this.reviews = {\n      data: {},\n      missing: [],\n    };\n  }\n\n  parseResults(newResult, idManager, configMap, text) {\n    idManager.clear();\n    if (!newResult) return;\n    const { results } = this;\n    const length = strlen(text);\n    // parse label\n    newResult.labels.forEach((label) => {\n      // invalid start & end\n      if (typeof (label) !== 'object') return;\n      if (Number.isNaN(label.start) || label.start === null || label.start < 0 || label.start >= length) {\n        label.dirty = true;\n        return;\n      }\n      if (Number.isNaN(label.end) || label.end === null || label.end < 0 || label.end >= length + 1) {\n        label.dirty = true;\n        return;\n      }\n      // invalid value\n      if (!isLabel(configMap.get(label.value)?.type)) {\n        label.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      label.id = idManager.checkAndInsert(label.id, TAG.LABEL);\n      // missing text\n      if (!label.text) label.text = substr(text, label.start, label.end - label.start);\n    });\n    results.labels = newResult.labels.filter((label) => typeof (label) === 'object' && !label.dirty);\n    // parse insertion\n    newResult.insertions.forEach((insertion) => {\n      // invalid start & end\n      if (typeof (insertion) !== 'object') return;\n      if (Number.isNaN(insertion.at) || insertion.at === null || insertion.at < 0 || insertion.at >= length) {\n        insertion.dirty = true;\n        return;\n      }\n      // invalid value\n      if (!isInsertion(configMap.get(insertion.value)?.type)) {\n        insertion.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      insertion.id = idManager.checkAndInsert(insertion.id, TAG.INSERTION);\n      // missing text\n      if (!insertion.text) insertion.text = getTextByInsertion(this.text, insertion);\n    });\n    results.insertions = newResult.insertions.filter((insertion) => typeof (insertion) === 'object' && !insertion.dirty);\n    // parse connection\n    newResult.connections.forEach((connection) => {\n      // invalid start & end\n      if (typeof (connection) !== 'object') return;\n      // invalid value\n      if (!isConnection(configMap.get(connection.value)?.type)) {\n        connection.dirty = true;\n        return;\n      }\n      // invalid from & to\n      if (findIndex(newResult.labels, { id: connection.from }) === -1 && findIndex(newResult.insertions, { id: connection.from }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      if (findIndex(newResult.labels, { id: connection.to }) === -1 && findIndex(newResult.insertions, { id: connection.to }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      connection.id = idManager.checkAndInsert(connection.id, TAG.CONNECTION);\n    });\n    results.connections = newResult.connections.filter((connection) => typeof (connection) === 'object' && !connection.dirty);\n  }\n\n  parseReview(reviews, idManager, configMap, text) {\n    const length = strlen(text);\n    this.reviews.data = reviews.data;\n    this.reviews.missing = reviews.missing.filter((label) => {\n      // invalid start & end\n      if (typeof (label) !== 'object') return false;\n      if (Number.isNaN(label.start) || label.start === null || label.start < 0 || label.start >= length) {\n        return false;\n      }\n      if (Number.isNaN(label.end) || label.end === null || label.end < 0 || label.end >= length) {\n        return false;\n      }\n      // invalid value\n      if (!isLabel(configMap.get(label.value)?.type)) {\n        return false;\n      }\n      // invalid & missing id\n      label.id = idManager.checkAndInsert(label.id, toQA(TAG.LABEL));\n      // missing text\n      if (!label.text) label.text = substr(text, label.start, label.end - label.start);\n      return true;\n    });\n  }\n\n  getItem(id) {\n    const { labels, insertions, connections } = this.results;\n    const { missing } = this.reviews;\n    switch (true) {\n      case (isQATool(id)): {\n        const index = findIndex(missing, { id });\n        return missing[index];\n      }\n      case (isLabel(id)): {\n        const index = findIndex(labels, { id });\n        return labels[index];\n      }\n      case (isConnection(id)): {\n        const index = findIndex(connections, { id });\n        return connections[index];\n      }\n      case (isInsertion(id)): {\n        const index = findIndex(insertions, { id });\n        return insertions[index];\n      }\n      default: return null;\n    }\n  }\n\n  getItemPosition(item) {\n    if (typeof item === 'object') {\n      switch (true) {\n        case (isLabel(item.id)): return item.start;\n        case (isInsertion(item.id)): return item.at;\n        case (isConnection(item.id)): return this.getItemPosition(item.from);\n        default: break;\n      }\n    } else {\n      switch (true) {\n        case (isLabel(item)): return this.getItem(item).start;\n        case (isInsertion(item)): return this.getItem(item).at;\n        case (isConnection(item)): return this.getItemPosition(this.getItem(item));\n        default: break;\n      }\n    }\n  }\n\n  loopNextPos(category, src) {\n    const pos = this.getItemPosition(src);\n    for (let i = 0; i < category.length; i += 1) {\n      const position = this.getItemPosition(category[i]);\n      if (category[i].id !== src && position >= pos) return { tag: category[i], position };\n    }\n    return null;\n  }\n\n  moveToTagByStep(id, step, reviewOnly = false) {\n    const { labels, connections, insertions } = this.results;\n    const { missing, data } = this.reviews;\n\n    if (reviewOnly) {\n      const list = Object.keys(data).map((key) => this.getItem(key))\n        .sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n      if (!data[id]) { // if id is not reviewed item then start from 0\n        return list[0];\n      }\n      return getNextInLoopList(list, findIndex(list, { id }), step);\n    }\n\n    const list = missing.concat(labels).concat(connections).concat(insertions);\n    list.sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n    return getNextInLoopList(list, findIndex(list, { id }), step);\n  }\n\n  stepToTag(id, step) {\n    const { labels, connections, insertions } = this.results;\n    const { missing } = this.reviews;\n    let targetList;\n    switch (true) {\n      case (isQATool(id)): targetList = missing; break;\n      case (isLabel(id)): targetList = labels; break;\n      case (isConnection(id)): targetList = connections; break;\n      case (isInsertion(id)): targetList = insertions; break;\n      default: break;\n    }\n    return targetList == null ? null : getNextInLoopList(targetList, findIndex(targetList, { id }), step);\n  }\n\n  getResults() {\n    const { labels, insertions, connections } = this.results;\n    const { missing } = this.reviews;\n    return {\n      labels: labels.concat(missing),\n      insertions,\n      connections,\n    };\n  }\n\n  deleteTag(id) {\n    const { connections, labels, insertions } = this.results;\n    const { missing, data } = this.reviews;\n\n    switch (true) {\n      case (isQATool(id)): {\n        const index = findIndex(missing, { id });\n        const label = missing[index];\n        missing.splice(index, 1);\n        const delConnection = connections.filter((connection) => connection.from === id || connection.to === id);\n        const nextConnections = connections.filter((connection) => connection.from !== id && connection.to !== id);\n        const relatedConnections = xor(connections, nextConnections);\n        this.results.connections = nextConnections;\n        delete data[id];\n        delConnection.forEach((it) => {\n          delete data[it.id];\n        });\n        return { relatedConnections, label };\n      }\n      case (isLabel(id)): {\n        const index = findIndex(labels, { id });\n        const label = labels[index];\n        labels.splice(index, 1);\n        const delConnection = connections.filter((connection) => connection.from === id || connection.to === id);\n        const nextConnections = connections.filter((connection) => connection.from !== id && connection.to !== id);\n        const relatedConnections = xor(connections, nextConnections);\n        this.results.connections = nextConnections;\n        // remove cooresponse review form\n        delete data[id];\n        delConnection.forEach((it) => {\n          delete data[it.id];\n        });\n        return { relatedConnections, label };\n      }\n      case (isConnection(id)): {\n        const index = findIndex(connections, { id });\n        const connection = connections[index];\n        connections.splice(index, 1);\n        delete data[id];\n        return { connection };\n      }\n      case (isInsertion(id)): {\n        const index = findIndex(insertions, { id });\n        const insertion = insertions[index];\n        insertions.splice(index, 1);\n        const delConnection = connections.filter((connection) => connection.from === id || connection.to === id);\n        const nextConnections = connections.filter((connection) => connection.from !== id && connection.to !== id);\n        const relatedConnections = xor(connections, nextConnections);\n        this.results.connections = nextConnections;\n\n        // remove cooresponse review form\n        delete data[id];\n        delConnection.forEach((it) => {\n          delete data[it.id];\n        });\n        return { relatedConnections, insertion };\n      }\n      default: break;\n    }\n  }\n\n  addResultItem(id, newItem, relatedConnections = []) {\n    const { insertions, labels, connections } = this.results;\n    const { missing } = this.reviews;\n    switch (true) {\n      case (isQATool(id)): {\n        missing.unshift(newItem);\n        missing.sort((a, b) => (a.start - b.start));\n        relatedConnections.forEach((connection) => {\n          connections.unshift((connection));\n        });\n        break;\n      }\n      case (isLabel(id)): {\n        labels.unshift(newItem);\n        labels.sort((a, b) => (a.start - b.start));\n        relatedConnections.forEach((connection) => {\n          connections.unshift((connection));\n        });\n        break;\n      }\n      case (isConnection(id)): {\n        connections.unshift(newItem);\n        break;\n      }\n      case (isInsertion(id)): {\n        insertions.unshift(newItem);\n        insertions.sort((a, b) => a.at - b.at);\n        relatedConnections.forEach((connection) => {\n          connections.unshift(connection);\n        });\n        break;\n      }\n      default: break;\n    }\n  }\n\n  tagMove(prevStart, prevEnd, offset, text) {\n    this.results.labels = this.results.labels.map((label) => {\n      const newLabel = { ...label };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) { // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) { // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) { // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.map((insertion) => {\n      const newInsertion = { ...insertion };\n      // insertions behind slice\n      if (insertion.at >= prevEnd) {\n        newInsertion.at += offset;\n      } else if (insertion.at > prevStart && insertion.at < prevEnd) newInsertion.dirty = true; // insertions contained slice\n      // insertions before slice\n      // nothing happened\n      if (insertion.at > prevStart - 5 && insertion.at < prevEnd + 5) {\n        newInsertion.text = getTextByInsertion(this.text, { at: newInsertion.at, value: newInsertion.value });\n      }\n      return newInsertion;\n    });\n    this.reviews.missing = this.reviews.missing.map((label) => {\n      const newLabel = { ...label };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) { // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) { // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) { // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.filter((insertion) => !insertion.dirty);\n    this.results.labels = this.results.labels.filter((label) => !label.dirty);\n    this.reviews.missing = this.reviews.missing.filter((label) => !label.dirty);\n  }\n\n  setReview(id, data) {\n    const { reviews } = this;\n    reviews.data[id] = data;\n  }\n\n  getReview(id) {\n    return this.reviews.data[id];\n  }\n}\n\nexport default DataProxy;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}