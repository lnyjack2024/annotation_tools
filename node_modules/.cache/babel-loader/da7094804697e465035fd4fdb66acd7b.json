{"ast":null,"code":"import { Graphics } from 'pixi.js';\nimport { BorderStyle } from './Shape';\nimport { ShapeLineType, ShapeVertexType } from './types';\nimport { drawVertex } from './utils';\nimport { curveLength } from '../../../utils/math';\n\n/**\n * Extended Graphics, with shape instance\n * @class\n */\nexport default class ShapeGraphics extends Graphics {\n  constructor(shape) {\n    super();\n    /**\n     * shape instance\n     * @member {Shape}\n     */\n    this.shape = void 0;\n    this.shape = shape;\n  }\n  dashLineTo(toX, toY, dash = 6, gap = 4) {\n    const {\n      points\n    } = this.currentPath;\n    const currentPosition = {\n      x: points[points.length - 2],\n      y: points[points.length - 1]\n    };\n    const toRight = currentPosition.x < toX;\n    const toBottom = currentPosition.y < toY;\n    const scaledDash = Math.max(dash / this.shape.scale, dash / 2);\n    const scaledGap = Math.max(gap / this.shape.scale, gap / 2);\n    const radian = Math.atan2(toY - currentPosition.y, toX - currentPosition.x);\n    const dashX = Math.cos(radian) * scaledDash;\n    const dashY = Math.sin(radian) * scaledDash;\n    const gapX = Math.cos(radian) * scaledGap;\n    const gapY = Math.sin(radian) * scaledGap;\n\n    // for vertical or horizontal line, when sin(cos) = 1, cos(sin) != 0\n    // add precision for these kind of cases to avoid oom\n    while (Math.abs(currentPosition.x - toX) > 0.00001 && (toRight ? currentPosition.x < toX : currentPosition.x > toX) || Math.abs(currentPosition.y - toY) > 0.00001 && (toBottom ? currentPosition.y < toY : currentPosition.y > toY)) {\n      currentPosition.x += dashX;\n      currentPosition.y += dashY;\n      if (toRight ? currentPosition.x > toX : currentPosition.x < toX) {\n        currentPosition.x = toX;\n      }\n      if (toBottom ? currentPosition.y > toY : currentPosition.y < toY) {\n        currentPosition.y = toY;\n      }\n      this.lineTo(currentPosition.x, currentPosition.y);\n      currentPosition.x += gapX;\n      currentPosition.y += gapY;\n      if (toRight ? currentPosition.x > toX : currentPosition.x < toX) {\n        currentPosition.x = toX;\n      }\n      if (toBottom ? currentPosition.y > toY : currentPosition.y < toY) {\n        currentPosition.y = toY;\n      }\n      this.moveTo(currentPosition.x, currentPosition.y);\n    }\n  }\n  dashBezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY, dash = 6, gap = 4, scale = true) {\n    const {\n      points\n    } = this.currentPath;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const scaledDash = scale ? Math.max(dash / this.shape.scale, dash / 2) : dash;\n    const scaledGap = scale ? Math.max(gap / this.shape.scale, gap / 2) : gap;\n    const len = curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY);\n    const groupCount = len / (scaledDash + scaledGap);\n    const groupLen = len / groupCount;\n    let groupIndex = 0;\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n    for (let i = 1, j = 0; i <= len; i += 1) {\n      j = i / len;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      const px = dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX;\n      const py = dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY;\n      if (i <= groupIndex * groupLen + scaledDash) {\n        this.lineTo(px, py);\n      } else if (i < (groupIndex + 1) * groupLen) {\n        this.moveTo(px, py);\n      } else {\n        this.moveTo(px, py);\n        groupIndex += 1;\n      }\n    }\n  }\n  drawLine(toX, toY, borderStyle, type = ShapeLineType.STRAIGHT) {\n    if (borderStyle === BorderStyle.DASHED) {\n      this.dashLineTo(toX, toY);\n    } else {\n      switch (type) {\n        case ShapeLineType.STRAIGHT:\n          this.lineTo(toX, toY);\n          break;\n        case ShapeLineType.WAVY:\n          {\n            const {\n              points\n            } = this.currentPath;\n            const currentPosition = {\n              x: points[points.length - 2],\n              y: points[points.length - 1]\n            };\n            const d = Math.max(2 / this.shape.scale, 1); // side edge to control point\n            const d2 = Math.max(4 / this.shape.scale, 2);\n            const offsetY = toY - currentPosition.y;\n            const offsetX = toX - currentPosition.x;\n            const radian = Math.atan2(offsetY, offsetX);\n            const sinD = Math.sin(radian) * d2;\n            const cosD = Math.cos(radian) * d2;\n            const sin2D = sinD * 2;\n            const cos2D = cosD * 2;\n            const sinPlus = Math.sin(radian + Math.PI / 4) * d;\n            const cosPlus = Math.cos(radian + Math.PI / 4) * d;\n            const sinMinus = Math.sin(Math.PI / 4 - radian) * d;\n            const cosMinus = Math.cos(Math.PI / 4 - radian) * d;\n            const decimalCount = Math.sqrt(offsetX ** 2 + offsetY ** 2) / (d2 * 2);\n            const count = Math.floor(decimalCount);\n            for (let i = 0; i <= count; i += 1) {\n              const py1 = sinD + currentPosition.y;\n              const px1 = cosD + currentPosition.x;\n              const py2 = sin2D + currentPosition.y;\n              const px2 = cos2D + currentPosition.x;\n              const cpY1 = sinPlus + currentPosition.y;\n              const cpX1 = cosPlus + currentPosition.x;\n              const cpY2 = sinMinus + py1;\n              const cpX2 = -cosMinus + px1;\n              const cpY3 = -sinMinus + py1;\n              const cpX3 = cosMinus + px1;\n              const cpY4 = -sinPlus + py2;\n              const cpX4 = -cosPlus + px2;\n              if (i === count) {\n                if (decimalCount - count <= 0.5) {\n                  this.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, toX, toY);\n                } else {\n                  this.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, px1, py1);\n                  this.bezierCurveTo(cpX3, cpY3, cpX4, cpY4, toX, toY);\n                }\n              } else {\n                this.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, px1, py1);\n                this.bezierCurveTo(cpX3, cpY3, cpX4, cpY4, px2, py2);\n                currentPosition.x = px2;\n                currentPosition.y = py2;\n              }\n            }\n            break;\n          }\n        case ShapeLineType.BROKEN:\n          {\n            const {\n              points\n            } = this.currentPath;\n            const currentPosition = {\n              x: points[points.length - 2],\n              y: points[points.length - 1]\n            };\n            const d = Math.max(4 / this.shape.scale, 2); // short edge\n            const d2 = Math.sqrt(2) * d; // long edge\n            const offsetY = toY - currentPosition.y;\n            const offsetX = toX - currentPosition.x;\n            const radian = Math.atan2(offsetY, offsetX);\n            const sinD = Math.sin(radian) * d2;\n            const cosD = Math.cos(radian) * d2;\n            const sin2D = sinD * 2;\n            const cos2D = cosD * 2;\n            const sinPlus = Math.sin(radian + Math.PI / 4) * d;\n            const cosPlus = Math.cos(radian + Math.PI / 4) * d;\n            const sinMinus = Math.sin(Math.PI / 4 - radian) * d;\n            const cosMinus = Math.cos(Math.PI / 4 - radian) * d;\n            const decimalCount = Math.sqrt(offsetX ** 2 + offsetY ** 2) / (d2 * 2);\n            const count = Math.floor(decimalCount);\n            const leftPointsCount = Math.floor((decimalCount - count) / 0.25);\n            for (let i = 0; i <= count; i += 1) {\n              const py1 = sinPlus + currentPosition.y;\n              const px1 = cosPlus + currentPosition.x;\n              const py2 = sinD + currentPosition.y;\n              const px2 = cosD + currentPosition.x;\n              const py3 = -sinMinus + py2;\n              const px3 = cosMinus + px2;\n              const py4 = sin2D + currentPosition.y;\n              const px4 = cos2D + currentPosition.x;\n              const fourPoints = [[px1, py1], [px2, py2], [px3, py3], [px4, py4]];\n              const pointsCount = i === count ? leftPointsCount : 4;\n              for (let j = 0; j < pointsCount; j += 1) {\n                currentPosition.x = fourPoints[j][0];\n                currentPosition.y = fourPoints[j][1];\n                this.lineTo(currentPosition.x, currentPosition.y);\n              }\n            }\n            currentPosition.x = toX;\n            currentPosition.y = toY;\n            this.lineTo(currentPosition.x, currentPosition.y);\n            break;\n          }\n        default:\n          this.lineTo(toX, toY);\n      }\n    }\n  }\n  drawVertex(x, y, size, type = ShapeVertexType.DOT) {\n    drawVertex(this, x, y, size, type);\n  }\n}","map":{"version":3,"names":["Graphics","BorderStyle","ShapeLineType","ShapeVertexType","drawVertex","curveLength","ShapeGraphics","constructor","shape","dashLineTo","toX","toY","dash","gap","points","currentPath","currentPosition","x","length","y","toRight","toBottom","scaledDash","Math","max","scale","scaledGap","radian","atan2","dashX","cos","dashY","sin","gapX","gapY","abs","lineTo","moveTo","dashBezierCurveTo","cpX","cpY","cpX2","cpY2","fromX","fromY","len","groupCount","groupLen","groupIndex","dt","dt2","dt3","t2","t3","i","j","px","py","drawLine","borderStyle","type","STRAIGHT","DASHED","WAVY","d","d2","offsetY","offsetX","sinD","cosD","sin2D","cos2D","sinPlus","PI","cosPlus","sinMinus","cosMinus","decimalCount","sqrt","count","floor","py1","px1","py2","px2","cpY1","cpX1","cpY3","cpX3","cpY4","cpX4","bezierCurveTo","BROKEN","leftPointsCount","py3","px3","py4","px4","fourPoints","pointsCount","size","DOT"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/ShapeGraphics.ts"],"sourcesContent":["import { Graphics } from 'pixi.js';\nimport Shape, { BorderStyle } from './Shape';\nimport { ShapeLineType, ShapeVertexType } from './types';\nimport { drawVertex } from './utils';\nimport { curveLength } from '../../../utils/math';\n\n/**\n * Extended Graphics, with shape instance\n * @class\n */\nexport default class ShapeGraphics<T> extends Graphics {\n  /**\n   * shape instance\n   * @member {Shape}\n   */\n  shape: Shape<T>;\n\n  constructor(shape: Shape<T>) {\n    super();\n    this.shape = shape;\n  }\n\n  dashLineTo(toX: number, toY: number, dash = 6, gap = 4) {\n    const { points } = this.currentPath;\n    const currentPosition = {\n      x: points[points.length - 2],\n      y: points[points.length - 1],\n    };\n\n    const toRight = currentPosition.x < toX;\n    const toBottom = currentPosition.y < toY;\n\n    const scaledDash = Math.max(dash / this.shape.scale, dash / 2);\n    const scaledGap = Math.max(gap / this.shape.scale, gap / 2);\n    const radian = Math.atan2(toY - currentPosition.y, toX - currentPosition.x);\n    const dashX = Math.cos(radian) * scaledDash;\n    const dashY = Math.sin(radian) * scaledDash;\n    const gapX = Math.cos(radian) * scaledGap;\n    const gapY = Math.sin(radian) * scaledGap;\n\n    // for vertical or horizontal line, when sin(cos) = 1, cos(sin) != 0\n    // add precision for these kind of cases to avoid oom\n    while (\n      (Math.abs(currentPosition.x - toX) > 0.00001 && (toRight ? currentPosition.x < toX : currentPosition.x > toX)) ||\n      (Math.abs(currentPosition.y - toY) > 0.00001 && (toBottom ? currentPosition.y < toY : currentPosition.y > toY))\n    ) {\n      currentPosition.x += dashX;\n      currentPosition.y += dashY;\n      if (toRight ? currentPosition.x > toX : currentPosition.x < toX) {\n        currentPosition.x = toX;\n      }\n      if (toBottom ? currentPosition.y > toY : currentPosition.y < toY) {\n        currentPosition.y = toY;\n      }\n      this.lineTo(currentPosition.x, currentPosition.y);\n\n      currentPosition.x += gapX;\n      currentPosition.y += gapY;\n      if (toRight ? currentPosition.x > toX : currentPosition.x < toX) {\n        currentPosition.x = toX;\n      }\n      if (toBottom ? currentPosition.y > toY : currentPosition.y < toY) {\n        currentPosition.y = toY;\n      }\n      this.moveTo(currentPosition.x, currentPosition.y);\n    }\n  }\n\n  dashBezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number, dash = 6, gap = 4, scale = true) {\n    const { points } = this.currentPath;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const scaledDash = scale ? Math.max(dash / this.shape.scale, dash / 2) : dash;\n    const scaledGap = scale ? Math.max(gap / this.shape.scale, gap / 2) : gap;\n\n    const len = curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY);\n    const groupCount = len / (scaledDash + scaledGap);\n    const groupLen = len / groupCount;\n    let groupIndex = 0;\n\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n\n    for (let i = 1, j = 0; i <= len; i += 1) {\n      j = i / len;\n\n      dt = (1 - j);\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n\n      t2 = j * j;\n      t3 = t2 * j;\n\n      const px = (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX);\n      const py = (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY);\n\n      if (i <= groupIndex * groupLen + scaledDash) {\n        this.lineTo(px, py);\n      } else if (i < (groupIndex + 1) * groupLen) {\n        this.moveTo(px, py);\n      } else {\n        this.moveTo(px, py);\n        groupIndex += 1;\n      }\n    }\n  }\n\n  drawLine(toX: number, toY: number, borderStyle: BorderStyle, type = ShapeLineType.STRAIGHT) {\n    if (borderStyle === BorderStyle.DASHED) {\n      this.dashLineTo(toX, toY);\n    } else {\n      switch (type) {\n        case ShapeLineType.STRAIGHT:\n          this.lineTo(toX, toY);\n          break;\n        case ShapeLineType.WAVY: {\n          const { points } = this.currentPath;\n          const currentPosition = {\n            x: points[points.length - 2],\n            y: points[points.length - 1],\n          };\n\n          const d = Math.max(2 / this.shape.scale, 1); // side edge to control point\n          const d2 = Math.max(4 / this.shape.scale, 2);\n          const offsetY = toY - currentPosition.y;\n          const offsetX = toX - currentPosition.x;\n          const radian = Math.atan2(offsetY, offsetX);\n          const sinD = Math.sin(radian) * d2;\n          const cosD = Math.cos(radian) * d2;\n          const sin2D = sinD * 2;\n          const cos2D = cosD * 2;\n          const sinPlus = Math.sin(radian + Math.PI / 4) * d;\n          const cosPlus = Math.cos(radian + Math.PI / 4) * d;\n          const sinMinus = Math.sin(Math.PI / 4 - radian) * d;\n          const cosMinus = Math.cos(Math.PI / 4 - radian) * d;\n          const decimalCount = Math.sqrt(offsetX ** 2 + offsetY ** 2) / (d2 * 2);\n          const count = Math.floor(decimalCount);\n\n          for (let i = 0; i <= count; i += 1) {\n            const py1 = sinD + currentPosition.y;\n            const px1 = cosD + currentPosition.x;\n            const py2 = sin2D + currentPosition.y;\n            const px2 = cos2D + currentPosition.x;\n            const cpY1 = sinPlus + currentPosition.y;\n            const cpX1 = cosPlus + currentPosition.x;\n            const cpY2 = sinMinus + py1;\n            const cpX2 = -cosMinus + px1;\n            const cpY3 = -sinMinus + py1;\n            const cpX3 = cosMinus + px1;\n            const cpY4 = -sinPlus + py2;\n            const cpX4 = -cosPlus + px2;\n\n            if (i === count) {\n              if (decimalCount - count <= 0.5) {\n                this.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, toX, toY);\n              } else {\n                this.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, px1, py1);\n                this.bezierCurveTo(cpX3, cpY3, cpX4, cpY4, toX, toY);\n              }\n            } else {\n              this.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, px1, py1);\n              this.bezierCurveTo(cpX3, cpY3, cpX4, cpY4, px2, py2);\n              currentPosition.x = px2;\n              currentPosition.y = py2;\n            }\n          }\n\n          break;\n        }\n        case ShapeLineType.BROKEN: {\n          const { points } = this.currentPath;\n          const currentPosition = {\n            x: points[points.length - 2],\n            y: points[points.length - 1],\n          };\n\n          const d = Math.max(4 / this.shape.scale, 2); // short edge\n          const d2 = Math.sqrt(2) * d; // long edge\n          const offsetY = toY - currentPosition.y;\n          const offsetX = toX - currentPosition.x;\n          const radian = Math.atan2(offsetY, offsetX);\n          const sinD = Math.sin(radian) * d2;\n          const cosD = Math.cos(radian) * d2;\n          const sin2D = sinD * 2;\n          const cos2D = cosD * 2;\n          const sinPlus = Math.sin(radian + Math.PI / 4) * d;\n          const cosPlus = Math.cos(radian + Math.PI / 4) * d;\n          const sinMinus = Math.sin(Math.PI / 4 - radian) * d;\n          const cosMinus = Math.cos(Math.PI / 4 - radian) * d;\n          const decimalCount = Math.sqrt(offsetX ** 2 + offsetY ** 2) / (d2 * 2);\n          const count = Math.floor(decimalCount);\n          const leftPointsCount = Math.floor((decimalCount - count) / 0.25);\n\n          for (let i = 0; i <= count; i += 1) {\n            const py1 = sinPlus + currentPosition.y;\n            const px1 = cosPlus + currentPosition.x;\n            const py2 = sinD + currentPosition.y;\n            const px2 = cosD + currentPosition.x;\n            const py3 = -sinMinus + py2;\n            const px3 = cosMinus + px2;\n            const py4 = sin2D + currentPosition.y;\n            const px4 = cos2D + currentPosition.x;\n            const fourPoints = [\n              [px1, py1],\n              [px2, py2],\n              [px3, py3],\n              [px4, py4],\n            ];\n            const pointsCount = i === count ? leftPointsCount : 4;\n            for (let j = 0; j < pointsCount; j += 1) {\n              currentPosition.x = fourPoints[j][0];\n              currentPosition.y = fourPoints[j][1];\n              this.lineTo(currentPosition.x, currentPosition.y);\n            }\n          }\n          currentPosition.x = toX;\n          currentPosition.y = toY;\n          this.lineTo(currentPosition.x, currentPosition.y);\n\n          break;\n        }\n        default:\n          this.lineTo(toX, toY);\n      }\n    }\n  }\n\n  drawVertex(x: number, y: number, size: number, type = ShapeVertexType.DOT) {\n    drawVertex(this, x, y, size, type);\n  }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,SAAS;AAClC,SAAgBC,WAAW,QAAQ,SAAS;AAC5C,SAASC,aAAa,EAAEC,eAAe,QAAQ,SAAS;AACxD,SAASC,UAAU,QAAQ,SAAS;AACpC,SAASC,WAAW,QAAQ,qBAAqB;;AAEjD;AACA;AACA;AACA;AACA,eAAe,MAAMC,aAAa,SAAYN,QAAQ,CAAC;EAOrDO,WAAWA,CAACC,KAAe,EAAE;IAC3B,KAAK,CAAC,CAAC;IAPT;AACF;AACA;AACA;IAHE,KAIAA,KAAK;IAIH,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;EAEAC,UAAUA,CAACC,GAAW,EAAEC,GAAW,EAAEC,IAAI,GAAG,CAAC,EAAEC,GAAG,GAAG,CAAC,EAAE;IACtD,MAAM;MAAEC;IAAO,CAAC,GAAG,IAAI,CAACC,WAAW;IACnC,MAAMC,eAAe,GAAG;MACtBC,CAAC,EAAEH,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;MAC5BC,CAAC,EAAEL,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC;IAC7B,CAAC;IAED,MAAME,OAAO,GAAGJ,eAAe,CAACC,CAAC,GAAGP,GAAG;IACvC,MAAMW,QAAQ,GAAGL,eAAe,CAACG,CAAC,GAAGR,GAAG;IAExC,MAAMW,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACZ,IAAI,GAAG,IAAI,CAACJ,KAAK,CAACiB,KAAK,EAAEb,IAAI,GAAG,CAAC,CAAC;IAC9D,MAAMc,SAAS,GAAGH,IAAI,CAACC,GAAG,CAACX,GAAG,GAAG,IAAI,CAACL,KAAK,CAACiB,KAAK,EAAEZ,GAAG,GAAG,CAAC,CAAC;IAC3D,MAAMc,MAAM,GAAGJ,IAAI,CAACK,KAAK,CAACjB,GAAG,GAAGK,eAAe,CAACG,CAAC,EAAET,GAAG,GAAGM,eAAe,CAACC,CAAC,CAAC;IAC3E,MAAMY,KAAK,GAAGN,IAAI,CAACO,GAAG,CAACH,MAAM,CAAC,GAAGL,UAAU;IAC3C,MAAMS,KAAK,GAAGR,IAAI,CAACS,GAAG,CAACL,MAAM,CAAC,GAAGL,UAAU;IAC3C,MAAMW,IAAI,GAAGV,IAAI,CAACO,GAAG,CAACH,MAAM,CAAC,GAAGD,SAAS;IACzC,MAAMQ,IAAI,GAAGX,IAAI,CAACS,GAAG,CAACL,MAAM,CAAC,GAAGD,SAAS;;IAEzC;IACA;IACA,OACGH,IAAI,CAACY,GAAG,CAACnB,eAAe,CAACC,CAAC,GAAGP,GAAG,CAAC,GAAG,OAAO,KAAKU,OAAO,GAAGJ,eAAe,CAACC,CAAC,GAAGP,GAAG,GAAGM,eAAe,CAACC,CAAC,GAAGP,GAAG,CAAC,IAC5Ga,IAAI,CAACY,GAAG,CAACnB,eAAe,CAACG,CAAC,GAAGR,GAAG,CAAC,GAAG,OAAO,KAAKU,QAAQ,GAAGL,eAAe,CAACG,CAAC,GAAGR,GAAG,GAAGK,eAAe,CAACG,CAAC,GAAGR,GAAG,CAAE,EAC/G;MACAK,eAAe,CAACC,CAAC,IAAIY,KAAK;MAC1Bb,eAAe,CAACG,CAAC,IAAIY,KAAK;MAC1B,IAAIX,OAAO,GAAGJ,eAAe,CAACC,CAAC,GAAGP,GAAG,GAAGM,eAAe,CAACC,CAAC,GAAGP,GAAG,EAAE;QAC/DM,eAAe,CAACC,CAAC,GAAGP,GAAG;MACzB;MACA,IAAIW,QAAQ,GAAGL,eAAe,CAACG,CAAC,GAAGR,GAAG,GAAGK,eAAe,CAACG,CAAC,GAAGR,GAAG,EAAE;QAChEK,eAAe,CAACG,CAAC,GAAGR,GAAG;MACzB;MACA,IAAI,CAACyB,MAAM,CAACpB,eAAe,CAACC,CAAC,EAAED,eAAe,CAACG,CAAC,CAAC;MAEjDH,eAAe,CAACC,CAAC,IAAIgB,IAAI;MACzBjB,eAAe,CAACG,CAAC,IAAIe,IAAI;MACzB,IAAId,OAAO,GAAGJ,eAAe,CAACC,CAAC,GAAGP,GAAG,GAAGM,eAAe,CAACC,CAAC,GAAGP,GAAG,EAAE;QAC/DM,eAAe,CAACC,CAAC,GAAGP,GAAG;MACzB;MACA,IAAIW,QAAQ,GAAGL,eAAe,CAACG,CAAC,GAAGR,GAAG,GAAGK,eAAe,CAACG,CAAC,GAAGR,GAAG,EAAE;QAChEK,eAAe,CAACG,CAAC,GAAGR,GAAG;MACzB;MACA,IAAI,CAAC0B,MAAM,CAACrB,eAAe,CAACC,CAAC,EAAED,eAAe,CAACG,CAAC,CAAC;IACnD;EACF;EAEAmB,iBAAiBA,CAACC,GAAW,EAAEC,GAAW,EAAEC,IAAY,EAAEC,IAAY,EAAEhC,GAAW,EAAEC,GAAW,EAAEC,IAAI,GAAG,CAAC,EAAEC,GAAG,GAAG,CAAC,EAAEY,KAAK,GAAG,IAAI,EAAE;IACjI,MAAM;MAAEX;IAAO,CAAC,GAAG,IAAI,CAACC,WAAW;IACnC,MAAM4B,KAAK,GAAG7B,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;IACvC,MAAM0B,KAAK,GAAG9B,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;IAEvC,MAAMI,UAAU,GAAGG,KAAK,GAAGF,IAAI,CAACC,GAAG,CAACZ,IAAI,GAAG,IAAI,CAACJ,KAAK,CAACiB,KAAK,EAAEb,IAAI,GAAG,CAAC,CAAC,GAAGA,IAAI;IAC7E,MAAMc,SAAS,GAAGD,KAAK,GAAGF,IAAI,CAACC,GAAG,CAACX,GAAG,GAAG,IAAI,CAACL,KAAK,CAACiB,KAAK,EAAEZ,GAAG,GAAG,CAAC,CAAC,GAAGA,GAAG;IAEzE,MAAMgC,GAAG,GAAGxC,WAAW,CAACsC,KAAK,EAAEC,KAAK,EAAEL,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEhC,GAAG,EAAEC,GAAG,CAAC;IACrE,MAAMmC,UAAU,GAAGD,GAAG,IAAIvB,UAAU,GAAGI,SAAS,CAAC;IACjD,MAAMqB,QAAQ,GAAGF,GAAG,GAAGC,UAAU;IACjC,IAAIE,UAAU,GAAG,CAAC;IAElB,IAAIC,EAAE,GAAG,CAAC;IACV,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,EAAE,GAAG,CAAC;IACV,IAAIC,EAAE,GAAG,CAAC;IAEV,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,IAAIT,GAAG,EAAES,CAAC,IAAI,CAAC,EAAE;MACvCC,CAAC,GAAGD,CAAC,GAAGT,GAAG;MAEXI,EAAE,GAAI,CAAC,GAAGM,CAAE;MACZL,GAAG,GAAGD,EAAE,GAAGA,EAAE;MACbE,GAAG,GAAGD,GAAG,GAAGD,EAAE;MAEdG,EAAE,GAAGG,CAAC,GAAGA,CAAC;MACVF,EAAE,GAAGD,EAAE,GAAGG,CAAC;MAEX,MAAMC,EAAE,GAAIL,GAAG,GAAGR,KAAK,GAAK,CAAC,GAAGO,GAAG,GAAGK,CAAC,GAAGhB,GAAI,GAAI,CAAC,GAAGU,EAAE,GAAGG,EAAE,GAAGX,IAAK,GAAIY,EAAE,GAAG3C,GAAI;MAClF,MAAM+C,EAAE,GAAIN,GAAG,GAAGP,KAAK,GAAK,CAAC,GAAGM,GAAG,GAAGK,CAAC,GAAGf,GAAI,GAAI,CAAC,GAAGS,EAAE,GAAGG,EAAE,GAAGV,IAAK,GAAIW,EAAE,GAAG1C,GAAI;MAElF,IAAI2C,CAAC,IAAIN,UAAU,GAAGD,QAAQ,GAAGzB,UAAU,EAAE;QAC3C,IAAI,CAACc,MAAM,CAACoB,EAAE,EAAEC,EAAE,CAAC;MACrB,CAAC,MAAM,IAAIH,CAAC,GAAG,CAACN,UAAU,GAAG,CAAC,IAAID,QAAQ,EAAE;QAC1C,IAAI,CAACV,MAAM,CAACmB,EAAE,EAAEC,EAAE,CAAC;MACrB,CAAC,MAAM;QACL,IAAI,CAACpB,MAAM,CAACmB,EAAE,EAAEC,EAAE,CAAC;QACnBT,UAAU,IAAI,CAAC;MACjB;IACF;EACF;EAEAU,QAAQA,CAAChD,GAAW,EAAEC,GAAW,EAAEgD,WAAwB,EAAEC,IAAI,GAAG1D,aAAa,CAAC2D,QAAQ,EAAE;IAC1F,IAAIF,WAAW,KAAK1D,WAAW,CAAC6D,MAAM,EAAE;MACtC,IAAI,CAACrD,UAAU,CAACC,GAAG,EAAEC,GAAG,CAAC;IAC3B,CAAC,MAAM;MACL,QAAQiD,IAAI;QACV,KAAK1D,aAAa,CAAC2D,QAAQ;UACzB,IAAI,CAACzB,MAAM,CAAC1B,GAAG,EAAEC,GAAG,CAAC;UACrB;QACF,KAAKT,aAAa,CAAC6D,IAAI;UAAE;YACvB,MAAM;cAAEjD;YAAO,CAAC,GAAG,IAAI,CAACC,WAAW;YACnC,MAAMC,eAAe,GAAG;cACtBC,CAAC,EAAEH,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;cAC5BC,CAAC,EAAEL,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC;YAC7B,CAAC;YAED,MAAM8C,CAAC,GAAGzC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAChB,KAAK,CAACiB,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YAC7C,MAAMwC,EAAE,GAAG1C,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAChB,KAAK,CAACiB,KAAK,EAAE,CAAC,CAAC;YAC5C,MAAMyC,OAAO,GAAGvD,GAAG,GAAGK,eAAe,CAACG,CAAC;YACvC,MAAMgD,OAAO,GAAGzD,GAAG,GAAGM,eAAe,CAACC,CAAC;YACvC,MAAMU,MAAM,GAAGJ,IAAI,CAACK,KAAK,CAACsC,OAAO,EAAEC,OAAO,CAAC;YAC3C,MAAMC,IAAI,GAAG7C,IAAI,CAACS,GAAG,CAACL,MAAM,CAAC,GAAGsC,EAAE;YAClC,MAAMI,IAAI,GAAG9C,IAAI,CAACO,GAAG,CAACH,MAAM,CAAC,GAAGsC,EAAE;YAClC,MAAMK,KAAK,GAAGF,IAAI,GAAG,CAAC;YACtB,MAAMG,KAAK,GAAGF,IAAI,GAAG,CAAC;YACtB,MAAMG,OAAO,GAAGjD,IAAI,CAACS,GAAG,CAACL,MAAM,GAAGJ,IAAI,CAACkD,EAAE,GAAG,CAAC,CAAC,GAAGT,CAAC;YAClD,MAAMU,OAAO,GAAGnD,IAAI,CAACO,GAAG,CAACH,MAAM,GAAGJ,IAAI,CAACkD,EAAE,GAAG,CAAC,CAAC,GAAGT,CAAC;YAClD,MAAMW,QAAQ,GAAGpD,IAAI,CAACS,GAAG,CAACT,IAAI,CAACkD,EAAE,GAAG,CAAC,GAAG9C,MAAM,CAAC,GAAGqC,CAAC;YACnD,MAAMY,QAAQ,GAAGrD,IAAI,CAACO,GAAG,CAACP,IAAI,CAACkD,EAAE,GAAG,CAAC,GAAG9C,MAAM,CAAC,GAAGqC,CAAC;YACnD,MAAMa,YAAY,GAAGtD,IAAI,CAACuD,IAAI,CAACX,OAAO,IAAI,CAAC,GAAGD,OAAO,IAAI,CAAC,CAAC,IAAID,EAAE,GAAG,CAAC,CAAC;YACtE,MAAMc,KAAK,GAAGxD,IAAI,CAACyD,KAAK,CAACH,YAAY,CAAC;YAEtC,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIyB,KAAK,EAAEzB,CAAC,IAAI,CAAC,EAAE;cAClC,MAAM2B,GAAG,GAAGb,IAAI,GAAGpD,eAAe,CAACG,CAAC;cACpC,MAAM+D,GAAG,GAAGb,IAAI,GAAGrD,eAAe,CAACC,CAAC;cACpC,MAAMkE,GAAG,GAAGb,KAAK,GAAGtD,eAAe,CAACG,CAAC;cACrC,MAAMiE,GAAG,GAAGb,KAAK,GAAGvD,eAAe,CAACC,CAAC;cACrC,MAAMoE,IAAI,GAAGb,OAAO,GAAGxD,eAAe,CAACG,CAAC;cACxC,MAAMmE,IAAI,GAAGZ,OAAO,GAAG1D,eAAe,CAACC,CAAC;cACxC,MAAMyB,IAAI,GAAGiC,QAAQ,GAAGM,GAAG;cAC3B,MAAMxC,IAAI,GAAG,CAACmC,QAAQ,GAAGM,GAAG;cAC5B,MAAMK,IAAI,GAAG,CAACZ,QAAQ,GAAGM,GAAG;cAC5B,MAAMO,IAAI,GAAGZ,QAAQ,GAAGM,GAAG;cAC3B,MAAMO,IAAI,GAAG,CAACjB,OAAO,GAAGW,GAAG;cAC3B,MAAMO,IAAI,GAAG,CAAChB,OAAO,GAAGU,GAAG;cAE3B,IAAI9B,CAAC,KAAKyB,KAAK,EAAE;gBACf,IAAIF,YAAY,GAAGE,KAAK,IAAI,GAAG,EAAE;kBAC/B,IAAI,CAACY,aAAa,CAACL,IAAI,EAAED,IAAI,EAAE5C,IAAI,EAAEC,IAAI,EAAEhC,GAAG,EAAEC,GAAG,CAAC;gBACtD,CAAC,MAAM;kBACL,IAAI,CAACgF,aAAa,CAACL,IAAI,EAAED,IAAI,EAAE5C,IAAI,EAAEC,IAAI,EAAEwC,GAAG,EAAED,GAAG,CAAC;kBACpD,IAAI,CAACU,aAAa,CAACH,IAAI,EAAED,IAAI,EAAEG,IAAI,EAAED,IAAI,EAAE/E,GAAG,EAAEC,GAAG,CAAC;gBACtD;cACF,CAAC,MAAM;gBACL,IAAI,CAACgF,aAAa,CAACL,IAAI,EAAED,IAAI,EAAE5C,IAAI,EAAEC,IAAI,EAAEwC,GAAG,EAAED,GAAG,CAAC;gBACpD,IAAI,CAACU,aAAa,CAACH,IAAI,EAAED,IAAI,EAAEG,IAAI,EAAED,IAAI,EAAEL,GAAG,EAAED,GAAG,CAAC;gBACpDnE,eAAe,CAACC,CAAC,GAAGmE,GAAG;gBACvBpE,eAAe,CAACG,CAAC,GAAGgE,GAAG;cACzB;YACF;YAEA;UACF;QACA,KAAKjF,aAAa,CAAC0F,MAAM;UAAE;YACzB,MAAM;cAAE9E;YAAO,CAAC,GAAG,IAAI,CAACC,WAAW;YACnC,MAAMC,eAAe,GAAG;cACtBC,CAAC,EAAEH,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;cAC5BC,CAAC,EAAEL,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC;YAC7B,CAAC;YAED,MAAM8C,CAAC,GAAGzC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAChB,KAAK,CAACiB,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YAC7C,MAAMwC,EAAE,GAAG1C,IAAI,CAACuD,IAAI,CAAC,CAAC,CAAC,GAAGd,CAAC,CAAC,CAAC;YAC7B,MAAME,OAAO,GAAGvD,GAAG,GAAGK,eAAe,CAACG,CAAC;YACvC,MAAMgD,OAAO,GAAGzD,GAAG,GAAGM,eAAe,CAACC,CAAC;YACvC,MAAMU,MAAM,GAAGJ,IAAI,CAACK,KAAK,CAACsC,OAAO,EAAEC,OAAO,CAAC;YAC3C,MAAMC,IAAI,GAAG7C,IAAI,CAACS,GAAG,CAACL,MAAM,CAAC,GAAGsC,EAAE;YAClC,MAAMI,IAAI,GAAG9C,IAAI,CAACO,GAAG,CAACH,MAAM,CAAC,GAAGsC,EAAE;YAClC,MAAMK,KAAK,GAAGF,IAAI,GAAG,CAAC;YACtB,MAAMG,KAAK,GAAGF,IAAI,GAAG,CAAC;YACtB,MAAMG,OAAO,GAAGjD,IAAI,CAACS,GAAG,CAACL,MAAM,GAAGJ,IAAI,CAACkD,EAAE,GAAG,CAAC,CAAC,GAAGT,CAAC;YAClD,MAAMU,OAAO,GAAGnD,IAAI,CAACO,GAAG,CAACH,MAAM,GAAGJ,IAAI,CAACkD,EAAE,GAAG,CAAC,CAAC,GAAGT,CAAC;YAClD,MAAMW,QAAQ,GAAGpD,IAAI,CAACS,GAAG,CAACT,IAAI,CAACkD,EAAE,GAAG,CAAC,GAAG9C,MAAM,CAAC,GAAGqC,CAAC;YACnD,MAAMY,QAAQ,GAAGrD,IAAI,CAACO,GAAG,CAACP,IAAI,CAACkD,EAAE,GAAG,CAAC,GAAG9C,MAAM,CAAC,GAAGqC,CAAC;YACnD,MAAMa,YAAY,GAAGtD,IAAI,CAACuD,IAAI,CAACX,OAAO,IAAI,CAAC,GAAGD,OAAO,IAAI,CAAC,CAAC,IAAID,EAAE,GAAG,CAAC,CAAC;YACtE,MAAMc,KAAK,GAAGxD,IAAI,CAACyD,KAAK,CAACH,YAAY,CAAC;YACtC,MAAMgB,eAAe,GAAGtE,IAAI,CAACyD,KAAK,CAAC,CAACH,YAAY,GAAGE,KAAK,IAAI,IAAI,CAAC;YAEjE,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIyB,KAAK,EAAEzB,CAAC,IAAI,CAAC,EAAE;cAClC,MAAM2B,GAAG,GAAGT,OAAO,GAAGxD,eAAe,CAACG,CAAC;cACvC,MAAM+D,GAAG,GAAGR,OAAO,GAAG1D,eAAe,CAACC,CAAC;cACvC,MAAMkE,GAAG,GAAGf,IAAI,GAAGpD,eAAe,CAACG,CAAC;cACpC,MAAMiE,GAAG,GAAGf,IAAI,GAAGrD,eAAe,CAACC,CAAC;cACpC,MAAM6E,GAAG,GAAG,CAACnB,QAAQ,GAAGQ,GAAG;cAC3B,MAAMY,GAAG,GAAGnB,QAAQ,GAAGQ,GAAG;cAC1B,MAAMY,GAAG,GAAG1B,KAAK,GAAGtD,eAAe,CAACG,CAAC;cACrC,MAAM8E,GAAG,GAAG1B,KAAK,GAAGvD,eAAe,CAACC,CAAC;cACrC,MAAMiF,UAAU,GAAG,CACjB,CAAChB,GAAG,EAAED,GAAG,CAAC,EACV,CAACG,GAAG,EAAED,GAAG,CAAC,EACV,CAACY,GAAG,EAAED,GAAG,CAAC,EACV,CAACG,GAAG,EAAED,GAAG,CAAC,CACX;cACD,MAAMG,WAAW,GAAG7C,CAAC,KAAKyB,KAAK,GAAGc,eAAe,GAAG,CAAC;cACrD,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4C,WAAW,EAAE5C,CAAC,IAAI,CAAC,EAAE;gBACvCvC,eAAe,CAACC,CAAC,GAAGiF,UAAU,CAAC3C,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpCvC,eAAe,CAACG,CAAC,GAAG+E,UAAU,CAAC3C,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC,IAAI,CAACnB,MAAM,CAACpB,eAAe,CAACC,CAAC,EAAED,eAAe,CAACG,CAAC,CAAC;cACnD;YACF;YACAH,eAAe,CAACC,CAAC,GAAGP,GAAG;YACvBM,eAAe,CAACG,CAAC,GAAGR,GAAG;YACvB,IAAI,CAACyB,MAAM,CAACpB,eAAe,CAACC,CAAC,EAAED,eAAe,CAACG,CAAC,CAAC;YAEjD;UACF;QACA;UACE,IAAI,CAACiB,MAAM,CAAC1B,GAAG,EAAEC,GAAG,CAAC;MACzB;IACF;EACF;EAEAP,UAAUA,CAACa,CAAS,EAAEE,CAAS,EAAEiF,IAAY,EAAExC,IAAI,GAAGzD,eAAe,CAACkG,GAAG,EAAE;IACzEjG,UAAU,CAAC,IAAI,EAAEa,CAAC,EAAEE,CAAC,EAAEiF,IAAI,EAAExC,IAAI,CAAC;EACpC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module"}