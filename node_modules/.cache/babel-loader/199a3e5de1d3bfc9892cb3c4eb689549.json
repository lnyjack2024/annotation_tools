{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport CameraData from './CameraData';\n/**\n * instance item\n * @class\n */\nexport default class InstanceItem {\n  /**\n   * instance item name\n   * @getter\n   */\n  get name() {\n    return this.categoryItemRef.name;\n  }\n\n  /**\n   * instance item label\n   * @getter\n   */\n  get label() {\n    if (this.instance.isSingle) {\n      return this.instance.label;\n    }\n    return `${this.instance.label}-${this.itemLabel}`;\n  }\n\n  /**\n   * instance item label only\n   * @getter\n   */\n  get itemLabel() {\n    let label = this.categoryItemRef.displayName;\n    if (this.instance.isSingle) {\n      label = this.instance.categoryRef.displayName;\n    }\n    if (this.isSingle) {\n      return label;\n    }\n    return `${label}${this.number}`;\n  }\n\n  /**\n   * instance item frame status (merged status)\n   * @getter\n   */\n  get frameStatus() {\n    // simple merge\n    return Object.values(this.cameras).map(c => c.frameStatus).reduce((acc, curr) => ({\n      ...acc,\n      ...curr\n    }), {});\n  }\n\n  /**\n   * instance item existed camera names\n   * @getter\n   */\n  get existedCameras() {\n    return Object.keys(this.cameras).filter(cameraName => !this.cameras[cameraName].isEmpty);\n  }\n\n  /**\n   * is instance item empty\n   * @getter\n   */\n  get isEmpty() {\n    return Object.values(this.cameras).every(camera => camera.isEmpty);\n  }\n\n  /**\n   * is instance item only contains one shape\n   * @getter\n   */\n  get isSingle() {\n    return this.categoryItemRef.count === 1;\n  }\n  constructor({\n    id,\n    instance,\n    categoryItemRef,\n    number,\n    cameras = []\n  }) {\n    /**\n     * instance item id\n     * @member\n     */\n    this.id = void 0;\n    /**\n     * instance which belongs to\n     * @member\n     */\n    this.instance = void 0;\n    /**\n     * category item reference\n     * @member\n     */\n    this.categoryItemRef = void 0;\n    /**\n     * instance item number\n     * @member\n     */\n    this.number = void 0;\n    /**\n     * instance item camera data\n     * @member\n     */\n    this.cameras = {};\n    /**\n     * is instance item selected\n     * @member\n     */\n    this.selected = false;\n    makeAutoObservable(this, {\n      id: false,\n      instance: false,\n      categoryItemRef: false,\n      isEmpty: false,\n      isSingle: false\n    }, {\n      autoBind: true\n    });\n    this.id = id || uuidv4();\n    this.instance = instance;\n    this.categoryItemRef = categoryItemRef;\n    this.number = number;\n    cameras.forEach(camera => this.createCameraFromData(camera));\n  }\n\n  /**\n   * create camera from structured camera data\n   * @param cameraData\n   */\n  createCameraFromData(cameraData) {\n    const camera = new CameraData({\n      camera: cameraData.camera,\n      frames: cameraData.frames,\n      instanceItem: this,\n      getNextShapeOrder: this.instance.getNextShapeOrder\n    });\n    this.cameras[camera.camera] = camera;\n  }\n\n  /**\n   * set selected\n   * @param selected\n   */\n  setSelected(selected) {\n    this.selected = selected;\n  }\n\n  /**\n   * get camera\n   * @param camera\n   */\n  getCamera(camera) {\n    if (!this.cameras[camera]) {\n      // create camera if not exist\n      this.createCameraFromData({\n        camera,\n        frames: []\n      });\n    }\n    return this.cameras[camera];\n  }\n\n  /**\n   * set attributes in frame\n   * @param camera\n   * @param frames\n   * @param attributes\n   */\n  setAttributes(camera, frames, attributes) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.setAttributes(frames, attributes);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * set attributes by frame\n   * @param camera\n   * @param frameAttributesMap\n   */\n  setAttributesByFrame(camera, frameAttributesMap) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.setAttributesByFrame(frameAttributesMap);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * add shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   */\n  addShape(camera, frameIndex, interpolation, shapeType, shapeData, order) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.addShape(frameIndex, interpolation, shapeType, shapeData, order);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * update shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(camera, frameIndex, interpolation, shapeType, shapeData, order, attributes) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.updateShape(frameIndex, interpolation, shapeType, shapeData, order, attributes);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * predict shape\n   * @param camera\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(camera, frameIndex, imageBounds, useNearest) {\n    const cameraData = this.getCamera(camera);\n    return cameraData.predictShape(frameIndex, imageBounds, useNearest);\n  }\n\n  /**\n   * remove from frames\n   * @param camera\n   * @param frames\n   */\n  remove(camera, frames) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.remove(frames);\n    if (cameraData.isEmpty) {\n      // delete camera\n      delete this.cameras[camera];\n    }\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * update frames by frame data\n   * @param camera\n   * @param frames\n   */\n  updateFramesFromData(camera, frames) {\n    const cameraData = this.getCamera(camera);\n    const {\n      prevState,\n      currState\n    } = cameraData.updateFramesFromData(frames);\n    return this.formatChangedState(prevState ? [prevState] : [], currState ? [currState] : []);\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON() {\n    return {\n      ...this.getBasicInfo(),\n      cameras: Object.values(this.cameras).filter(camera => !camera.isEmpty).map(camera => camera.toJSON())\n    };\n  }\n\n  /**\n   * return basic info data\n   */\n  getBasicInfo() {\n    return {\n      id: this.id,\n      name: this.name,\n      displayName: this.categoryItemRef.displayName,\n      displayColor: this.categoryItemRef.displayColor,\n      number: this.number\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState, currState) {\n    const basicInfo = this.getBasicInfo();\n    return {\n      ...(prevState.length > 0 && {\n        prevState: {\n          ...basicInfo,\n          cameras: [...prevState]\n        }\n      }),\n      ...(currState.length > 0 && {\n        currState: {\n          ...basicInfo,\n          cameras: [...currState]\n        }\n      })\n    };\n  }\n}","map":{"version":3,"names":["makeAutoObservable","v4","uuidv4","CameraData","InstanceItem","name","categoryItemRef","label","instance","isSingle","itemLabel","displayName","categoryRef","number","frameStatus","Object","values","cameras","map","c","reduce","acc","curr","existedCameras","keys","filter","cameraName","isEmpty","every","camera","count","constructor","id","selected","autoBind","forEach","createCameraFromData","cameraData","frames","instanceItem","getNextShapeOrder","setSelected","getCamera","setAttributes","attributes","prevState","currState","formatChangedState","setAttributesByFrame","frameAttributesMap","addShape","frameIndex","interpolation","shapeType","shapeData","order","updateShape","predictShape","imageBounds","useNearest","remove","updateFramesFromData","toJSON","getBasicInfo","displayColor","basicInfo","length"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/model/InstanceItem.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport CameraData from './CameraData';\nimport Instance from './Instance';\nimport { CameraData as ICameraData, InstanceItem as IInstanceItem, FrameData as IFrameData, CategoryItem } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\n\ninterface InstanceItemOptions {\n  id?: string;\n  instance: Instance;\n  categoryItemRef: CategoryItem;\n  number: number;\n  cameras?: ICameraData[];\n}\n\ninterface ChangedState {\n  prevState?: IInstanceItem;\n  currState?: IInstanceItem;\n}\n\n/**\n * instance item\n * @class\n */\nexport default class InstanceItem {\n  /**\n   * instance item id\n   * @member\n   */\n  id: string;\n\n  /**\n   * instance which belongs to\n   * @member\n   */\n  instance: Instance;\n\n  /**\n   * category item reference\n   * @member\n   */\n  categoryItemRef: CategoryItem;\n\n  /**\n   * instance item number\n   * @member\n   */\n  number: number;\n\n  /**\n   * instance item camera data\n   * @member\n   */\n  cameras: { [camera: string]: CameraData } = {};\n\n  /**\n   * is instance item selected\n   * @member\n   */\n  selected = false;\n\n  /**\n   * instance item name\n   * @getter\n   */\n  get name() {\n    return this.categoryItemRef.name;\n  }\n\n  /**\n   * instance item label\n   * @getter\n   */\n  get label() {\n    if (this.instance.isSingle) {\n      return this.instance.label;\n    }\n    return `${this.instance.label}-${this.itemLabel}`;\n  }\n\n  /**\n   * instance item label only\n   * @getter\n   */\n  get itemLabel() {\n    let label = this.categoryItemRef.displayName;\n    if (this.instance.isSingle) {\n      label = this.instance.categoryRef.displayName;\n    }\n    if (this.isSingle) {\n      return label;\n    }\n    return `${label}${this.number}`;\n  }\n\n  /**\n   * instance item frame status (merged status)\n   * @getter\n   */\n  get frameStatus() {\n    // simple merge\n    return Object.values(this.cameras)\n      .map((c) => c.frameStatus)\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n  }\n\n  /**\n   * instance item existed camera names\n   * @getter\n   */\n  get existedCameras() {\n    return Object.keys(this.cameras).filter((cameraName) => !this.cameras[cameraName].isEmpty);\n  }\n\n  /**\n   * is instance item empty\n   * @getter\n   */\n  get isEmpty() {\n    return Object.values(this.cameras).every((camera) => camera.isEmpty);\n  }\n\n  /**\n   * is instance item only contains one shape\n   * @getter\n   */\n  get isSingle() {\n    return this.categoryItemRef.count === 1;\n  }\n\n  constructor({ id, instance, categoryItemRef, number, cameras = [] }: InstanceItemOptions) {\n    makeAutoObservable(this, {\n      id: false,\n      instance: false,\n      categoryItemRef: false,\n      isEmpty: false,\n      isSingle: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.id = id || uuidv4();\n    this.instance = instance;\n    this.categoryItemRef = categoryItemRef;\n    this.number = number;\n    cameras.forEach((camera) => this.createCameraFromData(camera));\n  }\n\n  /**\n   * create camera from structured camera data\n   * @param cameraData\n   */\n  createCameraFromData(cameraData: ICameraData) {\n    const camera = new CameraData({\n      camera: cameraData.camera,\n      frames: cameraData.frames,\n      instanceItem: this,\n      getNextShapeOrder: this.instance.getNextShapeOrder,\n    });\n    this.cameras[camera.camera] = camera;\n  }\n\n  /**\n   * set selected\n   * @param selected\n   */\n  setSelected(selected: boolean) {\n    this.selected = selected;\n  }\n\n  /**\n   * get camera\n   * @param camera\n   */\n  getCamera(camera: string) {\n    if (!this.cameras[camera]) {\n      // create camera if not exist\n      this.createCameraFromData({ camera, frames: [] });\n    }\n    return this.cameras[camera];\n  }\n\n  /**\n   * set attributes in frame\n   * @param camera\n   * @param frames\n   * @param attributes\n   */\n  setAttributes(camera: string, frames: number[], attributes: { attributes?: any }) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.setAttributes(frames, attributes);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * set attributes by frame\n   * @param camera\n   * @param frameAttributesMap\n   */\n  setAttributesByFrame(camera: string, frameAttributesMap: { [frameIndex: number]: { attributes?: any } }) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.setAttributesByFrame(frameAttributesMap);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * add shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   */\n  addShape(camera: string, frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number): ChangedState {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.addShape(frameIndex, interpolation, shapeType, shapeData, order);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * update shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(camera: string, frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, attributes?: any) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.updateShape(frameIndex, interpolation, shapeType, shapeData, order, attributes);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * predict shape\n   * @param camera\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(camera: string, frameIndex: number, imageBounds?: { top: number; right: number; bottom: number; left: number }, useNearest?: boolean) {\n    const cameraData = this.getCamera(camera);\n    return cameraData.predictShape(frameIndex, imageBounds, useNearest);\n  }\n\n  /**\n   * remove from frames\n   * @param camera\n   * @param frames\n   */\n  remove(camera: string, frames: number[]) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.remove(frames);\n    if (cameraData.isEmpty) {\n      // delete camera\n      delete this.cameras[camera];\n    }\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * update frames by frame data\n   * @param camera\n   * @param frames\n   */\n  updateFramesFromData(camera: string, frames: IFrameData[]) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.updateFramesFromData(frames);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON(): IInstanceItem {\n    return {\n      ...this.getBasicInfo(),\n      cameras: Object.values(this.cameras)\n        .filter((camera) => !camera.isEmpty)\n        .map((camera) => camera.toJSON()),\n    };\n  }\n\n  /**\n   * return basic info data\n   */\n  getBasicInfo() {\n    return {\n      id: this.id,\n      name: this.name,\n      displayName: this.categoryItemRef.displayName,\n      displayColor: this.categoryItemRef.displayColor,\n      number: this.number,\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState: ICameraData[], currState: ICameraData[]): ChangedState {\n    const basicInfo = this.getBasicInfo();\n    return {\n      ...prevState.length > 0 && {\n        prevState: { ...basicInfo, cameras: [...prevState] },\n      },\n      ...currState.length > 0 && {\n        currState: { ...basicInfo, cameras: [...currState] },\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}