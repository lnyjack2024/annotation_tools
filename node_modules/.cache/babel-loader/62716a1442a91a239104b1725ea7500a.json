{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _constants = require(\"./constants\");\nvar _errorCodes = require(\"./errorCodes\");\nvar _createDestructor2 = _interopRequireDefault(require(\"./createDestructor\"));\nvar _getOriginFromSrc = _interopRequireDefault(require(\"./getOriginFromSrc\"));\nvar _createLogger = _interopRequireDefault(require(\"./createLogger\"));\nvar _connectCallReceiver = _interopRequireDefault(require(\"./connectCallReceiver\"));\nvar _connectCallSender = _interopRequireDefault(require(\"./connectCallSender\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * @typedef {Object} Child\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n * @property {Function} destroy A method that, when called, will disconnect any\n * messaging channels. You may call this even before a connection has been established.\n */\n\n/**\n * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with\n * the iframe.\n * @param {Object} options\n * @param {HTMLIframeElement} options.iframe The iframe to connect to.\n * @param {Object} [options.methods={}] Methods that may be called by the iframe.\n * @param {String} [options.childOrigin] The child origin to use to secure communication. If\n * not provided, the child origin will be derived from the iframe's src or srcdoc value.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the child to respond before rejecting the connection promise.\n * @return {Child}\n */\n\nvar _default = _ref => {\n  let iframe = _ref.iframe,\n    _ref$methods = _ref.methods,\n    methods = _ref$methods === void 0 ? {} : _ref$methods,\n    childOrigin = _ref.childOrigin,\n    timeout = _ref.timeout,\n    debug = _ref.debug;\n  const log = (0, _createLogger.default)(debug);\n  const parent = window;\n  const _createDestructor = (0, _createDestructor2.default)(),\n    destroy = _createDestructor.destroy,\n    onDestroy = _createDestructor.onDestroy;\n  if (!childOrigin) {\n    if (!iframe.src && !iframe.srcdoc) {\n      const error = new Error('Iframe must have src or srcdoc property defined.');\n      error.code = _errorCodes.ERR_NO_IFRAME_SRC;\n      throw error;\n    }\n    childOrigin = (0, _getOriginFromSrc.default)(iframe.src);\n  } // If event.origin is \"null\", the remote protocol is\n  // file:, data:, and we must post messages with \"*\" as targetOrigin\n  // when sending and allow\n  // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions\n\n  const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n  const promise = new Promise((resolveConnectionPromise, reject) => {\n    let connectionTimeoutId;\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(() => {\n        const error = new Error(`Connection to child timed out after ${timeout}ms`);\n        error.code = _errorCodes.ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    } // We resolve the promise with the call sender. If the child reconnects (for example, after\n    // refreshing or navigating to another page that uses Penpal, we'll update the call sender\n    // with methods that match the latest provided by the child.\n\n    const callSender = {};\n    let receiverMethodNames;\n    let destroyCallReceiver;\n    const handleMessage = event => {\n      const child = iframe.contentWindow;\n      if (event.source !== child || event.data.penpal !== _constants.HANDSHAKE) {\n        return;\n      }\n      if (event.origin !== childOrigin) {\n        log(`Parent received handshake from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n        return;\n      }\n      log('Parent: Received handshake, sending reply');\n      event.source.postMessage({\n        penpal: _constants.HANDSHAKE_REPLY,\n        methodNames: Object.keys(methods)\n      }, originForSending);\n      const info = {\n        localName: 'Parent',\n        local: parent,\n        remote: child,\n        originForSending: originForSending,\n        originForReceiving: childOrigin\n      }; // If the child reconnected, we need to destroy the previous call receiver before setting\n      // up a new one.\n\n      if (destroyCallReceiver) {\n        destroyCallReceiver();\n      }\n      destroyCallReceiver = (0, _connectCallReceiver.default)(info, methods, log);\n      onDestroy(destroyCallReceiver); // If the child reconnected, we need to remove the methods from the previous call receiver\n      // off the sender.\n\n      if (receiverMethodNames) {\n        receiverMethodNames.forEach(receiverMethodName => {\n          delete callSender[receiverMethodName];\n        });\n      }\n      receiverMethodNames = event.data.methodNames;\n      const destroyCallSender = (0, _connectCallSender.default)(callSender, info, receiverMethodNames, destroy, log);\n      onDestroy(destroyCallSender);\n      clearTimeout(connectionTimeoutId);\n      resolveConnectionPromise(callSender);\n    };\n    parent.addEventListener(_constants.MESSAGE, handleMessage);\n    log('Parent: Awaiting handshake'); // This is to prevent memory leaks when the iframe is removed\n    // from the document and the consumer hasn't called destroy().\n    // Without this, event listeners attached to the window would\n    // stick around and since the event handlers have a reference\n    // to the iframe in their closures, the iframe would stick around\n    // too.\n\n    var checkIframeInDocIntervalId = setInterval(() => {\n      if (!document.contains(iframe)) {\n        clearInterval(checkIframeInDocIntervalId);\n        destroy();\n      }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n      parent.removeEventListener(_constants.MESSAGE, handleMessage);\n      clearInterval(checkIframeInDocIntervalId);\n      const error = new Error('Connection destroyed');\n      error.code = _errorCodes.ERR_CONNECTION_DESTROYED;\n      reject(error);\n    });\n  });\n  return {\n    promise,\n    destroy\n  };\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_constants","require","_errorCodes","_createDestructor2","_interopRequireDefault","_getOriginFromSrc","_createLogger","_connectCallReceiver","_connectCallSender","obj","__esModule","CHECK_IFRAME_IN_DOC_INTERVAL","_default","_ref","iframe","_ref$methods","methods","childOrigin","timeout","debug","log","parent","window","_createDestructor","destroy","onDestroy","src","srcdoc","error","Error","code","ERR_NO_IFRAME_SRC","originForSending","promise","Promise","resolveConnectionPromise","reject","connectionTimeoutId","undefined","setTimeout","ERR_CONNECTION_TIMEOUT","callSender","receiverMethodNames","destroyCallReceiver","handleMessage","event","child","contentWindow","source","data","penpal","HANDSHAKE","origin","postMessage","HANDSHAKE_REPLY","methodNames","keys","info","localName","local","remote","originForReceiving","forEach","receiverMethodName","destroyCallSender","clearTimeout","addEventListener","MESSAGE","checkIframeInDocIntervalId","setInterval","document","contains","clearInterval","removeEventListener","ERR_CONNECTION_DESTROYED","module"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/penpal/lib/connectToChild.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorCodes = require(\"./errorCodes\");\n\nvar _createDestructor2 = _interopRequireDefault(require(\"./createDestructor\"));\n\nvar _getOriginFromSrc = _interopRequireDefault(require(\"./getOriginFromSrc\"));\n\nvar _createLogger = _interopRequireDefault(require(\"./createLogger\"));\n\nvar _connectCallReceiver = _interopRequireDefault(require(\"./connectCallReceiver\"));\n\nvar _connectCallSender = _interopRequireDefault(require(\"./connectCallSender\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * @typedef {Object} Child\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n * @property {Function} destroy A method that, when called, will disconnect any\n * messaging channels. You may call this even before a connection has been established.\n */\n\n/**\n * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with\n * the iframe.\n * @param {Object} options\n * @param {HTMLIframeElement} options.iframe The iframe to connect to.\n * @param {Object} [options.methods={}] Methods that may be called by the iframe.\n * @param {String} [options.childOrigin] The child origin to use to secure communication. If\n * not provided, the child origin will be derived from the iframe's src or srcdoc value.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the child to respond before rejecting the connection promise.\n * @return {Child}\n */\n\nvar _default = (_ref) => {\n  let iframe = _ref.iframe,\n      _ref$methods = _ref.methods,\n      methods = _ref$methods === void 0 ? {} : _ref$methods,\n      childOrigin = _ref.childOrigin,\n      timeout = _ref.timeout,\n      debug = _ref.debug;\n  const log = (0, _createLogger.default)(debug);\n  const parent = window;\n\n  const _createDestructor = (0, _createDestructor2.default)(),\n        destroy = _createDestructor.destroy,\n        onDestroy = _createDestructor.onDestroy;\n\n  if (!childOrigin) {\n    if (!iframe.src && !iframe.srcdoc) {\n      const error = new Error('Iframe must have src or srcdoc property defined.');\n      error.code = _errorCodes.ERR_NO_IFRAME_SRC;\n      throw error;\n    }\n\n    childOrigin = (0, _getOriginFromSrc.default)(iframe.src);\n  } // If event.origin is \"null\", the remote protocol is\n  // file:, data:, and we must post messages with \"*\" as targetOrigin\n  // when sending and allow\n  // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions\n\n\n  const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n  const promise = new Promise((resolveConnectionPromise, reject) => {\n    let connectionTimeoutId;\n\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(() => {\n        const error = new Error(`Connection to child timed out after ${timeout}ms`);\n        error.code = _errorCodes.ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    } // We resolve the promise with the call sender. If the child reconnects (for example, after\n    // refreshing or navigating to another page that uses Penpal, we'll update the call sender\n    // with methods that match the latest provided by the child.\n\n\n    const callSender = {};\n    let receiverMethodNames;\n    let destroyCallReceiver;\n\n    const handleMessage = event => {\n      const child = iframe.contentWindow;\n\n      if (event.source !== child || event.data.penpal !== _constants.HANDSHAKE) {\n        return;\n      }\n\n      if (event.origin !== childOrigin) {\n        log(`Parent received handshake from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n        return;\n      }\n\n      log('Parent: Received handshake, sending reply');\n      event.source.postMessage({\n        penpal: _constants.HANDSHAKE_REPLY,\n        methodNames: Object.keys(methods)\n      }, originForSending);\n      const info = {\n        localName: 'Parent',\n        local: parent,\n        remote: child,\n        originForSending: originForSending,\n        originForReceiving: childOrigin\n      }; // If the child reconnected, we need to destroy the previous call receiver before setting\n      // up a new one.\n\n      if (destroyCallReceiver) {\n        destroyCallReceiver();\n      }\n\n      destroyCallReceiver = (0, _connectCallReceiver.default)(info, methods, log);\n      onDestroy(destroyCallReceiver); // If the child reconnected, we need to remove the methods from the previous call receiver\n      // off the sender.\n\n      if (receiverMethodNames) {\n        receiverMethodNames.forEach(receiverMethodName => {\n          delete callSender[receiverMethodName];\n        });\n      }\n\n      receiverMethodNames = event.data.methodNames;\n      const destroyCallSender = (0, _connectCallSender.default)(callSender, info, receiverMethodNames, destroy, log);\n      onDestroy(destroyCallSender);\n      clearTimeout(connectionTimeoutId);\n      resolveConnectionPromise(callSender);\n    };\n\n    parent.addEventListener(_constants.MESSAGE, handleMessage);\n    log('Parent: Awaiting handshake'); // This is to prevent memory leaks when the iframe is removed\n    // from the document and the consumer hasn't called destroy().\n    // Without this, event listeners attached to the window would\n    // stick around and since the event handlers have a reference\n    // to the iframe in their closures, the iframe would stick around\n    // too.\n\n    var checkIframeInDocIntervalId = setInterval(() => {\n      if (!document.contains(iframe)) {\n        clearInterval(checkIframeInDocIntervalId);\n        destroy();\n      }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n      parent.removeEventListener(_constants.MESSAGE, handleMessage);\n      clearInterval(checkIframeInDocIntervalId);\n      const error = new Error('Connection destroyed');\n      error.code = _errorCodes.ERR_CONNECTION_DESTROYED;\n      reject(error);\n    });\n  });\n  return {\n    promise,\n    destroy\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}