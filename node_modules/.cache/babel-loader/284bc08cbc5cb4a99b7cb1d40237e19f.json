{"ast":null,"code":"import { makeObservable, observable, action } from 'mobx';\nimport { message } from 'antd';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape } from '../utils';\nimport { ReviewMode } from '../types';\nimport { CAMERA_VIEW_LABELS } from '../constants';\nimport ShapeFactory from '../../common/shapes/ShapeFactory';\nimport { ShapeType } from '../../common/shapes/types';\nimport { EventAction, BorderStyle } from '../../common/shapes/Shape';\nimport Polygon from '../../common/shapes/Polygon';\nimport Line from '../../common/shapes/Line';\nimport Label from '../../common/shapes/label/Label';\n\n/**\n * store for shapes in current camera & current frame\n * @class\n */\nexport default class ShapeStore {\n  /**\n   * is drawing shape\n   * @getter\n   */\n  get isDrawing() {\n    return this.drawingShape !== null;\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * app\n     */\n    this.app = void 0;\n    /**\n     * current layer\n     */\n    this.currentLayer = void 0;\n    /**\n     * shapes in current frame\n     */\n    this.shapes = {};\n    /**\n     * currently drawing shape\n     */\n    this.drawingShape = null;\n    /**\n     * currently selected shapes\n     */\n    this.selectedShapes = [];\n    /**\n     * currently selected shape vertex index for polygon & line\n     */\n    this.selectedPointIndex = -1;\n    /**\n     * predicted shapes\n     */\n    this.predictedShapes = {};\n    /**\n     * hovered shape id\n     */\n    this.hoveredShapeId = '';\n    /**\n     * waiting merge polygon\n     */\n    this.pendingMergePolygon = '';\n    /**\n     * is deleting\n     */\n    this.deleting = false;\n    /**\n     * shape display config\n     */\n    this.config = {\n      fill: true,\n      alpha: 20,\n      showVertex: false,\n      showVertexOrder: false\n    };\n    /**\n     * default config from payload\n     */\n    this.defaultConfig = this.config;\n    /**\n     * clear shapes\n     */\n    this.clearShapes = () => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.destroy();\n      });\n      this.shapes = {};\n      this.drawingShape = null;\n      this.selectedShapes = [];\n      this.clearPredictedShapes();\n      this.selectedPointIndex = -1;\n    };\n    /**\n     * clear predicted shapes\n     */\n    this.clearPredictedShapes = () => {\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.destroy();\n      });\n      this.predictedShapes = {};\n    };\n    /**\n     * is predicted shape\n     * @param s\n     */\n    this.isPredictedShape = s => Object.values(this.predictedShapes).findIndex(({\n      shape\n    }) => shape === s) >= 0;\n    /**\n     * get shape by instance item\n     * @param instanceItem\n     */\n    this.getShapeByInstanceItem = (instanceItem, camera = this.rootStore.frame.currentCamera) => {\n      const shapeItem = Object.values(this.shapes).find(i => i.camera === camera && i.instanceItem === instanceItem);\n      if (shapeItem) {\n        return shapeItem.shape;\n      }\n      return undefined;\n    };\n    /**\n     * get shapes by instance items\n     * @param instanceItems\n     * @param camera\n     */\n    this.getShapesByInstanceItems = (instanceItems, camera = this.rootStore.frame.currentCamera) => {\n      const shapeItems = Object.values(this.shapes).filter(i => i.camera === camera && instanceItems.indexOf(i.instanceItem) >= 0);\n      return shapeItems.map(i => i.shape);\n    };\n    /**\n     * get shapes for one camera\n     * @param camera\n     */\n    this.getShapesForCamera = camera => Object.values(this.shapes).filter(s => s.camera === camera);\n    /**\n     * update shapes interactive\n     * @param interactive\n     * @param ignoreIds\n     */\n    this.updateShapesInteractive = (interactive, ignoreIds) => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (ignoreIds && ignoreIds.includes(shape.uid)) {\n          return;\n        }\n        shape.interactive = interactive;\n        if (interactive && this.selectedShapes.indexOf(shape) >= 0) {\n          shape.selected = true;\n        }\n      });\n    };\n    /**\n     * redraw shapes label\n     */\n    this.redrawShapesLabel = () => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.drawShapeLabel();\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.drawShapeLabel();\n      });\n    };\n    /**\n     * setup shapes for current frame\n     */\n    this.setupShapes = () => {\n      this.clearShapes();\n      const {\n        cameraViews,\n        currentFrame,\n        cameraNames,\n        getImageBoundsForCamera\n      } = this.rootStore.frame;\n      const allShapeOrders = {};\n      const noOrderShapes = {};\n      cameraNames.forEach(cameraName => {\n        allShapeOrders[cameraName] = new Set();\n        noOrderShapes[cameraName] = [];\n      });\n      const startOrder = 0;\n      Object.values(this.rootStore.instance.instances).forEach(instance => {\n        Object.values(instance.items).forEach(item => {\n          Object.values(item.cameras).forEach(({\n            camera\n          }) => {\n            const {\n              frames\n            } = item.cameras[camera];\n            const cameraView = cameraViews[camera];\n            if (frames[currentFrame] && cameraView && !cameraView.imageLoadError) {\n              const shape = this.createShape(cameraView.shapesLayer, getImageBoundsForCamera(camera), item.categoryItemRef.displayColor, instance.category, item.name, frames[currentFrame].shapeType, frames[currentFrame].shape, frames[currentFrame].order, item.label, camera);\n              if (shape.destroyed) {\n                // delete instance item\n                this.rootStore.instance.deleteInstanceItemByFrame(item, currentFrame, camera);\n                return;\n              }\n              if (this.rootStore.readonly) {\n                shape.editable = false;\n              }\n              this.addShapeListeners(shape);\n              this.shapes[shape.uid] = {\n                shape,\n                camera,\n                instanceItem: item\n              };\n              const {\n                order\n              } = frames[currentFrame];\n              if (typeof order === 'number' && order >= startOrder && !allShapeOrders[camera].has(order)) {\n                // update next shape order\n                shape.order = order;\n              } else {\n                // add to temp array\n                noOrderShapes[camera].push({\n                  frameData: frames[currentFrame],\n                  shape\n                });\n              }\n            }\n          });\n        });\n      });\n      Object.keys(noOrderShapes).forEach(cameraName => {\n        noOrderShapes[cameraName].forEach(({\n          frameData,\n          shape\n        }) => {\n          // new order\n          shape.order = this.rootStore.frame.getNextShapeOrder(currentFrame, cameraName);\n          frameData.order = shape.order;\n        });\n      });\n    };\n    /**\n     * select shapes\n     * @param shapes\n     */\n    this.selectShapes = shapes => {\n      if (this.selectedPointIndex >= 0) {\n        // has point selected\n        if (this.selectedShapes.length === 1 && shapes.length === 1 && this.selectedShapes[0] === shapes[0]) {\n          // same shape, do not unselect\n          return;\n        }\n        this.selectedPointIndex = -1;\n      }\n      this.selectedShapes.forEach(shape => {\n        if (shapes.indexOf(shape) < 0) {\n          // not selected any more\n          shape.selected = false;\n        }\n      });\n      this.selectedShapes = [...shapes];\n      this.selectedShapes.forEach(shape => {\n        shape.selected = true;\n      });\n    };\n    /**\n     * select shape by instance item\n     * @param instanceItem\n     */\n    this.selectShapeByInstanceItem = instanceItem => {\n      const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...(instanceItem ? [instanceItem] : [])];\n      const shapes = this.getShapesByInstanceItems(instanceItems);\n      this.selectShapes(shapes);\n      const instancesSet = new Set(instanceItems.map(i => i.instance));\n      this.updateShapesInInstance(Array.from(instancesSet));\n      this.predict();\n    };\n    /**\n     * click to unselect shape\n     */\n    this.unselectShape = () => {\n      if (this.rootStore.config.addMode) {\n        return;\n      }\n      this.selectedShapes.forEach(shape => {\n        shape.selected = false;\n      });\n      this.selectedShapes = [];\n      this.rootStore.instance.selectInstance(null);\n    };\n    /**\n     * update shape border color\n     * @param instance\n     */\n    this.updateShapesInInstance = instance => {\n      const instances = Array.isArray(instance) ? instance : [...(instance ? [instance] : [])];\n      Object.values(this.shapes).forEach(({\n        shape,\n        instanceItem\n      }) => {\n        if (instances.indexOf(instanceItem.instance) >= 0) {\n          shape.borderColor = 0xFFFF00;\n          if (shape.shapeType === ShapeType.DOT) {\n            shape.color = 0xFFFF00;\n          }\n        } else {\n          shape.borderColor = shape.originColors.borderColor;\n          if (shape.shapeType === ShapeType.DOT) {\n            shape.color = shape.originColors.color;\n          }\n        }\n      });\n    };\n    /**\n     * click to draw a shape\n     * @param point\n     * @param shapeContainer\n     * @param imageBounds\n     * @param finishCallback\n     */\n    this.addShape = (point, shapeContainer, imageBounds, finishCallback) => {\n      if (this.rootStore.initialized && this.rootStore.config.addMode && !this.drawingShape) {\n        this.drawingShape = this.createShape(shapeContainer || this.currentLayer, imageBounds || this.rootStore.frame.imageBounds, this.rootStore.ontology.selectedCategoryItem.displayColor, this.rootStore.ontology.selectedCategory.className, this.rootStore.ontology.selectedCategoryItem.name);\n\n        // add listeners\n        this.drawingShape.on(EventAction.FINISHED, (shape, otherShapeData) => {\n          // remove listeners after creating\n          shape.off(EventAction.FINISHED);\n          shape.off(EventAction.REMOVED);\n          this.drawingShape = null;\n          this.rootStore.config.setAddMode(false);\n          // add shape to instance item\n          this.addShapeToCurrentInstanceItem(shape, otherShapeData);\n\n          // finish creating\n          // if (finishCallback) {\n          //   finishCallback();\n          // }\n        });\n        this.drawingShape.on(EventAction.REMOVED, () => {\n          this.drawingShape = null;\n        });\n        // start create\n        this.drawingShape.create(point);\n        return this.drawingShape;\n      }\n      return null;\n    };\n    /**\n     * add shape to current instance item\n     * @param shape\n     */\n    this.addShapeToCurrentInstanceItem = (shape, otherShapeData) => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem();\n      const data = shape.getData();\n      const prevBasicInfo = instanceItem.instance.getBasicInfo();\n      const {\n        prevState: prevStateItem,\n        currState: currStateItem\n      } = instanceItem.addShape(currentCamera, currentFrame, true, shape.shapeType, data, shape.order);\n      const basicInfo = instanceItem.instance.getBasicInfo();\n      const attributes = instanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n      const instanceState = {\n        [prevBasicInfo.id]: {\n          prev: {\n            ...prevBasicInfo,\n            children: prevStateItem ? [prevStateItem] : []\n          },\n          curr: {\n            ...basicInfo,\n            children: currStateItem ? [currStateItem] : []\n          }\n        }\n      };\n      if (otherShapeData) {\n        otherShapeData.forEach(shapeData => {\n          const otherInstanceItem = this.rootStore.instance.getCurrentInstanceItem();\n          const prevInfo = otherInstanceItem.instance.getBasicInfo();\n          if (otherInstanceItem.instance !== instanceItem.instance) {\n            otherInstanceItem.instance.setAttributes(instanceItem.instance.attributes);\n          }\n          const {\n            prevState,\n            currState\n          } = otherInstanceItem.updateShape(currentCamera, currentFrame, true, shape.shapeType, shapeData, this.rootStore.frame.getNextShapeOrder(), attributes);\n          this.setupShape(otherInstanceItem);\n          const currInfo = otherInstanceItem.instance.getBasicInfo();\n          if (!instanceState[currInfo.id]) {\n            instanceState[currInfo.id] = {\n              prev: {\n                ...prevInfo,\n                children: []\n              },\n              curr: {\n                ...currInfo,\n                children: []\n              }\n            };\n          }\n          const state = instanceState[currInfo.id];\n          if (prevState) {\n            state.prev.children.push(prevState);\n          }\n          if (currState) {\n            state.curr.children.push(currState);\n          }\n        });\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(instanceState).map(i => i.prev).filter(i => i.children.length > 0)\n      }, {\n        instances: Object.values(instanceState).map(i => i.curr)\n      });\n\n      // update shape instance\n      shape.label = instanceItem.label;\n      this.addShapeListeners(shape);\n      this.shapes[shape.uid] = {\n        shape,\n        camera: currentCamera,\n        instanceItem\n      };\n\n      // select\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n    };\n    /**\n     * add predicted shape to instance item\n     * @param instanceItem\n     * @param camera\n     */\n    this.addShapeToInstanceItem = (instanceItem, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentCamera,\n        currentFrame,\n        cameraViews,\n        getImageBoundsForCamera\n      } = this.rootStore.frame;\n      const currentCameraView = cameraViews[camera];\n      const imageBounds = getImageBoundsForCamera(camera);\n      if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n        return;\n      }\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame]) {\n        return;\n      }\n      let shapeInfo;\n      const predictedItem = Object.values(this.predictedShapes).find(i => i.instanceItem === instanceItem);\n      if (camera === currentCamera && predictedItem) {\n        // predicted shape in current camera exists, use it\n        const {\n          shape\n        } = predictedItem;\n        shapeInfo = {\n          shapeType: shape.shapeType,\n          shape: shape.getData()\n        };\n        // remove predicted shape\n        shape.destroy();\n        delete this.predictedShapes[shape.uid];\n      } else {\n        shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n      }\n      if (shapeInfo) {\n        // add to model\n        this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, shapeInfo.shapeType, shapeInfo.shape, this.rootStore.frame.getNextShapeOrder(currentFrame, camera), camera);\n        // create shape\n        this.setupShape(instanceItem, camera, currentCameraView.shapesLayer, imageBounds);\n        // select\n        this.rootStore.instance.selectInstanceItem(instanceItem);\n        this.rootStore.instance.autoOpenAttributesModal();\n      }\n    };\n    /**\n     * setup shape in current camera & current frame\n     * @param instanceItem\n     * @param shapeContainer\n     * @param imageBounds\n     */\n    this.setupShape = (instanceItem, camera = this.rootStore.frame.currentCamera, shapeContainer, imageBounds) => {\n      const {\n        cameraViews,\n        currentFrame\n      } = this.rootStore.frame;\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData) {\n        const frameData = cameraData.frames[currentFrame];\n        if (frameData) {\n          var _cameraViews$camera;\n          // remove shape if already exists\n          const existingShape = this.getShapeByInstanceItem(instanceItem, camera);\n          const existingShapeId = existingShape === null || existingShape === void 0 ? void 0 : existingShape.uid;\n          if (existingShape) {\n            this.deleteShape(existingShape);\n          }\n          // add shape\n          if (!((_cameraViews$camera = cameraViews[camera]) === null || _cameraViews$camera === void 0 ? void 0 : _cameraViews$camera.imageLoadError)) {\n            let order;\n            if (frameData.order !== undefined) {\n              order = frameData.order;\n            } else {\n              order = this.rootStore.frame.getNextShapeOrder();\n            }\n            const shape = this.createShape(shapeContainer || cameraViews[camera].shapesLayer, imageBounds || this.rootStore.frame.getImageBoundsForCamera(camera), instanceItem.categoryItemRef.displayColor, instanceItem.instance.category, instanceItem.name, frameData.shapeType, frameData.shape, order, instanceItem.label, camera);\n            if (shape.destroyed) {\n              // delete instance item\n              this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame, camera);\n              return;\n            }\n            this.addShapeListeners(shape);\n            this.shapes[shape.uid] = {\n              shape,\n              camera,\n              instanceItem\n            };\n            if (this.pendingMergePolygon === existingShapeId) {\n              this.pendingMergePolygon = shape.uid;\n            }\n          }\n        }\n      }\n    };\n    /**\n     * predict in current camera & current frame\n     */\n    this.predict = () => {\n      this.clearPredictedShapes();\n      const {\n        isMultiSelected,\n        selectedInstances,\n        selectedInstanceItems\n      } = this.rootStore.instance;\n      if (isMultiSelected) {\n        return;\n      }\n      if (selectedInstances.length === 1) {\n        const {\n          currentCamera,\n          currentFrame,\n          currentCameraView,\n          imageBounds\n        } = this.rootStore.frame;\n        if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n          return;\n        }\n        const selectedInstance = selectedInstances[0];\n        Object.values(selectedInstance.items).forEach(item => {\n          const shapeInfo = item.predictShape(currentCamera, currentFrame, imageBounds);\n          if (shapeInfo) {\n            // create predict shape\n            const predictedShape = this.createShape(this.currentLayer, imageBounds, item.categoryItemRef.displayColor, selectedInstance.category, item.name, shapeInfo.shapeType, shapeInfo.shape, 9999,\n            // predicted shape always on the top\n            item.label);\n            predictedShape.borderStyle = BorderStyle.DASHED;\n            predictedShape.borderColor = 0xFFFF00;\n            if (predictedShape.shapeType === ShapeType.DOT) {\n              predictedShape.color = 0xFFFF00;\n            }\n            predictedShape.editable = this.rootStore.config.reviewMode === ReviewMode.LABELING;\n            if (selectedInstanceItems.indexOf(item) >= 0) {\n              predictedShape.selected = true;\n            }\n            // add listeners\n            this.addShapeListeners(predictedShape);\n            this.predictedShapes[predictedShape.uid] = {\n              shape: predictedShape,\n              instanceItem: item\n            };\n          }\n        });\n      }\n    };\n    /**\n     * delete selected shape point or instance\n     */\n    this.delete = () => {\n      if (this.selectedShapes.length > 0) {\n        this.deleting = true;\n        this.selectedPointIndex = -1;\n        const pointsDeletedShapes = [];\n        this.selectedShapes.forEach(shape => {\n          const deleted = shape.deleteSelectedPoints();\n          if (deleted) {\n            pointsDeletedShapes.push(shape);\n          }\n        });\n        const {\n          currentFrame\n        } = this.rootStore.frame;\n        if (pointsDeletedShapes.length > 0) {\n          // has points deleted shapes\n          const instanceItems = [];\n          pointsDeletedShapes.forEach(shape => {\n            const shapeItem = this.shapes[shape.uid];\n            if (shapeItem) {\n              instanceItems.push({\n                instanceItem: shapeItem.instanceItem,\n                frameIndex: currentFrame,\n                shapeType: shape.shapeType,\n                shape: shape.destroyed ? undefined : shape.getData()\n              });\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n        } else {\n          // should delete shapes\n          const instanceItems = [];\n          this.selectedShapes.forEach(shape => {\n            const shapeItem = this.shapes[shape.uid];\n            if (shapeItem) {\n              const {\n                instanceItem\n              } = shapeItem;\n              instanceItems.push({\n                instanceItem,\n                frames: [currentFrame]\n              });\n            }\n          });\n          this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);\n          this.predict();\n        }\n      }\n      this.deleting = false;\n    };\n    /**\n     * delete shape instance\n     * @param shape\n     */\n    this.deleteShape = shape => {\n      const index = this.selectedShapes.indexOf(shape);\n      if (index >= 0) {\n        this.selectedShapes.splice(index, 1);\n      }\n      shape.destroy();\n      delete this.shapes[shape.uid];\n    };\n    /**\n     * delete shape by instance item\n     * @param instanceItem\n     */\n    this.deleteShapeByInstanceItem = instanceItem => {\n      const shape = this.getShapeByInstanceItem(instanceItem);\n      if (shape) {\n        this.deleteShape(shape);\n      }\n    };\n    /**\n     * set points user data for shape\n     * @param shape\n     * @param pointIndex\n     * @param userData\n     */\n    this.setPointUserData = (shape, pointIndex, userData) => {\n      if (shape instanceof Polygon || shape instanceof Line) {\n        const pointsData = [{\n          index: pointIndex,\n          userData\n        }];\n        shape.setPointsUserData(pointsData);\n      }\n    };\n    /**\n     * move selected shape to front\n     * @param toTop\n     */\n    this.moveFront = (toTop = false) => {\n      if (this.selectedShapes.length === 1) {\n        const selectedShape = this.selectedShapes[0];\n        if (toTop) {\n          this.moveToTop(this.shapes[selectedShape.uid].instanceItem);\n          return;\n        }\n        const intersections = this.getIntersectionsForShape(selectedShape);\n        if (intersections.length > 0) {\n          const upperShape = getUpperShape(selectedShape, intersections);\n          if (upperShape) {\n            this.exchangeShapeOrder(selectedShape, upperShape);\n            message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_FRONT_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    };\n    /**\n     * move selected shape to back\n     * @param toBottom\n     */\n    this.moveBack = (toBottom = false) => {\n      if (this.selectedShapes.length === 1) {\n        const selectedShape = this.selectedShapes[0];\n        if (toBottom) {\n          this.moveToBottom(this.shapes[selectedShape.uid].instanceItem);\n          return;\n        }\n        const intersections = this.getIntersectionsForShape(selectedShape);\n        if (intersections.length > 0) {\n          const underShape = getUnderShape(selectedShape, intersections);\n          if (underShape) {\n            this.exchangeShapeOrder(selectedShape, underShape);\n            message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_BACK_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    };\n    this.merge = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || this.selectedShapes.length !== 1) {\n        return;\n      }\n      const selectedShape = this.selectedShapes[0];\n      const {\n        shapeType\n      } = selectedShape;\n      if (shapeType === ShapeType.POLYGON) {\n        // merge polygon\n        const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i => i.shape);\n        const intersectPolygonIds = selectedShape.findIntersectPolygons(shapes);\n        if (intersectPolygonIds.length === 1) {\n          this.mergePolygons(selectedShape.uid, intersectPolygonIds[0]);\n        } else if (intersectPolygonIds.length === 0) {\n          message.warn(i18n.translate('MERGE_NO_INTERSECT'));\n        } else {\n          this.pendingMergePolygon = selectedShape.uid;\n          message.info(i18n.translate('MERGE_SELECT_NEXT'));\n        }\n      }\n    };\n    this.subtractPolygon = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || this.selectedShapes.length !== 1 || this.selectedShapes[0].shapeType !== ShapeType.POLYGON) {\n        return;\n      }\n      const selectedPolygon = this.selectedShapes[0];\n      const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i => i.shape);\n      const intersectPolygons = selectedPolygon.findIntersectPolygons(shapes, true).map(i => this.shapes[i].shape);\n      const subtractedData = selectedPolygon.subtract(intersectPolygons);\n      if (subtractedData && subtractedData.length > 0) {\n        this.updatePolygons(subtractedData[0][0], subtractedData.slice(1).map(d => d[0]));\n        message.success(i18n.translate('SUBTRACT_SUCCESS'));\n      } else {\n        message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));\n      }\n    };\n    this.updateConfig = ({\n      fill,\n      alpha,\n      showVertex,\n      showVertexOrder\n    }) => {\n      if (fill !== undefined) {\n        this.config.fill = fill;\n        this.updateShapesFill(fill);\n      }\n      if (alpha !== undefined) {\n        this.config.alpha = alpha;\n        this.updateShapesAlpha(alpha / 100);\n      }\n      if (showVertex !== undefined) {\n        this.config.showVertex = showVertex;\n        this.updateShowVertex(showVertex);\n      }\n      if (showVertexOrder !== undefined) {\n        this.config.showVertexOrder = showVertexOrder;\n        this.updateShowVertexOrder(showVertexOrder);\n      }\n    };\n    this.updateShapesFill = fill => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.alpha = fill ? this.config.alpha / 100 : 0;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.alpha = fill ? this.config.alpha / 100 : 0;\n      });\n    };\n    this.updateShapesAlpha = alpha => {\n      if (this.config.fill) {\n        if (this.drawingShape) {\n          this.drawingShape.alpha = alpha;\n        }\n        Object.values(this.shapes).forEach(({\n          shape\n        }) => {\n          shape.alpha = alpha;\n        });\n        Object.values(this.predictedShapes).forEach(({\n          shape\n        }) => {\n          shape.alpha = alpha;\n        });\n      }\n    };\n    this.updateShowVertex = showVertex => {\n      if (this.drawingShape) {\n        this.drawingShape.showVertex = showVertex;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showVertex = showVertex;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showVertex = showVertex;\n      });\n    };\n    this.updateShowVertexOrder = showVertexOrder => {\n      if (this.drawingShape) {\n        this.drawingShape.showVertexOrder = showVertexOrder;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n    };\n    this.resetConfig = () => {\n      this.updateConfig({\n        ...this.defaultConfig\n      });\n    };\n    makeObservable(this, {\n      shapes: observable,\n      selectedShapes: observable,\n      selectedPointIndex: observable,\n      config: observable,\n      init: action,\n      clearShapes: action,\n      setupShapes: action,\n      selectShapes: action,\n      unselectShape: action,\n      addShape: action,\n      setupShape: action,\n      deleteShape: action,\n      updateConfig: action\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload) {\n    this.config.fill = payload.is_fill !== 'false' && payload.is_fill !== false;\n    if (payload.fill_opacity !== undefined && payload.fill_opacity !== '') {\n      const alpha = Number(payload.fill_opacity);\n      if (!Number.isNaN(alpha) && alpha >= 0 && alpha <= 1) {\n        this.config.alpha = alpha * 100;\n      }\n    }\n    this.config.showVertex = payload.show_vertex === 'true' || payload.show_vertex === true;\n    this.config.showVertexOrder = payload.show_vertex_order === 'true' || payload.show_vertex_order === true;\n    this.defaultConfig = {\n      ...this.config\n    }; // save default settings\n\n    this.app = payload.app;\n  }\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable) {\n    Object.values(this.shapes).forEach(({\n      shape\n    }) => {\n      shape.editable = editable;\n    });\n    Object.values(this.predictedShapes).forEach(({\n      shape\n    }) => {\n      shape.editable = editable;\n    });\n  }\n  /**\n   * create shape label dom\n   */\n  createShapeLabel(camera = this.rootStore.frame.currentCamera) {\n    const shapeLabelsContainer = document.getElementById(`${CAMERA_VIEW_LABELS}-${camera}`);\n    if (shapeLabelsContainer) {\n      const shapeLabel = new Label({\n        className: 'shape-label',\n        transPosition: p => {\n          const cameraView = this.rootStore.frame.cameraViews[camera];\n          if (cameraView) {\n            return cameraView.toLocal(p);\n          }\n          return p;\n        }\n      });\n      shapeLabel.addToContainer(shapeLabelsContainer);\n      return shapeLabel;\n    }\n    return undefined;\n  }\n\n  /**\n   * create shape instance\n   * @param shapeContainer\n   * @param imageBounds\n   * @param hexColor\n   * @param categoryName\n   * @param categoryItemName\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param label\n   */\n  createShape(shapeContainer, imageBounds, hexColor, categoryName, categoryItemName, shapeType, shapeData, order, label, camera) {\n    var _this$rootStore$frame;\n    const {\n      rotatable\n    } = this.rootStore.config;\n    const {\n      currentShapeType\n    } = this.rootStore.ontology;\n    const useCurrent = shapeType === undefined;\n    const color = parseInt(hexColor.substr(1), 16);\n    const type = shapeType || currentShapeType;\n    const shape = ShapeFactory.getShape(type, {\n      app: this.app,\n      container: shapeContainer,\n      color,\n      alpha: this.config.fill ? this.config.alpha / 100 : 0,\n      showVertex: this.config.showVertex,\n      showVertexOrder: this.config.showVertexOrder,\n      label,\n      ...shapeData,\n      ...((type === ShapeType.RECTANGLE || type === ShapeType.POLYGON) && {\n        rotatable\n      }),\n      labelDom: this.createShapeLabel(camera),\n      scale: (_this$rootStore$frame = this.rootStore.frame.cameraViews[camera || this.rootStore.frame.currentCamera]) === null || _this$rootStore$frame === void 0 ? void 0 : _this$rootStore$frame.viewScale\n    });\n    // destroyed, not need to proceed\n    if (shape === null || shape === void 0 ? void 0 : shape.destroyed) {\n      return shape;\n    }\n    // update order, prefer to use given order\n    if (order !== undefined) {\n      shape.order = order;\n    } else if (useCurrent) {\n      shape.order = this.rootStore.frame.getNextShapeOrder();\n    }\n    // set default rotation for rectangle\n    if (shapeData && type === ShapeType.RECTANGLE) {\n      shape.rotation = shapeData.rotation || 0;\n    }\n    return shape;\n  }\n\n  /**\n   * add shape listeners\n   * @param shape\n   */\n  addShapeListeners(shape) {\n    shape.on(EventAction.SELECTED, (s, p) => {\n      if (!this.isPredictedShape(s)) {\n        if (this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n          if (this.pendingMergePolygon) {\n            this.mergePolygons(this.pendingMergePolygon, shape.uid);\n            this.pendingMergePolygon = '';\n            return;\n          }\n        }\n        if (this.selectedShapes.indexOf(s) < 0) {\n          this.selectShapes([s]);\n          this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n        }\n      } else {\n        // clear selected shape status\n        this.selectedShapes.forEach(ss => {\n          ss.selected = false;\n        });\n        this.selectedShapes = [];\n        // clear predicted shape selected status\n        Object.values(this.predictedShapes).forEach(predictedShape => {\n          if (predictedShape.shape !== s) {\n            predictedShape.shape.selected = false;\n          }\n        });\n        this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      }\n      if (this.rootStore.review.addMode) {\n        this.rootStore.review.addReview(p);\n      }\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      if (this.isPredictedShape(s)) {\n        this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      } else {\n        const {\n          instanceItem\n        } = this.shapes[s.uid];\n        const {\n          currentFrame\n        } = this.rootStore.frame;\n        if (!this.deleting) {\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, s.shapeType, data);\n        }\n      }\n    });\n    shape.on(EventAction.REMOVED, s => {\n      if (!this.deleting) {\n        const {\n          instanceItem\n        } = this.shapes[s.uid];\n        if (instanceItem) {\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n        }\n      }\n    });\n    shape.on(EventAction.POINTER_OVER, s => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = s.uid;\n      }\n    });\n    shape.on(EventAction.POINTER_OUT, s => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = '';\n      }\n    });\n    shape.on(EventAction.VERTEX_SELECTED, (s, index) => {\n      if (this.isPredictedShape(s)) {\n        return;\n      }\n      this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n      if (this.selectedShapes.length === 1 && this.selectedShapes[0] === s) {\n        this.selectedPointIndex = index;\n      } else {\n        this.selectedPointIndex = -1;\n      }\n    });\n  }\n  /**\n   * fit shapes to canvas for selected instances\n   */\n  fitShapes() {\n    const {\n      currentCamera,\n      cameraNames,\n      cameraViews\n    } = this.rootStore.frame;\n    const {\n      selectedInstanceItems,\n      selectedInstances\n    } = this.rootStore.instance;\n    const cameraShapes = selectedInstanceItems.length > 0 ? [{\n      camera: currentCamera,\n      shapes: this.getShapesByInstanceItems(selectedInstanceItems)\n    }] : cameraNames.map(camera => ({\n      camera,\n      shapes: Object.values(this.shapes).filter(s => s.camera === camera && selectedInstances.indexOf(s.instanceItem.instance) >= 0).map(s => s.shape)\n    }));\n    cameraShapes.forEach(({\n      camera,\n      shapes\n    }) => {\n      const cameraView = cameraViews[camera];\n      if (shapes.length > 0 && cameraView) {\n        let {\n          left,\n          top,\n          right,\n          bottom\n        } = shapes[0].instance.getLocalBounds();\n        for (let i = 1; i < shapes.length; i += 1) {\n          const bbox = shapes[i].instance.getLocalBounds();\n          left = Math.min(bbox.left, left);\n          top = Math.min(bbox.top, top);\n          right = Math.max(bbox.right, right);\n          bottom = Math.max(bbox.bottom, bottom);\n        }\n        cameraView.fitShapeToView({\n          left,\n          top,\n          right,\n          bottom\n        }, 0.5);\n      }\n    });\n  }\n  /**\n   * get intersections for shape\n   * @param shape\n   */\n  getIntersectionsForShape(shape) {\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i => i.shape).filter(s => s.visible && s.finished);\n    const intersections = shape.findIntersections(shapes);\n    return intersections;\n  }\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA, shapeB) {\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const {\n      instanceItem: instanceItemA\n    } = this.shapes[shapeA.uid];\n    const {\n      instanceItem: instanceItemB\n    } = this.shapes[shapeB.uid];\n    const instanceInfoA = instanceItemA.instance.getBasicInfo();\n    const instanceInfoB = instanceItemB.instance.getBasicInfo();\n\n    // save state\n    const prevInstances = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      });\n    } else {\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()]\n      });\n      prevInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()]\n      });\n    }\n    const storeId = this.rootStore.undo.preserve({\n      instances: prevInstances\n    });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    shapeA.order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    shapeB.order = orderA;\n    const currInstances = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      });\n    } else {\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()]\n      });\n      currInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()]\n      });\n    }\n    this.rootStore.undo.save(storeId, {\n      instances: currInstances\n    });\n  }\n\n  /**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */\n  moveToTop(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame,\n      getNextShapeOrder\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const maxOrder = Math.max(...cameraShapes.map(s => s.shape.order));\n    if (maxOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_FRONT_MOST'));\n      return;\n    }\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n    // preserve state\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }]\n    });\n    // update order\n    const order = getNextShapeOrder();\n    frameData.order = order;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = order;\n    }\n    // save state\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }]\n    });\n    message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));\n  }\n\n  /**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */\n  moveToBottom(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame,\n      updateNextShapeOrder\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const minOrder = Math.min(...cameraShapes.map(s => s.shape.order));\n    if (minOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_BACK_MOST'));\n      return;\n    }\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n\n    // prev instance state map\n    const prevInstanceMap = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }\n    };\n    // update selected shape order\n    const startOrder = 0;\n    frameData.order = startOrder;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = startOrder;\n    }\n    // current instance state map\n    const currInstanceMap = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }\n    };\n    if (minOrder <= startOrder) {\n      // show move all camera shapes upper\n      for (let i = 0; i < cameraShapes.length; i += 1) {\n        const {\n          shape: s,\n          instanceItem: sInstanceItem\n        } = cameraShapes[i];\n        if (sInstanceItem.id !== instanceItem.id) {\n          // not selected shape\n          const sInstanceInfo = sInstanceItem.instance.getBasicInfo();\n          const sInstanceItemInfo = sInstanceItem.getBasicInfo();\n          const sCameraData = sInstanceItem.cameras[currentCamera];\n          if (!prevInstanceMap[sInstanceInfo.id]) {\n            prevInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: []\n            };\n          }\n          prevInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()]\n          });\n          // update not selected shape's order\n          const order = s.order + 1;\n          sCameraData.frames[currentFrame].order = order;\n          s.order = order;\n          updateNextShapeOrder(order, currentFrame, currentCamera);\n          if (!currInstanceMap[sInstanceInfo.id]) {\n            currInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: []\n            };\n          }\n          currInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()]\n          });\n        }\n      }\n    }\n\n    // save state\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap)\n    }, {\n      instances: Object.values(currInstanceMap)\n    });\n    message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));\n  }\n  mergePolygons(polygonId1, polygonId2) {\n    const {\n      shape: polygon1,\n      instanceItem: instance1\n    } = this.shapes[polygonId1];\n    const {\n      shape: polygon2,\n      instanceItem: instance2\n    } = this.shapes[polygonId2];\n    const mergedData = polygon1.merge(polygon2);\n    if (mergedData.length === 1) {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const {\n        prevState,\n        currState\n      } = this.rootStore.instance.deleteInstanceItemByFrame(instance2, currentFrame);\n      const {\n        prevState: prevStateItem,\n        currState: currStateItem\n      } = instance1.updateShape(currentCamera, currentFrame, true, ShapeType.POLYGON, mergedData[0], this.rootStore.frame.getNextShapeOrder());\n      this.setupShape(instance1);\n      this.selectShapeByInstanceItem(instance1);\n      const basicInfo = instance1.instance.getBasicInfo();\n      this.rootStore.undo.push({\n        instances: [...prevState.instances, ...(prevStateItem ? [{\n          ...basicInfo,\n          children: [prevStateItem]\n        }] : [])]\n      }, {\n        instances: [...currState.instances, ...(currStateItem ? [{\n          ...basicInfo,\n          children: [currStateItem]\n        }] : [])]\n      });\n      message.success(i18n.translate('MERGE_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('MERGE_WITH_HOLE'));\n    }\n  }\n  updatePolygons(currPolygonData, otherPolygonData) {\n    this.updateShapes(currPolygonData, otherPolygonData, ShapeType.POLYGON);\n  }\n  updateShapes(currShapeData, otherShapeData, shapeType = ShapeType.POLYGON) {\n    const selectedShape = this.selectedShapes[0];\n    const {\n      instanceItem: selectedInstanceItem\n    } = this.shapes[selectedShape.uid];\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const attributes = selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n    const prevBasicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const {\n      prevState: prevStateItem,\n      currState: currStateItem\n    } = selectedInstanceItem.updateShape(currentCamera, currentFrame, true, shapeType, currShapeData, this.rootStore.frame.getNextShapeOrder(), attributes);\n    const basicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const instanceState = {\n      [basicInfo.id]: {\n        prev: {\n          ...prevBasicInfo,\n          children: prevStateItem ? [prevStateItem] : []\n        },\n        curr: {\n          ...basicInfo,\n          children: currStateItem ? [currStateItem] : []\n        }\n      }\n    };\n    this.setupShape(selectedInstanceItem);\n    for (let i = 0; i < otherShapeData.length; i += 1) {\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category, selectedInstanceItem.name);\n      const prevInfo = instanceItem.instance.getBasicInfo();\n      if (instanceItem.instance !== selectedInstanceItem.instance) {\n        var _selectedInstanceItem, _selectedInstanceItem2;\n        instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);\n        const dynamicAttributesCurrentFrame = (_selectedInstanceItem = selectedInstanceItem.instance.dynamicAttributes) === null || _selectedInstanceItem === void 0 ? void 0 : (_selectedInstanceItem2 = _selectedInstanceItem[currentCamera]) === null || _selectedInstanceItem2 === void 0 ? void 0 : _selectedInstanceItem2[currentFrame];\n        if (dynamicAttributesCurrentFrame && instanceItem.instance.categoryRef.labelConfigDynamic) {\n          instanceItem.instance.setDynamicAttributesByCamera(currentCamera, [dynamicAttributesCurrentFrame]);\n        }\n      }\n      const {\n        prevState,\n        currState\n      } = instanceItem.updateShape(currentCamera, currentFrame, true, shapeType, otherShapeData[i], this.rootStore.frame.getNextShapeOrder(), attributes);\n      this.setupShape(instanceItem);\n      const currInfo = instanceItem.instance.getBasicInfo();\n      if (!instanceState[currInfo.id]) {\n        instanceState[currInfo.id] = {\n          prev: {\n            ...prevInfo,\n            children: []\n          },\n          curr: {\n            ...currInfo,\n            children: []\n          }\n        };\n      }\n      const state = instanceState[currInfo.id];\n      if (prevState) {\n        state.prev.children.push(prevState);\n      }\n      if (currState) {\n        state.curr.children.push(currState);\n      }\n    }\n    this.selectShapeByInstanceItem(selectedInstanceItem);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map(i => i.prev).filter(i => i.children.length > 0)\n    }, {\n      instances: Object.values(instanceState).map(i => i.curr)\n    });\n  }\n}","map":{"version":3,"names":["makeObservable","observable","action","message","i18n","getUnderShape","getUpperShape","ReviewMode","CAMERA_VIEW_LABELS","ShapeFactory","ShapeType","EventAction","BorderStyle","Polygon","Line","Label","ShapeStore","isDrawing","drawingShape","constructor","rootStore","app","currentLayer","shapes","selectedShapes","selectedPointIndex","predictedShapes","hoveredShapeId","pendingMergePolygon","deleting","config","fill","alpha","showVertex","showVertexOrder","defaultConfig","clearShapes","Object","values","forEach","shape","destroy","clearPredictedShapes","isPredictedShape","s","findIndex","getShapeByInstanceItem","instanceItem","camera","frame","currentCamera","shapeItem","find","i","undefined","getShapesByInstanceItems","instanceItems","shapeItems","filter","indexOf","map","getShapesForCamera","updateShapesInteractive","interactive","ignoreIds","includes","uid","selected","redrawShapesLabel","drawShapeLabel","setupShapes","cameraViews","currentFrame","cameraNames","getImageBoundsForCamera","allShapeOrders","noOrderShapes","cameraName","Set","startOrder","instance","instances","items","item","cameras","frames","cameraView","imageLoadError","createShape","shapesLayer","categoryItemRef","displayColor","category","name","shapeType","order","label","destroyed","deleteInstanceItemByFrame","readonly","editable","addShapeListeners","has","push","frameData","keys","getNextShapeOrder","selectShapes","length","selectShapeByInstanceItem","Array","isArray","instancesSet","updateShapesInInstance","from","predict","unselectShape","addMode","selectInstance","borderColor","DOT","color","originColors","addShape","point","shapeContainer","imageBounds","finishCallback","initialized","ontology","selectedCategoryItem","selectedCategory","className","on","FINISHED","otherShapeData","off","REMOVED","setAddMode","addShapeToCurrentInstanceItem","create","getCurrentInstanceItem","data","getData","prevBasicInfo","getBasicInfo","prevState","prevStateItem","currState","currStateItem","basicInfo","attributes","instanceState","id","prev","children","curr","shapeData","otherInstanceItem","prevInfo","setAttributes","updateShape","setupShape","currInfo","state","undo","selectInstanceItem","autoOpenAttributesModal","addShapeToInstanceItem","currentCameraView","cameraData","shapeInfo","predictedItem","predictShape","updateFrameShapeForInstanceItem","_cameraViews$camera","existingShape","existingShapeId","deleteShape","isMultiSelected","selectedInstances","selectedInstanceItems","selectedInstance","predictedShape","borderStyle","DASHED","reviewMode","LABELING","delete","pointsDeletedShapes","deleted","deleteSelectedPoints","frameIndex","updateFrameShapeForInstanceItems","deleteFramesFromInstanceItems","index","splice","deleteShapeByInstanceItem","setPointUserData","pointIndex","userData","pointsData","setPointsUserData","moveFront","toTop","selectedShape","moveToTop","intersections","getIntersectionsForShape","upperShape","exchangeShapeOrder","success","translate","warning","moveBack","toBottom","moveToBottom","underShape","merge","isAnyModalOpened","POLYGON","intersectPolygonIds","findIntersectPolygons","mergePolygons","warn","info","subtractPolygon","selectedPolygon","intersectPolygons","subtractedData","subtract","updatePolygons","slice","d","updateConfig","updateShapesFill","updateShapesAlpha","updateShowVertex","updateShowVertexOrder","resetConfig","init","payload","is_fill","fill_opacity","Number","isNaN","show_vertex","show_vertex_order","updateShapesEditable","createShapeLabel","shapeLabelsContainer","document","getElementById","shapeLabel","transPosition","p","toLocal","addToContainer","hexColor","categoryName","categoryItemName","_this$rootStore$frame","rotatable","currentShapeType","useCurrent","parseInt","substr","type","getShape","container","RECTANGLE","labelDom","scale","viewScale","rotation","SELECTED","ss","updateSelectedInstanceItem","review","addReview","CHANGED","deleteFramesFromInstanceItem","POINTER_OVER","POINTER_OUT","VERTEX_SELECTED","fitShapes","cameraShapes","left","top","right","bottom","getLocalBounds","bbox","Math","min","max","fitShapeToView","visible","finished","findIntersections","shapeA","shapeB","orderA","orderB","instanceItemA","instanceItemB","instanceInfoA","instanceInfoB","prevInstances","toJSON","storeId","preserve","currInstances","save","maxOrder","instanceInfo","instanceItemInfo","updateNextShapeOrder","minOrder","prevInstanceMap","currInstanceMap","sInstanceItem","sInstanceInfo","sInstanceItemInfo","sCameraData","polygonId1","polygonId2","polygon1","instance1","polygon2","instance2","mergedData","currPolygonData","otherPolygonData","updateShapes","currShapeData","selectedInstanceItem","_selectedInstanceItem","_selectedInstanceItem2","dynamicAttributesCurrentFrame","dynamicAttributes","categoryRef","labelConfigDynamic","setDynamicAttributesByCamera"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/ShapeStore.ts"],"sourcesContent":["import { Application, Container, Point } from 'pixi.js';\nimport { makeObservable, observable, action } from 'mobx';\nimport { message } from 'antd';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport FrameData from '../model/FrameData';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape } from '../utils';\nimport { Payload, Instance as IInstance, ReviewMode } from '../types';\nimport { CAMERA_VIEW_LABELS } from '../constants';\nimport ShapeFactory from '../../common/shapes/ShapeFactory';\nimport { ShapeType, ShapeData } from '../../common/shapes/types';\nimport Shape, { EventAction, BorderStyle } from '../../common/shapes/Shape';\nimport { RectangleData } from '../../common/shapes/Rectangle';\nimport Polygon, { PolygonData } from '../../common/shapes/Polygon';\nimport Line from '../../common/shapes/Line';\nimport Label from '../../common/shapes/label/Label';\n\n/**\n * store for shapes in current camera & current frame\n * @class\n */\nexport default class ShapeStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * app\n   */\n  app?: Application;\n\n  /**\n   * current layer\n   */\n  currentLayer?: Container;\n\n  /**\n   * shapes in current frame\n   */\n  shapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      camera: string;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * currently drawing shape\n   */\n  drawingShape: Shape<ShapeData> | null = null;\n\n  /**\n   * currently selected shapes\n   */\n  selectedShapes: Shape<ShapeData>[] = [];\n\n  /**\n   * currently selected shape vertex index for polygon & line\n   */\n  selectedPointIndex = -1;\n\n  /**\n   * predicted shapes\n   */\n  predictedShapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * hovered shape id\n   */\n  hoveredShapeId = '';\n\n  /**\n   * waiting merge polygon\n   */\n  pendingMergePolygon = '';\n\n  /**\n   * is deleting\n   */\n  deleting = false;\n\n  /**\n   * shape display config\n   */\n  config = {\n    fill: true,\n    alpha: 20,\n    showVertex: false,\n    showVertexOrder: false,\n  };\n\n  /**\n   * default config from payload\n   */\n  defaultConfig = this.config;\n\n  /**\n   * is drawing shape\n   * @getter\n   */\n  get isDrawing() {\n    return this.drawingShape !== null;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeObservable(this, {\n      shapes: observable,\n      selectedShapes: observable,\n      selectedPointIndex: observable,\n      config: observable,\n      init: action,\n      clearShapes: action,\n      setupShapes: action,\n      selectShapes: action,\n      unselectShape: action,\n      addShape: action,\n      setupShape: action,\n      deleteShape: action,\n      updateConfig: action,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload: Payload) {\n    this.config.fill = payload.is_fill !== 'false' && payload.is_fill !== false;\n    if (payload.fill_opacity !== undefined && payload.fill_opacity !== '') {\n      const alpha = Number(payload.fill_opacity);\n      if (!Number.isNaN(alpha) && alpha >= 0 && alpha <= 1) {\n        this.config.alpha = alpha * 100;\n      }\n    }\n    this.config.showVertex = payload.show_vertex === 'true' || payload.show_vertex === true;\n    this.config.showVertexOrder = payload.show_vertex_order === 'true' || payload.show_vertex_order === true;\n    this.defaultConfig = { ...this.config }; // save default settings\n\n    this.app = payload.app;\n  }\n\n  /**\n   * clear shapes\n   */\n  clearShapes = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.shapes = {};\n    this.drawingShape = null;\n    this.selectedShapes = [];\n    this.clearPredictedShapes();\n    this.selectedPointIndex = -1;\n  };\n\n  /**\n   * clear predicted shapes\n   */\n  clearPredictedShapes = () => {\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.predictedShapes = {};\n  };\n\n  /**\n   * is predicted shape\n   * @param s\n   */\n  isPredictedShape = (s: Shape<ShapeData>) => Object.values(this.predictedShapes).findIndex(({ shape }) => shape === s) >= 0;\n\n  /**\n   * get shape by instance item\n   * @param instanceItem\n   */\n  getShapeByInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const shapeItem = Object.values(this.shapes).find((i) => i.camera === camera && i.instanceItem === instanceItem);\n    if (shapeItem) {\n      return shapeItem.shape;\n    }\n    return undefined;\n  };\n\n  /**\n   * get shapes by instance items\n   * @param instanceItems\n   * @param camera\n   */\n  getShapesByInstanceItems = (instanceItems: InstanceItem[], camera = this.rootStore.frame.currentCamera) => {\n    const shapeItems = Object.values(this.shapes).filter((i) => i.camera === camera && instanceItems.indexOf(i.instanceItem) >= 0);\n    return shapeItems.map((i) => i.shape);\n  };\n\n  /**\n   * get shapes for one camera\n   * @param camera\n   */\n  getShapesForCamera = (camera: string) => Object.values(this.shapes).filter((s) => s.camera === camera);\n\n  /**\n   * update shapes interactive\n   * @param interactive\n   * @param ignoreIds\n   */\n  updateShapesInteractive = (interactive: boolean, ignoreIds?: string[]) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (ignoreIds && ignoreIds.includes(shape.uid)) {\n        return;\n      }\n      shape.interactive = interactive;\n      if (interactive && this.selectedShapes.indexOf(shape) >= 0) {\n        shape.selected = true;\n      }\n    });\n  };\n\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable: boolean) {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.editable = editable;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.editable = editable;\n    });\n  }\n\n  /**\n   * redraw shapes label\n   */\n  redrawShapesLabel = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n  };\n\n  /**\n   * setup shapes for current frame\n   */\n  setupShapes = () => {\n    this.clearShapes();\n    const { cameraViews, currentFrame, cameraNames, getImageBoundsForCamera } = this.rootStore.frame;\n    const allShapeOrders: {\n      [camera: string]: Set<number>;\n    } = {};\n    const noOrderShapes: {\n      [camera: string]: { frameData: FrameData, shape: Shape<ShapeData> }[];\n    } = {};\n    cameraNames.forEach((cameraName) => {\n      allShapeOrders[cameraName] = new Set();\n      noOrderShapes[cameraName] = [];\n    });\n    const startOrder = 0;\n    Object.values(this.rootStore.instance.instances).forEach((instance) => {\n      Object.values(instance.items).forEach((item) => {\n        Object.values(item.cameras).forEach(({ camera }) => {\n          const { frames } = item.cameras[camera];\n          const cameraView = cameraViews[camera];\n          if (frames[currentFrame] && cameraView && !cameraView.imageLoadError) {\n            const shape = this.createShape(\n              cameraView.shapesLayer,\n              getImageBoundsForCamera(camera),\n              item.categoryItemRef.displayColor,\n              instance.category,\n              item.name,\n              frames[currentFrame].shapeType,\n              frames[currentFrame].shape,\n              frames[currentFrame].order,\n              item.label,\n              camera,\n            );\n            if (shape.destroyed) {\n              // delete instance item\n              this.rootStore.instance.deleteInstanceItemByFrame(item, currentFrame, camera);\n              return;\n            }\n            if (this.rootStore.readonly) {\n              shape.editable = false;\n            }\n            this.addShapeListeners(shape);\n            this.shapes[shape.uid] = {\n              shape,\n              camera,\n              instanceItem: item,\n            };\n\n            const { order } = frames[currentFrame];\n            if (typeof order === 'number' && order >= startOrder && !allShapeOrders[camera].has(order)) {\n              // update next shape order\n              shape.order = order;\n            } else {\n              // add to temp array\n              noOrderShapes[camera].push({ frameData: frames[currentFrame], shape });\n            }\n          }\n        });\n      });\n    });\n    Object.keys(noOrderShapes).forEach((cameraName) => {\n      noOrderShapes[cameraName].forEach(({ frameData, shape }) => {\n        // new order\n        shape.order = this.rootStore.frame.getNextShapeOrder(currentFrame, cameraName);\n        frameData.order = shape.order;\n      });\n    });\n  };\n\n  /**\n   * create shape label dom\n   */\n  createShapeLabel(camera = this.rootStore.frame.currentCamera) {\n    const shapeLabelsContainer = document.getElementById(`${CAMERA_VIEW_LABELS}-${camera}`);\n    if (shapeLabelsContainer) {\n      const shapeLabel = new Label({\n        className: 'shape-label',\n        transPosition: (p) => {\n          const cameraView = this.rootStore.frame.cameraViews[camera];\n          if (cameraView) {\n            return cameraView.toLocal(p);\n          }\n          return p;\n        },\n      });\n      shapeLabel.addToContainer(shapeLabelsContainer);\n      return shapeLabel;\n    }\n    return undefined;\n  }\n\n  /**\n   * create shape instance\n   * @param shapeContainer\n   * @param imageBounds\n   * @param hexColor\n   * @param categoryName\n   * @param categoryItemName\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param label\n   */\n  createShape(\n    shapeContainer: Container,\n    imageBounds: { left: number; top: number; right: number; bottom: number; },\n    hexColor: string,\n    categoryName: string,\n    categoryItemName: string,\n    shapeType?: ShapeType,\n    shapeData?: ShapeData,\n    order?: number,\n    label?: string,\n    camera?: string,\n  ) {\n    const { rotatable } = this.rootStore.config;\n    const { currentShapeType } = this.rootStore.ontology;\n    const useCurrent = shapeType === undefined;\n    const color = parseInt(hexColor.substr(1), 16);\n    const type = shapeType || currentShapeType;\n    const shape = ShapeFactory.getShape(type, {\n      app: this.app!,\n      container: shapeContainer,\n      color,\n      alpha: this.config.fill ? this.config.alpha / 100 : 0,\n      showVertex: this.config.showVertex,\n      showVertexOrder: this.config.showVertexOrder,\n      label,\n      ...shapeData,\n      ...(type === ShapeType.RECTANGLE || type === ShapeType.POLYGON) && {\n        rotatable,\n      },\n      labelDom: this.createShapeLabel(camera),\n      scale: this.rootStore.frame.cameraViews[camera || this.rootStore.frame.currentCamera]?.viewScale,\n    });\n    // destroyed, not need to proceed\n    if (shape?.destroyed) {\n      return shape;\n    }\n    // update order, prefer to use given order\n    if (order !== undefined) {\n      shape!.order = order;\n    } else if (useCurrent) {\n      shape!.order = this.rootStore.frame.getNextShapeOrder();\n    }\n    // set default rotation for rectangle\n    if (shapeData && type === ShapeType.RECTANGLE) {\n      shape!.rotation = (shapeData as RectangleData).rotation || 0;\n    }\n    return shape!;\n  }\n\n  /**\n   * add shape listeners\n   * @param shape\n   */\n  addShapeListeners(shape: Shape<ShapeData>) {\n    shape.on(EventAction.SELECTED, (s, p) => {\n      if (!this.isPredictedShape(s)) {\n        if (this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n          if (this.pendingMergePolygon) {\n            this.mergePolygons(this.pendingMergePolygon, shape.uid);\n            this.pendingMergePolygon = '';\n            return;\n          }\n        }\n        if (this.selectedShapes.indexOf(s) < 0) {\n          this.selectShapes([s]);\n          this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n        }\n      } else {\n        // clear selected shape status\n        this.selectedShapes.forEach((ss) => {\n          ss.selected = false;\n        });\n        this.selectedShapes = [];\n        // clear predicted shape selected status\n        Object.values(this.predictedShapes).forEach((predictedShape) => {\n          if (predictedShape.shape !== s) {\n            predictedShape.shape.selected = false;\n          }\n        });\n        this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      }\n      if (this.rootStore.review.addMode) {\n        this.rootStore.review.addReview(p);\n      }\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      if (this.isPredictedShape(s)) {\n        this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      } else {\n        const { instanceItem } = this.shapes[s.uid];\n        const { currentFrame } = this.rootStore.frame;\n        if (!this.deleting) {\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, s.shapeType, data);\n        }\n      }\n    });\n    shape.on(EventAction.REMOVED, (s) => {\n      if (!this.deleting) {\n        const { instanceItem } = this.shapes[s.uid];\n        if (instanceItem) {\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n        }\n      }\n    });\n    shape.on(EventAction.POINTER_OVER, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = s.uid;\n      }\n    });\n    shape.on(EventAction.POINTER_OUT, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = '';\n      }\n    });\n    shape.on(EventAction.VERTEX_SELECTED, (s, index) => {\n      if (this.isPredictedShape(s)) {\n        return;\n      }\n      this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n      if (this.selectedShapes.length === 1 && this.selectedShapes[0] === s) {\n        this.selectedPointIndex = index;\n      } else {\n        this.selectedPointIndex = -1;\n      }\n    });\n  }\n\n  /**\n   * select shapes\n   * @param shapes\n   */\n  selectShapes = (shapes: Shape<ShapeData>[]) => {\n    if (this.selectedPointIndex >= 0) {\n      // has point selected\n      if (this.selectedShapes.length === 1 && shapes.length === 1 && this.selectedShapes[0] === shapes[0]) {\n        // same shape, do not unselect\n        return;\n      }\n      this.selectedPointIndex = -1;\n    }\n    this.selectedShapes.forEach((shape) => {\n      if (shapes.indexOf(shape) < 0) { // not selected any more\n        shape.selected = false;\n      }\n    });\n    this.selectedShapes = [...shapes];\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = true;\n    });\n  };\n\n  /**\n   * select shape by instance item\n   * @param instanceItem\n   */\n  selectShapeByInstanceItem = (instanceItem: InstanceItem | InstanceItem[] | null) => {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...instanceItem ? [instanceItem] : []];\n    const shapes = this.getShapesByInstanceItems(instanceItems);\n    this.selectShapes(shapes);\n    const instancesSet = new Set(instanceItems.map((i) => i.instance));\n    this.updateShapesInInstance(Array.from(instancesSet));\n    this.predict();\n  };\n\n  /**\n   * fit shapes to canvas for selected instances\n   */\n  fitShapes() {\n    const { currentCamera, cameraNames, cameraViews } = this.rootStore.frame;\n    const { selectedInstanceItems, selectedInstances } = this.rootStore.instance;\n\n    const cameraShapes = selectedInstanceItems.length > 0\n      ? [{ camera: currentCamera, shapes: this.getShapesByInstanceItems(selectedInstanceItems) }]\n      : cameraNames.map((camera) => ({\n        camera,\n        shapes: Object.values(this.shapes).filter((s) => s.camera === camera && selectedInstances.indexOf(s.instanceItem.instance) >= 0).map((s) => s.shape),\n      }));\n    cameraShapes.forEach(({ camera, shapes }) => {\n      const cameraView = cameraViews[camera];\n      if (shapes.length > 0 && cameraView) {\n        let { left, top, right, bottom } = shapes[0].instance.getLocalBounds();\n        for (let i = 1; i < shapes.length; i += 1) {\n          const bbox = shapes[i].instance.getLocalBounds();\n          left = Math.min(bbox.left, left);\n          top = Math.min(bbox.top, top);\n          right = Math.max(bbox.right, right);\n          bottom = Math.max(bbox.bottom, bottom);\n        }\n        cameraView.fitShapeToView({ left, top, right, bottom }, 0.5);\n      }\n    });\n  }\n\n  /**\n   * click to unselect shape\n   */\n  unselectShape = () => {\n    if (\n      this.rootStore.config.addMode\n    ) {\n      return;\n    }\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = false;\n    });\n    this.selectedShapes = [];\n    this.rootStore.instance.selectInstance(null);\n  };\n\n  /**\n   * update shape border color\n   * @param instance\n   */\n  updateShapesInInstance = (instance?: Instance | Instance[] | null) => {\n    const instances = Array.isArray(instance) ? instance : [...instance ? [instance] : []];\n    Object.values(this.shapes).forEach(({ shape, instanceItem }) => {\n      if (instances.indexOf(instanceItem.instance) >= 0) {\n        shape.borderColor = 0xFFFF00;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = 0xFFFF00;\n        }\n      } else {\n        shape.borderColor = shape.originColors.borderColor;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = shape.originColors.color;\n        }\n      }\n    });\n  };\n\n  /**\n   * click to draw a shape\n   * @param point\n   * @param shapeContainer\n   * @param imageBounds\n   * @param finishCallback\n   */\n  addShape = (\n    point?: Point,\n    shapeContainer?: Container,\n    imageBounds?: { left: number; top: number; right: number; bottom: number },\n    finishCallback?: () => void,\n  ) => {\n    if (this.rootStore.initialized && this.rootStore.config.addMode && !this.drawingShape) {\n      this.drawingShape = this.createShape(\n        shapeContainer || this.currentLayer!,\n        imageBounds || this.rootStore.frame.imageBounds,\n        this.rootStore.ontology.selectedCategoryItem.displayColor,\n        this.rootStore.ontology.selectedCategory.className,\n        this.rootStore.ontology.selectedCategoryItem.name,\n      );\n\n      // add listeners\n      this.drawingShape.on(EventAction.FINISHED, (shape, otherShapeData) => {\n        // remove listeners after creating\n        shape.off(EventAction.FINISHED);\n        shape.off(EventAction.REMOVED);\n\n        this.drawingShape = null;\n        this.rootStore.config.setAddMode(false);\n        // add shape to instance item\n        this.addShapeToCurrentInstanceItem(shape, otherShapeData);\n\n        // finish creating\n        // if (finishCallback) {\n        //   finishCallback();\n        // }\n      });\n      this.drawingShape.on(EventAction.REMOVED, () => {\n        this.drawingShape = null;\n      });\n      // start create\n      this.drawingShape.create(point);\n      return this.drawingShape;\n    }\n    return null;\n  };\n\n  /**\n   * add shape to current instance item\n   * @param shape\n   */\n  addShapeToCurrentInstanceItem = (shape: Shape<ShapeData>, otherShapeData?: ShapeData[]) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const instanceItem = this.rootStore.instance.getCurrentInstanceItem();\n    const data = shape.getData();\n    const prevBasicInfo = instanceItem.instance.getBasicInfo();\n    const { prevState: prevStateItem, currState: currStateItem } = instanceItem.addShape(\n      currentCamera,\n      currentFrame,\n      true,\n      shape.shapeType,\n      data,\n      shape.order,\n    );\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    const attributes = instanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [prevBasicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevStateItem ? [prevStateItem] : [] },\n        curr: { ...basicInfo, children: currStateItem ? [currStateItem] : [] }\n      }\n    };\n\n    if (otherShapeData) {\n      otherShapeData.forEach((shapeData) => {\n        const otherInstanceItem = this.rootStore.instance.getCurrentInstanceItem();\n\n        const prevInfo = otherInstanceItem.instance.getBasicInfo();\n        if (otherInstanceItem.instance !== instanceItem.instance) {\n          otherInstanceItem.instance.setAttributes(instanceItem.instance.attributes);\n        }\n\n        const { prevState, currState } = otherInstanceItem.updateShape(\n          currentCamera,\n          currentFrame,\n          true,\n          shape.shapeType,\n          shapeData,\n          this.rootStore.frame.getNextShapeOrder(),\n          attributes,\n        );\n        this.setupShape(otherInstanceItem);\n        const currInfo = otherInstanceItem.instance.getBasicInfo();\n        if (!instanceState[currInfo.id]) {\n          instanceState[currInfo.id] = {\n            prev: { ...prevInfo, children: [] },\n            curr: { ...currInfo, children: [] }\n          };\n        }\n        const state = instanceState[currInfo.id];\n        if (prevState) {\n          state.prev.children.push(prevState);\n        }\n        if (currState) {\n          state.curr.children.push(currState);\n        }\n      });\n    }\n\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev).filter((i) => i.children.length > 0),\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr),\n    });\n\n    // update shape instance\n    shape.label = instanceItem.label;\n    this.addShapeListeners(shape);\n    this.shapes[shape.uid] = { shape, camera: currentCamera, instanceItem };\n\n    // select\n    this.rootStore.instance.selectInstanceItem(instanceItem);\n    this.rootStore.instance.autoOpenAttributesModal();\n  };\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const { currentCamera, currentFrame, cameraViews, getImageBoundsForCamera } = this.rootStore.frame;\n    const currentCameraView = cameraViews[camera];\n    const imageBounds = getImageBoundsForCamera(camera);\n    if (currentCameraView?.imageLoadError) {\n      return;\n    }\n\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData?.frames[currentFrame]) {\n      return;\n    }\n\n    let shapeInfo;\n    const predictedItem = Object.values(this.predictedShapes).find((i) => i.instanceItem === instanceItem);\n    if (camera === currentCamera && predictedItem) {\n      // predicted shape in current camera exists, use it\n      const { shape } = predictedItem;\n      shapeInfo = {\n        shapeType: shape.shapeType,\n        shape: shape.getData(),\n      };\n      // remove predicted shape\n      shape.destroy();\n      delete this.predictedShapes[shape.uid];\n    } else {\n      shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n    }\n\n    if (shapeInfo) {\n      // add to model\n      this.rootStore.instance.updateFrameShapeForInstanceItem(\n        instanceItem,\n        currentFrame,\n        shapeInfo.shapeType,\n        shapeInfo.shape,\n        this.rootStore.frame.getNextShapeOrder(currentFrame, camera),\n        camera,\n      );\n      // create shape\n      this.setupShape(instanceItem, camera, currentCameraView.shapesLayer, imageBounds);\n      // select\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  };\n\n  /**\n   * setup shape in current camera & current frame\n   * @param instanceItem\n   * @param shapeContainer\n   * @param imageBounds\n   */\n  setupShape = (\n    instanceItem: InstanceItem,\n    camera = this.rootStore.frame.currentCamera,\n    shapeContainer?: Container,\n    imageBounds?: { left: number; top: number; right: number; bottom: number; },\n  ) => {\n    const { cameraViews, currentFrame } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        // remove shape if already exists\n        const existingShape = this.getShapeByInstanceItem(instanceItem, camera);\n        const existingShapeId = existingShape?.uid;\n        if (existingShape) {\n          this.deleteShape(existingShape);\n        }\n        // add shape\n        if (!cameraViews[camera]?.imageLoadError) {\n          let order;\n          if (frameData.order !== undefined) {\n            order = frameData.order;\n          } else {\n            order = this.rootStore.frame.getNextShapeOrder();\n          }\n          const shape = this.createShape(\n            shapeContainer || cameraViews[camera].shapesLayer,\n            imageBounds || this.rootStore.frame.getImageBoundsForCamera(camera),\n            instanceItem.categoryItemRef.displayColor,\n            instanceItem.instance.category,\n            instanceItem.name,\n            frameData.shapeType,\n            frameData.shape,\n            order,\n            instanceItem.label,\n            camera,\n          );\n          if (shape.destroyed) {\n            // delete instance item\n            this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame, camera);\n            return;\n          }\n          this.addShapeListeners(shape);\n          this.shapes[shape.uid] = { shape, camera, instanceItem };\n          if (this.pendingMergePolygon === existingShapeId) {\n            this.pendingMergePolygon = shape.uid;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * predict in current camera & current frame\n   */\n  predict = () => {\n    this.clearPredictedShapes();\n\n    const { isMultiSelected, selectedInstances, selectedInstanceItems } = this.rootStore.instance;\n    if (isMultiSelected) {\n      return;\n    }\n\n    if (selectedInstances.length === 1) {\n      const { currentCamera, currentFrame, currentCameraView, imageBounds } = this.rootStore.frame;\n      if (currentCameraView?.imageLoadError) {\n        return;\n      }\n\n      const selectedInstance = selectedInstances[0];\n      Object.values(selectedInstance.items).forEach((item) => {\n        const shapeInfo = item.predictShape(currentCamera, currentFrame, imageBounds);\n        if (shapeInfo) {\n          // create predict shape\n          const predictedShape = this.createShape(\n            this.currentLayer!,\n            imageBounds,\n            item.categoryItemRef.displayColor,\n            selectedInstance.category,\n            item.name,\n            shapeInfo.shapeType,\n            shapeInfo.shape,\n            9999, // predicted shape always on the top\n            item.label,\n          );\n          predictedShape.borderStyle = BorderStyle.DASHED;\n          predictedShape.borderColor = 0xFFFF00;\n          if (predictedShape.shapeType === ShapeType.DOT) {\n            predictedShape.color = 0xFFFF00;\n          }\n          predictedShape.editable = this.rootStore.config.reviewMode === ReviewMode.LABELING;\n          if (selectedInstanceItems.indexOf(item) >= 0) {\n            predictedShape.selected = true;\n          }\n          // add listeners\n          this.addShapeListeners(predictedShape);\n\n          this.predictedShapes[predictedShape.uid] = {\n            shape: predictedShape,\n            instanceItem: item,\n          };\n        }\n      });\n    }\n  };\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete = () => {\n    if (this.selectedShapes.length > 0) {\n      this.deleting = true;\n      this.selectedPointIndex = -1;\n\n      const pointsDeletedShapes: Shape<ShapeData>[] = [];\n      this.selectedShapes.forEach((shape) => {\n        const deleted = shape.deleteSelectedPoints();\n        if (deleted) {\n          pointsDeletedShapes.push(shape);\n        }\n      });\n\n      const { currentFrame } = this.rootStore.frame;\n      if (pointsDeletedShapes.length > 0) {\n        // has points deleted shapes\n        const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape?: ShapeData }[] = [];\n        pointsDeletedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            instanceItems.push({\n              instanceItem: shapeItem.instanceItem,\n              frameIndex: currentFrame,\n              shapeType: shape.shapeType,\n              shape: shape.destroyed ? undefined : shape.getData(),\n            });\n          }\n        });\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      } else {\n        // should delete shapes\n        const instanceItems: { instanceItem: InstanceItem, frames: number[] }[] = [];\n        this.selectedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            const { instanceItem } = shapeItem;\n            instanceItems.push({ instanceItem, frames: [currentFrame] });\n          }\n        });\n        this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);\n        this.predict();\n      }\n    }\n    this.deleting = false;\n  };\n\n  /**\n   * delete shape instance\n   * @param shape\n   */\n  deleteShape = (shape: Shape<ShapeData>) => {\n    const index = this.selectedShapes.indexOf(shape);\n    if (index >= 0) {\n      this.selectedShapes.splice(index, 1);\n    }\n    shape.destroy();\n    delete this.shapes[shape.uid];\n  };\n\n  /**\n   * delete shape by instance item\n   * @param instanceItem\n   */\n  deleteShapeByInstanceItem = (instanceItem: InstanceItem) => {\n    const shape = this.getShapeByInstanceItem(instanceItem);\n    if (shape) {\n      this.deleteShape(shape);\n    }\n  };\n\n  /**\n   * set points user data for shape\n   * @param shape\n   * @param pointIndex\n   * @param userData\n   */\n  setPointUserData = (shape: Shape<ShapeData>, pointIndex: number, userData: any) => {\n    if (shape instanceof Polygon || shape instanceof Line) {\n      const pointsData = [{ index: pointIndex, userData }];\n      shape.setPointsUserData(pointsData);\n    }\n  };\n\n  /**\n   * get intersections for shape\n   * @param shape\n   */\n  getIntersectionsForShape(shape: Shape<ShapeData>) {\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape).filter((s) => s.visible && s.finished);\n    const intersections = shape.findIntersections(shapes);\n    return intersections;\n  }\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA: Shape<ShapeData>, shapeB: Shape<ShapeData>) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const { instanceItem: instanceItemA } = this.shapes[shapeA.uid];\n    const { instanceItem: instanceItemB } = this.shapes[shapeB.uid];\n    const instanceInfoA = instanceItemA.instance.getBasicInfo();\n    const instanceInfoB = instanceItemB.instance.getBasicInfo();\n\n    // save state\n    const prevInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      prevInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    const storeId = this.rootStore.undo.preserve({ instances: prevInstances });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    shapeA.order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    shapeB.order = orderA;\n\n    const currInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      currInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    this.rootStore.undo.save(storeId, { instances: currInstances });\n  }\n\n  /**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */\n  moveToTop(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, getNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const maxOrder = Math.max(...cameraShapes.map((s) => s.shape.order));\n    if (maxOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_FRONT_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n    // preserve state\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n    // update order\n    const order = getNextShapeOrder();\n    frameData.order = order;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = order;\n    }\n    // save state\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n\n    message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));\n  }\n\n  /**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */\n  moveToBottom(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, updateNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const minOrder = Math.min(...cameraShapes.map((s) => s.shape.order));\n    if (minOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_BACK_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n\n    // prev instance state map\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n    // update selected shape order\n    const startOrder = 0;\n    frameData.order = startOrder;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = startOrder;\n    }\n    // current instance state map\n    const currInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n\n    if (minOrder <= startOrder) {\n      // show move all camera shapes upper\n      for (let i = 0; i < cameraShapes.length; i += 1) {\n        const { shape: s, instanceItem: sInstanceItem } = cameraShapes[i];\n        if (sInstanceItem.id !== instanceItem.id) {\n          // not selected shape\n          const sInstanceInfo = sInstanceItem.instance.getBasicInfo();\n          const sInstanceItemInfo = sInstanceItem.getBasicInfo();\n          const sCameraData = sInstanceItem.cameras[currentCamera];\n          if (!prevInstanceMap[sInstanceInfo.id]) {\n            prevInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          prevInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n          // update not selected shape's order\n          const order = s.order + 1;\n          sCameraData.frames[currentFrame].order = order;\n          s.order = order;\n          updateNextShapeOrder(order, currentFrame, currentCamera);\n          if (!currInstanceMap[sInstanceInfo.id]) {\n            currInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          currInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n        }\n      }\n    }\n\n    // save state\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n    });\n\n    message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));\n  }\n\n  /**\n   * move selected shape to front\n   * @param toTop\n   */\n  moveFront = (toTop = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (toTop) {\n        this.moveToTop(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const upperShape = getUpperShape(selectedShape, intersections);\n        if (upperShape) {\n          this.exchangeShapeOrder(selectedShape, upperShape);\n          message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_FRONT_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  /**\n   * move selected shape to back\n   * @param toBottom\n   */\n  moveBack = (toBottom = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (toBottom) {\n        this.moveToBottom(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const underShape = getUnderShape(selectedShape, intersections);\n        if (underShape) {\n          this.exchangeShapeOrder(selectedShape, underShape);\n          message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_BACK_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  merge = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1\n    ) {\n      return;\n    }\n\n    const selectedShape = this.selectedShapes[0];\n    const { shapeType } = selectedShape;\n    if (shapeType === ShapeType.POLYGON) {\n      // merge polygon\n      const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape);\n      const intersectPolygonIds = (selectedShape as Polygon).findIntersectPolygons(shapes);\n      if (intersectPolygonIds.length === 1) {\n        this.mergePolygons(selectedShape.uid, intersectPolygonIds[0]);\n      } else if (intersectPolygonIds.length === 0) {\n        message.warn(i18n.translate('MERGE_NO_INTERSECT'));\n      } else {\n        this.pendingMergePolygon = selectedShape.uid;\n        message.info(i18n.translate('MERGE_SELECT_NEXT'));\n      }\n    }\n  };\n\n  mergePolygons(polygonId1: string, polygonId2: string) {\n    const { shape: polygon1, instanceItem: instance1 } = this.shapes[polygonId1];\n    const { shape: polygon2, instanceItem: instance2 } = this.shapes[polygonId2];\n    const mergedData = (polygon1 as Polygon).merge(polygon2 as Polygon);\n    if (mergedData.length === 1) {\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const { prevState, currState } = this.rootStore.instance.deleteInstanceItemByFrame(instance2, currentFrame);\n\n      const { prevState: prevStateItem, currState: currStateItem } = instance1.updateShape(\n        currentCamera,\n        currentFrame,\n        true,\n        ShapeType.POLYGON,\n        mergedData[0],\n        this.rootStore.frame.getNextShapeOrder(),\n      );\n\n      this.setupShape(instance1);\n      this.selectShapeByInstanceItem(instance1);\n      const basicInfo = instance1.instance.getBasicInfo();\n\n      this.rootStore.undo.push({\n        instances: [\n          ...prevState.instances,\n          ...prevStateItem ? [{ ...basicInfo, children: [prevStateItem] }] : [],\n        ],\n      }, {\n        instances: [\n          ...currState.instances,\n          ...currStateItem ? [{ ...basicInfo, children: [currStateItem] }] : [],\n        ],\n      });\n\n      message.success(i18n.translate('MERGE_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('MERGE_WITH_HOLE'));\n    }\n  }\n\n  subtractPolygon = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1 ||\n      this.selectedShapes[0].shapeType !== ShapeType.POLYGON\n    ) {\n      return;\n    }\n\n    const selectedPolygon = this.selectedShapes[0] as Polygon;\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape);\n    const intersectPolygons = selectedPolygon.findIntersectPolygons(shapes, true).map((i) => this.shapes[i].shape);\n    const subtractedData = selectedPolygon.subtract(intersectPolygons);\n\n    if (subtractedData && subtractedData.length > 0) {\n      this.updatePolygons(subtractedData[0][0], subtractedData.slice(1).map((d) => d[0]));\n      message.success(i18n.translate('SUBTRACT_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));\n    }\n  };\n\n  updatePolygons(currPolygonData: PolygonData, otherPolygonData: PolygonData[]) {\n    this.updateShapes(currPolygonData, otherPolygonData, ShapeType.POLYGON);\n  }\n\n  updateShapes(currShapeData: ShapeData, otherShapeData: ShapeData[], shapeType = ShapeType.POLYGON) {\n    const selectedShape = this.selectedShapes[0];\n    const { instanceItem: selectedInstanceItem } = this.shapes[selectedShape.uid];\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const attributes = selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n\n    const prevBasicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const { prevState: prevStateItem, currState: currStateItem } = selectedInstanceItem.updateShape(\n      currentCamera,\n      currentFrame,\n      true,\n      shapeType,\n      currShapeData,\n      this.rootStore.frame.getNextShapeOrder(),\n      attributes,\n    );\n\n    const basicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [basicInfo.id]: {\n        prev: { ...prevBasicInfo, children: prevStateItem ? [prevStateItem] : [] },\n        curr: { ...basicInfo, children: currStateItem ? [currStateItem] : [] }\n      }\n    };\n\n    this.setupShape(selectedInstanceItem);\n\n    for (let i = 0; i < otherShapeData.length; i += 1) {\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category, selectedInstanceItem.name);\n\n      const prevInfo = instanceItem.instance.getBasicInfo();\n      if (instanceItem.instance !== selectedInstanceItem.instance) {\n        instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);\n        const dynamicAttributesCurrentFrame = selectedInstanceItem.instance.dynamicAttributes?.[currentCamera]?.[currentFrame];\n        if (dynamicAttributesCurrentFrame && instanceItem.instance.categoryRef.labelConfigDynamic) {\n          instanceItem.instance.setDynamicAttributesByCamera(currentCamera, [dynamicAttributesCurrentFrame]);\n        }\n      }\n\n      const { prevState, currState } = instanceItem.updateShape(\n        currentCamera,\n        currentFrame,\n        true,\n        shapeType,\n        otherShapeData[i],\n        this.rootStore.frame.getNextShapeOrder(),\n        attributes,\n      );\n      this.setupShape(instanceItem);\n      const currInfo = instanceItem.instance.getBasicInfo();\n      if (!instanceState[currInfo.id]) {\n        instanceState[currInfo.id] = {\n          prev: { ...prevInfo, children: [] },\n          curr: { ...currInfo, children: [] }\n        };\n      }\n      const state = instanceState[currInfo.id];\n      if (prevState) {\n        state.prev.children.push(prevState);\n      }\n      if (currState) {\n        state.curr.children.push(currState);\n      }\n    }\n    this.selectShapeByInstanceItem(selectedInstanceItem);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev).filter((i) => i.children.length > 0)\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr)\n    });\n  }\n\n  updateConfig = ({ fill, alpha, showVertex, showVertexOrder }: {\n    fill?: boolean,\n    alpha?: number,\n    showVertex?: boolean,\n    showVertexOrder?: boolean,\n  }) => {\n    if (fill !== undefined) {\n      this.config.fill = fill;\n      this.updateShapesFill(fill);\n    }\n    if (alpha !== undefined) {\n      this.config.alpha = alpha;\n      this.updateShapesAlpha(alpha / 100);\n    }\n    if (showVertex !== undefined) {\n      this.config.showVertex = showVertex;\n      this.updateShowVertex(showVertex);\n    }\n    if (showVertexOrder !== undefined) {\n      this.config.showVertexOrder = showVertexOrder;\n      this.updateShowVertexOrder(showVertexOrder);\n    }\n  };\n\n  updateShapesFill = (fill: boolean) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.alpha = fill ? this.config.alpha / 100 : 0;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.alpha = fill ? this.config.alpha / 100 : 0;\n    });\n  };\n\n  updateShapesAlpha = (alpha: number) => {\n    if (this.config.fill) {\n      if (this.drawingShape) {\n        this.drawingShape.alpha = alpha;\n      }\n      Object.values(this.shapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n      Object.values(this.predictedShapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n    }\n  };\n\n  updateShowVertex = (showVertex: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertex = showVertex;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n  };\n\n  updateShowVertexOrder = (showVertexOrder: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertexOrder = showVertexOrder;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n  };\n\n  resetConfig = () => {\n    this.updateConfig({ ...this.defaultConfig });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}