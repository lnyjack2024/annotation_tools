{"ast":null,"code":"/*:: import type {Alignment, CellSize} from '../types';*/\nimport ScalingCellSizeAndPositionManager from './ScalingCellSizeAndPositionManager.js';\n\n/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\n/*:: type Params = {\n  // Width or height of cells for the current axis\n  cellSize?: CellSize,\n\n  // Manages size and position metadata of cells\n  cellSizeAndPositionManager: ScalingCellSizeAndPositionManager,\n\n  // Previous number of rows or columns\n  previousCellsCount: number,\n\n  // Previous width or height of cells\n  previousCellSize: CellSize,\n\n  previousScrollToAlignment: Alignment,\n\n  // Previous scroll-to-index\n  previousScrollToIndex: number,\n\n  // Previous width or height of the virtualized container\n  previousSize: number,\n\n  // Current scrollLeft or scrollTop\n  scrollOffset: number,\n\n  scrollToAlignment: Alignment,\n\n  // Scroll-to-index\n  scrollToIndex: number,\n\n  // Width or height of the virtualized container\n  size: number,\n\n  sizeJustIncreasedFromZero: boolean,\n\n  // Callback to invoke with an scroll-to-index value\n  updateScrollIndexCallback: (index: number) => void,\n};*/\nexport default function updateScrollIndexHelper(_ref /*:: */) {\n  var cellSize = _ref /*:: */.cellSize,\n    cellSizeAndPositionManager = _ref /*:: */.cellSizeAndPositionManager,\n    previousCellsCount = _ref /*:: */.previousCellsCount,\n    previousCellSize = _ref /*:: */.previousCellSize,\n    previousScrollToAlignment = _ref /*:: */.previousScrollToAlignment,\n    previousScrollToIndex = _ref /*:: */.previousScrollToIndex,\n    previousSize = _ref /*:: */.previousSize,\n    scrollOffset = _ref /*:: */.scrollOffset,\n    scrollToAlignment = _ref /*:: */.scrollToAlignment,\n    scrollToIndex = _ref /*:: */.scrollToIndex,\n    size = _ref /*:: */.size,\n    sizeJustIncreasedFromZero = _ref /*:: */.sizeJustIncreasedFromZero,\n    updateScrollIndexCallback = _ref /*:: */.updateScrollIndexCallback;\n  var cellCount = cellSizeAndPositionManager.getCellCount();\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;\n\n  // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex);\n\n    // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}","map":{"version":3,"names":["ScalingCellSizeAndPositionManager","updateScrollIndexHelper","_ref","cellSize","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToAlignment","scrollToIndex","size","sizeJustIncreasedFromZero","updateScrollIndexCallback","cellCount","getCellCount","hasScrollToIndex","sizeHasChanged","getTotalSize"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/react-virtualized/dist/es/Grid/utils/updateScrollIndexHelper.js"],"sourcesContent":["/*:: import type {Alignment, CellSize} from '../types';*/\nimport ScalingCellSizeAndPositionManager from './ScalingCellSizeAndPositionManager.js';\n\n/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\n/*:: type Params = {\n  // Width or height of cells for the current axis\n  cellSize?: CellSize,\n\n  // Manages size and position metadata of cells\n  cellSizeAndPositionManager: ScalingCellSizeAndPositionManager,\n\n  // Previous number of rows or columns\n  previousCellsCount: number,\n\n  // Previous width or height of cells\n  previousCellSize: CellSize,\n\n  previousScrollToAlignment: Alignment,\n\n  // Previous scroll-to-index\n  previousScrollToIndex: number,\n\n  // Previous width or height of the virtualized container\n  previousSize: number,\n\n  // Current scrollLeft or scrollTop\n  scrollOffset: number,\n\n  scrollToAlignment: Alignment,\n\n  // Scroll-to-index\n  scrollToIndex: number,\n\n  // Width or height of the virtualized container\n  size: number,\n\n  sizeJustIncreasedFromZero: boolean,\n\n  // Callback to invoke with an scroll-to-index value\n  updateScrollIndexCallback: (index: number) => void,\n};*/\nexport default function updateScrollIndexHelper(_ref /*:: */) {\n  var cellSize = _ref /*:: */.cellSize,\n    cellSizeAndPositionManager = _ref /*:: */.cellSizeAndPositionManager,\n    previousCellsCount = _ref /*:: */.previousCellsCount,\n    previousCellSize = _ref /*:: */.previousCellSize,\n    previousScrollToAlignment = _ref /*:: */.previousScrollToAlignment,\n    previousScrollToIndex = _ref /*:: */.previousScrollToIndex,\n    previousSize = _ref /*:: */.previousSize,\n    scrollOffset = _ref /*:: */.scrollOffset,\n    scrollToAlignment = _ref /*:: */.scrollToAlignment,\n    scrollToIndex = _ref /*:: */.scrollToIndex,\n    size = _ref /*:: */.size,\n    sizeJustIncreasedFromZero = _ref /*:: */.sizeJustIncreasedFromZero,\n    updateScrollIndexCallback = _ref /*:: */.updateScrollIndexCallback;\n  var cellCount = cellSizeAndPositionManager.getCellCount();\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;\n\n  // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex);\n\n    // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}"],"mappings":"AAAA;AACA,OAAOA,iCAAiC,MAAM,wCAAwC;;AAEtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,uBAAuBA,CAACC,IAAI,CAAC,SAAS;EAC5D,IAAIC,QAAQ,GAAGD,IAAI,CAAC,QAAQC,QAAQ;IAClCC,0BAA0B,GAAGF,IAAI,CAAC,QAAQE,0BAA0B;IACpEC,kBAAkB,GAAGH,IAAI,CAAC,QAAQG,kBAAkB;IACpDC,gBAAgB,GAAGJ,IAAI,CAAC,QAAQI,gBAAgB;IAChDC,yBAAyB,GAAGL,IAAI,CAAC,QAAQK,yBAAyB;IAClEC,qBAAqB,GAAGN,IAAI,CAAC,QAAQM,qBAAqB;IAC1DC,YAAY,GAAGP,IAAI,CAAC,QAAQO,YAAY;IACxCC,YAAY,GAAGR,IAAI,CAAC,QAAQQ,YAAY;IACxCC,iBAAiB,GAAGT,IAAI,CAAC,QAAQS,iBAAiB;IAClDC,aAAa,GAAGV,IAAI,CAAC,QAAQU,aAAa;IAC1CC,IAAI,GAAGX,IAAI,CAAC,QAAQW,IAAI;IACxBC,yBAAyB,GAAGZ,IAAI,CAAC,QAAQY,yBAAyB;IAClEC,yBAAyB,GAAGb,IAAI,CAAC,QAAQa,yBAAyB;EACpE,IAAIC,SAAS,GAAGZ,0BAA0B,CAACa,YAAY,CAAC,CAAC;EACzD,IAAIC,gBAAgB,GAAGN,aAAa,IAAI,CAAC,IAAIA,aAAa,GAAGI,SAAS;EACtE,IAAIG,cAAc,GAAGN,IAAI,KAAKJ,YAAY,IAAIK,yBAAyB,IAAI,CAACR,gBAAgB,IAAI,OAAOH,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAKG,gBAAgB;;EAE7J;EACA;EACA,IAAIY,gBAAgB,KAAKC,cAAc,IAAIR,iBAAiB,KAAKJ,yBAAyB,IAAIK,aAAa,KAAKJ,qBAAqB,CAAC,EAAE;IACtIO,yBAAyB,CAACH,aAAa,CAAC;;IAExC;IACA;EACF,CAAC,MAAM,IAAI,CAACM,gBAAgB,IAAIF,SAAS,GAAG,CAAC,KAAKH,IAAI,GAAGJ,YAAY,IAAIO,SAAS,GAAGX,kBAAkB,CAAC,EAAE;IACxG;IACA;IACA;IACA;IACA,IAAIK,YAAY,GAAGN,0BAA0B,CAACgB,YAAY,CAAC,CAAC,GAAGP,IAAI,EAAE;MACnEE,yBAAyB,CAACC,SAAS,GAAG,CAAC,CAAC;IAC1C;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module"}