{"ast":null,"code":"import{makeAutoObservable}from'mobx';import{v4 as uuidv4}from'uuid';import CameraData from'./CameraData';/**\n * instance item\n * @class\n */export default class InstanceItem{/**\n   * instance item name\n   * @getter\n   */get name(){return this.categoryItemRef.name;}/**\n   * instance item label\n   * @getter\n   */get label(){if(this.instance.isSingle){return this.instance.label;}return\"\".concat(this.instance.label,\"-\").concat(this.itemLabel);}/**\n   * instance item label only\n   * @getter\n   */get itemLabel(){let label=this.categoryItemRef.displayName;if(this.instance.isSingle){label=this.instance.categoryRef.displayName;}if(this.isSingle){return label;}return\"\".concat(label).concat(this.number);}/**\n   * instance item frame status (merged status)\n   * @getter\n   */get frameStatus(){// simple merge\nreturn Object.values(this.cameras).map(c=>c.frameStatus).reduce((acc,curr)=>({...acc,...curr}),{});}/**\n   * instance item existed camera names\n   * @getter\n   */get existedCameras(){return Object.keys(this.cameras).filter(cameraName=>!this.cameras[cameraName].isEmpty);}/**\n   * is instance item empty\n   * @getter\n   */get isEmpty(){return Object.values(this.cameras).every(camera=>camera.isEmpty);}/**\n   * is instance item only contains one shape\n   * @getter\n   */get isSingle(){return this.categoryItemRef.count===1;}constructor(_ref){let{id,instance,categoryItemRef,number,cameras=[]}=_ref;/**\n   * instance item id\n   * @member\n   */this.id=void 0;/**\n   * instance which belongs to\n   * @member\n   */this.instance=void 0;/**\n   * category item reference\n   * @member\n   */this.categoryItemRef=void 0;/**\n   * instance item number\n   * @member\n   */this.number=void 0;/**\n   * instance item camera data\n   * @member\n   */this.cameras={};/**\n   * is instance item selected\n   * @member\n   */this.selected=false;makeAutoObservable(this,{id:false,instance:false,categoryItemRef:false,isEmpty:false,isSingle:false},{autoBind:true});this.id=id||uuidv4();this.instance=instance;this.categoryItemRef=categoryItemRef;this.number=number;cameras.forEach(camera=>this.createCameraFromData(camera));}/**\n   * create camera from structured camera data\n   * @param cameraData\n   */createCameraFromData(cameraData){const camera=new CameraData({camera:cameraData.camera,frames:cameraData.frames,instanceItem:this,getNextShapeOrder:this.instance.getNextShapeOrder});this.cameras[camera.camera]=camera;}/**\n   * set selected\n   * @param selected\n   */setSelected(selected){this.selected=selected;}/**\n   * get camera\n   * @param camera\n   */getCamera(camera){if(!this.cameras[camera]){// create camera if not exist\nthis.createCameraFromData({camera,frames:[]});}return this.cameras[camera];}/**\n   * set attributes in frame\n   * @param camera\n   * @param frames\n   * @param attributes\n   */setAttributes(camera,frames,attributes){const cameraData=this.getCamera(camera);const{prevState,currState}=cameraData.setAttributes(frames,attributes);return this.formatChangedState(prevState?[prevState]:[],currState?[currState]:[]);}/**\n   * set attributes by frame\n   * @param camera\n   * @param frameAttributesMap\n   */setAttributesByFrame(camera,frameAttributesMap){const cameraData=this.getCamera(camera);const{prevState,currState}=cameraData.setAttributesByFrame(frameAttributesMap);return this.formatChangedState(prevState?[prevState]:[],currState?[currState]:[]);}/**\n   * add shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   */addShape(camera,frameIndex,interpolation,shapeType,shapeData,order){const cameraData=this.getCamera(camera);const{prevState,currState}=cameraData.addShape(frameIndex,interpolation,shapeType,shapeData,order);return this.formatChangedState(prevState?[prevState]:[],currState?[currState]:[]);}/**\n   * update shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */updateShape(camera,frameIndex,interpolation,shapeType,shapeData,order,attributes){const cameraData=this.getCamera(camera);const{prevState,currState}=cameraData.updateShape(frameIndex,interpolation,shapeType,shapeData,order,attributes);return this.formatChangedState(prevState?[prevState]:[],currState?[currState]:[]);}/**\n   * predict shape\n   * @param camera\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */predictShape(camera,frameIndex,imageBounds,useNearest){const cameraData=this.getCamera(camera);return cameraData.predictShape(frameIndex,imageBounds,useNearest);}/**\n   * remove from frames\n   * @param camera\n   * @param frames\n   */remove(camera,frames){const cameraData=this.getCamera(camera);const{prevState,currState}=cameraData.remove(frames);if(cameraData.isEmpty){// delete camera\ndelete this.cameras[camera];}return this.formatChangedState(prevState?[prevState]:[],currState?[currState]:[]);}/**\n   * update frames by frame data\n   * @param camera\n   * @param frames\n   */updateFramesFromData(camera,frames){const cameraData=this.getCamera(camera);const{prevState,currState}=cameraData.updateFramesFromData(frames);return this.formatChangedState(prevState?[prevState]:[],currState?[currState]:[]);}/**\n   * return structured data\n   */toJSON(){return{...this.getBasicInfo(),cameras:Object.values(this.cameras).filter(camera=>!camera.isEmpty).map(camera=>camera.toJSON())};}/**\n   * return basic info data\n   */getBasicInfo(){return{id:this.id,name:this.name,displayName:this.categoryItemRef.displayName,displayColor:this.categoryItemRef.displayColor,number:this.number};}/**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */formatChangedState(prevState,currState){const basicInfo=this.getBasicInfo();return{...(prevState.length>0&&{prevState:{...basicInfo,cameras:[...prevState]}}),...(currState.length>0&&{currState:{...basicInfo,cameras:[...currState]}})};}}","map":{"version":3,"names":["makeAutoObservable","v4","uuidv4","CameraData","InstanceItem","name","categoryItemRef","label","instance","isSingle","concat","itemLabel","displayName","categoryRef","number","frameStatus","Object","values","cameras","map","c","reduce","acc","curr","existedCameras","keys","filter","cameraName","isEmpty","every","camera","count","constructor","_ref","id","selected","autoBind","forEach","createCameraFromData","cameraData","frames","instanceItem","getNextShapeOrder","setSelected","getCamera","setAttributes","attributes","prevState","currState","formatChangedState","setAttributesByFrame","frameAttributesMap","addShape","frameIndex","interpolation","shapeType","shapeData","order","updateShape","predictShape","imageBounds","useNearest","remove","updateFramesFromData","toJSON","getBasicInfo","displayColor","basicInfo","length"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/model/InstanceItem.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport CameraData from './CameraData';\nimport Instance from './Instance';\nimport { CameraData as ICameraData, InstanceItem as IInstanceItem, FrameData as IFrameData, CategoryItem } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\n\ninterface InstanceItemOptions {\n  id?: string;\n  instance: Instance;\n  categoryItemRef: CategoryItem;\n  number: number;\n  cameras?: ICameraData[];\n}\n\ninterface ChangedState {\n  prevState?: IInstanceItem;\n  currState?: IInstanceItem;\n}\n\n/**\n * instance item\n * @class\n */\nexport default class InstanceItem {\n  /**\n   * instance item id\n   * @member\n   */\n  id: string;\n\n  /**\n   * instance which belongs to\n   * @member\n   */\n  instance: Instance;\n\n  /**\n   * category item reference\n   * @member\n   */\n  categoryItemRef: CategoryItem;\n\n  /**\n   * instance item number\n   * @member\n   */\n  number: number;\n\n  /**\n   * instance item camera data\n   * @member\n   */\n  cameras: { [camera: string]: CameraData } = {};\n\n  /**\n   * is instance item selected\n   * @member\n   */\n  selected = false;\n\n  /**\n   * instance item name\n   * @getter\n   */\n  get name() {\n    return this.categoryItemRef.name;\n  }\n\n  /**\n   * instance item label\n   * @getter\n   */\n  get label() {\n    if (this.instance.isSingle) {\n      return this.instance.label;\n    }\n    return `${this.instance.label}-${this.itemLabel}`;\n  }\n\n  /**\n   * instance item label only\n   * @getter\n   */\n  get itemLabel() {\n    let label = this.categoryItemRef.displayName;\n    if (this.instance.isSingle) {\n      label = this.instance.categoryRef.displayName;\n    }\n    if (this.isSingle) {\n      return label;\n    }\n    return `${label}${this.number}`;\n  }\n\n  /**\n   * instance item frame status (merged status)\n   * @getter\n   */\n  get frameStatus() {\n    // simple merge\n    return Object.values(this.cameras)\n      .map((c) => c.frameStatus)\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n  }\n\n  /**\n   * instance item existed camera names\n   * @getter\n   */\n  get existedCameras() {\n    return Object.keys(this.cameras).filter((cameraName) => !this.cameras[cameraName].isEmpty);\n  }\n\n  /**\n   * is instance item empty\n   * @getter\n   */\n  get isEmpty() {\n    return Object.values(this.cameras).every((camera) => camera.isEmpty);\n  }\n\n  /**\n   * is instance item only contains one shape\n   * @getter\n   */\n  get isSingle() {\n    return this.categoryItemRef.count === 1;\n  }\n\n  constructor({ id, instance, categoryItemRef, number, cameras = [] }: InstanceItemOptions) {\n    makeAutoObservable(this, {\n      id: false,\n      instance: false,\n      categoryItemRef: false,\n      isEmpty: false,\n      isSingle: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.id = id || uuidv4();\n    this.instance = instance;\n    this.categoryItemRef = categoryItemRef;\n    this.number = number;\n    cameras.forEach((camera) => this.createCameraFromData(camera));\n  }\n\n  /**\n   * create camera from structured camera data\n   * @param cameraData\n   */\n  createCameraFromData(cameraData: ICameraData) {\n    const camera = new CameraData({\n      camera: cameraData.camera,\n      frames: cameraData.frames,\n      instanceItem: this,\n      getNextShapeOrder: this.instance.getNextShapeOrder,\n    });\n    this.cameras[camera.camera] = camera;\n  }\n\n  /**\n   * set selected\n   * @param selected\n   */\n  setSelected(selected: boolean) {\n    this.selected = selected;\n  }\n\n  /**\n   * get camera\n   * @param camera\n   */\n  getCamera(camera: string) {\n    if (!this.cameras[camera]) {\n      // create camera if not exist\n      this.createCameraFromData({ camera, frames: [] });\n    }\n    return this.cameras[camera];\n  }\n\n  /**\n   * set attributes in frame\n   * @param camera\n   * @param frames\n   * @param attributes\n   */\n  setAttributes(camera: string, frames: number[], attributes: { attributes?: any }) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.setAttributes(frames, attributes);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * set attributes by frame\n   * @param camera\n   * @param frameAttributesMap\n   */\n  setAttributesByFrame(camera: string, frameAttributesMap: { [frameIndex: number]: { attributes?: any } }) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.setAttributesByFrame(frameAttributesMap);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * add shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   */\n  addShape(camera: string, frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number): ChangedState {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.addShape(frameIndex, interpolation, shapeType, shapeData, order);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * update shape in frame\n   * @param camera\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(camera: string, frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, attributes?: any) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.updateShape(frameIndex, interpolation, shapeType, shapeData, order, attributes);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * predict shape\n   * @param camera\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(camera: string, frameIndex: number, imageBounds?: { top: number; right: number; bottom: number; left: number }, useNearest?: boolean) {\n    const cameraData = this.getCamera(camera);\n    return cameraData.predictShape(frameIndex, imageBounds, useNearest);\n  }\n\n  /**\n   * remove from frames\n   * @param camera\n   * @param frames\n   */\n  remove(camera: string, frames: number[]) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.remove(frames);\n    if (cameraData.isEmpty) {\n      // delete camera\n      delete this.cameras[camera];\n    }\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * update frames by frame data\n   * @param camera\n   * @param frames\n   */\n  updateFramesFromData(camera: string, frames: IFrameData[]) {\n    const cameraData = this.getCamera(camera);\n    const { prevState, currState } = cameraData.updateFramesFromData(frames);\n    return this.formatChangedState(\n      prevState ? [prevState] : [],\n      currState ? [currState] : [],\n    );\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON(): IInstanceItem {\n    return {\n      ...this.getBasicInfo(),\n      cameras: Object.values(this.cameras)\n        .filter((camera) => !camera.isEmpty)\n        .map((camera) => camera.toJSON()),\n    };\n  }\n\n  /**\n   * return basic info data\n   */\n  getBasicInfo() {\n    return {\n      id: this.id,\n      name: this.name,\n      displayName: this.categoryItemRef.displayName,\n      displayColor: this.categoryItemRef.displayColor,\n      number: this.number,\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState: ICameraData[], currState: ICameraData[]): ChangedState {\n    const basicInfo = this.getBasicInfo();\n    return {\n      ...prevState.length > 0 && {\n        prevState: { ...basicInfo, cameras: [...prevState] },\n      },\n      ...currState.length > 0 && {\n        currState: { ...basicInfo, cameras: [...currState] },\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}