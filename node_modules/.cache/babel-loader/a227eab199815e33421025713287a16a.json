{"ast":null,"code":"import { Container } from 'pixi.js';\nimport polygonClipping from 'polygon-clipping';\nimport { ShapeType, ShapeVertexType } from './types';\nimport ShapeGraphics from './ShapeGraphics';\nimport { avgCircleDivider } from '../../../utils/math';\nexport function coverTest(shape, shapes) {\n  if (shapes.length <= 0) {\n    return false;\n  }\n  const {\n    left: cLeft,\n    top: cTop,\n    right: cRight,\n    bottom: cBottom\n  } = shape.instance.getLocalBounds();\n  const shapeBounds = shapes.map(s => s.instance.getLocalBounds());\n  const intersectedBounds = [];\n\n  // if cover any front shape, front shape should be selected, so skip\n  // const isCoverAnyShape = shapeBounds.some((bounds) => (\n  //   currentBounds.contains(bounds.x, bounds.y) &&\n  //   currentBounds.contains(bounds.x + bounds.width, bounds.y + bounds.height)\n  // ));\n  // if (isCoverAnyShape) {\n  //   return !isCoverAnyShape;\n  // }\n\n  // if covered by any front shape, should be selected\n  const isCoveredByAnyShape = shapeBounds.some(bounds => {\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = bounds;\n    const covered = cLeft >= left && cRight <= right && cTop >= top && cBottom <= bottom;\n    const intersected = cLeft <= right && cRight >= left && cTop <= bottom && cBottom >= top;\n    if (intersected) {\n      intersectedBounds.push(bounds);\n    }\n    return covered;\n  });\n  if (isCoveredByAnyShape) {\n    return isCoveredByAnyShape;\n  }\n\n  // if covered by front shapes bounding box, should be selected\n  if (intersectedBounds.length <= 0) {\n    return false;\n  }\n  let {\n    left,\n    top,\n    right,\n    bottom\n  } = intersectedBounds[0];\n  for (let i = 1; i < intersectedBounds.length; i += 1) {\n    const bounds = intersectedBounds[i];\n    if (left <= bounds.right && right >= bounds.left && top <= bounds.bottom && bottom >= bounds.top) {\n      left = Math.min(left, bounds.left);\n      top = Math.min(top, bounds.top);\n      right = Math.max(right, bounds.right);\n      bottom = Math.max(bottom, bounds.bottom);\n    }\n  }\n  return cLeft >= left && cTop >= top && cRight <= right && cBottom <= bottom;\n}\nexport function hitTesting(point, localPoint, rootChildren) {\n  const allShapes = [];\n  let snappingPoint = null;\n  const getIntersections = children => {\n    let shapes = [];\n    for (let i = 0; i < children.length; i += 1) {\n      const child = children[i];\n      if (child.visible) {\n        if (child instanceof ShapeGraphics) {\n          if (!snappingPoint && child.shape.finished && !child.shape.resizing && !child.shape.dragging) {\n            const sp = child.shape.snapToPoint(localPoint);\n            if (sp) {\n              snappingPoint = sp;\n            }\n          }\n          if (child.interactive && child.shape.finished) {\n            allShapes.push(child.shape);\n            if (child.shape.shapeType === ShapeType.LINE || child.shape.shapeType === ShapeType.ARROW) {\n              if (child.hitArea.contains(localPoint.x, localPoint.y)) {\n                shapes.push(child.shape);\n              }\n            } else if (child.shape.shapeType === ShapeType.RECTANGLE) {\n              if (child.hitArea ? child.hitArea.contains(localPoint.x, localPoint.y) : child.containsPoint(point)) {\n                shapes.push(child.shape);\n              }\n            } else if (child.containsPoint(point)) {\n              shapes.push(child.shape);\n            }\n          }\n        } else if (child instanceof Container) {\n          shapes = [...shapes, ...getIntersections(child.children)];\n        }\n      }\n    }\n    return shapes;\n  };\n  const intersections = getIntersections(rootChildren);\n  intersections.sort((a, b) => {\n    const abox = a.instance.getLocalBounds();\n    const bbox = b.instance.getLocalBounds();\n    return abox.width * abox.height - bbox.width * bbox.height;\n  }); // sort by area, small shapes have higher priority\n\n  let intersection;\n  for (let i = 0; i < intersections.length; i += 1) {\n    const curr = intersections[i];\n    const fronts = allShapes.filter(s => s.order > curr.order);\n    if (coverTest(curr, fronts)) {\n      // covered by front shapes\n      intersection = curr;\n      break;\n    }\n  }\n  return {\n    intersection: intersection || intersections[0],\n    snappingPoint\n  };\n}\nexport function findIntersections(currentShapeData, currentShapeBounds, currentShapeType, shapes) {\n  const intersections = [];\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    const {\n      shapeBounds\n    } = shape;\n    if (shapeBounds.left < currentShapeBounds.right && shapeBounds.right > currentShapeBounds.left && shapeBounds.top < currentShapeBounds.bottom && shapeBounds.bottom > currentShapeBounds.top) {\n      // bbox intersects\n      if (currentShapeType === ShapeType.DOT || shape.shapeType === ShapeType.DOT) {\n        // one of the shapes is dot\n        intersections.push(shape);\n      } else {\n        const shapeData = shape.getAreaAsGeoJSON();\n        const intersection = polygonClipping.intersection(currentShapeData, shapeData);\n        if (intersection.length > 0) {\n          intersections.push(shape);\n        }\n      }\n    }\n  }\n  return intersections;\n}\nexport function precise(num) {\n  return Math.round(num * 1000000) / 1000000;\n}\nexport function normalizePoints(points) {\n  const newPoints = [];\n  points.forEach((point, index) => {\n    const nextPoint = points[index === points.length - 1 ? 0 : index + 1];\n    const npx = precise(nextPoint[0]);\n    const npy = precise(nextPoint[1]);\n    const px = precise(point[0]);\n    const py = precise(point[1]);\n    if (px !== npx || py !== npy) {\n      newPoints.push({\n        x: px,\n        y: py\n      });\n    }\n  });\n  return newPoints;\n}\nexport function drawVertex(graphics, x, y, size, type = ShapeVertexType.DOT) {\n  switch (type) {\n    case ShapeVertexType.DOT:\n      graphics.drawCircle(x, y, size);\n      break;\n    case ShapeVertexType.TRIANGLE:\n      {\n        const r = size * 1.2;\n        drawRegularPolygon(graphics, x, y, r, 3);\n        break;\n      }\n    case ShapeVertexType.RECTANGLE:\n      {\n        const w = size * 0.9;\n        graphics.drawRect(x - w, y - w, w * 2, w * 2);\n        break;\n      }\n    case ShapeVertexType.TRAPEZOID:\n      {\n        const h = size * 0.9;\n        const d = size * 0.2;\n        const td = size - d;\n        const bd = size + d;\n        const p1 = [x - td, y - h];\n        const p2 = [x + td, y - h];\n        const p3 = [x + bd, y + h];\n        const p4 = [x - bd, y + h];\n        graphics.drawPolygon(...p1, ...p2, ...p3, ...p4);\n        break;\n      }\n    case ShapeVertexType.RHOMBUS:\n      {\n        const h = size * 1.2;\n        const p1 = [x, y - h];\n        const p2 = [x + size, y];\n        const p3 = [x, y + h];\n        const p4 = [x - size, y];\n        graphics.drawPolygon(...p1, ...p2, ...p3, ...p4);\n        break;\n      }\n    case ShapeVertexType.PENTAGON:\n      {\n        const r = size * 1.2;\n        drawRegularPolygon(graphics, x, y, r, 5);\n        break;\n      }\n    case ShapeVertexType.STAR:\n      {\n        const r = size * 1.4;\n        drawStar(graphics, x, y, 5, r);\n        break;\n      }\n    case ShapeVertexType.ASTERISK:\n      {\n        const r = size * 1.4;\n        const angle = Math.PI / 3;\n        const outerPoints1 = avgCircleDivider(x, y, r, 6, angle / 6);\n        const outerPoints2 = avgCircleDivider(x, y, r, 6, angle - angle / 6);\n        const innerPoints = avgCircleDivider(x, y, r / 3, 6, angle / 2);\n        const polygon = [];\n        for (let i = 0; i < 6; i += 1) {\n          polygon.push(outerPoints1[i].x, outerPoints1[i].y, innerPoints[i].x, innerPoints[i].y, outerPoints2[i].x, outerPoints2[i].y);\n        }\n        graphics.drawPolygon(polygon);\n        break;\n      }\n    default:\n      graphics.drawCircle(x, y, size);\n    // draw dot as default\n  }\n}\nexport function drawRegularPolygon(graphics, x, y, radius, sides, rotation = 0) {\n  const sidesNum = Math.max(sides, 3);\n  const startAngle = -(Math.PI / 2) + rotation;\n  const delta = Math.PI * 2 / sidesNum;\n  const polygon = [];\n  for (let i = 0; i < sidesNum; i += 1) {\n    const angle = i * delta + startAngle;\n    polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));\n  }\n  return graphics.drawPolygon(polygon);\n}\nexport function drawStar(graphics, x, y, points, radius, innerRadius, rotation = 0) {\n  const iRadius = innerRadius || radius / 2;\n  const startAngle = -(Math.PI / 2) + rotation;\n  const len = points * 2;\n  const delta = Math.PI * 2 / len;\n  const polygon = [];\n  for (let i = 0; i < len; i += 1) {\n    const r = i % 2 ? iRadius : radius;\n    const angle = i * delta + startAngle;\n    polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n  }\n  return graphics.drawPolygon(polygon);\n}","map":{"version":3,"names":["Container","polygonClipping","ShapeType","ShapeVertexType","ShapeGraphics","avgCircleDivider","coverTest","shape","shapes","length","left","cLeft","top","cTop","right","cRight","bottom","cBottom","instance","getLocalBounds","shapeBounds","map","s","intersectedBounds","isCoveredByAnyShape","some","bounds","covered","intersected","push","i","Math","min","max","hitTesting","point","localPoint","rootChildren","allShapes","snappingPoint","getIntersections","children","child","visible","finished","resizing","dragging","sp","snapToPoint","interactive","shapeType","LINE","ARROW","hitArea","contains","x","y","RECTANGLE","containsPoint","intersections","sort","a","b","abox","bbox","width","height","intersection","curr","fronts","filter","order","findIntersections","currentShapeData","currentShapeBounds","currentShapeType","DOT","shapeData","getAreaAsGeoJSON","precise","num","round","normalizePoints","points","newPoints","forEach","index","nextPoint","npx","npy","px","py","drawVertex","graphics","size","type","drawCircle","TRIANGLE","r","drawRegularPolygon","w","drawRect","TRAPEZOID","h","d","td","bd","p1","p2","p3","p4","drawPolygon","RHOMBUS","PENTAGON","STAR","drawStar","ASTERISK","angle","PI","outerPoints1","outerPoints2","innerPoints","polygon","radius","sides","rotation","sidesNum","startAngle","delta","cos","sin","innerRadius","iRadius","len"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/utils.ts"],"sourcesContent":["import { Container, DisplayObject, Graphics, Point, Rectangle } from 'pixi.js';\nimport polygonClipping, { Geom } from 'polygon-clipping';\nimport { ShapeType, ShapeData, ShapeVertexType } from './types';\nimport ShapeGraphics from './ShapeGraphics';\nimport type Shape from './Shape';\nimport { avgCircleDivider } from '../../../utils/math';\n\nexport function coverTest(shape: Shape<ShapeType>, shapes: Shape<ShapeType>[]) {\n  if (shapes.length <= 0) {\n    return false;\n  }\n  const { left: cLeft, top: cTop, right: cRight, bottom: cBottom } = shape.instance.getLocalBounds();\n  const shapeBounds = shapes.map((s) => s.instance.getLocalBounds());\n  const intersectedBounds: Rectangle[] = [];\n\n  // if cover any front shape, front shape should be selected, so skip\n  // const isCoverAnyShape = shapeBounds.some((bounds) => (\n  //   currentBounds.contains(bounds.x, bounds.y) &&\n  //   currentBounds.contains(bounds.x + bounds.width, bounds.y + bounds.height)\n  // ));\n  // if (isCoverAnyShape) {\n  //   return !isCoverAnyShape;\n  // }\n\n  // if covered by any front shape, should be selected\n  const isCoveredByAnyShape = shapeBounds.some((bounds) => {\n    const { left, top, right, bottom } = bounds;\n    const covered = cLeft >= left && cRight <= right && cTop >= top && cBottom <= bottom;\n    const intersected = cLeft <= right && cRight >= left && cTop <= bottom && cBottom >= top;\n    if (intersected) {\n      intersectedBounds.push(bounds);\n    }\n    return covered;\n  });\n  if (isCoveredByAnyShape) {\n    return isCoveredByAnyShape;\n  }\n\n  // if covered by front shapes bounding box, should be selected\n  if (intersectedBounds.length <= 0) {\n    return false;\n  }\n  let { left, top, right, bottom } = intersectedBounds[0];\n  for (let i = 1; i < intersectedBounds.length; i += 1) {\n    const bounds = intersectedBounds[i];\n    if (left <= bounds.right && right >= bounds.left && top <= bounds.bottom && bottom >= bounds.top) {\n      left = Math.min(left, bounds.left);\n      top = Math.min(top, bounds.top);\n      right = Math.max(right, bounds.right);\n      bottom = Math.max(bottom, bounds.bottom);\n    }\n  }\n  return cLeft >= left && cTop >= top && cRight <= right && cBottom <= bottom;\n}\n\nexport function hitTesting(point: Point, localPoint: Point, rootChildren: DisplayObject[]) {\n  const allShapes: Shape<ShapeType>[] = [];\n  let snappingPoint: Point | null = null;\n\n  const getIntersections = (children: DisplayObject[]) => {\n    let shapes: Shape<ShapeType>[] = [];\n    for (let i = 0; i < children.length; i += 1) {\n      const child = children[i];\n      if (child.visible) {\n        if (child instanceof ShapeGraphics) {\n          if (!snappingPoint && child.shape.finished && !child.shape.resizing && !child.shape.dragging) {\n            const sp = child.shape.snapToPoint(localPoint);\n            if (sp) {\n              snappingPoint = sp;\n            }\n          }\n          if (child.interactive && child.shape.finished) {\n            allShapes.push(child.shape);\n            if (child.shape.shapeType === ShapeType.LINE || child.shape.shapeType === ShapeType.ARROW) {\n              if (child.hitArea.contains(localPoint.x, localPoint.y)) {\n                shapes.push(child.shape);\n              }\n            } else if (child.shape.shapeType === ShapeType.RECTANGLE) {\n              if (child.hitArea ? child.hitArea.contains(localPoint.x, localPoint.y) : child.containsPoint(point)) {\n                shapes.push(child.shape);\n              }\n            } else if (child.containsPoint(point)) {\n              shapes.push(child.shape);\n            }\n          }\n        } else if (child instanceof Container) {\n          shapes = [...shapes, ...getIntersections(child.children)];\n        }\n      }\n    }\n    return shapes;\n  };\n  const intersections = getIntersections(rootChildren);\n  intersections.sort((a, b) => {\n    const abox = a.instance.getLocalBounds();\n    const bbox = b.instance.getLocalBounds();\n    return abox.width * abox.height - bbox.width * bbox.height;\n  }); // sort by area, small shapes have higher priority\n\n  let intersection;\n  for (let i = 0; i < intersections.length; i += 1) {\n    const curr = intersections[i];\n    const fronts = allShapes.filter((s) => s.order > curr.order);\n    if (coverTest(curr, fronts)) {\n      // covered by front shapes\n      intersection = curr;\n      break;\n    }\n  }\n\n  return {\n    intersection: intersection || intersections[0],\n    snappingPoint,\n  };\n}\n\nexport function findIntersections(\n  currentShapeData: Geom,\n  currentShapeBounds: { left: number, top: number, right: number, bottom: number },\n  currentShapeType: ShapeType,\n  shapes: Shape<ShapeData>[],\n): Shape<ShapeData>[] {\n  const intersections: Shape<ShapeData>[] = [];\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    const { shapeBounds } = shape;\n    if (\n      shapeBounds.left < currentShapeBounds.right &&\n      shapeBounds.right > currentShapeBounds.left &&\n      shapeBounds.top < currentShapeBounds.bottom &&\n      shapeBounds.bottom > currentShapeBounds.top\n    ) {\n      // bbox intersects\n      if (currentShapeType === ShapeType.DOT || shape.shapeType === ShapeType.DOT) {\n        // one of the shapes is dot\n        intersections.push(shape);\n      } else {\n        const shapeData = shape.getAreaAsGeoJSON();\n        const intersection = polygonClipping.intersection(currentShapeData, shapeData);\n        if (intersection.length > 0) {\n          intersections.push(shape);\n        }\n      }\n    }\n  }\n  return intersections;\n}\n\nexport function precise(num: number) {\n  return Math.round(num * 1000000) / 1000000;\n}\n\nexport function normalizePoints(points: [number, number][]) {\n  const newPoints: { x: number; y: number }[] = [];\n  points.forEach((point, index) => {\n    const nextPoint = points[index === points.length - 1 ? 0 : index + 1];\n    const npx = precise(nextPoint[0]);\n    const npy = precise(nextPoint[1]);\n    const px = precise(point[0]);\n    const py = precise(point[1]);\n    if (px !== npx || py !== npy) {\n      newPoints.push({ x: px, y: py });\n    }\n  });\n  return newPoints;\n}\n\nexport function drawVertex(graphics: Graphics, x: number, y: number, size: number, type = ShapeVertexType.DOT) {\n  switch (type) {\n    case ShapeVertexType.DOT:\n      graphics.drawCircle(x, y, size);\n      break;\n    case ShapeVertexType.TRIANGLE: {\n      const r = size * 1.2;\n      drawRegularPolygon(graphics, x, y, r, 3);\n      break;\n    }\n    case ShapeVertexType.RECTANGLE: {\n      const w = size * 0.9;\n      graphics.drawRect(x - w, y - w, w * 2, w * 2);\n      break;\n    }\n    case ShapeVertexType.TRAPEZOID: {\n      const h = size * 0.9;\n      const d = size * 0.2;\n      const td = size - d;\n      const bd = size + d;\n      const p1 = [x - td, y - h];\n      const p2 = [x + td, y - h];\n      const p3 = [x + bd, y + h];\n      const p4 = [x - bd, y + h];\n      graphics.drawPolygon(...p1, ...p2, ...p3, ...p4);\n      break;\n    }\n    case ShapeVertexType.RHOMBUS: {\n      const h = size * 1.2;\n      const p1 = [x, y - h];\n      const p2 = [x + size, y];\n      const p3 = [x, y + h];\n      const p4 = [x - size, y];\n      graphics.drawPolygon(...p1, ...p2, ...p3, ...p4);\n      break;\n    }\n    case ShapeVertexType.PENTAGON: {\n      const r = size * 1.2;\n      drawRegularPolygon(graphics, x, y, r, 5);\n      break;\n    }\n    case ShapeVertexType.STAR: {\n      const r = size * 1.4;\n      drawStar(graphics, x, y, 5, r);\n      break;\n    }\n    case ShapeVertexType.ASTERISK: {\n      const r = size * 1.4;\n      const angle = Math.PI / 3;\n      const outerPoints1 = avgCircleDivider(x, y, r, 6, angle / 6);\n      const outerPoints2 = avgCircleDivider(x, y, r, 6, angle - angle / 6);\n      const innerPoints = avgCircleDivider(x, y, r / 3, 6, angle / 2);\n      const polygon = [];\n      for (let i = 0; i < 6; i += 1) {\n        polygon.push(\n          outerPoints1[i].x,\n          outerPoints1[i].y,\n          innerPoints[i].x,\n          innerPoints[i].y,\n          outerPoints2[i].x,\n          outerPoints2[i].y,\n        );\n      }\n      graphics.drawPolygon(polygon);\n      break;\n    }\n    default:\n      graphics.drawCircle(x, y, size); // draw dot as default\n  }\n}\n\nexport function drawRegularPolygon(graphics: Graphics, x: number, y: number, radius: number, sides: number, rotation = 0): Graphics {\n  const sidesNum = Math.max(sides, 3);\n\n  const startAngle = -(Math.PI / 2) + rotation;\n  const delta = (Math.PI * 2) / sidesNum;\n  const polygon = [];\n\n  for (let i = 0; i < sidesNum; i += 1) {\n    const angle = (i * delta) + startAngle;\n    polygon.push(\n      x + radius * Math.cos(angle),\n      y + radius * Math.sin(angle),\n    );\n  }\n  return graphics.drawPolygon(polygon);\n}\n\nexport function drawStar(graphics: Graphics, x: number, y: number, points: number, radius: number, innerRadius?: number, rotation = 0): Graphics {\n  const iRadius = innerRadius || radius / 2;\n\n  const startAngle = -(Math.PI / 2) + rotation;\n  const len = points * 2;\n  const delta = (Math.PI * 2) / len;\n  const polygon = [];\n\n  for (let i = 0; i < len; i += 1) {\n    const r = i % 2 ? iRadius : radius;\n    const angle = (i * delta) + startAngle;\n    polygon.push(\n      x + r * Math.cos(angle),\n      y + r * Math.sin(angle),\n    );\n  }\n  return graphics.drawPolygon(polygon);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}