{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport { getNextKeyFrames, getShapeTypeByTool, preciseShapeByType } from '../utils';\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map = {};\n    Object.values(this.instances).forEach(instance => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({\n      className\n    }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.number - b.number);\n      }\n    });\n    return map;\n  }\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    const {\n      categories\n    } = this.rootStore.ontology;\n    return Object.values(this.instances).sort((a, b) => {\n      const instanceAFirstFrame = Number(Object.keys(a.frameStatus)[0]);\n      const instanceBFirstFrame = Number(Object.keys(b.frameStatus)[0]);\n      if (instanceAFirstFrame > instanceBFirstFrame) {\n        return 1;\n      }\n      if (instanceAFirstFrame < instanceBFirstFrame) {\n        return -1;\n      }\n      const instanceACategoryIndex = categories.findIndex(c => c.className === a.category);\n      const instanceBCategoryIndex = categories.findIndex(c => c.className === b.category);\n      if (instanceACategoryIndex > instanceBCategoryIndex) {\n        return 1;\n      }\n      if (instanceACategoryIndex < instanceBCategoryIndex) {\n        return -1;\n      }\n      return a.number > b.number ? 1 : -1;\n    });\n  }\n\n  /**\n   * multiple instance item selected\n   * @getter\n   */\n  get isMultiSelected() {\n    return this.selectedInstances.length > 1 || this.selectedInstanceItems.length > 1;\n  }\n\n  /**\n   * single instance item selected\n   */\n  get isSingleSelected() {\n    return this.selectedInstances.length === 1 && this.selectedInstanceItems.length === 1;\n  }\n\n  /**\n   * does selected instance has label config to set attributes\n   * @getter\n   */\n  get selectedInstanceAttributesEnabled() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return false;\n    }\n    const selectedInstance = this.selectedInstances[0];\n    const selectedInstanceItem = this.selectedInstanceItems.length === 1 ? this.selectedInstanceItems[0] : undefined;\n    return this.isAttributesEnabled(selectedInstance, selectedInstanceItem);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * all instances\n     */\n    this.instances = {};\n    /**\n     * selected instances\n     */\n    this.selectedInstances = [];\n    /**\n     * selected instance items\n     */\n    this.selectedInstanceItems = [];\n    /**\n     * delete frames from instance item\n     * @param instanceItem\n     * @param frames\n     * @param camera\n     */\n    this.deleteFramesFromInstanceItem = (instanceItem, frames, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      if (camera === currentCamera && frames.includes(currentFrame)) {\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      }\n      // remove relationship\n      const {\n        prevRelationships,\n        currRelationships\n      } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, frames);\n      const {\n        prevState,\n        currState\n      } = instanceItem.remove(camera, frames);\n      const basicInfo = instanceItem.instance.getBasicInfo();\n      this.rootStore.undo.push({\n        instances: prevState ? [{\n          ...basicInfo,\n          children: [prevState]\n        }] : [],\n        relationships: [...prevRelationships]\n      }, {\n        instances: currState ? [{\n          ...basicInfo,\n          children: [currState]\n        }] : [],\n        relationships: [...currRelationships]\n      });\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instanceItem.instance.isEmpty) {\n        this.deleteInstance(instanceItem.instance);\n      }\n    };\n    /**\n     * delete frames from instance items\n     * @param instanceItems\n     */\n    this.deleteFramesFromInstanceItems = instanceItems => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const prevInstanceMap = {};\n      const currInstanceMap = {};\n      const prevRelationshipMap = {};\n      const currRelationshipMap = {};\n      for (let i = 0; i < instanceItems.length; i += 1) {\n        const {\n          instanceItem,\n          frames,\n          camera = currentCamera\n        } = instanceItems[i];\n        const {\n          instance\n        } = instanceItem;\n        const {\n          id: instanceId\n        } = instance;\n        if (camera === currentCamera && frames.includes(currentFrame)) {\n          // remove shape\n          this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        }\n        // remove relationship\n        const {\n          prevRelationships,\n          currRelationships\n        } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, frames);\n        prevRelationships.forEach(r => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currRelationships.forEach(r => {\n          currRelationshipMap[r.id] = r;\n        });\n        const {\n          prevState,\n          currState\n        } = instanceItem.remove(camera, frames);\n        if (prevState) {\n          if (!prevInstanceMap[instanceId]) {\n            prevInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instance.isEmpty) {\n          this.deleteInstance(instance);\n        }\n      }\n      this.rootStore.undo.push({\n        instances: Object.values(prevInstanceMap),\n        relationships: Object.values(prevRelationshipMap)\n      }, {\n        instances: Object.values(currInstanceMap),\n        relationships: Object.values(currRelationshipMap)\n      });\n    };\n    this.deleteInstanceItemByFrame = (instanceItem, frame, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      if (camera === currentCamera && frame === currentFrame) {\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      }\n      // remove relationship\n      const {\n        prevRelationships,\n        currRelationships\n      } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [currentFrame]);\n      const {\n        prevState,\n        currState\n      } = instanceItem.remove(camera, [frame]);\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instanceItem.instance.isEmpty) {\n        this.deleteInstance(instanceItem.instance);\n      }\n      const basicInfo = instanceItem.instance.getBasicInfo();\n      return {\n        prevState: {\n          instances: prevState ? [{\n            ...basicInfo,\n            children: [prevState]\n          }] : [],\n          relationships: [...prevRelationships]\n        },\n        currState: {\n          instances: currState ? [{\n            ...basicInfo,\n            children: [currState]\n          }] : [],\n          relationships: [...currRelationships]\n        }\n      };\n    };\n    /**\n     * delete frames from instance item by type\n     * @param instanceItem\n     * @param type\n     * @param camera\n     */\n    this.deleteFramesFromInstanceItemByType = (instanceItem, type = 'current', camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentFrame\n      } = this.rootStore.frame;\n      switch (type) {\n        case 'current':\n          this.deleteFramesFromInstanceItem(instanceItem, [currentFrame]);\n          break;\n        case 'key':\n          {\n            const nextKeyFrames = getNextKeyFrames(1, currentFrame, instanceItem.cameras[camera].frames);\n            const nextKeyFrame = nextKeyFrames[0];\n            if (nextKeyFrame) {\n              this.deleteFramesFromInstanceItem(instanceItem, Array.from({\n                length: nextKeyFrame - currentFrame\n              }).map((_, index) => currentFrame + index));\n            }\n            break;\n          }\n        case 'following':\n          {\n            const allFrames = Object.keys(instanceItem.cameras[camera].frames).map(f => parseInt(f, 10));\n            const index = allFrames.indexOf(currentFrame);\n            this.deleteFramesFromInstanceItem(instanceItem, allFrames.slice(index, allFrames.length));\n            break;\n          }\n        case 'all':\n          {\n            const allFrames = Object.keys(instanceItem.cameras[camera].frames).map(f => parseInt(f, 10));\n            this.deleteFramesFromInstanceItem(instanceItem, allFrames);\n            break;\n          }\n        default:\n      }\n    };\n    makeAutoObservable(this, {\n      rootStore: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(instances) {\n    const {\n      getCategory\n    } = this.rootStore.ontology;\n    const {\n      cameraNames,\n      updateNextShapeOrder\n    } = this.rootStore.frame;\n    instances.forEach(instance => {\n      const category = getCategory(instance.category);\n      if (category) {\n        instance.children.forEach(instanceItem => {\n          const categoryItem = category.children.find(c => c.name === instanceItem.name);\n          if (categoryItem) {\n            instanceItem.cameras.forEach(cameraData => {\n              if (cameraNames.includes(cameraData.camera)) {\n                cameraData.frames.forEach(frameData => {\n                  // fix shape data precision\n                  preciseShapeByType(frameData.shapeType, frameData.shape);\n                  // update next shape order\n                  if (frameData.order !== undefined) {\n                    updateNextShapeOrder(frameData.order, frameData.frameIndex, cameraData.camera);\n                  }\n                });\n              } else {\n                cameraData.frames = [];\n              }\n            });\n            instanceItem.cameras = instanceItem.cameras.filter(c => c.frames.length > 0); // remove invalid camera data\n          } else {\n            instanceItem.cameras = [];\n          }\n        });\n        instance.children = instance.children.filter(i => i.cameras.length > 0); // remove invalid instance item data\n        if (instance.children.length > 0) {\n          this.createInstanceFromData(instance);\n        }\n      }\n    });\n  }\n\n  /**\n   * create instance from structured instance data\n   * @param instance\n   */\n  createInstanceFromData(instance) {\n    const category = this.rootStore.ontology.getCategory(instance.category);\n    if (category) {\n      const newInstance = new Instance({\n        id: instance.id,\n        categoryRef: category,\n        number: instance.number,\n        attributes: instance.attributes,\n        items: instance.children\n      });\n      this.instances[newInstance.id] = newInstance;\n    }\n  }\n\n  /**\n   * is instance attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceAttributesEnabled(instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfig;\n  }\n\n  /**\n   * is instance item attributes enabled\n   * @param instanceItem\n   */\n  isInstanceItemAttributesEnabled(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        if (frameData.isOCR || frameData.isFormula) {\n          // instance item currently is ocr shape or formula shape\n          return true;\n        }\n        if (instanceItem.categoryItemRef.labelConfig) {\n          // instance item has label config setting\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * is instance & instance item attributes enabled\n   * @param instance\n   * @param instanceItem\n   */\n  isAttributesEnabled(instance, instanceItem) {\n    const instanceAttributesEnabled = this.isInstanceAttributesEnabled(instance);\n    if (instanceAttributesEnabled) {\n      return true;\n    }\n    if (instanceItem) {\n      return this.isInstanceItemAttributesEnabled(instanceItem);\n    }\n    return Object.values(instance.items).some(item => this.isInstanceItemAttributesEnabled(item));\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * get next instance number\n   * @param categoryName\n   */\n  getNextInstanceNumber(categoryName) {\n    const categoryInstanceNumbers = (this.categoryInstancesMap[categoryName] || []).map(i => i.number);\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * get next instance item number\n   * @param instanceId\n   * @param categoryItemName\n   * @param camera\n   */\n  getNextInstanceItemNumber(instanceId, categoryItemName, camera = this.rootStore.frame.currentCamera) {\n    const instance = this.instances[instanceId];\n    const items = Object.values(instance.items).filter(i => i.name === categoryItemName);\n    const itemsInCamera = items.filter(i => {\n      const cameraData = i.cameras[camera];\n      return cameraData && !cameraData.isEmpty;\n    });\n    const itemNumbers = itemsInCamera.map(i => i.number);\n    return Math.max(...itemNumbers, 0) + 1;\n  }\n\n  /**\n   * update selected instance\n   * @param instance\n   */\n  updateSelectedInstance(instance) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances.forEach(i => {\n      if (instances.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstances = [...instances];\n    this.selectedInstances.forEach(i => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * update selected instance item\n   * @param instanceItem\n   */\n  updateSelectedInstanceItem(instanceItem) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems.forEach(i => {\n      if (instanceItems.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstanceItems = [...instanceItems];\n    this.selectedInstanceItems.forEach(i => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * select instance\n   * @param instance\n   * @param autoFocus\n   */\n  selectInstance(instance, autoFocus = false) {\n    const instances = Array.isArray(instance) ? instance : [...(instance ? [instance] : [])];\n    this.updateSelectedInstance(instances);\n    if (instances.length > 0) {\n      // select category if needed\n      const allCategories = instances.map(i => i.category);\n      if (allCategories.indexOf(this.rootStore.ontology.selectedCategoryName) < 0) {\n        this.rootStore.ontology.selectCategory(allCategories[0]);\n      }\n\n      // filter selected instance item\n      const instanceItems = this.selectedInstanceItems.filter(i => instances.indexOf(i.instance) >= 0);\n\n      // if the instance is single, default select first instance item\n      if (this.rootStore.frame.isSingleCamera) {\n        instances.forEach(i => {\n          if (i.isSingle && Object.keys(i.items).length > 0) {\n            const item = Object.values(i.items)[0];\n            if (instanceItems.indexOf(item) < 0) {\n              instanceItems.push(item);\n            }\n          }\n        });\n      }\n      this.updateSelectedInstanceItem(instanceItems);\n    } else {\n      this.updateSelectedInstanceItem([]);\n    }\n\n    // update shape selection\n    this.rootStore.shape.selectShapeByInstanceItem(this.selectedInstanceItems, autoFocus);\n    this.rootStore.shape.updateShapesInInstance(instances);\n  }\n\n  /**\n   * select instance item\n   * @param instanceItem\n   * @param autoFocus\n   */\n  selectInstanceItem(instanceItem, autoFocus = false) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...(instanceItem ? [instanceItem] : [])];\n    this.updateSelectedInstanceItem(instanceItems);\n    const instanceSet = new Set(instanceItems.map(i => i.instance));\n    const instances = Array.from(instanceSet);\n    this.selectInstance(instances, autoFocus);\n  }\n\n  /**\n   * get current editing instance item\n   */\n  getCurrentInstanceItem(currentCategoryName = this.rootStore.ontology.selectedCategoryName, currentCategoryItemName = this.rootStore.ontology.selectedCategoryItemName) {\n    const selectedInstance = this.selectedInstances.find(i => i.category === currentCategoryName) || this.selectedInstances[0];\n    if (selectedInstance && selectedInstance.category === currentCategoryName) {\n      const selectedInstanceItems = this.selectedInstanceItems.filter(i => i.instance === selectedInstance);\n      const selectedInstanceItem = selectedInstanceItems.find(i => i.name === currentCategoryItemName) || selectedInstanceItems[0];\n      if (selectedInstanceItem && selectedInstanceItem.name === currentCategoryItemName) {\n        // has selected instance item\n        const {\n          currentCamera,\n          currentFrame\n        } = this.rootStore.frame;\n        const {\n          frames\n        } = selectedInstanceItem.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          // not exist in current frame\n          return selectedInstanceItem;\n        }\n      }\n      const category = this.rootStore.ontology.getCategoryItem(currentCategoryName, currentCategoryItemName);\n      if (category) {\n        const {\n          currentCamera\n        } = this.rootStore.frame;\n        const {\n          name,\n          count,\n          maxCount = Infinity\n        } = category;\n        // find items exist in current camera\n        const items = selectedInstance.getItemsByName(name).filter(i => {\n          const cameraData = i.cameras[currentCamera];\n          return cameraData && !cameraData.isEmpty;\n        });\n        if (count !== undefined && items.length < count || count === undefined && items.length < maxCount) {\n          return this.createInstanceItem(selectedInstance, currentCategoryItemName);\n        }\n      }\n    }\n\n    // return a new instance\n    const instance = this.createInstance(currentCategoryName);\n    return this.createInstanceItem(instance, currentCategoryItemName);\n  }\n\n  /**\n   * get instance item for paste\n   * @param shapeType\n   */\n  getInstanceItemForPaste(shapeType) {\n    const {\n      selectedCategory\n    } = this.rootStore.ontology;\n    const supportedCategoryItems = [];\n    selectedCategory.children.forEach(item => {\n      const shapeTypes = new Set(item.tools.map(tool => getShapeTypeByTool(tool.type)));\n      if (shapeTypes.has(shapeType)) {\n        supportedCategoryItems.push(item);\n      }\n    });\n    if (supportedCategoryItems.length <= 0) {\n      // no avaliable category items\n      return null;\n    }\n    const supportedCategoryItemNames = supportedCategoryItems.map(i => i.name);\n    const selectedInstance = this.selectedInstances.find(i => i.category === selectedCategory.className);\n    if (selectedInstance) {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const supportedSelectedInstanceItems = this.selectedInstanceItems.filter(i => i.instance === selectedInstance && supportedCategoryItemNames.includes(i.name));\n      let instanceItem;\n      let i = 0;\n      while (!instanceItem && i < supportedSelectedInstanceItems.length) {\n        const item = supportedSelectedInstanceItems[i];\n        const {\n          frames\n        } = item.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          instanceItem = item;\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // find selected empty instance item\n      }\n      i = 0;\n      while (!instanceItem && i < supportedCategoryItems.length) {\n        const categoryItem = supportedCategoryItems[i];\n        const {\n          name,\n          count,\n          maxCount = Infinity\n        } = categoryItem;\n        const items = selectedInstance.getItemsByName(name);\n        if (count !== undefined && items.length < count || count === undefined && items.length < maxCount) {\n          instanceItem = this.createInstanceItem(selectedInstance, name);\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // new instance item\n      }\n    }\n    const instance = this.createInstance(selectedCategory.className);\n    return this.createInstanceItem(instance, supportedCategoryItemNames[0]);\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  createInstance(categoryName = this.rootStore.ontology.selectedCategory.className) {\n    const category = this.rootStore.ontology.getCategory(categoryName);\n    if (category) {\n      const instance = new Instance({\n        categoryRef: category,\n        number: this.getNextInstanceNumber(categoryName)\n      });\n      this.instances[instance.id] = instance;\n      return instance;\n    }\n    return undefined;\n  }\n\n  /**\n   * create instance item\n   * @param instance\n   * @param categoryItem\n   */\n  createInstanceItem(instance, categoryItem = this.rootStore.ontology.selectedCategoryItem.name) {\n    const number = this.getNextInstanceItemNumber(instance.id, categoryItem);\n    const existItem = instance.getItem(categoryItem, number);\n    if (existItem) {\n      return existItem;\n    }\n    // create\n    const {\n      children = []\n    } = instance.categoryRef;\n    const item = children.find(c => c.name === categoryItem);\n    const instanceItem = new InstanceItem({\n      instance,\n      categoryItemRef: item || children[0],\n      number\n    });\n    instance.items[instanceItem.id] = instanceItem;\n    return instanceItem;\n  }\n\n  /**\n   * delete instance\n   * @param instance\n   */\n  deleteInstance(instance) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances = this.selectedInstances.filter(i => instances.indexOf(i) < 0);\n    this.selectedInstanceItems = this.selectedInstanceItems.filter(i => instances.indexOf(i.instance) < 0);\n    instances.forEach(i => {\n      i.destroy();\n      delete this.instances[i.id];\n    });\n  }\n\n  /**\n   * delete instance item\n   * @param instanceItem\n   */\n  deleteInstanceItem(instanceItem) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems = this.selectedInstanceItems.filter(i => instanceItems.indexOf(i) < 0);\n    instanceItems.forEach(({\n      id,\n      instance\n    }) => {\n      instance.removeItem(id);\n    });\n  }\n  /**\n   * update frame shape info for instance item\n   * @param instanceItem\n   * @param frameIndex\n   * @param shapeType\n   * @param shape\n   * @param order\n   * @param camera\n   */\n  updateFrameShapeForInstanceItem(instanceItem, frameIndex, shapeType, shape, order, camera = this.rootStore.frame.currentCamera) {\n    const {\n      prevState,\n      currState\n    } = instanceItem.updateShape(camera, frameIndex, this.rootStore.config.autoInterpolation, shapeType, shape, order);\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    this.rootStore.undo.push({\n      instances: prevState ? [{\n        ...basicInfo,\n        children: [prevState]\n      }] : []\n    }, {\n      instances: currState ? [{\n        ...basicInfo,\n        children: [currState]\n      }] : []\n    });\n  }\n\n  /**\n   * update frame shape info for instance items list\n   * @param instanceItems\n   */\n  updateFrameShapeForInstanceItems(instanceItems) {\n    const prevInstanceMap = {};\n    const currInstanceMap = {};\n    const prevRelationshipMap = {};\n    const currRelationshipMap = {};\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const {\n        instanceItem,\n        frameIndex,\n        shapeType,\n        shape,\n        order,\n        camera = this.rootStore.frame.currentCamera\n      } = instanceItems[i];\n      let state;\n      if (shape) {\n        // update\n        state = instanceItem.updateShape(camera, frameIndex, this.rootStore.config.autoInterpolation, shapeType, shape, order);\n      } else {\n        // delete\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        // delete relationship\n        const {\n          prevRelationships,\n          currRelationships\n        } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [this.rootStore.frame.currentFrame]);\n        prevRelationships.forEach(r => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currRelationships.forEach(r => {\n          currRelationshipMap[r.id] = r;\n        });\n        state = instanceItem.remove(camera, [frameIndex]);\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instanceItem.instance.isEmpty) {\n          this.deleteInstance(instanceItem.instance);\n        }\n      }\n      if (state) {\n        const {\n          prevState,\n          currState\n        } = state;\n        const {\n          instance\n        } = instanceItem;\n        const {\n          id: instanceId\n        } = instance;\n        if (prevState) {\n          if (!prevInstanceMap[instanceId]) {\n            prevInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n      relationships: Object.values(prevRelationshipMap)\n    }, {\n      instances: Object.values(currInstanceMap),\n      relationships: Object.values(currRelationshipMap)\n    });\n  }\n\n  /**\n   * move instance item\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param targetInstanceId\n   * @param targetInstanceItemId\n   * @param frames\n   * @param newInstanceAttr\n   * @param newInstanceItemAttr\n   */\n  moveInstanceItem(targetCategory, targetCategoryItem, targetInstanceId, targetInstanceItemId, frames, newInstanceAttr, newInstanceItemAttr) {\n    if (!this.isSingleSelected) {\n      return;\n    }\n    const selectedInstanceItem = this.selectedInstanceItems[0];\n    const targetInstance = targetInstanceId === 'new' ? this.createInstance(targetCategory) : this.instances[targetInstanceId];\n    if (targetInstance) {\n      const targetInstanceItem = targetInstanceItemId === 'new' ? this.createInstanceItem(targetInstance, targetCategoryItem) : targetInstance.items[targetInstanceItemId];\n      if (targetInstanceItem) {\n        // FIXME: current only support single camera\n        const {\n          currentCamera\n        } = this.rootStore.frame;\n\n        // update target instance item\n        const currInstanceItem = selectedInstanceItem;\n        const framesData = frames.map(frameIndex => {\n          const frameJson = currInstanceItem.cameras[currentCamera].frames[frameIndex].toJSON();\n          if (targetCategory === currInstanceItem.instance.category && targetCategoryItem === currInstanceItem.name) {\n            return frameJson;\n          }\n          if (newInstanceItemAttr) {\n            frameJson.attributes = newInstanceItemAttr;\n          } else {\n            delete frameJson.attributes;\n          }\n          return frameJson;\n        });\n        const {\n          prevState: targetPrevState,\n          currState: targetCurrState\n        } = targetInstanceItem.updateFramesFromData(currentCamera, framesData);\n        const targetPrevInstance = targetInstance.getBasicInfo();\n        if (newInstanceAttr) {\n          targetInstance.setAttributes(newInstanceAttr);\n        }\n        const targetCurrInstance = targetInstance.getBasicInfo();\n\n        // remove from current instance item\n        const {\n          prevState,\n          currState\n        } = currInstanceItem.remove(currentCamera, frames);\n        if (currInstanceItem.isEmpty) {\n          this.deleteInstanceItem(currInstanceItem);\n        }\n        if (currInstanceItem.instance.isEmpty) {\n          this.deleteInstance(currInstanceItem.instance);\n        }\n\n        // update state\n        const basicInfo = currInstanceItem.instance.getBasicInfo();\n        if (currInstanceItem.instance.id === targetInstanceItem.instance.id) {\n          // same instance\n          const prevInstance = {\n            ...targetPrevInstance,\n            children: []\n          };\n          if (targetPrevState) {\n            prevInstance.children.push(targetPrevState);\n          }\n          if (prevState) {\n            prevInstance.children.push(prevState);\n          }\n          const currInstance = {\n            ...basicInfo,\n            children: []\n          };\n          if (targetCurrState) {\n            currInstance.children.push(targetCurrState);\n          }\n          if (currState) {\n            currInstance.children.push(currState);\n          }\n          this.rootStore.undo.push({\n            instances: prevInstance.children.length > 0 ? [prevInstance] : []\n          }, {\n            instances: currInstance.children.length > 0 ? [currInstance] : []\n          });\n        } else {\n          this.rootStore.undo.push({\n            instances: [...(prevState ? [{\n              ...basicInfo,\n              children: [prevState]\n            }] : []), ...(targetPrevState ? [{\n              ...targetPrevInstance,\n              children: [targetPrevState]\n            }] : [])]\n          }, {\n            instances: [...(currState ? [{\n              ...basicInfo,\n              children: [currState]\n            }] : []), ...(targetCurrState ? [{\n              ...targetCurrInstance,\n              children: [targetCurrState]\n            }] : [])]\n          });\n        }\n\n        // uppdate shapes\n        const currentShape = this.rootStore.shape.getShapeByInstanceItem(currInstanceItem);\n        if (currentShape) {\n          this.rootStore.shape.deleteShape(currentShape);\n        }\n        this.rootStore.shape.setupShape(targetInstanceItem);\n      }\n    }\n  }\n\n  /**\n   * open attributes modal automatically for selected instance\n   */\n  autoOpenAttributesModal() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return;\n    }\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const shouldOpen = instanceItem => {\n      var _instanceItem$cameras;\n      const frameData = (_instanceItem$cameras = instanceItem.cameras[currentCamera]) === null || _instanceItem$cameras === void 0 ? void 0 : _instanceItem$cameras.frames[currentFrame];\n      if ((frameData === null || frameData === void 0 ? void 0 : frameData.isOCR) && !(frameData === null || frameData === void 0 ? void 0 : frameData.OCRText)) {\n        this.rootStore.config.shouldSyncOCR = true;\n        return true;\n      }\n      if ((frameData === null || frameData === void 0 ? void 0 : frameData.isFormula) && !(frameData === null || frameData === void 0 ? void 0 : frameData.formulaText)) {\n        return true;\n      }\n      if (instanceItem.categoryItemRef.labelConfig && !(frameData === null || frameData === void 0 ? void 0 : frameData.attributes)) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n      return false;\n    };\n    if (this.selectedInstanceItems.length === 1) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const open = shouldOpen(selectedInstanceItem);\n      if (open) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return;\n      }\n    }\n    const selectedInstance = this.selectedInstances[0];\n    if (selectedInstance.categoryRef.labelConfig && !selectedInstance.attributes) {\n      this.rootStore.config.setAttributesModalVisible(true);\n      return;\n    }\n    if (this.selectedInstanceItems.length <= 0 && Object.values(selectedInstance.items).some(i => shouldOpen(i))) {\n      // no instance item selected\n      this.rootStore.config.setAttributesModalVisible(true);\n    }\n  }\n\n  /**\n   * get instances json data (for save)\n   */\n  instancesJSON() {\n    return Object.values(this.instances).map(instance => instance.toJSON());\n  }\n}","map":{"version":3,"names":["makeAutoObservable","Instance","InstanceItem","getNextKeyFrames","getShapeTypeByTool","preciseShapeByType","InstanceStore","categoryInstancesMap","map","Object","values","instances","forEach","instance","category","push","rootStore","ontology","categories","className","sort","a","b","number","allInstances","instanceAFirstFrame","Number","keys","frameStatus","instanceBFirstFrame","instanceACategoryIndex","findIndex","c","instanceBCategoryIndex","isMultiSelected","selectedInstances","length","selectedInstanceItems","isSingleSelected","selectedInstanceAttributesEnabled","selectedInstance","selectedInstanceItem","undefined","isAttributesEnabled","constructor","deleteFramesFromInstanceItem","instanceItem","frames","camera","frame","currentCamera","currentFrame","includes","shape","deleteShapeByInstanceItem","prevRelationships","currRelationships","relationship","deleteFromFramesByInstanceItem","prevState","currState","remove","basicInfo","getBasicInfo","undo","children","relationships","isEmpty","deleteInstanceItem","deleteInstance","deleteFramesFromInstanceItems","instanceItems","prevInstanceMap","currInstanceMap","prevRelationshipMap","currRelationshipMap","i","id","instanceId","r","deleteInstanceItemByFrame","deleteFramesFromInstanceItemByType","type","nextKeyFrames","cameras","nextKeyFrame","Array","from","_","index","allFrames","f","parseInt","indexOf","slice","autoBind","init","getCategory","cameraNames","updateNextShapeOrder","categoryItem","find","name","cameraData","frameData","shapeType","order","frameIndex","filter","createInstanceFromData","newInstance","categoryRef","attributes","items","isInstanceAttributesEnabled","labelConfig","isInstanceItemAttributesEnabled","isOCR","isFormula","categoryItemRef","instanceAttributesEnabled","some","item","getInstanceById","getNextInstanceNumber","categoryName","categoryInstanceNumbers","Math","max","getNextInstanceItemNumber","categoryItemName","itemsInCamera","itemNumbers","updateSelectedInstance","isArray","setSelected","updateSelectedInstanceItem","selectInstance","autoFocus","allCategories","selectedCategoryName","selectCategory","isSingleCamera","isSingle","selectShapeByInstanceItem","updateShapesInInstance","selectInstanceItem","instanceSet","Set","getCurrentInstanceItem","currentCategoryName","currentCategoryItemName","selectedCategoryItemName","getCategoryItem","count","maxCount","Infinity","getItemsByName","createInstanceItem","createInstance","getInstanceItemForPaste","selectedCategory","supportedCategoryItems","shapeTypes","tools","tool","has","supportedCategoryItemNames","supportedSelectedInstanceItems","selectedCategoryItem","existItem","getItem","destroy","removeItem","updateFrameShapeForInstanceItem","updateShape","config","autoInterpolation","updateFrameShapeForInstanceItems","state","moveInstanceItem","targetCategory","targetCategoryItem","targetInstanceId","targetInstanceItemId","newInstanceAttr","newInstanceItemAttr","targetInstance","targetInstanceItem","currInstanceItem","framesData","frameJson","toJSON","targetPrevState","targetCurrState","updateFramesFromData","targetPrevInstance","setAttributes","targetCurrInstance","prevInstance","currInstance","currentShape","getShapeByInstanceItem","deleteShape","setupShape","autoOpenAttributesModal","shouldOpen","_instanceItem$cameras","OCRText","shouldSyncOCR","formulaText","setAttributesModalVisible","open","instancesJSON"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/InstanceStore.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport { getNextKeyFrames, getShapeTypeByTool, preciseShapeByType } from '../utils';\nimport { Instance as IInstance, CategoryItem, Relationship as IRelationship } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\n\n/**\n * store for instances\n * @class\n */\nexport default class InstanceStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * all instances\n   */\n  instances: { [instanceId: string]: Instance } = {};\n\n  /**\n   * selected instances\n   */\n  selectedInstances: Instance[] = [];\n\n  /**\n   * selected instance items\n   */\n  selectedInstanceItems: InstanceItem[] = [];\n\n  /**\n   * category instances map\n   * @getter\n   */\n  get categoryInstancesMap() {\n    const map: { [categoryName: string]: Instance[] } = {};\n    Object.values(this.instances).forEach((instance) => {\n      if (!map[instance.category]) {\n        map[instance.category] = [];\n      }\n      map[instance.category].push(instance);\n    });\n    this.rootStore.ontology.categories.forEach(({ className }) => {\n      if (!map[className]) {\n        map[className] = [];\n      } else {\n        map[className].sort((a, b) => a.number - b.number);\n      }\n    });\n    return map;\n  };\n\n  /**\n   * all instances sorted by timeline\n   * @getter\n   */\n  get allInstances() {\n    const { categories } = this.rootStore.ontology;\n    return Object.values(this.instances)\n      .sort((a, b) => {\n        const instanceAFirstFrame = Number(Object.keys(a.frameStatus)[0]);\n        const instanceBFirstFrame = Number(Object.keys(b.frameStatus)[0]);\n        if (instanceAFirstFrame > instanceBFirstFrame) {\n          return 1;\n        }\n        if (instanceAFirstFrame < instanceBFirstFrame) {\n          return -1;\n        }\n        const instanceACategoryIndex = categories.findIndex((c) => c.className === a.category);\n        const instanceBCategoryIndex = categories.findIndex((c) => c.className === b.category);\n        if (instanceACategoryIndex > instanceBCategoryIndex) {\n          return 1;\n        }\n        if (instanceACategoryIndex < instanceBCategoryIndex) {\n          return -1;\n        }\n        return a.number > b.number ? 1 : -1;\n      });\n  }\n\n  /**\n   * multiple instance item selected\n   * @getter\n   */\n  get isMultiSelected() {\n    return this.selectedInstances.length > 1 || this.selectedInstanceItems.length > 1;\n  }\n\n  /**\n   * single instance item selected\n   */\n  get isSingleSelected() {\n    return this.selectedInstances.length === 1 && this.selectedInstanceItems.length === 1;\n  }\n\n  /**\n   * does selected instance has label config to set attributes\n   * @getter\n   */\n  get selectedInstanceAttributesEnabled() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return false;\n    }\n\n    const selectedInstance = this.selectedInstances[0];\n    const selectedInstanceItem = this.selectedInstanceItems.length === 1 ? this.selectedInstanceItems[0] : undefined;\n    return this.isAttributesEnabled(selectedInstance, selectedInstanceItem);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init instances\n   * @param instances\n   */\n  async init(instances: IInstance[]) {\n    const { getCategory } = this.rootStore.ontology;\n    const { cameraNames, updateNextShapeOrder } = this.rootStore.frame;\n    instances.forEach((instance) => {\n      const category = getCategory(instance.category);\n      if (category) {\n        instance.children.forEach((instanceItem) => {\n          const categoryItem = category.children.find((c) => c.name === instanceItem.name);\n          if (categoryItem) {\n            instanceItem.cameras.forEach((cameraData) => {\n              if (cameraNames.includes(cameraData.camera)) {\n                cameraData.frames.forEach((frameData) => {\n                  // fix shape data precision\n                  preciseShapeByType(frameData.shapeType, frameData.shape);\n                  // update next shape order\n                  if (frameData.order !== undefined) {\n                    updateNextShapeOrder(frameData.order, frameData.frameIndex, cameraData.camera);\n                  }\n                });\n              } else {\n                cameraData.frames = [];\n              }\n            });\n            instanceItem.cameras = instanceItem.cameras.filter((c) => c.frames.length > 0); // remove invalid camera data\n          } else {\n            instanceItem.cameras = [];\n          }\n        });\n        instance.children = instance.children.filter((i) => i.cameras.length > 0); // remove invalid instance item data\n        if (instance.children.length > 0) {\n          this.createInstanceFromData(instance);\n        }\n      }\n    });\n  }\n\n  /**\n   * create instance from structured instance data\n   * @param instance\n   */\n  createInstanceFromData(instance: IInstance) {\n    const category = this.rootStore.ontology.getCategory(instance.category);\n    if (category) {\n      const newInstance = new Instance({\n        id: instance.id,\n        categoryRef: category,\n        number: instance.number,\n        attributes: instance.attributes,\n        items: instance.children,\n      });\n      this.instances[newInstance.id] = newInstance;\n    }\n  }\n\n  /**\n   * is instance attributes enable\n   * @param instance\n   */\n  // eslint-disable-next-line class-methods-use-this\n  isInstanceAttributesEnabled(instance: Instance) {\n    // selected instance has label config setting\n    return !!instance.categoryRef.labelConfig;\n  }\n\n  /**\n   * is instance item attributes enabled\n   * @param instanceItem\n   */\n  isInstanceItemAttributesEnabled(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        if (frameData.isOCR || frameData.isFormula) {\n          // instance item currently is ocr shape or formula shape\n          return true;\n        }\n        if (instanceItem.categoryItemRef.labelConfig) {\n          // instance item has label config setting\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * is instance & instance item attributes enabled\n   * @param instance\n   * @param instanceItem\n   */\n  isAttributesEnabled(instance: Instance, instanceItem?: InstanceItem) {\n    const instanceAttributesEnabled = this.isInstanceAttributesEnabled(instance);\n    if (instanceAttributesEnabled) {\n      return true;\n    }\n    if (instanceItem) {\n      return this.isInstanceItemAttributesEnabled(instanceItem);\n    }\n    return Object.values(instance.items).some((item) => this.isInstanceItemAttributesEnabled(item));\n  }\n\n  /**\n   * get instance by id\n   * @param instanceId\n   */\n  getInstanceById(instanceId: string) {\n    return this.instances[instanceId];\n  }\n\n  /**\n   * get next instance number\n   * @param categoryName\n   */\n  getNextInstanceNumber(categoryName: string) {\n    const categoryInstanceNumbers = (this.categoryInstancesMap[categoryName] || []).map((i) => i.number);\n    return Math.max(...categoryInstanceNumbers, 0) + 1;\n  }\n\n  /**\n   * get next instance item number\n   * @param instanceId\n   * @param categoryItemName\n   * @param camera\n   */\n  getNextInstanceItemNumber(instanceId: string, categoryItemName: string, camera = this.rootStore.frame.currentCamera) {\n    const instance = this.instances[instanceId];\n    const items = Object.values(instance.items).filter((i) => i.name === categoryItemName);\n    const itemsInCamera = items.filter((i) => {\n      const cameraData = i.cameras[camera];\n      return cameraData && !cameraData.isEmpty;\n    });\n    const itemNumbers = itemsInCamera.map((i) => i.number);\n    return Math.max(...itemNumbers, 0) + 1;\n  }\n\n  /**\n   * update selected instance\n   * @param instance\n   */\n  updateSelectedInstance(instance: Instance | Instance[]) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances.forEach((i) => {\n      if (instances.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstances = [...instances];\n    this.selectedInstances.forEach((i) => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * update selected instance item\n   * @param instanceItem\n   */\n  updateSelectedInstanceItem(instanceItem: InstanceItem | InstanceItem[]) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems.forEach((i) => {\n      if (instanceItems.indexOf(i) < 0) {\n        i.setSelected(false);\n      }\n    });\n    this.selectedInstanceItems = [...instanceItems];\n    this.selectedInstanceItems.forEach((i) => {\n      i.setSelected(true);\n    });\n  }\n\n  /**\n   * select instance\n   * @param instance\n   * @param autoFocus\n   */\n  selectInstance(instance?: Instance | Instance[] | null, autoFocus = false) {\n    const instances = Array.isArray(instance) ? instance : [...instance ? [instance] : []];\n    this.updateSelectedInstance(instances);\n\n    if (instances.length > 0) {\n      // select category if needed\n      const allCategories = instances.map((i) => i.category);\n      if (allCategories.indexOf(this.rootStore.ontology.selectedCategoryName) < 0) {\n        this.rootStore.ontology.selectCategory(allCategories[0]);\n      }\n\n      // filter selected instance item\n      const instanceItems: InstanceItem[] = this.selectedInstanceItems.filter((i) => instances.indexOf(i.instance) >= 0);\n\n      // if the instance is single, default select first instance item\n      if (this.rootStore.frame.isSingleCamera) {\n        instances.forEach((i) => {\n          if (i.isSingle && Object.keys(i.items).length > 0) {\n            const item = Object.values(i.items)[0];\n            if (instanceItems.indexOf(item) < 0) {\n              instanceItems.push(item);\n            }\n          }\n        });\n      }\n      this.updateSelectedInstanceItem(instanceItems);\n    } else {\n      this.updateSelectedInstanceItem([]);\n    }\n\n    // update shape selection\n    this.rootStore.shape.selectShapeByInstanceItem(this.selectedInstanceItems, autoFocus);\n    this.rootStore.shape.updateShapesInInstance(instances);\n  }\n\n  /**\n   * select instance item\n   * @param instanceItem\n   * @param autoFocus\n   */\n  selectInstanceItem(instanceItem?: InstanceItem | InstanceItem[] | null, autoFocus = false) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...instanceItem ? [instanceItem] : []];\n    this.updateSelectedInstanceItem(instanceItems);\n    const instanceSet = new Set(instanceItems.map((i) => i.instance));\n    const instances = Array.from(instanceSet);\n    this.selectInstance(instances, autoFocus);\n  }\n\n  /**\n   * get current editing instance item\n   */\n  getCurrentInstanceItem(\n    currentCategoryName = this.rootStore.ontology.selectedCategoryName,\n    currentCategoryItemName = this.rootStore.ontology.selectedCategoryItemName\n  ) {\n    const selectedInstance = this.selectedInstances.find((i) => i.category === currentCategoryName) || this.selectedInstances[0];\n    if (selectedInstance && selectedInstance.category === currentCategoryName) {\n      const selectedInstanceItems = this.selectedInstanceItems.filter((i) => i.instance === selectedInstance);\n      const selectedInstanceItem = selectedInstanceItems.find((i) => i.name === currentCategoryItemName) || selectedInstanceItems[0];\n      if (selectedInstanceItem && selectedInstanceItem.name === currentCategoryItemName) {\n        // has selected instance item\n        const { currentCamera, currentFrame } = this.rootStore.frame;\n        const { frames } = selectedInstanceItem.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          // not exist in current frame\n          return selectedInstanceItem;\n        }\n      }\n\n      const category = this.rootStore.ontology.getCategoryItem(currentCategoryName, currentCategoryItemName);\n      if (category) {\n        const { currentCamera } = this.rootStore.frame;\n        const { name, count, maxCount = Infinity } = category;\n        // find items exist in current camera\n        const items = selectedInstance.getItemsByName(name).filter((i) => {\n          const cameraData = i.cameras[currentCamera];\n          return cameraData && !cameraData.isEmpty;\n        });\n        if ((count !== undefined && items.length < count) || (count === undefined && items.length < maxCount)) {\n          return this.createInstanceItem(selectedInstance, currentCategoryItemName);\n        }\n      }\n    }\n\n    // return a new instance\n    const instance = this.createInstance(currentCategoryName);\n    return this.createInstanceItem(instance!, currentCategoryItemName);\n  }\n\n  /**\n   * get instance item for paste\n   * @param shapeType\n   */\n  getInstanceItemForPaste(shapeType: ShapeType) {\n    const { selectedCategory } = this.rootStore.ontology;\n\n    const supportedCategoryItems: CategoryItem[] = [];\n    selectedCategory.children.forEach((item) => {\n      const shapeTypes = new Set(item.tools.map((tool) => getShapeTypeByTool(tool.type)));\n      if (shapeTypes.has(shapeType)) {\n        supportedCategoryItems.push(item);\n      }\n    });\n    if (supportedCategoryItems.length <= 0) {\n      // no avaliable category items\n      return null;\n    }\n\n    const supportedCategoryItemNames = supportedCategoryItems.map((i) => i.name);\n    const selectedInstance = this.selectedInstances.find((i) => i.category === selectedCategory.className);\n    if (selectedInstance) {\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const supportedSelectedInstanceItems = this.selectedInstanceItems.filter((i) => i.instance === selectedInstance && supportedCategoryItemNames.includes(i.name));\n\n      let instanceItem;\n      let i = 0;\n      while (!instanceItem && i < supportedSelectedInstanceItems.length) {\n        const item = supportedSelectedInstanceItems[i];\n        const { frames } = item.cameras[currentCamera];\n        if (!frames[currentFrame]) {\n          instanceItem = item;\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // find selected empty instance item\n      }\n\n      i = 0;\n      while (!instanceItem && i < supportedCategoryItems.length) {\n        const categoryItem = supportedCategoryItems[i];\n        const { name, count, maxCount = Infinity } = categoryItem;\n        const items = selectedInstance.getItemsByName(name);\n        if ((count !== undefined && items.length < count) || (count === undefined && items.length < maxCount)) {\n          instanceItem = this.createInstanceItem(selectedInstance, name);\n        }\n        i += 1;\n      }\n      if (instanceItem) {\n        return instanceItem; // new instance item\n      }\n    }\n\n    const instance = this.createInstance(selectedCategory.className);\n    return this.createInstanceItem(instance!, supportedCategoryItemNames[0]);\n  }\n\n  /**\n   * create instance\n   * @param categoryName\n   */\n  createInstance(categoryName = this.rootStore.ontology.selectedCategory.className) {\n    const category = this.rootStore.ontology.getCategory(categoryName);\n    if (category) {\n      const instance = new Instance({\n        categoryRef: category,\n        number: this.getNextInstanceNumber(categoryName),\n      });\n      this.instances[instance.id] = instance;\n      return instance;\n    }\n    return undefined;\n  }\n\n  /**\n   * create instance item\n   * @param instance\n   * @param categoryItem\n   */\n  createInstanceItem(instance: Instance, categoryItem = this.rootStore.ontology.selectedCategoryItem.name) {\n    const number = this.getNextInstanceItemNumber(instance.id, categoryItem);\n    const existItem = instance.getItem(categoryItem, number);\n    if (existItem) {\n      return existItem;\n    }\n    // create\n    const { children = [] } = instance.categoryRef;\n    const item = children.find((c) => c.name === categoryItem);\n    const instanceItem = new InstanceItem({\n      instance,\n      categoryItemRef: item || children[0],\n      number,\n    });\n    instance.items[instanceItem.id] = instanceItem;\n    return instanceItem;\n  }\n\n  /**\n   * delete instance\n   * @param instance\n   */\n  deleteInstance(instance: Instance | Instance[]) {\n    const instances = Array.isArray(instance) ? instance : [instance];\n    this.selectedInstances = this.selectedInstances.filter((i) => instances.indexOf(i) < 0);\n    this.selectedInstanceItems = this.selectedInstanceItems.filter((i) => instances.indexOf(i.instance) < 0);\n    instances.forEach((i) => {\n      i.destroy();\n      delete this.instances[i.id];\n    });\n  }\n\n  /**\n   * delete instance item\n   * @param instanceItem\n   */\n  deleteInstanceItem(instanceItem: InstanceItem | InstanceItem[]) {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [instanceItem];\n    this.selectedInstanceItems = this.selectedInstanceItems.filter((i) => instanceItems.indexOf(i) < 0);\n    instanceItems.forEach(({ id, instance }) => {\n      instance.removeItem(id);\n    });\n  }\n\n  /**\n   * delete frames from instance item\n   * @param instanceItem\n   * @param frames\n   * @param camera\n   */\n  deleteFramesFromInstanceItem = (\n    instanceItem: InstanceItem,\n    frames: number[],\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    if (camera === currentCamera && frames.includes(currentFrame)) {\n      // remove shape\n      this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n    }\n    // remove relationship\n    const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, frames);\n\n    const { prevState, currState } = instanceItem.remove(camera, frames);\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    this.rootStore.undo.push({\n      instances: prevState ? [{ ...basicInfo, children: [prevState] }] : [],\n      relationships: [...prevRelationships],\n    }, {\n      instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n      relationships: [...currRelationships],\n    });\n\n    if (instanceItem.isEmpty) {\n      this.deleteInstanceItem(instanceItem);\n    }\n    if (instanceItem.instance.isEmpty) {\n      this.deleteInstance(instanceItem.instance);\n    }\n  };\n\n  /**\n   * delete frames from instance items\n   * @param instanceItems\n   */\n  deleteFramesFromInstanceItems = (instanceItems: { instanceItem: InstanceItem, frames: number[], camera?: string }[]) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n    const prevRelationshipMap: { [id: string]: IRelationship } = {};\n    const currRelationshipMap: { [id: string]: IRelationship } = {};\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const { instanceItem, frames, camera = currentCamera } = instanceItems[i];\n      const { instance } = instanceItem;\n      const { id: instanceId } = instance;\n\n      if (camera === currentCamera && frames.includes(currentFrame)) {\n        // remove shape\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n      }\n      // remove relationship\n      const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, frames);\n      prevRelationships.forEach((r) => {\n        if (!prevRelationshipMap[r.id]) {\n          prevRelationshipMap[r.id] = r;\n        }\n      });\n      currRelationships.forEach((r) => {\n        currRelationshipMap[r.id] = r;\n      });\n\n      const { prevState, currState } = instanceItem.remove(camera, frames);\n      if (prevState) {\n        if (!prevInstanceMap[instanceId]) {\n          prevInstanceMap[instanceId] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        prevInstanceMap[instanceId].children.push(prevState);\n      }\n      if (currState) {\n        if (!currInstanceMap[instanceId]) {\n          currInstanceMap[instanceId] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        currInstanceMap[instanceId].children.push(currState);\n      }\n\n      if (instanceItem.isEmpty) {\n        this.deleteInstanceItem(instanceItem);\n      }\n      if (instance.isEmpty) {\n        this.deleteInstance(instance);\n      }\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n      relationships: Object.values(prevRelationshipMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n      relationships: Object.values(currRelationshipMap),\n    });\n  };\n\n  deleteInstanceItemByFrame = (\n    instanceItem: InstanceItem,\n    frame: number,\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    if (camera === currentCamera && frame === currentFrame) {\n      // remove shape\n      this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n    }\n    // remove relationship\n    const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [currentFrame]);\n\n    const { prevState, currState } = instanceItem.remove(camera, [frame]);\n\n    if (instanceItem.isEmpty) {\n      this.deleteInstanceItem(instanceItem);\n    }\n    if (instanceItem.instance.isEmpty) {\n      this.deleteInstance(instanceItem.instance);\n    }\n\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    return {\n      prevState: {\n        instances: prevState ? [{ ...basicInfo, children: [prevState] }] : [],\n        relationships: [...prevRelationships],\n      },\n      currState: {\n        instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n        relationships: [...currRelationships],\n      },\n    };\n  };\n\n  /**\n   * delete frames from instance item by type\n   * @param instanceItem\n   * @param type\n   * @param camera\n   */\n  deleteFramesFromInstanceItemByType = (\n    instanceItem: InstanceItem,\n    type: 'current' | 'key' | 'following' | 'all' = 'current',\n    camera = this.rootStore.frame.currentCamera,\n  ) => {\n    const { currentFrame } = this.rootStore.frame;\n    switch (type) {\n      case 'current':\n        this.deleteFramesFromInstanceItem(instanceItem, [currentFrame]);\n        break;\n      case 'key': {\n        const nextKeyFrames = getNextKeyFrames(1, currentFrame, instanceItem.cameras[camera].frames);\n        const nextKeyFrame = nextKeyFrames[0];\n        if (nextKeyFrame) {\n          this.deleteFramesFromInstanceItem(\n            instanceItem,\n            Array.from({ length: nextKeyFrame - currentFrame }).map((_, index) => currentFrame + index),\n          );\n        }\n        break;\n      }\n      case 'following': {\n        const allFrames = Object.keys(instanceItem.cameras[camera].frames).map((f) => parseInt(f, 10));\n        const index = allFrames.indexOf(currentFrame);\n        this.deleteFramesFromInstanceItem(\n          instanceItem,\n          allFrames.slice(index, allFrames.length),\n        );\n        break;\n      }\n      case 'all': {\n        const allFrames = Object.keys(instanceItem.cameras[camera].frames).map((f) => parseInt(f, 10));\n        this.deleteFramesFromInstanceItem(\n          instanceItem,\n          allFrames,\n        );\n        break;\n      }\n      default:\n    }\n  };\n\n  /**\n   * update frame shape info for instance item\n   * @param instanceItem\n   * @param frameIndex\n   * @param shapeType\n   * @param shape\n   * @param order\n   * @param camera\n   */\n  updateFrameShapeForInstanceItem(instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData, order?: number, camera = this.rootStore.frame.currentCamera) {\n    const { prevState, currState } = instanceItem.updateShape(\n      camera,\n      frameIndex,\n      this.rootStore.config.autoInterpolation,\n      shapeType,\n      shape,\n      order,\n    );\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    this.rootStore.undo.push({\n      instances: prevState ? [{ ...basicInfo, children: [prevState] }] : [],\n    }, {\n      instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n    });\n  }\n\n  /**\n   * update frame shape info for instance items list\n   * @param instanceItems\n   */\n  updateFrameShapeForInstanceItems(instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape?: ShapeData, order?: number, camera?: string }[]) {\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n    const prevRelationshipMap: { [id: string]: IRelationship } = {};\n    const currRelationshipMap: { [id: string]: IRelationship } = {};\n    for (let i = 0; i < instanceItems.length; i += 1) {\n      const { instanceItem, frameIndex, shapeType, shape, order, camera = this.rootStore.frame.currentCamera } = instanceItems[i];\n      let state;\n      if (shape) {\n        // update\n        state = instanceItem.updateShape(\n          camera,\n          frameIndex,\n          this.rootStore.config.autoInterpolation,\n          shapeType,\n          shape,\n          order,\n        );\n      } else {\n        // delete\n        this.rootStore.shape.deleteShapeByInstanceItem(instanceItem);\n        // delete relationship\n        const { prevRelationships, currRelationships } = this.rootStore.relationship.deleteFromFramesByInstanceItem(instanceItem, camera, [this.rootStore.frame.currentFrame]);\n        prevRelationships.forEach((r) => {\n          if (!prevRelationshipMap[r.id]) {\n            prevRelationshipMap[r.id] = r;\n          }\n        });\n        currRelationships.forEach((r) => {\n          currRelationshipMap[r.id] = r;\n        });\n\n        state = instanceItem.remove(camera, [frameIndex]);\n        if (instanceItem.isEmpty) {\n          this.deleteInstanceItem(instanceItem);\n        }\n        if (instanceItem.instance.isEmpty) {\n          this.deleteInstance(instanceItem.instance);\n        }\n      }\n\n      if (state) {\n        const { prevState, currState } = state;\n        const { instance } = instanceItem;\n        const { id: instanceId } = instance;\n        if (prevState) {\n          if (!prevInstanceMap[instanceId]) {\n            prevInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: [],\n            };\n          }\n          prevInstanceMap[instanceId].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instanceId]) {\n            currInstanceMap[instanceId] = {\n              ...instance.getBasicInfo(),\n              children: [],\n            };\n          }\n          currInstanceMap[instanceId].children.push(currState);\n        }\n      }\n    }\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n      relationships: Object.values(prevRelationshipMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n      relationships: Object.values(currRelationshipMap),\n    });\n  }\n\n  /**\n   * move instance item\n   * @param targetCategory\n   * @param targetCategoryItem\n   * @param targetInstanceId\n   * @param targetInstanceItemId\n   * @param frames\n   * @param newInstanceAttr\n   * @param newInstanceItemAttr\n   */\n  moveInstanceItem(targetCategory: string, targetCategoryItem: string, targetInstanceId: string, targetInstanceItemId: string, frames: number[], newInstanceAttr?: any, newInstanceItemAttr?: any) {\n    if (!this.isSingleSelected) {\n      return;\n    }\n\n    const selectedInstanceItem = this.selectedInstanceItems[0];\n    const targetInstance = targetInstanceId === 'new'\n      ? this.createInstance(targetCategory)\n      : this.instances[targetInstanceId];\n    if (targetInstance) {\n      const targetInstanceItem = targetInstanceItemId === 'new'\n        ? this.createInstanceItem(targetInstance, targetCategoryItem)\n        : targetInstance.items[targetInstanceItemId];\n      if (targetInstanceItem) {\n        // FIXME: current only support single camera\n        const { currentCamera } = this.rootStore.frame;\n\n        // update target instance item\n        const currInstanceItem = selectedInstanceItem;\n        const framesData = frames.map((frameIndex) => {\n          const frameJson = currInstanceItem.cameras[currentCamera].frames[frameIndex].toJSON();\n          if (targetCategory === currInstanceItem.instance.category && targetCategoryItem === currInstanceItem.name) {\n            return frameJson;\n          }\n          if (newInstanceItemAttr) {\n            frameJson.attributes = newInstanceItemAttr;\n          } else {\n            delete frameJson.attributes;\n          }\n          return frameJson;\n        });\n        const { prevState: targetPrevState, currState: targetCurrState } = targetInstanceItem.updateFramesFromData(currentCamera, framesData);\n        const targetPrevInstance = targetInstance.getBasicInfo();\n        if (newInstanceAttr) {\n          targetInstance.setAttributes(newInstanceAttr);\n        }\n        const targetCurrInstance = targetInstance.getBasicInfo();\n\n        // remove from current instance item\n        const { prevState, currState } = currInstanceItem.remove(currentCamera, frames);\n        if (currInstanceItem.isEmpty) {\n          this.deleteInstanceItem(currInstanceItem);\n        }\n        if (currInstanceItem.instance.isEmpty) {\n          this.deleteInstance(currInstanceItem.instance);\n        }\n\n        // update state\n        const basicInfo = currInstanceItem.instance.getBasicInfo();\n        if (currInstanceItem.instance.id === targetInstanceItem.instance.id) {\n          // same instance\n          const prevInstance: IInstance = { ...targetPrevInstance, children: [] };\n          if (targetPrevState) {\n            prevInstance.children.push(targetPrevState);\n          }\n          if (prevState) {\n            prevInstance.children.push(prevState);\n          }\n          const currInstance: IInstance = { ...basicInfo, children: [] };\n          if (targetCurrState) {\n            currInstance.children.push(targetCurrState);\n          }\n          if (currState) {\n            currInstance.children.push(currState);\n          }\n          this.rootStore.undo.push({\n            instances: prevInstance.children.length > 0 ? [prevInstance] : [],\n          }, {\n            instances: currInstance.children.length > 0 ? [currInstance] : [],\n          });\n        } else {\n          this.rootStore.undo.push({\n            instances: [\n              ...prevState ? [{ ...basicInfo, children: [prevState] }] : [],\n              ...targetPrevState ? [{ ...targetPrevInstance, children: [targetPrevState] }] : [],\n            ],\n          }, {\n            instances: [\n              ...currState ? [{ ...basicInfo, children: [currState] }] : [],\n              ...targetCurrState ? [{ ...targetCurrInstance, children: [targetCurrState] }] : [],\n            ],\n          });\n        }\n\n        // uppdate shapes\n        const currentShape = this.rootStore.shape.getShapeByInstanceItem(currInstanceItem);\n        if (currentShape) {\n          this.rootStore.shape.deleteShape(currentShape);\n        }\n        this.rootStore.shape.setupShape(targetInstanceItem);\n      }\n    }\n  }\n\n  /**\n   * open attributes modal automatically for selected instance\n   */\n  autoOpenAttributesModal() {\n    if (this.isMultiSelected || this.selectedInstances.length <= 0) {\n      return;\n    }\n\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const shouldOpen = (instanceItem: InstanceItem) => {\n      const frameData = instanceItem.cameras[currentCamera]?.frames[currentFrame];\n\n      if (frameData?.isOCR && !frameData?.OCRText) {\n        this.rootStore.config.shouldSyncOCR = true;\n        return true;\n      }\n\n      if (frameData?.isFormula && !frameData?.formulaText) {\n        return true;\n      }\n\n      if (\n        instanceItem.categoryItemRef.labelConfig &&\n        !frameData?.attributes\n      ) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return true;\n      }\n\n      return false;\n    };\n\n    if (this.selectedInstanceItems.length === 1) {\n      const selectedInstanceItem = this.selectedInstanceItems[0];\n      const open = shouldOpen(selectedInstanceItem);\n      if (open) {\n        this.rootStore.config.setAttributesModalVisible(true);\n        return;\n      }\n    }\n\n    const selectedInstance = this.selectedInstances[0];\n    if (\n      selectedInstance.categoryRef.labelConfig &&\n      !selectedInstance.attributes\n    ) {\n      this.rootStore.config.setAttributesModalVisible(true);\n      return;\n    }\n\n    if (this.selectedInstanceItems.length <= 0 && Object.values(selectedInstance.items).some((i) => shouldOpen(i))) {\n      // no instance item selected\n      this.rootStore.config.setAttributesModalVisible(true);\n    }\n  }\n\n  /**\n   * get instances json data (for save)\n   */\n  instancesJSON(): IInstance[] {\n    return Object.values(this.instances).map((instance) => instance.toJSON());\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}