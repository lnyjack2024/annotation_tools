{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx\";\nimport React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { LandmarkEditType, DELETETYPE, ReviewResult } from './types';\nimport { fetchResultByUrl } from './request';\nimport loader from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport { initInstances, loadInstancesFromResult, getFrameShapes, parseFramesByPaylod, getInstanceFrames, validate } from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nnotification.config({\n  top: 60\n});\nvar CANVASSTATUS = /*#__PURE__*/function (CANVASSTATUS) {\n  CANVASSTATUS[\"INITIAL\"] = \"initial\";\n  CANVASSTATUS[\"LANDMARK\"] = \"landmark\";\n  return CANVASSTATUS;\n}(CANVASSTATUS || {});\nconst LandmarkAnnotation = forwardRef((props, ref) => {\n  const store = useLocalObservable(() => rootStore);\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useState(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState(78);\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState('');\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState({});\n  const [updatedShapes, setUpdatedShapes] = useState([]);\n  const [updatedCategories, setUpdatedCategories] = useAsyncState([]);\n  const [defaultInstances, setDefaultInstances] = useAsyncState({});\n  const [instances, setInstances] = useAsyncState({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n  const [selectedShapes, setSelectedShapes] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [formConfig, setFormConfig] = useState(null);\n  const [formValues, setFormValues] = useState(null);\n  const [imageSize, setImageSize] = useState({\n    width: 0,\n    height: 0\n  });\n  const [editFormObject, setEditFormObject] = useState(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState({});\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef(null);\n  const canvas = useRef(null);\n  const isDrawMode = useMemo(() => store.review.drawMode, [store.review.drawMode]);\n  const displayedInstances = useMemo(() => isReview ? initialInstances : instances, [isReview, initialInstances, instances]);\n  const instanceIds = useMemo(() => Object.keys(displayedInstances), [displayedInstances]);\n  const instanceList = useMemo(() => Object.values(displayedInstances).filter(v => !!v), [displayedInstances]);\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap = {};\n    instanceList.forEach(({\n      category,\n      id,\n      number\n    }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n  const displayedCategoryInstancesMap = useMemo(() => isReview ? initialCategoryInstancesMap : categoryInstancesMap, [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n  const displayedCategoryPathShapes = useMemo(() => isReview ? initialCategoryPathShapes : categoryPathShapes, [isReview, initialCategoryPathShapes, categoryPathShapes]);\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    return ontologyItem;\n  });\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find(group => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n  const categories = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.categories) || [], [ontologyGroup]);\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.id;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ? categories.findIndex(c => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) : -1;\n  }, [selectedShapeStatus, categories]);\n  const instancesFrames = useMemo(() => {\n    const items = {};\n    instanceList.forEach(instance => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n  const shapes = useMemo(() => {\n    var _selectedInstance$chi;\n    const group = selectedInstance === null || selectedInstance === void 0 ? void 0 : (_selectedInstance$chi = selectedInstance.children.find(g => g.name === selectedOntologyGroup)) === null || _selectedInstance$chi === void 0 ? void 0 : _selectedInstance$chi.frames[currentFrame];\n    return group && group.shapes || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n  const selectedShapeInfo = useMemo(() => {\n    let info = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        displayColor: (selectedOntology === null || selectedOntology === void 0 ? void 0 : selectedOntology.display_color) || ''\n      };\n      if ((ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        var _categories$selectedC;\n        info = {\n          ...info,\n          pointCategory: (_categories$selectedC = categories[selectedCategoryIndex]) === null || _categories$selectedC === void 0 ? void 0 : _categories$selectedC.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n  const annotatedPointOrShapeCount = useMemo(() => Object.entries(shapes).filter(([, v]) => v !== undefined).length, [shapes]);\n  const totalPointCount = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.count) || 0, [ontologyGroup]);\n  const instancesReviewsMap = useObserver(() => {\n    const map = {};\n    store.review.reviews.forEach(review => {\n      var _instances$instanceId;\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        shapeIds,\n        result\n      } = review;\n      const category = (_instances$instanceId = instances[instanceId]) === null || _instances$instanceId === void 0 ? void 0 : _instances$instanceId.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0\n        };\n      }\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n  useEffect(() => {\n    onLoad();\n  }, []);\n  const getInstance = instanceId => displayedInstances[instanceId];\n  const getGroup = (instanceId, groupName, frameIndex = currentFrame) => {\n    var _instance$children$fi;\n    const instance = getInstance(instanceId);\n    const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[frameIndex];\n    return group;\n  };\n  const getShape = (instanceId, groupName, id, frameIndex = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? group.shapes[id] : group.shapes[id]);\n  };\n  const setInstance = (id, instance) => {\n    setInstances({\n      ...instances,\n      [id]: instance\n    });\n  };\n  const setShape = (frameIndex, instanceId, groupName, id, shapeType, shape) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      var _group;\n      let group = instance.children.find(g => g.name === groupName);\n      let currentGroup = (_group = group) === null || _group === void 0 ? void 0 : _group.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = currentGroup.shapes[id];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = currentGroup.shapes[id];\n      }\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete currentGroup.shapes[id];\n        } else {\n          delete currentGroup.shapes[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n        }\n        currentGroup.shapes = {\n          ...currentGroup.shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === groupInfo.count && !currentGroup.attributes) {\n        handleFormConfig(groupInfo.label_config, {}, {\n          instanceId,\n          category: instance.category,\n          groupName\n        });\n      }\n    }\n  };\n  const updateStatus = async (curr, prev) => {\n    let newUpdatedShapes = [];\n    let newUpdatedCategories = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const {\n          frameIndex,\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        let keyObj;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = {\n            index\n          };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = {\n            id\n          };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({\n            ...frameGroup,\n            ...keyObj,\n            shapeType\n          });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          const {\n            updateShapes\n          } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          const instanceIndex = instanceIds.findIndex(v => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          frameIndex,\n          groupName,\n          attributes\n        } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n          if (newInstance && newGroup) {\n            newGroup.frames[frameIndex].attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'shape') {\n        const {\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType,\n          shape,\n          frameIndex\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape;\n            const {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              attributes\n            } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex(p => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: {\n                  ...point.position\n                }\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                index,\n                shape: updateShape,\n                shapeType\n              });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape;\n            const {\n              displayColor,\n              visible,\n              x,\n              y,\n              width,\n              height\n            } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible\n            };\n            const updateIndex = newUpdatedShapes.findIndex(rect => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                id,\n                shape: updateRectangle,\n                shapeType\n              });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const {\n          frameIndex,\n          pointCategory,\n          shape\n        } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3]\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const {\n            updateShapes,\n            updatedCategories: newCategories\n          } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          newUpdatedCategories = [...newUpdatedCategories, ...newCategories];\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          groupName,\n          attributes,\n          frameIndex\n        } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach(id => {\n            var _canvas$current;\n            const attrLayer = (_canvas$current = canvas.current) === null || _canvas$current === void 0 ? void 0 : _canvas$current.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              var _canvas$current2;\n              (_canvas$current2 = canvas.current) === null || _canvas$current2 === void 0 ? void 0 : _canvas$current2.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          newGroup.frames[frameIndex].attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    setUpdatedShapes(newUpdatedShapes);\n  };\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({\n          message: 'Undo successfully.'\n        });\n      }\n    }\n  };\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({\n          message: 'Redo successfully.'\n        });\n      }\n    }\n  };\n  const handleChangeDrawMode = mode => {\n    if (store.review.isEditable) {\n      var _canvas$current3;\n      (_canvas$current3 = canvas.current) === null || _canvas$current3 === void 0 ? void 0 : _canvas$current3.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(undefined, {\n          instanceId,\n          category,\n          groupName\n        });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n  const loadInitialData = async () => {\n    let data;\n    const {\n      initial_result: initialResult\n    } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n  const addInstance = async ontologyName => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter(v => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n      const children = ontologyItem.children.map(v => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({\n        [id]: instance\n      });\n      await handleInstanceChange({\n        [id]: instance\n      });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, {\n          category: ontologyName,\n          shapeType: ontologyItem.children[0].type\n        });\n      }\n    }\n  };\n  const addInstanceInFrame = (instanceId, groupName) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex(group => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame;\n          Object.keys(newInstance.children[groupIdx].frames).forEach(i => {\n            const index = Number(i);\n            const frame = {\n              ...newInstance.children[groupIdx].frames[index]\n            };\n            frame.shapes = {\n              ...frame.shapes\n            };\n            if ((frame === null || frame === void 0 ? void 0 : frame.count) && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx;\n        Object.keys(instancesFrames[instanceId]).forEach(i => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach(group => {\n            const copyFrame = {\n              ...group.frames[copyFrameIdx]\n            };\n            copyFrame.shapes = {\n              ...copyFrame.shapes\n            };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const {\n        updateShapes,\n        updatedCategories: newUpdatedCategories\n      } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n      setUpdatedCategories(newUpdatedCategories);\n      setUpdatedShapes(updateShapes);\n    }\n  };\n  const removeInstanceFrames = (type, instance, name) => {\n    if (instance) {\n      let delShapes = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance, frameIndex) => {\n        updateInstance.children.forEach(group => {\n          if (name && name === group.name || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= group.frames[frameIndex].count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const {\n          updateShapes\n        } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({\n          length: frames.length - diffFrame\n        }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const {\n            updateShapes\n          } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [...delShapes, ...updateShapes];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter(v => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      setUpdatedShapes(delShapes);\n      handleInstanceChange({\n        [newInstance.id]: newInstance\n      });\n    }\n  };\n  const handleInstanceChange = async (newInstances, status) => {\n    const ids = Object.keys(newInstances);\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async id => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach(child => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance\n          }\n        });\n        after.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n  const onLoad = async () => {\n    var _result, _saverRef$current;\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n    let result;\n    let initialData;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({\n        message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({\n      frames: props.image,\n      imageData: (_result = result) === null || _result === void 0 ? void 0 : _result.images\n    });\n    // preload image\n    setImagePreloader(loader(framesData.map(v => v.url)));\n    // set frame images\n    setFrames(framesData);\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes = {};\n        result.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height\n      });\n    }\n\n    // load reviews\n    await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData = {};\n        initialData.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const {\n        newInstances,\n        categoryInstancesMap: newCategoryInstancesMap\n      } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const {\n        newInstances\n      } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    (_saverRef$current = saverRef.current) === null || _saverRef$current === void 0 ? void 0 : _saverRef$current.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = (frameIndex, currentInstances = instances, type) => {\n    var _canvas$current4, _canvas$current5;\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    const currentInstanceList = Object.values(currentInstances);\n    (_canvas$current4 = canvas.current) === null || _canvas$current4 === void 0 ? void 0 : _canvas$current4.cleanLayer();\n    (_canvas$current5 = canvas.current) === null || _canvas$current5 === void 0 ? void 0 : _canvas$current5.setMultiShapesUnselected();\n    imagePreloader === null || imagePreloader === void 0 ? void 0 : imagePreloader.preload(frameIndex);\n    setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const {\n        id,\n        category,\n        children: [{\n          name\n        }]\n      } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group === null || group === void 0 ? void 0 : group.type\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const {\n      updateShapes,\n      updatedCategories: updatedCategoriesData\n    } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    setUpdatedShapes(updateShapes);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n  const onSave = async (submit = true) => {\n    var _saverRef$current2, _canvas$current6, _canvas$current6$imag, _canvas$current7, _canvas$current7$imag;\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({\n        message: loadError\n      });\n      throw new Error(loadError);\n    }\n    (_saverRef$current2 = saverRef.current) === null || _saverRef$current2 === void 0 ? void 0 : _saverRef$current2.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances = instanceList.filter(v => v && v.notEmpty).map(instance => {\n      const {\n        id,\n        category,\n        number,\n        displayColor,\n        children\n      } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map(group => {\n          const {\n            frames: groupFrames\n          } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter(v => !!v && v.count > 0).map(frameGroup => {\n              if (frameGroup) {\n                const {\n                  frameIndex,\n                  count,\n                  shapes: groupShapes\n                } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach(key => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point = groupShapes && groupShapes[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        newShapes.push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle = groupShapes && groupShapes[key];\n                      if (rectangle) newShapes.push(rectangle);\n                    }\n                  });\n                }\n                if (checkMissingPoints && frames[frameIndex].valid !== false && groupInfo && newShapes.length < groupInfo.count) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.display_name) || (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.class_name),\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({\n                    message: errMsg\n                  });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: ((_canvas$current6 = canvas.current) === null || _canvas$current6 === void 0 ? void 0 : (_canvas$current6$imag = _canvas$current6.imageCanvas) === null || _canvas$current6$imag === void 0 ? void 0 : _canvas$current6$imag.width) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.width),\n      height: ((_canvas$current7 = canvas.current) === null || _canvas$current7 === void 0 ? void 0 : (_canvas$current7$imag = _canvas$current7.imageCanvas) === null || _canvas$current7$imag === void 0 ? void 0 : _canvas$current7$imag.height) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.height),\n      instances: newInstances,\n      categoryPathShapes: Object.keys(categoryPathShapes).map(pointCategory => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory]\n      })),\n      images: frames,\n      statistics\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0\n    };\n    const reviews = store.review.reviews.filter(r => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          statShapes[shape].total += 1;\n          objects.total += 1;\n          const review = reviews.find(r => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.REJECT) {\n            statShapes[shape].rejected += 1;\n            objects.rejected += 1;\n          } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.SUSPEND) {\n            statShapes[shape].suspended += 1;\n            objects.suspended += 1;\n          } else {\n            statShapes[shape].approved += 1;\n            objects.approved += 1;\n          }\n        }\n      }\n    }\n    return {\n      objects,\n      shapes: statShapes\n    };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const {\n      ontology\n    } = store.ontology;\n    const data = {\n      elements: [],\n      categories: ontology.map(({\n        class_name: className\n      }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set()\n    };\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const {\n        id,\n        category,\n        children\n      } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [id],\n              category,\n              shape,\n              count: 1,\n              distinctCount: 1\n            };\n          } else {\n            data.summary[key].count += 1;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += 1;\n              data.summary[key].ids.push(id);\n            }\n          }\n          if (frameShapes.length > 0) {\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push({\n              id,\n              shape,\n              frame: frame.frameIndex + 1,\n              category\n            });\n          }\n        }\n      }\n    }\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({\n        category,\n        shape,\n        count,\n        distinctCount\n      }) => ({\n        category,\n        shape,\n        count,\n        distinctCount\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames)\n    };\n  };\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n  const saveReviews = (type = 'submit') => {\n    var _saverRef$current3;\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find(review => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    (_saverRef$current3 = saverRef.current) === null || _saverRef$current3 === void 0 ? void 0 : _saverRef$current3.disableLeaveCheck();\n    return props.jobProxy.saveReviews(store.review.reviews);\n  };\n  const handleSave = async () => {\n    const {\n      toolMode\n    } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n    try {\n      await onSave(false);\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({\n        message: formatMessage('SAVE_SUCCESS')\n      });\n    } catch (e) {\n      notification.error({\n        message: formatMessage('SAVE_FAIL')\n      });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const {\n        hasCustomError,\n        blockSubmitErrors\n      } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n  const setSelectedShape = (id, groupData) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        shapeType\n      } = groupData;\n      if (instanceId !== (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.id)) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        groupName\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n  const setNextEmptyShape = (shapeStatus = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let {\n        id\n      } = shapeStatus;\n      const {\n        instanceId,\n        groupName,\n        shapeType\n      } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const {\n            range = []\n          } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            id += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n  const onShapesUpdated = () => {\n    setUpdatedShapes([]);\n  };\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n  const handleShapesChange = (newShapes, groupsAttributes, status) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    const {\n      instanceId,\n      groupName\n    } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData((newInstance === null || newInstance === void 0 ? void 0 : newInstance.category) || '', groupName);\n    newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          };\n        }\n        ;\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const {\n            id,\n            frameIndex,\n            index,\n            shape\n          } = newShapes[i];\n          let oldShape;\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = child.frames[frameIndex].shapes[index];\n            child.frames[frameIndex].shapes[index] = {\n              ...oldShape,\n              ...shape\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = child.frames[frameIndex].shapes[id];\n            child.frames[frameIndex].shapes[id] = {\n              ...oldShape,\n              ...shape\n            };\n          }\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        }\n        ;\n        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.count) && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, {\n            instanceId,\n            category: newInstance.category,\n            groupName\n          });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({\n        instanceId: id,\n        name,\n        category,\n        attributes\n      }) => {\n        const frameGroup = {\n          frameIndex: currentFrame,\n          instanceId: id,\n          category,\n          groupName: name\n        };\n        before.push({\n          type: 'group',\n          status: {\n            ...frameGroup\n          }\n        });\n        after.push({\n          type: 'group',\n          status: {\n            ...frameGroup,\n            attributes\n          }\n        });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({\n        [instanceId]: newInstance\n      }, {\n        before,\n        after\n      });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n  const handleShapesRemove = removeShapes => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n    const changeInstances = {};\n    const {\n      instanceId,\n      groupName\n    } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({\n            id,\n            frameIndex,\n            index\n          }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete child.frames[frameIndex].shapes[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete child.frames[frameIndex].shapes[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n    }\n  };\n  const togglePointsVisibility = points => {\n    const list = [];\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: {\n            ...point,\n            visible: !point.visible\n          }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n  const setCategoryPathShape = (categoryKey, shapeType, _updatedShapes) => {\n    const before = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: categoryPathShapes[categoryKey]\n      }\n    }];\n    const after = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: shapeType\n      }\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, {\n        before,\n        after\n      });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n  const selectGroup = (id, groupName, isFit = true, groupData) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: (groupData === null || groupData === void 0 ? void 0 : groupData.category) || selectedShapeStatus.category,\n      groupName,\n      shapeType: (groupData === null || groupData === void 0 ? void 0 : groupData.shapeType) || undefined,\n      id: undefined\n    };\n    if (instance) {\n      var _canvas$current8;\n      const ontologyItem = store.ontology.ontology.find(v => v.class_name === instance.category);\n      const group = ontologyItem === null || ontologyItem === void 0 ? void 0 : ontologyItem.children.find(v => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = (group === null || group === void 0 ? void 0 : group.type) || undefined;\n      if (isDrawMode) {\n        if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.KEYPOINT) {\n          const index = group.categories && group.categories[0] && group.categories[0].range[0] || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach(child => {\n            var _child$frames$current;\n            if (child.name === groupName && ((_child$frames$current = child.frames[currentFrame]) === null || _child$frames$current === void 0 ? void 0 : _child$frames$current.shapes)) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      (_canvas$current8 = canvas.current) === null || _canvas$current8 === void 0 ? void 0 : _canvas$current8.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        var _canvas$current9;\n        (_canvas$current9 = canvas.current) === null || _canvas$current9 === void 0 ? void 0 : _canvas$current9.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n  const editShapeForm = () => {\n    const {\n      instanceId,\n      groupName,\n      shapeType,\n      id,\n      category\n    } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, id);\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.point_label_config)) {\n        handleFormConfig(currentOntologyGroup.point_label_config, point.attributes || {}, {\n          instanceId,\n          category,\n          groupName\n        }, id, point);\n      }\n    }\n  };\n  const editGroupForm = () => {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.label_config)) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, {\n        instanceId,\n        category,\n        groupName\n      });\n    }\n  };\n  const handleFormConfig = (config, values, group, index, point) => {\n    var _attributesRef$curren;\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    (_attributesRef$curren = attributesRef.current) === null || _attributesRef$curren === void 0 ? void 0 : _attributesRef$curren.showModal(title);\n  };\n  const getShapeLabel = (instanceId, category, groupName) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', {\n          values: {\n            frameIndex: currentFrame + 1\n          }\n        })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n  const setAttributes = values => {\n    if (editFormObject) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        index,\n        point\n      } = editFormObject;\n      const before = [];\n      const after = [];\n      const frameGroup = {\n        frameIndex: currentFrame,\n        instanceId,\n        category,\n        groupName\n      };\n      if ((index || index === 0) && point) {\n        var _canvas$current0;\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = {\n          ...oldPoint,\n          ...point,\n          attributes: values\n        };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: oldPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        after.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: newPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        (_canvas$current0 = canvas.current) === null || _canvas$current0 === void 0 ? void 0 : _canvas$current0.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        var _newInstance$children;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : (_newInstance$children = newInstance.children.find(v => v.name === groupName)) === null || _newInstance$children === void 0 ? void 0 : _newInstance$children.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: oldAttrs\n            }\n          });\n          after.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: values\n            }\n          });\n          if (oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach(id => {\n                var _canvas$current1;\n                (_canvas$current1 = canvas.current) === null || _canvas$current1 === void 0 ? void 0 : _canvas$current1.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode, type = 'object') => {\n    var _canvas$current10;\n    (_canvas$current10 = canvas.current) === null || _canvas$current10 === void 0 ? void 0 : _canvas$current10.updatelabelVisible(activeMode, type);\n  };\n  const onSizeChange = () => {\n    var _canvas$current11;\n    (_canvas$current11 = canvas.current) === null || _canvas$current11 === void 0 ? void 0 : _canvas$current11.resizeShapes();\n  };\n  const onFilterChange = () => {\n    var _canvas$current12;\n    (_canvas$current12 = canvas.current) === null || _canvas$current12 === void 0 ? void 0 : _canvas$current12.updateFilters();\n  };\n  const onLabelModeChange = () => {\n    var _canvas$current13;\n    if ((_canvas$current13 = canvas.current) === null || _canvas$current13 === void 0 ? void 0 : _canvas$current13.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n  const onGridVisibleChange = () => {\n    var _canvas$current14;\n    if ((_canvas$current14 = canvas.current) === null || _canvas$current14 === void 0 ? void 0 : _canvas$current14.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n  const setFrameValid = (frame, valid) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n  const getScriptResult = async () => {\n    let resultLink = '';\n    if (store.setting.customCheck) {\n      if (typeof props.jobProxy.reviewFrom === 'string') {\n        resultLink = props.jobProxy.reviewFrom;\n      }\n      if (!isAnnotationReadonly(props.jobProxy.toolMode)) {\n        try {\n          resultLink = await onSave(false);\n        } catch (e) {\n          resultLink = '';\n        }\n      }\n    }\n    const [result] = await Promise.all([validate(store.setting.customCheck, {\n      resultLink\n    }), new Promise(resolve => {\n      setTimeout(resolve, 300);\n    })]);\n    if (result) {\n      store.review.setScriptResult(result);\n    }\n  };\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics\n  }));\n  return /*#__PURE__*/React.createElement(Observer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 1578,\n      columnNumber: 5\n    }\n  }, () => {\n    var _frames$currentFrame, _frames$currentFrame2;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"landmark-annotation-app\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1580,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(AutoSaver, {\n      ref: saverRef,\n      leaveCheck: true,\n      data: {\n        instance: instances,\n        reviews: store.review.qaWarnings\n      },\n      save: handleSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1581,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(Toolbar, {\n      readonly: readonly || loading || isReview,\n      isReview: isReview,\n      isPreview: readonly,\n      initialDataLength: Object.keys(initialInstances).length,\n      onAttributesModeChanges: onAttributesModeChanges,\n      onSizeChange: onSizeChange,\n      onFilterChange: onFilterChange,\n      onLabelModeChange: onLabelModeChange,\n      onGridVisibleChange: onGridVisibleChange,\n      onSave: handleSave,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1587,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"container\",\n      style: {\n        height: `calc(100% - ${frames.length > 1 && currentFrame >= 0 ? `${frameControlHeight + 35}px` : '35px'})`,\n        transition: 'height 0.15s'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1603,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(TabMenu, {\n      tabs: [{\n        title: formatMessage('MENU_INSTANCE'),\n        key: 'instance',\n        count: 0,\n        content: /*#__PURE__*/React.createElement(SideMenus, {\n          readonly: readonly || loading || isReview || !isDrawMode,\n          loading: loading,\n          instances: instanceList,\n          currentFrame: currentFrame,\n          instancesFrames: instancesFrames,\n          selectedInstance: selectedInstance,\n          selectedOntologyGroup: selectedOntologyGroup,\n          instancesReviewsMap: instancesReviewsMap,\n          addInstance: addInstance,\n          selectGroup: selectGroup,\n          addInstanceInFrame: addInstanceInFrame,\n          removeInstanceFrames: removeInstanceFrames,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1617,\n            columnNumber: 21\n          }\n        })\n      }, {\n        title: formatMessage('MENU_WARNING'),\n        key: 'validator',\n        count: store.review.warnings.length,\n        content: /*#__PURE__*/React.createElement(Validator, {\n          ref: validatorRef,\n          instances: instances,\n          jobProxy: props.jobProxy,\n          getScriptResult: getScriptResult,\n          warnings: store.review.warnings || [],\n          setFrame: setFrame,\n          setSelectedShape: setSelectedShape,\n          selectGroup: selectGroup,\n          getInstance: getInstance,\n          saveResult: () => onSave(false),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1638,\n            columnNumber: 21\n          }\n        })\n      }],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1610,\n        columnNumber: 13\n      }\n    }), selectedInstance && ontologyGroup && !isReview && /*#__PURE__*/React.createElement(Board, {\n      categories: categories,\n      categoryPathShapes: displayedCategoryPathShapes,\n      points: shapes,\n      ontologyGroup: ontologyGroup,\n      selectedShapeStatus: selectedShapeStatus,\n      selectedShapes: selectedShapes,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      drawMode: isDrawMode,\n      setSelectedShape: id => {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(id, {\n          instanceId,\n          category,\n          groupName\n        });\n      },\n      frameControlHeight: frameControlHeight,\n      readonly: loading,\n      instanceReviewsMap: store.review.frameReviewsMap[currentFrame],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1655,\n        columnNumber: 15\n      }\n    }), /*#__PURE__*/React.createElement(Canvas, {\n      ref: canvas,\n      readonly: readonly,\n      loading: loading,\n      isReview: isReview,\n      currentFrame: currentFrame,\n      image: (_frames$currentFrame = frames[currentFrame]) === null || _frames$currentFrame === void 0 ? void 0 : _frames$currentFrame.url,\n      categories: categories,\n      selectedInstance: selectedInstance,\n      selectedGroupName: selectedOntologyGroup,\n      ontologyGroup: ontologyGroup,\n      annotatedPointOrShapeCount: annotatedPointOrShapeCount,\n      updatedShapes: updatedShapes,\n      updatedCategories: updatedCategories,\n      defaultInstances: defaultInstances,\n      selectedShapeStatus: selectedShapeStatus,\n      selectedShapeInfo: selectedShapeInfo,\n      warnings: store.review.qaWarnings,\n      undoPointer: store.undo.actionPointer,\n      changeLoading: setLoading,\n      selectGroup: selectGroup,\n      setSelectedShape: setSelectedShape,\n      setMultiSelectedShape: setSelectedShapes,\n      handleShapesChange: handleShapesChange,\n      onShapesUpdated: onShapesUpdated,\n      onCategoriesUpdated: onCategoriesUpdated,\n      handleShapesRemove: handleShapesRemove,\n      togglePointsVisibility: togglePointsVisibility,\n      setNextEmptyShape: setNextEmptyShape,\n      editShapeForm: editShapeForm,\n      editGroupForm: editGroupForm,\n      onSave: handleSave,\n      getInstance: getInstance,\n      categoryPathShapes: displayedCategoryPathShapes,\n      setCategoryPathShape: setCategoryPathShape,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1674,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"arributes-panel\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1714,\n        columnNumber: 13\n      }\n    }, selectedShapeStatus.groupName && /*#__PURE__*/React.createElement(Information, {\n      pointCategory: (categories[selectedCategoryIndex] || {}).name,\n      point: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1716,\n        columnNumber: 17\n      }\n    }), ((_frames$currentFrame2 = frames[currentFrame]) === null || _frames$currentFrame2 === void 0 ? void 0 : _frames$currentFrame2.url) && /*#__PURE__*/React.createElement(FrameAttributes, {\n      currentFrame: currentFrame,\n      currentFrameValid: frames[currentFrame].valid,\n      setFrameValid: setFrameValid,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1724,\n        columnNumber: 17\n      }\n    })), /*#__PURE__*/React.createElement(Attributes, {\n      ref: attributesRef,\n      readonly: readonly || isReview || !isDrawMode,\n      config: formConfig,\n      values: formValues,\n      onValuesChange: setAttributes,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1731,\n        columnNumber: 13\n      }\n    })), frames.length > 1 && currentFrame >= 0 && /*#__PURE__*/React.createElement(FrameControl, {\n      frames: frames,\n      frameLoading: loading,\n      currentFrame: currentFrame,\n      categoryInstancesMap: displayedCategoryInstancesMap,\n      instancesReviewsMap: instancesReviewsMap,\n      instances: displayedInstances,\n      selectedInstance: selectedInstance,\n      selectedInstanceGroup: selectedOntologyGroup,\n      selectGroup: selectGroup,\n      setFrame: setFrame,\n      onHeightChange: setFrameControlHeight,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1740,\n        columnNumber: 13\n      }\n    }), store.review.selectedReview && /*#__PURE__*/React.createElement(QualityControl, {\n      review: store.review.selectedReview,\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      selectedShapeStatus: selectedShapeStatus,\n      getShapeLabel: getShapeLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1755,\n        columnNumber: 13\n      }\n    }));\n  });\n});\nexport default LandmarkAnnotation;","map":{"version":3,"names":["React","useState","useRef","useMemo","useEffect","forwardRef","useImperativeHandle","Observer","useLocalObservable","useObserver","cloneDeep","notification","v4","uuid","TabMenu","AutoSaver","Toolbar","SideMenus","Board","Canvas","FrameControl","Validator","Attributes","QualityControl","Information","FrameAttributes","formatMessage","i18n","LandmarkEditType","DELETETYPE","ReviewResult","fetchResultByUrl","loader","isPreview","isAnnotationReadonly","initInstances","loadInstancesFromResult","getFrameShapes","parseFramesByPaylod","getInstanceFrames","validate","rootStore","useAsyncState","config","top","CANVASSTATUS","LandmarkAnnotation","props","ref","store","readonly","setReadOnly","frames","setFrames","currentFrame","setCurrentFrame","frameControlHeight","setFrameControlHeight","selectedOntologyGroup","setSelectedOntologyGroup","categoryPathShapes","setCategoryPathShapes","updatedShapes","setUpdatedShapes","updatedCategories","setUpdatedCategories","defaultInstances","setDefaultInstances","instances","setInstances","imagePreloader","setImagePreloader","selectedShapeStatus","setSelectedShapeStatus","frameIndex","category","instanceId","groupName","shapeType","undefined","id","selectedShapes","setSelectedShapes","loading","setLoading","formConfig","setFormConfig","formValues","setFormValues","imageSize","setImageSize","width","height","editFormObject","setEditFormObject","isReview","setIsReview","initialInstances","setInitialInstances","initialCategoryInstancesMap","setInitialCategoryInstancesMap","initialCategoryPathShapes","setInitialCategoryPathShapes","attributesRef","saverRef","validatorRef","canvas","isDrawMode","review","drawMode","displayedInstances","instanceIds","Object","keys","instanceList","values","filter","v","selectedInstance","categoryInstancesMap","newCategoryInstancesMap","forEach","number","displayedCategoryInstancesMap","displayedCategoryPathShapes","selectedOntology","ontologyItem","ontology","find","class_name","ontologyGroup","groupItem","children","group","name","categories","selectedCategoryIndex","KEYPOINT","findIndex","c","range","length","instancesFrames","items","instance","shapes","_selectedInstance$chi","g","selectedShapeInfo","info","type","displayColor","display_color","_categories$selectedC","pointCategory","isKeyPoint","includes","annotatedPointOrShapeCount","entries","totalPointCount","count","instancesReviewsMap","map","reviews","_instances$instanceId","shapeIds","result","approveCount","REJECT","SUSPEND","APPROVE","len","ontologyCount","ontologyMap","onLoad","getInstance","getGroup","_instance$children$fi","getShape","setInstance","setShape","shape","_group","currentGroup","push","oldShape","RECTANGLE","notEmpty","groupInfo","getGroupData","label_config","attributes","handleFormConfig","updateStatus","curr","prev","newUpdatedShapes","newUpdatedCategories","newCategoryPathShapes","m","item","index","status","frameGroup","keyObj","updateShapes","instanceIndex","selectedIndex","newInstance","selectGroup","newGroup","setInitialData","n","point","visible","updateIndex","p","updateShape","position","rectangle","x","y","updateRectangle","rect","split","newCategories","_canvas$current","attrLayer","current","getAttrLabelByKey","_canvas$current2","updateAttributeLabel","handleUndo","undo","undoDisabled","before","after","success","message","handleRedo","redoDisabled","redo","handleChangeDrawMode","mode","isEditable","_canvas$current3","clearHits","setNextEmptyShape","setSelectedShape","setDrawMode","loadInitialData","data","initial_result","initialResult","e","console","log","addInstance","ontologyName","sameOntologyInstances","reverse","handleInstanceChange","addInstanceInFrame","groupIdx","copyFrame","i","Number","frame","copyFrameIdx","removeInstanceFrames","delShapes","update","updateInstance","CURRENT","FOLLOW","ALL","diffFrame","Array","from","_","newInstances","ids","oldInstance","isRemove","child","saveStatus","_result","_saverRef$current","jobProxy","toolMode","setLocale","locale","init","initialData","initInstancesData","loadResult","error","duration","framesData","image","imageData","images","url","isArray","auditId","setAuditId","points","loadReviews","initialCategoryPathShapesData","initialInstancesData","currentInstances","setFrame","setTempSaved","renderComplete","_canvas$current4","_canvas$current5","INITIAL","currentInstanceList","cleanLayer","setMultiShapesUnselected","preload","currentShapeStatus","updatedCategoriesData","setReview","newIsReview","displayInstances","onSave","submit","_saverRef$current2","_canvas$current6","_canvas$current6$imag","_canvas$current7","_canvas$current7$imag","loadError","Error","disableLeaveCheck","setting","submitCheck","passed","triggerValidation","checkMissingPoints","check_missing_points","ontologyInfo","getOntologyInfo","groupFrames","groupShapes","newShapes","key","pointIndex","parseInt","valid","errMsg","display_name","annotated","total","statData","getInstanceStatistics","statistics","saveResultStat","saveResult","imageCanvas","getStatistics","statShapes","objects","approved","rejected","suspended","missed","r","instancesList","j","itemFrames","k","elements","className","Set","summary","frameCount","annotatedFrames","frameShapes","add","distinctCount","saveReviews","_saverRef$current3","hasSuspend","handleSave","isEnabled","hasCustomError","blockSubmitErrors","handleSync","groupData","newSelectedShapeStatus","shapeStatus","categoryScannedCount","categoryIndex","onShapesUpdated","onCategoriesUpdated","handleShapesChange","groupsAttributes","handleShapesRemove","removeShapes","changeInstances","togglePointsVisibility","list","setCategoryPathShape","categoryKey","_updatedShapes","isFit","_canvas$current8","_child$frames$current","rectangles","updateGroupBox","_canvas$current9","fitSelected","editShapeForm","currentOntologyGroup","point_label_config","editGroupForm","_attributesRef$curren","title","getShapeLabel","showModal","class_display_name","setAttributes","_canvas$current0","oldPoint","newPoint","_newInstance$children","oldGroup","ontologyChild","oldAttrs","_canvas$current1","onAttributesModeChanges","activeMode","_canvas$current10","updatelabelVisible","onSizeChange","_canvas$current11","resizeShapes","onFilterChange","_canvas$current12","updateFilters","onLabelModeChange","_canvas$current13","labelLayer","labelMode","onGridVisibleChange","_canvas$current14","gridLayer","isGridVisible","setFrameValid","newFramesData","getScriptResult","resultLink","customCheck","reviewFrom","Promise","all","resolve","setTimeout","setScriptResult","createElement","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","_frames$currentFrame","_frames$currentFrame2","leaveCheck","qaWarnings","save","initialDataLength","style","transition","tabs","content","warnings","instanceReviewsMap","frameReviewsMap","selectedGroupName","undoPointer","actionPointer","changeLoading","setMultiSelectedShape","currentFrameValid","onValuesChange","frameLoading","selectedInstanceGroup","onHeightChange","selectedReview"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx"],"sourcesContent":["import React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes, { AttributesHandle } from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { Status } from './store/UndoStore';\nimport { AttributesMode } from './store/SettingsStore';\nimport { IWarning } from '../common/tabs-menu/Validator';\nimport {\n  LandmarkEditType, InstanceListItem, CategoryPathShape, Point, PointListItem, PointStatus, FrameGroup,\n  ShapeInfo, PointInfo, Group, InstanceAct, Rectangle, GroupInfo, FormConfig, ObjectInfo, UpdatedShape,\n  Points, CurrentShapes, CategoryInstancesMap, KeypointCategoryProps, DELETETYPE, Frame, ReviewResult,\n  Payload, Statistic, Image\n} from './types';\nimport { fetchResultByUrl } from './request';\nimport loader, { ImagePreloader } from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport {\n  initInstances,\n  loadInstancesFromResult,\n  getFrameShapes,\n  parseFramesByPaylod,\n  getInstanceFrames,\n  validate\n} from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\n\nnotification.config({ top: 60 });\n\nenum CANVASSTATUS {\n  INITIAL = 'initial',\n  LANDMARK = 'landmark',\n}\n\nexport interface GroupReviewsMap {\n  [groupName: string]: {\n    approveCount: number;\n    result?: ReviewResult;\n  }\n}\n\nexport interface InstancesReviewsMap {\n  [instanceId: string]: {\n    [frameIndex: number]: {\n      approveCount: number;\n      result?: ReviewResult;\n      children: GroupReviewsMap\n    }\n  }\n}\n\nconst LandmarkAnnotation = forwardRef((props: Payload, ref) => {\n  const store = useLocalObservable(() => rootStore);\n\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState<Image[]>([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useState<number>(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState<number>(78);\n\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState<string>('');\n\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState<{ [categoryKey: string]: CategoryPathShape }>({});\n\n  const [updatedShapes, setUpdatedShapes] = useState<UpdatedShape[]>([]);\n\n  const [updatedCategories, setUpdatedCategories] = useAsyncState<KeypointCategoryProps[]>([]);\n\n  const [defaultInstances, setDefaultInstances] = useAsyncState<{[id: string]: InstanceAct}>({});\n\n  const [instances, setInstances] = useAsyncState<{[id: string]: InstanceAct}>({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState<ImagePreloader | null>(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState<ShapeInfo>({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n\n  const [selectedShapes, setSelectedShapes] = useState<number[] | string[]>([]);\n\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const [formConfig, setFormConfig] = useState<FormConfig | null>(null);\n\n  const [formValues, setFormValues] = useState<{[attr: string]: any;} | null>(null);\n\n  const [imageSize, setImageSize] = useState<{width: number, height: number} | undefined>({ width: 0, height: 0 });\n\n  const [editFormObject, setEditFormObject] = useState<ObjectInfo | null>(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState<boolean>(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState<{[id: string]: InstanceAct}>({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState<CategoryInstancesMap>({});\n\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState<{[categoryKey: string]: CategoryPathShape}>({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef<AttributesHandle>(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef<AutoSaver>(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef<Validator>(null);\n\n  const canvas = useRef<Canvas>(null);\n\n  const isDrawMode = useMemo(() => (\n    store.review.drawMode\n  ), [store.review.drawMode]);\n\n  const displayedInstances = useMemo(() => (\n    isReview ? initialInstances : instances\n  ), [isReview, initialInstances, instances]);\n\n  const instanceIds = useMemo(() => (\n    Object.keys(displayedInstances)\n  ), [displayedInstances]);\n\n  const instanceList = useMemo(() => (\n    Object.values(displayedInstances).filter((v) => !!v)\n  ), [displayedInstances]);\n\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus?.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap: CategoryInstancesMap = {};\n    instanceList.forEach(({ category, id, number }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n\n  const displayedCategoryInstancesMap = useMemo(() => (\n    isReview ? initialCategoryInstancesMap : categoryInstancesMap\n  ), [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n\n  const displayedCategoryPathShapes = useMemo(() => (\n    isReview ? initialCategoryPathShapes : categoryPathShapes\n  ), [isReview, initialCategoryPathShapes, categoryPathShapes]);\n\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    return ontologyItem;\n  });\n\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find((group) => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n\n  const categories = useMemo(() => (\n    ontologyGroup?.categories || []\n  ), [ontologyGroup]);\n\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus?.id as number;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ?\n      categories.findIndex((c) => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) :\n      -1;\n  }, [selectedShapeStatus, categories]);\n\n  const instancesFrames = useMemo(() => {\n    const items: { [id: string]: {\n      [frameIndex: number]: boolean;\n    } } = {};\n    instanceList.forEach((instance) => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n\n  const shapes = useMemo(() => {\n    const group = selectedInstance?.children.find((g) => g.name === selectedOntologyGroup)?.frames[currentFrame];\n    return (group && group.shapes) || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n\n  const selectedShapeInfo = useMemo(() => {\n    let info: PointInfo | GroupInfo | null = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: ontologyGroup?.type || undefined,\n        displayColor: selectedOntology?.display_color || ''\n      };\n      if (ontologyGroup?.type === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        info = {\n          ...info,\n          pointCategory: categories[selectedCategoryIndex]?.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id as number)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n\n  const annotatedPointOrShapeCount = useMemo(() => (\n    Object.entries(shapes).filter(([, v]) => v !== undefined).length\n  ), [shapes]);\n\n  const totalPointCount = useMemo(() => (\n    ontologyGroup?.count || 0\n  ), [ontologyGroup]);\n\n  const instancesReviewsMap = useObserver(() => {\n    const map: InstancesReviewsMap = {};\n    store.review.reviews.forEach((review) => {\n      const { frameIndex, instanceId, groupName, shapeIds, result } = review;\n      const category = instances[instanceId]?.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0,\n        };\n      }\n\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n\n  useEffect(() => {\n    onLoad();\n  }, []);\n\n  const getInstance = (instanceId: string) => displayedInstances[instanceId];\n\n  const getGroup = (instanceId: string, groupName: string, frameIndex: number = currentFrame) => {\n    const instance = getInstance(instanceId);\n    const group = instance?.children.find((g) => g.name === groupName)?.frames[frameIndex];\n    return group;\n  };\n\n  const getShape = (instanceId: string, groupName: string, id: string | number, frameIndex: number = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? (group.shapes as Points)[id] : (group.shapes as CurrentShapes)[id]);\n  };\n\n  const setInstance = (id: string, instance?: InstanceAct) => {\n    setInstances({\n      ...instances,\n      [id]: instance!\n    });\n  };\n\n  const setShape = (frameIndex: number, instanceId: string, groupName: string, id: number | string, shapeType: LandmarkEditType, shape?: Point | Rectangle) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      let group = instance.children.find((g) => g.name === groupName);\n      let currentGroup = group?.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape: Point | Rectangle | undefined;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = ((currentGroup as Frame).shapes as Points)[id as number];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = ((currentGroup as Frame).shapes as CurrentShapes)[id];\n      }\n\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete ((currentGroup as Frame).shapes as Points)[id as number];\n        } else {\n          delete ((currentGroup as Frame).shapes as CurrentShapes)[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count + 1 : 1;\n        }\n        (currentGroup as Frame).shapes = {\n          ...(currentGroup as Frame).shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if (groupInfo?.label_config && (currentGroup as Frame).count === groupInfo.count && !(currentGroup as Frame).attributes) {\n        handleFormConfig(groupInfo.label_config, {}, { instanceId, category: instance.category, groupName });\n      }\n    }\n  };\n\n  const updateStatus = async (curr: Status[], prev: Status[]) => {\n    let newUpdatedShapes: UpdatedShape[] = [];\n    let newUpdatedCategories: KeypointCategoryProps[] = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const { frameIndex, instanceId, groupName, category, index, id, shapeType } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        let keyObj: { id: string } | { index: number } | undefined;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = { index };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = { id };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({ ...frameGroup, ...keyObj, shapeType });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          const instanceIndex = instanceIds.findIndex((v) => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, frameIndex, groupName, attributes } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance?.children.find((v) => v.name === groupName);\n          if (newInstance && newGroup) {\n            (newGroup.frames[frameIndex] as Frame).attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'shape') {\n        const { instanceId, groupName, category, index, id, shapeType, shape, frameIndex } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape as Point;\n            const { pointCategory, isKeyPoint, visible, attributes } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex((p) => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape: Point = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: { ...point.position },\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, index, shape: updateShape, shapeType });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape as Rectangle;\n            const { displayColor, visible, x, y, width, height } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle: Rectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible,\n            };\n            const updateIndex = newUpdatedShapes.findIndex((rect) => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, id, shape: updateRectangle, shapeType });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const { frameIndex, pointCategory, shape } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3],\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const { updateShapes, updatedCategories: newCategories } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          newUpdatedCategories = [\n            ...newUpdatedCategories,\n            ...newCategories\n          ];\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, groupName, attributes, frameIndex } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach((id) => {\n            const attrLayer = canvas.current?.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              canvas.current?.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          (newGroup.frames[frameIndex] as Frame).attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    setUpdatedShapes(newUpdatedShapes);\n  };\n\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({ message: 'Undo successfully.' });\n      }\n    }\n  };\n\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({ message: 'Redo successfully.' });\n      }\n    }\n  };\n\n  const handleChangeDrawMode = (mode: boolean) => {\n    if (store.review.isEditable) {\n      canvas.current?.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const { instanceId, category, groupName } = selectedShapeStatus;\n        setSelectedShape(undefined, { instanceId, category, groupName });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n\n  const loadInitialData = async () => {\n    let data;\n    const { initial_result: initialResult } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n\n  const addInstance = async (ontologyName: string) => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter((v) => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n\n      const children = ontologyItem.children.map((v) => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({ [id]: instance });\n      await handleInstanceChange({ [id]: instance });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, { category: ontologyName, shapeType: ontologyItem.children[0].type });\n      }\n    }\n  };\n\n  const addInstanceInFrame = (instanceId: string, groupName?: string) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex((group) => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame: Frame | undefined;\n          Object.keys(newInstance.children[groupIdx].frames).forEach((i) => {\n            const index = Number(i);\n            const frame = { ...newInstance.children[groupIdx].frames[index] };\n            frame.shapes = { ...frame.shapes };\n            if (frame?.count && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx: number | undefined;\n        Object.keys(instancesFrames[instanceId]).forEach((i) => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach((group) => {\n            const copyFrame = { ...group.frames[copyFrameIdx as number] };\n            copyFrame.shapes = { ...copyFrame.shapes };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const { updateShapes, updatedCategories: newUpdatedCategories } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({ [instanceId]: newInstance });\n      setUpdatedCategories(newUpdatedCategories);\n      setUpdatedShapes(updateShapes);\n    }\n  };\n\n  const removeInstanceFrames = (type: DELETETYPE, instance: InstanceAct, name?: string) => {\n    if (instance) {\n      let delShapes: UpdatedShape[] = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance: InstanceAct, frameIndex: number) => {\n        updateInstance.children.forEach((group) => {\n          if ((name && name === group.name) || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= (group.frames[frameIndex] as Frame).count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({ length: frames.length - diffFrame }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const { updateShapes } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [\n            ...delShapes,\n            ...updateShapes\n          ];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter((v) => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      setUpdatedShapes(delShapes);\n      handleInstanceChange({ [newInstance.id]: newInstance });\n    }\n  };\n\n  const handleInstanceChange = async (\n    newInstances: {[id: string] : InstanceAct},\n    status?: {before: Status[], after: Status[]}\n  ) => {\n    const ids = Object.keys(newInstances);\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async (id) => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach((child) => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({ type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance,\n          }\n        });\n        after.push({ type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n\n  const onLoad = async () => {\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n\n    let result;\n    let initialData: any;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({ message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({ frames: props.image, imageData: result?.images as Image[] });\n    // preload image\n    setImagePreloader(loader(framesData.map((v) => v.url)));\n    // set frame images\n    setFrames(framesData);\n\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes: { [categoryKey: string]: CategoryPathShape } = {};\n        result.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height,\n      });\n    }\n\n    // load reviews\n    await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData: { [key: string]: CategoryPathShape } = {};\n        initialData.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const { newInstances, categoryInstancesMap: newCategoryInstancesMap } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances: {[id: string]: InstanceAct} = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const { newInstances } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    saverRef.current?.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = (frameIndex: number, currentInstances: {[id: string]: InstanceAct} | undefined = instances, type?: CANVASSTATUS) => {\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    const currentInstanceList = Object.values(currentInstances);\n    canvas.current?.cleanLayer();\n    canvas.current?.setMultiShapesUnselected();\n    imagePreloader?.preload(frameIndex);\n    setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex,\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const { id, category, children: [{ name }] } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group?.type,\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const { updateShapes, updatedCategories: updatedCategoriesData } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    setUpdatedShapes(updateShapes);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n\n  const onSave = async (submit = true) => {\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({ message: loadError });\n      throw new Error(loadError);\n    }\n\n    saverRef.current?.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances: InstanceListItem[] = instanceList.filter((v) => v && v.notEmpty).map((instance) => {\n      const { id, category, number, displayColor, children } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map((group) => {\n          const { frames: groupFrames } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter((v) => !!v && v.count > 0).map((frameGroup) => {\n              if (frameGroup) {\n                const { frameIndex, count, shapes: groupShapes } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes: PointListItem[] | Rectangle[] = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach((key) => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point: PointListItem | undefined = groupShapes && (groupShapes as Points)[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        (newShapes as PointListItem[]).push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle: Rectangle | undefined = groupShapes && (groupShapes as CurrentShapes)[key];\n                      if (rectangle) (newShapes as Rectangle[]).push(rectangle);\n                    }\n                  });\n                }\n                if (\n                  checkMissingPoints &&\n                  frames[frameIndex].valid !== false &&\n                  groupInfo &&\n                  newShapes.length < groupInfo.count\n                ) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: ontologyInfo?.display_name || ontologyInfo?.class_name,\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({ message: errMsg });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: canvas.current?.imageCanvas?.width || imageSize?.width,\n      height: canvas.current?.imageCanvas?.height || imageSize?.height,\n      instances: newInstances,\n      categoryPathShapes: Object.keys(categoryPathShapes).map((pointCategory) => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory],\n      })),\n      images: frames,\n      statistics,\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes: {\n      [shape: string]: { rejected: number; approved: number, suspended: number, missed: number, total: number };\n    } = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0,\n    };\n    const reviews = store.review.reviews.filter((r) => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          statShapes[shape].total += 1;\n          objects.total += 1;\n          const review = reviews.find((r) => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          if (review?.result === ReviewResult.REJECT) {\n            statShapes[shape].rejected += 1;\n            objects.rejected += 1;\n          } else if (review?.result === ReviewResult.SUSPEND) {\n            statShapes[shape].suspended += 1;\n            objects.suspended += 1;\n          } else {\n            statShapes[shape].approved += 1;\n            objects.approved += 1;\n          }\n        }\n      }\n    }\n    return { objects, shapes: statShapes };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const { ontology } = store.ontology;\n    const data: Statistic = {\n      elements: [],\n      categories: ontology.map(({ class_name: className }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set(),\n    };\n\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, category, children } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [id],\n              category,\n              shape,\n              count: 1,\n              distinctCount: 1,\n            };\n          } else {\n            data.summary[key].count += 1;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += 1;\n              data.summary[key].ids.push(id);\n            }\n          }\n          if (frameShapes.length > 0) {\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push({\n              id,\n              shape,\n              frame: frame.frameIndex + 1,\n              category,\n            });\n          }\n        }\n      }\n    }\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({ category, shape, count, distinctCount }) => ({\n        category,\n        shape,\n        count,\n        distinctCount,\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n    };\n  };\n\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n\n  const saveReviews = (type = 'submit') => {\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find((review) => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    saverRef.current?.disableLeaveCheck();\n    return props.jobProxy.saveReviews(store.review.reviews);\n  };\n\n  const handleSave = async () => {\n    const { toolMode } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n\n    try {\n      await onSave(false);\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({ message: formatMessage('SAVE_SUCCESS') });\n    } catch (e) {\n      notification.error({ message: formatMessage('SAVE_FAIL') });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const { hasCustomError, blockSubmitErrors } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n\n  const setSelectedShape = (id?: number | string, groupData?: Group) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const { instanceId, category, groupName, shapeType } = groupData;\n      if (instanceId !== selectedInstance?.id) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || ontologyGroup?.type || undefined,\n        groupName,\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n\n  const setNextEmptyShape = (shapeStatus: ShapeInfo = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let { id } = shapeStatus;\n      const { instanceId, groupName, shapeType } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const { range = [] } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            (id as number) += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id!) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n\n  const onShapesUpdated = () => {\n    setUpdatedShapes([]);\n  };\n\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n\n  const handleShapesChange = (\n    newShapes: UpdatedShape[],\n    groupsAttributes?: { instanceId: string, category: string, name: string, attributes: any }[],\n    status?: {before: Status[], after: Status[]}\n  ) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    const { instanceId, groupName } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData(newInstance?.category || '', groupName);\n    newInstance?.children.forEach((child) => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {},\n          };\n        };\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const { id, frameIndex, index, shape } = newShapes[i];\n          let oldShape;\n\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = (child.frames[frameIndex].shapes as Points)[index];\n            (child.frames[frameIndex].shapes as Points)[index] = {\n              ...oldShape,\n              ...shape as Point\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            (child.frames[frameIndex].shapes as CurrentShapes)[id] = {\n              ...oldShape,\n              ...shape as Rectangle\n            };\n          }\n\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        };\n        if (groupInfo?.label_config && currentGroup.count === groupInfo?.count && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, { instanceId, category: newInstance.category, groupName });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({ instanceId: id, name, category, attributes }) => {\n        const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId: id, category, groupName: name };\n        before.push({ type: 'group', status: { ...frameGroup } });\n        after.push({ type: 'group', status: { ...frameGroup, attributes } });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({ [instanceId]: newInstance }, { before, after });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n\n  const handleShapesRemove = (removeShapes: UpdatedShape[]) => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n\n    const changeInstances: { [id: string]: InstanceAct } = {};\n    const { instanceId, groupName } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance?.children.forEach((child) => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({ id, frameIndex, index }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete (child.frames[frameIndex].shapes as Points)[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({ [instanceId]: newInstance });\n    }\n  };\n\n  const togglePointsVisibility = (points: PointStatus[]) => {\n    const list: UpdatedShape[] = [];\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: { ...point, visible: !point.visible }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n\n  const setCategoryPathShape = (categoryKey: string, shapeType?: CategoryPathShape, _updatedShapes?: UpdatedShape[]) => {\n    const before: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: categoryPathShapes[categoryKey] },\n    }];\n    const after: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: shapeType },\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, { before, after });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n\n  const selectGroup = (id: string, groupName: string, isFit = true, groupData?: { category: string, shapeType: LandmarkEditType }) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus:ShapeInfo = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: groupData?.category || selectedShapeStatus.category,\n      groupName,\n      shapeType: groupData?.shapeType || undefined,\n      id: undefined\n    };\n    if (instance) {\n      const ontologyItem = store.ontology.ontology.find((v) => v.class_name === instance.category);\n      const group = ontologyItem?.children.find((v) => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = group?.type || undefined;\n      if (isDrawMode) {\n        if (group?.type === LandmarkEditType.KEYPOINT) {\n          const index = (group.categories && group.categories[0] && group.categories[0].range[0]) || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if (group?.type === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach((child) => {\n            if (child.name === groupName && child.frames[currentFrame]?.shapes) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      canvas.current?.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        canvas.current?.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n\n  const editShapeForm = () => {\n    const { instanceId, groupName, shapeType, id, category } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, (id as number));\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && currentOntologyGroup?.point_label_config) {\n        handleFormConfig(currentOntologyGroup.point_label_config, (point as Point).attributes || {}, { instanceId, category, groupName }, (id as number), point);\n      }\n    }\n  };\n\n  const editGroupForm = () => {\n    const { instanceId, groupName, category } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && currentOntologyGroup?.label_config) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, { instanceId, category, groupName });\n    }\n  };\n\n  const handleFormConfig = (config: FormConfig, values: {[attr: string]: any;}, group: Group, index?: number, point?: Point) => {\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point,\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    attributesRef.current?.showModal(title);\n  };\n\n  const getShapeLabel = (instanceId: string, category: string, groupName: string) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', { values: { frameIndex: currentFrame + 1 } })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n\n  const setAttributes = (values: any) => {\n    if (editFormObject) {\n      const { instanceId, category, groupName, index, point } = editFormObject;\n      const before: Status[] = [];\n      const after: Status[] = [];\n      const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId, category, groupName };\n      if ((index || index === 0) && point) {\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = { ...oldPoint, ...point, attributes: values };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({ type: 'shape', status: { ...frameGroup, index, shape: oldPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        after.push({ type: 'shape', status: { ...frameGroup, index, shape: newPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        canvas.current?.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName)?.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup?.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({ type: 'group', status: { ...frameGroup, attributes: oldAttrs } });\n          after.push({ type: 'group', status: { ...frameGroup, attributes: values } });\n          if (oldGroup?.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach((id) => {\n                canvas.current?.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode: AttributesMode, type = 'object') => {\n    canvas.current?.updatelabelVisible(activeMode, type);\n  };\n\n  const onSizeChange = () => {\n    canvas.current?.resizeShapes();\n  };\n\n  const onFilterChange = () => {\n    canvas.current?.updateFilters();\n  };\n\n  const onLabelModeChange = () => {\n    if (canvas.current?.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n\n  const onGridVisibleChange = () => {\n    if (canvas.current?.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n\n  const setFrameValid = (frame: number, valid: boolean) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n\n  const getScriptResult = async () => {\n    let resultLink = '';\n    if (store.setting.customCheck) {\n      if (typeof props.jobProxy.reviewFrom === 'string') {\n        resultLink = props.jobProxy.reviewFrom;\n      }\n      if (!isAnnotationReadonly(props.jobProxy.toolMode)) {\n        try {\n          resultLink = await onSave(false);\n        } catch (e) {\n          resultLink = '';\n        }\n      }\n    }\n\n    const [result] = await Promise.all([\n      validate(store.setting.customCheck, {\n        resultLink,\n      }),\n      new Promise((resolve) => {\n        setTimeout(resolve, 300);\n      }),\n    ]);\n    if (result) {\n      store.review.setScriptResult(result as {results: IWarning[]; hasCustomError: boolean});\n    }\n  };\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics,\n  }));\n\n  return (\n    <Observer>\n      {() => (\n        <div className=\"landmark-annotation-app\">\n          <AutoSaver\n            ref={saverRef}\n            leaveCheck\n            data={{ instance: instances, reviews: store.review.qaWarnings }}\n            save={handleSave}\n          />\n          <Toolbar\n            readonly={readonly || loading || isReview}\n            isReview={isReview}\n            isPreview={readonly}\n            initialDataLength={Object.keys(initialInstances).length}\n            onAttributesModeChanges={onAttributesModeChanges}\n            onSizeChange={onSizeChange}\n            onFilterChange={onFilterChange}\n            onLabelModeChange={onLabelModeChange}\n            onGridVisibleChange={onGridVisibleChange}\n            onSave={handleSave}\n            handleUndo={handleUndo}\n            handleRedo={handleRedo}\n            setReview={setReview}\n            handleChangeDrawMode={handleChangeDrawMode}\n          />\n          <div\n            className=\"container\"\n            style={{\n              height: `calc(100% - ${(frames.length > 1 && currentFrame >= 0) ? `${frameControlHeight + 35}px` : '35px'})`,\n              transition: 'height 0.15s',\n            }}\n          >\n            <TabMenu\n              tabs={[\n                {\n                  title: formatMessage('MENU_INSTANCE'),\n                  key: 'instance',\n                  count: 0,\n                  content: (\n                    <SideMenus\n                      readonly={readonly || loading || isReview || !isDrawMode}\n                      loading={loading}\n                      instances={instanceList}\n                      currentFrame={currentFrame}\n                      instancesFrames={instancesFrames}\n                      selectedInstance={selectedInstance}\n                      selectedOntologyGroup={selectedOntologyGroup}\n                      instancesReviewsMap={instancesReviewsMap}\n                      addInstance={addInstance}\n                      selectGroup={selectGroup}\n                      addInstanceInFrame={addInstanceInFrame}\n                      removeInstanceFrames={removeInstanceFrames}\n                    />\n                  )\n                },\n                {\n                  title: formatMessage('MENU_WARNING'),\n                  key: 'validator',\n                  count: store.review.warnings.length,\n                  content: (\n                    <Validator\n                      ref={validatorRef}\n                      instances={instances}\n                      jobProxy={props.jobProxy}\n                      getScriptResult={getScriptResult}\n                      warnings={store.review.warnings || []}\n                      setFrame={setFrame}\n                      setSelectedShape={setSelectedShape}\n                      selectGroup={selectGroup}\n                      getInstance={getInstance}\n                      saveResult={() => onSave(false)}\n                    />\n                  )\n                }\n              ]}\n            />\n            {selectedInstance && ontologyGroup && !isReview && (\n              <Board\n                categories={categories}\n                categoryPathShapes={displayedCategoryPathShapes}\n                points={shapes}\n                ontologyGroup={ontologyGroup}\n                selectedShapeStatus={selectedShapeStatus}\n                selectedShapes={selectedShapes as number[]}\n                annotated={annotatedPointOrShapeCount}\n                total={totalPointCount}\n                drawMode={isDrawMode}\n                setSelectedShape={(id) => {\n                  const { instanceId, category, groupName } = selectedShapeStatus;\n                  setSelectedShape(id, { instanceId, category, groupName });\n                }}\n                frameControlHeight={frameControlHeight}\n                readonly={loading}\n                instanceReviewsMap={store.review.frameReviewsMap[currentFrame]}\n              />\n            )}\n            <Canvas\n              ref={canvas}\n              readonly={readonly}\n              loading={loading}\n              isReview={isReview}\n              currentFrame={currentFrame}\n              image={frames[currentFrame]?.url}\n              categories={categories}\n              selectedInstance={selectedInstance}\n              selectedGroupName={selectedOntologyGroup}\n              ontologyGroup={ontologyGroup}\n              annotatedPointOrShapeCount={annotatedPointOrShapeCount}\n              updatedShapes={updatedShapes}\n              updatedCategories={updatedCategories}\n              defaultInstances={defaultInstances}\n              selectedShapeStatus={selectedShapeStatus}\n              selectedShapeInfo={selectedShapeInfo}\n              warnings={store.review.qaWarnings}\n              undoPointer={store.undo.actionPointer}\n              changeLoading={setLoading}\n              selectGroup={selectGroup}\n              setSelectedShape={setSelectedShape}\n              setMultiSelectedShape={setSelectedShapes}\n              handleShapesChange={handleShapesChange}\n              onShapesUpdated={onShapesUpdated}\n              onCategoriesUpdated={onCategoriesUpdated}\n              handleShapesRemove={handleShapesRemove}\n              togglePointsVisibility={togglePointsVisibility}\n              setNextEmptyShape={setNextEmptyShape}\n              editShapeForm={editShapeForm}\n              editGroupForm={editGroupForm}\n              onSave={handleSave}\n              getInstance={getInstance}\n              categoryPathShapes={displayedCategoryPathShapes}\n              setCategoryPathShape={setCategoryPathShape}\n              handleUndo={handleUndo}\n              handleRedo={handleRedo}\n              setReview={setReview}\n              handleChangeDrawMode={handleChangeDrawMode}\n            />\n            <div className=\"arributes-panel\">\n              {selectedShapeStatus.groupName && (\n                <Information\n                  pointCategory={(categories[selectedCategoryIndex] || {}).name}\n                  point={selectedShapeStatus}\n                  annotated={annotatedPointOrShapeCount}\n                  total={totalPointCount}\n                />\n              )}\n              {frames[currentFrame]?.url && (\n                <FrameAttributes\n                  currentFrame={currentFrame}\n                  currentFrameValid={frames[currentFrame].valid}\n                  setFrameValid={setFrameValid}\n                />\n              )}\n            </div>\n            <Attributes\n              ref={attributesRef}\n              readonly={readonly || isReview || !isDrawMode}\n              config={formConfig}\n              values={formValues}\n              onValuesChange={setAttributes}\n            />\n          </div>\n          {(frames.length > 1 && currentFrame >= 0) && (\n            <FrameControl\n              frames={frames}\n              frameLoading={loading}\n              currentFrame={currentFrame}\n              categoryInstancesMap={displayedCategoryInstancesMap}\n              instancesReviewsMap={instancesReviewsMap}\n              instances={displayedInstances}\n              selectedInstance={selectedInstance}\n              selectedInstanceGroup={selectedOntologyGroup}\n              selectGroup={selectGroup}\n              setFrame={setFrame}\n              onHeightChange={setFrameControlHeight}\n            />\n          )}\n          {store.review.selectedReview && (\n            <QualityControl\n              review={store.review.selectedReview}\n              readonly={readonly || isDrawMode}\n              jobProxy={props.jobProxy}\n              selectedShapeStatus={selectedShapeStatus}\n              getShapeLabel={getShapeLabel}\n            />\n          )}\n        </div>\n      )}\n    </Observer>\n  );\n});\n\nexport default LandmarkAnnotation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}