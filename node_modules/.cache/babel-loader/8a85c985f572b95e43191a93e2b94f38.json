{"ast":null,"code":"import { makeAutoObservable, reaction, runInAction, toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport { message, notification } from 'antd';\nimport { Base64 } from 'js-base64';\nimport CamerasMapping from '../cameras-mapping/CamerasMapping';\nimport View, { EventAction } from '../shapes/View';\nimport NIFTIView from '../shapes/NIFTIView';\nimport DICOMView from '../shapes/DICOMView';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_FRAME_IMAGE_NAME, SIDEBAR_WIDTH, TOOLBAR_HEIGHT } from '../constants';\nimport { isPDFUrl, isVideoUrl, parseFramesByPaylod, parseLabelConfig } from '../utils';\nimport { ViewMode, ReviewMode, PixelToolMode } from '../types';\nimport i18n from '../locales';\nimport { ShapeRotateMode } from '../../common/shapes/Shape';\nimport Pixel from '../../common/shapes/Pixel';\nimport loader from '../../../utils/image-preloader';\nimport { triggerFormRules } from '../../../utils/form';\nimport NIFTIParser, { Plane } from '../../../libs/nifti/NIFTIParser';\nimport DICOMParser from '../../../libs/dicom/DICOMParser';\nimport PDFLoader from '../../../libs/pdf/PDFLoader';\nimport { estimateFPS, getDuration } from '../../../utils/video';\n\n/**\n * store for frames\n * @class\n */\nexport default class FrameStore {\n  /**\n   * is single camera\n   * @getter\n   */\n  get isSingleCamera() {\n    return this.cameraCount === 1;\n  }\n\n  /**\n   * camera names\n   * @getter\n   */\n  get cameraNames() {\n    return Object.keys(this.cameraFrames);\n  }\n\n  /**\n   * camera count\n   * @getter\n   */\n  get cameraCount() {\n    return this.cameraNames.length;\n  }\n\n  /**\n   * current camera frame count\n   * @getter\n   */\n  get frameCount() {\n    return this.cameraFrames[this.currentCamera];\n  }\n\n  /**\n   * current camera frame index\n   * @getter\n   */\n  get currentFrame() {\n    return this.currentFrameByCamera[this.currentCamera];\n  }\n\n  /**\n   * current camera image name\n   * @getter\n   */\n  get currentCameraImage() {\n    return this.currentImageByCamera[this.currentCamera] || DEFAULT_FRAME_IMAGE_NAME;\n  }\n\n  /**\n   * current camera image boundary\n   * @getter\n   */\n  get imageBounds() {\n    return this.getImageBoundsForCamera(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * current frame rotation, default is 0\n   * @getter\n   */\n  get currentFrameRotation() {\n    return this.getFrameRotationForCamera(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current frame valid, default is valid\n   * @getter\n   */\n  get currentFrameValid() {\n    return this.isFrameValidForCamera(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current common frame valid, default is valid\n   * @getter\n   */\n  get currentCommonFrameValid() {\n    return this.isCommonFrameValid(this.currentFrame);\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  get currentFrameAttributes() {\n    var _this$attributes$this;\n    const {\n      attributes = {}\n    } = ((_this$attributes$this = this.attributes[this.currentCamera]) === null || _this$attributes$this === void 0 ? void 0 : _this$attributes$this[this.currentFrame]) || {};\n    return attributes;\n  }\n\n  /**\n   * invalid frame indexes in summary (just current camera)\n   * @getter\n   */\n  get invalidFrames() {\n    const invalidFrames = new Set();\n    Array.from({\n      length: this.frameCount\n    }).forEach((item, frameIndex) => {\n      if (!this.isCommonFrameValid(frameIndex)) {\n        invalidFrames.add(frameIndex);\n      }\n    });\n    return Array.from(invalidFrames);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * frame count by camera\n     */\n    this.cameraFrames = {};\n    /**\n     * all camera images\n     */\n    this.cameraImages = {};\n    /**\n     * frame image embedding urls\n     */\n    this.imageEmbeddings = {};\n    /**\n     * nifti parser\n     */\n    this.niftiParser = void 0;\n    /**\n     * dicom parser\n     */\n    this.dicomParser = void 0;\n    /**\n     * pdf documents cache\n     */\n    this.pdfCache = {};\n    /**\n     * video cache\n     */\n    this.videoCache = {};\n    /**\n     * project worker\n     */\n    this.camerasMapping = new CamerasMapping();\n    /**\n     * camera views\n     */\n    this.cameraViews = {};\n    /**\n     * current active camera\n     */\n    this.currentCameraView = null;\n    /**\n     * frame attributes (for each camera)\n     */\n    this.attributes = {};\n    /**\n     * initial frame attributes (for each camera)\n     */\n    this.initialAttributes = {};\n    /**\n     * frame attributes (for all cameras)\n     */\n    this.frameAttributes = {};\n    /**\n     * initial frame attributes (for all cameras)\n     */\n    this.initialFrameAttributes = {};\n    /**\n     * next shape orders for different cameras & frames\n     */\n    this.nextShapeOrders = {};\n    /**\n     * current camera name\n     */\n    this.currentCamera = DEFAULT_CAMERA_NAME;\n    /**\n     * current frame by camera\n     */\n    this.currentFrameByCamera = {};\n    /**\n     * current image name by camera\n     */\n    this.currentImageByCamera = {};\n    /**\n     * current time for video\n     */\n    this.currentVideoTime = 0;\n    /**\n     * frame loading\n     */\n    this.loading = true;\n    /**\n     * is playing\n     */\n    this.isPlaying = false;\n    /**\n     * video element if is playing a video\n     */\n    this.playingVideo = void 0;\n    /**\n     * play timer\n     */\n    this.playTimer = null;\n    /**\n     * image preloader\n     */\n    this.imagePreloader = null;\n    /**\n     * frame config (for each camera)\n     */\n    this.frameConfig = void 0;\n    /**\n     * frame config validity (for each camera)\n     */\n    this.frameConfigValidity = void 0;\n    /**\n     * frame config (for all cameras)\n     */\n    this.commonFrameConfig = void 0;\n    /**\n     * frame config common validity (for all cameras)\n     */\n    this.commonFrameConfigValidity = void 0;\n    /**\n     *  image filters preset\n     */\n    this.imageFiltersPresets = void 0;\n    /**\n     * camera image filters\n     */\n    this.cameraFilters = {};\n    /**\n     * get next shape order & do increment\n     * @param layer\n     * @param frameIndex\n     * @param camera\n     */\n    this.getNextShapeOrder = (layer = this.rootStore.config.activeLayerIndex, frameIndex = this.currentFrame, camera = this.currentCamera) => {\n      if (this.nextShapeOrders[camera] === undefined) {\n        this.nextShapeOrders[camera] = {};\n      }\n      if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n        this.nextShapeOrders[camera][frameIndex] = [];\n      }\n      if (this.nextShapeOrders[camera][frameIndex][layer] === undefined) {\n        this.nextShapeOrders[camera][frameIndex][layer] = this.rootStore.segmentation.enabled ? 1 : 0;\n      }\n      const order = this.nextShapeOrders[camera][frameIndex][layer];\n      this.nextShapeOrders[camera][frameIndex][layer] += 1;\n      return order;\n    };\n    makeAutoObservable(this, {\n      rootStore: false,\n      imageEmbeddings: false,\n      niftiParser: false,\n      dicomParser: false,\n      pdfCache: false,\n      videoCache: false,\n      camerasMapping: false,\n      cameraViews: false,\n      nextShapeOrders: false,\n      playingVideo: false,\n      playTimer: false,\n      imagePreloader: false,\n      imageBounds: false,\n      initialAttributes: false,\n      initialFrameAttributes: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  async init(payload) {\n    // parse frame config\n    this.frameConfig = parseLabelConfig(payload.frame_config);\n    this.commonFrameConfig = parseLabelConfig(payload.frame_config_common);\n    if (payload.frame_config_validity) {\n      try {\n        this.frameConfigValidity = JSON.parse(payload.frame_config_validity);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('PAYLOAD_ERROR_INVALID_VALIDITY', {\n            values: {\n              validity: payload.frame_config_validity\n            }\n          })\n        });\n      }\n    }\n    if (payload.frame_config_common_validity) {\n      try {\n        this.commonFrameConfigValidity = JSON.parse(payload.frame_config_common_validity);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('PAYLOAD_ERROR_INVALID_VALIDITY', {\n            values: {\n              validity: payload.frame_config_common_validity\n            }\n          })\n        });\n      }\n    }\n    if (payload.image_filters_preset_config) {\n      try {\n        this.imageFiltersPresets = JSON.parse(Base64.decode(payload.image_filters_preset_config));\n      } catch (error) {\n        this.imageFiltersPresets = undefined;\n      }\n    }\n    const {\n      cameras = [],\n      niftiUrl,\n      dicomDirUrl\n    } = await parseFramesByPaylod(payload, this.rootStore);\n    if (niftiUrl) {\n      this.niftiParser = new NIFTIParser(niftiUrl);\n      await this.niftiParser.load();\n      [Plane.AXIAL, Plane.SAGITTAL, Plane.CORONAL].forEach(cameraKey => {\n        this.createCameraView(cameraKey);\n        const frameCount = this.niftiParser.getPlaneDimension(cameraKey);\n        this.cameraFrames[cameraKey] = frameCount;\n        this.cameraImages[cameraKey] = Array.from({\n          length: frameCount\n        }).map(() => ({}));\n        this.currentFrameByCamera[cameraKey] = Math.floor(frameCount / 2);\n      });\n      this.setDefaultAttributes();\n      this.setCamera(Plane.AXIAL);\n\n      // 设置nifti store\n      this.rootStore.initNIFTIStore();\n      // 禁用一部分功能\n      this.rootStore.config.viewRotatable = false;\n      return;\n    }\n    if (dicomDirUrl) {\n      this.dicomParser = new DICOMParser(dicomDirUrl);\n      await this.dicomParser.load();\n      const allCameras = Object.keys(this.dicomParser.cameras);\n      allCameras.forEach(cameraKey => {\n        const cameraView = this.createCameraView(cameraKey);\n        cameraView.images = this.dicomParser.cameras[cameraKey].images;\n        cameraView.imageIndex = 0;\n        this.cameraFrames[cameraKey] = cameraView.images.length;\n        this.cameraImages[cameraKey] = Array.from({\n          length: cameraView.images.length\n        }).map(() => ({}));\n        this.currentFrameByCamera[cameraKey] = cameraView.imageIndex;\n      });\n      this.setDefaultAttributes();\n      this.setCamera(allCameras[0]);\n\n      // 禁用一部分功能\n      this.rootStore.config.viewRotatable = false;\n      return;\n    }\n    let preload = true;\n    let pdfLoader;\n    for (let i = 0; i < cameras.length; i += 1) {\n      const {\n        camera,\n        images,\n        data\n      } = cameras[i];\n      if (images.length === 1) {\n        const imageNames = Object.keys(images[0]);\n        for (let j = 0; j < imageNames.length; j += 1) {\n          const name = imageNames[j];\n          const url = images[0][name];\n          if (isPDFUrl(url)) {\n            preload = false;\n            if (!pdfLoader) {\n              pdfLoader = new PDFLoader();\n              try {\n                // eslint-disable-next-line no-await-in-loop\n                await pdfLoader.init({\n                  basic: true\n                });\n              } catch (e) {\n                // eslint-disable-next-line no-console\n                console.log('PDF loader init error');\n              }\n            }\n            try {\n              // eslint-disable-next-line no-await-in-loop\n              const {\n                pdfDocument\n              } = await pdfLoader.load(this.rootStore.proxyResource(url));\n              if (!this.pdfCache[camera]) {\n                this.pdfCache[camera] = {};\n              }\n              this.pdfCache[camera][name] = pdfDocument;\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.log('Failed to load PDF:', url);\n            }\n          } else if (isVideoUrl(url)) {\n            var _data$fps, _data$duration;\n            preload = false;\n            const video = document.createElement('video');\n            video.src = this.rootStore.proxyResource(url);\n            video.crossOrigin = 'anonymous';\n            // for cached video, should muted, only used for capture image\n            video.muted = true;\n            // eslint-disable-next-line no-await-in-loop\n            const fps = (_data$fps = data === null || data === void 0 ? void 0 : data.fps) !== null && _data$fps !== void 0 ? _data$fps : await estimateFPS(video);\n            // eslint-disable-next-line no-await-in-loop\n            const duration = (_data$duration = data === null || data === void 0 ? void 0 : data.duration) !== null && _data$duration !== void 0 ? _data$duration : await getDuration(video);\n            // last frame duration <= 1/FPS\n            const totalFrames = Math.ceil(fps * duration);\n            if (!this.videoCache[camera]) {\n              this.videoCache[camera] = {};\n            }\n            this.videoCache[camera][name] = {\n              video,\n              fps,\n              totalFrames\n            };\n          }\n        }\n      }\n    }\n    cameras.forEach(({\n      camera,\n      images,\n      embeddings,\n      calibrations\n    }) => {\n      var _images$, _ref, _this$pdfCache$camera, _this$pdfCache$camera2, _this$pdfCache$camera3, _this$videoCache$came, _this$videoCache$came2;\n      const firstName = Object.keys((_images$ = images[0]) !== null && _images$ !== void 0 ? _images$ : {})[0];\n      const count = (_ref = (_this$pdfCache$camera = (_this$pdfCache$camera2 = this.pdfCache[camera]) === null || _this$pdfCache$camera2 === void 0 ? void 0 : (_this$pdfCache$camera3 = _this$pdfCache$camera2[firstName]) === null || _this$pdfCache$camera3 === void 0 ? void 0 : _this$pdfCache$camera3.totalPages) !== null && _this$pdfCache$camera !== void 0 ? _this$pdfCache$camera : (_this$videoCache$came = this.videoCache[camera]) === null || _this$videoCache$came === void 0 ? void 0 : (_this$videoCache$came2 = _this$videoCache$came[firstName]) === null || _this$videoCache$came2 === void 0 ? void 0 : _this$videoCache$came2.totalFrames) !== null && _ref !== void 0 ? _ref : images.length;\n      this.cameraFrames[camera] = count;\n      // update embeddings\n      this.imageEmbeddings[camera] = embeddings || [];\n      // set calibrations\n      this.camerasMapping.setCalibrations(camera, calibrations);\n    });\n    this.setDefaultAttributes();\n    await this.parseEmbeddings();\n    runInAction(() => {\n      if (cameras.length > 0) {\n        const cameraImagesList = {};\n        for (let i = 0; i < cameras.length; i += 1) {\n          const {\n            camera,\n            images\n          } = cameras[i];\n          cameraImagesList[camera] = images;\n          // setup camera container\n          this.createCameraView(camera);\n          // update current frame for camera\n          this.currentFrameByCamera[camera] = 0;\n        }\n        this.cameraImages = cameraImagesList;\n        // set current camera\n        this.setCamera(cameras[0].camera);\n        // preload image\n        if (preload) {\n          // 预加载仅加载每个相机每一帧的第一张图片\n          const allImages = Array.from({\n            length: Math.max(...Object.values(this.cameraFrames))\n          }).flatMap((_, i) => cameras.map(({\n            camera\n          }) => {\n            var _Object$values$, _cameraImagesList$cam, _cameraImagesList$cam2;\n            return this.rootStore.proxyResource((_Object$values$ = Object.values((_cameraImagesList$cam = (_cameraImagesList$cam2 = cameraImagesList[camera]) === null || _cameraImagesList$cam2 === void 0 ? void 0 : _cameraImagesList$cam2[i]) !== null && _cameraImagesList$cam !== void 0 ? _cameraImagesList$cam : {})[0]) !== null && _Object$values$ !== void 0 ? _Object$values$ : '');\n          }));\n          this.imagePreloader = loader(allImages);\n        }\n      }\n    });\n  }\n\n  /**\n   * update resource\n   * @param resource\n   */\n  async updateResource(resource) {\n    const {\n      cameras = [],\n      niftiUrl,\n      dicomDirUrl\n    } = await parseFramesByPaylod({\n      base_url: resource\n    });\n    if (niftiUrl || dicomDirUrl) {\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console.log(`Update resource from ${resource}. Parsed data:`, cameras);\n    cameras.forEach(({\n      camera,\n      images,\n      embeddings\n    }) => {\n      this.cameraImages[camera] = images;\n      if (embeddings && embeddings.length > 0) {\n        this.imageEmbeddings[camera] = embeddings;\n      }\n    });\n    if (this.imagePreloader) {\n      const frameCount = Math.max(...Object.values(this.cameraFrames));\n      const allImages = Array.from({\n        length: frameCount\n      }).flatMap((_, i) => cameras.map(({\n        camera\n      }) => {\n        var _Object$values$2, _this$cameraImages$ca, _this$cameraImages$ca2;\n        return this.rootStore.proxyResource((_Object$values$2 = Object.values((_this$cameraImages$ca = (_this$cameraImages$ca2 = this.cameraImages[camera]) === null || _this$cameraImages$ca2 === void 0 ? void 0 : _this$cameraImages$ca2[i]) !== null && _this$cameraImages$ca !== void 0 ? _this$cameraImages$ca : {})[0]) !== null && _Object$values$2 !== void 0 ? _Object$values$2 : '');\n      }));\n      this.imagePreloader.images = allImages;\n    }\n  }\n\n  /**\n   * parse embeddings from flow data\n   */\n  async parseEmbeddings() {\n    try {\n      var _this$rootStore$jobPr;\n      const flowData = JSON.parse(((_this$rootStore$jobPr = this.rootStore.jobProxy) === null || _this$rootStore$jobPr === void 0 ? void 0 : _this$rootStore$jobPr.flowData) || '');\n      const link = flowData === null || flowData === void 0 ? void 0 : flowData.appen_ai_image_2d_pre_embedding_sam;\n      if (link) {\n        const {\n          cameras = []\n        } = await parseFramesByPaylod({\n          base_url: link\n        });\n        cameras.forEach(({\n          camera,\n          embeddings\n        }) => {\n          embeddings === null || embeddings === void 0 ? void 0 : embeddings.forEach((embedding, index) => {\n            if (!this.imageEmbeddings[camera][index] && embedding) {\n              // update\n              this.imageEmbeddings[camera][index] = embedding;\n            }\n          });\n        });\n      }\n    } catch (e) {\n      // error\n    }\n  }\n\n  /**\n   * set default frame attributes\n   */\n  setDefaultAttributes() {\n    let defaultAttributes;\n    if (this.frameConfig) {\n      const {\n        updatedValues\n      } = triggerFormRules(this.frameConfig, {});\n      if (updatedValues && Object.keys(updatedValues).length > 0) {\n        defaultAttributes = updatedValues;\n      }\n    }\n    const attributes = {};\n    Object.keys(this.cameraFrames).forEach(camera => {\n      if (!attributes[camera]) {\n        attributes[camera] = {};\n      }\n      Array.from({\n        length: this.cameraFrames[camera]\n      }).forEach((_, frameIndex) => {\n        if (!attributes[camera][frameIndex]) {\n          attributes[camera][frameIndex] = {\n            frameIndex,\n            valid: true,\n            originValid: true,\n            rotation: 0\n          };\n        }\n        if (defaultAttributes) {\n          if (this.rootStore.annotatable) {\n            // save to attributes directly\n            attributes[camera][frameIndex].attributes = {\n              ...defaultAttributes\n            };\n          } else {\n            // just show attribute keys if no value\n            attributes[camera][frameIndex].attributes = {};\n            Object.keys(defaultAttributes).forEach(key => {\n              attributes[camera][frameIndex].attributes[key] = '';\n            });\n          }\n        }\n      });\n    });\n    this.attributes = attributes;\n    this.initialAttributes = attributes;\n    if (this.commonFrameConfig) {\n      const {\n        updatedValues\n      } = triggerFormRules(this.commonFrameConfig, {});\n      if (updatedValues && Object.keys(updatedValues).length > 0) {\n        // has default value\n        const frameAttributes = {};\n        const maxFrameCount = Math.max(...Object.values(this.cameraFrames));\n        for (let i = 0; i < maxFrameCount; i += 1) {\n          if (this.rootStore.annotatable) {\n            frameAttributes[i] = {\n              ...updatedValues\n            };\n          } else {\n            frameAttributes[i] = {};\n            Object.keys(updatedValues).forEach(key => {\n              frameAttributes[i][key] = '';\n            });\n          }\n        }\n        this.frameAttributes = frameAttributes;\n        this.initialFrameAttributes = frameAttributes;\n      }\n    }\n  }\n\n  /**\n   * init attributes\n   * @param result\n   */\n  initAttributes(result) {\n    this.clearAttributes();\n    const {\n      frames: attrs\n    } = result;\n    if (Array.isArray(attrs)) {\n      const attributes = toJS(this.attributes);\n      attrs.forEach(cameraItem => {\n        const {\n          camera,\n          frames\n        } = cameraItem || {};\n        if (camera) {\n          if (!attributes[camera]) {\n            attributes[camera] = {};\n          }\n          if (Array.isArray(frames)) {\n            frames.forEach(frameItem => {\n              const {\n                frameIndex,\n                imageUrl,\n                imageUrls,\n                imageWidth,\n                imageHeight,\n                valid,\n                originValid,\n                rotation,\n                attributes: frameAttributes,\n                ...legacyAttributes\n              } = frameItem;\n              attributes[camera][frameIndex] = {\n                ...attributes[camera][frameIndex],\n                frameIndex,\n                imageUrl,\n                imageUrls,\n                imageWidth,\n                imageHeight,\n                valid: valid !== false && valid !== 'false',\n                rotation: rotation % (Math.PI / 2) === 0 ? rotation : 0,\n                attributes: frameAttributes || Object.keys(legacyAttributes).length > 0 ? cloneDeep({\n                  ...legacyAttributes,\n                  ...frameAttributes\n                }) : undefined\n              };\n              if (originValid === undefined) {\n                attributes[camera][frameIndex].originValid = attributes[camera][frameIndex].valid;\n              } else {\n                attributes[camera][frameIndex].originValid = originValid;\n              }\n            });\n          }\n        }\n      });\n      this.attributes = attributes;\n    }\n    const {\n      frames: frameAttrs\n    } = (result === null || result === void 0 ? void 0 : result.attributes) || {};\n    if (Array.isArray(frameAttrs)) {\n      const frameAttributes = toJS(this.frameAttributes);\n      frameAttrs.forEach(item => {\n        const {\n          frameIndex,\n          attributes\n        } = item || {};\n        if (frameIndex !== undefined && !!attributes) {\n          frameAttributes[frameIndex] = attributes;\n        }\n      });\n      this.frameAttributes = frameAttributes;\n    }\n  }\n  clearAttributes() {\n    this.attributes = cloneDeep(this.initialAttributes);\n    this.frameAttributes = cloneDeep(this.initialFrameAttributes);\n  }\n\n  /**\n   * init tool config\n   * @param toolConfig\n   */\n  initToolConfig(toolConfig) {\n    if (toolConfig === null || toolConfig === void 0 ? void 0 : toolConfig.cameraFilters) {\n      this.cameraFilters = {\n        ...toolConfig.cameraFilters\n      };\n    }\n  }\n\n  /**\n   * create camera view\n   * @param camera\n   */\n  createCameraView(camera) {\n    var _this$rootStore$jobPr2;\n    const {\n      layers,\n      activeLayerIndex,\n      auxiliaryLines,\n      autoSnapPoint,\n      needThumbnailLayer,\n      canvasConfig\n    } = this.rootStore.config;\n    const options = {\n      id: camera,\n      layers,\n      enableThumbnail: needThumbnailLayer,\n      enableReview: (_this$rootStore$jobPr2 = this.rootStore.jobProxy) === null || _this$rootStore$jobPr2 === void 0 ? void 0 : _this$rootStore$jobPr2.loadReviewEnabled,\n      enableSnap: autoSnapPoint,\n      showGrid: canvasConfig.gridVisible,\n      gridSize: canvasConfig.gap,\n      ...(auxiliaryLines && {\n        auxiliaryLines\n      })\n    };\n    let cameraView;\n    if (this.niftiParser) {\n      cameraView = new NIFTIView(options);\n    } else if (this.dicomParser) {\n      cameraView = new DICOMView({\n        ...options,\n        cornerstone: this.dicomParser.cornerstone,\n        cornerstoneWADOImageLoader: this.dicomParser.cornerstoneWADOImageLoader\n      });\n    } else {\n      cameraView = new View(options);\n    }\n\n    // bind listeners\n    cameraView.on(EventAction.SELECTED, (event, view) => {\n      if (view !== this.currentCameraView) {\n        if (this.currentCameraView && this.rootStore.config.pixelSearchVisible) {\n          const p = this.currentCameraView.pixelMarkPosition;\n          this.currentCameraView.removePixelMark();\n          if (p) {\n            view.fitPixelMarkToView(p);\n          }\n        }\n        this.setCamera(view.id);\n      }\n      if (event.button === 2) {\n        return;\n      }\n      this.rootStore.unselect(event);\n    });\n    cameraView.on(EventAction.POINTERDOWN, (p, selectedChanged, event, view) => {\n      if (this.rootStore.config.isWorkingOnAnyShape) {\n        return; // ignore click when cutting polygon or splitting polygon\n      }\n      if (event.button === 2) {\n        return;\n      }\n      if (this.rootStore.config.reviewMode === ReviewMode.LABELING) {\n        const shape = this.rootStore.shape.addShape(p, event);\n        if (shape) {\n          return;\n        }\n      } else {\n        const review = this.rootStore.review.addReview(p);\n        if (review) {\n          return;\n        }\n      }\n      if (cameraView instanceof NIFTIView && !selectedChanged) {\n        this.syncNIFTIViews(cameraView.id, p.x, p.y);\n      } else if (this.rootStore.initialized && !this.rootStore.config.addMode && !this.rootStore.review.addMode && !(this.rootStore.config.rotatable && event.ctrlKey && this.rootStore.config.preferences.shapeRotateMode === ShapeRotateMode.CTRL)) {\n        view.startSelect();\n      }\n    });\n    cameraView.on(EventAction.BLANK_POINTERUP_RIGHT, event => {\n      this.rootStore.unselect(event);\n      this.rootStore.openContextMenu({\n        x: event.clientX,\n        y: event.clientY\n      });\n    });\n    cameraView.on(EventAction.SCALE_CHANGED, scale => {\n      this.rootStore.config.setViewScale(scale, camera);\n    });\n    cameraView.on(EventAction.POSITION_CHANGED, p => {\n      this.rootStore.config.setViewPosition(p, camera);\n    });\n    cameraView.on(EventAction.SHAPES_SELECTED, shapes => this.rootStore.shape.setSelectedShapes(shapes));\n    cameraView.on(EventAction.POINTS_SELECTED, points => this.rootStore.shape.setSelectedPoints(points));\n    cameraView.activeLayerIndex = activeLayerIndex;\n    this.cameraViews[camera] = cameraView;\n    return cameraView;\n  }\n\n  /**\n   * get image url\n   * @param camera\n   * @param frameIndex\n   */\n  getImageUrl(camera, frameIndex) {\n    var _this$cameraImages$ca3, _this$cameraImages$ca4, _this$cameraImages$ca5;\n    const imageName = this.currentImageByCamera[camera] || DEFAULT_FRAME_IMAGE_NAME;\n    return (_this$cameraImages$ca3 = (_this$cameraImages$ca4 = this.cameraImages[camera]) === null || _this$cameraImages$ca4 === void 0 ? void 0 : (_this$cameraImages$ca5 = _this$cameraImages$ca4[frameIndex]) === null || _this$cameraImages$ca5 === void 0 ? void 0 : _this$cameraImages$ca5[imageName]) !== null && _this$cameraImages$ca3 !== void 0 ? _this$cameraImages$ca3 : '';\n  }\n\n  /**\n   * get readable image\n   * @param camera\n   * @param frameIndex\n   */\n  getReadableImage(camera, frameIndex) {\n    if (this.niftiParser) {\n      var _image$toDataURL$spli;\n      // 获取base64\n      const image = this.niftiParser.getPlaneImage(camera, frameIndex);\n      return (_image$toDataURL$spli = image === null || image === void 0 ? void 0 : image.toDataURL().split(';base64,')[1]) !== null && _image$toDataURL$spli !== void 0 ? _image$toDataURL$spli : '';\n    }\n    return this.getImageUrl(camera, frameIndex);\n  }\n\n  /**\n   * get pdf document by camera\n   * @param camera\n   */\n  getPDFDocument(camera) {\n    var _this$pdfCache$camera4;\n    const imageName = this.currentImageByCamera[camera] || DEFAULT_FRAME_IMAGE_NAME;\n    return (_this$pdfCache$camera4 = this.pdfCache[camera]) === null || _this$pdfCache$camera4 === void 0 ? void 0 : _this$pdfCache$camera4[imageName];\n  }\n\n  /**\n   * get video by camera\n   * @param camera\n   */\n  getVideo(camera) {\n    var _this$videoCache$came3;\n    const imageName = this.currentImageByCamera[camera] || DEFAULT_FRAME_IMAGE_NAME;\n    return (_this$videoCache$came3 = this.videoCache[camera]) === null || _this$videoCache$came3 === void 0 ? void 0 : _this$videoCache$came3[imageName];\n  }\n\n  /**\n   * get image bounds for camera\n   * @param camera\n   * @param frameIndex\n   */\n  getImageBoundsForCamera(camera, frameIndex) {\n    var _this$attributes$came;\n    // const cameraView = this.cameraViews[camera];\n    // let w = cameraView?.image.width;\n    // let h = cameraView?.image.height;\n    // if (cameraView?.imageRotation % Math.PI !== 0) {\n    //   w = cameraView?.image.height;\n    //   h = cameraView?.image.width;\n    // }\n    const {\n      imageWidth,\n      imageHeight,\n      rotation\n    } = ((_this$attributes$came = this.attributes[camera]) === null || _this$attributes$came === void 0 ? void 0 : _this$attributes$came[frameIndex]) || {};\n    let w = imageWidth;\n    let h = imageHeight;\n    if (rotation % Math.PI !== 0) {\n      w = imageHeight;\n      h = imageWidth;\n    }\n    return {\n      left: 0,\n      top: 0,\n      right: w || 0,\n      bottom: h || 0\n    };\n  }\n\n  /**\n   * set current camera\n   * @param camera\n   */\n  setCamera(camera) {\n    this.rootStore.shape.cancelCreateShape();\n    if (this.rootStore.config.isWorkingOnAnyShape) {\n      return;\n    }\n    // cancel working status\n    this.rootStore.shape.clearPendingWithAlert();\n    this.rootStore.cancelShapeWorking();\n    // reset camera selected status\n    if (this.currentCameraView) {\n      this.currentCameraView.selected = false;\n    }\n    // set selected camera\n    this.currentCamera = camera;\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.selected = true;\n      this.currentCameraView = cameraView;\n      this.updateCameraLayers(cameraView);\n    }\n    // sync dicom views?\n    // this.syncDICOMViews();\n    // update current image\n    this.updateCurrentImage();\n    // update shapes selected status\n    const {\n      selectedInstances\n    } = this.rootStore.instance;\n    this.rootStore.instance.selectInstanceItem(null);\n    this.rootStore.instance.selectInstance(selectedInstances);\n    // update pixel info\n    this.rootStore.segmentation.reset();\n    // preload image for recognizer\n    this.rootStore.shape.loadImageForRecognizer();\n  }\n\n  /**\n   * update working layers by camera view\n   * @param cameraView\n   */\n  updateCameraLayers(cameraView) {\n    // update view scale\n    this.rootStore.config.setViewScale(cameraView.viewScale);\n    // update shapes layer\n    this.rootStore.shape.currentLayer = cameraView.activeShapesLayer;\n    // update review layer\n    if (cameraView.reviewLayer) {\n      this.rootStore.review.setReviewLayer(cameraView.reviewLayer);\n      this.rootStore.review.setReviewLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n    if (cameraView.thumbnailLayer) {\n      this.rootStore.thumbnail.setThumbnailLayer(cameraView.thumbnailLayer);\n      this.rootStore.thumbnail.setThumbnailLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n  }\n\n  /**\n   * set frame for all cameras\n   * @param frameIndex\n   */\n  setFrameForCameras(frameIndex) {\n    // TODO: may add pdf & video\n    const keepFrameInAllCameras = !this.niftiParser && !this.dicomParser;\n    const frames = {};\n    for (let i = 0; i < this.cameraNames.length; i += 1) {\n      const camera = this.cameraNames[i];\n      if (this.currentFrameByCamera[camera] !== frameIndex && (keepFrameInAllCameras || camera === this.currentCamera)) {\n        frames[camera] = frameIndex;\n      }\n    }\n    if (Object.values(frames).length > 0) {\n      this.currentFrameByCamera = {\n        ...this.currentFrameByCamera,\n        ...frames\n      };\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * set current frame\n   * @param frameIndex\n   * @param manual\n   */\n  setFrame(frameIndex, manual = false) {\n    const frameChange = this.setFrameForCameras(frameIndex);\n    if (frameChange) {\n      // frame changes\n      this.updateCurrentImage();\n      this.rootStore.config.setMeasureMode(false);\n      const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n      if (!isGridView) {\n        this.loading = true;\n        this.rootStore.config.setContextMenuVisible(false);\n        this.rootStore.review.clearAnchors();\n      }\n      if (!this.isPlaying) {\n        // not auto playing\n        const videoObj = this.getVideo(this.currentCamera);\n        if (videoObj) {\n          this.currentVideoTime = frameIndex / videoObj.fps;\n        }\n      } else if (manual && this.playingVideo) {\n        // auto playing, update playing video time\n        const videoObj = this.getVideo(this.currentCamera);\n        if (videoObj) {\n          this.playingVideo.currentTime = frameIndex / videoObj.fps;\n        }\n      }\n    }\n    return frameChange;\n  }\n\n  /**\n   * sync to set current frame\n   * @param frameIndex\n   * @param manual\n   */\n  setFrameSync(frameIndex, manual = false) {\n    return new Promise(resolve => {\n      const frameChange = this.setFrame(frameIndex, manual);\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT && frameChange) {\n        const disposer = reaction(() => this.loading, () => {\n          if (!this.loading) {\n            resolve();\n            disposer();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * when frame loaded\n   * @param image\n   */\n  async onFrameLoaded() {\n    var _this$rootStore$nifti, _this$imagePreloader;\n    const keepWorkingOnPixelShapeToolMode = this.rootStore.segmentation.currMode;\n    this.camerasMapping.setFrame(this.currentFrame);\n\n    // turn off add mode\n    this.rootStore.config.setAddMode(false, false);\n    // update pixel info\n    this.rootStore.segmentation.reset(this.rootStore.config.viewMode === ViewMode.GRID);\n    // setup current shapes\n    this.rootStore.shape.setupShapes();\n    // setup relationships\n    this.rootStore.relationship.setupConnections();\n    // setup reivew anchors\n    this.rootStore.review.setupReviewAnchors();\n    // redraw empty area\n    this.rootStore.validation.redrawCheckLayer();\n\n    // select shape\n    const {\n      selectedInstanceItems,\n      selectedInstances\n    } = this.rootStore.instance;\n    if (selectedInstanceItems.length > 0) {\n      this.rootStore.shape.selectShapeByInstanceItem(selectedInstanceItems, false);\n    } else if (selectedInstances.length > 0) {\n      this.rootStore.shape.updateShapesInInstance(selectedInstances);\n      this.rootStore.shape.hideOrShowOthers();\n    } else {\n      this.rootStore.shape.hideOrShowOthers();\n    }\n    // predict\n    await this.rootStore.shape.predict();\n    // 更新投影\n    (_this$rootStore$nifti = this.rootStore.nifti) === null || _this$rootStore$nifti === void 0 ? void 0 : _this$rootStore$nifti.projectShapes();\n\n    // keep working on pixel shape\n    if (keepWorkingOnPixelShapeToolMode !== PixelToolMode.NONE) {\n      const selectedShape = this.rootStore.shape.selectedShapes[0];\n      if (selectedShape instanceof Pixel) {\n        this.rootStore.segmentation.setMode(keepWorkingOnPixelShapeToolMode);\n      }\n    }\n    this.loading = false;\n\n    // set preview mode to false to force recache bitmap\n    if (this.rootStore.config.previewMode) {\n      Object.values(this.cameraViews).forEach(view => {\n        view.setPreviewMode(false);\n      });\n    }\n    this.updatePreviewMode();\n\n    // preload image\n    (_this$imagePreloader = this.imagePreloader) === null || _this$imagePreloader === void 0 ? void 0 : _this$imagePreloader.preload((this.currentFrame + 1) * this.cameraCount);\n    // preload image for recognizer\n    this.rootStore.shape.loadImageForRecognizer();\n\n    // when loaded, if is auto playing, play next frame\n    if (this.isPlaying && !this.getVideo(this.currentCamera)) {\n      this.playTimer = window.setTimeout(() => {\n        this.setFrameByAutoPlay();\n      }, 300);\n    }\n  }\n\n  /**\n   * go to previous frame by step\n   * @param step\n   */\n  prev(step) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.max(this.currentFrame - step, 0));\n    }\n  }\n\n  /**\n   * go to next frame by step\n   * @param step\n   */\n  next(step) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.min(this.currentFrame + step, this.frameCount - 1));\n    }\n  }\n\n  /**\n   * toggle playing\n   */\n  togglePlaying() {\n    this.isPlaying = !this.isPlaying;\n    const videoPlay = this.autoPlayVideo();\n    if (videoPlay) {\n      return;\n    }\n    if (this.isPlaying) {\n      this.setFrameByAutoPlay();\n    } else if (this.playTimer) {\n      window.clearTimeout(this.playTimer);\n      this.playTimer = null;\n    }\n  }\n\n  /**\n   * set frame by auto play\n   */\n  setFrameByAutoPlay() {\n    if (this.currentFrame < this.frameCount - 1) {\n      this.setFrame(this.currentFrame + 1);\n    } else {\n      this.isPlaying = false;\n      this.setFrame(0);\n    }\n  }\n\n  /**\n   * play video\n   */\n  autoPlayVideo() {\n    const videoObj = this.getVideo(this.currentCamera);\n    if (videoObj) {\n      if (this.isPlaying) {\n        const {\n          video,\n          fps\n        } = videoObj;\n        if (!this.playingVideo) {\n          this.playingVideo = document.createElement('video');\n        }\n        this.playingVideo.src = video.src;\n        this.playingVideo.crossOrigin = 'anonymous';\n        if (this.currentFrame >= this.frameCount - 1) {\n          // last frame\n          this.setFrameForCameras(0);\n        }\n        const startTime = this.currentFrame / fps;\n        this.playingVideo.currentTime = startTime;\n        this.playingVideo.play();\n        requestAnimationFrame(() => this.playVideo(fps));\n      } else {\n        var _this$playingVideo;\n        (_this$playingVideo = this.playingVideo) === null || _this$playingVideo === void 0 ? void 0 : _this$playingVideo.pause();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * play video\n   */\n  playVideo(fps) {\n    if (!this.playingVideo) {\n      return;\n    }\n    const {\n      currentTime\n    } = this.playingVideo;\n    const videoFrame = Math.floor(currentTime * fps);\n    if (videoFrame > this.currentFrame) {\n      this.setFrame(videoFrame);\n    }\n    this.currentVideoTime = currentTime;\n    if (currentTime >= this.playingVideo.duration) {\n      // end\n      this.isPlaying = false;\n      return;\n    }\n    if (this.playingVideo.paused || this.playingVideo.ended) {\n      return;\n    }\n    requestAnimationFrame(() => this.playVideo(fps));\n  }\n\n  /**\n   * update current image by current camera & frame\n   */\n  updateCurrentImage() {\n    var _this$cameraImages$th;\n    // set camera image\n    const imageKeys = Object.keys(((_this$cameraImages$th = this.cameraImages[this.currentCamera]) === null || _this$cameraImages$th === void 0 ? void 0 : _this$cameraImages$th[this.currentFrame]) || {});\n    if (imageKeys.length <= 1) {\n      return;\n    }\n    if (imageKeys.indexOf(this.currentCameraImage) < 0) {\n      this.currentImageByCamera[this.currentCamera] = imageKeys[0];\n    }\n  }\n\n  /**\n   * set image\n   * @param image\n   */\n  setImage(image) {\n    this.currentImageByCamera[this.currentCamera] = image;\n  }\n\n  /**\n   * switch image\n   */\n  switchImage() {\n    var _this$cameraImages$th2;\n    if (this.rootStore.config.viewMode === ViewMode.GRID) {\n      return;\n    }\n    const imageKeys = Object.keys(((_this$cameraImages$th2 = this.cameraImages[this.currentCamera]) === null || _this$cameraImages$th2 === void 0 ? void 0 : _this$cameraImages$th2[this.currentFrame]) || {});\n    if (imageKeys.length <= 1) {\n      return;\n    }\n    const index = imageKeys.indexOf(this.currentCameraImage);\n    const nextIndex = (index + 1) % imageKeys.length;\n    this.setImage(imageKeys[nextIndex]);\n  }\n\n  /**\n   * can update attributes by camera & frameIndex\n   * @param camera\n   * @param frameIndex\n   */\n  canUpdateFrameForCamera(camera, frameIndex) {\n    if (this.rootStore.readonly) {\n      return false;\n    }\n    if (!this.attributes[camera] || !this.attributes[camera][frameIndex]) {\n      // attributes not initialized as expected, may have wrong frames or base_url input\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * get frame rotation\n   * @param camera\n   * @param frameIndex\n   */\n  getFrameRotationForCamera(camera, frameIndex) {\n    if (!this.attributes[camera]) {\n      return 0;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return 0;\n    }\n    return this.attributes[camera][frameIndex].rotation || 0;\n  }\n\n  /**\n   * set frame rotation\n   * @param camera\n   * @param frameIndex\n   * @param rotation\n   */\n  setFrameRotationForCamera(camera, frameIndex, rotation) {\n    if (!this.canUpdateFrameForCamera(camera, frameIndex)) {\n      return;\n    }\n\n    // calc rotation diff\n    let diff = rotation - this.currentFrameRotation;\n    if (diff > Math.PI) {\n      diff -= Math.PI * 2;\n    } else if (diff <= -Math.PI) {\n      diff += Math.PI * 2;\n    }\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = this.imageBounds;\n    const imageWidth = right - left;\n    const imageHeight = bottom - top;\n    const LTPoint = {\n      x: left,\n      y: top\n    };\n    const rotatedLTPoint = {\n      ...LTPoint\n    };\n    if (diff === -Math.PI / 2) {\n      // anti-clockwise 90 degrees\n      rotatedLTPoint.y -= imageWidth;\n    } else if (diff === Math.PI) {\n      // anti-clockwise 180 degrees\n      rotatedLTPoint.x -= imageWidth;\n      rotatedLTPoint.y -= imageHeight;\n    } else if (diff === Math.PI / 2) {\n      // anti-clockwise 270 degrees\n      rotatedLTPoint.x -= imageHeight;\n    }\n\n    // rotate shapes\n    const {\n      prevState,\n      currState\n    } = this.rootStore.shape.rotateShapesByCanvas(diff, LTPoint, rotatedLTPoint.x, rotatedLTPoint.y);\n\n    // save rotation\n    const storeId = this.rootStore.undo.preserve({\n      ...prevState,\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n    this.attributes[camera][frameIndex].rotation = rotation;\n    this.rootStore.undo.save(storeId, {\n      ...currState,\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n\n    // set rotation for camera view\n    this.cameraViews[camera].imageRotation = rotation;\n    this.cameraViews[camera].rotate();\n    // update shapes bounds\n    this.rootStore.shape.updateShapesBounds();\n    // update pixel info\n    this.rootStore.segmentation.reset();\n  }\n\n  /**\n   * is frame valid\n   * @param camera\n   * @param frameIndex\n   */\n  isFrameValidForCamera(camera, frameIndex) {\n    var _this$frameConfigVali, _this$frameConfigVali2, _this$attributes$came2;\n    if (!this.attributes[camera]) {\n      return true;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return true;\n    }\n    const validKey = (_this$frameConfigVali = this.frameConfigValidity) === null || _this$frameConfigVali === void 0 ? void 0 : _this$frameConfigVali.key;\n    if (!validKey || !this.rootStore.annotatable) {\n      return this.attributes[camera][frameIndex].valid !== false;\n    }\n    const invalidValues = ((_this$frameConfigVali2 = this.frameConfigValidity) === null || _this$frameConfigVali2 === void 0 ? void 0 : _this$frameConfigVali2.invalid) || [];\n    const currentValue = (_this$attributes$came2 = this.attributes[camera][frameIndex].attributes) === null || _this$attributes$came2 === void 0 ? void 0 : _this$attributes$came2[validKey];\n    return !invalidValues.includes(currentValue);\n  }\n\n  /**\n   * is frame common valid\n   * @param frameIndex\n   */\n  isCommonFrameValid(frameIndex) {\n    var _this$commonFrameConf, _this$commonFrameConf2;\n    if (!this.frameAttributes) {\n      return true;\n    }\n    if (!this.frameAttributes[frameIndex]) {\n      return true;\n    }\n    const validKey = (_this$commonFrameConf = this.commonFrameConfigValidity) === null || _this$commonFrameConf === void 0 ? void 0 : _this$commonFrameConf.key;\n    if (!validKey) {\n      return true;\n    }\n    const invalidValues = ((_this$commonFrameConf2 = this.commonFrameConfigValidity) === null || _this$commonFrameConf2 === void 0 ? void 0 : _this$commonFrameConf2.invalid) || [];\n    const currentValue = this.frameAttributes[frameIndex][validKey];\n    return !invalidValues.includes(currentValue);\n  }\n\n  /**\n   * set frame valid\n   * @param camera\n   * @param frameIndex\n   * @param valid\n   */\n  setFrameValidForCamera(camera, frameIndex, valid) {\n    if (!this.canUpdateFrameForCamera(camera, frameIndex)) {\n      return;\n    }\n    const storeId = this.rootStore.undo.preserve({\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n    this.attributes[camera][frameIndex].valid = valid;\n    this.rootStore.undo.save(storeId, {\n      frames: [{\n        camera,\n        frames: [toJS(this.attributes[camera][frameIndex])]\n      }]\n    });\n  }\n\n  /**\n   * set frame attributes\n   * @param camera\n   * @param frames\n   * @param replaceAttributes\n   */\n  updateFrameAttributesForCamera(camera, frames, replaceAttributes) {\n    const currentFramesData = [];\n    const newFramesData = [];\n    frames.forEach(frameIndex => {\n      if (this.canUpdateFrameForCamera(camera, frameIndex)) {\n        const preFrameAttrs = toJS(this.attributes[camera][frameIndex]);\n        currentFramesData.push(preFrameAttrs);\n        this.attributes[camera][frameIndex].attributes = {\n          ...preFrameAttrs.attributes,\n          ...replaceAttributes\n        };\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{\n          camera,\n          frames: currentFramesData\n        }]\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{\n          camera,\n          frames: newFramesData\n        }]\n      });\n    }\n  }\n\n  /**\n   * set frame attributes\n   * @param camera\n   * @param updatedFrameAttributes\n   */\n  setFrameAttributesForCamera(camera, updatedFrameAttributes) {\n    const currentFramesData = [];\n    const newFramesData = [];\n    for (let i = 0; i < updatedFrameAttributes.length; i += 1) {\n      const {\n        frameIndex,\n        attributes\n      } = updatedFrameAttributes[i];\n      if (this.canUpdateFrameForCamera(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n        if (this.isFrameValidForCamera(camera, frameIndex)) {\n          this.attributes[camera][frameIndex].originValid = true;\n        }\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    }\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{\n          camera,\n          frames: currentFramesData\n        }]\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{\n          camera,\n          frames: newFramesData\n        }]\n      });\n    }\n  }\n\n  /**\n   * set common frame attributes\n   * @param updatedFrameAttributes\n   */\n  setCommonFrameAttributes(updatedFrameAttributes) {\n    const storeId = this.rootStore.undo.preserve({\n      attributes: this.attributesJSON()\n    });\n    for (let i = 0; i < updatedFrameAttributes.length; i += 1) {\n      const {\n        frameIndex,\n        attributes\n      } = updatedFrameAttributes[i];\n      this.frameAttributes[frameIndex] = cloneDeep(attributes);\n    }\n    this.rootStore.undo.save(storeId, {\n      attributes: this.attributesJSON()\n    });\n  }\n  /**\n   * update next shape order\n   * @param currentOrder\n   * @param layer\n   * @param frameIndex\n   * @param camera\n   */\n  updateNextShapeOrder(currentOrder, layer = this.rootStore.config.activeLayerIndex, frameIndex = this.currentFrame, camera = this.currentCamera) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n      this.nextShapeOrders[camera][frameIndex] = [];\n    }\n    if (this.nextShapeOrders[camera][frameIndex][layer] === undefined || this.nextShapeOrders[camera][frameIndex][layer] <= currentOrder) {\n      this.nextShapeOrders[camera][frameIndex][layer] = currentOrder + 1;\n    }\n  }\n\n  /**\n   * fix image size if no image width & height\n   */\n  async fixImageSize(showMsg = true) {\n    const noSizeFrames = [];\n    for (let i = 0; i < this.cameraNames.length; i += 1) {\n      const camera = this.cameraNames[i];\n      const cameraFrames = this.cameraImages[camera];\n      for (let j = 0; j < cameraFrames.length; j += 1) {\n        const {\n          imageWidth,\n          imageHeight\n        } = this.attributes[camera][j];\n        if (imageWidth === undefined || imageHeight === undefined) {\n          // 仅取每个相机每一帧的第一张图片，默认同相机同一帧的图片尺寸一致\n          noSizeFrames.push({\n            camera,\n            frameIndex: j,\n            imageUrl: Object.values(cameraFrames[j])[0]\n          });\n        }\n      }\n    }\n    if (noSizeFrames.length <= 0) {\n      Promise.resolve();\n      return;\n    }\n    const count = noSizeFrames.length;\n    let hide;\n    if (showMsg) {\n      hide = message.loading({\n        key: 'loading',\n        duration: 0,\n        content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', {\n          values: {\n            count,\n            finished: 0\n          }\n        })\n      });\n    }\n    return new Promise(resolve => {\n      const queue = [];\n      let finished = 0;\n      let i = 0;\n      const loadImageSize = ({\n        camera,\n        frameIndex,\n        imageUrl\n      }) => {\n        const finish = () => {\n          finished += 1;\n          if (showMsg) {\n            message.loading({\n              key: 'loading',\n              duration: 0,\n              content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', {\n                values: {\n                  count,\n                  finished\n                }\n              })\n            });\n          }\n          if (finished === count) {\n            if (hide) {\n              hide();\n            }\n            resolve();\n          } else if (i < count - 1) {\n            i += 1;\n            queue.shift();\n            loadImageSize(noSizeFrames[i]);\n          }\n        };\n        const img = new Image();\n        img.onload = () => {\n          this.updateImageSize(camera, frameIndex, img.width, img.height);\n          finish();\n        };\n        img.onerror = () => {\n          this.updateImageSize(camera, frameIndex, -1, -1);\n          finish();\n        };\n        img.src = imageUrl;\n        queue.push(imageUrl);\n        if (queue.length < 10 && i < count - 1) {\n          i += 1;\n          loadImageSize(noSizeFrames[i]);\n        }\n      };\n      loadImageSize(noSizeFrames[i]);\n    });\n  }\n\n  /**\n   * update camera filters\n   * @param camera\n   * @param filters\n   */\n  updateCameraFilters(camera, filters) {\n    const currFilters = this.getFiltersForCamera(camera);\n    const {\n      keep,\n      ...rest\n    } = filters;\n    if (!this.cameraFilters[camera]) {\n      // init camera filters\n      this.cameraFilters[camera] = {\n        keep,\n        frames: {}\n      };\n    } else if (keep !== undefined) {\n      // update keep\n      this.cameraFilters[camera].keep = keep;\n    }\n    if (this.cameraFilters[camera].keep) {\n      this.cameraFilters[camera].global = {\n        ...currFilters,\n        ...rest\n      };\n      this.cameraFilters[camera].frames = {}; // remove all frames settings\n    } else {\n      this.cameraFilters[camera].frames[this.currentFrame] = {\n        ...currFilters,\n        ...rest\n      };\n    }\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.applyFilters(rest);\n    }\n  }\n\n  /**\n   * get image filters presets map\n   */\n  getImageFiltersPresetsMap() {\n    var _this$imageFiltersPre;\n    const result = {};\n    (_this$imageFiltersPre = this.imageFiltersPresets) === null || _this$imageFiltersPre === void 0 ? void 0 : _this$imageFiltersPre.forEach(filterPreset => {\n      const {\n        name,\n        ...rest\n      } = filterPreset;\n      result[filterPreset.name] = rest;\n    });\n    return result;\n  }\n\n  /**\n   * get filters\n   * @param camera\n   */\n  getFiltersForCamera(camera) {\n    const {\n      keep = false,\n      global,\n      frames = {}\n    } = this.cameraFilters[camera] || {};\n    if (keep) {\n      return global;\n    }\n    return frames[this.currentFrame] || global;\n  }\n\n  /**\n   * update image size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  updateImageSize(camera, frameIndex, width, height) {\n    if (this.attributes[camera] && this.attributes[camera][frameIndex]) {\n      const {\n        imageWidth,\n        imageHeight\n      } = this.attributes[camera][frameIndex];\n      if (width > 0 && height > 0 || imageWidth === undefined || imageHeight === undefined) {\n        // only update when size valid, or size not initialized\n        this.attributes[camera][frameIndex].imageWidth = width;\n        this.attributes[camera][frameIndex].imageHeight = height;\n        this.camerasMapping.setCameraSize(camera, frameIndex, width, height);\n      }\n    }\n  }\n\n  /**\n   * update active layer index in all cameras\n   */\n  updateActiveLayerIndexInAllCameras() {\n    const {\n      activeLayerIndex\n    } = this.rootStore.config;\n    Object.values(this.cameraViews).forEach(cameraView => {\n      // update layer index for each camera\n      cameraView.activeLayerIndex = activeLayerIndex;\n      // update current layer for shapes\n      if (cameraView.id === this.currentCamera) {\n        this.rootStore.shape.currentLayer = cameraView.activeShapesLayer;\n      }\n    });\n  }\n  updatePreviewMode() {\n    const {\n      previewMode\n    } = this.rootStore.config;\n    const {\n      config,\n      getShapesForCamera\n    } = this.rootStore.shape;\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    Object.keys(this.cameraViews).forEach(camera => {\n      const shapes = getShapesForCamera(camera);\n      shapes.forEach(({\n        shape,\n        instanceItem\n      }) => {\n        if (previewMode) {\n          shape.alpha = 1;\n          shape.borderWidth *= shape.scale;\n          shape.showSideLength = false;\n          shape.showDirection = false;\n          shape.showVertex = false;\n          shape.showVertexOrder = false;\n          shape.interactive = false;\n        } else {\n          var _instanceItem$cameras, _instanceItem$cameras2;\n          shape.alpha = config.fill ? config.alpha / 100 : 0;\n          shape.borderWidth = config.borderWidth;\n          shape.showSideLength = config.showSideLength;\n          shape.showDirection = config.showDirection;\n          shape.showVertex = config.showVertex;\n          shape.showVertexOrder = config.showVertexOrder;\n          shape.interactive = true;\n          shape.editable = !this.rootStore.readonly && !((_instanceItem$cameras = instanceItem.cameras[camera]) === null || _instanceItem$cameras === void 0 ? void 0 : (_instanceItem$cameras2 = _instanceItem$cameras.frames[currentFrame]) === null || _instanceItem$cameras2 === void 0 ? void 0 : _instanceItem$cameras2.locked);\n        }\n      });\n      const cameraView = this.cameraViews[camera];\n      cameraView.setPreviewMode(previewMode);\n      if (previewMode) {\n        cameraView.updatePreviewModeAlpha(config.alpha / 100);\n      }\n    });\n  }\n  drawNIFTIViews() {\n    if (!this.niftiParser) {\n      return;\n    }\n    const {\n      dims,\n      pixDims\n    } = this.niftiParser;\n    // x轴切帧方向是 L -> R，显示方向是 R -> L，因此需要转换一下\n    const x = (dims[0] - 1 - this.currentFrameByCamera[Plane.SAGITTAL] + 0.5) * pixDims[0];\n    // y、z轴切帧方向和显示方向一致\n    const y = (this.currentFrameByCamera[Plane.CORONAL] + 0.5) * pixDims[1];\n    const z = (this.currentFrameByCamera[Plane.AXIAL] + 0.5) * pixDims[2];\n    Object.values(this.cameraViews).forEach(cameraView => {\n      if (cameraView instanceof NIFTIView) {\n        cameraView.drawAxisProjection(x, y, z);\n      }\n    });\n  }\n  syncNIFTIViews(baseCamera, u, v) {\n    if (!this.niftiParser) {\n      return;\n    }\n    const {\n      dims,\n      pixDims\n    } = this.niftiParser;\n    this.currentFrameByCamera = {\n      ...this.currentFrameByCamera,\n      ...(baseCamera === Plane.SAGITTAL ? {\n        [Plane.CORONAL]: Math.min(Math.max(Math.floor(u / pixDims[1]), 0), dims[1] - 1)\n      } : {\n        [Plane.SAGITTAL]: dims[0] - 1 - Math.min(Math.max(Math.floor(u / pixDims[0]), 0), dims[0] - 1)\n      }),\n      ...(baseCamera === Plane.AXIAL ? {\n        [Plane.CORONAL]: Math.min(Math.max(Math.floor(v / pixDims[1]), 0), dims[1] - 1)\n      } : {\n        [Plane.AXIAL]: Math.min(Math.max(Math.floor(v / pixDims[2]), 0), dims[2] - 1)\n      })\n    };\n  }\n\n  /**\n   * sync all dicom camera views\n   */\n  syncDICOMViews() {\n    if (!this.dicomParser || !(this.currentCameraView instanceof DICOMView)) {\n      return;\n    }\n    const {\n      imageIndex: currentImageIndex\n    } = this.currentCameraView;\n    Object.keys(this.dicomParser.cameras).forEach(cameraKey => {\n      const cameraView = this.cameraViews[cameraKey];\n      if (cameraView instanceof DICOMView) {\n        if (cameraKey !== this.currentCamera) {\n          // 处理非当前相机的case\n          const imageIndex = this.dicomParser.findClosestImageIndex(this.currentCamera, currentImageIndex, cameraKey);\n          if (imageIndex >= 0) {\n            // 这里是平行的切片，同步播放（找最近的）\n            cameraView.imageIndex = imageIndex;\n            cameraView.drawProjections();\n          } else {\n            // 无法同步的，要绘制当前切片位置的投影\n            const projections = this.dicomParser.projectToCamera(this.currentCamera, currentImageIndex, cameraKey, cameraView.imageIndex);\n            cameraView.drawProjections(projections);\n          }\n        } else {\n          // 清空\n          cameraView.drawProjections();\n        }\n      }\n    });\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  framesJSON() {\n    return this.cameraNames.map(camera => ({\n      camera,\n      frames: Array.from({\n        length: this.frameCount\n      }).map((_, frameIndex) => {\n        var _this$cameraImages$ca6;\n        const imageUrl = this.getImageUrl(camera, frameIndex);\n        let imageUrls;\n        if ((_this$cameraImages$ca6 = this.cameraImages[camera]) === null || _this$cameraImages$ca6 === void 0 ? void 0 : _this$cameraImages$ca6[frameIndex]) {\n          const urls = Object.values(this.cameraImages[camera][frameIndex]);\n          if (urls.length > 1) {\n            imageUrls = urls;\n          }\n        }\n        return {\n          frameIndex,\n          imageUrl,\n          imageUrls,\n          imageWidth: this.attributes[camera][frameIndex].imageWidth,\n          imageHeight: this.attributes[camera][frameIndex].imageHeight,\n          valid: this.isFrameValidForCamera(camera, frameIndex),\n          originValid: this.attributes[camera][frameIndex].originValid !== false,\n          rotation: this.getFrameRotationForCamera(camera, frameIndex),\n          attributes: toJS(this.attributes[camera][frameIndex].attributes)\n        };\n      })\n    }));\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  attributesJSON() {\n    if (!this.commonFrameConfig && Object.values(this.frameAttributes).length === 0) {\n      // no config & no initial attributes\n      return {};\n    }\n    return {\n      frames: Array.from({\n        length: this.frameCount\n      }).map((_, frameIndex) => ({\n        frameIndex,\n        valid: this.isCommonFrameValid(frameIndex),\n        attributes: toJS(this.frameAttributes[frameIndex])\n      }))\n    };\n  }\n}","map":{"version":3,"names":["makeAutoObservable","reaction","runInAction","toJS","cloneDeep","message","notification","Base64","CamerasMapping","View","EventAction","NIFTIView","DICOMView","DEFAULT_CAMERA_NAME","DEFAULT_FRAME_IMAGE_NAME","SIDEBAR_WIDTH","TOOLBAR_HEIGHT","isPDFUrl","isVideoUrl","parseFramesByPaylod","parseLabelConfig","ViewMode","ReviewMode","PixelToolMode","i18n","ShapeRotateMode","Pixel","loader","triggerFormRules","NIFTIParser","Plane","DICOMParser","PDFLoader","estimateFPS","getDuration","FrameStore","isSingleCamera","cameraCount","cameraNames","Object","keys","cameraFrames","length","frameCount","currentCamera","currentFrame","currentFrameByCamera","currentCameraImage","currentImageByCamera","imageBounds","getImageBoundsForCamera","currentFrameRotation","getFrameRotationForCamera","currentFrameValid","isFrameValidForCamera","currentCommonFrameValid","isCommonFrameValid","currentFrameAttributes","_this$attributes$this","attributes","invalidFrames","Set","Array","from","forEach","item","frameIndex","add","constructor","rootStore","cameraImages","imageEmbeddings","niftiParser","dicomParser","pdfCache","videoCache","camerasMapping","cameraViews","currentCameraView","initialAttributes","frameAttributes","initialFrameAttributes","nextShapeOrders","currentVideoTime","loading","isPlaying","playingVideo","playTimer","imagePreloader","frameConfig","frameConfigValidity","commonFrameConfig","commonFrameConfigValidity","imageFiltersPresets","cameraFilters","getNextShapeOrder","layer","config","activeLayerIndex","camera","undefined","segmentation","enabled","order","autoBind","init","payload","frame_config","frame_config_common","frame_config_validity","JSON","parse","error","translate","values","validity","frame_config_common_validity","image_filters_preset_config","decode","cameras","niftiUrl","dicomDirUrl","load","AXIAL","SAGITTAL","CORONAL","cameraKey","createCameraView","getPlaneDimension","map","Math","floor","setDefaultAttributes","setCamera","initNIFTIStore","viewRotatable","allCameras","cameraView","images","imageIndex","preload","pdfLoader","i","data","imageNames","j","name","url","basic","e","console","log","pdfDocument","proxyResource","_data$fps","_data$duration","video","document","createElement","src","crossOrigin","muted","fps","duration","totalFrames","ceil","embeddings","calibrations","_images$","_ref","_this$pdfCache$camera","_this$pdfCache$camera2","_this$pdfCache$camera3","_this$videoCache$came","_this$videoCache$came2","firstName","count","totalPages","setCalibrations","parseEmbeddings","cameraImagesList","allImages","max","flatMap","_","_Object$values$","_cameraImagesList$cam","_cameraImagesList$cam2","updateResource","resource","base_url","_Object$values$2","_this$cameraImages$ca","_this$cameraImages$ca2","_this$rootStore$jobPr","flowData","jobProxy","link","appen_ai_image_2d_pre_embedding_sam","embedding","index","defaultAttributes","updatedValues","valid","originValid","rotation","annotatable","key","maxFrameCount","initAttributes","result","clearAttributes","frames","attrs","isArray","cameraItem","frameItem","imageUrl","imageUrls","imageWidth","imageHeight","legacyAttributes","PI","frameAttrs","initToolConfig","toolConfig","_this$rootStore$jobPr2","layers","auxiliaryLines","autoSnapPoint","needThumbnailLayer","canvasConfig","options","id","enableThumbnail","enableReview","loadReviewEnabled","enableSnap","showGrid","gridVisible","gridSize","gap","cornerstone","cornerstoneWADOImageLoader","on","SELECTED","event","view","pixelSearchVisible","p","pixelMarkPosition","removePixelMark","fitPixelMarkToView","button","unselect","POINTERDOWN","selectedChanged","isWorkingOnAnyShape","reviewMode","LABELING","shape","addShape","review","addReview","syncNIFTIViews","x","y","initialized","addMode","rotatable","ctrlKey","preferences","shapeRotateMode","CTRL","startSelect","BLANK_POINTERUP_RIGHT","openContextMenu","clientX","clientY","SCALE_CHANGED","scale","setViewScale","POSITION_CHANGED","setViewPosition","SHAPES_SELECTED","shapes","setSelectedShapes","POINTS_SELECTED","points","setSelectedPoints","getImageUrl","_this$cameraImages$ca3","_this$cameraImages$ca4","_this$cameraImages$ca5","imageName","getReadableImage","_image$toDataURL$spli","image","getPlaneImage","toDataURL","split","getPDFDocument","_this$pdfCache$camera4","getVideo","_this$videoCache$came3","_this$attributes$came","w","h","left","top","right","bottom","cancelCreateShape","clearPendingWithAlert","cancelShapeWorking","selected","updateCameraLayers","updateCurrentImage","selectedInstances","instance","selectInstanceItem","selectInstance","reset","loadImageForRecognizer","viewScale","currentLayer","activeShapesLayer","reviewLayer","setReviewLayer","setReviewLayerOffset","thumbnailLayer","thumbnail","setThumbnailLayer","setThumbnailLayerOffset","setFrameForCameras","keepFrameInAllCameras","setFrame","manual","frameChange","setMeasureMode","isGridView","viewMode","GRID","setContextMenuVisible","clearAnchors","videoObj","currentTime","setFrameSync","Promise","resolve","DEFAULT","disposer","onFrameLoaded","_this$rootStore$nifti","_this$imagePreloader","keepWorkingOnPixelShapeToolMode","currMode","setAddMode","setupShapes","relationship","setupConnections","setupReviewAnchors","validation","redrawCheckLayer","selectedInstanceItems","selectShapeByInstanceItem","updateShapesInInstance","hideOrShowOthers","predict","nifti","projectShapes","NONE","selectedShape","selectedShapes","setMode","previewMode","setPreviewMode","updatePreviewMode","window","setTimeout","setFrameByAutoPlay","prev","step","next","min","togglePlaying","videoPlay","autoPlayVideo","clearTimeout","startTime","play","requestAnimationFrame","playVideo","_this$playingVideo","pause","videoFrame","paused","ended","_this$cameraImages$th","imageKeys","indexOf","setImage","switchImage","_this$cameraImages$th2","nextIndex","canUpdateFrameForCamera","readonly","setFrameRotationForCamera","diff","LTPoint","rotatedLTPoint","prevState","currState","rotateShapesByCanvas","storeId","undo","preserve","save","imageRotation","rotate","updateShapesBounds","_this$frameConfigVali","_this$frameConfigVali2","_this$attributes$came2","validKey","invalidValues","invalid","currentValue","includes","_this$commonFrameConf","_this$commonFrameConf2","setFrameValidForCamera","updateFrameAttributesForCamera","replaceAttributes","currentFramesData","newFramesData","preFrameAttrs","push","setFrameAttributesForCamera","updatedFrameAttributes","setCommonFrameAttributes","attributesJSON","updateNextShapeOrder","currentOrder","fixImageSize","showMsg","noSizeFrames","hide","content","finished","queue","loadImageSize","finish","shift","img","Image","onload","updateImageSize","width","height","onerror","updateCameraFilters","filters","currFilters","getFiltersForCamera","keep","rest","global","applyFilters","getImageFiltersPresetsMap","_this$imageFiltersPre","filterPreset","setCameraSize","updateActiveLayerIndexInAllCameras","getShapesForCamera","frame","instanceItem","alpha","borderWidth","showSideLength","showDirection","showVertex","showVertexOrder","interactive","_instanceItem$cameras","_instanceItem$cameras2","fill","editable","locked","updatePreviewModeAlpha","drawNIFTIViews","dims","pixDims","z","drawAxisProjection","baseCamera","u","v","syncDICOMViews","currentImageIndex","findClosestImageIndex","drawProjections","projections","projectToCamera","framesJSON","_this$cameraImages$ca6","urls"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/FrameStore.ts"],"sourcesContent":["import { makeAutoObservable, reaction, runInAction, toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport { message, notification } from 'antd';\nimport { MessageType } from 'antd/es/message';\nimport { Base64 } from 'js-base64';\nimport RootStore from './RootStore';\nimport CamerasMapping from '../cameras-mapping/CamerasMapping';\nimport View, { EventAction } from '../shapes/View';\nimport NIFTIView from '../shapes/NIFTIView';\nimport DICOMView from '../shapes/DICOMView';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_FRAME_IMAGE_NAME, SIDEBAR_WIDTH, TOOLBAR_HEIGHT } from '../constants';\nimport { isPDFUrl, isVideoUrl, parseFramesByPaylod, parseLabelConfig } from '../utils';\nimport { Payload, FrameAttributes, CameraFrameAttributes, CommonFrameAttributes, ViewMode, LabelConfig, ReviewMode, ImageFilters, ImageFiltersPresets, CameraFilters, Attributes, PixelToolMode, CameraName, ImageName, Frame } from '../types';\nimport i18n from '../locales';\nimport { ShapeRotateMode } from '../../common/shapes/Shape';\nimport Pixel from '../../common/shapes/Pixel';\nimport loader, { ImagePreloader } from '../../../utils/image-preloader';\nimport { triggerFormRules } from '../../../utils/form';\nimport NIFTIParser, { Plane } from '../../../libs/nifti/NIFTIParser';\nimport DICOMParser from '../../../libs/dicom/DICOMParser';\nimport PDFLoader from '../../../libs/pdf/PDFLoader';\nimport PDFDocument from '../../../libs/pdf/PDFDocument';\nimport { estimateFPS, getDuration } from '../../../utils/video';\n\n/**\n * store for frames\n * @class\n */\nexport default class FrameStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * frame count by camera\n   */\n  cameraFrames: Record<CameraName, number> = {};\n\n  /**\n   * all camera images\n   */\n  cameraImages: Record<CameraName, Record<ImageName, string>[]> = {};\n\n  /**\n   * frame image embedding urls\n   */\n  imageEmbeddings: Record<CameraName, Record<ImageName, string>[]> = {};\n\n  /**\n   * nifti parser\n   */\n  niftiParser?: NIFTIParser;\n\n  /**\n   * dicom parser\n   */\n  dicomParser?: DICOMParser;\n\n  /**\n   * pdf documents cache\n   */\n  pdfCache: Record<CameraName, Record<ImageName, PDFDocument>> = {};\n\n  /**\n   * video cache\n   */\n  videoCache: Record<CameraName, Record<ImageName, { video: HTMLVideoElement; fps: number; totalFrames: number }>> = {};\n\n  /**\n   * project worker\n   */\n  camerasMapping = new CamerasMapping();\n\n  /**\n   * camera views\n   */\n  cameraViews: Record<CameraName, View> = {};\n\n  /**\n   * current active camera\n   */\n  currentCameraView: View | null = null;\n\n  /**\n   * frame attributes (for each camera)\n   */\n  attributes: Record<CameraName, Record<Frame, FrameAttributes>> = {};\n\n  /**\n   * initial frame attributes (for each camera)\n   */\n  initialAttributes: Record<CameraName, Record<Frame, FrameAttributes>> = {};\n\n  /**\n   * frame attributes (for all cameras)\n   */\n  frameAttributes: Record<Frame, any> = {};\n\n  /**\n   * initial frame attributes (for all cameras)\n   */\n  initialFrameAttributes: Record<Frame, any> = {};\n\n  /**\n   * next shape orders for different cameras & frames\n   */\n  nextShapeOrders: Record<CameraName, Record<Frame, number[]>> = {};\n\n  /**\n   * current camera name\n   */\n  currentCamera = DEFAULT_CAMERA_NAME;\n\n  /**\n   * current frame by camera\n   */\n  currentFrameByCamera: Record<CameraName, Frame> = {};\n\n  /**\n   * current image name by camera\n   */\n  currentImageByCamera: Record<CameraName, ImageName> = {};\n\n  /**\n   * current time for video\n   */\n  currentVideoTime = 0;\n\n  /**\n   * frame loading\n   */\n  loading = true;\n\n  /**\n   * is playing\n   */\n  isPlaying = false;\n\n  /**\n   * video element if is playing a video\n   */\n  playingVideo?: HTMLVideoElement;\n\n  /**\n   * play timer\n   */\n  playTimer: number | null = null;\n\n  /**\n   * image preloader\n   */\n  imagePreloader: ImagePreloader | null = null;\n\n  /**\n   * frame config (for each camera)\n   */\n  frameConfig?: LabelConfig;\n\n  /**\n   * frame config validity (for each camera)\n   */\n  frameConfigValidity?: {\n    key: string;\n    invalid: any[];\n    valid: any[];\n  };\n\n  /**\n   * frame config (for all cameras)\n   */\n  commonFrameConfig?: LabelConfig;\n\n  /**\n   * frame config common validity (for all cameras)\n   */\n  commonFrameConfigValidity?: {\n    key: string;\n    invalid: any[];\n    valid: any[];\n  };\n\n  /**\n   *  image filters preset\n   */\n  imageFiltersPresets?: ImageFiltersPresets[];\n\n  /**\n   * camera image filters\n   */\n  cameraFilters: CameraFilters = {};\n\n  /**\n   * is single camera\n   * @getter\n   */\n  get isSingleCamera() {\n    return this.cameraCount === 1;\n  }\n\n  /**\n   * camera names\n   * @getter\n   */\n  get cameraNames() {\n    return Object.keys(this.cameraFrames);\n  }\n\n  /**\n   * camera count\n   * @getter\n   */\n  get cameraCount() {\n    return this.cameraNames.length;\n  }\n\n  /**\n   * current camera frame count\n   * @getter\n   */\n  get frameCount() {\n    return this.cameraFrames[this.currentCamera];\n  }\n\n  /**\n   * current camera frame index\n   * @getter\n   */\n  get currentFrame() {\n    return this.currentFrameByCamera[this.currentCamera];\n  }\n\n  /**\n   * current camera image name\n   * @getter\n   */\n  get currentCameraImage() {\n    return this.currentImageByCamera[this.currentCamera] || DEFAULT_FRAME_IMAGE_NAME;\n  }\n\n  /**\n   * current camera image boundary\n   * @getter\n   */\n  get imageBounds() {\n    return this.getImageBoundsForCamera(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * current frame rotation, default is 0\n   * @getter\n   */\n  get currentFrameRotation() {\n    return this.getFrameRotationForCamera(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current frame valid, default is valid\n   * @getter\n   */\n  get currentFrameValid() {\n    return this.isFrameValidForCamera(this.currentCamera, this.currentFrame);\n  }\n\n  /**\n   * is current common frame valid, default is valid\n   * @getter\n   */\n  get currentCommonFrameValid() {\n    return this.isCommonFrameValid(this.currentFrame);\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  get currentFrameAttributes() {\n    const { attributes = {} } = this.attributes[this.currentCamera]?.[this.currentFrame] || {};\n    return attributes;\n  }\n\n  /**\n   * invalid frame indexes in summary (just current camera)\n   * @getter\n   */\n  get invalidFrames() {\n    const invalidFrames = new Set<number>();\n    Array.from({ length: this.frameCount }).forEach((item, frameIndex) => {\n      if (!this.isCommonFrameValid(frameIndex)) {\n        invalidFrames.add(frameIndex);\n      }\n    });\n    return Array.from(invalidFrames);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      imageEmbeddings: false,\n      niftiParser: false,\n      dicomParser: false,\n      pdfCache: false,\n      videoCache: false,\n      camerasMapping: false,\n      cameraViews: false,\n      nextShapeOrders: false,\n      playingVideo: false,\n      playTimer: false,\n      imagePreloader: false,\n      imageBounds: false,\n      initialAttributes: false,\n      initialFrameAttributes: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  async init(payload: Payload) {\n    // parse frame config\n    this.frameConfig = parseLabelConfig(payload.frame_config);\n    this.commonFrameConfig = parseLabelConfig(payload.frame_config_common);\n    if (payload.frame_config_validity) {\n      try {\n        this.frameConfigValidity = JSON.parse(payload.frame_config_validity);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('PAYLOAD_ERROR_INVALID_VALIDITY', {\n            values: {\n              validity: payload.frame_config_validity,\n            }\n          })\n        });\n      }\n    }\n    if (payload.frame_config_common_validity) {\n      try {\n        this.commonFrameConfigValidity = JSON.parse(payload.frame_config_common_validity);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('PAYLOAD_ERROR_INVALID_VALIDITY', {\n            values: {\n              validity: payload.frame_config_common_validity,\n            }\n          })\n        });\n      }\n    }\n    if (payload.image_filters_preset_config) {\n      try {\n        this.imageFiltersPresets = JSON.parse(Base64.decode(payload.image_filters_preset_config));\n      } catch (error) {\n        this.imageFiltersPresets = undefined;\n      }\n    }\n\n    const { cameras = [], niftiUrl, dicomDirUrl } = await parseFramesByPaylod(payload, this.rootStore);\n    if (niftiUrl) {\n      this.niftiParser = new NIFTIParser(niftiUrl);\n      await this.niftiParser.load();\n\n      [Plane.AXIAL, Plane.SAGITTAL, Plane.CORONAL].forEach((cameraKey) => {\n        this.createCameraView(cameraKey);\n\n        const frameCount = this.niftiParser!.getPlaneDimension(cameraKey);\n        this.cameraFrames[cameraKey] = frameCount;\n        this.cameraImages[cameraKey] = Array.from({ length: frameCount }).map(() => ({}));\n        this.currentFrameByCamera[cameraKey] = Math.floor(frameCount / 2);\n      });\n      this.setDefaultAttributes();\n      this.setCamera(Plane.AXIAL);\n\n      // 设置nifti store\n      this.rootStore.initNIFTIStore();\n      // 禁用一部分功能\n      this.rootStore.config.viewRotatable = false;\n      return;\n    }\n    if (dicomDirUrl) {\n      this.dicomParser = new DICOMParser(dicomDirUrl);\n      await this.dicomParser.load();\n\n      const allCameras = Object.keys(this.dicomParser.cameras);\n      allCameras.forEach((cameraKey) => {\n        const cameraView = this.createCameraView(cameraKey) as DICOMView;\n        cameraView.images = this.dicomParser!.cameras[cameraKey].images;\n        cameraView.imageIndex = 0;\n\n        this.cameraFrames[cameraKey] = cameraView.images.length;\n        this.cameraImages[cameraKey] = Array.from({ length: cameraView.images.length }).map(() => ({}));\n        this.currentFrameByCamera[cameraKey] = cameraView.imageIndex;\n      });\n      this.setDefaultAttributes();\n      this.setCamera(allCameras[0]);\n\n      // 禁用一部分功能\n      this.rootStore.config.viewRotatable = false;\n      return;\n    }\n\n    let preload = true;\n    let pdfLoader: PDFLoader | undefined;\n    for (let i = 0; i < cameras.length; i += 1) {\n      const { camera, images, data } = cameras[i];\n      if (images.length === 1) {\n        const imageNames = Object.keys(images[0]);\n        for (let j = 0; j < imageNames.length; j += 1) {\n          const name = imageNames[j];\n          const url = images[0][name];\n          if (isPDFUrl(url)) {\n            preload = false;\n            if (!pdfLoader) {\n              pdfLoader = new PDFLoader();\n              try {\n                // eslint-disable-next-line no-await-in-loop\n                await pdfLoader.init({ basic: true });\n              } catch (e) {\n                // eslint-disable-next-line no-console\n                console.log('PDF loader init error');\n              }\n            }\n            try {\n              // eslint-disable-next-line no-await-in-loop\n              const { pdfDocument } = await pdfLoader.load(this.rootStore.proxyResource(url));\n              if (!this.pdfCache[camera]) {\n                this.pdfCache[camera] = {};\n              }\n              this.pdfCache[camera][name] = pdfDocument;\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.log('Failed to load PDF:', url);\n            }\n          } else if (isVideoUrl(url)) {\n            preload = false;\n            const video = document.createElement('video');\n            video.src = this.rootStore.proxyResource(url);\n            video.crossOrigin = 'anonymous';\n            // for cached video, should muted, only used for capture image\n            video.muted = true;\n            // eslint-disable-next-line no-await-in-loop\n            const fps = data?.fps ?? await estimateFPS(video);\n            // eslint-disable-next-line no-await-in-loop\n            const duration = data?.duration ?? await getDuration(video);\n            // last frame duration <= 1/FPS\n            const totalFrames = Math.ceil(fps * duration);\n            if (!this.videoCache[camera]) {\n              this.videoCache[camera] = {};\n            }\n            this.videoCache[camera][name] = { video, fps, totalFrames };\n          }\n        }\n      }\n    }\n\n    cameras.forEach(({ camera, images, embeddings, calibrations }) => {\n      const firstName = Object.keys(images[0] ?? {})[0];\n      const count = this.pdfCache[camera]?.[firstName]?.totalPages\n        ?? this.videoCache[camera]?.[firstName]?.totalFrames\n        ?? images.length;\n      this.cameraFrames[camera] = count;\n      // update embeddings\n      this.imageEmbeddings[camera] = embeddings || [];\n      // set calibrations\n      this.camerasMapping.setCalibrations(camera, calibrations);\n    });\n\n    this.setDefaultAttributes();\n    await this.parseEmbeddings();\n    runInAction(() => {\n      if (cameras.length > 0) {\n        const cameraImagesList: Record<CameraName, Record<ImageName, string>[]> = {};\n        for (let i = 0; i < cameras.length; i += 1) {\n          const { camera, images } = cameras[i];\n          cameraImagesList[camera] = images;\n          // setup camera container\n          this.createCameraView(camera);\n          // update current frame for camera\n          this.currentFrameByCamera[camera] = 0;\n        }\n        this.cameraImages = cameraImagesList;\n        // set current camera\n        this.setCamera(cameras[0].camera);\n        // preload image\n        if (preload) {\n          // 预加载仅加载每个相机每一帧的第一张图片\n          const allImages = Array.from({ length: Math.max(...Object.values(this.cameraFrames)) })\n            .flatMap((_, i) => cameras.map(({ camera }) => (\n              this.rootStore.proxyResource(Object.values(cameraImagesList[camera]?.[i] ?? {})[0] ?? '')\n            )));\n          this.imagePreloader = loader(allImages);\n        }\n      }\n    });\n  }\n\n  /**\n   * update resource\n   * @param resource\n   */\n  async updateResource(resource: unknown) {\n    const { cameras = [], niftiUrl, dicomDirUrl } = await parseFramesByPaylod({ base_url: resource as string });\n    if (niftiUrl || dicomDirUrl) {\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console.log(`Update resource from ${resource}. Parsed data:`, cameras);\n    cameras.forEach(({ camera, images, embeddings }) => {\n      this.cameraImages[camera] = images;\n      if (embeddings && embeddings.length > 0) {\n        this.imageEmbeddings[camera] = embeddings;\n      }\n    });\n    if (this.imagePreloader) {\n      const frameCount = Math.max(...Object.values(this.cameraFrames));\n      const allImages = Array.from({ length: frameCount })\n        .flatMap((_, i) => cameras.map(({ camera }) => (\n          this.rootStore.proxyResource(Object.values(this.cameraImages[camera]?.[i] ?? {})[0] ?? '')\n        )));\n      this.imagePreloader.images = allImages;\n    }\n  }\n\n  /**\n   * parse embeddings from flow data\n   */\n  async parseEmbeddings() {\n    try {\n      const flowData = JSON.parse(this.rootStore.jobProxy?.flowData || '');\n      const link = flowData?.appen_ai_image_2d_pre_embedding_sam;\n      if (link) {\n        const { cameras = [] } = await parseFramesByPaylod({ base_url: link });\n        cameras.forEach(({ camera, embeddings }) => {\n          embeddings?.forEach((embedding, index) => {\n            if (!this.imageEmbeddings[camera][index] && embedding) {\n              // update\n              this.imageEmbeddings[camera][index] = embedding;\n            }\n          });\n        });\n      }\n    } catch (e) {\n      // error\n    }\n  }\n\n  /**\n   * set default frame attributes\n   */\n  setDefaultAttributes() {\n    let defaultAttributes: any;\n    if (this.frameConfig) {\n      const { updatedValues } = triggerFormRules(this.frameConfig, {});\n      if (updatedValues && Object.keys(updatedValues).length > 0) {\n        defaultAttributes = updatedValues;\n      }\n    }\n    const attributes: {\n      [camera: string]: {\n        [frameIndex: number]: FrameAttributes;\n      }\n    } = {};\n    Object.keys(this.cameraFrames).forEach((camera) => {\n      if (!attributes[camera]) {\n        attributes[camera] = {};\n      }\n      Array.from({ length: this.cameraFrames[camera] }).forEach((_, frameIndex) => {\n        if (!attributes[camera][frameIndex]) {\n          attributes[camera][frameIndex] = {\n            frameIndex,\n            valid: true,\n            originValid: true,\n            rotation: 0,\n          };\n        }\n        if (defaultAttributes) {\n          if (this.rootStore.annotatable) {\n            // save to attributes directly\n            attributes[camera][frameIndex].attributes = { ...defaultAttributes };\n          } else {\n            // just show attribute keys if no value\n            attributes[camera][frameIndex].attributes = {};\n            Object.keys(defaultAttributes).forEach((key) => {\n              attributes[camera][frameIndex].attributes[key] = '';\n            });\n          }\n        }\n      });\n    });\n    this.attributes = attributes;\n    this.initialAttributes = attributes;\n    if (this.commonFrameConfig) {\n      const { updatedValues } = triggerFormRules(this.commonFrameConfig, {});\n      if (updatedValues && Object.keys(updatedValues).length > 0) {\n        // has default value\n        const frameAttributes: {\n          [frameIndex: number]: any;\n        } = {};\n        const maxFrameCount = Math.max(...Object.values(this.cameraFrames));\n        for (let i = 0; i < maxFrameCount; i += 1) {\n          if (this.rootStore.annotatable) {\n            frameAttributes[i] = { ...updatedValues };\n          } else {\n            frameAttributes[i] = {};\n            Object.keys(updatedValues).forEach((key) => {\n              frameAttributes[i][key] = '';\n            });\n          }\n        }\n        this.frameAttributes = frameAttributes;\n        this.initialFrameAttributes = frameAttributes;\n      }\n    }\n  }\n\n  /**\n   * init attributes\n   * @param result\n   */\n  initAttributes(result: any) {\n    this.clearAttributes();\n    const { frames: attrs } = result;\n    if (Array.isArray(attrs)) {\n      const attributes = toJS(this.attributes);\n\n      attrs.forEach((cameraItem) => {\n        const { camera, frames } = cameraItem || {};\n        if (camera) {\n          if (!attributes[camera]) {\n            attributes[camera] = {};\n          }\n          if (Array.isArray(frames)) {\n            frames.forEach((frameItem) => {\n              const { frameIndex, imageUrl, imageUrls, imageWidth, imageHeight, valid, originValid, rotation, attributes: frameAttributes, ...legacyAttributes } = frameItem;\n              attributes[camera][frameIndex] = {\n                ...attributes[camera][frameIndex],\n                frameIndex,\n                imageUrl,\n                imageUrls,\n                imageWidth,\n                imageHeight,\n                valid: valid !== false && valid !== 'false',\n                rotation: rotation % (Math.PI / 2) === 0 ? rotation : 0,\n                attributes: frameAttributes || Object.keys(legacyAttributes).length > 0 ? cloneDeep({ ...legacyAttributes, ...frameAttributes }) : undefined,\n              };\n              if (originValid === undefined) {\n                attributes[camera][frameIndex].originValid = attributes[camera][frameIndex].valid;\n              } else {\n                attributes[camera][frameIndex].originValid = originValid;\n              }\n            });\n          }\n        }\n      });\n\n      this.attributes = attributes;\n    }\n    const { frames: frameAttrs } = result?.attributes || {};\n    if (Array.isArray(frameAttrs)) {\n      const frameAttributes = toJS(this.frameAttributes);\n      frameAttrs.forEach((item) => {\n        const { frameIndex, attributes } = item || {};\n        if (frameIndex !== undefined && !!attributes) {\n          frameAttributes[frameIndex] = attributes;\n        }\n      });\n      this.frameAttributes = frameAttributes;\n    }\n  }\n\n  clearAttributes() {\n    this.attributes = cloneDeep(this.initialAttributes);\n    this.frameAttributes = cloneDeep(this.initialFrameAttributes);\n  }\n\n  /**\n   * init tool config\n   * @param toolConfig\n   */\n  initToolConfig(toolConfig: { cameraFilters?: CameraFilters }) {\n    if (toolConfig?.cameraFilters) {\n      this.cameraFilters = { ...toolConfig.cameraFilters };\n    }\n  }\n\n  /**\n   * create camera view\n   * @param camera\n   */\n  createCameraView(camera: string) {\n    const { layers, activeLayerIndex, auxiliaryLines, autoSnapPoint, needThumbnailLayer, canvasConfig } = this.rootStore.config;\n    const options = {\n      id: camera,\n      layers,\n      enableThumbnail: needThumbnailLayer,\n      enableReview: this.rootStore.jobProxy?.loadReviewEnabled,\n      enableSnap: autoSnapPoint,\n      showGrid: canvasConfig.gridVisible,\n      gridSize: canvasConfig.gap,\n      ...auxiliaryLines && { auxiliaryLines },\n    };\n    let cameraView: View;\n    if (this.niftiParser) {\n      cameraView = new NIFTIView(options);\n    } else if (this.dicomParser) {\n      cameraView = new DICOMView({\n        ...options,\n        cornerstone: this.dicomParser.cornerstone,\n        cornerstoneWADOImageLoader: this.dicomParser.cornerstoneWADOImageLoader,\n      });\n    } else {\n      cameraView = new View(options);\n    }\n\n    // bind listeners\n    cameraView.on(EventAction.SELECTED, (event, view) => {\n      if (view !== this.currentCameraView) {\n        if (this.currentCameraView && this.rootStore.config.pixelSearchVisible) {\n          const p = this.currentCameraView.pixelMarkPosition;\n          this.currentCameraView.removePixelMark();\n          if (p) {\n            view.fitPixelMarkToView(p);\n          }\n        }\n        this.setCamera(view.id);\n      }\n      if (event.button === 2) {\n        return;\n      }\n      this.rootStore.unselect(event);\n    });\n    cameraView.on(EventAction.POINTERDOWN, (p, selectedChanged, event, view) => {\n      if (this.rootStore.config.isWorkingOnAnyShape) {\n        return; // ignore click when cutting polygon or splitting polygon\n      }\n      if (event.button === 2) {\n        return;\n      }\n      if (this.rootStore.config.reviewMode === ReviewMode.LABELING) {\n        const shape = this.rootStore.shape.addShape(p, event);\n        if (shape) {\n          return;\n        }\n      } else {\n        const review = this.rootStore.review.addReview(p);\n        if (review) {\n          return;\n        }\n      }\n      if (cameraView instanceof NIFTIView && !selectedChanged) {\n        this.syncNIFTIViews(cameraView.id, p.x, p.y);\n      } else if (\n        this.rootStore.initialized &&\n        !this.rootStore.config.addMode &&\n        !this.rootStore.review.addMode &&\n        !(\n          this.rootStore.config.rotatable &&\n          event.ctrlKey &&\n          this.rootStore.config.preferences.shapeRotateMode === ShapeRotateMode.CTRL\n        )\n      ) {\n        view.startSelect();\n      }\n    });\n    cameraView.on(EventAction.BLANK_POINTERUP_RIGHT, (event) => {\n      this.rootStore.unselect(event);\n      this.rootStore.openContextMenu({\n        x: event.clientX,\n        y: event.clientY,\n      });\n    });\n    cameraView.on(EventAction.SCALE_CHANGED, (scale) => {\n      this.rootStore.config.setViewScale(scale, camera);\n    });\n    cameraView.on(EventAction.POSITION_CHANGED, (p) => {\n      this.rootStore.config.setViewPosition(p, camera);\n    });\n    cameraView.on(EventAction.SHAPES_SELECTED, (shapes) => this.rootStore.shape.setSelectedShapes(shapes));\n    cameraView.on(EventAction.POINTS_SELECTED, (points) => this.rootStore.shape.setSelectedPoints(points));\n\n    cameraView.activeLayerIndex = activeLayerIndex;\n    this.cameraViews[camera] = cameraView;\n    return cameraView;\n  }\n\n  /**\n   * get image url\n   * @param camera\n   * @param frameIndex\n   */\n  getImageUrl(camera: string, frameIndex: number) {\n    const imageName = this.currentImageByCamera[camera] || DEFAULT_FRAME_IMAGE_NAME;\n    return this.cameraImages[camera]?.[frameIndex]?.[imageName] ?? '';\n  }\n\n  /**\n   * get readable image\n   * @param camera\n   * @param frameIndex\n   */\n  getReadableImage(camera: string, frameIndex: number) {\n    if (this.niftiParser) {\n      // 获取base64\n      const image = this.niftiParser.getPlaneImage(camera, frameIndex);\n      return image?.toDataURL().split(';base64,')[1] ?? '';\n    }\n    return this.getImageUrl(camera, frameIndex);\n  }\n\n  /**\n   * get pdf document by camera\n   * @param camera\n   */\n  getPDFDocument(camera: string) {\n    const imageName = this.currentImageByCamera[camera] || DEFAULT_FRAME_IMAGE_NAME;\n    return this.pdfCache[camera]?.[imageName];\n  }\n\n  /**\n   * get video by camera\n   * @param camera\n   */\n  getVideo(camera: string) {\n    const imageName = this.currentImageByCamera[camera] || DEFAULT_FRAME_IMAGE_NAME;\n    return this.videoCache[camera]?.[imageName];\n  }\n\n  /**\n   * get image bounds for camera\n   * @param camera\n   * @param frameIndex\n   */\n  getImageBoundsForCamera(camera: string, frameIndex: number) {\n    // const cameraView = this.cameraViews[camera];\n    // let w = cameraView?.image.width;\n    // let h = cameraView?.image.height;\n    // if (cameraView?.imageRotation % Math.PI !== 0) {\n    //   w = cameraView?.image.height;\n    //   h = cameraView?.image.width;\n    // }\n    const { imageWidth, imageHeight, rotation } = this.attributes[camera]?.[frameIndex] || {};\n    let w = imageWidth;\n    let h = imageHeight;\n    if (rotation % Math.PI !== 0) {\n      w = imageHeight;\n      h = imageWidth;\n    }\n    return { left: 0, top: 0, right: w || 0, bottom: h || 0 };\n  }\n\n  /**\n   * set current camera\n   * @param camera\n   */\n  setCamera(camera: string) {\n    this.rootStore.shape.cancelCreateShape();\n    if (this.rootStore.config.isWorkingOnAnyShape) {\n      return;\n    }\n    // cancel working status\n    this.rootStore.shape.clearPendingWithAlert();\n    this.rootStore.cancelShapeWorking();\n    // reset camera selected status\n    if (this.currentCameraView) {\n      this.currentCameraView.selected = false;\n    }\n    // set selected camera\n    this.currentCamera = camera;\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.selected = true;\n      this.currentCameraView = cameraView;\n      this.updateCameraLayers(cameraView);\n    }\n    // sync dicom views?\n    // this.syncDICOMViews();\n    // update current image\n    this.updateCurrentImage();\n    // update shapes selected status\n    const { selectedInstances } = this.rootStore.instance;\n    this.rootStore.instance.selectInstanceItem(null);\n    this.rootStore.instance.selectInstance(selectedInstances);\n    // update pixel info\n    this.rootStore.segmentation.reset();\n    // preload image for recognizer\n    this.rootStore.shape.loadImageForRecognizer();\n  }\n\n  /**\n   * update working layers by camera view\n   * @param cameraView\n   */\n  updateCameraLayers(cameraView: View) {\n    // update view scale\n    this.rootStore.config.setViewScale(cameraView.viewScale);\n    // update shapes layer\n    this.rootStore.shape.currentLayer = cameraView.activeShapesLayer;\n    // update review layer\n    if (cameraView.reviewLayer) {\n      this.rootStore.review.setReviewLayer(cameraView.reviewLayer);\n      this.rootStore.review.setReviewLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n    if (cameraView.thumbnailLayer) {\n      this.rootStore.thumbnail.setThumbnailLayer(cameraView.thumbnailLayer);\n      this.rootStore.thumbnail.setThumbnailLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n  }\n\n  /**\n   * set frame for all cameras\n   * @param frameIndex\n   */\n  setFrameForCameras(frameIndex: Frame) {\n    // TODO: may add pdf & video\n    const keepFrameInAllCameras = !this.niftiParser && !this.dicomParser;\n    const frames: Record<CameraName, Frame> = {};\n    for (let i = 0; i < this.cameraNames.length; i += 1) {\n      const camera = this.cameraNames[i];\n      if (\n        this.currentFrameByCamera[camera] !== frameIndex &&\n        (keepFrameInAllCameras || camera === this.currentCamera)\n      ) {\n        frames[camera] = frameIndex;\n      }\n    }\n    if (Object.values(frames).length > 0) {\n      this.currentFrameByCamera = {\n        ...this.currentFrameByCamera,\n        ...frames,\n      };\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * set current frame\n   * @param frameIndex\n   * @param manual\n   */\n  setFrame(frameIndex: number, manual = false) {\n    const frameChange = this.setFrameForCameras(frameIndex);\n    if (frameChange) {\n      // frame changes\n      this.updateCurrentImage();\n      this.rootStore.config.setMeasureMode(false);\n      const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n      if (!isGridView) {\n        this.loading = true;\n        this.rootStore.config.setContextMenuVisible(false);\n        this.rootStore.review.clearAnchors();\n      }\n      if (!this.isPlaying) {\n        // not auto playing\n        const videoObj = this.getVideo(this.currentCamera);\n        if (videoObj) {\n          this.currentVideoTime = frameIndex / videoObj.fps;\n        }\n      } else if (manual && this.playingVideo) {\n        // auto playing, update playing video time\n        const videoObj = this.getVideo(this.currentCamera);\n        if (videoObj) {\n          this.playingVideo.currentTime = frameIndex / videoObj.fps;\n        }\n      }\n    }\n    return frameChange;\n  }\n\n  /**\n   * sync to set current frame\n   * @param frameIndex\n   * @param manual\n   */\n  setFrameSync(frameIndex: number, manual = false) {\n    return new Promise<void>((resolve) => {\n      const frameChange = this.setFrame(frameIndex, manual);\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT && frameChange) {\n        const disposer = reaction(\n          () => this.loading,\n          () => {\n            if (!this.loading) {\n              resolve();\n              disposer();\n            }\n          },\n        );\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * when frame loaded\n   * @param image\n   */\n  async onFrameLoaded() {\n    const keepWorkingOnPixelShapeToolMode = this.rootStore.segmentation.currMode;\n\n    this.camerasMapping.setFrame(this.currentFrame);\n\n    // turn off add mode\n    this.rootStore.config.setAddMode(false, false);\n    // update pixel info\n    this.rootStore.segmentation.reset(this.rootStore.config.viewMode === ViewMode.GRID);\n    // setup current shapes\n    this.rootStore.shape.setupShapes();\n    // setup relationships\n    this.rootStore.relationship.setupConnections();\n    // setup reivew anchors\n    this.rootStore.review.setupReviewAnchors();\n    // redraw empty area\n    this.rootStore.validation.redrawCheckLayer();\n\n    // select shape\n    const { selectedInstanceItems, selectedInstances } = this.rootStore.instance;\n    if (selectedInstanceItems.length > 0) {\n      this.rootStore.shape.selectShapeByInstanceItem(selectedInstanceItems, false);\n    } else if (selectedInstances.length > 0) {\n      this.rootStore.shape.updateShapesInInstance(selectedInstances);\n      this.rootStore.shape.hideOrShowOthers();\n    } else {\n      this.rootStore.shape.hideOrShowOthers();\n    }\n    // predict\n    await this.rootStore.shape.predict();\n    // 更新投影\n    this.rootStore.nifti?.projectShapes();\n\n    // keep working on pixel shape\n    if (keepWorkingOnPixelShapeToolMode !== PixelToolMode.NONE) {\n      const selectedShape = this.rootStore.shape.selectedShapes[0];\n      if (selectedShape instanceof Pixel) {\n        this.rootStore.segmentation.setMode(keepWorkingOnPixelShapeToolMode);\n      }\n    }\n\n    this.loading = false;\n\n    // set preview mode to false to force recache bitmap\n    if (this.rootStore.config.previewMode) {\n      Object.values(this.cameraViews).forEach((view) => {\n        view.setPreviewMode(false);\n      });\n    }\n    this.updatePreviewMode();\n\n    // preload image\n    this.imagePreloader?.preload((this.currentFrame + 1) * this.cameraCount);\n    // preload image for recognizer\n    this.rootStore.shape.loadImageForRecognizer();\n\n    // when loaded, if is auto playing, play next frame\n    if (this.isPlaying && !this.getVideo(this.currentCamera)) {\n      this.playTimer = window.setTimeout(() => {\n        this.setFrameByAutoPlay();\n      }, 300);\n    }\n  }\n\n  /**\n   * go to previous frame by step\n   * @param step\n   */\n  prev(step: number) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.max(this.currentFrame - step, 0));\n    }\n  }\n\n  /**\n   * go to next frame by step\n   * @param step\n   */\n  next(step: number) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.min(this.currentFrame + step, this.frameCount - 1));\n    }\n  }\n\n  /**\n   * toggle playing\n   */\n  togglePlaying() {\n    this.isPlaying = !this.isPlaying;\n\n    const videoPlay = this.autoPlayVideo();\n    if (videoPlay) {\n      return;\n    }\n\n    if (this.isPlaying) {\n      this.setFrameByAutoPlay();\n    } else if (this.playTimer) {\n      window.clearTimeout(this.playTimer);\n      this.playTimer = null;\n    }\n  }\n\n  /**\n   * set frame by auto play\n   */\n  setFrameByAutoPlay() {\n    if (this.currentFrame < this.frameCount - 1) {\n      this.setFrame(this.currentFrame + 1);\n    } else {\n      this.isPlaying = false;\n      this.setFrame(0);\n    }\n  }\n\n  /**\n   * play video\n   */\n  autoPlayVideo() {\n    const videoObj = this.getVideo(this.currentCamera);\n    if (videoObj) {\n      if (this.isPlaying) {\n        const { video, fps } = videoObj;\n        if (!this.playingVideo) {\n          this.playingVideo = document.createElement('video');\n        }\n        this.playingVideo.src = video.src;\n        this.playingVideo.crossOrigin = 'anonymous';\n\n        if (this.currentFrame >= this.frameCount - 1) {\n          // last frame\n          this.setFrameForCameras(0);\n        }\n        const startTime = this.currentFrame / fps;\n        this.playingVideo.currentTime = startTime;\n        this.playingVideo.play();\n        requestAnimationFrame(() => this.playVideo(fps));\n      } else {\n        this.playingVideo?.pause();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * play video\n   */\n  playVideo(fps: number) {\n    if (!this.playingVideo) {\n      return;\n    }\n    const { currentTime } = this.playingVideo;\n    const videoFrame = Math.floor(currentTime * fps);\n    if (videoFrame > this.currentFrame) {\n      this.setFrame(videoFrame);\n    }\n    this.currentVideoTime = currentTime;\n    if (currentTime >= this.playingVideo.duration) {\n      // end\n      this.isPlaying = false;\n      return;\n    }\n    if (this.playingVideo.paused || this.playingVideo.ended) {\n      return;\n    }\n    requestAnimationFrame(() => this.playVideo(fps));\n  }\n\n  /**\n   * update current image by current camera & frame\n   */\n  updateCurrentImage() {\n    // set camera image\n    const imageKeys = Object.keys(this.cameraImages[this.currentCamera]?.[this.currentFrame] || {});\n    if (imageKeys.length <= 1) {\n      return;\n    }\n    if (imageKeys.indexOf(this.currentCameraImage) < 0) {\n      this.currentImageByCamera[this.currentCamera] = imageKeys[0];\n    }\n  }\n\n  /**\n   * set image\n   * @param image\n   */\n  setImage(image: string) {\n    this.currentImageByCamera[this.currentCamera] = image;\n  }\n\n  /**\n   * switch image\n   */\n  switchImage() {\n    if (this.rootStore.config.viewMode === ViewMode.GRID) {\n      return;\n    }\n    const imageKeys = Object.keys(this.cameraImages[this.currentCamera]?.[this.currentFrame] || {});\n    if (imageKeys.length <= 1) {\n      return;\n    }\n    const index = imageKeys.indexOf(this.currentCameraImage);\n    const nextIndex = (index + 1) % imageKeys.length;\n    this.setImage(imageKeys[nextIndex]);\n  }\n\n  /**\n   * can update attributes by camera & frameIndex\n   * @param camera\n   * @param frameIndex\n   */\n  canUpdateFrameForCamera(camera: string, frameIndex: number) {\n    if (this.rootStore.readonly) {\n      return false;\n    }\n    if (!this.attributes[camera] || !this.attributes[camera][frameIndex]) {\n      // attributes not initialized as expected, may have wrong frames or base_url input\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * get frame rotation\n   * @param camera\n   * @param frameIndex\n   */\n  getFrameRotationForCamera(camera: string, frameIndex: number) {\n    if (!this.attributes[camera]) {\n      return 0;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return 0;\n    }\n    return this.attributes[camera][frameIndex].rotation || 0;\n  }\n\n  /**\n   * set frame rotation\n   * @param camera\n   * @param frameIndex\n   * @param rotation\n   */\n  setFrameRotationForCamera(camera: string, frameIndex: number, rotation: number) {\n    if (!this.canUpdateFrameForCamera(camera, frameIndex)) {\n      return;\n    }\n\n    // calc rotation diff\n    let diff = rotation - this.currentFrameRotation;\n    if (diff > Math.PI) {\n      diff -= Math.PI * 2;\n    } else if (diff <= -Math.PI) {\n      diff += Math.PI * 2;\n    }\n\n    const { left, top, right, bottom } = this.imageBounds;\n    const imageWidth = right - left;\n    const imageHeight = bottom - top;\n    const LTPoint = { x: left, y: top };\n    const rotatedLTPoint = { ...LTPoint };\n    if (diff === -Math.PI / 2) {\n      // anti-clockwise 90 degrees\n      rotatedLTPoint.y -= imageWidth;\n    } else if (diff === Math.PI) {\n      // anti-clockwise 180 degrees\n      rotatedLTPoint.x -= imageWidth;\n      rotatedLTPoint.y -= imageHeight;\n    } else if (diff === Math.PI / 2) {\n      // anti-clockwise 270 degrees\n      rotatedLTPoint.x -= imageHeight;\n    }\n\n    // rotate shapes\n    const { prevState, currState } = this.rootStore.shape.rotateShapesByCanvas(diff, LTPoint, rotatedLTPoint.x, rotatedLTPoint.y);\n\n    // save rotation\n    const storeId = this.rootStore.undo.preserve({\n      ...prevState,\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n    this.attributes[camera][frameIndex].rotation = rotation;\n    this.rootStore.undo.save(storeId, {\n      ...currState,\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n\n    // set rotation for camera view\n    this.cameraViews[camera].imageRotation = rotation;\n    this.cameraViews[camera].rotate();\n    // update shapes bounds\n    this.rootStore.shape.updateShapesBounds();\n    // update pixel info\n    this.rootStore.segmentation.reset();\n  }\n\n  /**\n   * is frame valid\n   * @param camera\n   * @param frameIndex\n   */\n  isFrameValidForCamera(camera: string, frameIndex: number) {\n    if (!this.attributes[camera]) {\n      return true;\n    }\n    if (!this.attributes[camera][frameIndex]) {\n      return true;\n    }\n    const validKey = this.frameConfigValidity?.key;\n    if (!validKey || !this.rootStore.annotatable) {\n      return this.attributes[camera][frameIndex].valid !== false;\n    }\n    const invalidValues = this.frameConfigValidity?.invalid || [];\n    const currentValue = this.attributes[camera][frameIndex].attributes?.[validKey];\n    return !invalidValues.includes(currentValue);\n  }\n\n  /**\n   * is frame common valid\n   * @param frameIndex\n   */\n  isCommonFrameValid(frameIndex: number) {\n    if (!this.frameAttributes) {\n      return true;\n    }\n    if (!this.frameAttributes[frameIndex]) {\n      return true;\n    }\n    const validKey = this.commonFrameConfigValidity?.key;\n    if (!validKey) {\n      return true;\n    }\n    const invalidValues = this.commonFrameConfigValidity?.invalid || [];\n    const currentValue = this.frameAttributes[frameIndex][validKey];\n    return !invalidValues.includes(currentValue);\n  }\n\n  /**\n   * set frame valid\n   * @param camera\n   * @param frameIndex\n   * @param valid\n   */\n  setFrameValidForCamera(camera: string, frameIndex: number, valid: boolean) {\n    if (!this.canUpdateFrameForCamera(camera, frameIndex)) {\n      return;\n    }\n\n    const storeId = this.rootStore.undo.preserve({\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n    this.attributes[camera][frameIndex].valid = valid;\n    this.rootStore.undo.save(storeId, {\n      frames: [{ camera, frames: [toJS(this.attributes[camera][frameIndex])] }],\n    });\n  }\n\n  /**\n   * set frame attributes\n   * @param camera\n   * @param frames\n   * @param replaceAttributes\n   */\n  updateFrameAttributesForCamera(camera: string, frames: number[], replaceAttributes: any) {\n    const currentFramesData: FrameAttributes[] = [];\n    const newFramesData: FrameAttributes[] = [];\n\n    frames.forEach((frameIndex) => {\n      if (this.canUpdateFrameForCamera(camera, frameIndex)) {\n        const preFrameAttrs = toJS(this.attributes[camera][frameIndex]);\n        currentFramesData.push(preFrameAttrs);\n        this.attributes[camera][frameIndex].attributes = {\n          ...preFrameAttrs.attributes,\n          ...replaceAttributes\n        };\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{ camera, frames: currentFramesData }],\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{ camera, frames: newFramesData }],\n      });\n    }\n  }\n\n  /**\n   * set frame attributes\n   * @param camera\n   * @param updatedFrameAttributes\n   */\n  setFrameAttributesForCamera(camera: string, updatedFrameAttributes: FrameAttributes[]) {\n    const currentFramesData: FrameAttributes[] = [];\n    const newFramesData: FrameAttributes[] = [];\n    for (let i = 0; i < updatedFrameAttributes.length; i += 1) {\n      const { frameIndex, attributes } = updatedFrameAttributes[i];\n      if (this.canUpdateFrameForCamera(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n        if (this.isFrameValidForCamera(camera, frameIndex)) {\n          this.attributes[camera][frameIndex].originValid = true;\n        }\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    }\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{ camera, frames: currentFramesData }],\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{ camera, frames: newFramesData }],\n      });\n    }\n  }\n\n  /**\n   * set common frame attributes\n   * @param updatedFrameAttributes\n   */\n  setCommonFrameAttributes(updatedFrameAttributes: CommonFrameAttributes[]) {\n    const storeId = this.rootStore.undo.preserve({\n      attributes: this.attributesJSON(),\n    });\n    for (let i = 0; i < updatedFrameAttributes.length; i += 1) {\n      const { frameIndex, attributes } = updatedFrameAttributes[i];\n      this.frameAttributes[frameIndex] = cloneDeep(attributes);\n    }\n    this.rootStore.undo.save(storeId, {\n      attributes: this.attributesJSON(),\n    });\n  }\n\n  /**\n   * get next shape order & do increment\n   * @param layer\n   * @param frameIndex\n   * @param camera\n   */\n  getNextShapeOrder = (\n    layer = this.rootStore.config.activeLayerIndex,\n    frameIndex = this.currentFrame,\n    camera = this.currentCamera,\n  ) => {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n      this.nextShapeOrders[camera][frameIndex] = [];\n    }\n    if (this.nextShapeOrders[camera][frameIndex][layer] === undefined) {\n      this.nextShapeOrders[camera][frameIndex][layer] = this.rootStore.segmentation.enabled ? 1 : 0;\n    }\n\n    const order = this.nextShapeOrders[camera][frameIndex][layer];\n    this.nextShapeOrders[camera][frameIndex][layer] += 1;\n    return order;\n  };\n\n  /**\n   * update next shape order\n   * @param currentOrder\n   * @param layer\n   * @param frameIndex\n   * @param camera\n   */\n  updateNextShapeOrder(\n    currentOrder: number,\n    layer = this.rootStore.config.activeLayerIndex,\n    frameIndex = this.currentFrame,\n    camera = this.currentCamera,\n  ) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n      this.nextShapeOrders[camera][frameIndex] = [];\n    }\n    if (this.nextShapeOrders[camera][frameIndex][layer] === undefined\n      || this.nextShapeOrders[camera][frameIndex][layer] <= currentOrder) {\n      this.nextShapeOrders[camera][frameIndex][layer] = currentOrder + 1;\n    }\n  }\n\n  /**\n   * fix image size if no image width & height\n   */\n  async fixImageSize(showMsg = true) {\n    const noSizeFrames: { camera: string; frameIndex: number; imageUrl: string }[] = [];\n    for (let i = 0; i < this.cameraNames.length; i += 1) {\n      const camera = this.cameraNames[i];\n      const cameraFrames = this.cameraImages[camera];\n      for (let j = 0; j < cameraFrames.length; j += 1) {\n        const { imageWidth, imageHeight } = this.attributes[camera][j];\n        if (imageWidth === undefined || imageHeight === undefined) {\n          // 仅取每个相机每一帧的第一张图片，默认同相机同一帧的图片尺寸一致\n          noSizeFrames.push({ camera, frameIndex: j, imageUrl: Object.values(cameraFrames[j])[0] });\n        }\n      }\n    }\n\n    if (noSizeFrames.length <= 0) {\n      Promise.resolve();\n      return;\n    }\n\n    const count = noSizeFrames.length;\n    let hide: MessageType | undefined;\n    if (showMsg) {\n      hide = message.loading({\n        key: 'loading',\n        duration: 0,\n        content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', { values: { count, finished: 0 } }),\n      });\n    }\n    return new Promise<void>((resolve) => {\n      const queue: string[] = [];\n      let finished = 0;\n      let i = 0;\n      const loadImageSize = ({ camera, frameIndex, imageUrl }: { camera: string; frameIndex: number; imageUrl: string }) => {\n        const finish = () => {\n          finished += 1;\n          if (showMsg) {\n            message.loading({\n              key: 'loading',\n              duration: 0,\n              content: i18n.translate('SUBMIT_FIX_IMAGE_SIZE', { values: { count, finished } }),\n            });\n          }\n          if (finished === count) {\n            if (hide) {\n              hide();\n            }\n            resolve();\n          } else if (i < count - 1) {\n            i += 1;\n            queue.shift();\n            loadImageSize(noSizeFrames[i]);\n          }\n        };\n        const img = new Image();\n        img.onload = () => {\n          this.updateImageSize(camera, frameIndex, img.width, img.height);\n          finish();\n        };\n        img.onerror = () => {\n          this.updateImageSize(camera, frameIndex, -1, -1);\n          finish();\n        };\n        img.src = imageUrl;\n        queue.push(imageUrl);\n        if (queue.length < 10 && i < count - 1) {\n          i += 1;\n          loadImageSize(noSizeFrames[i]);\n        }\n      };\n      loadImageSize(noSizeFrames[i]);\n    });\n  }\n\n  /**\n   * update camera filters\n   * @param camera\n   * @param filters\n   */\n  updateCameraFilters(camera: string, filters: { keep?: boolean; brightness?: number; contrast?: number; saturation?: number; gamma?: number }) {\n    const currFilters = this.getFiltersForCamera(camera);\n\n    const { keep, ...rest } = filters;\n    if (!this.cameraFilters[camera]) {\n      // init camera filters\n      this.cameraFilters[camera] = {\n        keep,\n        frames: {},\n      };\n    } else if (keep !== undefined) {\n      // update keep\n      this.cameraFilters[camera].keep = keep;\n    }\n\n    if (this.cameraFilters[camera].keep) {\n      this.cameraFilters[camera].global = {\n        ...currFilters,\n        ...rest,\n      };\n      this.cameraFilters[camera].frames = {}; // remove all frames settings\n    } else {\n      this.cameraFilters[camera].frames[this.currentFrame] = {\n        ...currFilters,\n        ...rest,\n      };\n    }\n\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.applyFilters(rest);\n    }\n  }\n\n  /**\n   * get image filters presets map\n   */\n  getImageFiltersPresetsMap() {\n    const result: { [key: string]: ImageFilters } = {};\n    this.imageFiltersPresets?.forEach((filterPreset: ImageFiltersPresets) => {\n      const { name, ...rest } = filterPreset;\n      result[filterPreset.name] = rest;\n    });\n    return result;\n  }\n\n  /**\n   * get filters\n   * @param camera\n   */\n  getFiltersForCamera(camera: string) {\n    const { keep = false, global, frames = {} } = this.cameraFilters[camera] || {};\n    if (keep) {\n      return global;\n    }\n    return frames[this.currentFrame] || global;\n  }\n\n  /**\n   * update image size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  updateImageSize(camera: string, frameIndex: number, width: number, height: number) {\n    if (this.attributes[camera] && this.attributes[camera][frameIndex]) {\n      const { imageWidth, imageHeight } = this.attributes[camera][frameIndex];\n      if ((width > 0 && height > 0) || imageWidth === undefined || imageHeight === undefined) {\n        // only update when size valid, or size not initialized\n        this.attributes[camera][frameIndex].imageWidth = width;\n        this.attributes[camera][frameIndex].imageHeight = height;\n        this.camerasMapping.setCameraSize(camera, frameIndex, width, height);\n      }\n    }\n  }\n\n  /**\n   * update active layer index in all cameras\n   */\n  updateActiveLayerIndexInAllCameras() {\n    const { activeLayerIndex } = this.rootStore.config;\n    Object.values(this.cameraViews).forEach((cameraView) => {\n      // update layer index for each camera\n      cameraView.activeLayerIndex = activeLayerIndex;\n      // update current layer for shapes\n      if (cameraView.id === this.currentCamera) {\n        this.rootStore.shape.currentLayer = cameraView.activeShapesLayer;\n      }\n    });\n  }\n\n  updatePreviewMode() {\n    const { previewMode } = this.rootStore.config;\n    const { config, getShapesForCamera } = this.rootStore.shape;\n    const { currentFrame } = this.rootStore.frame;\n    Object.keys(this.cameraViews).forEach((camera) => {\n      const shapes = getShapesForCamera(camera);\n      shapes.forEach(({ shape, instanceItem }) => {\n        if (previewMode) {\n          shape.alpha = 1;\n          shape.borderWidth *= shape.scale;\n          shape.showSideLength = false;\n          shape.showDirection = false;\n          shape.showVertex = false;\n          shape.showVertexOrder = false;\n          shape.interactive = false;\n        } else {\n          shape.alpha = config.fill ? config.alpha / 100 : 0;\n          shape.borderWidth = config.borderWidth;\n          shape.showSideLength = config.showSideLength;\n          shape.showDirection = config.showDirection;\n          shape.showVertex = config.showVertex;\n          shape.showVertexOrder = config.showVertexOrder;\n          shape.interactive = true;\n          shape.editable = !this.rootStore.readonly && !instanceItem.cameras[camera]?.frames[currentFrame]?.locked;\n        }\n      });\n\n      const cameraView = this.cameraViews[camera];\n      cameraView.setPreviewMode(previewMode);\n      if (previewMode) {\n        cameraView.updatePreviewModeAlpha(config.alpha / 100);\n      }\n    });\n  }\n\n  drawNIFTIViews() {\n    if (!this.niftiParser) {\n      return;\n    }\n    const { dims, pixDims } = this.niftiParser;\n    // x轴切帧方向是 L -> R，显示方向是 R -> L，因此需要转换一下\n    const x = (dims[0] - 1 - this.currentFrameByCamera[Plane.SAGITTAL] + 0.5) * pixDims[0];\n    // y、z轴切帧方向和显示方向一致\n    const y = (this.currentFrameByCamera[Plane.CORONAL] + 0.5) * pixDims[1];\n    const z = (this.currentFrameByCamera[Plane.AXIAL] + 0.5) * pixDims[2];\n    Object.values(this.cameraViews).forEach((cameraView) => {\n      if (cameraView instanceof NIFTIView) {\n        cameraView.drawAxisProjection(x, y, z);\n      }\n    });\n  }\n\n  syncNIFTIViews(baseCamera: string, u: number, v: number) {\n    if (!this.niftiParser) {\n      return;\n    }\n    const { dims, pixDims } = this.niftiParser;\n    this.currentFrameByCamera = {\n      ...this.currentFrameByCamera,\n      ...baseCamera === Plane.SAGITTAL ? {\n        [Plane.CORONAL]: Math.min(Math.max(Math.floor(u / pixDims[1]), 0), dims[1] - 1),\n      } : {\n        [Plane.SAGITTAL]: dims[0] - 1 - Math.min(Math.max(Math.floor(u / pixDims[0]), 0), dims[0] - 1),\n      },\n      ...baseCamera === Plane.AXIAL ? {\n        [Plane.CORONAL]: Math.min(Math.max(Math.floor(v / pixDims[1]), 0), dims[1] - 1),\n      } : {\n        [Plane.AXIAL]: Math.min(Math.max(Math.floor(v / pixDims[2]), 0), dims[2] - 1),\n      },\n    };\n  }\n\n  /**\n   * sync all dicom camera views\n   */\n  syncDICOMViews() {\n    if (!this.dicomParser || !(this.currentCameraView instanceof DICOMView)) {\n      return;\n    }\n\n    const { imageIndex: currentImageIndex } = this.currentCameraView;\n    Object.keys(this.dicomParser.cameras).forEach((cameraKey) => {\n      const cameraView = this.cameraViews[cameraKey];\n      if (cameraView instanceof DICOMView) {\n        if (cameraKey !== this.currentCamera) {\n          // 处理非当前相机的case\n          const imageIndex = this.dicomParser!.findClosestImageIndex(\n            this.currentCamera,\n            currentImageIndex,\n            cameraKey,\n          );\n          if (imageIndex >= 0) {\n            // 这里是平行的切片，同步播放（找最近的）\n            cameraView.imageIndex = imageIndex;\n            cameraView.drawProjections();\n          } else {\n            // 无法同步的，要绘制当前切片位置的投影\n            const projections = this.dicomParser!.projectToCamera(\n              this.currentCamera,\n              currentImageIndex,\n              cameraKey,\n              cameraView.imageIndex,\n            );\n            cameraView.drawProjections(projections);\n          }\n        } else {\n          // 清空\n          cameraView.drawProjections();\n        }\n      }\n    });\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  framesJSON(): CameraFrameAttributes[] {\n    return this.cameraNames.map((camera) => ({\n      camera,\n      frames: Array.from({ length: this.frameCount }).map((_, frameIndex) => {\n        const imageUrl = this.getImageUrl(camera, frameIndex);\n        let imageUrls;\n        if (this.cameraImages[camera]?.[frameIndex]) {\n          const urls = Object.values(this.cameraImages[camera][frameIndex]);\n          if (urls.length > 1) {\n            imageUrls = urls;\n          }\n        }\n        return {\n          frameIndex,\n          imageUrl,\n          imageUrls,\n          imageWidth: this.attributes[camera][frameIndex].imageWidth,\n          imageHeight: this.attributes[camera][frameIndex].imageHeight,\n          valid: this.isFrameValidForCamera(camera, frameIndex),\n          originValid: this.attributes[camera][frameIndex].originValid !== false,\n          rotation: this.getFrameRotationForCamera(camera, frameIndex),\n          attributes: toJS(this.attributes[camera][frameIndex].attributes),\n        };\n      }),\n    }));\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  attributesJSON(): Attributes {\n    if (!this.commonFrameConfig && Object.values(this.frameAttributes).length === 0) {\n      // no config & no initial attributes\n      return {};\n    }\n    return {\n      frames: Array.from({ length: this.frameCount }).map((_, frameIndex) => ({\n        frameIndex,\n        valid: this.isCommonFrameValid(frameIndex),\n        attributes: toJS(this.frameAttributes[frameIndex]),\n      })),\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}