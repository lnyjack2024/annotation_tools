{"ast":null,"code":"/* eslint-disable class-methods-use-this */\nimport React from 'react';\nimport hexToRgba from 'hex-to-rgba';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport { notification, Modal } from 'antd';\nimport { defaultColor, formatTimestamp, translate, triggerForm, StyleConfigMode, getConfigColor } from '../../constants';\nimport { getWavesurfers, setPlayingState, setVideoValid, deleteLine, pushLine, setLineRole, parseSegments, setErrorMsg, setAudioErrorMsg, appendSegment, updateSegment, deleteSegment, setSegments, updateLineRole, updateVideoInfo, setLoading } from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { formatTimeCallback, primaryLabelInterval, secondaryLabelInterval, timeInterval } from '../utils/TimelineUtil';\nimport i18n from '../../locales';\nnotification.config({\n  top: 60\n});\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\nclass WavesurferComp extends React.Component {\n  constructor() {\n    super();\n    this.tempRegion = undefined;\n    this.insertLine = data => {\n      // eslint-disable-next-line prefer-const\n      const {\n        segmentIndex,\n        role: currentRole,\n        attributes,\n        region: currentRegion\n      } = data;\n      const {\n        ontology,\n        styleConfig\n      } = this.props;\n      const segment = this.currentSegments[segmentIndex];\n      const region = currentRegion || this.getRegionById(segment === null || segment === void 0 ? void 0 : segment.id);\n      if (region) {\n        var _styleConfig$groups;\n        const role = currentRole || 'none';\n        let configColor = '';\n        if (attributes && (styleConfig === null || styleConfig === void 0 ? void 0 : (_styleConfig$groups = styleConfig.groups) === null || _styleConfig$groups === void 0 ? void 0 : _styleConfig$groups.length) > 0) {\n          configColor = getConfigColor(attributes, styleConfig.groups);\n        }\n        const color = hexToRgba(configColor || ontology.get(role) || defaultColor.defaultWhite, role === 'none' && !configColor ? 0 : defaultColor.defaultAlpha);\n        region.element.classList.add('line-region');\n        const mark = document.createElement('div');\n        mark.className = 'line-mark';\n        mark.style.background = color;\n        region.element.appendChild(mark);\n        Array.from(region.element.getElementsByClassName('line-mark')).forEach((line, index, array) => {\n          const height = 100 / array.length;\n          const top = height * index;\n          line.style.height = `${height}%`;\n          line.style.top = `${top}%`;\n        });\n      }\n    };\n    this.setCurrentZoom = newZoom => {\n      if (newZoom) {\n        this.current.zoom = newZoom;\n      }\n      const {\n        zoom,\n        videoIndex,\n        wavesurfer\n      } = this.current;\n      if (wavesurfer) {\n        const duration = this.wavesurfers[videoIndex].getDuration();\n        const cursorTime = this.getCursorTime();\n        const currentTime = wavesurfer.getCurrentTime();\n        const {\n          offsetWidth\n        } = wavesurfer.container;\n        const {\n          offsetLeft\n        } = wavesurfer.cursor.cursor;\n        const totalWidth = offsetWidth * zoom;\n        const pxPerSec = totalWidth / duration;\n        wavesurfer.zoom(pxPerSec);\n        this.setCurrentScroll(cursorTime < 0 ? currentTime : cursorTime, cursorTime < 0 ? offsetWidth / 2 : offsetLeft, false);\n      }\n    };\n    this.handleKeyDown = e => {\n      if (!e.key) return;\n      if (window.disableLongAudioHotKeys) return;\n      if (isInput()) return;\n      if (isAnnotationReadonly(this.props.toolMode)) return;\n      if (e.altKey && this.props.segmentOverlap) {\n        this.altKeyDown = true;\n        if (this.hoveredRegion) {\n          this.hoveredRegion.drag = false;\n          this.hoveredRegion.resize = false;\n        }\n      }\n      switch (e.keyCode) {\n        case 8: // backspace\n        case 46:\n          // delete\n          if (e.ctrlKey) {\n            this.clearAll();\n          } else {\n            this.deleteCurrentSegment();\n          }\n          break;\n        case 90:\n          // z\n          if (e.ctrlKey) {\n            this.recallHistory('undo');\n          }\n          break;\n        case 89:\n          // y\n          if (e.ctrlKey) {\n            this.recallHistory('redo');\n          }\n          break;\n        default:\n      }\n    };\n    this.handleKeyUp = e => {\n      if (!e.altKey) {\n        this.altKeyDown = false;\n        Object.values(this.current.wavesurfer.regions.list).forEach(region => {\n          region.drag = true;\n          region.resize = true;\n        });\n      }\n    };\n    this.handleRegionCreated = region => {\n      if (this.tempRegion) this.tempRegion.remove();\n      region.element.classList.add('line-region');\n      const mark = document.createElement('div');\n      mark.className = 'line-mark';\n      mark.style.height = '100%';\n      region.element.appendChild(mark);\n    };\n    this.handleRegionUpdate = region => {\n      const {\n        annotateDisabled\n      } = this.props;\n      if (annotateDisabled) {\n        if (region) region.remove();\n        return;\n      }\n      if (!this.props.segmentOverlap && !region.temp) {\n        const overlappedRegions = Object.values(this.current.wavesurfer.regions.list).filter(r => !(r.end <= region.start || r.start >= region.end) && r !== region);\n        if (overlappedRegions.length > 0) {\n          // has overlapping\n          const minStart = Math.min(...overlappedRegions.map(r => r.start));\n          const maxEnd = Math.max(...overlappedRegions.map(r => r.end));\n          if (this.updatingRegionStart === region.start) {\n            // drag end handler\n            if (region.end > minStart) {\n              region.update({\n                end: minStart\n              });\n            }\n          } else if (this.updatingRegionEnd === region.end) {\n            // drag start handler\n            if (region.start < maxEnd) {\n              region.update({\n                start: maxEnd\n              });\n            }\n          } else if (region.start < this.updatingRegionStart) {\n            // move left\n            region.update({\n              start: maxEnd,\n              end: region.end - region.start + maxEnd\n            });\n          } else if (region.start > this.updatingRegionStart) {\n            // move right\n            region.update({\n              start: region.start - region.end + minStart,\n              end: minStart\n            });\n          }\n        }\n      }\n      this.updatingRegionStart = region.start;\n      this.updatingRegionEnd = region.end;\n      this.updateRegionElement(region);\n    };\n    this.handleRegionEdit = (region, e) => {\n      const {\n        annotateDisabled,\n        toolMode\n      } = this.props;\n      const readonly = isAnnotationReadonly(toolMode) || annotateDisabled;\n      if ((readonly || (e === null || e === void 0 ? void 0 : e.buttons) === 2 || (e === null || e === void 0 ? void 0 : e.button) === 2) && !region.data.id) {\n        var _this$current$wavesur;\n        region.temp = true;\n        region.update({\n          color: hexToRgba(defaultColor.defaultGray, 0.2)\n        });\n        this.tempRegion = region;\n        (_this$current$wavesur = this.current.wavesurfer) === null || _this$current$wavesur === void 0 ? void 0 : _this$current$wavesur.play(region.start, region.end);\n        this.props.setCurrentSegment({\n          index: -1\n        });\n      }\n      if (region.temp) return;\n      this.updatingRegionStart = null;\n      this.updatingRegionEn = null;\n      const {\n        id\n      } = region.data;\n      const duration = this.current.wavesurfer.getDuration();\n      region.start = Math.max(region.start, 0);\n      region.end = Math.min(region.end, duration);\n      const {\n        minSegmentLength,\n        segmentConfig,\n        lineConfig\n      } = this.props;\n      if (!id) {\n        // create region\n        if (region.end - region.start < minSegmentLength) {\n          region.remove();\n          return;\n        }\n        const segment = createSegment(region.start, region.end, segmentConfig, lineConfig);\n        // eslint-disable-next-line no-param-reassign\n        region.data.id = segment.id;\n        region.play();\n        this.props.appendSegment({\n          segment\n        });\n        this.addHistory('segment', {\n          segmentIndex: this.props.currentSegment,\n          nextSegment: cloneDeep(segment),\n          region\n        });\n      } else {\n        // update region\n        const segmentIndex = this.getSegmentIndexById(id);\n        if (segmentIndex >= 0) {\n          const segment = this.currentSegments[segmentIndex];\n          const prevSegment = cloneDeep(segment);\n          let {\n            start,\n            end\n          } = region;\n          if (end - start < minSegmentLength) {\n            const draggingStart = end === segment.end;\n            const draggingEnd = start === segment.start;\n            if (draggingStart) {\n              start = end - minSegmentLength;\n            } else if (draggingEnd) {\n              end = start + minSegmentLength;\n            }\n          }\n          region.update({\n            start,\n            end\n          });\n          segment.start = start;\n          segment.end = end;\n          this.props.updateSegment({\n            segment\n          });\n          this.addHistory('segment', {\n            segmentIndex,\n            prevSegment,\n            nextSegment: cloneDeep(segment),\n            region\n          });\n        }\n      }\n    };\n    this.renderSegments = () => {\n      const {\n        videos,\n        results\n      } = this.props;\n      videos.forEach((v, i) => {\n        if (v.ready) {\n          this.wavesurfers[i].clearRegions();\n          this.initRegion(i, results[i]);\n        }\n      });\n    };\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null,\n      // Minimap container\n      waveform: null,\n      // Waveform container\n      timeline: null,\n      // Timeline container\n      audioContainer: null,\n      // Cursor container\n      videoContainer: null // Video container\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      undoList: null,\n      redoList: null,\n      segmentSelected: null\n    };\n    this.updatingRegionStart = null;\n    this.updatingRegionEnd = null;\n    this.altKeyDown = false;\n    this.hoveredRegion = null;\n    this.state = {\n      cursorTime: 0 // seconds\n    };\n  }\n  get currentSegments() {\n    return this.props.results[this.current.videoIndex];\n  }\n  componentDidMount() {\n    this.props.getWavesurfers({\n      wavesurfers: this\n    });\n    this.timer = setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const {\n        wavesurfer\n      } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n    window.addEventListener('resize', this.setCurrentZoom);\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n    window.addEventListener('contextmenu', this.onContextmenu);\n  }\n  onContextmenu(e) {\n    e.preventDefault();\n  }\n  shouldComponentUpdate(nextProps) {\n    const currSeg = this.props.results[this.props.currentVideo][this.props.currentSegment];\n    const nextSeg = nextProps.results[nextProps.currentVideo][nextProps.currentSegment];\n    // return !isEqual(currSeg, nextSeg);\n    return (currSeg === null || currSeg === void 0 ? void 0 : currSeg.id) !== (nextSeg === null || nextSeg === void 0 ? void 0 : nextSeg.id) || nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n  componentDidUpdate() {\n    if (this.props.isLoadedAlaw) {\n      this.initWaveSurfer();\n    } else {\n      this.setCurrentSegment(this.props.currentSegment);\n    }\n  }\n  componentWillUnmount() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n    window.removeEventListener('resize', this.setCurrentZoom);\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n    window.removeEventListener('contextmenu', this.onContextmenu);\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach(c => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) {\n      this.initWaveSurfer();\n    }\n  }\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) {\n      this.initWaveSurfer();\n    }\n  }\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n  getSegmentIndexById(id) {\n    return this.currentSegments.findIndex(seg => seg.id === id);\n  }\n  getRegionById(id) {\n    return Object.values(this.current.wavesurfer.regions.list).find(r => r.data.id === id);\n  }\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [RegionsPlugin.create(), CursorPlugin.create({\n            width: '1px',\n            height: '10px',\n            container: this.container.audioContainer[i],\n            color: defaultColor.defaultGreen,\n            showTime: true,\n            opacity: 1,\n            customShowTimeStyle: {\n              color: defaultColor.defaultGreen,\n              fontSize: '14px',\n              paddingLeft: '5px',\n              position: 'absolute',\n              bottom: '3px'\n            },\n            formatTimeCallback: sec => {\n              this.setState({\n                cursorTime: sec\n              });\n              return formatTimestamp(sec);\n            }\n          }), TimelinePlugin.create({\n            container: this.container.timeline[i],\n            primaryFontColor: defaultColor.defaultWhite,\n            secondaryFontColor: defaultColor.defaultWhite,\n            primaryColor: defaultColor.defaultWhite,\n            secondaryColor: defaultColor.defaultWhite,\n            fontSize: '10',\n            notchPercentHeight: 30,\n            timeInterval,\n            primaryLabelInterval,\n            secondaryLabelInterval,\n            formatTimeCallback\n          }), MinimapPlugin.create({\n            container: this.container.minimap[i]\n          })]\n        });\n        urls[i] = this.container.videoContainer[i];\n        this.wavesurfers[i].on('ready', () => {\n          this.wavesurfers[i].pause();\n          this.wavesurfers[i].enableDragSelection({\n            color: hexToRgba(this.props.ontology.get('none'), defaultColor.defaultAlpha)\n          });\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            this.props.setErrorMsg({\n              errorMsg: e.toString()\n            });\n            return;\n          }\n          this.props.setLoading(false);\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (i === 0) {\n            this.setNewVideo();\n          }\n          this.wavesurfers[i].on('play', () => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', () => this.handlePlayPause());\n          this.wavesurfers[i].on('region-created', this.handleRegionCreated);\n          this.wavesurfers[i].on('region-updated', region => this.handleRegionUpdate(region));\n          this.wavesurfers[i].on('region-update-end', (region, e) => this.handleRegionEdit(region, e));\n          this.wavesurfers[i].on('region-out', region => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', region => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (_, e) => e.preventDefault());\n          this.wavesurfers[i].on('region-mouseenter', region => {\n            this.hoveredRegion = region;\n            if (this.altKeyDown) {\n              this.hoveredRegion.drag = false;\n              this.hoveredRegion.resize = false;\n            }\n          });\n          this.wavesurfers[i].on('region-mouseleave', () => {\n            this.hoveredRegion = null;\n          });\n          this.props.setVideoValid({\n            index: i\n          });\n          this.props.updateVideoInfo({\n            index: i,\n            duration: this.wavesurfers[i].getDuration()\n          });\n        });\n        this.wavesurfers[i].on('error', error => {\n          notification.error({\n            message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}`\n          });\n          console.log('error', urls[i].src, error);\n          this.props.setAudioErrorMsg({\n            index: i,\n            errorMsg: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1} ${urls[i].src} ${error}`\n          });\n          this.wavesurfers[i].destroy();\n          if (i === size - 1) {\n            this.props.setLoading(false);\n          }\n        });\n        this.wavesurfers[i].on('redraw', this.props.setXScroll);\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n  initRegion(videoIndex, segments) {\n    // setup initial regions\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const {\n      toolMode,\n      ontology\n    } = this.props;\n    const readonly = isAnnotationReadonly(toolMode);\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      const region = wavesurfer.addRegion({\n        start: segment.start,\n        end: segment.end,\n        color: hexToRgba(ontology.get('none'), defaultColor.defaultAlpha),\n        drag: !readonly,\n        resize: !readonly\n      });\n      region.data = {\n        id: segment.id\n      };\n      segment.content.forEach((line, lineIndex) => {\n        var _this$props$styleConf;\n        const attributes = ((_this$props$styleConf = this.props.styleConfig) === null || _this$props$styleConf === void 0 ? void 0 : _this$props$styleConf.mode) === StyleConfigMode.segment ? segment.attributes : line.attributes;\n        this.insertLine({\n          videoIndex,\n          segmentIndex,\n          region,\n          lineIndex,\n          role: line.role,\n          attributes\n        });\n      });\n      this.updateRegionElement(region);\n    }\n  }\n  deleteLine(data) {\n    const {\n      segmentIndex,\n      lineIndex\n    } = data;\n    const segment = this.currentSegments[segmentIndex];\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      var _removeEle$;\n      const lineEleArray = Array.from(region.element.getElementsByClassName('line-mark'));\n      const removeEle = lineEleArray.splice(lineIndex, 1);\n      (_removeEle$ = removeEle[0]) === null || _removeEle$ === void 0 ? void 0 : _removeEle$.remove();\n      lineEleArray.forEach((line, index, array) => {\n        const height = 100 / array.length;\n        const top = height * index;\n        line.style.height = `${height}%`;\n        line.style.top = `${top}%`;\n      });\n    }\n  }\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n  parseSegments(videoIndex) {\n    const {\n      results,\n      ontology,\n      lineConfig,\n      segmentConfig,\n      keyAttribute,\n      minSegmentLength\n    } = this.props;\n    const segments = results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map(value => value.name);\n    const {\n      updatedValues: updateLineValues\n    } = triggerForm(lineConfig, {});\n    const {\n      updatedValues: updateSegmentValues\n    } = triggerForm(segmentConfig, {});\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map(value => value.name);\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    const segmentsMap = {};\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start & end\n      if (segment.start === null || segment.start === undefined || segment.end === null || segment.end === undefined) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        // eslint-disable-next-line no-console\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end || segment.end - segment.start < minSegmentLength) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      segment.attributes = {\n        ...updateSegmentValues,\n        ...segment.attributes\n      };\n      Object.keys(segment.attributes).forEach(key => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = {\n          ...updateLineValues,\n          ...line.attributes\n        };\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach(key => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n      segmentsMap[segment.id] = segment;\n    }\n    const newSegments = Object.values(segmentsMap).sort((a, b) => a.start - b.start);\n    if (!this.props.segmentOverlap) {\n      for (let i = 0; i < newSegments.length - 1; i += 1) {\n        const currSeg = newSegments[i];\n        const nextSeg = newSegments[i + 1];\n        if (currSeg.end > nextSeg.start) {\n          currSeg.end = nextSeg.start;\n        }\n      }\n    }\n    this.props.parseSegments({\n      videoIndex,\n      segments: newSegments\n    });\n    return newSegments;\n  }\n  playVideo() {\n    this.current.wavesurfer.play();\n  }\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n  setCurrentSpeed(speed) {\n    var _this$current$wavesur2;\n    (_this$current$wavesur2 = this.current.wavesurfer) === null || _this$current$wavesur2 === void 0 ? void 0 : _this$current$wavesur2.setPlaybackRate(speed);\n  }\n  setPlayMode() {\n    // mode\n  }\n  setNewVideo() {\n    const {\n      videoIndex\n    } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      // eslint-disable-next-line no-console\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n  setCurrentVideo(newVideoIndex) {\n    const {\n      videoIndex\n    } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n  setCurrentScroll(destTime = 0, offsetLeft = 0, boundaryCheck) {\n    const {\n      wavesurfer\n    } = this.current;\n    const {\n      scrollLeft\n    } = wavesurfer.container.lastChild;\n    const {\n      offsetWidth\n    } = wavesurfer.container;\n    const {\n      minPxPerSec\n    } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) {\n      wavesurfer.drawer.recenter(scrollTime / duration);\n    } else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) {\n        wavesurfer.drawer.recenter(scrollTime / duration);\n      }\n    }\n  }\n  setCurrentSegment(currentSegment, start) {\n    const segment = this.currentSegments[currentSegment];\n    if (!segment) {\n      Object.values(this.current.wavesurfer.regions.list).forEach(r => r.element.classList.remove('selected'));\n      this.current.segmentSelected = null;\n      return;\n    }\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      if (region !== this.current.segmentSelected) {\n        Object.values(this.current.wavesurfer.regions.list).forEach(r => r.element.classList.remove('selected'));\n        region.element.classList.add('selected');\n        this.current.segmentSelected = region;\n      }\n      const s = start || region.start;\n      this.seekCurrentAudio(s);\n      this.setCurrentScroll(s, 0, true);\n    }\n    if (this.props.currentPlayMode !== 'overallLoop') {\n      this.current.wavesurfer.play();\n    }\n  }\n  setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole, type) {\n    if (videoIndex === this.current.videoIndex) {\n      const {\n        styleConfig,\n        results\n      } = this.props;\n      const segments = results[videoIndex];\n      const segment = segments[segmentIndex];\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        var _styleConfig$groups2;\n        let color = this.props.ontology.get(role);\n        if ((styleConfig === null || styleConfig === void 0 ? void 0 : (_styleConfig$groups2 = styleConfig.groups) === null || _styleConfig$groups2 === void 0 ? void 0 : _styleConfig$groups2.length) > 0) {\n          var _segment$content$line;\n          const attributes = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.mode) === StyleConfigMode.line ? (_segment$content$line = segment.content[lineIndex]) === null || _segment$content$line === void 0 ? void 0 : _segment$content$line.attributes : segment.attributes;\n          color = getConfigColor(attributes, styleConfig.groups) || color;\n        }\n        this.setLineEleColor(segment, region, lineIndex, color);\n        if (type !== 'history') {\n          this.addHistory('setLineColor', {\n            videoIndex,\n            segmentIndex,\n            lineIndex,\n            role: prevRole,\n            actionType: 'history'\n          });\n        }\n      }\n    }\n  }\n  setSegmentColor(videoIndex, segmentIndex, lines, color) {\n    const segment = this.props.results[videoIndex][segmentIndex];\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      for (let i = 0; i < lines.length; i += 1) {\n        const lineIndex = lines[i];\n        this.setLineEleColor(segment, region, lineIndex, color);\n      }\n    }\n  }\n  setLineEleColor(segment, region, lineIndex, color) {\n    const line = segment.content[lineIndex];\n    const roleColor = this.props.ontology.get(line.role);\n    const rgba = hexToRgba(color || roleColor || defaultColor.defaultWhite, !color && line.role === 'none' ? 0 : defaultColor.defaultAlpha);\n    const lineElement = region.element.getElementsByClassName('line-mark')[lineIndex];\n    if (lineElement) {\n      lineElement.style.background = rgba;\n    }\n  }\n  setSegmentStartEnd(videoIndex, segmentIndex, start, end) {\n    if (videoIndex === this.current.videoIndex) {\n      const segments = this.props.results[videoIndex];\n      const segment = segments[segmentIndex];\n      const prevSegment = cloneDeep(segment);\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        region.update({\n          start,\n          end\n        });\n      }\n      this.addHistory('segment', {\n        segmentIndex,\n        prevSegment,\n        nextSegment: cloneDeep(segment),\n        region\n      });\n    }\n  }\n  seekCurrentAudio(currentTime = 0) {\n    const {\n      wavesurfer\n    } = this.current;\n    const duration = wavesurfer.getDuration();\n    wavesurfer.backend.seekTo(Math.min(Math.max(currentTime, 0), duration));\n  }\n  deleteCurrentSegment() {\n    const {\n      currentSegment\n    } = this.props;\n    const segment = this.currentSegments[currentSegment];\n    if (segment) {\n      const region = this.getRegionById(segment.id);\n      this.addHistory('segment', {\n        segmentIndex: currentSegment,\n        prevSegment: cloneDeep(segment),\n        region\n      });\n      if (region) {\n        region.remove();\n      }\n      this.props.deleteSegment({\n        segmentIndex: currentSegment\n      });\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      const currentSegmentIndex = this.currentSegments.findIndex(seg => seg.start <= currentTime && seg.end >= currentTime);\n      this.props.setCurrentSegment({\n        index: currentSegmentIndex,\n        start: currentTime\n      });\n      this.current.segmentSelected = null;\n    }\n  }\n  handlePlayPause() {\n    this.props.setPlayingState({\n      isPlaying: this.current.wavesurfer.isPlaying()\n    });\n  }\n  handleRegionOut(region) {\n    const segment = this.currentSegments[this.props.currentSegment];\n    if (!segment && !(region === null || region === void 0 ? void 0 : region.temp)) {\n      return;\n    }\n    const currentRegion = region.temp ? region : this.getRegionById(segment === null || segment === void 0 ? void 0 : segment.id);\n    if (currentRegion === region) {\n      if (this.props.currentPlayMode === 'overallLoop') {\n        this.props.setCurrentSegment({\n          index: -1\n        });\n      } else if (this.props.currentPlayMode === 'regionLoop') {\n        this.seekCurrentAudio(region.start);\n        this.setCurrentScroll(region.start, 0, true);\n      } else if (this.props.currentPlayMode === 'regionPlay') {\n        this.current.wavesurfer.pause();\n        this.seekCurrentAudio(region.end);\n      }\n    }\n  }\n  handleRegionIn(region) {\n    if (this.props.currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentIndexById(region.data.id);\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      if (segmentIndex !== this.props.currentSegment && segmentIndex >= 0) {\n        this.props.setCurrentSegment({\n          index: segmentIndex,\n          start: currentTime\n        });\n      }\n    }\n  }\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const segmentIndex = this.getSegmentIndexById(region.data.id);\n    if (segmentIndex >= 0) {\n      const cursorTime = this.getCursorTime();\n      const start = cursorTime > 0 && (e.altKey || e.ctrlKey) || this.props.currentPlayMode === 'overallLoop' ? cursorTime : null;\n      this.props.setCurrentSegment({\n        index: segmentIndex,\n        start\n      });\n      if (this.tempRegion) this.tempRegion.remove();\n    } else if (region) {\n      var _this$current$wavesur3;\n      (_this$current$wavesur3 = this.current.wavesurfer) === null || _this$current$wavesur3 === void 0 ? void 0 : _this$current$wavesur3.play(region.start, region.end);\n    }\n  }\n  clearAll() {\n    Modal.confirm({\n      className: 'modal-root',\n      title: i18n.translate('COMMON_CLAER_CONFIRM_TITLE'),\n      content: i18n.translate('COMMON_CLAER_CONFIRM_DESC'),\n      autoFocusButton: null,\n      okText: i18n.translate('COMMON_CLAER_CONFIRM_SURE'),\n      okType: 'danger',\n      cancelText: i18n.translate('COMMON_CLAER_CONFIRM_CANCEL'),\n      onOk: () => {\n        const {\n          currentSegment\n        } = this.props;\n        const {\n          videoIndex\n        } = this.current;\n        const segments = cloneDeep(this.currentSegments);\n        this.props.setSegments({\n          videoIndex,\n          segments: []\n        });\n        this.wavesurfers[videoIndex].clearRegions();\n        this.addHistory('clear_all', {\n          after: {\n            videoIndex,\n            currentIndex: -1,\n            segments: []\n          },\n          before: {\n            videoIndex,\n            currentIndex: currentSegment,\n            segments\n          }\n        });\n      }\n    });\n  }\n  addHistory(type, data) {\n    // update redo list each time\n    this.current.redoList = [];\n    this.current.undoList.push({\n      type,\n      data\n    });\n    if (this.current.undoList.length > 50) {\n      this.current.undoList.shift();\n    }\n  }\n  recallHistory(action) {\n    const {\n      undoList,\n      redoList\n    } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) {\n      return;\n    }\n    this.props.setCurrentSegment({\n      index: -1\n    });\n    const recallItem = recallList.pop();\n    const {\n      type,\n      data\n    } = recallItem;\n    switch (type) {\n      case 'segment':\n        {\n          const {\n            segmentIndex,\n            prevSegment,\n            nextSegment,\n            region\n          } = data;\n          const currSegment = action === 'undo' ? prevSegment : nextSegment;\n          const otherSegment = action === 'undo' ? nextSegment : prevSegment;\n          if (currSegment && otherSegment) {\n            this.props.updateSegment({\n              segment: currSegment\n            });\n            const currentRegion = this.getRegionById(currSegment.id);\n            currentRegion.update({\n              start: currSegment.start,\n              end: currSegment.end\n            });\n          } else if (region && currSegment && !otherSegment) {\n            this.props.appendSegment({\n              segmentIndex,\n              segment: currSegment\n            });\n            const currentRegion = this.current.wavesurfer.regions.add(region);\n            this.updateRegionElement(currentRegion);\n          } else if (region && !currSegment && otherSegment) {\n            this.props.deleteSegment({\n              segmentIndex\n            });\n            const currentRegion = this.getRegionById(otherSegment.id);\n            currentRegion.remove();\n          }\n          break;\n        }\n      case 'clear_all':\n        {\n          const {\n            before,\n            after\n          } = data;\n          const {\n            videoIndex,\n            currentIndex,\n            segments\n          } = action === 'undo' ? before : after;\n          this.wavesurfers[videoIndex].clearRegions();\n          this.props.setSegments({\n            videoIndex,\n            segments\n          });\n          this.initRegion(videoIndex, segments);\n          this.props.setCurrentSegment(currentIndex);\n          break;\n        }\n      case 'pushLine':\n        this.props.deleteLine({\n          ...data,\n          actionType: 'history'\n        });\n        break;\n      case 'deleteLine':\n        this.props.pushLine({\n          ...data,\n          actionType: 'history'\n        });\n        break;\n      case 'setLineColor':\n        this.props.setLineRole({\n          ...data,\n          actionType: 'history'\n        });\n        break;\n      default:\n        break;\n    }\n    if (recallItem.type === 'pushLine') {\n      recallItem.type = 'deleteLine';\n    } else if (recallItem.type === 'deleteLine') {\n      recallItem.type = 'pushLine';\n    }\n    if (recallItem.type === 'setLineColor') {\n      const [nextRole, role] = [data.role, data.nextRole];\n      recallItem.data.role = role;\n      recallItem.data.nextRole = nextRole;\n    }\n    (action === 'undo' ? redoList : undoList).push(recallItem);\n  }\n  updateRegionElement(region) {\n    const {\n      element,\n      start,\n      end\n    } = region;\n    element.classList.add('dragged-region');\n    if (this.props.spaceLine > 0) {\n      const offset = this.props.spaceLine / (end - start);\n      let startLine = element.querySelector('.space-line.space-line-start');\n      let endLine = element.querySelector('.space-line.space-line-end');\n      if (offset < 0.5) {\n        if (!startLine) {\n          startLine = document.createElement('div');\n          startLine.className = 'space-line space-line-start';\n          element.appendChild(startLine);\n        }\n        if (!endLine) {\n          endLine = document.createElement('div');\n          endLine.className = 'space-line space-line-end';\n          element.appendChild(endLine);\n        }\n        startLine.style.left = `${offset * 100}%`;\n        endLine.style.right = `${offset * 100}%`;\n      } else {\n        if (startLine) {\n          startLine.remove();\n        }\n        if (endLine) {\n          endLine.remove();\n        }\n      }\n    }\n  }\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const {\n          zoom,\n          wavesurfer\n        } = this.current;\n        if (!cursorHelper) {\n          var _wavesurfer$cursor;\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer === null || wavesurfer === void 0 ? void 0 : (_wavesurfer$cursor = wavesurfer.cursor) === null || _wavesurfer$cursor === void 0 ? void 0 : _wavesurfer$cursor.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const {\n          offsetWidth\n        } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = totalWidth / duration * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n  render() {\n    return null;\n  }\n}\nconst mapStateToProps = state => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  segmentOverlap: state.segmentOverlap,\n  keyAttribute: state.keyAttribute,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw,\n  styleConfig: state.styleConfig\n});\nconst mapDispatchToProps = {\n  getWavesurfers,\n  setPlayingState,\n  setVideoValid,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  parseSegments,\n  setErrorMsg,\n  setAudioErrorMsg,\n  appendSegment,\n  updateSegment,\n  deleteSegment,\n  setSegments,\n  updateLineRole,\n  updateVideoInfo,\n  setLoading\n};\nexport default connect(mapStateToProps, mapDispatchToProps, null, {\n  forwardRef: true\n})(WavesurferComp);","map":{"version":3,"names":["React","hexToRgba","WaveSurfer","TimelinePlugin","RegionsPlugin","CursorPlugin","MinimapPlugin","connect","v4","uuid","cloneDeep","notification","Modal","defaultColor","formatTimestamp","translate","triggerForm","StyleConfigMode","getConfigColor","getWavesurfers","setPlayingState","setVideoValid","deleteLine","pushLine","setLineRole","parseSegments","setErrorMsg","setAudioErrorMsg","appendSegment","updateSegment","deleteSegment","setSegments","updateLineRole","updateVideoInfo","setLoading","createLine","createSegment","isInput","isAnnotationReadonly","formatTimeCallback","primaryLabelInterval","secondaryLabelInterval","timeInterval","i18n","config","top","ANCHOR_MOVEMENT_STEP","WavesurferComp","Component","constructor","tempRegion","undefined","insertLine","data","segmentIndex","role","currentRole","attributes","region","currentRegion","ontology","styleConfig","props","segment","currentSegments","getRegionById","id","_styleConfig$groups","configColor","groups","length","color","get","defaultWhite","defaultAlpha","element","classList","add","mark","document","createElement","className","style","background","appendChild","Array","from","getElementsByClassName","forEach","line","index","array","height","setCurrentZoom","newZoom","current","zoom","videoIndex","wavesurfer","duration","wavesurfers","getDuration","cursorTime","getCursorTime","currentTime","getCurrentTime","offsetWidth","container","offsetLeft","cursor","totalWidth","pxPerSec","setCurrentScroll","handleKeyDown","e","key","window","disableLongAudioHotKeys","toolMode","altKey","segmentOverlap","altKeyDown","hoveredRegion","drag","resize","keyCode","ctrlKey","clearAll","deleteCurrentSegment","recallHistory","handleKeyUp","Object","values","regions","list","handleRegionCreated","remove","handleRegionUpdate","annotateDisabled","temp","overlappedRegions","filter","r","end","start","minStart","Math","min","map","maxEnd","max","updatingRegionStart","update","updatingRegionEnd","updateRegionElement","handleRegionEdit","readonly","buttons","button","_this$current$wavesur","defaultGray","play","setCurrentSegment","updatingRegionEn","minSegmentLength","segmentConfig","lineConfig","addHistory","currentSegment","nextSegment","getSegmentIndexById","prevSegment","draggingStart","draggingEnd","renderSegments","videos","results","v","i","ready","clearRegions","initRegion","undoList","redoList","minimap","waveform","timeline","audioContainer","videoContainer","segmentSelected","state","componentDidMount","timer","setInterval","isPlaying","timestamp","innerText","addEventListener","onContextmenu","preventDefault","shouldComponentUpdate","nextProps","currSeg","currentVideo","nextSeg","isLoadedAlaw","componentDidUpdate","initWaveSurfer","componentWillUnmount","clearInterval","removeEventListener","isArray","c","updateMeasurement","getAudioContainer","getVideoContainer","findIndex","seg","find","size","urls","loaded","create","autoCenter","backend","normalize","loopSelection","scrollParent","backgroundColor","waveColor","darkGray","progressColor","cursorColor","defaultRed","pixelRatio","maxCanvasWidth","plugins","width","defaultGreen","showTime","opacity","customShowTimeStyle","fontSize","paddingLeft","position","bottom","sec","setState","primaryFontColor","secondaryFontColor","primaryColor","secondaryColor","notchPercentHeight","on","pause","enableDragSelection","segments","errorMsg","toString","initMiniMap","setNewVideo","handlePlayPause","handleRegionOut","handleRegionIn","handleRegionClick","_","error","message","console","log","src","destroy","setXScroll","load","addRegion","content","lineIndex","_this$props$styleConf","mode","_removeEle$","lineEleArray","removeEle","splice","wave","getElementsByTagName","keyAttribute","segmentConfigValidKeys","fields","value","name","updatedValues","updateLineValues","updateSegmentValues","push","lineConfigValidKeys","ontologyValidKeys","segmentsMap","startNum","Number","isNaN","Error","JSON","stringify","endNum","keys","indexOf","arr","newSegments","sort","a","b","playVideo","pauseVideo","forwardVideo","skipForward","backwardVideo","skipBackward","setCurrentSpeed","speed","_this$current$wavesur2","setPlaybackRate","setPlayMode","isDestroyed","setCurrentVideo","newVideoIndex","destTime","boundaryCheck","scrollLeft","lastChild","minPxPerSec","params","scrollTime","drawer","recenter","rightBoundaryTime","leftBoundaryTime","s","seekCurrentAudio","currentPlayMode","setLineColor","prevRole","type","_styleConfig$groups2","_segment$content$line","setLineEleColor","actionType","setSegmentColor","lines","roleColor","rgba","lineElement","setSegmentStartEnd","seekTo","currentSegmentIndex","stopPropagation","_this$current$wavesur3","confirm","title","autoFocusButton","okText","okType","cancelText","onOk","after","currentIndex","before","shift","action","recallList","recallItem","pop","currSegment","otherSegment","nextRole","spaceLine","offset","startLine","querySelector","endLine","left","right","cursorHelper","selectedMeasurement","_wavesurfer$cursor","render","mapStateToProps","mapDispatchToProps","forwardRef"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/components/WavesurferComp/DragWavesurferComp.jsx"],"sourcesContent":["/* eslint-disable class-methods-use-this */\nimport React from 'react';\nimport hexToRgba from 'hex-to-rgba';\nimport WaveSurfer from 'wavesurfer.js/dist/wavesurfer';\nimport TimelinePlugin from 'wavesurfer.js/dist/plugin/wavesurfer.timeline.min.js';\nimport RegionsPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport CursorPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.cursor.min.js';\nimport MinimapPlugin from 'wavesurfer.js/src/plugin/minimap';\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport { notification, Modal } from 'antd';\nimport { defaultColor, formatTimestamp, translate, triggerForm, StyleConfigMode, getConfigColor } from '../../constants';\nimport {\n  getWavesurfers,\n  setPlayingState,\n  setVideoValid,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  parseSegments,\n  setErrorMsg,\n  setAudioErrorMsg,\n  appendSegment,\n  updateSegment,\n  deleteSegment,\n  setSegments,\n  updateLineRole,\n  updateVideoInfo,\n  setLoading,\n} from '../../redux/action';\nimport './WavesurferComp.scss';\nimport { createLine, createSegment, isInput } from '../../redux/reducer/segmentController';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { formatTimeCallback, primaryLabelInterval, secondaryLabelInterval, timeInterval } from '../utils/TimelineUtil';\nimport i18n from '../../locales';\n\nnotification.config({ top: 60 });\nexport const ANCHOR_MOVEMENT_STEP = 0.01;\n\nclass WavesurferComp extends React.Component {\n  tempRegion = undefined;\n\n  constructor() {\n    super();\n    this.wavesurfers = [];\n    this.undoList = [];\n    this.redoList = [];\n    this.container = {\n      minimap: null, // Minimap container\n      waveform: null, // Waveform container\n      timeline: null, // Timeline container\n      audioContainer: null, // Cursor container\n      videoContainer: null, // Video container\n    };\n    this.current = {\n      zoom: 1,\n      videoIndex: 0,\n      wavesurfer: null,\n      undoList: null,\n      redoList: null,\n      segmentSelected: null,\n    };\n    this.updatingRegionStart = null;\n    this.updatingRegionEnd = null;\n    this.altKeyDown = false;\n    this.hoveredRegion = null;\n    this.state = {\n      cursorTime: 0, // seconds\n    };\n  }\n\n  get currentSegments() {\n    return this.props.results[this.current.videoIndex];\n  }\n\n  componentDidMount() {\n    this.props.getWavesurfers({ wavesurfers: this });\n    this.timer = setInterval(() => {\n      if (!this.props.isPlaying) return;\n      const { wavesurfer } = this.current;\n      const currentTime = wavesurfer.getCurrentTime();\n      const duration = wavesurfer.getDuration();\n      wavesurfer.timestamp.innerText = `${formatTimestamp(currentTime)}/${formatTimestamp(duration)}`;\n      this.setCurrentScroll(currentTime, 0, true);\n    }, 200);\n    window.addEventListener('resize', this.setCurrentZoom);\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n    window.addEventListener('contextmenu', this.onContextmenu);\n  }\n\n  onContextmenu(e) {\n    e.preventDefault();\n  }\n\n  shouldComponentUpdate(nextProps) {\n    const currSeg = this.props.results[this.props.currentVideo][this.props.currentSegment];\n    const nextSeg = nextProps.results[nextProps.currentVideo][nextProps.currentSegment];\n    // return !isEqual(currSeg, nextSeg);\n    return currSeg?.id !== nextSeg?.id || nextProps.isLoadedAlaw !== this.props.isLoadedAlaw;\n  }\n\n  componentDidUpdate() {\n    if (this.props.isLoadedAlaw) {\n      this.initWaveSurfer();\n    } else {\n      this.setCurrentSegment(this.props.currentSegment);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n    window.removeEventListener('resize', this.setCurrentZoom);\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n    window.removeEventListener('contextmenu', this.onContextmenu);\n    if (Array.isArray(this.container.audioContainer)) {\n      this.container.audioContainer.forEach((c) => {\n        if (c) {\n          c.removeEventListener('mousemove', this.updateMeasurement);\n          c.removeEventListener('wheel', this.updateMeasurement);\n        }\n      });\n    }\n  }\n\n  getAudioContainer(waveform, timeline, audioContainer, minimap) {\n    this.container.waveform = waveform;\n    this.container.timeline = timeline;\n    this.container.audioContainer = audioContainer;\n    this.container.minimap = minimap;\n    if (this.container.videoContainer) {\n      this.initWaveSurfer();\n    }\n  }\n\n  getVideoContainer(videoContainer) {\n    this.container.videoContainer = videoContainer;\n    if (this.container.waveform) {\n      this.initWaveSurfer();\n    }\n  }\n\n  getCursorTime() {\n    return this.state.cursorTime;\n  }\n\n  getSegmentIndexById(id) {\n    return this.currentSegments.findIndex((seg) => seg.id === id);\n  }\n\n  getRegionById(id) {\n    return Object.values(this.current.wavesurfer.regions.list).find((r) => r.data.id === id);\n  }\n\n  initWaveSurfer() {\n    const size = this.props.videos.length;\n    const urls = [];\n    for (let i = 0; i < size; i += 1) {\n      if (this.props.videos[i].loaded && !this.wavesurfers[i]) {\n        this.wavesurfers[i] = WaveSurfer.create({\n          container: this.container.waveform[i],\n          autoCenter: false,\n          backend: 'MediaElement',\n          normalize: true,\n          loopSelection: true,\n          scrollParent: true,\n          backgroundColor: defaultColor.defaultGray,\n          waveColor: defaultColor.darkGray,\n          progressColor: defaultColor.darkGray,\n          cursorColor: defaultColor.defaultRed,\n          pixelRatio: 1,\n          maxCanvasWidth: 4000,\n          plugins: [\n            RegionsPlugin.create(),\n            CursorPlugin.create({\n              width: '1px',\n              height: '10px',\n              container: this.container.audioContainer[i],\n              color: defaultColor.defaultGreen,\n              showTime: true,\n              opacity: 1,\n              customShowTimeStyle: {\n                color: defaultColor.defaultGreen,\n                fontSize: '14px',\n                paddingLeft: '5px',\n                position: 'absolute',\n                bottom: '3px',\n              },\n              formatTimeCallback: (sec) => {\n                this.setState({ cursorTime: sec });\n                return formatTimestamp(sec);\n              },\n            }),\n            TimelinePlugin.create({\n              container: this.container.timeline[i],\n              primaryFontColor: defaultColor.defaultWhite,\n              secondaryFontColor: defaultColor.defaultWhite,\n              primaryColor: defaultColor.defaultWhite,\n              secondaryColor: defaultColor.defaultWhite,\n              fontSize: '10',\n              notchPercentHeight: 30,\n              timeInterval,\n              primaryLabelInterval,\n              secondaryLabelInterval,\n              formatTimeCallback,\n            }),\n            MinimapPlugin.create({\n              container: this.container.minimap[i],\n            }),\n          ],\n        });\n        urls[i] = this.container.videoContainer[i];\n\n        this.wavesurfers[i].on('ready', () => {\n          this.wavesurfers[i].pause();\n          this.wavesurfers[i].enableDragSelection({\n            color: hexToRgba(this.props.ontology.get('none'), defaultColor.defaultAlpha),\n          });\n\n          let segments;\n          try {\n            segments = this.parseSegments(i);\n          } catch (e) {\n            this.props.setErrorMsg({ errorMsg: e.toString() });\n            return;\n          }\n          this.props.setLoading(false);\n          this.initRegion(i, segments);\n          this.initMiniMap(i);\n          if (i === 0) {\n            this.setNewVideo();\n          }\n          this.wavesurfers[i].on('play', () => this.handlePlayPause());\n          this.wavesurfers[i].on('pause', () => this.handlePlayPause());\n          this.wavesurfers[i].on('region-created', this.handleRegionCreated);\n          this.wavesurfers[i].on('region-updated', (region) => this.handleRegionUpdate(region));\n          this.wavesurfers[i].on('region-update-end', (region, e) => this.handleRegionEdit(region, e));\n          this.wavesurfers[i].on('region-out', (region) => this.handleRegionOut(region));\n          this.wavesurfers[i].on('region-in', (region) => this.handleRegionIn(region));\n          this.wavesurfers[i].on('region-click', (region, e) => this.handleRegionClick(region, e));\n          this.wavesurfers[i].on('region-contextmenu', (_, e) => e.preventDefault());\n          this.wavesurfers[i].on('region-mouseenter', (region) => {\n            this.hoveredRegion = region;\n            if (this.altKeyDown) {\n              this.hoveredRegion.drag = false;\n              this.hoveredRegion.resize = false;\n            }\n          });\n          this.wavesurfers[i].on('region-mouseleave', () => {\n            this.hoveredRegion = null;\n          });\n          this.props.setVideoValid({ index: i });\n          this.props.updateVideoInfo({ index: i, duration: this.wavesurfers[i].getDuration() });\n        });\n        this.wavesurfers[i].on('error', (error) => {\n          notification.error({ message: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1}` });\n          console.log('error', urls[i].src, error);\n          this.props.setAudioErrorMsg({\n            index: i,\n            errorMsg: `${translate('AUDIO_ERROR')} ${translate('RECORD_PREFIX')}${i + 1} ${urls[i].src} ${error}`\n          });\n          this.wavesurfers[i].destroy();\n          if (i === size - 1) {\n            this.props.setLoading(false);\n          }\n        });\n        this.wavesurfers[i].on('redraw', this.props.setXScroll);\n        this.undoList[i] = [];\n        this.redoList[i] = [];\n\n        this.container.audioContainer[i].addEventListener('mousemove', () => this.updateMeasurement(i));\n        this.container.audioContainer[i].addEventListener('wheel', () => this.updateMeasurement(i));\n        this.wavesurfers[i].load(this.container.videoContainer[i]);\n      }\n    }\n  }\n\n  initRegion(videoIndex, segments) {\n    // setup initial regions\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const { toolMode, ontology } = this.props;\n    const readonly = isAnnotationReadonly(toolMode);\n    for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex += 1) {\n      const segment = segments[segmentIndex];\n      const region = wavesurfer.addRegion({\n        start: segment.start,\n        end: segment.end,\n        color: hexToRgba(ontology.get('none'), defaultColor.defaultAlpha),\n        drag: !readonly,\n        resize: !readonly,\n      });\n      region.data = { id: segment.id };\n      segment.content.forEach((line, lineIndex) => {\n        const attributes = this.props.styleConfig?.mode === StyleConfigMode.segment ? segment.attributes : line.attributes;\n        this.insertLine({\n          videoIndex,\n          segmentIndex,\n          region,\n          lineIndex,\n          role: line.role,\n          attributes,\n        });\n      });\n      this.updateRegionElement(region);\n    }\n  }\n\n  insertLine = (data) => {\n    // eslint-disable-next-line prefer-const\n    const { segmentIndex, role: currentRole, attributes, region: currentRegion } = data;\n    const { ontology, styleConfig } = this.props;\n    const segment = this.currentSegments[segmentIndex];\n    const region = currentRegion || this.getRegionById(segment?.id);\n    if (region) {\n      const role = currentRole || 'none';\n      let configColor = '';\n      if (attributes && styleConfig?.groups?.length > 0) {\n        configColor = getConfigColor(attributes, styleConfig.groups);\n      }\n      const color = hexToRgba(\n        configColor || ontology.get(role) || defaultColor.defaultWhite,\n        (role === 'none' && !configColor) ? 0 : defaultColor.defaultAlpha\n      );\n      region.element.classList.add('line-region');\n      const mark = document.createElement('div');\n      mark.className = 'line-mark';\n      mark.style.background = color;\n      region.element.appendChild(mark);\n      Array.from(region.element.getElementsByClassName('line-mark')).forEach((line, index, array) => {\n        const height = 100 / array.length;\n        const top = height * index;\n        line.style.height = `${height}%`;\n        line.style.top = `${top}%`;\n      });\n    }\n  };\n\n  deleteLine(data) {\n    const { segmentIndex, lineIndex } = data;\n    const segment = this.currentSegments[segmentIndex];\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      const lineEleArray = Array.from(region.element.getElementsByClassName('line-mark'));\n      const removeEle = lineEleArray.splice(lineIndex, 1);\n      removeEle[0]?.remove();\n      lineEleArray.forEach((line, index, array) => {\n        const height = 100 / array.length;\n        const top = height * index;\n        line.style.height = `${height}%`;\n        line.style.top = `${top}%`;\n      });\n    }\n  }\n\n  initMiniMap(i) {\n    const wave = this.container.minimap[i].getElementsByTagName('wave')[0];\n    const timestamp = document.createElement('div');\n    const currentTime = this.wavesurfers[i].getDuration();\n    timestamp.className = 'wavesurfer-timestamp';\n    timestamp.innerText = `00:00.000/${formatTimestamp(currentTime)}`;\n    wave.appendChild(timestamp);\n    this.wavesurfers[i].timestamp = timestamp;\n  }\n\n  parseSegments(videoIndex) {\n    const { results, ontology, lineConfig, segmentConfig, keyAttribute, minSegmentLength } = this.props;\n    const segments = results[videoIndex];\n    const wavesurfer = this.wavesurfers[videoIndex];\n    const duration = wavesurfer.getDuration();\n    const segmentConfigValidKeys = segmentConfig.fields.map((value) => value.name);\n    const { updatedValues: updateLineValues } = triggerForm(lineConfig, {});\n    const { updatedValues: updateSegmentValues } = triggerForm(segmentConfig, {});\n    if (keyAttribute) {\n      segmentConfigValidKeys.push(keyAttribute.name);\n    }\n    const lineConfigValidKeys = lineConfig.fields.map((value) => value.name);\n    const ontologyValidKeys = [];\n    ontology.forEach((value, key) => {\n      ontologyValidKeys.push(key);\n    });\n    const segmentsMap = {};\n    for (let i = 0; i < segments.length; i += 1) {\n      const segment = segments[i];\n      // validate start/end time nan\n      if (segment.start) {\n        const startNum = Number(segment.start);\n        if (Number.isNaN(startNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [start NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.start = startNum;\n      }\n      if (segment.end) {\n        const endNum = Number(segment.end);\n        if (Number.isNaN(endNum)) {\n          throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_NAN')} [end NAN] ${JSON.stringify(segment)}`);\n        }\n        segment.end = endNum;\n      }\n      // validate segment id\n      segment.id = segment.id || uuid();\n      // validate segment start & end\n      if (segment.start === null || segment.start === undefined || segment.end === null || segment.end === undefined) {\n        throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      if (segment.end > duration) {\n        segment.end = duration;\n        // eslint-disable-next-line no-console\n        console.log(`${translate('PAYLOAD_ERROR_SEGMENT_LENGTH_OVERFLOW')} ${JSON.stringify(segment)} set as max=${duration}`);\n      }\n      if (segment.start < 0 || segment.end < 0 || segment.start > segment.end || segment.end - segment.start < minSegmentLength) {\n        segments.splice(i, 1);\n        i -= 1;\n        // throw new Error(`${translate('PAYLOAD_ERROR_SEGMENT_START_END_INVALID')} ${JSON.stringify(segment)}`);\n      }\n      // validate segment attribute\n      segment.attributes = {\n        ...updateSegmentValues,\n        ...segment.attributes,\n      };\n      Object.keys(segment.attributes).forEach((key) => {\n        if (segmentConfigValidKeys.indexOf(key) < 0) {\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n          delete segment.attributes[key];\n        }\n      });\n      if (segment.content == null || !segment.content[0]) segment.content = [createLine('none', lineConfig)];\n      segment.content.forEach((line, index, arr) => {\n        line.role = line.role || 'none';\n        line.attributes = {\n          ...updateLineValues,\n          ...line.attributes,\n        };\n        if (ontologyValidKeys.indexOf(line.role) < 0) {\n          line.role = 'none';\n          // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ROLE')}: ${line.role}`);\n        }\n        Object.keys(line.attributes).forEach((key) => {\n          if (lineConfigValidKeys.indexOf(key) < 0) {\n            // throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE')}: ${key}`);\n            delete line.attributes[key];\n          }\n        });\n      });\n      segmentsMap[segment.id] = segment;\n    }\n    const newSegments = Object.values(segmentsMap).sort((a, b) => a.start - b.start);\n    if (!this.props.segmentOverlap) {\n      for (let i = 0; i < newSegments.length - 1; i += 1) {\n        const currSeg = newSegments[i];\n        const nextSeg = newSegments[i + 1];\n        if (currSeg.end > nextSeg.start) {\n          currSeg.end = nextSeg.start;\n        }\n      }\n    }\n    this.props.parseSegments({\n      videoIndex,\n      segments: newSegments,\n    });\n    return newSegments;\n  }\n\n  playVideo() {\n    this.current.wavesurfer.play();\n  }\n\n  pauseVideo() {\n    this.current.wavesurfer.pause();\n  }\n\n  forwardVideo() {\n    this.current.wavesurfer.skipForward(0.5);\n  }\n\n  backwardVideo() {\n    this.current.wavesurfer.skipBackward(0.5);\n  }\n\n  setCurrentSpeed(speed) {\n    this.current.wavesurfer?.setPlaybackRate(speed);\n  }\n\n  setPlayMode() {\n    // mode\n  }\n\n  setNewVideo() {\n    const { videoIndex } = this.current;\n    if (this.wavesurfers[videoIndex].isDestroyed) {\n      // eslint-disable-next-line no-console\n      console.error('Video destroyed:', videoIndex);\n      return;\n    }\n    this.current.wavesurfer = this.wavesurfers[videoIndex];\n    this.current.zoom = this.props.videos[videoIndex].zoom;\n    this.current.undoList = this.undoList[videoIndex];\n    this.current.redoList = this.redoList[videoIndex];\n    this.setCurrentZoom();\n  }\n\n  setCurrentVideo(newVideoIndex) {\n    const { videoIndex } = this.current;\n    this.wavesurfers[videoIndex].pause();\n    this.current.videoIndex = newVideoIndex;\n    this.setNewVideo();\n  }\n\n  setCurrentZoom = (newZoom) => {\n    if (newZoom) {\n      this.current.zoom = newZoom;\n    }\n    const { zoom, videoIndex, wavesurfer } = this.current;\n    if (wavesurfer) {\n      const duration = this.wavesurfers[videoIndex].getDuration();\n      const cursorTime = this.getCursorTime();\n      const currentTime = wavesurfer.getCurrentTime();\n      const { offsetWidth } = wavesurfer.container;\n      const { offsetLeft } = wavesurfer.cursor.cursor;\n      const totalWidth = offsetWidth * zoom;\n      const pxPerSec = totalWidth / duration;\n      wavesurfer.zoom(pxPerSec);\n      this.setCurrentScroll(\n        cursorTime < 0 ? currentTime : cursorTime,\n        cursorTime < 0 ? offsetWidth / 2 : offsetLeft,\n        false,\n      );\n    }\n  };\n\n  setCurrentScroll(destTime = 0, offsetLeft = 0, boundaryCheck) {\n    const { wavesurfer } = this.current;\n    const { scrollLeft } = wavesurfer.container.lastChild;\n    const { offsetWidth } = wavesurfer.container;\n    const { minPxPerSec } = wavesurfer.params;\n    const scrollTime = destTime - (offsetLeft - offsetWidth / 2) / minPxPerSec;\n    const duration = wavesurfer.getDuration();\n    if (!boundaryCheck) {\n      wavesurfer.drawer.recenter(scrollTime / duration);\n    } else {\n      const rightBoundaryTime = (scrollLeft + offsetWidth) / minPxPerSec;\n      const leftBoundaryTime = scrollLeft / minPxPerSec;\n      if (destTime < leftBoundaryTime || destTime > rightBoundaryTime) {\n        wavesurfer.drawer.recenter(scrollTime / duration);\n      }\n    }\n  }\n\n  setCurrentSegment(currentSegment, start) {\n    const segment = this.currentSegments[currentSegment];\n    if (!segment) {\n      Object.values(this.current.wavesurfer.regions.list).forEach((r) => r.element.classList.remove('selected'));\n      this.current.segmentSelected = null;\n      return;\n    }\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      if (region !== this.current.segmentSelected) {\n        Object.values(this.current.wavesurfer.regions.list).forEach((r) => r.element.classList.remove('selected'));\n        region.element.classList.add('selected');\n        this.current.segmentSelected = region;\n      }\n      const s = start || region.start;\n      this.seekCurrentAudio(s);\n      this.setCurrentScroll(s, 0, true);\n    }\n    if (this.props.currentPlayMode !== 'overallLoop') {\n      this.current.wavesurfer.play();\n    }\n  }\n\n  setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole, type) {\n    if (videoIndex === this.current.videoIndex) {\n      const { styleConfig, results } = this.props;\n      const segments = results[videoIndex];\n      const segment = segments[segmentIndex];\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        let color = this.props.ontology.get(role);\n        if (styleConfig?.groups?.length > 0) {\n          const attributes = styleConfig?.mode === StyleConfigMode.line ? segment.content[lineIndex]?.attributes : segment.attributes;\n          color = getConfigColor(attributes, styleConfig.groups) || color;\n        }\n        this.setLineEleColor(segment, region, lineIndex, color);\n        if (type !== 'history') {\n          this.addHistory('setLineColor', { videoIndex, segmentIndex, lineIndex, role: prevRole, actionType: 'history' });\n        }\n      }\n    }\n  }\n\n  setSegmentColor(videoIndex, segmentIndex, lines, color) {\n    const segment = this.props.results[videoIndex][segmentIndex];\n    const region = this.getRegionById(segment.id);\n    if (region) {\n      for (let i = 0; i < lines.length; i += 1) {\n        const lineIndex = lines[i];\n        this.setLineEleColor(segment, region, lineIndex, color);\n      }\n    }\n  }\n\n  setLineEleColor(segment, region, lineIndex, color) {\n    const line = segment.content[lineIndex];\n    const roleColor = this.props.ontology.get(line.role);\n    const rgba = hexToRgba(\n      color || roleColor || defaultColor.defaultWhite,\n      !color && line.role === 'none' ? 0 : defaultColor.defaultAlpha\n    );\n    const lineElement = region.element.getElementsByClassName('line-mark')[lineIndex];\n    if (lineElement) {\n      lineElement.style.background = rgba;\n    }\n  }\n\n  setSegmentStartEnd(videoIndex, segmentIndex, start, end) {\n    if (videoIndex === this.current.videoIndex) {\n      const segments = this.props.results[videoIndex];\n      const segment = segments[segmentIndex];\n      const prevSegment = cloneDeep(segment);\n      const region = this.getRegionById(segment.id);\n      if (region) {\n        region.update({ start, end });\n      }\n      this.addHistory('segment', {\n        segmentIndex,\n        prevSegment,\n        nextSegment: cloneDeep(segment),\n        region,\n      });\n    }\n  }\n\n  seekCurrentAudio(currentTime = 0) {\n    const { wavesurfer } = this.current;\n    const duration = wavesurfer.getDuration();\n    wavesurfer.backend.seekTo(Math.min(Math.max(currentTime, 0), duration));\n  }\n\n  deleteCurrentSegment() {\n    const { currentSegment } = this.props;\n    const segment = this.currentSegments[currentSegment];\n    if (segment) {\n      const region = this.getRegionById(segment.id);\n      this.addHistory('segment', {\n        segmentIndex: currentSegment,\n        prevSegment: cloneDeep(segment),\n        region,\n      });\n      if (region) {\n        region.remove();\n      }\n      this.props.deleteSegment({ segmentIndex: currentSegment });\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      const currentSegmentIndex = this.currentSegments.findIndex((seg) => seg.start <= currentTime && seg.end >= currentTime);\n      this.props.setCurrentSegment({ index: currentSegmentIndex, start: currentTime });\n      this.current.segmentSelected = null;\n    }\n  }\n\n  handleKeyDown = (e) => {\n    if (!e.key) return;\n    if (window.disableLongAudioHotKeys) return;\n    if (isInput()) return;\n    if (isAnnotationReadonly(this.props.toolMode)) return;\n    if (e.altKey && this.props.segmentOverlap) {\n      this.altKeyDown = true;\n      if (this.hoveredRegion) {\n        this.hoveredRegion.drag = false;\n        this.hoveredRegion.resize = false;\n      }\n    }\n    switch (e.keyCode) {\n      case 8: // backspace\n      case 46: // delete\n        if (e.ctrlKey) {\n          this.clearAll();\n        } else {\n          this.deleteCurrentSegment();\n        }\n        break;\n      case 90: // z\n        if (e.ctrlKey) {\n          this.recallHistory('undo');\n        }\n        break;\n      case 89: // y\n        if (e.ctrlKey) {\n          this.recallHistory('redo');\n        }\n        break;\n      default:\n    }\n  };\n\n  handleKeyUp = (e) => {\n    if (!e.altKey) {\n      this.altKeyDown = false;\n      Object.values(this.current.wavesurfer.regions.list).forEach((region) => {\n        region.drag = true;\n        region.resize = true;\n      });\n    }\n  };\n\n  handlePlayPause() {\n    this.props.setPlayingState({\n      isPlaying: this.current.wavesurfer.isPlaying(),\n    });\n  }\n\n  handleRegionCreated = (region) => {\n    if (this.tempRegion) this.tempRegion.remove();\n    region.element.classList.add('line-region');\n    const mark = document.createElement('div');\n    mark.className = 'line-mark';\n    mark.style.height = '100%';\n    region.element.appendChild(mark);\n  };\n\n  handleRegionUpdate = (region) => {\n    const { annotateDisabled } = this.props;\n    if (annotateDisabled) {\n      if (region) region.remove();\n      return;\n    }\n    if (!this.props.segmentOverlap && !region.temp) {\n      const overlappedRegions = Object.values(this.current.wavesurfer.regions.list).filter((r) => !(r.end <= region.start || r.start >= region.end) && r !== region);\n      if (overlappedRegions.length > 0) {\n        // has overlapping\n        const minStart = Math.min(...overlappedRegions.map((r) => r.start));\n        const maxEnd = Math.max(...overlappedRegions.map((r) => r.end));\n        if (this.updatingRegionStart === region.start) {\n          // drag end handler\n          if (region.end > minStart) {\n            region.update({ end: minStart });\n          }\n        } else if (this.updatingRegionEnd === region.end) {\n          // drag start handler\n          if (region.start < maxEnd) {\n            region.update({ start: maxEnd });\n          }\n        } else if (region.start < this.updatingRegionStart) {\n          // move left\n          region.update({ start: maxEnd, end: region.end - region.start + maxEnd });\n        } else if (region.start > this.updatingRegionStart) {\n          // move right\n          region.update({ start: region.start - region.end + minStart, end: minStart });\n        }\n      }\n    }\n    this.updatingRegionStart = region.start;\n    this.updatingRegionEnd = region.end;\n    this.updateRegionElement(region);\n  };\n\n  handleRegionEdit = (region, e) => {\n    const { annotateDisabled, toolMode } = this.props;\n    const readonly = isAnnotationReadonly(toolMode) || annotateDisabled;\n    if ((readonly || (e?.buttons === 2 || e?.button === 2)) && !region.data.id) {\n      region.temp = true;\n      region.update({\n        color: hexToRgba(defaultColor.defaultGray, 0.2),\n      });\n      this.tempRegion = region;\n      this.current.wavesurfer?.play(region.start, region.end);\n      this.props.setCurrentSegment({ index: -1 });\n    }\n    if (region.temp) return;\n    this.updatingRegionStart = null;\n    this.updatingRegionEn = null;\n\n    const { id } = region.data;\n    const duration = this.current.wavesurfer.getDuration();\n    region.start = Math.max(region.start, 0);\n    region.end = Math.min(region.end, duration);\n    const { minSegmentLength, segmentConfig, lineConfig } = this.props;\n    if (!id) {\n      // create region\n      if (region.end - region.start < minSegmentLength) {\n        region.remove();\n        return;\n      }\n      const segment = createSegment(region.start, region.end, segmentConfig, lineConfig);\n      // eslint-disable-next-line no-param-reassign\n      region.data.id = segment.id;\n      region.play();\n      this.props.appendSegment({ segment });\n      this.addHistory('segment', {\n        segmentIndex: this.props.currentSegment,\n        nextSegment: cloneDeep(segment),\n        region,\n      });\n    } else {\n      // update region\n      const segmentIndex = this.getSegmentIndexById(id);\n      if (segmentIndex >= 0) {\n        const segment = this.currentSegments[segmentIndex];\n        const prevSegment = cloneDeep(segment);\n        let { start, end } = region;\n        if (end - start < minSegmentLength) {\n          const draggingStart = end === segment.end;\n          const draggingEnd = start === segment.start;\n          if (draggingStart) {\n            start = end - minSegmentLength;\n          } else if (draggingEnd) {\n            end = start + minSegmentLength;\n          }\n        }\n        region.update({ start, end });\n        segment.start = start;\n        segment.end = end;\n        this.props.updateSegment({ segment });\n        this.addHistory('segment', {\n          segmentIndex,\n          prevSegment,\n          nextSegment: cloneDeep(segment),\n          region,\n        });\n      }\n    }\n  };\n\n  handleRegionOut(region) {\n    const segment = this.currentSegments[this.props.currentSegment];\n    if (!segment && !region?.temp) {\n      return;\n    }\n    const currentRegion = region.temp ? region : this.getRegionById(segment?.id);\n    if (currentRegion === region) {\n      if (this.props.currentPlayMode === 'overallLoop') {\n        this.props.setCurrentSegment({ index: -1 });\n      } else if (this.props.currentPlayMode === 'regionLoop') {\n        this.seekCurrentAudio(region.start);\n        this.setCurrentScroll(region.start, 0, true);\n      } else if (this.props.currentPlayMode === 'regionPlay') {\n        this.current.wavesurfer.pause();\n        this.seekCurrentAudio(region.end);\n      }\n    }\n  }\n\n  handleRegionIn(region) {\n    if (this.props.currentPlayMode === 'overallLoop') {\n      const segmentIndex = this.getSegmentIndexById(region.data.id);\n      const currentTime = this.current.wavesurfer.getCurrentTime();\n      if (segmentIndex !== this.props.currentSegment && segmentIndex >= 0) {\n        this.props.setCurrentSegment({ index: segmentIndex, start: currentTime });\n      }\n    }\n  }\n\n  handleRegionClick(region, e) {\n    e.stopPropagation();\n    const segmentIndex = this.getSegmentIndexById(region.data.id);\n    if (segmentIndex >= 0) {\n      const cursorTime = this.getCursorTime();\n      const start = ((cursorTime > 0 && (e.altKey || e.ctrlKey)) || this.props.currentPlayMode === 'overallLoop') ? cursorTime : null;\n      this.props.setCurrentSegment({ index: segmentIndex, start });\n      if (this.tempRegion) this.tempRegion.remove();\n    } else if (region) {\n      this.current.wavesurfer?.play(region.start, region.end);\n    }\n  }\n\n  clearAll() {\n    Modal.confirm({\n      className: 'modal-root',\n      title: i18n.translate('COMMON_CLAER_CONFIRM_TITLE'),\n      content: i18n.translate('COMMON_CLAER_CONFIRM_DESC'),\n      autoFocusButton: null,\n      okText: i18n.translate('COMMON_CLAER_CONFIRM_SURE'),\n      okType: 'danger',\n      cancelText: i18n.translate('COMMON_CLAER_CONFIRM_CANCEL'),\n      onOk: () => {\n        const { currentSegment } = this.props;\n        const { videoIndex } = this.current;\n        const segments = cloneDeep(this.currentSegments);\n        this.props.setSegments({ videoIndex, segments: [] });\n        this.wavesurfers[videoIndex].clearRegions();\n        this.addHistory('clear_all', {\n          after: {\n            videoIndex,\n            currentIndex: -1,\n            segments: []\n          },\n          before: {\n            videoIndex,\n            currentIndex: currentSegment,\n            segments\n          },\n        });\n      },\n    });\n  }\n\n  addHistory(type, data) {\n    // update redo list each time\n    this.current.redoList = [];\n    this.current.undoList.push({ type, data });\n    if (this.current.undoList.length > 50) {\n      this.current.undoList.shift();\n    }\n  }\n\n  recallHistory(action) {\n    const { undoList, redoList } = this.current;\n    const recallList = action === 'undo' ? undoList : redoList;\n    if (!recallList.length) {\n      return;\n    }\n    this.props.setCurrentSegment({ index: -1 });\n    const recallItem = recallList.pop();\n    const { type, data } = recallItem;\n    switch (type) {\n      case 'segment': {\n        const { segmentIndex, prevSegment, nextSegment, region } = data;\n        const currSegment = action === 'undo' ? prevSegment : nextSegment;\n        const otherSegment = action === 'undo' ? nextSegment : prevSegment;\n        if (currSegment && otherSegment) {\n          this.props.updateSegment({ segment: currSegment });\n          const currentRegion = this.getRegionById(currSegment.id);\n          currentRegion.update({ start: currSegment.start, end: currSegment.end });\n        } else if (region && currSegment && !otherSegment) {\n          this.props.appendSegment({ segmentIndex, segment: currSegment });\n          const currentRegion = this.current.wavesurfer.regions.add(region);\n          this.updateRegionElement(currentRegion);\n        } else if (region && !currSegment && otherSegment) {\n          this.props.deleteSegment({ segmentIndex });\n          const currentRegion = this.getRegionById(otherSegment.id);\n          currentRegion.remove();\n        }\n        break;\n      }\n      case 'clear_all': {\n        const { before, after } = data;\n        const { videoIndex, currentIndex, segments } = action === 'undo' ? before : after;\n        this.wavesurfers[videoIndex].clearRegions();\n        this.props.setSegments({ videoIndex, segments });\n        this.initRegion(videoIndex, segments);\n        this.props.setCurrentSegment(currentIndex);\n        break;\n      }\n      case 'pushLine':\n        this.props.deleteLine({ ...data, actionType: 'history' });\n        break;\n      case 'deleteLine':\n        this.props.pushLine({ ...data, actionType: 'history' });\n        break;\n      case 'setLineColor':\n        this.props.setLineRole({ ...data, actionType: 'history' });\n        break;\n      default:\n        break;\n    }\n    if (recallItem.type === 'pushLine') {\n      recallItem.type = 'deleteLine';\n    } else if (recallItem.type === 'deleteLine') {\n      recallItem.type = 'pushLine';\n    } if (recallItem.type === 'setLineColor') {\n      const [nextRole, role] = [data.role, data.nextRole];\n      recallItem.data.role = role;\n      recallItem.data.nextRole = nextRole;\n    }\n\n    (action === 'undo' ? redoList : undoList).push(recallItem);\n  }\n\n  updateRegionElement(region) {\n    const { element, start, end } = region;\n    element.classList.add('dragged-region');\n    if (this.props.spaceLine > 0) {\n      const offset = this.props.spaceLine / (end - start);\n      let startLine = element.querySelector('.space-line.space-line-start');\n      let endLine = element.querySelector('.space-line.space-line-end');\n      if (offset < 0.5) {\n        if (!startLine) {\n          startLine = document.createElement('div');\n          startLine.className = 'space-line space-line-start';\n          element.appendChild(startLine);\n        }\n        if (!endLine) {\n          endLine = document.createElement('div');\n          endLine.className = 'space-line space-line-end';\n          element.appendChild(endLine);\n        }\n        startLine.style.left = `${offset * 100}%`;\n        endLine.style.right = `${offset * 100}%`;\n      } else {\n        if (startLine) {\n          startLine.remove();\n        }\n        if (endLine) {\n          endLine.remove();\n        }\n      }\n    }\n  }\n\n  updateMeasurement(index) {\n    if (this.current.videoIndex === index) {\n      // current video\n      let cursorHelper = this.container.audioContainer[index].getElementsByClassName('audio-cursor-helper')[0];\n      if (this.props.selectedMeasurement < 0) {\n        if (cursorHelper) {\n          cursorHelper.remove();\n        }\n      } else {\n        const { zoom, wavesurfer } = this.current;\n        if (!cursorHelper) {\n          cursorHelper = document.createElement('div');\n          cursorHelper.className = 'audio-cursor-helper';\n          wavesurfer?.cursor?.cursor.appendChild(cursorHelper);\n        }\n        // calc width\n        const duration = wavesurfer.getDuration();\n        const { offsetWidth } = wavesurfer.container;\n        const totalWidth = offsetWidth * zoom;\n        const width = (totalWidth / duration) * this.props.selectedMeasurement;\n        cursorHelper.style.width = `${width}px`;\n        cursorHelper.style.left = `-${width / 2}px`;\n      }\n    }\n  }\n\n  renderSegments = () => {\n    const { videos, results } = this.props;\n    videos.forEach((v, i) => {\n      if (v.ready) {\n        this.wavesurfers[i].clearRegions();\n        this.initRegion(i, results[i]);\n      }\n    });\n  };\n\n  render() { return null; }\n}\n\nconst mapStateToProps = (state) => ({\n  videos: state.videos,\n  results: state.results,\n  segmentConfig: state.segmentConfig,\n  lineConfig: state.lineConfig,\n  ontology: state.ontology,\n  currentSegment: state.currentSegment,\n  currentVideo: state.currentVideo,\n  currentPlayMode: state.currentPlayMode,\n  minSegmentLength: state.minSegmentLength,\n  isPlaying: state.isPlaying,\n  toolMode: state.toolMode,\n  spaceLine: state.spaceLine,\n  selectedMeasurement: state.selectedMeasurement,\n  segmentOverlap: state.segmentOverlap,\n  keyAttribute: state.keyAttribute,\n  annotateDisabled: state.annotateDisabled,\n  isLoadedAlaw: state.isLoadedAlaw,\n  styleConfig: state.styleConfig,\n});\nconst mapDispatchToProps = {\n  getWavesurfers,\n  setPlayingState,\n  setVideoValid,\n  deleteLine,\n  pushLine,\n  setLineRole,\n  parseSegments,\n  setErrorMsg,\n  setAudioErrorMsg,\n  appendSegment,\n  updateSegment,\n  deleteSegment,\n  setSegments,\n  updateLineRole,\n  updateVideoInfo,\n  setLoading,\n};\nexport default connect(mapStateToProps, mapDispatchToProps, null, { forwardRef: true })(WavesurferComp);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}