{"ast":null,"code":"/**\n * This module contains code for converting to and from the Textgrid\n * datastructure.  Textgrid files are typically stored as plain text.\n * This library does not do actual file IO but instead converts\n * to and from loaded strings to instances of Textgrid.\n *\n * @author Tim Mahrt\n * @since March 25, 2015\n * @module textgrid_io\n */\n\nimport iconvlite from 'iconv-lite';\nimport { Textgrid, IntervalTier, PointTier, copyTier, POINT_TIER, INTERVAL_TIER, MIN_INTERVAL_LENGTH } from './textgrid.js';\nimport { cropTextgrid } from './textgrid_modifiers.js';\n\n/**\n * Python-like split from\n * http://stackoverflow.com/questions/6131195/javascript-splitting-string-from-the-first-comma\n * @param {string} str\n * @param {string} separator - the separator to split on\n * @param {number} max - the max number of times to split\n * @return {Array}\n * @ignore\n */\nfunction extendedSplit(str, separator, max) {\n  const out = [];\n  let index = 0;\n  let next;\n  if (max) {\n    while (out.length < max - 1) {\n      next = str.indexOf(separator, index);\n      if (next === -1) {\n        break;\n      }\n      out.push(str.substring(index, next));\n      index = next + separator.length;\n    }\n  }\n  out.push(str.substring(index));\n  return out;\n}\nfunction findAllSubstrings(sourceStr, subStr) {\n  const indexList = [];\n  let index = sourceStr.indexOf(subStr);\n  while (index !== -1) {\n    indexList.push(index);\n    index += 1;\n    index = sourceStr.indexOf(subStr, index);\n  }\n  return indexList;\n}\nfunction fetchRow(dataStr, searchStr, index) {\n  const startIndex = dataStr.indexOf(searchStr, index) + searchStr.length;\n  let endIndex = dataStr.indexOf('\\n', startIndex);\n  let word = dataStr.substring(startIndex, endIndex);\n  word = word.trim();\n  if (word[0] === '\"' && word[word.length - 1] === '\"') {\n    word = word.substring(1, word.length - 1);\n  }\n  word = word.trim();\n\n  // Increment the index by 1, unless nothing was found\n  if (endIndex !== -1) endIndex += 1;\n  return [word, endIndex];\n}\nfunction parseNormalTextgrid(data) {\n  // Toss header\n  const tierList = data.split('item [');\n  const textgridHeader = tierList.shift();\n  const tgMin = parseFloat(textgridHeader.split('xmin = ', 2)[1].split('\\n', 1)[0].trim());\n  const tgMax = parseFloat(textgridHeader.split('xmax = ', 2)[1].split('\\n', 1)[0].trim());\n\n  // Process each tier individually\n  // tierList = data.split('item');\n  // tierList = tierList[1,tierList.length];\n  let tierTxt = '';\n  tierList.shift(); // Removing the document root empty item\n  const textgrid = new Textgrid();\n  textgrid.minTimestamp = tgMin;\n  textgrid.maxTimestamp = tgMax;\n  for (let i = 0; i < tierList.length; i++) {\n    tierTxt = tierList[i];\n\n    // Get tier type\n    let tierType = POINT_TIER;\n    let searchWord = 'points';\n    if (tierTxt.indexOf('class = \"IntervalTier\"') > -1) {\n      tierType = INTERVAL_TIER;\n      searchWord = 'intervals';\n    }\n\n    // Get tier meta-information\n    const tmpArray = extendedSplit(tierTxt, searchWord + ':', 2);\n    const header = tmpArray[0];\n    const tierData = tmpArray[1];\n    let tierName = header.split('name = ', 2)[1].split('\\n', 1)[0].trim();\n    tierName = tierName.slice(1, tierName.length - 1); // remove quotes\n    const tierStart = header.split('xmin = ', 2)[1].split('\\n', 1)[0].trim();\n    const tierEnd = header.split('xmax = ', 2)[1].split('\\n', 1)[0].trim();\n\n    // Get the tier entry list\n    const entryList = [];\n    let labelI = 0;\n    let label = null;\n    let tier = null;\n    if (tierType === INTERVAL_TIER) {\n      let timeStartI = null;\n      let timeEndI = null;\n      let timeStart = null;\n      let timeEnd = null;\n      while (true) {\n        [timeStart, timeStartI] = fetchRow(tierData, 'xmin = ', labelI);\n\n        // Break condition here.  indexof loops around at the end of a file\n        if (timeStartI <= labelI) break;\n        [timeEnd, timeEndI] = fetchRow(tierData, 'xmax = ', timeStartI);\n        [label, labelI] = fetchRow(tierData, 'text =', timeEndI);\n        label = label.trim();\n        entryList.push([parseFloat(timeStart), parseFloat(timeEnd), label]);\n      }\n      tier = new IntervalTier(tierName, entryList, tierStart, tierEnd);\n    } else {\n      let timePointI = null;\n      let timePoint = null;\n      while (true) {\n        [timePoint, timePointI] = fetchRow(tierData, 'number = ', labelI);\n\n        // Break condition here.  indexof loops around at the end of a file\n        if (timePointI <= labelI) break;\n        [label, labelI] = fetchRow(tierData, 'mark =', timePointI);\n        label = label.trim();\n        entryList.push([parseFloat(timePoint), label]);\n      }\n      tier = new PointTier(tierName, entryList, tierStart, tierEnd);\n    }\n    textgrid.addTier(tier);\n  }\n  return textgrid;\n}\nfunction parseShortTextgrid(data) {\n  const indexList = [];\n  const intervalIndicies = findAllSubstrings(data, '\"IntervalTier\"');\n  for (let i = 0; i < intervalIndicies.length; i++) {\n    indexList.push([intervalIndicies[i], true]);\n  }\n  const pointIndicies = findAllSubstrings(data, '\"TextTier\"');\n  for (let i = 0; i < pointIndicies.length; i++) {\n    indexList.push([pointIndicies[i], false]);\n  }\n  indexList.push([data.length, null]); // The 'end' of the file\n  indexList.sort(function (x, y) {\n    return x[0] - y[0];\n  });\n  const tupleList = [];\n  for (let i = 0; i < indexList.length - 1; i++) {\n    tupleList.push([indexList[i][0], indexList[i + 1][0], indexList[i][1]]);\n  }\n\n  // Set the textgrid's min and max times\n  const header = data.slice(0, tupleList[0][0]);\n  const headerList = header.split('\\n');\n  const tgMin = parseFloat(headerList[3]);\n  const tgMax = parseFloat(headerList[4]);\n\n  // Add the textgrid tiers\n  const textgrid = new Textgrid();\n  textgrid.minTimestamp = tgMin;\n  textgrid.maxTimestamp = tgMax;\n  for (let i = 0; i < tupleList.length; i++) {\n    let tier = null;\n    const blockStartI = tupleList[i][0];\n    const blockEndI = tupleList[i][1];\n    const isInterval = tupleList[i][2];\n    const tierData = data.slice(blockStartI, blockEndI);\n    const metaStartI = fetchRow(tierData, '', 0)[1];\n\n    // Tier meta-information\n    const [tierName, tierNameEndI] = fetchRow(tierData, '', metaStartI);\n    let [tierStartTime, tierStartTimeI] = fetchRow(tierData, '', tierNameEndI);\n    let [tierEndTime, tierEndTimeI] = fetchRow(tierData, '', tierStartTimeI);\n    let startTimeI = fetchRow(tierData, '', tierEndTimeI)[1];\n    tierStartTime = parseFloat(tierStartTime);\n    tierEndTime = parseFloat(tierEndTime);\n\n    // Tier entry data\n    let startTime = null;\n    let endTime = null;\n    let label = null;\n    // let tierType = null;\n    let endTimeI = null;\n    let labelI = null;\n    const entryList = [];\n    if (isInterval === true) {\n      while (true) {\n        [startTime, endTimeI] = fetchRow(tierData, '', startTimeI);\n        if (endTimeI === -1) break;\n        [endTime, labelI] = fetchRow(tierData, '', endTimeI);\n        [label, startTimeI] = fetchRow(tierData, '', labelI);\n        label = label.trim();\n        entryList.push([startTime, endTime, label]);\n      }\n      tier = new IntervalTier(tierName, entryList, tierStartTime, tierEndTime);\n    } else {\n      while (true) {\n        [startTime, labelI] = fetchRow(tierData, '', startTimeI);\n        if (labelI === -1) break;\n        [label, startTimeI] = fetchRow(tierData, '', labelI);\n        label = label.trim();\n        entryList.push([startTime, label]);\n      }\n      tier = new PointTier(tierName, entryList, tierStartTime, tierEndTime);\n    }\n    textgrid.addTier(tier);\n  }\n  return textgrid;\n}\n\n/**\n * Fills in the space between intervals with empty space.\n * This is necessary to do when saving to create a well-formed textgrid.\n * @ignore\n */\nfunction fillInBlanks(tier, blankLabel = '', startTime = null, endTime = null) {\n  if (startTime === null) startTime = tier.minTimestamp;\n  if (endTime === null) endTime = tier.maxTimestamp;\n\n  // Special case: empty textgrid\n  if (tier.entryList.length === 0) tier.entryList.push([startTime, endTime, blankLabel]);\n\n  // Create a new entry list\n  const entryList = tier.entryList.slice();\n  const entry = entryList[0];\n  let prevEnd = parseFloat(entry[1]);\n  const newEntryList = [entry];\n  for (let i = 1; i < entryList.length; i++) {\n    const newStart = parseFloat(entryList[i][0]);\n    const newEnd = parseFloat(entryList[i][1]);\n    if (prevEnd < newStart) newEntryList.push([prevEnd, newStart, blankLabel]);\n    newEntryList.push(entryList[i]);\n    prevEnd = newEnd;\n  }\n\n  // Special case: If there is a gap at the start of the file\n  if (parseFloat(newEntryList[0][0]) < parseFloat(startTime)) {\n    throw new Error('Tier data is before the tier start time.');\n  }\n  if (parseFloat(newEntryList[0][0]) > parseFloat(startTime)) {\n    newEntryList.splice(0, 0, [startTime, newEntryList[0][0], blankLabel]);\n  }\n\n  // Special case: If there is a gap at the end of the file\n  if (endTime !== null) {\n    const lastI = newEntryList.length - 1;\n    if (parseFloat(newEntryList[lastI][1]) > parseFloat(endTime)) {\n      throw new Error('Tier data is after the tier end time.');\n    }\n    if (parseFloat(newEntryList[lastI][1]) < parseFloat(endTime)) {\n      newEntryList.push([newEntryList[lastI][1], endTime, blankLabel]);\n    }\n  }\n  return copyTier(tier, {\n    entryList: newEntryList\n  });\n}\n\n/**\n * Prints each entry in the tier on a separate line w/ timing info\n * @ignore\n */\nfunction tierToText(tier) {\n  let text = '';\n  text += `\"${tier.tierType}\"\\n`;\n  text += `\"${tier.name}\"\\n`;\n  text += `${tier.minTimestamp}\\n${tier.maxTimestamp}\\n`;\n  text += `${tier.entryList.length}\\n`;\n  for (let i = 0; i < tier.entryList.length; i++) {\n    let entry = tier.entryList[i];\n    entry = entry.map(val => `${val}`);\n    let labelI;\n    if (tier.tierType === POINT_TIER) {\n      labelI = 1;\n    } else if (tier.tierType === INTERVAL_TIER) {\n      labelI = 2;\n    }\n    entry[labelI] = `\"${entry[labelI]}\"`;\n    text += entry.join('\\n') + '\\n';\n  }\n  return text;\n}\n\n/**\n * Remove intervals that are very tiny\n * Doing many small manipulations on intervals can lead to the creation\n * of ultrashort intervals (e.g. 1*10^-15 seconds long).  This function\n * removes such intervals.\n * @ignore\n */\nfunction removeUltrashortIntervals(tier, minLength, minTimestamp) {\n  // First, remove tiny intervals\n  const newEntryList = [];\n  let j = 0;\n  for (let i = 0; i < tier.entryList.length; i++) {\n    const [start, stop, label] = tier.entryList[i];\n    if (stop - start < minLength) {\n      // Correct ultra-short entries\n      if (newEntryList.length > 0) {\n        newEntryList[j - 1] = (newEntryList[j - 1], stop, newEntryList[j - 1]);\n      }\n    } else {\n      // Special case: the first entry in oldEntryList was ultra-short\n      if (newEntryList.length === 0 && start !== minTimestamp) {\n        newEntryList.push([minTimestamp, stop, label]);\n      } else {\n        // Normal case\n        newEntryList.push([start, stop, label]);\n      }\n      j += 1;\n    }\n  }\n\n  // Next, shift near equivalent tiny boundaries\n  j = 0;\n  while (j < newEntryList.length - 1) {\n    const diff = Math.abs(newEntryList[j][1] - newEntryList[j + 1][0]);\n    if (diff > 0 && diff < minLength) {\n      newEntryList[j] = [newEntryList[j][0], newEntryList[j + 1][0], newEntryList[j][2]];\n    }\n    j += 1;\n  }\n  return copyTier(tier, {\n    entryList: newEntryList\n  });\n}\n\n/**\n * Formats a textgrid instance for saving to a .csv file\n * @param {Textgrid} tg\n * @param {string} pivotTierName - One row in the output is listed for each entry in this tier.\n *  The corresponding entry in each tier will be provided on the same row\n *  along with the start and end time of the entry from the pivot tier.\n * @param {Array} [tierNameList=null] - the list of tier names to save.  If null, save all tiers.\n * @return {text}\n */\nfunction serializeTextgridToCsv(tg, pivotTierName, tierNameList = null, includeHeader = true) {\n  if (!tierNameList) tierNameList = tg.tierNameList;\n  let table = [];\n  if (includeHeader === true) {\n    const colHeader = tierNameList.slice();\n    colHeader.push('Start Time');\n    colHeader.push('End Time');\n    table.push(colHeader);\n  }\n  const tier = tg.tierDict[pivotTierName];\n  for (let i = 0; i < tier.entryList.length; i++) {\n    const start = tier.entryList[i][0];\n    const stop = tier.entryList[i][1];\n    // let label = tier.entryList[i][2];\n\n    const subTG = cropTextgrid(tg, start, stop, 'truncated', false);\n    const row = [];\n    for (let j = 0; j < tierNameList.length; j++) {\n      let subLabel = '';\n      if (subTG.tierNameList.includes(tierNameList[j])) {\n        const subTier = subTG.tierDict[tierNameList[j]];\n        if (subTier.entryList.length > 0) {\n          subLabel = subTier.entryList[0][2];\n        }\n      }\n      row.push(subLabel);\n    }\n    row.push(start);\n    row.push(stop);\n    table.push(row);\n  }\n  table = table.map(row => row.join(','));\n  const csv = table.join('\\n');\n  return csv;\n}\n\n/**\n * Formats a textgrid instance for saving to a .TextGrid file.\n * @param {Textgrid} tg\n * @param {number} [minimumIntervalLength=MIN_INTERVAL_LENGTH] - remove all intervals shorter than this; if null, don't remove any intervals\n * @param {number} [minTimestamp = null] -- the minTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If minTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @param {number} [maxTimestamp = null] -- the maxTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If maxTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @param {boolean} [useShortForm = true] -- specifies whether to use the short or long form specification of a textgrid;  the long form is more human readable, the short form is more compact\n * @return A text representation of a textgrid that can be opened by Praat\n */\nfunction serializeTextgrid(tg, minimumIntervalLength = MIN_INTERVAL_LENGTH, minTimestamp = null, maxTimestamp = null, useShortForm = true) {\n  if (minTimestamp === null) minTimestamp = tg.minTimestamp;\n  if (maxTimestamp === null) maxTimestamp = tg.maxTimestamp;\n  const outputTg = prepTgForSaving(tg, minimumIntervalLength, minTimestamp, maxTimestamp);\n  let outputTxt = '';\n  if (useShortForm) {\n    outputTxt = tgToShortTextForm(outputTg, minTimestamp, maxTimestamp);\n  } else {\n    outputTxt = tgToLongTextForm(outputTg, minTimestamp, maxTimestamp);\n  }\n  return outputTxt;\n}\nfunction tgToShortTextForm(tg, minTimestamp, maxTimestamp) {\n  let outputTxt = '';\n  outputTxt += 'File type = \"ooTextFile\"\\n';\n  outputTxt += 'Object class = \"TextGrid\"\\n\\n';\n  outputTxt += `${minTimestamp}\\n${maxTimestamp}\\n`;\n  outputTxt += `<exists>\\n${tg.tierNameList.length}\\n`;\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    outputTxt += tierToText(tg.tierDict[tg.tierNameList[i]]);\n  }\n  return outputTxt;\n}\nfunction tgToLongTextForm(tg, minTimestamp, maxTimestamp) {\n  const tab = ' '.repeat(4);\n  let outputTxt = '';\n\n  // File header\n  outputTxt += 'File type = \"ooTextFile\"\\n';\n  outputTxt += 'Object class = \"TextGrid\"\\n\\n';\n  outputTxt += `xmin = ${minTimestamp} \\n`;\n  outputTxt += `xmax = ${maxTimestamp} \\n`;\n  outputTxt += 'tiers? <exists> \\n';\n  outputTxt += `size = ${tg.tierNameList.length} \\n`;\n  outputTxt += 'item []: \\n';\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    const tier = tg.tierDict[tierName];\n\n    // Interval header\n    outputTxt += tab + `item [${i + 1}]:\\n`;\n    outputTxt += tab.repeat(2) + `class = \"${tier.tierType}\" \\n`;\n    outputTxt += tab.repeat(2) + `name = \"${tierName}\" \\n`;\n    outputTxt += tab.repeat(2) + `xmin = ${minTimestamp} \\n`;\n    outputTxt += tab.repeat(2) + `xmax = ${maxTimestamp} \\n`;\n    if (tier.tierType === INTERVAL_TIER) {\n      outputTxt += tab.repeat(2) + `intervals: size = ${tier.entryList.length} \\n`;\n      for (let j = 0; j < tier.entryList.length; j++) {\n        const [start, stop, label] = tier.entryList[j];\n        outputTxt += tab.repeat(2) + `intervals [${j + 1}]:\\n`;\n        outputTxt += tab.repeat(3) + `xmin = ${start} \\n`;\n        outputTxt += tab.repeat(3) + `xmax = ${stop} \\n`;\n        outputTxt += tab.repeat(3) + `text = \"${label}\" \\n`;\n      }\n    } else {\n      outputTxt += tab.repeat(2) + `points: size = ${tier.entryList.length} \\n`;\n      for (let j = 0; j < tier.entryList.length; j++) {\n        const [timestamp, label] = tier.entryList[j];\n        outputTxt += tab.repeat(2) + `points [${j + 1}]:\\n`;\n        outputTxt += tab.repeat(3) + `number = ${timestamp} \\n`;\n        outputTxt += tab.repeat(3) + `mark = \"${label}\" \\n`;\n      }\n    }\n  }\n  return outputTxt;\n}\n\n/**\n * Processing done before every textgrid is saved (serializeTextgrid calls this function) -- gaps are filled with silence and short intervals can be removed\n * @param {Textgrid} tg\n * @param {number} [minimumIntervalLength=MIN_INTERVAL_LENGTH] - remove all intervals shorter than this; if null, don't remove any intervals\n * @param {number} [minTimestamp = null] -- the minTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If minTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @param {number} [maxTimestamp = null] -- the maxTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If maxTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @return A cleaned TextGrid\n */\nfunction prepTgForSaving(tg, minimumIntervalLength = MIN_INTERVAL_LENGTH, minTimestamp = null, maxTimestamp = null) {\n  if (minTimestamp === null) minTimestamp = tg.minTimestamp;\n  if (maxTimestamp === null) maxTimestamp = tg.maxTimestamp;\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    tg.tierDict[tg.tierNameList[i]].sort();\n  }\n\n  // Fill in the blank spaces for interval tiers\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    let tier = tg.tierDict[tierName];\n    if (tier instanceof IntervalTier) {\n      tier = fillInBlanks(tier, '', minTimestamp, maxTimestamp);\n      if (minimumIntervalLength !== null) {\n        tier = removeUltrashortIntervals(tier, minimumIntervalLength, minTimestamp);\n      }\n      tg.tierDict[tierName] = tier;\n    }\n  }\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    tg.tierDict[tg.tierNameList[i]].sort();\n  }\n  return tg;\n}\n\n/**\n * Creates an instance of a Textgrid from the contents of a .Textgrid file.\n * @param {Buffer|string} text - can be either a buffer or a raw text string\n * @param {boolean} readRaw - default false; if true, points and intervals with an empty label '' are removed\n * @return {Textgrid}\n */\nfunction parseTextgrid(text, readRaw = false) {\n  text = decodeBuffer(text);\n  text = text.replace(/\\r\\n/g, '\\n');\n  let textgrid;\n  const caseA = text.indexOf('ooTextFile short') > -1; // 'short' in header\n  const caseB = text.indexOf('item [') === -1; // 'item' keyword not in file\n  if (caseA || caseB) {\n    textgrid = parseShortTextgrid(text);\n  } else {\n    textgrid = parseNormalTextgrid(text);\n  }\n  if (readRaw === false) {\n    for (let i = 0; i < textgrid.tierNameList.length; i++) {\n      const tierName = textgrid.tierNameList[i];\n      const tier = removeBlanks(textgrid.tierDict[tierName]);\n      textgrid.replaceTier(tierName, tier);\n    }\n  }\n  return textgrid;\n}\nfunction removeBlanks(tier) {\n  const entryList = [];\n  for (let i = 0; i < tier.entryList.length; i++) {\n    const entry = tier.entryList[i];\n    if (entry[entry.length - 1] === '') {\n      continue;\n    }\n    entryList.push(entry);\n  }\n  return copyTier(tier, {\n    entryList: entryList\n  });\n}\n\n/**\n * Decodes a buffer from utf16/8 to text.\n * @param {Buffer} buffer - if not of type Buffer, it will be returned without modification.\n * @return {string}\n * @ignore\n */\nfunction decodeBuffer(buffer) {\n  let returnText = buffer;\n  if (Buffer.isBuffer(buffer)) {\n    let decodedText = iconvlite.decode(buffer, 'utf16');\n    if (decodedText.indexOf('ooTextFile') === -1) {\n      decodedText = iconvlite.decode(buffer, 'utf8');\n    }\n    returnText = decodedText;\n  }\n  return returnText;\n}\nexport { parseTextgrid, serializeTextgrid, serializeTextgridToCsv, decodeBuffer, prepTgForSaving };","map":{"version":3,"names":["iconvlite","Textgrid","IntervalTier","PointTier","copyTier","POINT_TIER","INTERVAL_TIER","MIN_INTERVAL_LENGTH","cropTextgrid","extendedSplit","str","separator","max","out","index","next","length","indexOf","push","substring","findAllSubstrings","sourceStr","subStr","indexList","fetchRow","dataStr","searchStr","startIndex","endIndex","word","trim","parseNormalTextgrid","data","tierList","split","textgridHeader","shift","tgMin","parseFloat","tgMax","tierTxt","textgrid","minTimestamp","maxTimestamp","i","tierType","searchWord","tmpArray","header","tierData","tierName","slice","tierStart","tierEnd","entryList","labelI","label","tier","timeStartI","timeEndI","timeStart","timeEnd","timePointI","timePoint","addTier","parseShortTextgrid","intervalIndicies","pointIndicies","sort","x","y","tupleList","headerList","blockStartI","blockEndI","isInterval","metaStartI","tierNameEndI","tierStartTime","tierStartTimeI","tierEndTime","tierEndTimeI","startTimeI","startTime","endTime","endTimeI","fillInBlanks","blankLabel","entry","prevEnd","newEntryList","newStart","newEnd","Error","splice","lastI","tierToText","text","name","map","val","join","removeUltrashortIntervals","minLength","j","start","stop","diff","Math","abs","serializeTextgridToCsv","tg","pivotTierName","tierNameList","includeHeader","table","colHeader","tierDict","subTG","row","subLabel","includes","subTier","csv","serializeTextgrid","minimumIntervalLength","useShortForm","outputTg","prepTgForSaving","outputTxt","tgToShortTextForm","tgToLongTextForm","tab","repeat","timestamp","parseTextgrid","readRaw","decodeBuffer","replace","caseA","caseB","removeBlanks","replaceTier","buffer","returnText","Buffer","isBuffer","decodedText","decode"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/praatio/lib/textgrid_io.js"],"sourcesContent":["/**\n * This module contains code for converting to and from the Textgrid\n * datastructure.  Textgrid files are typically stored as plain text.\n * This library does not do actual file IO but instead converts\n * to and from loaded strings to instances of Textgrid.\n *\n * @author Tim Mahrt\n * @since March 25, 2015\n * @module textgrid_io\n */\n\nimport iconvlite from 'iconv-lite';\nimport {\n  Textgrid, IntervalTier, PointTier, copyTier,\n  POINT_TIER, INTERVAL_TIER, MIN_INTERVAL_LENGTH\n} from './textgrid.js';\n\nimport {\n  cropTextgrid\n} from './textgrid_modifiers.js';\n\n/**\n * Python-like split from\n * http://stackoverflow.com/questions/6131195/javascript-splitting-string-from-the-first-comma\n * @param {string} str\n * @param {string} separator - the separator to split on\n * @param {number} max - the max number of times to split\n * @return {Array}\n * @ignore\n */\nfunction extendedSplit (str, separator, max) {\n  const out = [];\n  let index = 0;\n  let next;\n\n  if (max) {\n    while (out.length < max - 1) {\n      next = str.indexOf(separator, index);\n      if (next === -1) {\n        break;\n      }\n      out.push(str.substring(index, next));\n      index = next + separator.length;\n    }\n  }\n  out.push(str.substring(index));\n  return out;\n}\n\nfunction findAllSubstrings (sourceStr, subStr) {\n  const indexList = [];\n  let index = sourceStr.indexOf(subStr);\n  while (index !== -1) {\n    indexList.push(index);\n    index += 1;\n\n    index = sourceStr.indexOf(subStr, index);\n  }\n  return indexList;\n}\n\nfunction fetchRow (dataStr, searchStr, index) {\n  const startIndex = dataStr.indexOf(searchStr, index) + searchStr.length;\n  let endIndex = dataStr.indexOf('\\n', startIndex);\n\n  let word = dataStr.substring(startIndex, endIndex);\n  word = word.trim();\n\n  if (word[0] === '\"' && word[word.length - 1] === '\"') {\n    word = word.substring(1, word.length - 1);\n  }\n  word = word.trim();\n\n  // Increment the index by 1, unless nothing was found\n  if (endIndex !== -1) endIndex += 1;\n\n  return [word, endIndex];\n}\n\nfunction parseNormalTextgrid (data) {\n  // Toss header\n  const tierList = data.split('item [');\n  const textgridHeader = tierList.shift();\n\n  const tgMin = parseFloat(textgridHeader.split('xmin = ', 2)[1].split('\\n', 1)[0].trim());\n  const tgMax = parseFloat(textgridHeader.split('xmax = ', 2)[1].split('\\n', 1)[0].trim());\n\n  // Process each tier individually\n  // tierList = data.split('item');\n  // tierList = tierList[1,tierList.length];\n  let tierTxt = '';\n  tierList.shift(); // Removing the document root empty item\n  const textgrid = new Textgrid();\n  textgrid.minTimestamp = tgMin;\n  textgrid.maxTimestamp = tgMax;\n\n  for (let i = 0; i < tierList.length; i++) {\n    tierTxt = tierList[i];\n\n    // Get tier type\n    let tierType = POINT_TIER;\n    let searchWord = 'points';\n    if (tierTxt.indexOf('class = \"IntervalTier\"') > -1) {\n      tierType = INTERVAL_TIER;\n      searchWord = 'intervals';\n    }\n\n    // Get tier meta-information\n    const tmpArray = extendedSplit(tierTxt, searchWord + ':', 2);\n    const header = tmpArray[0];\n    const tierData = tmpArray[1];\n    let tierName = header.split('name = ', 2)[1].split('\\n', 1)[0].trim();\n    tierName = tierName.slice(1, tierName.length - 1); // remove quotes\n    const tierStart = header.split('xmin = ', 2)[1].split('\\n', 1)[0].trim();\n    const tierEnd = header.split('xmax = ', 2)[1].split('\\n', 1)[0].trim();\n\n    // Get the tier entry list\n    const entryList = [];\n    let labelI = 0;\n    let label = null;\n    let tier = null;\n    if (tierType === INTERVAL_TIER) {\n      let timeStartI = null;\n      let timeEndI = null;\n      let timeStart = null;\n      let timeEnd = null;\n      while (true) {\n        [timeStart, timeStartI] = fetchRow(tierData, 'xmin = ', labelI);\n\n        // Break condition here.  indexof loops around at the end of a file\n        if (timeStartI <= labelI) break;\n\n        [timeEnd, timeEndI] = fetchRow(tierData, 'xmax = ', timeStartI);\n        [label, labelI] = fetchRow(tierData, 'text =', timeEndI);\n\n        label = label.trim();\n        entryList.push([parseFloat(timeStart), parseFloat(timeEnd), label]);\n      }\n      tier = new IntervalTier(tierName, entryList, tierStart, tierEnd);\n    } else {\n      let timePointI = null;\n      let timePoint = null;\n      while (true) {\n        [timePoint, timePointI] = fetchRow(tierData, 'number = ', labelI);\n\n        // Break condition here.  indexof loops around at the end of a file\n        if (timePointI <= labelI) break;\n\n        [label, labelI] = fetchRow(tierData, 'mark =', timePointI);\n\n        label = label.trim();\n        entryList.push([parseFloat(timePoint), label]);\n      }\n      tier = new PointTier(tierName, entryList, tierStart, tierEnd);\n    }\n    textgrid.addTier(tier);\n  }\n  return textgrid;\n}\n\nfunction parseShortTextgrid (data) {\n  const indexList = [];\n\n  const intervalIndicies = findAllSubstrings(data, '\"IntervalTier\"');\n  for (let i = 0; i < intervalIndicies.length; i++) {\n    indexList.push([intervalIndicies[i], true]);\n  }\n\n  const pointIndicies = findAllSubstrings(data, '\"TextTier\"');\n  for (let i = 0; i < pointIndicies.length; i++) {\n    indexList.push([pointIndicies[i], false]);\n  }\n\n  indexList.push([data.length, null]); // The 'end' of the file\n  indexList.sort(function (x, y) {\n    return x[0] - y[0];\n  });\n\n  const tupleList = [];\n  for (let i = 0; i < indexList.length - 1; i++) {\n    tupleList.push([indexList[i][0], indexList[i + 1][0], indexList[i][1]]);\n  }\n\n  // Set the textgrid's min and max times\n  const header = data.slice(0, tupleList[0][0]);\n  const headerList = header.split('\\n');\n  const tgMin = parseFloat(headerList[3]);\n  const tgMax = parseFloat(headerList[4]);\n\n  // Add the textgrid tiers\n  const textgrid = new Textgrid();\n  textgrid.minTimestamp = tgMin;\n  textgrid.maxTimestamp = tgMax;\n\n  for (let i = 0; i < tupleList.length; i++) {\n    let tier = null;\n\n    const blockStartI = tupleList[i][0];\n    const blockEndI = tupleList[i][1];\n    const isInterval = tupleList[i][2];\n\n    const tierData = data.slice(blockStartI, blockEndI);\n\n    const metaStartI = fetchRow(tierData, '', 0)[1];\n\n    // Tier meta-information\n    const [tierName, tierNameEndI] = fetchRow(tierData, '', metaStartI);\n    let [tierStartTime, tierStartTimeI] = fetchRow(tierData, '', tierNameEndI);\n    let [tierEndTime, tierEndTimeI] = fetchRow(tierData, '', tierStartTimeI);\n    let startTimeI = fetchRow(tierData, '', tierEndTimeI)[1];\n\n    tierStartTime = parseFloat(tierStartTime);\n    tierEndTime = parseFloat(tierEndTime);\n\n    // Tier entry data\n    let startTime = null;\n    let endTime = null;\n    let label = null;\n    // let tierType = null;\n    let endTimeI = null;\n    let labelI = null;\n\n    const entryList = [];\n    if (isInterval === true) {\n      while (true) {\n        [startTime, endTimeI] = fetchRow(tierData, '', startTimeI);\n        if (endTimeI === -1) break;\n\n        [endTime, labelI] = fetchRow(tierData, '', endTimeI);\n        [label, startTimeI] = fetchRow(tierData, '', labelI);\n\n        label = label.trim();\n        entryList.push([startTime, endTime, label]);\n      }\n      tier = new IntervalTier(tierName, entryList, tierStartTime, tierEndTime);\n    } else {\n      while (true) {\n        [startTime, labelI] = fetchRow(tierData, '', startTimeI);\n        if (labelI === -1) break;\n\n        [label, startTimeI] = fetchRow(tierData, '', labelI);\n\n        label = label.trim();\n        entryList.push([startTime, label]);\n      }\n      tier = new PointTier(tierName, entryList, tierStartTime, tierEndTime);\n    }\n    textgrid.addTier(tier);\n  }\n\n  return textgrid;\n}\n\n/**\n * Fills in the space between intervals with empty space.\n * This is necessary to do when saving to create a well-formed textgrid.\n * @ignore\n */\nfunction fillInBlanks (tier, blankLabel = '', startTime = null, endTime = null) {\n  if (startTime === null) startTime = tier.minTimestamp;\n  if (endTime === null) endTime = tier.maxTimestamp;\n\n  // Special case: empty textgrid\n  if (tier.entryList.length === 0) tier.entryList.push([startTime, endTime, blankLabel]);\n\n  // Create a new entry list\n  const entryList = tier.entryList.slice();\n  const entry = entryList[0];\n  let prevEnd = parseFloat(entry[1]);\n  const newEntryList = [entry];\n\n  for (let i = 1; i < entryList.length; i++) {\n    const newStart = parseFloat(entryList[i][0]);\n    const newEnd = parseFloat(entryList[i][1]);\n\n    if (prevEnd < newStart) newEntryList.push([prevEnd, newStart, blankLabel]);\n\n    newEntryList.push(entryList[i]);\n\n    prevEnd = newEnd;\n  }\n\n  // Special case: If there is a gap at the start of the file\n  if (parseFloat(newEntryList[0][0]) < parseFloat(startTime)) {\n    throw new Error('Tier data is before the tier start time.');\n  }\n  if (parseFloat(newEntryList[0][0]) > parseFloat(startTime)) {\n    newEntryList.splice(0, 0, [startTime, newEntryList[0][0], blankLabel]);\n  }\n\n  // Special case: If there is a gap at the end of the file\n  if (endTime !== null) {\n    const lastI = newEntryList.length - 1\n    if (parseFloat(newEntryList[lastI][1]) > parseFloat(endTime)) {\n      throw new Error('Tier data is after the tier end time.');\n    }\n    if (parseFloat(newEntryList[lastI][1]) < parseFloat(endTime)) {\n      newEntryList.push([newEntryList[lastI][1], endTime, blankLabel]);\n    }\n  }\n  return copyTier(tier, { entryList: newEntryList });\n}\n\n/**\n * Prints each entry in the tier on a separate line w/ timing info\n * @ignore\n */\nfunction tierToText (tier) {\n  let text = ''\n  text += `\"${tier.tierType}\"\\n`;\n  text += `\"${tier.name}\"\\n`;\n  text += `${tier.minTimestamp}\\n${tier.maxTimestamp}\\n`;\n  text += `${tier.entryList.length}\\n`;\n\n  for (let i = 0; i < tier.entryList.length; i++) {\n    let entry = tier.entryList[i];\n    entry = entry.map(val => `${val}`);\n\n    let labelI;\n    if (tier.tierType === POINT_TIER) {\n      labelI = 1;\n    }\n    else if (tier.tierType === INTERVAL_TIER) {\n      labelI = 2;\n    }\n\n    entry[labelI] = `\"${entry[labelI]}\"`\n    text += entry.join('\\n') + '\\n';\n  }\n\n  return text\n}\n\n/**\n * Remove intervals that are very tiny\n * Doing many small manipulations on intervals can lead to the creation\n * of ultrashort intervals (e.g. 1*10^-15 seconds long).  This function\n * removes such intervals.\n * @ignore\n */\nfunction removeUltrashortIntervals (tier, minLength, minTimestamp) {\n  // First, remove tiny intervals\n  const newEntryList = [];\n  let j = 0;\n  for (let i = 0; i < tier.entryList.length; i++) {\n    const [start, stop, label] = tier.entryList[i];\n    if (stop - start < minLength) {\n      // Correct ultra-short entries\n      if (newEntryList.length > 0) {\n        newEntryList[j - 1] = (newEntryList[j - 1], stop, newEntryList[j - 1]);\n      }\n    } else {\n      // Special case: the first entry in oldEntryList was ultra-short\n      if (newEntryList.length === 0 && start !== minTimestamp) {\n        newEntryList.push([minTimestamp, stop, label]);\n      } else { // Normal case\n        newEntryList.push([start, stop, label]);\n      }\n      j += 1;\n    }\n  }\n\n  // Next, shift near equivalent tiny boundaries\n  j = 0;\n  while (j < newEntryList.length - 1) {\n    const diff = Math.abs(newEntryList[j][1] - newEntryList[j + 1][0]);\n    if (diff > 0 && diff < minLength) {\n      newEntryList[j] = [newEntryList[j][0], newEntryList[j + 1][0], newEntryList[j][2]];\n    }\n    j += 1;\n  }\n\n  return copyTier(tier, { entryList: newEntryList });\n}\n\n/**\n * Formats a textgrid instance for saving to a .csv file\n * @param {Textgrid} tg\n * @param {string} pivotTierName - One row in the output is listed for each entry in this tier.\n *  The corresponding entry in each tier will be provided on the same row\n *  along with the start and end time of the entry from the pivot tier.\n * @param {Array} [tierNameList=null] - the list of tier names to save.  If null, save all tiers.\n * @return {text}\n */\nfunction serializeTextgridToCsv (tg, pivotTierName, tierNameList = null, includeHeader = true) {\n  if (!tierNameList) tierNameList = tg.tierNameList;\n\n  let table = [];\n  if (includeHeader === true) {\n    const colHeader = tierNameList.slice();\n    colHeader.push('Start Time');\n    colHeader.push('End Time');\n    table.push(colHeader);\n  }\n  const tier = tg.tierDict[pivotTierName];\n  for (let i = 0; i < tier.entryList.length; i++) {\n    const start = tier.entryList[i][0];\n    const stop = tier.entryList[i][1];\n    // let label = tier.entryList[i][2];\n\n    const subTG = cropTextgrid(tg, start, stop, 'truncated', false);\n\n    const row = [];\n    for (let j = 0; j < tierNameList.length; j++) {\n      let subLabel = '';\n      if (subTG.tierNameList.includes(tierNameList[j])) {\n        const subTier = subTG.tierDict[tierNameList[j]];\n        if (subTier.entryList.length > 0) {\n          subLabel = subTier.entryList[0][2];\n        }\n      }\n      row.push(subLabel);\n    }\n    row.push(start);\n    row.push(stop);\n    table.push(row);\n  }\n\n  table = table.map(row => row.join(','));\n  const csv = table.join('\\n');\n\n  return csv;\n}\n\n/**\n * Formats a textgrid instance for saving to a .TextGrid file.\n * @param {Textgrid} tg\n * @param {number} [minimumIntervalLength=MIN_INTERVAL_LENGTH] - remove all intervals shorter than this; if null, don't remove any intervals\n * @param {number} [minTimestamp = null] -- the minTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If minTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @param {number} [maxTimestamp = null] -- the maxTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If maxTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @param {boolean} [useShortForm = true] -- specifies whether to use the short or long form specification of a textgrid;  the long form is more human readable, the short form is more compact\n * @return A text representation of a textgrid that can be opened by Praat\n */\nfunction serializeTextgrid (tg, minimumIntervalLength = MIN_INTERVAL_LENGTH, minTimestamp = null, maxTimestamp = null, useShortForm = true) {\n  if (minTimestamp === null) minTimestamp = tg.minTimestamp;\n  if (maxTimestamp === null) maxTimestamp = tg.maxTimestamp;\n\n  const outputTg = prepTgForSaving(tg, minimumIntervalLength, minTimestamp, maxTimestamp);\n\n  let outputTxt = '';\n  if (useShortForm) {\n    outputTxt = tgToShortTextForm(outputTg, minTimestamp, maxTimestamp);\n  } else {\n    outputTxt = tgToLongTextForm(outputTg, minTimestamp, maxTimestamp);\n  }\n\n  return outputTxt;\n}\n\nfunction tgToShortTextForm (tg, minTimestamp, maxTimestamp) {\n  let outputTxt = '';\n  outputTxt += 'File type = \"ooTextFile\"\\n';\n  outputTxt += 'Object class = \"TextGrid\"\\n\\n';\n  outputTxt += `${minTimestamp}\\n${maxTimestamp}\\n`;\n  outputTxt += `<exists>\\n${tg.tierNameList.length}\\n`;\n\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    outputTxt += tierToText(tg.tierDict[tg.tierNameList[i]]);\n  }\n\n  return outputTxt;\n}\n\nfunction tgToLongTextForm (tg, minTimestamp, maxTimestamp) {\n  const tab = ' '.repeat(4);\n\n  let outputTxt = '';\n\n  // File header\n  outputTxt += 'File type = \"ooTextFile\"\\n';\n  outputTxt += 'Object class = \"TextGrid\"\\n\\n';\n  outputTxt += `xmin = ${minTimestamp} \\n`\n  outputTxt += `xmax = ${maxTimestamp} \\n`\n  outputTxt += 'tiers? <exists> \\n'\n  outputTxt += `size = ${tg.tierNameList.length} \\n`\n  outputTxt += 'item []: \\n'\n\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    const tier = tg.tierDict[tierName];\n\n    // Interval header\n    outputTxt += tab + `item [${i + 1}]:\\n`\n    outputTxt += tab.repeat(2) + `class = \"${tier.tierType}\" \\n`\n    outputTxt += tab.repeat(2) + `name = \"${tierName}\" \\n`\n    outputTxt += tab.repeat(2) + `xmin = ${minTimestamp} \\n`\n    outputTxt += tab.repeat(2) + `xmax = ${maxTimestamp} \\n`\n\n    if (tier.tierType === INTERVAL_TIER) {\n      outputTxt += tab.repeat(2) + `intervals: size = ${tier.entryList.length} \\n`\n      for (let j = 0; j < tier.entryList.length; j++) {\n        const [start, stop, label] = tier.entryList[j];\n        outputTxt += tab.repeat(2) + `intervals [${j + 1}]:\\n`\n        outputTxt += tab.repeat(3) + `xmin = ${start} \\n`\n        outputTxt += tab.repeat(3) + `xmax = ${stop} \\n`\n        outputTxt += tab.repeat(3) + `text = \"${label}\" \\n`\n      }\n    } else {\n      outputTxt += tab.repeat(2) + `points: size = ${tier.entryList.length} \\n`\n      for (let j = 0; j < tier.entryList.length; j++) {\n        const [timestamp, label] = tier.entryList[j];\n        outputTxt += tab.repeat(2) + `points [${j + 1}]:\\n`\n        outputTxt += tab.repeat(3) + `number = ${timestamp} \\n`\n        outputTxt += tab.repeat(3) + `mark = \"${label}\" \\n`\n      }\n    }\n  }\n\n  return outputTxt;\n}\n\n/**\n * Processing done before every textgrid is saved (serializeTextgrid calls this function) -- gaps are filled with silence and short intervals can be removed\n * @param {Textgrid} tg\n * @param {number} [minimumIntervalLength=MIN_INTERVAL_LENGTH] - remove all intervals shorter than this; if null, don't remove any intervals\n * @param {number} [minTimestamp = null] -- the minTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If minTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @param {number} [maxTimestamp = null] -- the maxTimestamp of the saved Textgrid; if None, use whatever is defined in the Textgrid object.  If maxTimestamp is larger than timestamps in your textgrid, an exception will be thrown.\n * @return A cleaned TextGrid\n */\nfunction prepTgForSaving (tg, minimumIntervalLength = MIN_INTERVAL_LENGTH, minTimestamp = null, maxTimestamp = null) {\n  if (minTimestamp === null) minTimestamp = tg.minTimestamp;\n  if (maxTimestamp === null) maxTimestamp = tg.maxTimestamp;\n\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    tg.tierDict[tg.tierNameList[i]].sort();\n  }\n\n  // Fill in the blank spaces for interval tiers\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    const tierName = tg.tierNameList[i];\n    let tier = tg.tierDict[tierName];\n\n    if (tier instanceof IntervalTier) {\n      tier = fillInBlanks(tier, '', minTimestamp, maxTimestamp);\n      if (minimumIntervalLength !== null) {\n        tier = removeUltrashortIntervals(tier, minimumIntervalLength, minTimestamp);\n      }\n      tg.tierDict[tierName] = tier;\n    }\n  }\n\n  for (let i = 0; i < tg.tierNameList.length; i++) {\n    tg.tierDict[tg.tierNameList[i]].sort();\n  }\n\n  return tg;\n}\n\n/**\n * Creates an instance of a Textgrid from the contents of a .Textgrid file.\n * @param {Buffer|string} text - can be either a buffer or a raw text string\n * @param {boolean} readRaw - default false; if true, points and intervals with an empty label '' are removed\n * @return {Textgrid}\n */\nfunction parseTextgrid (text, readRaw = false) {\n  text = decodeBuffer(text);\n  text = text.replace(/\\r\\n/g, '\\n');\n\n  let textgrid;\n  const caseA = text.indexOf('ooTextFile short') > -1; // 'short' in header\n  const caseB = text.indexOf('item [') === -1; // 'item' keyword not in file\n  if (caseA || caseB) {\n    textgrid = parseShortTextgrid(text);\n  } else {\n    textgrid = parseNormalTextgrid(text);\n  }\n\n  if (readRaw === false) {\n    for (let i = 0; i < textgrid.tierNameList.length; i++) {\n      const tierName = textgrid.tierNameList[i];\n      const tier = removeBlanks(textgrid.tierDict[tierName]);\n      textgrid.replaceTier(tierName, tier);\n    }\n  }\n\n  return textgrid;\n}\n\nfunction removeBlanks (tier) {\n  const entryList = [];\n  for (let i = 0; i < tier.entryList.length; i++) {\n    const entry = tier.entryList[i];\n    if (entry[entry.length - 1] === '') {\n      continue;\n    }\n    entryList.push(entry);\n  }\n  return copyTier(tier, { entryList: entryList });\n}\n\n/**\n * Decodes a buffer from utf16/8 to text.\n * @param {Buffer} buffer - if not of type Buffer, it will be returned without modification.\n * @return {string}\n * @ignore\n */\nfunction decodeBuffer (buffer) {\n  let returnText = buffer\n  if (Buffer.isBuffer(buffer)) {\n    let decodedText = iconvlite.decode(buffer, 'utf16');\n    if (decodedText.indexOf('ooTextFile') === -1) {\n      decodedText = iconvlite.decode(buffer, 'utf8');\n    }\n    returnText = decodedText;\n  }\n  return returnText;\n}\n\nexport { parseTextgrid, serializeTextgrid, serializeTextgridToCsv, decodeBuffer, prepTgForSaving };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}