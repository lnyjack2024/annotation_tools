{"ast":null,"code":"import _applyDecoratedDescriptor from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nvar _class,\n  _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/components/TierPannel/index.tsx\";\nimport React from 'react';\nimport { cloneDeep, debounce } from 'lodash';\nimport { makeObservable, reaction, computed } from 'mobx';\nimport { Point, Container } from 'pixi.js';\nimport { observer } from 'mobx-react';\nimport { notification } from 'antd';\nimport rootStore from '../../store/RootStore';\nimport ShapeFactory, { ShapeType } from '../../common/shapes/ShapeFactory';\nimport { hitTesting } from '../../utils';\nimport i18n from '../../locales';\nimport { AnnotationType, ReviewResult } from '../../types';\nimport './index.scss';\nexport let Tier = (_class = class Tier extends React.Component {\n  constructor(props) {\n    super(props);\n    /**\n     * application dom container\n     */\n    this.container = void 0;\n    this.hoveredShape = void 0;\n    /**\n     * selected Tier\n     */\n    this.selectedTier = null;\n    /**\n    * view container\n    */\n    this.viewContainer = new Container();\n    /**\n    * tier container map\n    */\n    this.tierContainerMap = {};\n    /**\n    * add bar map\n    */\n    this.addBarMap = {};\n    /**\n    * add bar container\n    */\n    this.addContainer = new Container();\n    /**\n    * reaction disposer\n    */\n    this.reactionDisposer = void 0;\n    /**\n    * selected Shape\n    */\n    this.selectedShape = null;\n    /**\n     * same start time shape\n     */\n    this.sameStartShapes = [];\n    /**\n    * shape map\n    */\n    this.shapeMap = {};\n    this.resizeDebounced = void 0;\n    /**\n     * canvas dom mouse down\n     * @param event\n     */\n    this.handleMouseDown = uid => {\n      var _this$hoveredShape;\n      if (!rootStore.review.isSelectInstanceEnable) {\n        notification.error({\n          message: i18n.translate('QC_REASON_LABEL')\n        });\n        return;\n      }\n      const hoveredShape = uid === ((_this$hoveredShape = this.hoveredShape) === null || _this$hoveredShape === void 0 ? void 0 : _this$hoveredShape.id) ? this.hoveredShape : this.shapeMap[uid];\n      if (hoveredShape) {\n        rootStore.analyse.setSelectedTime(hoveredShape.start);\n        const {\n          id,\n          category\n        } = hoveredShape;\n        const {\n          getInstanceById,\n          setSelectedInstance\n        } = rootStore.instance;\n        setSelectedInstance(getInstanceById(id));\n        this.selectTier(category, this.tierContainerMap[category]);\n        const {\n          isEnabled,\n          drawMode,\n          handleChangeReview\n        } = rootStore.review;\n        if (isEnabled && !drawMode) {\n          handleChangeReview(id);\n        }\n      }\n    };\n    /**\n     * canvas dom mouse move\n     * @param event\n     */\n    this.handleMouseMove = event => {\n      const currentPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this.mapStageToLocalPosition(currentPoint);\n      const intersection = hitTesting(currentPoint, localPoint, this.props.app.stage.children);\n      this.setHoveredShape(intersection === null || intersection === void 0 ? void 0 : intersection.shape);\n    };\n    /**\n     * resize\n     */\n    this.resizeTier = () => {\n      const {\n        atlasWidth,\n        tierHeight\n      } = rootStore.analyse.placement;\n      this.props.app.renderer.resize(atlasWidth, tierHeight);\n      this.props.app.render();\n      this.props.app.renderer.backgroundColor = 0xf1f5f8;\n      this.props.app.stage.removeChildren();\n      this.props.app.stage.addChild(this.viewContainer);\n      this.viewContainer.sortableChildren = true;\n      this.initContainer();\n      this.redrawShapes();\n    };\n    this.selectTier = (className, ctx) => {\n      var _this$selectedTier;\n      if (`tier_${(_this$selectedTier = this.selectedTier) === null || _this$selectedTier === void 0 ? void 0 : _this$selectedTier.id}` !== ctx.id) {\n        rootStore.ontology.selectCategory(className);\n        if (this.selectedTier) {\n          this.selectedTier.selected = false;\n        }\n        this.selectedTier = ctx;\n        this.selectedTier.selected = true;\n      }\n    };\n    this.redrawShapes = () => {\n      this.updateShapes(rootStore.instance.instances);\n    };\n    this.handleAddShape = className => {\n      const {\n        selectedTime\n      } = rootStore.analyse;\n      if (selectedTime) {\n        if (this.selectedTier && this.selectedTier.category !== className) {\n          this.selectedTier.selected = false;\n        }\n        this.selectedTier = this.tierContainerMap[className];\n        this.selectedTier.selected = true;\n        rootStore.instance.addInstance(className, selectedTime);\n      }\n    };\n    this.positionListener = start => {\n      rootStore.analyse.setSelectedTime(start);\n    };\n    this.handleMoveShape = shapes => {\n      const updatedInstances = {};\n      shapes.forEach(({\n        id,\n        start,\n        end\n      }) => {\n        const instance = rootStore.instance.getInstanceById(id);\n        if (instance && (instance.start !== start || instance.end !== end)) {\n          updatedInstances[id] = {\n            ...instance,\n            start,\n            end\n          };\n        }\n      });\n      rootStore.instance.setUpdatedInstances(updatedInstances);\n    };\n    /**\n     * update shapes\n     */\n    this.updateShapes = updatedInstances => {\n      const {\n        atlasWidth\n      } = rootStore.analyse.placement;\n      if (atlasWidth > 0) {\n        const ids = Object.keys(updatedInstances);\n        if (ids.length > 0) {\n          Object.keys(updatedInstances).forEach(id => {\n            const instance = updatedInstances[id];\n            if (instance) {\n              const {\n                start,\n                end,\n                category,\n                categoryIndex,\n                text\n              } = instance;\n              if (this.shapeMap[id]) {\n                this.updateShape(id, start, end, text);\n              } else {\n                this.createShape(id, category, categoryIndex, start, text, end);\n              }\n            } else {\n              this.removeShape(id);\n            }\n          });\n          rootStore.instance.setUpdatedInstances({});\n          if (rootStore.review.drawMode) {\n            this.getCanAddTiers();\n          }\n        }\n      }\n    };\n    /**\n     * update shape\n     * @param id\n     * @param startTime\n     * @param endTime\n     */\n    this.updateShape = (id, startTime, endTime, text) => {\n      const shape = this.shapeMap[id];\n      if (shape) {\n        if (shape.end === endTime && shape.start === startTime) {\n          if (text !== shape.text) {\n            shape.text = text;\n          } else {\n            shape.normalize();\n          }\n        } else {\n          shape.start = startTime;\n          if (endTime && shape.shapeType === AnnotationType.SEGMENT) {\n            shape.end = endTime;\n          }\n        }\n      }\n    };\n    /**\n     * remove shape\n     * @param id\n     */\n    this.removeShape = id => {\n      const shape = this.shapeMap[id];\n      if (shape) {\n        shape.destroy();\n        delete this.shapeMap[id];\n      }\n    };\n    this.initReviews = () => {\n      const {\n        reviewsResult,\n        customWarnings\n      } = rootStore.review;\n      const keys = Object.keys(rootStore.instance.instances);\n      keys.forEach(key => {\n        let review;\n        const warning = customWarnings.find(({\n          id\n        }) => id === key);\n        if (warning) {\n          review = {\n            instanceId: warning.id,\n            result: ReviewResult.REJECT\n          };\n        } else {\n          review = reviewsResult.find(({\n            instanceId\n          }) => instanceId === key);\n        }\n        this.drawReview(key, review);\n      });\n    };\n    this.drawReview = (id, review) => {\n      if (id && this.shapeMap[id]) {\n        this.shapeMap[id].reviewResult = review ? review.result : undefined;\n      }\n    };\n    /**\n     * create shape\n     * @param id\n     * @param className tier category\n     * @param index tier number\n     * @param startTime start time\n     * @param endTime end time\n     */\n    this.createShape = (id, className, index, startTime, text, endTime) => {\n      const category = rootStore.ontology.getCategory(className);\n      if (startTime !== undefined && category !== undefined) {\n        var _rootStore$review$upd;\n        const shapeType = category.type;\n        const shape = ShapeFactory.getShape(shapeType, {\n          id,\n          app: this.props.app,\n          start: startTime,\n          end: endTime,\n          text,\n          container: this.viewContainer,\n          shapeType,\n          category: className,\n          categoryIndex: index,\n          reviewResult: (_rootStore$review$upd = rootStore.review.updatedReviews[id]) === null || _rootStore$review$upd === void 0 ? void 0 : _rootStore$review$upd.result,\n          selectShape: this.handleMouseDown,\n          moveShape: this.handleMoveShape,\n          positionListener: this.positionListener,\n          getPrevShape: this.getPrevShape,\n          getSameAndAdjoinTimeShapes: this.getSameAndAdjoinTimeShapes\n        });\n        this.shapeMap[shape.id] = shape;\n        if (rootStore.instance.selectedInstanceId === id) {\n          this.setSelectedShape(id);\n          this.selectTier(className, this.tierContainerMap[className]);\n        }\n      }\n    };\n    this.getPrevShape = (category, start) => {\n      const {\n        prevInstance,\n        nextInstance\n      } = rootStore.instance.getAdjoinInstances(category, start);\n      const adjoinShapes = {\n        prev: undefined,\n        next: undefined\n      };\n      if (prevInstance) {\n        adjoinShapes.prev = this.shapeMap[prevInstance.id];\n      }\n      if (nextInstance) {\n        adjoinShapes.next = this.shapeMap[nextInstance.id];\n      }\n      return adjoinShapes;\n    };\n    this.getSameAndAdjoinTimeShapes = time => {\n      const sameTimeShapes = this.shapes.filter(shape => shape.start === time);\n      const adjoinTimeShapes = sameTimeShapes.map(({\n        category,\n        start\n      }) => this.getPrevShape(category, start));\n      return {\n        sameTimeShapes,\n        adjoinTimeShapes\n      };\n    };\n    this.container = React.createRef();\n\n    // set interactive\n    this.props.app.stage.interactive = this.props.interactive !== false;\n    makeObservable(this, {});\n  }\n  get shapes() {\n    return Object.values(this.shapeMap);\n  }\n  async componentDidMount() {\n    if (this.container.current) {\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n      this.props.app.stage.sortableChildren = true;\n      this.reactionDisposer = reaction(() => this.selectedTime, () => {\n        this.getCanAddTiers();\n      });\n      reaction(() => this.resizeShapes, () => {\n        if (!this.resizeDebounced) {\n          this.resizeDebounced = debounce(this.resizeTier, 100);\n        }\n        this.resizeDebounced();\n      });\n      reaction(() => rootStore.ontology.canAddTiers, () => {\n        this.initAddBar();\n      });\n      reaction(() => rootStore.instance.updatedInstances, () => {\n        this.updateShapes(rootStore.instance.updatedInstances);\n      });\n      reaction(() => rootStore.review.updatedReviews, () => {\n        this.initReviews();\n      });\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get selectedTime() {\n    return {\n      time: rootStore.analyse.selectedTime,\n      region: rootStore.analyse.selectedRegion,\n      drawMode: rootStore.review.drawMode\n    };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get resizeShapes() {\n    return {\n      placement: rootStore.analyse.placement,\n      displayBuffer: rootStore.analyse.displayBuffer\n    };\n  }\n  componentDidUpdate(prevProps) {\n    if (JSON.stringify(prevProps.selectedInstance) !== JSON.stringify(this.props.selectedInstance)) {\n      var _this$props$selectedI;\n      this.setSelectedShape((_this$props$selectedI = this.props.selectedInstance) === null || _this$props$selectedI === void 0 ? void 0 : _this$props$selectedI.id);\n    }\n  }\n  componentWillUnmount() {\n    if (this.reactionDisposer) {\n      this.reactionDisposer();\n    }\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x, y) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n  initContainer() {\n    this.tierContainerMap = {};\n    const {\n      categories\n    } = rootStore.ontology;\n    const {\n      tierHeight,\n      atlasWidth\n    } = rootStore.analyse.placement;\n    const height = tierHeight / categories.length;\n    categories.forEach((category, i) => {\n      const container = ShapeFactory.getShape(ShapeType.TIER_CONTAINER, {\n        id: `tier_${category.className}`,\n        index: i,\n        width: atlasWidth,\n        container: this.viewContainer,\n        height,\n        category: category.className,\n        app: this.props.app,\n        selected: i === 0,\n        onSelected: this.selectTier\n      });\n      this.tierContainerMap[category.className] = container;\n      if (i === 0) {\n        this.selectedTier = container;\n      }\n    });\n    this.addContainer.zIndex = 999;\n    this.props.app.stage.addChild(this.addContainer);\n  }\n  initAddBar() {\n    const {\n      selectedTime,\n      displayBuffer,\n      placement\n    } = rootStore.analyse;\n    const {\n      canAddTiers,\n      categories\n    } = rootStore.ontology;\n    const {\n      atlasWidth,\n      tierHeight,\n      duration\n    } = placement;\n    const tiers = Object.entries(canAddTiers);\n    this.addContainer.removeChildren();\n    if (selectedTime && tiers.length > 0) {\n      const {\n        start,\n        precent\n      } = displayBuffer;\n      const visibleStartTime = start * duration;\n      const colWidth = atlasWidth / (precent * duration);\n      const x = (selectedTime - visibleStartTime) * colWidth;\n      const height = tierHeight / categories.length;\n      tiers.forEach(([className, {\n        index\n      }]) => {\n        const add = ShapeFactory.getShape(ShapeType.ADD_BAR, {\n          x,\n          index,\n          height,\n          category: className,\n          container: this.addContainer,\n          app: this.props.app,\n          onAdd: this.handleAddShape\n        });\n        this.addBarMap[className] = add;\n      });\n    }\n  }\n  getCanAddTiers() {\n    if (!rootStore.review.drawMode) {\n      this.addContainer.removeChildren();\n      return;\n    }\n    const {\n      selectedTime,\n      displayBuffer,\n      placement,\n      selectedRegion\n    } = rootStore.analyse;\n    const {\n      start,\n      precent\n    } = displayBuffer;\n    const {\n      atlasWidth,\n      duration\n    } = placement;\n    const visibleStartTime = start * duration;\n    const colWidth = atlasWidth / (precent * duration);\n    const enableCategories = cloneDeep(rootStore.ontology.enableCategories);\n    if (selectedTime) {\n      const x = (selectedTime - visibleStartTime) * colWidth;\n      Object.values(this.shapeMap).forEach(({\n        startX,\n        category\n      }) => {\n        if (Math.abs(x - startX) < 10) {\n          delete enableCategories[category];\n        }\n      });\n      rootStore.ontology.setCanAddTiers(enableCategories);\n    } else if (selectedRegion) {\n      const categoryDisabled = {};\n      const {\n        start: frist,\n        end: second\n      } = selectedRegion;\n      const firstX = (frist - visibleStartTime) * colWidth;\n      const secondX = (second - visibleStartTime) * colWidth;\n      Object.values(this.shapeMap).forEach(({\n        startX,\n        category\n      }) => {\n        if (!categoryDisabled[category]) {\n          if (startX > firstX && startX < secondX) {\n            enableCategories[category].first = false;\n            enableCategories[category].second = false;\n            categoryDisabled[category] = true;\n          } else if (Math.abs(firstX - startX) < 10 || Math.abs(secondX - startX) < 10) {\n            const firstDisabled = Math.abs(firstX - startX) < 10;\n            const secondDisabled = Math.abs(secondX - startX) < 10;\n            if (firstDisabled && secondDisabled) {\n              delete enableCategories[category];\n            } else if (firstDisabled) {\n              enableCategories[category].first = false;\n            } else if (secondDisabled) {\n              enableCategories[category].second = false;\n            }\n          }\n        }\n      });\n      rootStore.ontology.setCanAddTiers(enableCategories);\n    } else {\n      rootStore.ontology.setCanAddTiers({});\n    }\n  }\n  /**\n   * set selected shape\n   * @param shape\n   */\n  setSelectedShape(id) {\n    if (this.selectedShape) {\n      this.selectedShape.selected = false;\n    }\n    const shape = this.shapeMap[id || ''];\n    if (shape) {\n      this.selectedShape = shape;\n      this.selectedShape.selected = true;\n    }\n    this.drawSameStartShape(shape === null || shape === void 0 ? void 0 : shape.start);\n  }\n\n  /**\n   * redraw shape control\n   * @param start start time\n   */\n  drawSameStartShape(start) {\n    if (this.sameStartShapes.length > 0) {\n      this.sameStartShapes.forEach(s => {\n        s.selectedStart = false;\n      });\n    }\n    if (start !== undefined) {\n      const sameStartShapes = [];\n      this.shapes.forEach(s => {\n        var _this$selectedShape;\n        if (s.start === start && s.id !== ((_this$selectedShape = this.selectedShape) === null || _this$selectedShape === void 0 ? void 0 : _this$selectedShape.id)) {\n          s.selectedStart = true;\n          sameStartShapes.push(s);\n        }\n      });\n      this.sameStartShapes = sameStartShapes;\n    }\n  }\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point) {\n    return this.props.app.stage.toLocal(point);\n  }\n\n  /**\n   * check if the point is in the stage\n   * @param point\n   */\n  isPointInStage(point) {\n    const {\n      x,\n      y\n    } = this.getStagePosition();\n    const {\n      width,\n      height\n    } = this.getStageSize();\n    return point.x >= x && point.x <= x + width && point.y >= y && point.y <= y + height;\n  }\n\n  /**\n   * get stage size\n   */\n  getStageSize() {\n    return {\n      width: this.props.app.stage.width,\n      height: this.props.app.stage.height\n    };\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.props.app.stage.x,\n      y: this.props.app.stage.y\n    };\n  }\n  render() {\n    const {\n      margin,\n      tierHeight\n    } = rootStore.analyse.placement;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"praat-tier-container\",\n      style: {\n        height: tierHeight,\n        padding: `0 ${margin}px`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 627,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"canvas-container\",\n      ref: this.container,\n      style: {\n        width: '100%',\n        height: '100%'\n      },\n      onMouseMove: this.handleMouseMove,\n      onContextMenu: e => e.preventDefault(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 628,\n        columnNumber: 9\n      }\n    }));\n  }\n}, _applyDecoratedDescriptor(_class.prototype, \"shapes\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"shapes\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"selectedTime\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"selectedTime\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"resizeShapes\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"resizeShapes\"), _class.prototype), _class);\nexport default observer(Tier);","map":{"version":3,"names":["React","cloneDeep","debounce","makeObservable","reaction","computed","Point","Container","observer","notification","rootStore","ShapeFactory","ShapeType","hitTesting","i18n","AnnotationType","ReviewResult","Tier","_class","Component","constructor","props","container","hoveredShape","selectedTier","viewContainer","tierContainerMap","addBarMap","addContainer","reactionDisposer","selectedShape","sameStartShapes","shapeMap","resizeDebounced","handleMouseDown","uid","_this$hoveredShape","review","isSelectInstanceEnable","error","message","translate","id","analyse","setSelectedTime","start","category","getInstanceById","setSelectedInstance","instance","selectTier","isEnabled","drawMode","handleChangeReview","handleMouseMove","event","currentPoint","mapScreenToStagePosition","clientX","clientY","localPoint","mapStageToLocalPosition","intersection","app","stage","children","setHoveredShape","shape","resizeTier","atlasWidth","tierHeight","placement","renderer","resize","render","backgroundColor","removeChildren","addChild","sortableChildren","initContainer","redrawShapes","className","ctx","_this$selectedTier","ontology","selectCategory","selected","updateShapes","instances","handleAddShape","selectedTime","addInstance","positionListener","handleMoveShape","shapes","updatedInstances","forEach","end","setUpdatedInstances","ids","Object","keys","length","categoryIndex","text","updateShape","createShape","removeShape","getCanAddTiers","startTime","endTime","normalize","shapeType","SEGMENT","destroy","initReviews","reviewsResult","customWarnings","key","warning","find","instanceId","result","REJECT","drawReview","reviewResult","undefined","index","getCategory","_rootStore$review$upd","type","getShape","updatedReviews","selectShape","moveShape","getPrevShape","getSameAndAdjoinTimeShapes","selectedInstanceId","setSelectedShape","prevInstance","nextInstance","getAdjoinInstances","adjoinShapes","prev","next","time","sameTimeShapes","filter","adjoinTimeShapes","map","createRef","interactive","values","componentDidMount","current","appendChild","view","resizeShapes","canAddTiers","initAddBar","region","selectedRegion","displayBuffer","componentDidUpdate","prevProps","JSON","stringify","selectedInstance","_this$props$selectedI","componentWillUnmount","x","y","point","plugins","interaction","mapPositionToPoint","hovered","categories","height","i","TIER_CONTAINER","width","onSelected","zIndex","duration","tiers","entries","precent","visibleStartTime","colWidth","add","ADD_BAR","onAdd","enableCategories","startX","Math","abs","setCanAddTiers","categoryDisabled","frist","second","firstX","secondX","first","firstDisabled","secondDisabled","drawSameStartShape","s","selectedStart","_this$selectedShape","push","toLocal","isPointInStage","getStagePosition","getStageSize","margin","createElement","style","padding","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref","onMouseMove","onContextMenu","e","preventDefault","_applyDecoratedDescriptor","prototype","getOwnPropertyDescriptor"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/components/TierPannel/index.tsx"],"sourcesContent":["import React from 'react';\nimport { cloneDeep, debounce, DebouncedFunc } from 'lodash';\nimport { makeObservable, IReactionDisposer, reaction, computed } from 'mobx';\nimport { Application, Point, Container } from 'pixi.js';\nimport { observer } from 'mobx-react';\nimport { notification } from 'antd';\nimport TierContainer from '../../common/shapes/TierContainer';\nimport AddBar from '../../common/controls/AddBar';\nimport Shape from '../../common/shapes/Shape';\nimport rootStore from '../../store/RootStore';\nimport ShapeFactory, { ShapeType } from '../../common/shapes/ShapeFactory';\nimport { hitTesting } from '../../utils';\nimport i18n from '../../locales';\nimport { Instance, AnnotationType, Review, ReviewResult } from '../../types';\nimport './index.scss';\n\ninterface TierProps {\n  app: Application;\n  interactive: boolean;\n  selectedInstance: Instance | null;\n}\nexport class Tier extends React.Component<TierProps> {\n  /**\n   * application dom container\n   */\n  container: React.RefObject<HTMLDivElement>;\n\n  hoveredShape?: Shape<unknown>;\n\n  /**\n   * selected Tier\n   */\n  selectedTier: TierContainer | null = null;\n\n  /**\n  * view container\n  */\n  viewContainer = new Container();\n\n  /**\n  * tier container map\n  */\n  tierContainerMap: { [category: string]: TierContainer } = {};\n\n  /**\n  * add bar map\n  */\n  addBarMap: { [category: string]: AddBar } = {};\n\n  /**\n  * add bar container\n  */\n  addContainer = new Container();\n\n  /**\n  * reaction disposer\n  */\n  reactionDisposer?: IReactionDisposer;\n\n  /**\n  * selected Shape\n  */\n  selectedShape: Shape<unknown> | null = null;\n\n  /**\n   * same start time shape\n   */\n  sameStartShapes: Shape<unknown>[] = [];\n\n  /**\n  * shape map\n  */\n  shapeMap: {[id: string]: Shape<unknown>} = {};\n\n  resizeDebounced?: DebouncedFunc<any>;\n\n  constructor(props: TierProps) {\n    super(props);\n    this.container = React.createRef();\n\n    // set interactive\n    this.props.app.stage.interactive = this.props.interactive !== false;\n\n    makeObservable(this, {});\n  }\n\n  @computed get shapes() {\n    return Object.values(this.shapeMap);\n  }\n\n  async componentDidMount() {\n    if (this.container.current) {\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n      this.props.app.stage.sortableChildren = true;\n\n      this.reactionDisposer = reaction(\n        () => this.selectedTime,\n        () => {\n          this.getCanAddTiers();\n        },\n      );\n\n      reaction(\n        () => this.resizeShapes,\n        () => {\n          if (!this.resizeDebounced) {\n            this.resizeDebounced = debounce(this.resizeTier, 100);\n          }\n          this.resizeDebounced();\n        },\n      );\n\n      reaction(\n        () => rootStore.ontology.canAddTiers,\n        () => {\n          this.initAddBar();\n        },\n      );\n\n      reaction(\n        () => rootStore.instance.updatedInstances,\n        () => {\n          this.updateShapes(rootStore.instance.updatedInstances);\n        }\n      );\n\n      reaction(\n        () => rootStore.review.updatedReviews,\n        () => {\n          this.initReviews();\n        }\n      );\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  @computed get selectedTime() {\n    return {\n      time: rootStore.analyse.selectedTime,\n      region: rootStore.analyse.selectedRegion,\n      drawMode: rootStore.review.drawMode,\n    };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  @computed get resizeShapes() {\n    return {\n      placement: rootStore.analyse.placement,\n      displayBuffer: rootStore.analyse.displayBuffer,\n    };\n  }\n\n  componentDidUpdate(prevProps: TierProps) {\n    if (JSON.stringify(prevProps.selectedInstance) !== JSON.stringify(this.props.selectedInstance)) {\n      this.setSelectedShape(this.props.selectedInstance?.id);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.reactionDisposer) {\n      this.reactionDisposer();\n    }\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x: number, y: number) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * canvas dom mouse down\n   * @param event\n   */\n  handleMouseDown = (uid: string) => {\n    if (!rootStore.review.isSelectInstanceEnable) {\n      notification.error({ message: i18n.translate('QC_REASON_LABEL') });\n      return;\n    }\n    const hoveredShape = uid === this.hoveredShape?.id ? this.hoveredShape : this.shapeMap[uid];\n    if (hoveredShape) {\n      rootStore.analyse.setSelectedTime(hoveredShape.start);\n      const { id, category } = hoveredShape;\n      const { getInstanceById, setSelectedInstance } = rootStore.instance;\n      setSelectedInstance(getInstanceById(id));\n      this.selectTier(category, this.tierContainerMap[category]);\n      const { isEnabled, drawMode, handleChangeReview } = rootStore.review;\n      if (isEnabled && !drawMode) {\n        handleChangeReview(id);\n      }\n    }\n  };\n\n  /**\n   * canvas dom mouse move\n   * @param event\n   */\n  handleMouseMove = (event: React.MouseEvent) => {\n    const currentPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n\n    const localPoint = this.mapStageToLocalPosition(currentPoint);\n    const intersection = hitTesting(currentPoint, localPoint, this.props.app.stage.children);\n    this.setHoveredShape(intersection?.shape as unknown as Shape<unknown>);\n  };\n\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape?: Shape<unknown>) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n\n  /**\n   * resize\n   */\n  resizeTier = () => {\n    const { atlasWidth, tierHeight } = rootStore.analyse.placement;\n    this.props.app.renderer.resize(atlasWidth, tierHeight);\n    this.props.app.render();\n    this.props.app.renderer.backgroundColor = 0xf1f5f8;\n    this.props.app.stage.removeChildren();\n    this.props.app.stage.addChild(this.viewContainer);\n    this.viewContainer.sortableChildren = true;\n\n    this.initContainer();\n    this.redrawShapes();\n  };\n\n  initContainer() {\n    this.tierContainerMap = {};\n    const { categories } = rootStore.ontology;\n    const { tierHeight, atlasWidth } = rootStore.analyse.placement;\n    const height = tierHeight / categories.length;\n    categories.forEach((category, i) => {\n      const container = ShapeFactory.getShape(ShapeType.TIER_CONTAINER, {\n        id: `tier_${category.className}`,\n        index: i,\n        width: atlasWidth,\n        container: this.viewContainer,\n        height,\n        category: category.className,\n        app: this.props.app,\n        selected: i === 0,\n        onSelected: this.selectTier\n      }) as TierContainer;\n      this.tierContainerMap[category.className] = container;\n      if (i === 0) {\n        this.selectedTier = container;\n      }\n    });\n    this.addContainer.zIndex = 999;\n    this.props.app.stage.addChild(this.addContainer);\n  }\n\n  selectTier = (className: string, ctx: TierContainer) => {\n    if (`tier_${this.selectedTier?.id}` !== ctx.id) {\n      rootStore.ontology.selectCategory(className);\n      if (this.selectedTier) {\n        this.selectedTier.selected = false;\n      }\n      this.selectedTier = ctx;\n      this.selectedTier.selected = true;\n    }\n  };\n\n  initAddBar() {\n    const { selectedTime, displayBuffer, placement } = rootStore.analyse;\n    const { canAddTiers, categories } = rootStore.ontology;\n    const { atlasWidth, tierHeight, duration } = placement;\n    const tiers = Object.entries(canAddTiers);\n    this.addContainer.removeChildren();\n    if (selectedTime && tiers.length > 0) {\n      const { start, precent } = displayBuffer;\n      const visibleStartTime = start * duration;\n      const colWidth = atlasWidth / (precent * duration);\n      const x = (selectedTime - visibleStartTime) * colWidth;\n\n      const height = tierHeight / categories.length;\n      tiers.forEach(([className, { index }]) => {\n        const add = ShapeFactory.getShape(ShapeType.ADD_BAR, {\n          x,\n          index,\n          height,\n          category: className,\n          container: this.addContainer,\n          app: this.props.app,\n          onAdd: this.handleAddShape\n        }) as AddBar;\n        this.addBarMap[className] = add;\n      });\n    }\n  }\n\n  redrawShapes = () => {\n    this.updateShapes(rootStore.instance.instances);\n  };\n\n  handleAddShape = (className: string) => {\n    const { selectedTime } = rootStore.analyse;\n    if (selectedTime) {\n      if (this.selectedTier && this.selectedTier.category !== className) {\n        this.selectedTier.selected = false;\n      }\n      this.selectedTier = this.tierContainerMap[className];\n      this.selectedTier.selected = true;\n      rootStore.instance.addInstance(className, selectedTime);\n    }\n  };\n\n  positionListener = (start: number) => {\n    rootStore.analyse.setSelectedTime(start);\n  };\n\n  handleMoveShape = (shapes: { id: string; start: number; end?: number; }[]) => {\n    const updatedInstances:{[id: string]: Instance} = {};\n    shapes.forEach(({ id, start, end }) => {\n      const instance = rootStore.instance.getInstanceById(id);\n      if (instance && (instance.start !== start || instance.end !== end)) {\n        updatedInstances[id] = {\n          ...instance,\n          start,\n          end\n        };\n      }\n    });\n    rootStore.instance.setUpdatedInstances(updatedInstances);\n  };\n\n  getCanAddTiers() {\n    if (!rootStore.review.drawMode) {\n      this.addContainer.removeChildren();\n      return;\n    }\n    const { selectedTime, displayBuffer, placement, selectedRegion } = rootStore.analyse;\n    const { start, precent } = displayBuffer;\n    const { atlasWidth, duration } = placement;\n    const visibleStartTime = start * duration;\n    const colWidth = atlasWidth / (precent * duration);\n    const enableCategories = cloneDeep(rootStore.ontology.enableCategories);\n    if (selectedTime) {\n      const x = (selectedTime - visibleStartTime) * colWidth;\n      Object.values(this.shapeMap).forEach(({ startX, category }) => {\n        if (Math.abs(x - startX) < 10) {\n          delete enableCategories[category];\n        }\n      });\n      rootStore.ontology.setCanAddTiers(enableCategories);\n    } else if (selectedRegion) {\n      const categoryDisabled: {[key:string]: boolean} = {};\n      const { start: frist, end: second } = selectedRegion;\n      const firstX = (frist - visibleStartTime) * colWidth;\n      const secondX = (second - visibleStartTime) * colWidth;\n      Object.values(this.shapeMap).forEach(({ startX, category }) => {\n        if (!categoryDisabled[category]) {\n          if (startX > firstX && startX < secondX) {\n            enableCategories[category].first = false;\n            enableCategories[category].second = false;\n            categoryDisabled[category] = true;\n          } else if (\n            Math.abs(firstX - startX) < 10 ||\n            Math.abs(secondX - startX) < 10\n          ) {\n            const firstDisabled = Math.abs(firstX - startX) < 10;\n            const secondDisabled = Math.abs(secondX - startX) < 10;\n            if (firstDisabled && secondDisabled) {\n              delete enableCategories[category];\n            } else if (firstDisabled) {\n              enableCategories[category].first = false;\n            } else if (secondDisabled) {\n              enableCategories[category].second = false;\n            }\n          }\n        }\n      });\n      rootStore.ontology.setCanAddTiers(enableCategories);\n    } else {\n      rootStore.ontology.setCanAddTiers({});\n    }\n  }\n\n  /**\n   * update shapes\n   */\n  updateShapes = (updatedInstances: {[id:string]: Instance | null}) => {\n    const { atlasWidth } = rootStore.analyse.placement;\n    if (atlasWidth > 0) {\n      const ids = Object.keys(updatedInstances);\n      if (ids.length > 0) {\n        Object.keys(updatedInstances).forEach((id) => {\n          const instance = updatedInstances[id];\n          if (instance) {\n            const { start, end, category, categoryIndex, text } = instance;\n            if (this.shapeMap[id]) {\n              this.updateShape(id, start, end, text);\n            } else {\n              this.createShape(id, category, categoryIndex, start, text, end);\n            }\n          } else {\n            this.removeShape(id);\n          }\n        });\n        rootStore.instance.setUpdatedInstances({});\n        if (rootStore.review.drawMode) {\n          this.getCanAddTiers();\n        }\n      }\n    }\n  };\n\n  /**\n   * update shape\n   * @param id\n   * @param startTime\n   * @param endTime\n   */\n  updateShape = (id: string, startTime: number, endTime?: number, text?: string) => {\n    const shape = this.shapeMap[id];\n    if (shape) {\n      if (shape.end === endTime && shape.start === startTime) {\n        if (text !== shape.text) {\n          shape.text = text;\n        } else {\n          shape.normalize();\n        }\n      } else {\n        shape.start = startTime;\n        if (endTime && shape.shapeType === AnnotationType.SEGMENT) {\n          shape.end = endTime;\n        }\n      }\n    }\n  };\n\n  /**\n   * remove shape\n   * @param id\n   */\n  removeShape = (id: string) => {\n    const shape = this.shapeMap[id];\n    if (shape) {\n      shape.destroy();\n      delete this.shapeMap[id];\n    }\n  };\n\n  initReviews = () => {\n    const { reviewsResult, customWarnings } = rootStore.review;\n    const keys = Object.keys(rootStore.instance.instances);\n    keys.forEach((key) => {\n      let review: Review | undefined;\n      const warning = customWarnings.find(({ id }) => id === key);\n      if (warning) {\n        review = {\n          instanceId: warning.id,\n          result: ReviewResult.REJECT\n        };\n      } else {\n        review = reviewsResult.find(({ instanceId }) => instanceId === key);\n      }\n      this.drawReview(key, review);\n    });\n  };\n\n  drawReview = (id: string, review?: Review) => {\n    if (id && this.shapeMap[id]) {\n      this.shapeMap[id].reviewResult = review ? review.result : undefined;\n    }\n  };\n\n  /**\n   * set selected shape\n   * @param shape\n   */\n  setSelectedShape(id?: string) {\n    if (this.selectedShape) {\n      this.selectedShape.selected = false;\n    }\n    const shape = this.shapeMap[id || ''];\n    if (shape) {\n      this.selectedShape = shape;\n      this.selectedShape.selected = true;\n    }\n    this.drawSameStartShape(shape?.start);\n  }\n\n  /**\n   * redraw shape control\n   * @param start start time\n   */\n  drawSameStartShape(start?: number) {\n    if (this.sameStartShapes.length > 0) {\n      this.sameStartShapes.forEach((s) => {\n        s.selectedStart = false;\n      });\n    }\n    if (start !== undefined) {\n      const sameStartShapes: Shape<unknown>[] = [];\n      this.shapes.forEach((s) => {\n        if (s.start === start && s.id !== this.selectedShape?.id) {\n          s.selectedStart = true;\n          sameStartShapes.push(s);\n        }\n      });\n      this.sameStartShapes = sameStartShapes;\n    }\n  }\n\n  /**\n   * create shape\n   * @param id\n   * @param className tier category\n   * @param index tier number\n   * @param startTime start time\n   * @param endTime end time\n   */\n  createShape = (id: string, className: string, index: number, startTime: number, text?: string, endTime?: number) => {\n    const category = rootStore.ontology.getCategory(className);\n    if (startTime !== undefined && category !== undefined) {\n      const shapeType = category.type;\n      const shape = ShapeFactory.getShape(shapeType as unknown as ShapeType, {\n        id,\n        app: this.props.app,\n        start: startTime,\n        end: endTime!,\n        text,\n        container: this.viewContainer,\n        shapeType,\n        category: className,\n        categoryIndex: index,\n        reviewResult: rootStore.review.updatedReviews[id]?.result,\n        selectShape: this.handleMouseDown,\n        moveShape: this.handleMoveShape,\n        positionListener: this.positionListener,\n        getPrevShape: this.getPrevShape,\n        getSameAndAdjoinTimeShapes: this.getSameAndAdjoinTimeShapes,\n      }) as Shape<unknown>;\n      this.shapeMap[shape.id] = shape;\n      if (rootStore.instance.selectedInstanceId === id) {\n        this.setSelectedShape(id);\n        this.selectTier(className, this.tierContainerMap[className]);\n      }\n    }\n  };\n\n  getPrevShape = (category: string, start: number) => {\n    const { prevInstance, nextInstance } = rootStore.instance.getAdjoinInstances(category, start);\n    const adjoinShapes: { prev: Shape<unknown> | undefined; next: Shape<unknown> | undefined; } = {\n      prev: undefined,\n      next: undefined,\n    };\n    if (prevInstance) {\n      adjoinShapes.prev = this.shapeMap[prevInstance.id];\n    }\n    if (nextInstance) {\n      adjoinShapes.next = this.shapeMap[nextInstance.id];\n    }\n    return adjoinShapes;\n  };\n\n  getSameAndAdjoinTimeShapes = (time: number) => {\n    const sameTimeShapes = this.shapes.filter((shape) => shape.start === time);\n    const adjoinTimeShapes = sameTimeShapes\n      .map(({ category, start }) => this.getPrevShape(category, start));\n    return {\n      sameTimeShapes,\n      adjoinTimeShapes,\n    };\n  };\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point: Point) {\n    return this.props.app.stage.toLocal(point);\n  }\n\n  /**\n   * check if the point is in the stage\n   * @param point\n   */\n  isPointInStage(point: Point) {\n    const { x, y } = this.getStagePosition();\n    const { width, height } = this.getStageSize();\n    return point.x >= x && point.x <= x + width && point.y >= y && point.y <= y + height;\n  }\n\n  /**\n   * get stage size\n   */\n  getStageSize() {\n    return {\n      width: this.props.app.stage.width,\n      height: this.props.app.stage.height,\n    };\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.props.app.stage.x,\n      y: this.props.app.stage.y,\n    };\n  }\n\n  render() {\n    const { margin, tierHeight } = rootStore.analyse.placement;\n    return (\n      <div className=\"praat-tier-container\" style={{ height: tierHeight, padding: `0 ${margin}px` }}>\n        <div\n          className=\"canvas-container\"\n          ref={this.container}\n          style={{ width: '100%', height: '100%' }}\n          onMouseMove={this.handleMouseMove}\n          onContextMenu={(e) => e.preventDefault()}\n        />\n      </div>\n    );\n  }\n}\n\nexport default observer(Tier);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}