{"ast":null,"code":"import { makeAutoObservable, toJS } from 'mobx';\nimport { DEFAULT_CATEGORY_ITEM } from '../constants';\nimport { getShapeTypeByTool, parseCategoryHotkey, parseLabelConfig, parseModelConfig, parseToolConfig, parseToolStyles } from '../utils';\nimport { Tool, CVModel, PolygonCreateMethod, LineCreateMethod, RectangleCreateMethod } from '../types';\nimport { ShapeType } from '../../common/shapes/types';\nimport Cursor from '../../common/Cursor';\nimport runner, { OnnxModel } from '../../../model/runner';\n\n/**\n * store for ontology\n * @class\n */\nexport default class OntologyStore {\n  /**\n   * selected category\n   * @getter\n   */\n  get selectedCategory() {\n    const currentCategory = this.getCategory(this.selectedCategoryName);\n    return currentCategory || this.categories[0];\n  }\n\n  /**\n   * selected category item\n   * @getter\n   */\n  get selectedCategoryItem() {\n    const {\n      children\n    } = this.selectedCategory;\n    const index = children.findIndex(c => c.name === this.selectedCategoryItemName);\n    return index >= 0 ? children[index] : children[0];\n  }\n\n  /**\n   * current tool\n   * @getter\n   */\n  get currentTool() {\n    if (this.currentToolItem) {\n      return this.currentToolItem.type;\n    }\n    return Tool.RECTANGLE;\n  }\n\n  /**\n   * current shapeType by currentTool\n   * @getter\n   */\n  get currentShapeType() {\n    return getShapeTypeByTool(this.currentTool) || ShapeType.RECTANGLE;\n  }\n\n  /**\n   * current tool supported create methods\n   */\n  get currentToolOptions() {\n    if (!this.currentToolItem) {\n      return [];\n    }\n    const {\n      type,\n      methods = [],\n      models = []\n    } = this.currentToolItem;\n    const isPolygon = type === Tool.POLYGON || type === Tool.OCR_POLYGON || type === Tool.FORMULA_POLYGON;\n    const isLine = type === Tool.LINE || type === Tool.ARROW;\n    const isRect = type === Tool.RECTANGLE;\n    if (!isPolygon && !isLine && !isRect) {\n      return [];\n    }\n    const toolsOptions = [];\n    // polygon\n    if (isPolygon && (methods.length === 0 || methods.indexOf(PolygonCreateMethod.DEFAULT) >= 0)) {\n      toolsOptions.push(PolygonCreateMethod.DEFAULT);\n    }\n    if (isPolygon && methods.indexOf(PolygonCreateMethod.RECT) >= 0) {\n      toolsOptions.push(PolygonCreateMethod.RECT);\n    }\n    if (isPolygon && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n      toolsOptions.push(CVModel.SEGMENTATION);\n    }\n    // line\n    if (isLine && (methods.length === 0 || methods.indexOf(LineCreateMethod.DEFAULT) >= 0)) {\n      toolsOptions.push(LineCreateMethod.DEFAULT);\n    }\n    if (isLine && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n      toolsOptions.push(CVModel.SEGMENTATION);\n    }\n    // rectangle\n    if (isRect && (methods.length === 0 || methods.indexOf(RectangleCreateMethod.DEFAULT) >= 0)) {\n      toolsOptions.push(RectangleCreateMethod.DEFAULT);\n    }\n    if (isRect && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.OBJECT_DETECTION) >= 0)) {\n      toolsOptions.push(CVModel.OBJECT_DETECTION);\n    }\n    if (isRect && models.indexOf(CVModel.OBJECT_DETECTION_MULTI) >= 0) {\n      toolsOptions.push(CVModel.OBJECT_DETECTION_MULTI);\n    }\n    if (toolsOptions.length < 2) {\n      return [];\n    }\n    return toolsOptions;\n  }\n\n  /**\n   * current create method\n   * @getter\n   */\n  get currentCreateMethod() {\n    var _this$toolCreateMetho;\n    const savedCreateMethod = (_this$toolCreateMetho = this.toolCreateMethods[this.selectedCategoryName]) === null || _this$toolCreateMetho === void 0 ? void 0 : _this$toolCreateMetho[this.selectedCategoryItemName];\n    if (savedCreateMethod) {\n      return savedCreateMethod;\n    }\n    if (this.currentToolItem) {\n      const {\n        type,\n        methods = [],\n        models = []\n      } = this.currentToolItem;\n      // rectangle\n      if (type === Tool.RECTANGLE && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.OBJECT_DETECTION) >= 0)) {\n        return CVModel.OBJECT_DETECTION;\n      }\n      if (type === Tool.RECTANGLE && models.indexOf(CVModel.OBJECT_DETECTION_MULTI) >= 0) {\n        return CVModel.OBJECT_DETECTION_MULTI;\n      }\n      // polygon\n      if (type === Tool.POLYGON && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n        return CVModel.SEGMENTATION;\n      }\n      if (methods.indexOf(PolygonCreateMethod.RECT) >= 0) {\n        return PolygonCreateMethod.RECT;\n      }\n      // line\n      if ((type === Tool.LINE || type === Tool.ARROW) && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n        return CVModel.SEGMENTATION;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * is curret tool is ocr tool\n   * @getter\n   */\n  get isOCRTool() {\n    return this.currentTool === Tool.OCR || this.currentTool === Tool.OCR_POLYGON;\n  }\n\n  /**\n   * is curret tool is formula tool\n   * @getter\n   */\n  get isFormulaTool() {\n    return this.currentTool === Tool.FORMULA_POLYGON;\n  }\n\n  /**\n   * is any point label config in category items\n   * @getter\n   */\n  get pointLabelConfigEnabled() {\n    return this.categories.some(({\n      children\n    }) => children.some(c => !!c.pointLabelConfig));\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * categories\n     */\n    this.categories = [];\n    /**\n     * selected category name\n     */\n    this.selectedCategoryName = '';\n    /**\n     * selected category item name\n     */\n    this.selectedCategoryItemName = '';\n    /**\n     * selected tool item\n     */\n    this.currentToolItem = null;\n    /**\n     * tool create methods\n     */\n    this.toolCreateMethods = {};\n    /**\n     * current tool options (used for shape creation)\n     */\n    this.currentOptions = {\n      cols: 5,\n      // grid tool default cols\n      rows: 5 // grid tool default rows\n    };\n    /**\n     * styles cache\n     */\n    this.toolStylesCache = {};\n    /**\n     * set create method\n     * @param method\n     */\n    this.setCreateMethod = method => {\n      // if currentCreateMethod is same with new method return\n      const currentCreateMethod = this.currentCreateMethod;\n      if (currentCreateMethod === method) return;\n      if (!this.toolCreateMethods[this.selectedCategoryName]) {\n        this.toolCreateMethods[this.selectedCategoryName] = {};\n      }\n      this.toolCreateMethods[this.selectedCategoryName][this.selectedCategoryItemName] = method;\n\n      // reset cursor\n      this.rootStore.config.setCursor(Cursor.CROSSHAIR);\n      // destroy drawing shape if exits\n      if (this.rootStore.shape.drawingShape) {\n        this.rootStore.shape.drawingShape.destroy();\n        this.rootStore.shape.drawingShape = null;\n      }\n    };\n    /**\n     * toggle create method by keyboard\n     */\n    this.toggleCreateMethodByKeyboard = () => {\n      if (!this.currentToolItem) {\n        return;\n      }\n      if (this.currentToolItem.type === Tool.PIXEL) {\n        this.rootStore.segmentation.switchMethod();\n        return;\n      }\n      const toolsOptions = this.currentToolOptions;\n      if (toolsOptions.length <= 0) {\n        return;\n      }\n      if (this.currentCreateMethod) {\n        const currentIndex = toolsOptions.findIndex(item => item === this.currentCreateMethod);\n        const nextIndex = (currentIndex + 1) % toolsOptions.length;\n        this.setCreateMethod(toolsOptions[nextIndex]);\n      } else {\n        this.setCreateMethod(toolsOptions[0]);\n      }\n    };\n    makeAutoObservable(this, {\n      rootStore: false,\n      currentOptions: false,\n      toolStylesCache: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload) {\n    var _this$categories$, _this$categories$2, _this$categories$2$ch, _this$categories$3, _this$categories$3$ch;\n    const categories = [];\n    const {\n      ontology = [],\n      tools: legacyTools,\n      label_config: legacyLabelConfig\n    } = payload;\n    ontology.forEach(o => {\n      const items = [];\n      if (!o.children || o.children.length === 0) {\n        // legacy data, add default item\n        items.push({\n          name: DEFAULT_CATEGORY_ITEM,\n          displayName: DEFAULT_CATEGORY_ITEM,\n          displayColor: o.display_color || '',\n          tools: (legacyTools || Object.values(Tool)).map(t => ({\n            type: t\n          })),\n          count: 1,\n          labelConfig: parseLabelConfig(legacyLabelConfig)\n        });\n      } else {\n        o.children.forEach(child => {\n          const {\n            name,\n            display_name,\n            display_color,\n            count,\n            min_count,\n            max_count,\n            label_config,\n            label_config_point,\n            label_config_groups,\n            label_config_point_groups,\n            type = '',\n            edges,\n            tools\n          } = child;\n\n          // parse tools\n          let allTools = [];\n          if (tools) {\n            tools.forEach(item => {\n              const tool = {\n                type: item.type || Tool.RECTANGLE\n              };\n              if ((item.snapshot === true || item.snapshot === 'true') && (tool.type === Tool.POLYGON || tool.type === Tool.RECTANGLE)) {\n                tool.snapshot = true;\n              }\n              if (item.bbox === true || item.bbox === 'true') {\n                tool.bbox = true;\n              }\n              if (item.edges !== undefined && item.edges !== null) {\n                tool.edges = Number(item.edges);\n              }\n              if (item.models !== undefined) {\n                if (typeof item.models === 'boolean' && item.models) {\n                  // use default model\n                  tool.models = [CVModel.DEFAULT];\n                } else {\n                  const models = new Set();\n                  const allModels = Object.values(CVModel);\n                  (Array.isArray(item.models) ? item.models : [item.models]).forEach(m => {\n                    if (allModels.indexOf(m) >= 0) {\n                      models.add(m);\n                    }\n                  });\n                  if (models.size > 0) {\n                    tool.models = Array.from(models);\n                  }\n                }\n              }\n              if (item.methods !== undefined) {\n                const methods = new Set();\n                const allMethodsForPolygon = Object.values(PolygonCreateMethod);\n                const allMethodsForLine = Object.values(LineCreateMethod);\n                const allMethodsForRect = Object.values(RectangleCreateMethod);\n                (Array.isArray(item.methods) ? item.methods : [item.methods]).forEach(m => {\n                  if (allMethodsForPolygon.indexOf(m) >= 0 || allMethodsForLine.indexOf(m) >= 0 || allMethodsForRect.indexOf(m) >= 0) {\n                    methods.add(m);\n                  }\n                });\n                if (methods.size > 0) {\n                  tool.methods = Array.from(methods);\n                }\n              }\n              allTools.push({\n                ...tool,\n                ...parseToolStyles(item),\n                ...parseToolConfig(tool.type, item.config),\n                ...parseModelConfig(item.modelConfig)\n              });\n            });\n          } else {\n            // legacy config\n            let legacyEdges;\n            if (edges !== undefined && edges !== null) {\n              legacyEdges = Number(edges);\n            }\n            allTools = type.split(',').map(i => ({\n              type: i || Tool.RECTANGLE,\n              edges: legacyEdges\n            }));\n          }\n          const item = {\n            name,\n            displayName: display_name || name,\n            displayColor: display_color || o.display_color || '',\n            tools: allTools\n          };\n          if (count !== undefined && count !== null) {\n            item.count = Number(count);\n          }\n          if (min_count !== undefined && min_count !== null) {\n            item.minCount = Number(min_count);\n          }\n          if (max_count !== undefined && max_count !== null) {\n            item.maxCount = Number(max_count);\n          }\n          if (label_config) {\n            item.labelConfig = parseLabelConfig(label_config);\n          }\n          if (label_config_point) {\n            item.pointLabelConfig = parseLabelConfig(label_config_point);\n          }\n          if (Array.isArray(label_config_groups)) {\n            item.labelConfigGroups = label_config_groups.map(({\n              attributes,\n              ...styles\n            }) => ({\n              attributes,\n              ...parseToolStyles(styles)\n            }));\n          }\n          if (Array.isArray(label_config_point_groups)) {\n            item.pointLabelConfigGroups = label_config_point_groups.map(({\n              attributes,\n              ...styles\n            }) => ({\n              attributes,\n              ...parseToolStyles(styles)\n            }));\n          }\n          items.push(item);\n        });\n      }\n      let categoryColor = '';\n      if (items.length === 1 && items[0].count === 1) {\n        categoryColor = items[0].displayColor;\n      }\n      categories.push({\n        description: o.description,\n        className: o.class_name,\n        displayName: o.display_name || o.class_name,\n        displayColor: categoryColor,\n        children: items,\n        labelConfig: parseLabelConfig(o.label_config),\n        labelConfigDynamic: parseLabelConfig(o.label_config_dynamic),\n        shortcut: parseCategoryHotkey(o.shortcut)\n      });\n    });\n    this.categories = categories;\n    this.selectedCategoryName = (_this$categories$ = this.categories[0]) === null || _this$categories$ === void 0 ? void 0 : _this$categories$.className;\n    this.selectedCategoryItemName = (_this$categories$2 = this.categories[0]) === null || _this$categories$2 === void 0 ? void 0 : (_this$categories$2$ch = _this$categories$2.children[0]) === null || _this$categories$2$ch === void 0 ? void 0 : _this$categories$2$ch.name;\n    this.currentToolItem = (_this$categories$3 = this.categories[0]) === null || _this$categories$3 === void 0 ? void 0 : (_this$categories$3$ch = _this$categories$3.children[0]) === null || _this$categories$3$ch === void 0 ? void 0 : _this$categories$3$ch.tools[0];\n    this.loadModels();\n  }\n\n  /**\n   * load models by categories configuration\n   */\n  loadModels() {\n    let segModel = false;\n    let odModel = false;\n    const modelLoaded = this.categories.some(category => category.children.some(child => child.tools.some(tool => {\n      var _tool$models, _tool$models2, _tool$models3, _tool$models4, _tool$models5;\n      if (tool.type === Tool.PIXEL || tool.type === Tool.RECOGNITION || ((_tool$models = tool.models) === null || _tool$models === void 0 ? void 0 : _tool$models.includes(CVModel.SEGMENTATION)) || (tool.type === Tool.POLYGON || tool.type === Tool.LINE || tool.type === Tool.ARROW) && ((_tool$models2 = tool.models) === null || _tool$models2 === void 0 ? void 0 : _tool$models2.includes(CVModel.DEFAULT))) {\n        segModel = true;\n        runner.loadModel(OnnxModel.CV_RITM_SEGMENTATION);\n        runner.loadModel(OnnxModel.CV_SAM_SEGMENTATION);\n      }\n      if (tool.type === Tool.RECTANGLE && (((_tool$models3 = tool.models) === null || _tool$models3 === void 0 ? void 0 : _tool$models3.includes(CVModel.DEFAULT)) || ((_tool$models4 = tool.models) === null || _tool$models4 === void 0 ? void 0 : _tool$models4.includes(CVModel.OBJECT_DETECTION)) || ((_tool$models5 = tool.models) === null || _tool$models5 === void 0 ? void 0 : _tool$models5.includes(CVModel.OBJECT_DETECTION_MULTI)))) {\n        odModel = true;\n        runner.loadModel(OnnxModel.CV_YOLOGV5S);\n      }\n      return segModel && odModel;\n    })));\n    if (!modelLoaded) {\n      // should setup recognizer\n      this.rootStore.shape.setupRecognizer();\n    }\n  }\n\n  /**\n   * get category object\n   * @param categoryName\n   */\n  getCategory(categoryName) {\n    return toJS(this.categories.find(o => o.className === categoryName));\n  }\n\n  /**\n   * get category item\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getCategoryItem(categoryName, categoryItemName) {\n    const category = this.getCategory(categoryName);\n    return toJS(((category === null || category === void 0 ? void 0 : category.children) || []).find(o => o.name === categoryItemName));\n  }\n\n  /**\n   * set selected category\n   * @param categoryName\n   */\n  selectCategory(categoryName) {\n    if (this.selectedCategoryName !== categoryName) {\n      // turn off the add mode\n      this.rootStore.config.setAddMode(false);\n      // category changes\n      this.selectedCategoryName = categoryName;\n      // update selected category name\n      this.selectCategoryItem(this.selectedCategory.children[0].name); // default select the first one\n      // unselect selected instance if needed\n      if (this.rootStore.instance.selectedInstances.findIndex(i => i.category === categoryName) < 0) {\n        this.rootStore.instance.selectInstance(null);\n      }\n    }\n  }\n\n  /**\n   * select category by hotkey\n   * @param event\n   */\n  selectCategoryByHotkey(event) {\n    const categoryName = this.getCategoryNameByHotkey(event);\n    if (categoryName) {\n      this.selectCategory(categoryName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * get category name by hotkey\n   * @param event\n   */\n  getCategoryNameByHotkey(event) {\n    const key = event.key.toLocaleLowerCase();\n    for (let i = 0; i < this.categories.length; i += 1) {\n      const {\n        className,\n        shortcut\n      } = this.categories[i];\n      if ((shortcut === null || shortcut === void 0 ? void 0 : shortcut.key) === key && (shortcut === null || shortcut === void 0 ? void 0 : shortcut.shiftKey) === event.shiftKey && (shortcut === null || shortcut === void 0 ? void 0 : shortcut.ctrlKey) === event.ctrlKey && (shortcut === null || shortcut === void 0 ? void 0 : shortcut.altKey) === event.altKey) {\n        return className;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * set selected category item\n   * @param categoryItemName\n   */\n  selectCategoryItem(categoryItemName) {\n    this.selectedCategoryItemName = categoryItemName;\n    this.currentToolItem = this.selectedCategoryItem.tools[0];\n  }\n\n  /**\n   * select next category item\n   */\n  selectNextCategoryItem() {\n    const {\n      children\n    } = this.selectedCategory;\n    const index = children.findIndex(c => c.name === this.selectedCategoryItemName);\n    if (index >= 0 && children.length > 1) {\n      const nextIndex = (index + 1) % children.length;\n      const categoryItem = children[nextIndex];\n      this.selectCategoryItem(categoryItem.name);\n    }\n  }\n\n  /**\n   * select category item by index\n   * @param index\n   */\n  selectCategoryItemByIndex(index) {\n    const categoryItem = this.selectedCategory.children[index];\n    if (categoryItem) {\n      this.selectCategoryItem(categoryItem.name);\n    }\n  }\n\n  /**\n   * activate category item\n   * @param categoryItemName\n   * @param tool\n   */\n  activateCategoryItem(categoryItemName, tool) {\n    if (this.rootStore.shape.isDrawing) {\n      return;\n    }\n    this.selectCategoryItem(categoryItemName);\n    this.selectTool(tool);\n    this.rootStore.config.setAddMode(true);\n  }\n\n  /**\n   * activate category item by index\n   * @param index\n   */\n  activateCategoryItemByIndex(index) {\n    if (this.rootStore.shape.isDrawing) {\n      return;\n    }\n    const child = this.selectedCategory.children[index];\n    if (child) {\n      const tool = child.name === this.selectedCategoryItemName ? this.currentToolItem : child.tools[0];\n      this.activateCategoryItem(child.name, tool);\n    }\n  }\n\n  /**\n   * set current tool\n   * @param tool\n   */\n  selectTool(tool) {\n    if (this.currentToolItem !== tool) {\n      this.currentToolItem = tool;\n    }\n  }\n\n  /**\n   * get label config from category\n   * @param categoryName\n   */\n  getLabelConfigFromCategory(categoryName) {\n    const category = this.getCategory(categoryName);\n    return category === null || category === void 0 ? void 0 : category.labelConfig;\n  }\n\n  /**\n   * get dynamic label config from category\n   * @param categoryName\n   */\n  getDynamicLabelConfigFromCategory(categoryName) {\n    const category = this.getCategory(categoryName);\n    return category === null || category === void 0 ? void 0 : category.labelConfigDynamic;\n  }\n\n  /**\n   * get label config from category item\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getLabelConfigFromCategoryItem(categoryName, categoryItemName) {\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    return categoryItem === null || categoryItem === void 0 ? void 0 : categoryItem.labelConfig;\n  }\n\n  /**\n   * get point label config from category item\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getPointLabelConfigFromCategoryItem(categoryName, categoryItemName) {\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    return categoryItem === null || categoryItem === void 0 ? void 0 : categoryItem.pointLabelConfig;\n  }\n\n  /**\n   * get configured styles from tool\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolStylesByCategoryItem(categoryName, categoryItemName) {\n    // has cache\n    if (this.toolStylesCache[categoryName] && this.toolStylesCache[categoryName][categoryItemName]) {\n      return this.toolStylesCache[categoryName][categoryItemName];\n    }\n    if (!this.toolStylesCache[categoryName]) {\n      this.toolStylesCache[categoryName] = {};\n    }\n    this.toolStylesCache[categoryName][categoryItemName] = {\n      pointsStyles: null,\n      edgesStyles: null\n    };\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    if (categoryItem) {\n      const tool = categoryItem.tools[0]; // simply use first one because only one tool can be configured\n      if (tool) {\n        const {\n          fillColor,\n          pointColor,\n          pointType,\n          edgeColor,\n          edgeType,\n          edgeBold,\n          pointsColor,\n          pointsType,\n          edgesColor,\n          edgesType,\n          edgesBold\n        } = tool;\n        if (fillColor) {\n          this.toolStylesCache[categoryName][categoryItemName].fillColor = fillColor;\n        }\n        if (pointColor || pointType || pointsColor || pointsType) {\n          this.toolStylesCache[categoryName][categoryItemName].pointsStyles = {\n            pointColor,\n            pointType,\n            pointsColor,\n            pointsType\n          };\n        }\n        if (edgeColor || edgeType || edgeBold !== undefined || edgesColor || edgesType || edgesBold) {\n          this.toolStylesCache[categoryName][categoryItemName].edgesStyles = {\n            edgeColor,\n            edgeType,\n            edgeBold,\n            edgesColor,\n            edgesType,\n            edgesBold\n          };\n        }\n      }\n    }\n    return this.toolStylesCache[categoryName][categoryItemName];\n  }\n\n  /**\n   * get configured points styles\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolPointsStylesByCategoryItem(categoryName, categoryItemName) {\n    return this.getToolStylesByCategoryItem(categoryName, categoryItemName).pointsStyles;\n  }\n\n  /**\n   * get configured edges styles\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolEdgesStylesByCategoryItem(categoryName, categoryItemName) {\n    return this.getToolStylesByCategoryItem(categoryName, categoryItemName).edgesStyles;\n  }\n\n  /**\n   * get fill color\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolFillByCategoryItem(categoryName, categoryItemName) {\n    return this.getToolStylesByCategoryItem(categoryName, categoryItemName).fillColor;\n  }\n\n  /**\n   * get tool config (including common config)\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolConfigByCategoryItem(categoryName, categoryItemName) {\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    if (categoryItem) {\n      const tool = categoryItem.tools[0];\n      const {\n        bbox = false,\n        config\n      } = tool || {};\n      return {\n        exportShapeBounds: bbox,\n        ...config\n      };\n    }\n    return undefined;\n  }\n}","map":{"version":3,"names":["makeAutoObservable","toJS","DEFAULT_CATEGORY_ITEM","getShapeTypeByTool","parseCategoryHotkey","parseLabelConfig","parseModelConfig","parseToolConfig","parseToolStyles","Tool","CVModel","PolygonCreateMethod","LineCreateMethod","RectangleCreateMethod","ShapeType","Cursor","runner","OnnxModel","OntologyStore","selectedCategory","currentCategory","getCategory","selectedCategoryName","categories","selectedCategoryItem","children","index","findIndex","c","name","selectedCategoryItemName","currentTool","currentToolItem","type","RECTANGLE","currentShapeType","currentToolOptions","methods","models","isPolygon","POLYGON","OCR_POLYGON","FORMULA_POLYGON","isLine","LINE","ARROW","isRect","toolsOptions","length","indexOf","DEFAULT","push","RECT","SEGMENTATION","OBJECT_DETECTION","OBJECT_DETECTION_MULTI","currentCreateMethod","_this$toolCreateMetho","savedCreateMethod","toolCreateMethods","undefined","isOCRTool","OCR","isFormulaTool","pointLabelConfigEnabled","some","pointLabelConfig","constructor","rootStore","currentOptions","cols","rows","toolStylesCache","setCreateMethod","method","config","setCursor","CROSSHAIR","shape","drawingShape","destroy","toggleCreateMethodByKeyboard","PIXEL","segmentation","switchMethod","currentIndex","item","nextIndex","autoBind","init","payload","_this$categories$","_this$categories$2","_this$categories$2$ch","_this$categories$3","_this$categories$3$ch","ontology","tools","legacyTools","label_config","legacyLabelConfig","forEach","o","items","displayName","displayColor","display_color","Object","values","map","t","count","labelConfig","child","display_name","min_count","max_count","label_config_point","label_config_groups","label_config_point_groups","edges","allTools","tool","snapshot","bbox","Number","Set","allModels","Array","isArray","m","add","size","from","allMethodsForPolygon","allMethodsForLine","allMethodsForRect","modelConfig","legacyEdges","split","i","minCount","maxCount","labelConfigGroups","attributes","styles","pointLabelConfigGroups","categoryColor","description","className","class_name","labelConfigDynamic","label_config_dynamic","shortcut","loadModels","segModel","odModel","modelLoaded","category","_tool$models","_tool$models2","_tool$models3","_tool$models4","_tool$models5","RECOGNITION","includes","loadModel","CV_RITM_SEGMENTATION","CV_SAM_SEGMENTATION","CV_YOLOGV5S","setupRecognizer","categoryName","find","getCategoryItem","categoryItemName","selectCategory","setAddMode","selectCategoryItem","instance","selectedInstances","selectInstance","selectCategoryByHotkey","event","getCategoryNameByHotkey","key","toLocaleLowerCase","shiftKey","ctrlKey","altKey","selectNextCategoryItem","categoryItem","selectCategoryItemByIndex","activateCategoryItem","isDrawing","selectTool","activateCategoryItemByIndex","getLabelConfigFromCategory","getDynamicLabelConfigFromCategory","getLabelConfigFromCategoryItem","getPointLabelConfigFromCategoryItem","getToolStylesByCategoryItem","pointsStyles","edgesStyles","fillColor","pointColor","pointType","edgeColor","edgeType","edgeBold","pointsColor","pointsType","edgesColor","edgesType","edgesBold","getToolPointsStylesByCategoryItem","getToolEdgesStylesByCategoryItem","getToolFillByCategoryItem","getToolConfigByCategoryItem","exportShapeBounds"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/OntologyStore.ts"],"sourcesContent":["import { makeAutoObservable, toJS } from 'mobx';\nimport RootStore from './RootStore';\nimport { DEFAULT_CATEGORY_ITEM } from '../constants';\nimport { getShapeTypeByTool, parseCategoryHotkey, parseLabelConfig, parseModelConfig, parseToolConfig, parseToolStyles } from '../utils';\nimport { Tool, Payload, Category, CategoryItem, ToolItem, CVModel, ToolCreateMethod, PolygonCreateMethod, LineCreateMethod, RectangleCreateMethod } from '../types';\nimport { ShapeType } from '../../common/shapes/types';\nimport Cursor from '../../common/Cursor';\nimport runner, { OnnxModel } from '../../../model/runner';\n\n/**\n * store for ontology\n * @class\n */\nexport default class OntologyStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * categories\n   */\n  categories: Category[] = [];\n\n  /**\n   * selected category name\n   */\n  selectedCategoryName = '';\n\n  /**\n   * selected category item name\n   */\n  selectedCategoryItemName = '';\n\n  /**\n   * selected tool item\n   */\n  currentToolItem: ToolItem | null = null;\n\n  /**\n   * tool create methods\n   */\n  toolCreateMethods: {\n    [category: string]: {\n      [item: string]: ToolCreateMethod | CVModel;\n    }\n  } = {};\n\n  /**\n   * current tool options (used for shape creation)\n   */\n  currentOptions: {\n    cols: number;\n    rows: number;\n  } = {\n    cols: 5, // grid tool default cols\n    rows: 5, // grid tool default rows\n  };\n\n  /**\n   * styles cache\n   */\n  toolStylesCache: {\n    [categoryName: string]: {\n      [categoryItemName: string]: {\n        fillColor?: string;\n        pointsStyles: {\n          pointColor?: string;\n          pointType?: string;\n          pointsColor?: string[];\n          pointsType?: string[];\n        } | null;\n        edgesStyles: {\n          edgeColor?: string;\n          edgeType?: string;\n          edgeBold?: boolean;\n          edgesColor?: string[];\n          edgesType?: string[];\n          edgesBold?: boolean[];\n        } | null;\n      }\n    }\n  } = {};\n\n  /**\n   * selected category\n   * @getter\n   */\n  get selectedCategory() {\n    const currentCategory = this.getCategory(this.selectedCategoryName);\n    return currentCategory || this.categories[0];\n  }\n\n  /**\n   * selected category item\n   * @getter\n   */\n  get selectedCategoryItem() {\n    const { children } = this.selectedCategory;\n    const index = children.findIndex((c) => c.name === this.selectedCategoryItemName);\n    return index >= 0 ? children[index] : children[0];\n  }\n\n  /**\n   * current tool\n   * @getter\n   */\n  get currentTool() {\n    if (this.currentToolItem) {\n      return this.currentToolItem.type;\n    }\n    return Tool.RECTANGLE;\n  }\n\n  /**\n   * current shapeType by currentTool\n   * @getter\n   */\n  get currentShapeType() {\n    return getShapeTypeByTool(this.currentTool) || ShapeType.RECTANGLE;\n  }\n\n  /**\n   * current tool supported create methods\n   */\n  get currentToolOptions() {\n    if (!this.currentToolItem) {\n      return [];\n    }\n\n    const { type, methods = [], models = [] } = this.currentToolItem;\n    const isPolygon = type === Tool.POLYGON || type === Tool.OCR_POLYGON || type === Tool.FORMULA_POLYGON;\n    const isLine = type === Tool.LINE || type === Tool.ARROW;\n    const isRect = type === Tool.RECTANGLE;\n    if (!isPolygon && !isLine && !isRect) {\n      return [];\n    }\n\n    const toolsOptions = [];\n    // polygon\n    if (isPolygon && (methods.length === 0 || methods.indexOf(PolygonCreateMethod.DEFAULT) >= 0)) {\n      toolsOptions.push(PolygonCreateMethod.DEFAULT);\n    }\n    if (isPolygon && methods.indexOf(PolygonCreateMethod.RECT) >= 0) {\n      toolsOptions.push(PolygonCreateMethod.RECT);\n    }\n    if (isPolygon && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n      toolsOptions.push(CVModel.SEGMENTATION);\n    }\n    // line\n    if (isLine && (methods.length === 0 || methods.indexOf(LineCreateMethod.DEFAULT) >= 0)) {\n      toolsOptions.push(LineCreateMethod.DEFAULT);\n    }\n    if (isLine && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n      toolsOptions.push(CVModel.SEGMENTATION);\n    }\n    // rectangle\n    if (isRect && (methods.length === 0 || methods.indexOf(RectangleCreateMethod.DEFAULT) >= 0)) {\n      toolsOptions.push(RectangleCreateMethod.DEFAULT);\n    }\n    if (isRect && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.OBJECT_DETECTION) >= 0)) {\n      toolsOptions.push(CVModel.OBJECT_DETECTION);\n    }\n    if (isRect && models.indexOf(CVModel.OBJECT_DETECTION_MULTI) >= 0) {\n      toolsOptions.push(CVModel.OBJECT_DETECTION_MULTI);\n    }\n    if (toolsOptions.length < 2) {\n      return [];\n    }\n    return toolsOptions;\n  }\n\n  /**\n   * current create method\n   * @getter\n   */\n  get currentCreateMethod() {\n    const savedCreateMethod = this.toolCreateMethods[this.selectedCategoryName]?.[this.selectedCategoryItemName];\n    if (savedCreateMethod) {\n      return savedCreateMethod;\n    }\n    if (this.currentToolItem) {\n      const { type, methods = [], models = [] } = this.currentToolItem;\n      // rectangle\n      if (type === Tool.RECTANGLE && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.OBJECT_DETECTION) >= 0)) {\n        return CVModel.OBJECT_DETECTION;\n      }\n      if (type === Tool.RECTANGLE && models.indexOf(CVModel.OBJECT_DETECTION_MULTI) >= 0) {\n        return CVModel.OBJECT_DETECTION_MULTI;\n      }\n      // polygon\n      if (type === Tool.POLYGON && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n        return CVModel.SEGMENTATION;\n      }\n      if (methods.indexOf(PolygonCreateMethod.RECT) >= 0) {\n        return PolygonCreateMethod.RECT;\n      }\n      // line\n      if ((type === Tool.LINE || type === Tool.ARROW) && (models.indexOf(CVModel.DEFAULT) >= 0 || models.indexOf(CVModel.SEGMENTATION) >= 0)) {\n        return CVModel.SEGMENTATION;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * is curret tool is ocr tool\n   * @getter\n   */\n  get isOCRTool() {\n    return this.currentTool === Tool.OCR || this.currentTool === Tool.OCR_POLYGON;\n  }\n\n  /**\n   * is curret tool is formula tool\n   * @getter\n   */\n  get isFormulaTool() {\n    return this.currentTool === Tool.FORMULA_POLYGON;\n  }\n\n  /**\n   * is any point label config in category items\n   * @getter\n   */\n  get pointLabelConfigEnabled() {\n    return this.categories.some(({ children }) => children.some((c) => !!c.pointLabelConfig));\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      currentOptions: false,\n      toolStylesCache: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload: Payload) {\n    const categories: Category[] = [];\n\n    const { ontology = [], tools: legacyTools, label_config: legacyLabelConfig } = payload;\n    ontology.forEach((o) => {\n      const items: CategoryItem[] = [];\n      if (!o.children || o.children.length === 0) {\n        // legacy data, add default item\n        items.push({\n          name: DEFAULT_CATEGORY_ITEM,\n          displayName: DEFAULT_CATEGORY_ITEM,\n          displayColor: o.display_color || '',\n          tools: (legacyTools || Object.values(Tool)).map((t) => ({ type: t })),\n          count: 1,\n          labelConfig: parseLabelConfig(legacyLabelConfig),\n        });\n      } else {\n        o.children.forEach((child) => {\n          const {\n            name,\n            display_name,\n            display_color,\n            count,\n            min_count,\n            max_count,\n            label_config,\n            label_config_point,\n            label_config_groups,\n            label_config_point_groups,\n            type = '',\n            edges,\n            tools,\n          } = child;\n\n          // parse tools\n          let allTools: ToolItem[] = [];\n          if (tools) {\n            tools.forEach((item) => {\n              const tool: ToolItem = { type: item.type as Tool || Tool.RECTANGLE };\n              if ((item.snapshot === true || item.snapshot === 'true') && (tool.type === Tool.POLYGON || tool.type === Tool.RECTANGLE)) {\n                tool.snapshot = true;\n              }\n              if (item.bbox === true || item.bbox === 'true') {\n                tool.bbox = true;\n              }\n              if (item.edges !== undefined && item.edges !== null) {\n                tool.edges = Number(item.edges);\n              }\n              if (item.models !== undefined) {\n                if (typeof item.models === 'boolean' && item.models) {\n                  // use default model\n                  tool.models = [CVModel.DEFAULT];\n                } else {\n                  const models = new Set<CVModel>();\n                  const allModels = Object.values(CVModel);\n                  (Array.isArray(item.models) ? item.models : [item.models]).forEach((m) => {\n                    if (allModels.indexOf(m as CVModel) >= 0) {\n                      models.add(m as CVModel);\n                    }\n                  });\n                  if (models.size > 0) {\n                    tool.models = Array.from(models);\n                  }\n                }\n              }\n              if (item.methods !== undefined) {\n                const methods = new Set<ToolCreateMethod>();\n                const allMethodsForPolygon = Object.values(PolygonCreateMethod);\n                const allMethodsForLine = Object.values(LineCreateMethod);\n                const allMethodsForRect = Object.values(RectangleCreateMethod);\n                (Array.isArray(item.methods) ? item.methods : [item.methods]).forEach((m) => {\n                  if (\n                    allMethodsForPolygon.indexOf(m as PolygonCreateMethod) >= 0 ||\n                    allMethodsForLine.indexOf(m as LineCreateMethod) >= 0 ||\n                    allMethodsForRect.indexOf(m as RectangleCreateMethod) >= 0\n                  ) {\n                    methods.add(m as ToolCreateMethod);\n                  }\n                });\n                if (methods.size > 0) {\n                  tool.methods = Array.from(methods);\n                }\n              }\n              allTools.push({\n                ...tool,\n                ...parseToolStyles(item),\n                ...parseToolConfig(tool.type, item.config),\n                ...parseModelConfig(item.modelConfig),\n              });\n            });\n          } else {\n            // legacy config\n            let legacyEdges: number | undefined;\n            if (edges !== undefined && edges !== null) {\n              legacyEdges = Number(edges);\n            }\n            allTools = type.split(',').map((i) => ({ type: i as Tool || Tool.RECTANGLE, edges: legacyEdges }));\n          }\n          const item: CategoryItem = {\n            name,\n            displayName: display_name || name,\n            displayColor: display_color || o.display_color || '',\n            tools: allTools,\n          };\n          if (count !== undefined && count !== null) {\n            item.count = Number(count);\n          }\n          if (min_count !== undefined && min_count !== null) {\n            item.minCount = Number(min_count);\n          }\n          if (max_count !== undefined && max_count !== null) {\n            item.maxCount = Number(max_count);\n          }\n          if (label_config) {\n            item.labelConfig = parseLabelConfig(label_config);\n          }\n          if (label_config_point) {\n            item.pointLabelConfig = parseLabelConfig(label_config_point);\n          }\n          if (Array.isArray(label_config_groups)) {\n            item.labelConfigGroups = label_config_groups.map(({ attributes, ...styles }) => ({\n              attributes,\n              ...parseToolStyles(styles),\n            }));\n          }\n          if (Array.isArray(label_config_point_groups)) {\n            item.pointLabelConfigGroups = label_config_point_groups.map(({ attributes, ...styles }) => ({\n              attributes,\n              ...parseToolStyles(styles),\n            }));\n          }\n          items.push(item);\n        });\n      }\n\n      let categoryColor = '';\n      if (items.length === 1 && items[0].count === 1) {\n        categoryColor = items[0].displayColor;\n      }\n      categories.push({\n        description: o.description,\n        className: o.class_name,\n        displayName: o.display_name || o.class_name,\n        displayColor: categoryColor,\n        children: items,\n        labelConfig: parseLabelConfig(o.label_config),\n        labelConfigDynamic: parseLabelConfig(o.label_config_dynamic),\n        shortcut: parseCategoryHotkey(o.shortcut),\n      });\n    });\n    this.categories = categories;\n    this.selectedCategoryName = this.categories[0]?.className;\n    this.selectedCategoryItemName = this.categories[0]?.children[0]?.name;\n    this.currentToolItem = this.categories[0]?.children[0]?.tools[0];\n    this.loadModels();\n  }\n\n  /**\n   * load models by categories configuration\n   */\n  loadModels() {\n    let segModel = false;\n    let odModel = false;\n    const modelLoaded = this.categories.some((category) => category.children.some((child) => child.tools.some((tool) => {\n      if (\n        tool.type === Tool.PIXEL ||\n        tool.type === Tool.RECOGNITION ||\n        tool.models?.includes(CVModel.SEGMENTATION) ||\n        ((\n          tool.type === Tool.POLYGON ||\n          tool.type === Tool.LINE ||\n          tool.type === Tool.ARROW\n        ) && tool.models?.includes(CVModel.DEFAULT))\n      ) {\n        segModel = true;\n        runner.loadModel(OnnxModel.CV_RITM_SEGMENTATION);\n        runner.loadModel(OnnxModel.CV_SAM_SEGMENTATION);\n      }\n      if (tool.type === Tool.RECTANGLE && (\n        tool.models?.includes(CVModel.DEFAULT) ||\n        tool.models?.includes(CVModel.OBJECT_DETECTION) ||\n        tool.models?.includes(CVModel.OBJECT_DETECTION_MULTI)\n      )) {\n        odModel = true;\n        runner.loadModel(OnnxModel.CV_YOLOGV5S);\n      }\n      return segModel && odModel;\n    })));\n    if (!modelLoaded) {\n      // should setup recognizer\n      this.rootStore.shape.setupRecognizer();\n    }\n  }\n\n  /**\n   * get category object\n   * @param categoryName\n   */\n  getCategory(categoryName: string) {\n    return toJS(this.categories.find((o) => o.className === categoryName));\n  }\n\n  /**\n   * get category item\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getCategoryItem(categoryName: string, categoryItemName: string) {\n    const category = this.getCategory(categoryName);\n    return toJS((category?.children || []).find((o) => o.name === categoryItemName));\n  }\n\n  /**\n   * set selected category\n   * @param categoryName\n   */\n  selectCategory(categoryName: string) {\n    if (this.selectedCategoryName !== categoryName) {\n      // turn off the add mode\n      this.rootStore.config.setAddMode(false);\n      // category changes\n      this.selectedCategoryName = categoryName;\n      // update selected category name\n      this.selectCategoryItem(this.selectedCategory.children[0].name); // default select the first one\n      // unselect selected instance if needed\n      if (this.rootStore.instance.selectedInstances.findIndex((i) => i.category === categoryName) < 0) {\n        this.rootStore.instance.selectInstance(null);\n      }\n    }\n  }\n\n  /**\n   * select category by hotkey\n   * @param event\n   */\n  selectCategoryByHotkey(event: KeyboardEvent) {\n    const categoryName = this.getCategoryNameByHotkey(event);\n    if (categoryName) {\n      this.selectCategory(categoryName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * get category name by hotkey\n   * @param event\n   */\n  getCategoryNameByHotkey(event: KeyboardEvent) {\n    const key = event.key.toLocaleLowerCase();\n    for (let i = 0; i < this.categories.length; i += 1) {\n      const { className, shortcut } = this.categories[i];\n      if (\n        shortcut?.key === key &&\n        shortcut?.shiftKey === event.shiftKey &&\n        shortcut?.ctrlKey === event.ctrlKey &&\n        shortcut?.altKey === event.altKey\n      ) {\n        return className;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * set selected category item\n   * @param categoryItemName\n   */\n  selectCategoryItem(categoryItemName: string) {\n    this.selectedCategoryItemName = categoryItemName;\n    this.currentToolItem = this.selectedCategoryItem.tools[0];\n  }\n\n  /**\n   * select next category item\n   */\n  selectNextCategoryItem() {\n    const { children } = this.selectedCategory;\n    const index = children.findIndex((c) => c.name === this.selectedCategoryItemName);\n    if (index >= 0 && children.length > 1) {\n      const nextIndex = (index + 1) % children.length;\n      const categoryItem = children[nextIndex];\n      this.selectCategoryItem(categoryItem.name);\n    }\n  }\n\n  /**\n   * select category item by index\n   * @param index\n   */\n  selectCategoryItemByIndex(index: number) {\n    const categoryItem = this.selectedCategory.children[index];\n    if (categoryItem) {\n      this.selectCategoryItem(categoryItem.name);\n    }\n  }\n\n  /**\n   * activate category item\n   * @param categoryItemName\n   * @param tool\n   */\n  activateCategoryItem(categoryItemName: string, tool: ToolItem) {\n    if (this.rootStore.shape.isDrawing) {\n      return;\n    }\n    this.selectCategoryItem(categoryItemName);\n    this.selectTool(tool);\n    this.rootStore.config.setAddMode(true);\n  }\n\n  /**\n   * activate category item by index\n   * @param index\n   */\n  activateCategoryItemByIndex(index: number) {\n    if (this.rootStore.shape.isDrawing) {\n      return;\n    }\n    const child = this.selectedCategory.children[index];\n    if (child) {\n      const tool = child.name === this.selectedCategoryItemName ? this.currentToolItem! : child.tools[0];\n      this.activateCategoryItem(child.name, tool);\n    }\n  }\n\n  /**\n   * set current tool\n   * @param tool\n   */\n  selectTool(tool: ToolItem) {\n    if (this.currentToolItem !== tool) {\n      this.currentToolItem = tool;\n    }\n  }\n\n  /**\n   * get label config from category\n   * @param categoryName\n   */\n  getLabelConfigFromCategory(categoryName: string) {\n    const category = this.getCategory(categoryName);\n    return category?.labelConfig;\n  }\n\n  /**\n   * get dynamic label config from category\n   * @param categoryName\n   */\n  getDynamicLabelConfigFromCategory(categoryName: string) {\n    const category = this.getCategory(categoryName);\n    return category?.labelConfigDynamic;\n  }\n\n  /**\n   * get label config from category item\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getLabelConfigFromCategoryItem(categoryName: string, categoryItemName: string) {\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    return categoryItem?.labelConfig;\n  }\n\n  /**\n   * get point label config from category item\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getPointLabelConfigFromCategoryItem(categoryName: string, categoryItemName: string) {\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    return categoryItem?.pointLabelConfig;\n  }\n\n  /**\n   * get configured styles from tool\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolStylesByCategoryItem(categoryName: string, categoryItemName: string) {\n    // has cache\n    if (this.toolStylesCache[categoryName] && this.toolStylesCache[categoryName][categoryItemName]) {\n      return this.toolStylesCache[categoryName][categoryItemName];\n    }\n\n    if (!this.toolStylesCache[categoryName]) {\n      this.toolStylesCache[categoryName] = {};\n    }\n    this.toolStylesCache[categoryName][categoryItemName] = {\n      pointsStyles: null,\n      edgesStyles: null,\n    };\n\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    if (categoryItem) {\n      const tool = categoryItem.tools[0]; // simply use first one because only one tool can be configured\n      if (tool) {\n        const {\n          fillColor,\n          pointColor,\n          pointType,\n          edgeColor,\n          edgeType,\n          edgeBold,\n          pointsColor,\n          pointsType,\n          edgesColor,\n          edgesType,\n          edgesBold,\n        } = tool;\n        if (fillColor) {\n          this.toolStylesCache[categoryName][categoryItemName].fillColor = fillColor;\n        }\n        if (pointColor || pointType || pointsColor || pointsType) {\n          this.toolStylesCache[categoryName][categoryItemName].pointsStyles = {\n            pointColor,\n            pointType,\n            pointsColor,\n            pointsType,\n          };\n        }\n        if (edgeColor || edgeType || edgeBold !== undefined || edgesColor || edgesType || edgesBold) {\n          this.toolStylesCache[categoryName][categoryItemName].edgesStyles = {\n            edgeColor,\n            edgeType,\n            edgeBold,\n            edgesColor,\n            edgesType,\n            edgesBold,\n          };\n        }\n      }\n    }\n\n    return this.toolStylesCache[categoryName][categoryItemName];\n  }\n\n  /**\n   * get configured points styles\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolPointsStylesByCategoryItem(categoryName: string, categoryItemName: string) {\n    return this.getToolStylesByCategoryItem(categoryName, categoryItemName).pointsStyles;\n  }\n\n  /**\n   * get configured edges styles\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolEdgesStylesByCategoryItem(categoryName: string, categoryItemName: string) {\n    return this.getToolStylesByCategoryItem(categoryName, categoryItemName).edgesStyles;\n  }\n\n  /**\n   * get fill color\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolFillByCategoryItem(categoryName: string, categoryItemName: string) {\n    return this.getToolStylesByCategoryItem(categoryName, categoryItemName).fillColor;\n  }\n\n  /**\n   * get tool config (including common config)\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getToolConfigByCategoryItem(categoryName: string, categoryItemName: string) {\n    const categoryItem = this.getCategoryItem(categoryName, categoryItemName);\n    if (categoryItem) {\n      const tool = categoryItem.tools[0];\n      const { bbox = false, config } = tool || {};\n      return {\n        exportShapeBounds: bbox,\n        ...config,\n      };\n    }\n    return undefined;\n  }\n\n  /**\n   * set create method\n   * @param method\n   */\n  setCreateMethod = (method: ToolCreateMethod | CVModel) => {\n    // if currentCreateMethod is same with new method return\n    const currentCreateMethod = this.currentCreateMethod;\n    if (currentCreateMethod === method) return;\n\n    if (!this.toolCreateMethods[this.selectedCategoryName]) {\n      this.toolCreateMethods[this.selectedCategoryName] = {};\n    }\n    this.toolCreateMethods[this.selectedCategoryName][this.selectedCategoryItemName] = method;\n\n    // reset cursor\n    this.rootStore.config.setCursor(Cursor.CROSSHAIR);\n    // destroy drawing shape if exits\n    if (this.rootStore.shape.drawingShape) {\n      this.rootStore.shape.drawingShape.destroy();\n      this.rootStore.shape.drawingShape = null;\n    }\n  };\n\n  /**\n   * toggle create method by keyboard\n   */\n  toggleCreateMethodByKeyboard = () => {\n    if (!this.currentToolItem) {\n      return;\n    }\n\n    if (this.currentToolItem.type === Tool.PIXEL) {\n      this.rootStore.segmentation.switchMethod();\n      return;\n    }\n\n    const toolsOptions = this.currentToolOptions;\n    if (toolsOptions.length <= 0) {\n      return;\n    }\n\n    if (this.currentCreateMethod) {\n      const currentIndex = toolsOptions.findIndex((item) => item === this.currentCreateMethod);\n      const nextIndex = (currentIndex + 1) % toolsOptions.length;\n      this.setCreateMethod(toolsOptions[nextIndex]);\n    } else {\n      this.setCreateMethod(toolsOptions[0]);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}