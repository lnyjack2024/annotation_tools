{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx\";\nimport React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Attributes from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { LandmarkEditType, DELETETYPE, ReviewResult } from './types';\nimport { fetchResultByUrl } from './request';\nimport loader from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport { initInstances, loadInstancesFromResult, getFrameShapes, parseFramesByPaylod, getInstanceFrames } from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\nnotification.config({\n  top: 60\n});\nvar CANVASSTATUS = /*#__PURE__*/function (CANVASSTATUS) {\n  CANVASSTATUS[\"INITIAL\"] = \"initial\";\n  CANVASSTATUS[\"LANDMARK\"] = \"landmark\";\n  return CANVASSTATUS;\n}(CANVASSTATUS || {});\nconst LandmarkAnnotation = forwardRef((props, ref) => {\n  const store = useLocalObservable(() => rootStore);\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState(78);\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState('');\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState({});\n  const [updatedCategories, setUpdatedCategories] = useAsyncState([]);\n  const [defaultInstances, setDefaultInstances] = useAsyncState({});\n  const [instances, setInstances] = useAsyncState({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n  const [loading, setLoading] = useState(false);\n  const [formConfig, setFormConfig] = useState(null);\n  const [formValues, setFormValues] = useState(null);\n  const [imageSize, setImageSize] = useState({\n    width: 0,\n    height: 0\n  });\n  const [editFormObject, setEditFormObject] = useState(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState({});\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef(null);\n  const canvas = useRef(null);\n  const isDrawMode = useMemo(() => store.review.drawMode, [store.review.drawMode]);\n  const displayedInstances = useMemo(() => isReview ? initialInstances : instances, [isReview, initialInstances, instances]);\n  const instanceIds = useMemo(() => Object.keys(displayedInstances), [displayedInstances]);\n  const instanceList = useMemo(() => Object.values(displayedInstances).filter(v => !!v), [displayedInstances]);\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap = {};\n    instanceList.forEach(({\n      category,\n      id,\n      number\n    }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n  const displayedCategoryInstancesMap = useMemo(() => isReview ? initialCategoryInstancesMap : categoryInstancesMap, [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n  const displayedCategoryPathShapes = useMemo(() => isReview ? initialCategoryPathShapes : categoryPathShapes, [isReview, initialCategoryPathShapes, categoryPathShapes]);\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    return ontologyItem;\n  });\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category));\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find(group => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n  const categories = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.categories) || [], [ontologyGroup]);\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus === null || selectedShapeStatus === void 0 ? void 0 : selectedShapeStatus.id;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ? categories.findIndex(c => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) : -1;\n  }, [selectedShapeStatus, categories]);\n  const instancesFrames = useMemo(() => {\n    const items = {};\n    instanceList.forEach(instance => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n  const shapes = useMemo(() => {\n    var _selectedInstance$chi;\n    const group = selectedInstance === null || selectedInstance === void 0 ? void 0 : (_selectedInstance$chi = selectedInstance.children.find(g => g.name === selectedOntologyGroup)) === null || _selectedInstance$chi === void 0 ? void 0 : _selectedInstance$chi.frames[currentFrame];\n    return group && group.shapes || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n  const selectedShapeInfo = useMemo(() => {\n    let info = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        displayColor: (selectedOntology === null || selectedOntology === void 0 ? void 0 : selectedOntology.display_color) || ''\n      };\n      if ((ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        var _categories$selectedC;\n        info = {\n          ...info,\n          pointCategory: (_categories$selectedC = categories[selectedCategoryIndex]) === null || _categories$selectedC === void 0 ? void 0 : _categories$selectedC.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n  const annotatedPointOrShapeCount = useMemo(() => Object.entries(shapes).filter(([, v]) => v !== undefined).length, [shapes]);\n  const totalPointCount = useMemo(() => (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.count) || 0, [ontologyGroup]);\n  const instancesReviewsMap = useObserver(() => {\n    const map = {};\n    store.review.reviews.forEach(review => {\n      var _instances$instanceId;\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        shapeIds,\n        result\n      } = review;\n      const category = (_instances$instanceId = instances[instanceId]) === null || _instances$instanceId === void 0 ? void 0 : _instances$instanceId.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0\n        };\n      }\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n  useEffect(() => {\n    onLoad();\n  }, []);\n  const getInstance = instanceId => displayedInstances[instanceId];\n  const getGroup = (instanceId, groupName, frameIndex = currentFrame) => {\n    var _instance$children$fi;\n    const instance = getInstance(instanceId);\n    const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[frameIndex];\n    return group;\n  };\n  const getShape = (instanceId, groupName, id, frameIndex = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? group.shapes[id] : group.shapes[id]);\n  };\n  const setInstance = (id, instance) => {\n    setInstances({\n      ...instances,\n      [id]: instance\n    });\n  };\n  const setShape = (frameIndex, instanceId, groupName, id, shapeType, shape) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      var _group;\n      let group = instance.children.find(g => g.name === groupName);\n      let currentGroup = (_group = group) === null || _group === void 0 ? void 0 : _group.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = currentGroup.shapes[id];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = currentGroup.shapes[id];\n      }\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete currentGroup.shapes[id];\n        } else {\n          delete currentGroup.shapes[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n        }\n        currentGroup.shapes = {\n          ...currentGroup.shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === groupInfo.count && !currentGroup.attributes) {\n        handleFormConfig(groupInfo.label_config, {}, {\n          instanceId,\n          category: instance.category,\n          groupName\n        });\n      }\n    }\n  };\n  const updateStatus = async (curr, prev) => {\n    let newUpdatedShapes = [];\n    let newUpdatedCategories = [];\n    let updatedHandles = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const {\n          frameIndex,\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        let keyObj;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = {\n            index\n          };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = {\n            id\n          };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({\n            ...frameGroup,\n            ...keyObj,\n            shapeType\n          });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          const {\n            updateShapes\n          } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          const instanceIndex = instanceIds.findIndex(v => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          frameIndex,\n          groupName,\n          attributes\n        } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n          if (newInstance && newGroup) {\n            newGroup.frames[frameIndex].attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const {\n          instanceId,\n          groupName,\n          category,\n          index,\n          id,\n          shapeType,\n          shape,\n          frameIndex\n        } = item.status;\n        const frameGroup = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape;\n            const {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              attributes\n            } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex(p => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: {\n                  ...point.position\n                }\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                index,\n                shape: updateShape,\n                shapeType\n              });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape;\n            const {\n              displayColor,\n              visible,\n              x,\n              y,\n              width,\n              height\n            } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible\n            };\n            const updateIndex = newUpdatedShapes.findIndex(rect => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({\n                ...frameGroup,\n                id,\n                shape: updateRectangle,\n                shapeType\n              });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const {\n          frameIndex,\n          pointCategory,\n          shape\n        } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3]\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const {\n          id,\n          instance\n        } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const {\n            updateShapes,\n            updatedCategories: newCategories\n          } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [...newUpdatedShapes, ...updateShapes];\n          newUpdatedCategories = [...newUpdatedCategories, ...newCategories];\n        }\n      } else if (item.type === 'group') {\n        const {\n          instanceId,\n          groupName,\n          attributes,\n          frameIndex\n        } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.find(v => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach(id => {\n            var _canvas$current;\n            const attrLayer = (_canvas$current = canvas.current) === null || _canvas$current === void 0 ? void 0 : _canvas$current.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              var _canvas$current2;\n              (_canvas$current2 = canvas.current) === null || _canvas$current2 === void 0 ? void 0 : _canvas$current2.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          newGroup.frames[frameIndex].attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    }\n    ;\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({\n          message: 'Undo successfully.'\n        });\n      }\n    }\n  };\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({\n          message: 'Redo successfully.'\n        });\n      }\n    }\n  };\n  const handleChangeDrawMode = mode => {\n    if (store.review.isEditable) {\n      var _canvas$current3;\n      (_canvas$current3 = canvas.current) === null || _canvas$current3 === void 0 ? void 0 : _canvas$current3.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(undefined, {\n          instanceId,\n          category,\n          groupName\n        });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n  const loadInitialData = async () => {\n    let data;\n    const {\n      initial_result: initialResult\n    } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n  const addInstance = async ontologyName => {\n    const ontologyItem = store.ontology.ontology.find(category => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter(v => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n      const children = ontologyItem.children.map(v => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({\n        [id]: instance\n      });\n      await handleInstanceChange({\n        [id]: instance\n      });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, {\n          category: ontologyName,\n          shapeType: ontologyItem.children[0].type\n        });\n      }\n    }\n  };\n  const addInstanceInFrame = (instanceId, groupName) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex(group => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame;\n          Object.keys(newInstance.children[groupIdx].frames).forEach(i => {\n            const index = Number(i);\n            const frame = {\n              ...newInstance.children[groupIdx].frames[index]\n            };\n            frame.shapes = {\n              ...frame.shapes\n            };\n            if ((frame === null || frame === void 0 ? void 0 : frame.count) && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx;\n        Object.keys(instancesFrames[instanceId]).forEach(i => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach(group => {\n            const copyFrame = {\n              ...group.frames[copyFrameIdx]\n            };\n            copyFrame.shapes = {\n              ...copyFrame.shapes\n            };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const {\n        updateShapes,\n        updatedCategories: newUpdatedCategories\n      } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n  const removeInstanceFrames = (type, instance, name) => {\n    if (instance) {\n      let delShapes = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance, frameIndex) => {\n        updateInstance.children.forEach(group => {\n          if (name && name === group.name || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= group.frames[frameIndex].count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const {\n          updateShapes\n        } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({\n          length: frames.length - diffFrame\n        }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const {\n            updateShapes\n          } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [...delShapes, ...updateShapes];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter(v => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({\n        [newInstance.id]: newInstance\n      });\n    }\n  };\n  const handleInstanceChange = async (newInstances, status) => {\n    const ids = Object.keys(newInstances);\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async id => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach(child => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance\n          }\n        });\n        after.push({\n          type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n  const onLoad = async () => {\n    var _result, _saverRef$current;\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n    let result;\n    let initialData;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({\n        message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'),\n        duration: null\n      });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({\n      frames: props.image,\n      imageData: (_result = result) === null || _result === void 0 ? void 0 : _result.images\n    });\n    // preload image\n    setImagePreloader(loader(framesData.map(v => v.url)));\n    // set frame images\n    setFrames(framesData);\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes = {};\n        result.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData = {};\n        initialData.categoryPathShapes.forEach(({\n          pointCategory,\n          shape\n        }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const {\n        newInstances,\n        categoryInstancesMap: newCategoryInstancesMap\n      } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const {\n        newInstances\n      } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    (_saverRef$current = saverRef.current) === null || _saverRef$current === void 0 ? void 0 : _saverRef$current.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex, currentInstances = instances, type) => {\n    var _canvas$current4, _canvas$current5;\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    const currentInstanceList = Object.values(currentInstances);\n    (_canvas$current4 = canvas.current) === null || _canvas$current4 === void 0 ? void 0 : _canvas$current4.cleanLayer();\n    (_canvas$current5 = canvas.current) === null || _canvas$current5 === void 0 ? void 0 : _canvas$current5.setMultiShapesUnselected();\n    imagePreloader === null || imagePreloader === void 0 ? void 0 : imagePreloader.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const {\n        id,\n        category,\n        children: [{\n          name\n        }]\n      } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group === null || group === void 0 ? void 0 : group.type\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const {\n      updateShapes,\n      updatedCategories: updatedCategoriesData\n    } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n  const onSave = async (submit = true) => {\n    var _saverRef$current2, _canvas$current6, _canvas$current6$imag, _canvas$current7, _canvas$current7$imag;\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({\n        message: loadError\n      });\n      throw new Error(loadError);\n    }\n    (_saverRef$current2 = saverRef.current) === null || _saverRef$current2 === void 0 ? void 0 : _saverRef$current2.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances = instanceList.filter(v => v && v.notEmpty).map(instance => {\n      const {\n        id,\n        category,\n        number,\n        displayColor,\n        children\n      } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map(group => {\n          const {\n            frames: groupFrames\n          } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter(v => !!v && v.count > 0).map(frameGroup => {\n              if (frameGroup) {\n                const {\n                  frameIndex,\n                  count,\n                  shapes: groupShapes\n                } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach(key => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point = groupShapes && groupShapes[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        newShapes.push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle = groupShapes && groupShapes[key];\n                      if (rectangle) newShapes.push(rectangle);\n                    }\n                  });\n                }\n                if (checkMissingPoints && frames[frameIndex].valid !== false && groupInfo && newShapes.length < groupInfo.count) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.display_name) || (ontologyInfo === null || ontologyInfo === void 0 ? void 0 : ontologyInfo.class_name),\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({\n                    message: errMsg\n                  });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: ((_canvas$current6 = canvas.current) === null || _canvas$current6 === void 0 ? void 0 : (_canvas$current6$imag = _canvas$current6.imageCanvas) === null || _canvas$current6$imag === void 0 ? void 0 : _canvas$current6$imag.width) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.width),\n      height: ((_canvas$current7 = canvas.current) === null || _canvas$current7 === void 0 ? void 0 : (_canvas$current7$imag = _canvas$current7.imageCanvas) === null || _canvas$current7$imag === void 0 ? void 0 : _canvas$current7$imag.height) || (imageSize === null || imageSize === void 0 ? void 0 : imageSize.height),\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map(pointCategory => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory]\n      })),\n      images: frames,\n      statistics\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0\n    };\n    const reviews = store.review.reviews.filter(r => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter(r => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find(r => r.shapeIds.indexOf(shapeId) >= 0);\n            if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return {\n      objects,\n      shapes: statShapes\n    };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const {\n      ontology\n    } = store.ontology;\n    const data = {\n      elements: [],\n      categories: ontology.map(({\n        class_name: className\n      }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set()\n    };\n    const instancesList = Object.values(instances).filter(v => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const {\n        id,\n        category,\n        children\n      } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(...frameShapes.map(s => ({\n              instance: id,\n              shape,\n              frame: frame.frameIndex + 1,\n              category,\n              id: s.id || s.index\n            })));\n          }\n        }\n      }\n    }\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({\n        category,\n        shape,\n        count,\n        distinctCount\n      }) => ({\n        category,\n        shape,\n        count,\n        distinctCount\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size\n    };\n  };\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n  const saveReviews = (type = 'submit') => {\n    var _saverRef$current3;\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find(review => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    (_saverRef$current3 = saverRef.current) === null || _saverRef$current3 === void 0 ? void 0 : _saverRef$current3.disableLeaveCheck();\n    return props.jobProxy.saveReviews(store.review.reviews, type === 'submit');\n  };\n  const handleSave = async () => {\n    const {\n      toolMode\n    } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n    try {\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({\n        message: formatMessage('SAVE_SUCCESS')\n      });\n    } catch (e) {\n      notification.error({\n        message: formatMessage('SAVE_FAIL')\n      });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const {\n        hasCustomError,\n        blockSubmitErrors\n      } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n  const setSelectedShape = (id, groupData) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        shapeType\n      } = groupData;\n      if (instanceId !== (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.id)) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || (ontologyGroup === null || ontologyGroup === void 0 ? void 0 : ontologyGroup.type) || undefined,\n        groupName\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n  const setNextEmptyShape = (shapeStatus = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let {\n        id\n      } = shapeStatus;\n      const {\n        instanceId,\n        groupName,\n        shapeType\n      } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const {\n            range = []\n          } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            id += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n  const handleShapesChange = (newShapes, groupsAttributes, status) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before = status ? status.before : [];\n    const after = status ? status.after : [];\n    const {\n      instanceId,\n      groupName\n    } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData((newInstance === null || newInstance === void 0 ? void 0 : newInstance.category) || '', groupName);\n    newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          };\n        }\n        ;\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const {\n            id,\n            frameIndex,\n            index,\n            shape\n          } = newShapes[i];\n          let oldShape;\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = child.frames[frameIndex].shapes[index];\n            child.frames[frameIndex].shapes[index] = {\n              ...oldShape,\n              ...shape\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = child.frames[frameIndex].shapes[id];\n            child.frames[frameIndex].shapes[id] = {\n              ...oldShape,\n              ...shape\n            };\n          }\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        }\n        ;\n        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.label_config) && currentGroup.count === (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.count) && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, {\n            instanceId,\n            category: newInstance.category,\n            groupName\n          });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({\n        instanceId: id,\n        name,\n        category,\n        attributes\n      }) => {\n        const frameGroup = {\n          frameIndex: currentFrame,\n          instanceId: id,\n          category,\n          groupName: name\n        };\n        before.push({\n          type: 'group',\n          status: {\n            ...frameGroup\n          }\n        });\n        after.push({\n          type: 'group',\n          status: {\n            ...frameGroup,\n            attributes\n          }\n        });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({\n        [instanceId]: newInstance\n      }, {\n        before,\n        after\n      });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n  const handleShapesRemove = removeShapes => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n    const changeInstances = {};\n    const {\n      instanceId,\n      groupName\n    } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance === null || newInstance === void 0 ? void 0 : newInstance.children.forEach(child => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({\n            id,\n            frameIndex,\n            index\n          }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete child.frames[frameIndex].shapes[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete child.frames[frameIndex].shapes[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({\n        [instanceId]: newInstance\n      });\n    }\n  };\n  const togglePointsVisibility = points => {\n    const list = [];\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: {\n            ...point,\n            visible: !point.visible\n          }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n  const setCategoryPathShape = (categoryKey, shapeType, _updatedShapes) => {\n    const before = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: categoryPathShapes[categoryKey]\n      }\n    }];\n    const after = [{\n      type: 'pointCategory-path-shape',\n      status: {\n        frameIndex: selectedShapeStatus.frameIndex,\n        pointCategory: categoryKey,\n        shape: shapeType\n      }\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, {\n        before,\n        after\n      });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n  const selectGroup = (id, groupName, isFit = true, groupData) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: (groupData === null || groupData === void 0 ? void 0 : groupData.category) || selectedShapeStatus.category,\n      groupName,\n      shapeType: (groupData === null || groupData === void 0 ? void 0 : groupData.shapeType) || undefined,\n      id: undefined\n    };\n    if (instance) {\n      var _canvas$current8;\n      const ontologyItem = store.ontology.ontology.find(v => v.class_name === instance.category);\n      const group = ontologyItem === null || ontologyItem === void 0 ? void 0 : ontologyItem.children.find(v => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = (group === null || group === void 0 ? void 0 : group.type) || undefined;\n      if (isDrawMode) {\n        if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.KEYPOINT) {\n          const index = group.categories && group.categories[0] && group.categories[0].range[0] || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if ((group === null || group === void 0 ? void 0 : group.type) === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach(child => {\n            var _child$frames$current;\n            if (child.name === groupName && ((_child$frames$current = child.frames[currentFrame]) === null || _child$frames$current === void 0 ? void 0 : _child$frames$current.shapes)) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      (_canvas$current8 = canvas.current) === null || _canvas$current8 === void 0 ? void 0 : _canvas$current8.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        var _canvas$current9;\n        (_canvas$current9 = canvas.current) === null || _canvas$current9 === void 0 ? void 0 : _canvas$current9.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n  const editShapeForm = () => {\n    const {\n      instanceId,\n      groupName,\n      shapeType,\n      id,\n      category\n    } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, id);\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.point_label_config)) {\n        handleFormConfig(currentOntologyGroup.point_label_config, point.attributes || {}, {\n          instanceId,\n          category,\n          groupName\n        }, id, point);\n      }\n    }\n  };\n  const editGroupForm = () => {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && (currentOntologyGroup === null || currentOntologyGroup === void 0 ? void 0 : currentOntologyGroup.label_config)) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, {\n        instanceId,\n        category,\n        groupName\n      });\n    }\n  };\n  const handleFormConfig = (config, values, group, index, point) => {\n    var _attributesRef$curren;\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    (_attributesRef$curren = attributesRef.current) === null || _attributesRef$curren === void 0 ? void 0 : _attributesRef$curren.showModal(title);\n  };\n  const getShapeLabel = (instanceId, category, groupName) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', {\n          values: {\n            frameIndex: currentFrame + 1\n          }\n        })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n  const setAttributes = values => {\n    if (editFormObject) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        index,\n        point\n      } = editFormObject;\n      const before = [];\n      const after = [];\n      const frameGroup = {\n        frameIndex: currentFrame,\n        instanceId,\n        category,\n        groupName\n      };\n      if ((index || index === 0) && point) {\n        var _canvas$current10;\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = {\n          ...oldPoint,\n          ...point,\n          attributes: values\n        };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: oldPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        after.push({\n          type: 'shape',\n          status: {\n            ...frameGroup,\n            index,\n            shape: newPoint,\n            shapeType: LandmarkEditType.KEYPOINT\n          }\n        });\n        (_canvas$current10 = canvas.current) === null || _canvas$current10 === void 0 ? void 0 : _canvas$current10.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        var _newInstance$children;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance === null || newInstance === void 0 ? void 0 : (_newInstance$children = newInstance.children.find(v => v.name === groupName)) === null || _newInstance$children === void 0 ? void 0 : _newInstance$children.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: oldAttrs\n            }\n          });\n          after.push({\n            type: 'group',\n            status: {\n              ...frameGroup,\n              attributes: values\n            }\n          });\n          if (oldGroup === null || oldGroup === void 0 ? void 0 : oldGroup.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach(id => {\n                var _canvas$current11;\n                (_canvas$current11 = canvas.current) === null || _canvas$current11 === void 0 ? void 0 : _canvas$current11.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode, type = 'object') => {\n    var _canvas$current12;\n    (_canvas$current12 = canvas.current) === null || _canvas$current12 === void 0 ? void 0 : _canvas$current12.updatelabelVisible(activeMode, type);\n  };\n  const onSizeChange = () => {\n    var _canvas$current13;\n    (_canvas$current13 = canvas.current) === null || _canvas$current13 === void 0 ? void 0 : _canvas$current13.resizeShapes();\n  };\n  const onFilterChange = () => {\n    var _canvas$current14;\n    (_canvas$current14 = canvas.current) === null || _canvas$current14 === void 0 ? void 0 : _canvas$current14.updateFilters();\n  };\n  const onLabelModeChange = () => {\n    var _canvas$current15;\n    if ((_canvas$current15 = canvas.current) === null || _canvas$current15 === void 0 ? void 0 : _canvas$current15.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n  const onGridVisibleChange = () => {\n    var _canvas$current16;\n    if ((_canvas$current16 = canvas.current) === null || _canvas$current16 === void 0 ? void 0 : _canvas$current16.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n  const setFrameValid = (frame, valid) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics\n  }));\n  return /*#__PURE__*/React.createElement(Observer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 1563,\n      columnNumber: 5\n    }\n  }, () => {\n    var _frames$currentFrame, _frames$currentFrame2;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"landmark-annotation-app\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1565,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(AutoSaver, {\n      ref: saverRef,\n      leaveCheck: true,\n      data: {\n        instance: instances,\n        reviews: store.review.qaWarnings\n      },\n      save: handleSave,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1566,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(Toolbar, {\n      readonly: readonly || loading || isReview,\n      isReview: isReview,\n      isPreview: readonly,\n      initialDataLength: Object.keys(initialInstances).length,\n      onAttributesModeChanges: onAttributesModeChanges,\n      onSizeChange: onSizeChange,\n      onFilterChange: onFilterChange,\n      onLabelModeChange: onLabelModeChange,\n      onGridVisibleChange: onGridVisibleChange,\n      onSave: handleSave,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1572,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"container\",\n      style: {\n        height: `calc(100% - ${frames.length > 1 && currentFrame >= 0 ? `${frameControlHeight + 35}px` : '35px'})`,\n        transition: 'height 0.15s'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1588,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(TabMenu, {\n      tabs: [{\n        title: formatMessage('MENU_INSTANCE'),\n        key: 'instance',\n        count: 0,\n        content: /*#__PURE__*/React.createElement(SideMenus, {\n          readonly: readonly || loading || isReview || !isDrawMode,\n          loading: loading,\n          instances: instanceList,\n          currentFrame: currentFrame,\n          instancesFrames: instancesFrames,\n          selectedInstance: selectedInstance,\n          selectedOntologyGroup: selectedOntologyGroup,\n          instancesReviewsMap: instancesReviewsMap,\n          addInstance: addInstance,\n          selectGroup: selectGroup,\n          addInstanceInFrame: addInstanceInFrame,\n          removeInstanceFrames: removeInstanceFrames,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1602,\n            columnNumber: 21\n          }\n        })\n      }\n      // {\n      //   title: formatMessage('MENU_WARNING'),\n      //   key: 'validator',\n      //   count: store.review.warnings.length,\n      //   content: (\n      //     <Validator\n      //       ref={validatorRef}\n      //       instances={instances}\n      //       jobProxy={props.jobProxy}\n      //       getScriptResult={getScriptResult}\n      //       warnings={store.review.warnings || []}\n      //       setFrame={setFrame}\n      //       setSelectedShape={setSelectedShape}\n      //       selectGroup={selectGroup}\n      //       getInstance={getInstance}\n      //       saveResult={() => onSave(false)}\n      //     />\n      //   )\n      // }\n      ],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1595,\n        columnNumber: 13\n      }\n    }), selectedInstance && ontologyGroup && !isReview && /*#__PURE__*/React.createElement(Board, {\n      categories: categories,\n      categoryPathShapes: displayedCategoryPathShapes,\n      points: shapes,\n      ontologyGroup: ontologyGroup,\n      selectedShapeStatus: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      drawMode: isDrawMode,\n      setSelectedShape: id => {\n        const {\n          instanceId,\n          category,\n          groupName\n        } = selectedShapeStatus;\n        setSelectedShape(id, {\n          instanceId,\n          category,\n          groupName\n        });\n      },\n      frameControlHeight: frameControlHeight,\n      readonly: loading,\n      instanceReviewsMap: store.review.frameReviewsMap[currentFrame],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1640,\n        columnNumber: 15\n      }\n    }), /*#__PURE__*/React.createElement(Canvas, {\n      ref: canvas,\n      readonly: readonly,\n      loading: loading,\n      isReview: isReview,\n      currentFrame: currentFrame,\n      image: (_frames$currentFrame = frames[currentFrame]) === null || _frames$currentFrame === void 0 ? void 0 : _frames$currentFrame.url,\n      categories: categories,\n      selectedInstance: selectedInstance,\n      selectedGroupName: selectedOntologyGroup,\n      ontologyGroup: ontologyGroup,\n      annotatedPointOrShapeCount: annotatedPointOrShapeCount,\n      updatedCategories: updatedCategories,\n      defaultInstances: defaultInstances,\n      selectedShapeStatus: selectedShapeStatus,\n      selectedShapeInfo: selectedShapeInfo,\n      changeLoading: setLoading,\n      selectGroup: selectGroup,\n      setSelectedShape: setSelectedShape,\n      handleShapesChange: handleShapesChange,\n      onCategoriesUpdated: onCategoriesUpdated,\n      handleShapesRemove: handleShapesRemove,\n      togglePointsVisibility: togglePointsVisibility,\n      setNextEmptyShape: setNextEmptyShape,\n      editShapeForm: editShapeForm,\n      editGroupForm: editGroupForm,\n      onSave: handleSave,\n      getInstance: getInstance,\n      categoryPathShapes: displayedCategoryPathShapes,\n      setCategoryPathShape: setCategoryPathShape,\n      handleUndo: handleUndo,\n      handleRedo: handleRedo,\n      setReview: setReview,\n      handleChangeDrawMode: handleChangeDrawMode,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1658,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"arributes-panel\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1693,\n        columnNumber: 13\n      }\n    }, selectedShapeStatus.groupName && /*#__PURE__*/React.createElement(Information, {\n      pointCategory: (categories[selectedCategoryIndex] || {}).name,\n      point: selectedShapeStatus,\n      annotated: annotatedPointOrShapeCount,\n      total: totalPointCount,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1695,\n        columnNumber: 17\n      }\n    }), ((_frames$currentFrame2 = frames[currentFrame]) === null || _frames$currentFrame2 === void 0 ? void 0 : _frames$currentFrame2.url) && /*#__PURE__*/React.createElement(FrameAttributes, {\n      currentFrame: currentFrame,\n      currentFrameValid: frames[currentFrame].valid,\n      setFrameValid: setFrameValid,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1703,\n        columnNumber: 17\n      }\n    })), /*#__PURE__*/React.createElement(Attributes, {\n      ref: attributesRef,\n      readonly: readonly || isReview || !isDrawMode,\n      config: formConfig,\n      values: formValues,\n      onValuesChange: setAttributes,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1710,\n        columnNumber: 13\n      }\n    })), frames.length > 1 && currentFrame >= 0 && /*#__PURE__*/React.createElement(FrameControl, {\n      frames: frames,\n      frameLoading: loading,\n      currentFrame: currentFrame,\n      categoryInstancesMap: displayedCategoryInstancesMap,\n      instancesReviewsMap: instancesReviewsMap,\n      instances: displayedInstances,\n      selectedInstance: selectedInstance,\n      selectedInstanceGroup: selectedOntologyGroup,\n      selectGroup: selectGroup,\n      setFrame: setFrame,\n      onHeightChange: setFrameControlHeight,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1719,\n        columnNumber: 13\n      }\n    }), store.review.selectedReview && /*#__PURE__*/React.createElement(QualityControl, {\n      review: store.review.selectedReview,\n      readonly: readonly || isDrawMode,\n      jobProxy: props.jobProxy,\n      selectedShapeStatus: selectedShapeStatus,\n      getShapeLabel: getShapeLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1734,\n        columnNumber: 13\n      }\n    }));\n  });\n});\nexport default LandmarkAnnotation;","map":{"version":3,"names":["React","useState","useRef","useMemo","useEffect","forwardRef","useImperativeHandle","Observer","useLocalObservable","useObserver","cloneDeep","notification","v4","uuid","TabMenu","AutoSaver","Toolbar","SideMenus","Board","Canvas","FrameControl","Attributes","QualityControl","Information","FrameAttributes","formatMessage","i18n","LandmarkEditType","DELETETYPE","ReviewResult","fetchResultByUrl","loader","isPreview","isAnnotationReadonly","initInstances","loadInstancesFromResult","getFrameShapes","parseFramesByPaylod","getInstanceFrames","rootStore","useAsyncState","config","top","CANVASSTATUS","LandmarkAnnotation","props","ref","store","readonly","setReadOnly","frames","setFrames","currentFrame","setCurrentFrame","frameControlHeight","setFrameControlHeight","selectedOntologyGroup","setSelectedOntologyGroup","categoryPathShapes","setCategoryPathShapes","updatedCategories","setUpdatedCategories","defaultInstances","setDefaultInstances","instances","setInstances","imagePreloader","setImagePreloader","selectedShapeStatus","setSelectedShapeStatus","frameIndex","category","instanceId","groupName","shapeType","undefined","id","loading","setLoading","formConfig","setFormConfig","formValues","setFormValues","imageSize","setImageSize","width","height","editFormObject","setEditFormObject","isReview","setIsReview","initialInstances","setInitialInstances","initialCategoryInstancesMap","setInitialCategoryInstancesMap","initialCategoryPathShapes","setInitialCategoryPathShapes","attributesRef","saverRef","validatorRef","canvas","isDrawMode","review","drawMode","displayedInstances","instanceIds","Object","keys","instanceList","values","filter","v","selectedInstance","categoryInstancesMap","newCategoryInstancesMap","forEach","number","displayedCategoryInstancesMap","displayedCategoryPathShapes","selectedOntology","ontologyItem","ontology","find","class_name","ontologyGroup","groupItem","children","group","name","categories","selectedCategoryIndex","KEYPOINT","findIndex","c","range","length","instancesFrames","items","instance","shapes","_selectedInstance$chi","g","selectedShapeInfo","info","type","displayColor","display_color","_categories$selectedC","pointCategory","isKeyPoint","includes","annotatedPointOrShapeCount","entries","totalPointCount","count","instancesReviewsMap","map","reviews","_instances$instanceId","shapeIds","result","approveCount","REJECT","SUSPEND","APPROVE","len","ontologyCount","ontologyMap","onLoad","getInstance","getGroup","_instance$children$fi","getShape","setInstance","setShape","shape","_group","currentGroup","push","oldShape","RECTANGLE","notEmpty","groupInfo","getGroupData","label_config","attributes","handleFormConfig","updateStatus","curr","prev","newUpdatedShapes","newUpdatedCategories","updatedHandles","newCategoryPathShapes","m","item","index","status","frameGroup","keyObj","updateShapes","instanceIndex","selectedIndex","newInstance","selectGroup","newGroup","setInitialData","n","point","visible","updateIndex","p","updateShape","position","rectangle","x","y","updateRectangle","rect","split","newCategories","_canvas$current","attrLayer","current","getAttrLabelByKey","_canvas$current2","updateAttributeLabel","setUpdatedShapes","handle","setUpdatedHandles","handleUndo","undo","undoDisabled","before","after","success","message","handleRedo","redoDisabled","redo","handleChangeDrawMode","mode","isEditable","_canvas$current3","clearHits","setNextEmptyShape","setSelectedShape","setDrawMode","loadInitialData","data","initial_result","initialResult","e","console","log","addInstance","ontologyName","sameOntologyInstances","reverse","handleInstanceChange","addInstanceInFrame","groupIdx","copyFrame","i","Number","frame","copyFrameIdx","removeInstanceFrames","delShapes","update","updateInstance","CURRENT","FOLLOW","ALL","diffFrame","Array","from","_","newInstances","ids","oldInstance","isRemove","child","saveStatus","_result","_saverRef$current","jobProxy","toolMode","setLocale","locale","init","initialData","initInstancesData","loadResult","error","duration","framesData","image","imageData","images","url","isArray","auditId","setAuditId","points","initialCategoryPathShapesData","initialInstancesData","currentInstances","setFrame","setTempSaved","renderComplete","_canvas$current4","_canvas$current5","INITIAL","currentInstanceList","cleanLayer","setMultiShapesUnselected","preload","currentShapeStatus","updatedCategoriesData","changeFrame","setReview","newIsReview","displayInstances","onSave","submit","_saverRef$current2","_canvas$current6","_canvas$current6$imag","_canvas$current7","_canvas$current7$imag","loadError","Error","disableLeaveCheck","setting","submitCheck","passed","triggerValidation","checkMissingPoints","check_missing_points","ontologyInfo","getOntologyInfo","groupFrames","groupShapes","newShapes","key","pointIndex","parseInt","valid","errMsg","display_name","annotated","total","statData","getInstanceStatistics","statistics","saveResultStat","handles","getHandles","saveResult","imageCanvas","getStatistics","statShapes","objects","approved","rejected","suspended","missed","r","instancesList","j","itemFrames","k","frameReviews","frameShapes","l","shapeId","indexOf","elements","className","Set","summary","frameCount","annotatedFrames","add","distinctCount","shapeCount","s","annotatedFrameCount","size","loadReviews","saveReviews","_saverRef$current3","hasSuspend","handleSave","isEnabled","hasCustomError","blockSubmitErrors","handleSync","groupData","newSelectedShapeStatus","shapeStatus","categoryScannedCount","categoryIndex","onCategoriesUpdated","handleShapesChange","groupsAttributes","handleShapesRemove","removeShapes","changeInstances","togglePointsVisibility","list","setCategoryPathShape","categoryKey","_updatedShapes","isFit","_canvas$current8","_child$frames$current","rectangles","updateGroupBox","_canvas$current9","fitSelected","editShapeForm","currentOntologyGroup","point_label_config","editGroupForm","_attributesRef$curren","title","getShapeLabel","showModal","class_display_name","setAttributes","_canvas$current10","oldPoint","newPoint","_newInstance$children","oldGroup","ontologyChild","oldAttrs","_canvas$current11","onAttributesModeChanges","activeMode","_canvas$current12","updatelabelVisible","onSizeChange","_canvas$current13","resizeShapes","onFilterChange","_canvas$current14","updateFilters","onLabelModeChange","_canvas$current15","labelLayer","labelMode","onGridVisibleChange","_canvas$current16","gridLayer","isGridVisible","setFrameValid","newFramesData","createElement","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","_frames$currentFrame","_frames$currentFrame2","leaveCheck","qaWarnings","save","initialDataLength","style","transition","tabs","content","instanceReviewsMap","frameReviewsMap","selectedGroupName","changeLoading","currentFrameValid","onValuesChange","frameLoading","selectedInstanceGroup","onHeightChange","selectedReview"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/index.tsx"],"sourcesContent":["import React, { useState, useRef, useMemo, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport { Observer, useLocalObservable, useObserver } from 'mobx-react';\nimport { cloneDeep } from 'lodash';\nimport { notification } from 'antd';\nimport { v4 as uuid } from 'uuid';\nimport TabMenu from '../common/tabs-menu/TabMenu';\nimport AutoSaver from '../common/AutoSaver';\nimport Toolbar from './components/Toolbar';\nimport SideMenus from './components/SideMenus';\nimport Board from './components/Board';\nimport Canvas from './components/Canvas';\nimport FrameControl from './components/FrameContorl';\nimport Validator from './components/Validator';\nimport Attributes, { AttributesHandle } from './components/Attributes';\nimport QualityControl from './components/QualityControl';\nimport Information from './components/Information';\nimport FrameAttributes from './components/FrameAttributes';\nimport formatMessage, { i18n } from './locales';\nimport { Status } from './store/UndoStore';\nimport { AttributesMode } from './store/SettingsStore';\nimport { IWarning } from '../common/tabs-menu/Validator';\nimport {\n  LandmarkEditType, InstanceListItem, CategoryPathShape, Point, PointListItem, PointStatus, FrameGroup,\n  ShapeInfo, PointInfo, Group, InstanceAct, Rectangle, GroupInfo, FormConfig, ObjectInfo, UpdatedShape,\n  Points, CurrentShapes, CategoryInstancesMap, KeypointCategoryProps, DELETETYPE, Frame, ReviewResult,\n  Payload, Statistic, Image, HandleStatus\n} from './types';\nimport { fetchResultByUrl } from './request';\nimport loader, { ImagePreloader } from '../../utils/image-preloader';\nimport { isPreview, isAnnotationReadonly } from '../../utils/tool-mode';\nimport {\n  initInstances,\n  loadInstancesFromResult,\n  getFrameShapes,\n  parseFramesByPaylod,\n  getInstanceFrames,\n} from './utils';\nimport './index.scss';\nimport rootStore from './store/RootStore';\nimport useAsyncState from './useAsyncState';\n\nnotification.config({ top: 60 });\n\nenum CANVASSTATUS {\n  INITIAL = 'initial',\n  LANDMARK = 'landmark',\n}\n\nexport interface GroupReviewsMap {\n  [groupName: string]: {\n    approveCount: number;\n    result?: ReviewResult;\n  }\n}\n\nexport interface InstancesReviewsMap {\n  [instanceId: string]: {\n    [frameIndex: number]: {\n      approveCount: number;\n      result?: ReviewResult;\n      children: GroupReviewsMap\n    }\n  }\n}\n\nconst LandmarkAnnotation = forwardRef((props: Payload, ref) => {\n  const store = useLocalObservable(() => rootStore);\n\n  const [readonly, setReadOnly] = useState(false);\n  /**\n   * frame image urls\n   */\n  const [frames, setFrames] = useState<Image[]>([]);\n\n  /**\n   * current frame index\n   */\n  const [currentFrame, setCurrentFrame] = useAsyncState<number>(-1);\n\n  /**\n   * frame control height (default is 48 + 30 = 78)\n   */\n  const [frameControlHeight, setFrameControlHeight] = useState<number>(78);\n\n  const [selectedOntologyGroup, setSelectedOntologyGroup] = useState<string>('');\n\n  const [categoryPathShapes, setCategoryPathShapes] = useAsyncState<{ [categoryKey: string]: CategoryPathShape }>({});\n\n  const [updatedCategories, setUpdatedCategories] = useAsyncState<KeypointCategoryProps[]>([]);\n\n  const [defaultInstances, setDefaultInstances] = useAsyncState<{[id: string]: InstanceAct}>({});\n\n  const [instances, setInstances] = useAsyncState<{[id: string]: InstanceAct}>({});\n\n  /**\n   * image preloader\n   */\n  const [imagePreloader, setImagePreloader] = useState<ImagePreloader | null>(null);\n\n  /**\n   * selected shape info\n   */\n  const [selectedShapeStatus, setSelectedShapeStatus] = useState<ShapeInfo>({\n    frameIndex: -1,\n    category: '',\n    instanceId: '',\n    groupName: '',\n    shapeType: undefined,\n    id: undefined\n  });\n\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const [formConfig, setFormConfig] = useState<FormConfig | null>(null);\n\n  const [formValues, setFormValues] = useState<{[attr: string]: any;} | null>(null);\n\n  const [imageSize, setImageSize] = useState<{width: number, height: number} | undefined>({ width: 0, height: 0 });\n\n  const [editFormObject, setEditFormObject] = useState<ObjectInfo | null>(null);\n\n  /**\n   * is review mode\n   */\n  const [isReview, setIsReview] = useState<boolean>(false);\n\n  /**\n   * initial instances, used to review\n   */\n  const [initialInstances, setInitialInstances] = useState<{[id: string]: InstanceAct}>({});\n\n  /**\n   * category instances\n   */\n  const [initialCategoryInstancesMap, setInitialCategoryInstancesMap] = useState<CategoryInstancesMap>({});\n\n  const [initialCategoryPathShapes, setInitialCategoryPathShapes] = useState<{[categoryKey: string]: CategoryPathShape}>({});\n\n  /**\n   * attributes reference\n   */\n  const attributesRef = useRef<AttributesHandle>(null);\n\n  /**\n   * auto saver reference\n   */\n  const saverRef = useRef<AutoSaver>(null);\n\n  /**\n   * validator reference\n   */\n  const validatorRef = useRef<Validator>(null);\n\n  const canvas = useRef<Canvas>(null);\n\n  const isDrawMode = useMemo(() => (\n    store.review.drawMode\n  ), [store.review.drawMode]);\n\n  const displayedInstances = useMemo(() => (\n    isReview ? initialInstances : instances\n  ), [isReview, initialInstances, instances]);\n\n  const instanceIds = useMemo(() => (\n    Object.keys(displayedInstances)\n  ), [displayedInstances]);\n\n  const instanceList = useMemo(() => (\n    Object.values(displayedInstances).filter((v) => !!v)\n  ), [displayedInstances]);\n\n  const selectedInstance = useMemo(() => {\n    if (selectedShapeStatus?.instanceId) {\n      return displayedInstances[selectedShapeStatus.instanceId];\n    }\n    return undefined;\n  }, [selectedShapeStatus, displayedInstances]);\n\n  /**\n   * category instances (used for sidebar render)\n   */\n  const categoryInstancesMap = useMemo(() => {\n    const newCategoryInstancesMap: CategoryInstancesMap = {};\n    instanceList.forEach(({ category, id, number }) => {\n      if (!newCategoryInstancesMap[category]) {\n        newCategoryInstancesMap[category] = {};\n      }\n      newCategoryInstancesMap[category][id] = number;\n    });\n\n    return newCategoryInstancesMap;\n  }, [isReview, initialInstances, instanceList]);\n\n  const displayedCategoryInstancesMap = useMemo(() => (\n    isReview ? initialCategoryInstancesMap : categoryInstancesMap\n  ), [isReview, initialCategoryInstancesMap, categoryInstancesMap]);\n\n  const displayedCategoryPathShapes = useMemo(() => (\n    isReview ? initialCategoryPathShapes : categoryPathShapes\n  ), [isReview, initialCategoryPathShapes, categoryPathShapes]);\n\n  const selectedOntology = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    return ontologyItem;\n  });\n\n  const ontologyGroup = useObserver(() => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === selectedInstance?.category);\n    const groupItem = ontologyItem && ontologyItem.children && ontologyItem.children.find((group) => group.name === selectedOntologyGroup);\n    return groupItem;\n  });\n\n  const categories = useMemo(() => (\n    ontologyGroup?.categories || []\n  ), [ontologyGroup]);\n\n  const selectedCategoryIndex = useMemo(() => {\n    const id = selectedShapeStatus?.id as number;\n    return selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT ?\n      categories.findIndex((c) => c.range && c.range.length === 2 && id >= c.range[0] && id <= c.range[1]) :\n      -1;\n  }, [selectedShapeStatus, categories]);\n\n  const instancesFrames = useMemo(() => {\n    const items: { [id: string]: {\n      [frameIndex: number]: boolean;\n    } } = {};\n    instanceList.forEach((instance) => {\n      items[instance.id] = getInstanceFrames(instance);\n    });\n    return items;\n  }, [instanceList]);\n\n  const shapes = useMemo(() => {\n    const group = selectedInstance?.children.find((g) => g.name === selectedOntologyGroup)?.frames[currentFrame];\n    return (group && group.shapes) || {};\n  }, [selectedInstance, selectedOntologyGroup, currentFrame]);\n\n  const selectedShapeInfo = useMemo(() => {\n    let info: PointInfo | GroupInfo | null = null;\n    if (selectedShapeStatus) {\n      info = {\n        category: selectedShapeStatus.category,\n        instanceId: selectedShapeStatus.instanceId,\n        groupName: selectedShapeStatus.groupName,\n        shapeType: ontologyGroup?.type || undefined,\n        displayColor: selectedOntology?.display_color || ''\n      };\n      if (ontologyGroup?.type === LandmarkEditType.KEYPOINT && selectedCategoryIndex >= 0) {\n        info = {\n          ...info,\n          pointCategory: categories[selectedCategoryIndex]?.name,\n          isKeyPoint: categories[selectedCategoryIndex].keys.includes(selectedShapeStatus.id as number)\n        };\n      }\n    }\n    return info;\n  }, [selectedShapeStatus, selectedCategoryIndex, ontologyGroup]);\n\n  const annotatedPointOrShapeCount = useMemo(() => (\n    Object.entries(shapes).filter(([, v]) => v !== undefined).length\n  ), [shapes]);\n\n  const totalPointCount = useMemo(() => (\n    ontologyGroup?.count || 0\n  ), [ontologyGroup]);\n\n  const instancesReviewsMap = useObserver(() => {\n    const map: InstancesReviewsMap = {};\n    store.review.reviews.forEach((review) => {\n      const { frameIndex, instanceId, groupName, shapeIds, result } = review;\n      const category = instances[instanceId]?.category;\n      if (!category) return;\n      if (!map[instanceId]) {\n        map[instanceId] = {};\n      }\n      if (!map[instanceId][frameIndex]) {\n        map[instanceId][frameIndex] = {\n          approveCount: 0,\n          children: {}\n        };\n      }\n      if (!map[instanceId][frameIndex].children[groupName]) {\n        map[instanceId][frameIndex].children[groupName] = {\n          approveCount: 0,\n        };\n      }\n\n      if (result === ReviewResult.REJECT) {\n        map[instanceId][frameIndex].result = result;\n        map[instanceId][frameIndex].children[groupName].result = result;\n      } else if (result === ReviewResult.SUSPEND) {\n        if (map[instanceId][frameIndex].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].result = result;\n        }\n        if (map[instanceId][frameIndex].children[groupName].result !== ReviewResult.REJECT) {\n          map[instanceId][frameIndex].children[groupName].result = result;\n        }\n      } else if (result === ReviewResult.APPROVE) {\n        const len = shapeIds.length;\n        map[instanceId][frameIndex].approveCount += len;\n        map[instanceId][frameIndex].children[groupName].approveCount += len;\n        const ontologyCount = store.ontology.ontologyMap[category];\n        if (map[instanceId][frameIndex].approveCount === ontologyCount.count) {\n          map[instanceId][frameIndex].result = ReviewResult.APPROVE;\n        }\n        if (map[instanceId][frameIndex].children[groupName].approveCount === ontologyCount.children[groupName]) {\n          map[instanceId][frameIndex].children[groupName].result = ReviewResult.APPROVE;\n        }\n      }\n    });\n    return map;\n  });\n\n  useEffect(() => {\n    onLoad();\n  }, []);\n\n  const getInstance = (instanceId: string) => displayedInstances[instanceId];\n\n  const getGroup = (instanceId: string, groupName: string, frameIndex: number = currentFrame) => {\n    const instance = getInstance(instanceId);\n    const group = instance?.children.find((g) => g.name === groupName)?.frames[frameIndex];\n    return group;\n  };\n\n  const getShape = (instanceId: string, groupName: string, id: string | number, frameIndex: number = currentFrame) => {\n    const group = getGroup(instanceId, groupName, frameIndex);\n    return group && group.shapes && (typeof id === 'number' ? (group.shapes as Points)[id] : (group.shapes as CurrentShapes)[id]);\n  };\n\n  const setInstance = (id: string, instance?: InstanceAct) => {\n    setInstances({\n      ...instances,\n      [id]: instance!\n    });\n  };\n\n  const setShape = (frameIndex: number, instanceId: string, groupName: string, id: number | string, shapeType: LandmarkEditType, shape?: Point | Rectangle) => {\n    const instance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (instance) {\n      let group = instance.children.find((g) => g.name === groupName);\n      let currentGroup = group?.frames[frameIndex];\n      if (!group) {\n        group = {\n          name: groupName,\n          shapeType,\n          count: 0,\n          frames: {\n            [frameIndex]: {\n              frameIndex,\n              count: 0,\n              shapes: {}\n            }\n          }\n        };\n        instance.children.push(group);\n        currentGroup = group.frames[frameIndex];\n      } else if (!currentGroup) {\n        group.frames[frameIndex] = {\n          frameIndex,\n          count: 0,\n          shapes: {}\n        };\n        currentGroup = group.frames[frameIndex];\n      }\n      if (currentGroup !== undefined && !currentGroup.shapes) {\n        currentGroup.shapes = {};\n      }\n      let oldShape: Point | Rectangle | undefined;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        oldShape = ((currentGroup as Frame).shapes as Points)[id as number];\n      } else if (shapeType === LandmarkEditType.RECTANGLE) {\n        oldShape = ((currentGroup as Frame).shapes as CurrentShapes)[id];\n      }\n\n      if (!shape && oldShape) {\n        group.count = group.count ? group.count - 1 : 0;\n        (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count - 1 : 0;\n        instance.notEmpty = (instance.notEmpty || 0) - 1;\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          delete ((currentGroup as Frame).shapes as Points)[id as number];\n        } else {\n          delete ((currentGroup as Frame).shapes as CurrentShapes)[id];\n        }\n      } else if (shape) {\n        if (!oldShape) {\n          instance.notEmpty = (instance.notEmpty || 0) + 1;\n          group.count = group.count ? group.count + 1 : 1;\n          (currentGroup as Frame).count = (currentGroup as Frame).count ? (currentGroup as Frame).count + 1 : 1;\n        }\n        (currentGroup as Frame).shapes = {\n          ...(currentGroup as Frame).shapes,\n          [id]: shape\n        };\n      }\n      setInstance(instanceId, instance);\n      const groupInfo = store.ontology.getGroupData(instance.category, groupName);\n      if (groupInfo?.label_config && (currentGroup as Frame).count === groupInfo.count && !(currentGroup as Frame).attributes) {\n        handleFormConfig(groupInfo.label_config, {}, { instanceId, category: instance.category, groupName });\n      }\n    }\n  };\n\n  const updateStatus = async (curr: Status[], prev: Status[]) => {\n    let newUpdatedShapes: UpdatedShape[] = [];\n    let newUpdatedCategories: KeypointCategoryProps[] = [];\n    let updatedHandles: HandleStatus[] = [];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    for (let m = 0; m < prev.length; m += 1) {\n      const item = prev[m];\n      if (item.type === 'shape') {\n        const { frameIndex, instanceId, groupName, category, index, id, shapeType } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        let keyObj: { id: string } | { index: number } | undefined;\n        if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n          keyObj = { index };\n        } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n          keyObj = { id };\n        }\n        if (keyObj) {\n          setShape(frameIndex, instanceId, groupName, Object.values(keyObj)[0], shapeType);\n          newUpdatedShapes.push({ ...frameGroup, ...keyObj, shapeType });\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        if (item.status.shape) {\n          delete newCategoryPathShapes[item.status.pointCategory];\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          const instanceIndex = instanceIds.findIndex((v) => v === id);\n          if (instanceIndex >= 0) {\n            setInstance(id);\n            const selectedIndex = instanceIndex - 1;\n            const newInstance = instances[instanceIds[selectedIndex]];\n            if (newInstance) {\n              selectGroup(newInstance.id, newInstance.children[0].name, false);\n            } else {\n              selectGroup('', '', false);\n            }\n          }\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, frameIndex, groupName, attributes } = item.status;\n        if (attributes) {\n          const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n          const newGroup = newInstance?.children.find((v) => v.name === groupName);\n          if (newInstance && newGroup) {\n            (newGroup.frames[frameIndex] as Frame).attributes = undefined;\n            setInstance(instanceId, newInstance);\n          }\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    for (let n = 0; n < curr.length; n += 1) {\n      const item = curr[n];\n      if (item.type === 'handle') {\n        updatedHandles = item.status;\n      } else if (item.type === 'shape') {\n        const { instanceId, groupName, category, index, id, shapeType, shape, frameIndex } = item.status;\n        const frameGroup: FrameGroup = { frameIndex, instanceId, category, groupName };\n        if (shape) {\n          if (shapeType === LandmarkEditType.KEYPOINT && index !== undefined) {\n            const point = shape as Point;\n            const { pointCategory, isKeyPoint, visible, attributes } = point;\n            setShape(frameIndex, instanceId, groupName, index, shapeType, point);\n            const updateIndex = newUpdatedShapes.findIndex((p) => p.instanceId === instanceId && p.groupName === groupName && p.index === index);\n            const updateShape: Point = {\n              pointCategory,\n              isKeyPoint,\n              visible,\n              ...(point.position && {\n                position: { ...point.position },\n              }),\n              attributes\n            };\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateShape;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, index, shape: updateShape, shapeType });\n            }\n          } else if (shapeType === LandmarkEditType.RECTANGLE && id !== undefined) {\n            const rectangle = shape as Rectangle;\n            const { displayColor, visible, x, y, width, height } = rectangle;\n            setShape(frameIndex, instanceId, groupName, id, LandmarkEditType.RECTANGLE, rectangle);\n            const updateRectangle: Rectangle = {\n              id,\n              x,\n              y,\n              width,\n              height,\n              displayColor,\n              visible,\n            };\n            const updateIndex = newUpdatedShapes.findIndex((rect) => rect.instanceId === instanceId && rect.groupName === groupName && rect.id === id);\n            if (updateIndex >= 0) {\n              newUpdatedShapes[updateIndex].shape = updateRectangle;\n            } else {\n              newUpdatedShapes.push({ ...frameGroup, id, shape: updateRectangle, shapeType });\n            }\n          }\n        }\n      } else if (item.type === 'pointCategory-path-shape') {\n        const { frameIndex, pointCategory, shape } = item.status;\n        const keys = pointCategory.split('_');\n        newUpdatedCategories.push({\n          frameIndex,\n          instanceId: keys[1],\n          groupName: keys[2],\n          category: instances[keys[1]].category,\n          pointCategory: keys[3],\n        });\n        if (shape) {\n          newCategoryPathShapes[pointCategory] = shape;\n        }\n      } else if (item.type === 'instance') {\n        const { id, instance } = item.status;\n        if (instance) {\n          setInstance(id, instance);\n          selectGroup(instance.id, instance.children[0].name, false);\n          const { updateShapes, updatedCategories: newCategories } = getFrameShapes([instance], currentFrame);\n          newUpdatedShapes = [\n            ...newUpdatedShapes,\n            ...updateShapes\n          ];\n          newUpdatedCategories = [\n            ...newUpdatedCategories,\n            ...newCategories\n          ];\n        }\n      } else if (item.type === 'group') {\n        const { instanceId, groupName, attributes, frameIndex } = item.status;\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName);\n        if (newInstance && newGroup) {\n          Object.keys(newGroup.frames[frameIndex].shapes).forEach((id) => {\n            const attrLayer = canvas.current?.getAttrLabelByKey(instanceId, groupName, id);\n            if (attrLayer) {\n              canvas.current?.updateAttributeLabel(instanceId, newInstance.category, groupName, id, attributes);\n            }\n          });\n          (newGroup.frames[frameIndex] as Frame).attributes = attributes;\n          setInstance(instanceId, newInstance);\n        }\n      } else if (item.type === 'reviews') {\n        store.review.setInitialData(item.status);\n      }\n    };\n    await setCategoryPathShapes(newCategoryPathShapes);\n    await setUpdatedCategories(newUpdatedCategories);\n    store.shape.setUpdatedShapes(newUpdatedShapes);\n    store.handle.setUpdatedHandles(updatedHandles);\n  };\n\n  const handleUndo = () => {\n    if (!store.undo.undoDisabled && !isReview) {\n      const item = store.undo.undo();\n      if (item && item.before) {\n        updateStatus(item.before, item.after);\n        notification.success({ message: 'Undo successfully.' });\n      }\n    }\n  };\n\n  const handleRedo = () => {\n    if (!store.undo.redoDisabled && !isReview) {\n      const item = store.undo.redo();\n      if (item && item.after) {\n        updateStatus(item.after, item.before);\n        notification.success({ message: 'Redo successfully.' });\n      }\n    }\n  };\n\n  const handleChangeDrawMode = (mode: boolean) => {\n    if (store.review.isEditable) {\n      canvas.current?.clearHits();\n      if (mode) {\n        setNextEmptyShape();\n      } else {\n        const { instanceId, category, groupName } = selectedShapeStatus;\n        setSelectedShape(undefined, { instanceId, category, groupName });\n      }\n      store.review.setDrawMode(mode);\n    }\n  };\n\n  const loadInitialData = async () => {\n    let data;\n    const { initial_result: initialResult } = props;\n    if (initialResult) {\n      try {\n        data = await fetchResultByUrl(initialResult);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(`Fetch data from ${initialResult} error:`, e);\n      }\n    }\n    return data;\n  };\n\n  const addInstance = async (ontologyName: string) => {\n    const ontologyItem = store.ontology.ontology.find((category) => category.class_name === ontologyName);\n    if (ontologyItem) {\n      const id = uuid();\n      const sameOntologyInstances = instanceList.filter((v) => v.category === ontologyName).reverse();\n      const number = sameOntologyInstances.length ? sameOntologyInstances[0].number + 1 : 1;\n\n      const children = ontologyItem.children.map((v) => ({\n        name: v.name,\n        shapeType: v.type,\n        count: 0,\n        frames: {\n          [currentFrame]: {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {}\n          }\n        }\n      }));\n      const instance = {\n        id,\n        number,\n        displayColor: ontologyItem.display_color,\n        notEmpty: 0,\n        category: ontologyItem.class_name,\n        children\n      };\n      setDefaultInstances({ [id]: instance });\n      await handleInstanceChange({ [id]: instance });\n      if (ontologyItem.children && ontologyItem.children.length > 0) {\n        selectGroup(id, ontologyItem.children[0].name, false, { category: ontologyName, shapeType: ontologyItem.children[0].type });\n      }\n    }\n  };\n\n  const addInstanceInFrame = (instanceId: string, groupName?: string) => {\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      if (groupName) {\n        const groupIdx = newInstance.children.findIndex((group) => group.name === groupName);\n        if (groupIdx >= 0) {\n          let copyFrame: Frame | undefined;\n          Object.keys(newInstance.children[groupIdx].frames).forEach((i) => {\n            const index = Number(i);\n            const frame = { ...newInstance.children[groupIdx].frames[index] };\n            frame.shapes = { ...frame.shapes };\n            if (frame?.count && frame.count > 0) {\n              if (index < currentFrame) {\n                copyFrame = frame;\n              } else if (index > currentFrame && copyFrame === undefined) {\n                copyFrame = frame;\n              }\n            }\n          });\n          if (copyFrame !== undefined) {\n            newInstance.children[groupIdx].frames[currentFrame] = {\n              ...copyFrame,\n              frameIndex: currentFrame\n            };\n            newInstance.children[groupIdx].count += copyFrame.count;\n            newInstance.notEmpty += copyFrame.count;\n          }\n        }\n      } else {\n        let copyFrameIdx: number | undefined;\n        Object.keys(instancesFrames[instanceId]).forEach((i) => {\n          const index = Number(i);\n          if (index < currentFrame) {\n            copyFrameIdx = index;\n          } else if (index > currentFrame && copyFrameIdx === undefined) {\n            copyFrameIdx = index;\n          }\n        });\n        if (copyFrameIdx !== undefined) {\n          newInstance.children.forEach((group) => {\n            const copyFrame = { ...group.frames[copyFrameIdx as number] };\n            copyFrame.shapes = { ...copyFrame.shapes };\n            if (copyFrame) {\n              group.count += copyFrame.count;\n              newInstance.notEmpty += group.count;\n              group.frames[currentFrame] = {\n                ...copyFrame,\n                frameIndex: currentFrame\n              };\n            }\n          });\n        }\n      }\n      const { updateShapes, updatedCategories: newUpdatedCategories } = getFrameShapes([newInstance], currentFrame);\n      handleInstanceChange({ [instanceId]: newInstance });\n      setUpdatedCategories(newUpdatedCategories);\n      store.shape.setUpdatedShapes(updateShapes);\n    }\n  };\n\n  const removeInstanceFrames = (type: DELETETYPE, instance: InstanceAct, name?: string) => {\n    if (instance) {\n      let delShapes: UpdatedShape[] = [];\n      const newInstance = cloneDeep(instance);\n      const update = (updateInstance: InstanceAct, frameIndex: number) => {\n        updateInstance.children.forEach((group) => {\n          if ((name && name === group.name) || !name) {\n            if (group.frames[frameIndex] !== undefined) {\n              group.count -= (group.frames[frameIndex] as Frame).count;\n              delete group.frames[frameIndex];\n            }\n          }\n        });\n      };\n      if (type === DELETETYPE.CURRENT) {\n        const { updateShapes } = getFrameShapes([instance], currentFrame, true);\n        delShapes = updateShapes;\n        update(newInstance, currentFrame);\n      } else if (type === DELETETYPE.FOLLOW || type === DELETETYPE.ALL) {\n        const diffFrame = type === DELETETYPE.FOLLOW ? currentFrame : 0;\n        Array.from({ length: frames.length - diffFrame }).forEach((_, i) => {\n          const frameIndex = i + diffFrame;\n          const { updateShapes } = getFrameShapes([instance], frameIndex, true);\n          delShapes = [\n            ...delShapes,\n            ...updateShapes\n          ];\n          update(newInstance, frameIndex);\n        });\n      }\n      if (name) {\n        delShapes = delShapes.filter((v) => v.groupName === name);\n      }\n      newInstance.notEmpty -= delShapes.length;\n      store.shape.setUpdatedShapes(delShapes);\n      handleInstanceChange({ [newInstance.id]: newInstance });\n    }\n  };\n\n  const handleInstanceChange = async (\n    newInstances: {[id: string] : InstanceAct},\n    status?: {before: Status[], after: Status[]}\n  ) => {\n    const ids = Object.keys(newInstances);\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    if (ids.length > 0) {\n      ids.forEach(async (id) => {\n        const oldInstance = instances[id] ? cloneDeep(instances[id]) : undefined;\n        let isRemove = true;\n        newInstances[id].children.forEach((child) => {\n          if (Object.keys(child.frames).length > 0) {\n            isRemove = false;\n          }\n        });\n        before.push({ type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: oldInstance,\n          }\n        });\n        after.push({ type: 'instance',\n          status: {\n            frameIndex: currentFrame,\n            id,\n            instance: isRemove ? undefined : newInstances[id]\n          }\n        });\n        setInstance(id, isRemove ? undefined : newInstances[id]);\n      });\n    }\n    store.undo.saveStatus(before, after);\n  };\n\n  const onLoad = async () => {\n    setLoading(true);\n    setReadOnly(isPreview(props.jobProxy.toolMode));\n\n    // i18n\n    i18n.setLocale(props.locale);\n\n    // init payload\n    await store.init(props);\n\n    let result;\n    let initialData: any;\n    let initInstancesData;\n    try {\n      result = await props.jobProxy.loadResult();\n      initialData = await loadInitialData();\n    } catch (e) {\n      notification.error({ message: formatMessage('ANNOTATION_DATA_LOAD_ERROR'), duration: null });\n      return;\n    }\n\n    // parse frames\n    const framesData = await parseFramesByPaylod({ frames: props.image, imageData: result?.images as Image[] });\n    // preload image\n    setImagePreloader(loader(framesData.map((v) => v.url)));\n    // set frame images\n    setFrames(framesData);\n\n    if (result) {\n      if (Array.isArray(result)) {\n        // legacy data\n        if (result[0] && result[0].position) {\n          initInstancesData = initInstances(result, framesData.length);\n        } else {\n          initInstancesData = result;\n        }\n      }\n      if (result.auditId) {\n        props.jobProxy.setAuditId(result.auditId);\n      }\n      if (result.instances) {\n        initInstancesData = result.instances;\n      } else if (result.points) {\n        initInstancesData = initInstances(result.points, framesData.length);\n      }\n      // if (Array.isArray(result.handles)) {\n      //   store.handle.init(result.handles);\n      // }\n\n      if (result.categoryPathShapes) {\n        const newCategoryPathShapes: { [categoryKey: string]: CategoryPathShape } = {};\n        result.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          newCategoryPathShapes[pointCategory] = shape;\n        });\n        setCategoryPathShapes(newCategoryPathShapes);\n      }\n      setImageSize({\n        width: result.width,\n        height: result.height,\n      });\n    }\n\n    // load reviews\n    // await loadReviews();\n    if (initialData) {\n      if (initialData.categoryPathShapes) {\n        const initialCategoryPathShapesData: { [key: string]: CategoryPathShape } = {};\n        initialData.categoryPathShapes.forEach(({ pointCategory, shape }: { pointCategory: string; shape: CategoryPathShape }) => {\n          initialCategoryPathShapesData[pointCategory] = shape;\n        });\n        setInitialCategoryPathShapes(initialCategoryPathShapesData);\n      }\n      let initialInstancesData;\n      if (initialData.instances) {\n        initialInstancesData = initialData.instances;\n      } else if (initialData.points) {\n        initialInstancesData = initInstances(result.points, framesData.length);\n      }\n      const { newInstances, categoryInstancesMap: newCategoryInstancesMap } = loadInstancesFromResult(initialInstancesData);\n      setInitialInstances(newInstances);\n      setInitialCategoryInstancesMap(newCategoryInstancesMap);\n    }\n    let currentInstances: {[id: string]: InstanceAct} = {};\n    if (Array.isArray(initInstancesData) && initInstancesData.length > 0) {\n      const { newInstances } = loadInstancesFromResult(initInstancesData);\n      await setDefaultInstances(newInstances);\n      await setInstances(newInstances);\n      currentInstances = newInstances;\n    }\n    setLoading(false);\n    setFrame(0, currentInstances);\n    saverRef.current?.setTempSaved(true);\n    // render completed\n    props.renderComplete();\n  };\n\n  /**\n   * set current frame\n   * @param frame\n   */\n  const setFrame = async (frameIndex: number, currentInstances: {[id: string]: InstanceAct} | undefined = instances, type?: CANVASSTATUS) => {\n    if (frameIndex === currentFrame && type !== CANVASSTATUS.INITIAL) {\n      return;\n    }\n    const currentInstanceList = Object.values(currentInstances);\n    canvas.current?.cleanLayer();\n    canvas.current?.setMultiShapesUnselected();\n    imagePreloader?.preload(frameIndex);\n    await setCurrentFrame(frameIndex);\n    let currentShapeStatus = {\n      ...selectedShapeStatus,\n      frameIndex,\n    };\n    if (!currentShapeStatus.groupName && currentInstanceList.length > 0) {\n      const { id, category, children: [{ name }] } = currentInstanceList[0];\n      const group = store.ontology.getGroupData(category, name);\n      currentShapeStatus = {\n        ...currentShapeStatus,\n        instanceId: id,\n        category,\n        groupName: name,\n        shapeType: group?.type,\n      };\n      setSelectedOntologyGroup(name);\n    }\n    setSelectedShapeStatus(currentShapeStatus);\n    const { updateShapes, updatedCategories: updatedCategoriesData } = getFrameShapes(currentInstanceList, frameIndex);\n    setUpdatedCategories(updatedCategoriesData);\n    store.shape.setUpdatedShapes(updateShapes);\n    store.handle.changeFrame(frameIndex);\n  };\n\n  /**\n   * set visible review data\n   */\n  const setReview = async () => {\n    if (initialInstances && Object.keys(initialInstances).length > 0) {\n      const newIsReview = !isReview;\n      const displayInstances = newIsReview ? initialInstances : instances || {};\n      await setDefaultInstances(displayInstances);\n      setFrame(currentFrame, displayInstances, CANVASSTATUS.INITIAL);\n      setIsReview(newIsReview);\n    }\n  };\n\n  const onSave = async (submit = true) => {\n    if (loading) {\n      const loadError = formatMessage('ERROR_DATA_LOAD');\n      notification.error({ message: loadError });\n      throw new Error(loadError);\n    }\n\n    saverRef.current?.disableLeaveCheck();\n    if (submit) {\n      if (store.setting.submitCheck) {\n        // validate before submit\n        const passed = await triggerValidation();\n        if (!passed) {\n          throw new Error(formatMessage('SUBMIT_CHECK_FAIL'));\n        }\n      }\n    }\n    const checkMissingPoints = props.check_missing_points === true && submit === true;\n    const newInstances: InstanceListItem[] = instanceList.filter((v) => v && v.notEmpty).map((instance) => {\n      const { id, category, number, displayColor, children } = instance;\n      const ontologyInfo = store.ontology.getOntologyInfo(category);\n      return {\n        id,\n        category,\n        number,\n        displayColor,\n        children: children.map((group) => {\n          const { frames: groupFrames } = group;\n          return {\n            ...group,\n            frames: Object.values(groupFrames).filter((v) => !!v && v.count > 0).map((frameGroup) => {\n              if (frameGroup) {\n                const { frameIndex, count, shapes: groupShapes } = frameGroup;\n                const groupInfo = store.ontology.getGroupData(instance.category, group.name);\n                const newShapes: PointListItem[] | Rectangle[] = [];\n                if (groupShapes) {\n                  Object.keys(groupShapes).forEach((key) => {\n                    if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                      const pointIndex = parseInt(key, 10);\n                      const point: PointListItem | undefined = groupShapes && (groupShapes as Points)[pointIndex];\n                      if (point) {\n                        point.index = pointIndex;\n                        (newShapes as PointListItem[]).push(point);\n                      }\n                    } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                      const rectangle: Rectangle | undefined = groupShapes && (groupShapes as CurrentShapes)[key];\n                      if (rectangle) (newShapes as Rectangle[]).push(rectangle);\n                    }\n                  });\n                }\n                if (\n                  checkMissingPoints &&\n                  frames[frameIndex].valid !== false &&\n                  groupInfo &&\n                  newShapes.length < groupInfo.count\n                ) {\n                  const errMsg = formatMessage('ERROR_INCOMPLETE', {\n                    values: {\n                      frameIndex: frameIndex + 1,\n                      class_name: ontologyInfo?.display_name || ontologyInfo?.class_name,\n                      index: `${instance.number}`,\n                      name: group.name,\n                      annotated: `${count}`,\n                      total: `${groupInfo.count}`\n                    }\n                  });\n                  notification.error({ message: errMsg });\n                  throw new Error(errMsg);\n                }\n                return {\n                  ...frameGroup,\n                  shapes: newShapes\n                };\n              }\n              return undefined;\n            })\n          };\n        })\n      };\n    });\n    const statData = getInstanceStatistics();\n    const statistics = await props.jobProxy.saveResultStat(statData);\n    const handles = store.handle.getHandles();\n    return props.jobProxy.saveResult({\n      auditId: props.jobProxy.auditId,\n      width: canvas.current?.imageCanvas?.width || imageSize?.width,\n      height: canvas.current?.imageCanvas?.height || imageSize?.height,\n      instances: newInstances,\n      handles,\n      categoryPathShapes: Object.keys(categoryPathShapes).map((pointCategory) => ({\n        pointCategory,\n        shape: categoryPathShapes[pointCategory],\n      })),\n      images: frames,\n      statistics,\n    }, submit);\n  };\n\n  /**\n   * get review statistics\n   */\n  const getStatistics = () => {\n    const statShapes: {\n      [shape: string]: { rejected: number; approved: number, suspended: number, missed: number, total: number };\n    } = {};\n    const objects = {\n      total: 0,\n      approved: 0,\n      rejected: 0,\n      suspended: 0,\n      missed: 0,\n    };\n    const reviews = store.review.reviews.filter((r) => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const instance = instancesList[i];\n      for (let j = 0; j < instance.children.length; j += 1) {\n        const item = instance.children[j];\n        const shape = item.shapeType;\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          if (!statShapes[shape]) {\n            statShapes[shape] = {\n              rejected: 0,\n              approved: 0,\n              suspended: 0,\n              missed: 0,\n              total: 0\n            };\n          }\n          const frameReviews = reviews.filter((r) => r.frameIndex === frame.frameIndex && r.instanceId === instance.id && r.groupName === item.name);\n          const frameShapes = Object.keys(frame.shapes);\n          for (let l = 0; l < frameShapes.length; l += 1) {\n            statShapes[shape].total += 1;\n            objects.total += 1;\n            const shapeId = shape === LandmarkEditType.KEYPOINT ? Number(frameShapes[l]) : frameShapes[l];\n            const review = frameReviews.find((r) => r.shapeIds.indexOf(shapeId) >= 0);\n            if (review?.result === ReviewResult.REJECT) {\n              statShapes[shape].rejected += 1;\n              objects.rejected += 1;\n            } else if (review?.result === ReviewResult.SUSPEND) {\n              statShapes[shape].suspended += 1;\n              objects.suspended += 1;\n            } else {\n              statShapes[shape].approved += 1;\n              objects.approved += 1;\n            }\n          }\n        }\n      }\n    }\n    return { objects, shapes: statShapes };\n  };\n\n  /**\n   * get instance statistics\n   */\n  const getInstanceStatistics = () => {\n    const { ontology } = store.ontology;\n    const data: Statistic = {\n      elements: [],\n      categories: ontology.map(({ class_name: className }) => className),\n      shapes: new Set(),\n      summary: {},\n      frameCount: frames.length,\n      annotatedFrames: new Set(),\n    };\n\n    const instancesList = Object.values(instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, category, children } = instancesList[i];\n      for (let j = 0; j < children.length; j += 1) {\n        const item = children[j];\n        const itemFrames = Object.values(item.frames);\n        for (let k = 0; k < itemFrames.length; k += 1) {\n          const frame = itemFrames[k];\n          const frameShapes = Object.values(frame.shapes);\n          const shape = item.shapeType;\n          data.shapes.add(shape);\n          const key = `${shape}_${category}`;\n          if (!data.summary[key]) {\n            data.summary[key] = {\n              ids: [],\n              category,\n              shape,\n              count: 0,\n              distinctCount: 0,\n            };\n          }\n          const shapeCount = frameShapes.length;\n          if (shapeCount > 0) {\n            data.summary[key].count += shapeCount;\n            if (!data.summary[key].ids.includes(id)) {\n              data.summary[key].distinctCount += shapeCount;\n              data.summary[key].ids.push(id);\n            }\n            data.annotatedFrames.add(frame.frameIndex);\n            data.elements.push(\n              ...frameShapes.map((s) => ({\n                instance: id,\n                shape,\n                frame: frame.frameIndex + 1,\n                category,\n                id: s.id || s.index,\n              }))\n            );\n          }\n        }\n      }\n    }\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n      summary: Object.values(data.summary).map(({ category, shape, count, distinctCount }) => ({\n        category,\n        shape,\n        count,\n        distinctCount,\n      })),\n      annotatedFrames: Array.from(data.annotatedFrames),\n      annotatedFrameCount: data.annotatedFrames.size,\n    };\n  };\n\n  const loadReviews = async () => {\n    const reviews = await props.jobProxy.loadReviews();\n    store.review.setInitialData(reviews);\n  };\n\n  const saveReviews = (type = 'submit') => {\n    if (type === 'submit') {\n      const hasSuspend = store.review.reviews.find((review) => review.result === ReviewResult.SUSPEND);\n      if (hasSuspend) {\n        throw new Error(formatMessage('QC_SUSPEND_ERROR'));\n      }\n    }\n    saverRef.current?.disableLeaveCheck();\n    return props.jobProxy.saveReviews(store.review.reviews, type === 'submit');\n  };\n\n  const handleSave = async () => {\n    const { toolMode } = props.jobProxy;\n    if (isPreview(toolMode)) {\n      return;\n    }\n\n    try {\n      if (!isAnnotationReadonly(toolMode)) {\n        await onSave(false);\n      }\n      if (store.review.isEnabled) {\n        await saveReviews('save');\n      }\n      notification.success({ message: formatMessage('SAVE_SUCCESS') });\n    } catch (e) {\n      notification.error({ message: formatMessage('SAVE_FAIL') });\n    }\n  };\n\n  /**\n   * trigger validation, return passed or not\n   */\n  const triggerValidation = async () => {\n    if (validatorRef.current) {\n      const { hasCustomError, blockSubmitErrors } = await validatorRef.current.handleSync();\n      return !hasCustomError && blockSubmitErrors.length <= 0; // no script error & no block submit errors\n    }\n    return true;\n  };\n\n  const setSelectedShape = (id?: number | string, groupData?: Group) => {\n    let newSelectedShapeStatus = cloneDeep(selectedShapeStatus);\n    newSelectedShapeStatus.id = id;\n    if (groupData) {\n      const { instanceId, category, groupName, shapeType } = groupData;\n      if (instanceId !== selectedInstance?.id) {\n        selectGroup(instanceId, groupName, false);\n      } else if (groupName !== selectedOntologyGroup) {\n        setSelectedOntologyGroup(groupName);\n      }\n      newSelectedShapeStatus = {\n        ...newSelectedShapeStatus,\n        instanceId,\n        category,\n        shapeType: shapeType || ontologyGroup?.type || undefined,\n        groupName,\n      };\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n  };\n\n  const setNextEmptyShape = (shapeStatus: ShapeInfo = selectedShapeStatus) => {\n    if (shapeStatus) {\n      let { id } = shapeStatus;\n      const { instanceId, groupName, shapeType } = shapeStatus;\n      if (shapeType === LandmarkEditType.KEYPOINT) {\n        let categoryScannedCount = 0;\n        let categoryIndex = selectedCategoryIndex >= 0 ? selectedCategoryIndex : 0;\n        id = shapeStatus.id;\n        while (categories.length > 0 && categoryScannedCount <= categories.length) {\n          const { range = [] } = categories[categoryIndex];\n          if (id === undefined || id === -1) {\n            id = range[0] - 1;\n          }\n          if (id !== range[1]) {\n            (id as number) += 1;\n          } else {\n            categoryIndex = categoryIndex < categories.length - 1 ? categoryIndex + 1 : 0;\n            categoryScannedCount += 1;\n            id = categories[categoryIndex].range[0] || 0;\n          }\n          if (!instanceId || getShape(instanceId, groupName, id!) === undefined) {\n            break;\n          }\n        }\n      } else if (ontologyGroup) {\n        id = undefined;\n      }\n      setSelectedShapeStatus({\n        ...shapeStatus,\n        id\n      });\n    }\n  };\n\n  const onCategoriesUpdated = () => {\n    setUpdatedCategories([]);\n  };\n\n  const handleShapesChange = (\n    newShapes: UpdatedShape[],\n    groupsAttributes?: { instanceId: string, category: string, name: string, attributes: any }[],\n    status?: {before: Status[], after: Status[]}\n  ) => {\n    if (newShapes.length === 0) {\n      return;\n    }\n    const before: Status[] = status ? status.before : [];\n    const after: Status[] = status ? status.after : [];\n    const { instanceId, groupName } = newShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    const groupInfo = store.ontology.getGroupData(newInstance?.category || '', groupName);\n    newInstance?.children.forEach((child) => {\n      if (child.name === groupName) {\n        if (!child.frames[currentFrame]) {\n          child.frames[currentFrame] = {\n            frameIndex: currentFrame,\n            count: 0,\n            shapes: {},\n          };\n        };\n        const currentGroup = child.frames[currentFrame];\n        for (let i = 0; i < newShapes.length; i += 1) {\n          const { id, frameIndex, index, shape } = newShapes[i];\n          let oldShape;\n\n          if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n            oldShape = (child.frames[frameIndex].shapes as Points)[index];\n            (child.frames[frameIndex].shapes as Points)[index] = {\n              ...oldShape,\n              ...shape as Point\n            };\n          } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n            oldShape = (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            (child.frames[frameIndex].shapes as CurrentShapes)[id] = {\n              ...oldShape,\n              ...shape as Rectangle\n            };\n          }\n\n          if (!shape && oldShape) {\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          } else if (shape && !oldShape) {\n            child.count = child.count ? child.count + 1 : 1;\n            currentGroup.count = currentGroup.count ? currentGroup.count + 1 : 1;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) + 1;\n          }\n        };\n        if (groupInfo?.label_config && currentGroup.count === groupInfo?.count && !currentGroup.attributes) {\n          handleFormConfig(groupInfo.label_config, {}, { instanceId, category: newInstance.category, groupName });\n        }\n      }\n    });\n    if (groupsAttributes && groupsAttributes.length > 0) {\n      groupsAttributes.forEach(({ instanceId: id, name, category, attributes }) => {\n        const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId: id, category, groupName: name };\n        before.push({ type: 'group', status: { ...frameGroup } });\n        after.push({ type: 'group', status: { ...frameGroup, attributes } });\n      });\n    }\n    if (newInstance) {\n      handleInstanceChange({ [instanceId]: newInstance }, { before, after });\n    } else {\n      store.undo.saveStatus(before, after);\n    }\n  };\n\n  const handleShapesRemove = (removeShapes: UpdatedShape[]) => {\n    if (removeShapes.length === 0) {\n      return;\n    }\n\n    const changeInstances: { [id: string]: InstanceAct } = {};\n    const { instanceId, groupName } = removeShapes[0];\n    const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n    if (newInstance) {\n      newInstance?.children.forEach((child) => {\n        if (child.name === groupName) {\n          const currentGroup = child.frames[currentFrame];\n          removeShapes.forEach(({ id, frameIndex, index }) => {\n            if (child.shapeType === LandmarkEditType.KEYPOINT && typeof index === 'number') {\n              delete (child.frames[frameIndex].shapes as Points)[index];\n            } else if (child.shapeType === LandmarkEditType.RECTANGLE && typeof id === 'string') {\n              delete (child.frames[frameIndex].shapes as CurrentShapes)[id];\n            }\n            child.count = child.count ? child.count - 1 : 0;\n            currentGroup.count = currentGroup.count ? currentGroup.count - 1 : 0;\n            newInstance.notEmpty = (newInstance.notEmpty || 0) - 1;\n          });\n        }\n      });\n      changeInstances[instanceId] = newInstance;\n      handleInstanceChange({ [instanceId]: newInstance });\n    }\n  };\n\n  const togglePointsVisibility = (points: PointStatus[]) => {\n    const list: UpdatedShape[] = [];\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = getShape(instanceId, groupName, index);\n      if (point) {\n        list.push({\n          frameIndex: selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index,\n          shapeType: LandmarkEditType.KEYPOINT,\n          shape: { ...point, visible: !point.visible }\n        });\n      }\n    });\n    handleShapesChange(list);\n  };\n\n  const setCategoryPathShape = (categoryKey: string, shapeType?: CategoryPathShape, _updatedShapes?: UpdatedShape[]) => {\n    const before: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: categoryPathShapes[categoryKey] },\n    }];\n    const after: Status[] = [{\n      type: 'pointCategory-path-shape',\n      status: { frameIndex: selectedShapeStatus.frameIndex, pointCategory: categoryKey, shape: shapeType },\n    }];\n    const newCategoryPathShapes = cloneDeep(categoryPathShapes);\n    if (shapeType && _updatedShapes) {\n      newCategoryPathShapes[categoryKey] = shapeType;\n      handleShapesChange(_updatedShapes, undefined, { before, after });\n    } else {\n      delete newCategoryPathShapes[categoryKey];\n      store.undo.saveStatus(before, after);\n    }\n    setCategoryPathShapes(newCategoryPathShapes);\n  };\n\n  const selectGroup = (id: string, groupName: string, isFit = true, groupData?: { category: string, shapeType: LandmarkEditType }) => {\n    const instance = isReview ? initialInstances[id] : instances[id];\n    const newSelectedShapeStatus:ShapeInfo = {\n      frameIndex: currentFrame,\n      instanceId: id,\n      category: groupData?.category || selectedShapeStatus.category,\n      groupName,\n      shapeType: groupData?.shapeType || undefined,\n      id: undefined\n    };\n    if (instance) {\n      const ontologyItem = store.ontology.ontology.find((v) => v.class_name === instance.category);\n      const group = ontologyItem?.children.find((v) => v.name === groupName);\n      newSelectedShapeStatus.category = instance.category;\n      newSelectedShapeStatus.shapeType = group?.type || undefined;\n      if (isDrawMode) {\n        if (group?.type === LandmarkEditType.KEYPOINT) {\n          const index = (group.categories && group.categories[0] && group.categories[0].range[0]) || 0;\n          // set selected to the empty\n          newSelectedShapeStatus.id = index;\n        } else if (group?.type === LandmarkEditType.RECTANGLE) {\n          instance.children.forEach((child) => {\n            if (child.name === groupName && child.frames[currentFrame]?.shapes) {\n              const rectangles = child.frames[currentFrame].shapes;\n              newSelectedShapeStatus.id = Object.keys(rectangles)[0];\n            }\n          });\n        }\n      }\n      canvas.current?.updateGroupBox(id, instance.category, groupName);\n      if (isFit) {\n        canvas.current?.fitSelected(id, groupName);\n      }\n    }\n    setSelectedShapeStatus(newSelectedShapeStatus);\n    setSelectedOntologyGroup(groupName);\n  };\n\n  const editShapeForm = () => {\n    const { instanceId, groupName, shapeType, id, category } = selectedShapeStatus;\n    if (shapeType === LandmarkEditType.KEYPOINT) {\n      const point = getShape(instanceId, groupName, (id as number));\n      const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n      if (point && currentOntologyGroup?.point_label_config) {\n        handleFormConfig(currentOntologyGroup.point_label_config, (point as Point).attributes || {}, { instanceId, category, groupName }, (id as number), point);\n      }\n    }\n  };\n\n  const editGroupForm = () => {\n    const { instanceId, groupName, category } = selectedShapeStatus;\n    const group = getGroup(instanceId, groupName);\n    const currentOntologyGroup = store.ontology.getGroupData(category, groupName);\n    if (group && currentOntologyGroup?.label_config) {\n      handleFormConfig(currentOntologyGroup.label_config, group.attributes || {}, { instanceId, category, groupName });\n    }\n  };\n\n  const handleFormConfig = (config: FormConfig, values: {[attr: string]: any;}, group: Group, index?: number, point?: Point) => {\n    setFormConfig(config);\n    setFormValues(values);\n    setEditFormObject({\n      ...group,\n      index,\n      point,\n    });\n    let title = getShapeLabel(group.instanceId, group.category, group.groupName) || formatMessage('EDIT_ATTRIBUTES');\n    if (index !== undefined) {\n      title = `${title} [${index}]`;\n    }\n    attributesRef.current?.showModal(title);\n  };\n\n  const getShapeLabel = (instanceId: string, category: string, groupName: string) => {\n    let title = '';\n    if (displayedInstances) {\n      const instance = instances[instanceId];\n      const groupData = store.ontology.getGroupData(category, groupName);\n      if (instance && groupData) {\n        title = `${formatMessage('VALIDATION_FRAME', { values: { frameIndex: currentFrame + 1 } })}${groupData.class_display_name || ''}${instance.number || ''}-${groupData.display_name || groupData.name}`;\n      }\n    }\n    return title;\n  };\n\n  const setAttributes = (values: any) => {\n    if (editFormObject) {\n      const { instanceId, category, groupName, index, point } = editFormObject;\n      const before: Status[] = [];\n      const after: Status[] = [];\n      const frameGroup: FrameGroup = { frameIndex: currentFrame, instanceId, category, groupName };\n      if ((index || index === 0) && point) {\n        const oldPoint = getShape(instanceId, groupName, index);\n        const newPoint = { ...oldPoint, ...point, attributes: values };\n        setShape(currentFrame, instanceId, groupName, index, LandmarkEditType.KEYPOINT, newPoint);\n        before.push({ type: 'shape', status: { ...frameGroup, index, shape: oldPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        after.push({ type: 'shape', status: { ...frameGroup, index, shape: newPoint, shapeType: LandmarkEditType.KEYPOINT } });\n        canvas.current?.updateAttributeLabel(instanceId, category, groupName, index, values);\n      } else {\n        const newInstance = instances[instanceId] ? cloneDeep(instances[instanceId]) : undefined;\n        const newGroup = newInstance?.children.find((v) => v.name === groupName)?.frames[currentFrame];\n        const oldGroup = getGroup(instanceId, groupName);\n        const ontologyChild = store.ontology.getGroupData(category, groupName);\n        if (newInstance && newGroup && ontologyChild) {\n          const oldAttrs = oldGroup?.attributes;\n          newGroup.attributes = values;\n          setInstance(instanceId, newInstance);\n          before.push({ type: 'group', status: { ...frameGroup, attributes: oldAttrs } });\n          after.push({ type: 'group', status: { ...frameGroup, attributes: values } });\n          if (oldGroup?.shapes) {\n            if (ontologyChild.type === LandmarkEditType.RECTANGLE) {\n              Object.keys(oldGroup.shapes).forEach((id) => {\n                canvas.current?.updateAttributeLabel(instanceId, category, groupName, id, values, newInstance.number);\n              });\n            }\n          }\n        }\n      }\n      if (before.length > 0) {\n        store.undo.saveStatus(before, after);\n      }\n    }\n    setFormConfig(null);\n    setFormValues(null);\n    setEditFormObject(null);\n  };\n\n  /**\n   * set active attributes mode\n   * @param activeMode\n   * @param type point or object\n   */\n  const onAttributesModeChanges = (activeMode: AttributesMode, type = 'object') => {\n    canvas.current?.updatelabelVisible(activeMode, type);\n  };\n\n  const onSizeChange = () => {\n    canvas.current?.resizeShapes();\n  };\n\n  const onFilterChange = () => {\n    canvas.current?.updateFilters();\n  };\n\n  const onLabelModeChange = () => {\n    if (canvas.current?.labelLayer) {\n      canvas.current.labelLayer.visible = store.setting.labelMode;\n    }\n  };\n\n  const onGridVisibleChange = () => {\n    if (canvas.current?.gridLayer) {\n      canvas.current.gridLayer.visible = store.setting.isGridVisible;\n    }\n  };\n\n  const setFrameValid = (frame: number, valid: boolean) => {\n    const newFramesData = cloneDeep(frames);\n    newFramesData[frame].valid = valid;\n    setFrames(newFramesData);\n  };\n\n  useImperativeHandle(ref, () => ({\n    onSave,\n    saveReviews,\n    getStatistics,\n  }));\n\n  return (\n    <Observer>\n      {() => (\n        <div className=\"landmark-annotation-app\">\n          <AutoSaver\n            ref={saverRef}\n            leaveCheck\n            data={{ instance: instances, reviews: store.review.qaWarnings }}\n            save={handleSave}\n          />\n          <Toolbar\n            readonly={readonly || loading || isReview}\n            isReview={isReview}\n            isPreview={readonly}\n            initialDataLength={Object.keys(initialInstances).length}\n            onAttributesModeChanges={onAttributesModeChanges}\n            onSizeChange={onSizeChange}\n            onFilterChange={onFilterChange}\n            onLabelModeChange={onLabelModeChange}\n            onGridVisibleChange={onGridVisibleChange}\n            onSave={handleSave}\n            handleUndo={handleUndo}\n            handleRedo={handleRedo}\n            setReview={setReview}\n            handleChangeDrawMode={handleChangeDrawMode}\n          />\n          <div\n            className=\"container\"\n            style={{\n              height: `calc(100% - ${(frames.length > 1 && currentFrame >= 0) ? `${frameControlHeight + 35}px` : '35px'})`,\n              transition: 'height 0.15s',\n            }}\n          >\n            <TabMenu\n              tabs={[\n                {\n                  title: formatMessage('MENU_INSTANCE'),\n                  key: 'instance',\n                  count: 0,\n                  content: (\n                    <SideMenus\n                      readonly={readonly || loading || isReview || !isDrawMode}\n                      loading={loading}\n                      instances={instanceList}\n                      currentFrame={currentFrame}\n                      instancesFrames={instancesFrames}\n                      selectedInstance={selectedInstance}\n                      selectedOntologyGroup={selectedOntologyGroup}\n                      instancesReviewsMap={instancesReviewsMap}\n                      addInstance={addInstance}\n                      selectGroup={selectGroup}\n                      addInstanceInFrame={addInstanceInFrame}\n                      removeInstanceFrames={removeInstanceFrames}\n                    />\n                  )\n                },\n                // {\n                //   title: formatMessage('MENU_WARNING'),\n                //   key: 'validator',\n                //   count: store.review.warnings.length,\n                //   content: (\n                //     <Validator\n                //       ref={validatorRef}\n                //       instances={instances}\n                //       jobProxy={props.jobProxy}\n                //       getScriptResult={getScriptResult}\n                //       warnings={store.review.warnings || []}\n                //       setFrame={setFrame}\n                //       setSelectedShape={setSelectedShape}\n                //       selectGroup={selectGroup}\n                //       getInstance={getInstance}\n                //       saveResult={() => onSave(false)}\n                //     />\n                //   )\n                // }\n              ]}\n            />\n            {selectedInstance && ontologyGroup && !isReview && (\n              <Board\n                categories={categories}\n                categoryPathShapes={displayedCategoryPathShapes}\n                points={shapes}\n                ontologyGroup={ontologyGroup}\n                selectedShapeStatus={selectedShapeStatus}\n                annotated={annotatedPointOrShapeCount}\n                total={totalPointCount}\n                drawMode={isDrawMode}\n                setSelectedShape={(id) => {\n                  const { instanceId, category, groupName } = selectedShapeStatus;\n                  setSelectedShape(id, { instanceId, category, groupName });\n                }}\n                frameControlHeight={frameControlHeight}\n                readonly={loading}\n                instanceReviewsMap={store.review.frameReviewsMap[currentFrame]}\n              />\n            )}\n            <Canvas\n              ref={canvas}\n              readonly={readonly}\n              loading={loading}\n              isReview={isReview}\n              currentFrame={currentFrame}\n              image={frames[currentFrame]?.url}\n              categories={categories}\n              selectedInstance={selectedInstance}\n              selectedGroupName={selectedOntologyGroup}\n              ontologyGroup={ontologyGroup}\n              annotatedPointOrShapeCount={annotatedPointOrShapeCount}\n              updatedCategories={updatedCategories}\n              defaultInstances={defaultInstances}\n              selectedShapeStatus={selectedShapeStatus}\n              selectedShapeInfo={selectedShapeInfo}\n              changeLoading={setLoading}\n              selectGroup={selectGroup}\n              setSelectedShape={setSelectedShape}\n              handleShapesChange={handleShapesChange}\n              onCategoriesUpdated={onCategoriesUpdated}\n              handleShapesRemove={handleShapesRemove}\n              togglePointsVisibility={togglePointsVisibility}\n              setNextEmptyShape={setNextEmptyShape}\n              editShapeForm={editShapeForm}\n              editGroupForm={editGroupForm}\n              onSave={handleSave}\n              getInstance={getInstance}\n              categoryPathShapes={displayedCategoryPathShapes}\n              setCategoryPathShape={setCategoryPathShape}\n              handleUndo={handleUndo}\n              handleRedo={handleRedo}\n              setReview={setReview}\n              handleChangeDrawMode={handleChangeDrawMode}\n            />\n            <div className=\"arributes-panel\">\n              {selectedShapeStatus.groupName && (\n                <Information\n                  pointCategory={(categories[selectedCategoryIndex] || {}).name}\n                  point={selectedShapeStatus}\n                  annotated={annotatedPointOrShapeCount}\n                  total={totalPointCount}\n                />\n              )}\n              {frames[currentFrame]?.url && (\n                <FrameAttributes\n                  currentFrame={currentFrame}\n                  currentFrameValid={frames[currentFrame].valid}\n                  setFrameValid={setFrameValid}\n                />\n              )}\n            </div>\n            <Attributes\n              ref={attributesRef}\n              readonly={readonly || isReview || !isDrawMode}\n              config={formConfig}\n              values={formValues}\n              onValuesChange={setAttributes}\n            />\n          </div>\n          {(frames.length > 1 && currentFrame >= 0) && (\n            <FrameControl\n              frames={frames}\n              frameLoading={loading}\n              currentFrame={currentFrame}\n              categoryInstancesMap={displayedCategoryInstancesMap}\n              instancesReviewsMap={instancesReviewsMap}\n              instances={displayedInstances}\n              selectedInstance={selectedInstance}\n              selectedInstanceGroup={selectedOntologyGroup}\n              selectGroup={selectGroup}\n              setFrame={setFrame}\n              onHeightChange={setFrameControlHeight}\n            />\n          )}\n          {store.review.selectedReview && (\n            <QualityControl\n              review={store.review.selectedReview}\n              readonly={readonly || isDrawMode}\n              jobProxy={props.jobProxy}\n              selectedShapeStatus={selectedShapeStatus}\n              getShapeLabel={getShapeLabel}\n            />\n          )}\n        </div>\n      )}\n    </Observer>\n  );\n});\n\nexport default LandmarkAnnotation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}