{"ast":null,"code":"export const parseAlawPcmToAudioData = data => {\n  const dataView = new DataView(data);\n  const reader = createReader(dataView);\n  const read = reader.pcm16;\n  const length = data.byteLength / 2;\n  const audioBuffer = new AudioBuffer({\n    numberOfChannels: 1,\n    length,\n    sampleRate: 8000\n  });\n  const channelData = audioBuffer.getChannelData(0);\n  for (let i = 0; i < length; i += 1) {\n    channelData[i] = read();\n  }\n  return audioBuffer;\n};\nexport function createReader(dataView) {\n  let pos = 0;\n  return {\n    remain() {\n      return dataView.byteLength - pos;\n    },\n    skip(n) {\n      pos += n;\n    },\n    uint8() {\n      const data = dataView.getUint8(pos);\n      pos += 1;\n      return data;\n    },\n    int16() {\n      const data = dataView.getInt16(pos, true);\n      pos += 2;\n      return data;\n    },\n    uint16() {\n      const data = dataView.getUint16(pos, true);\n      pos += 2;\n      return data;\n    },\n    uint32() {\n      const data = dataView.getUint32(pos, true);\n      pos += 4;\n      return data;\n    },\n    string(n) {\n      let data = '';\n      for (let i = 0; i < n; i += 1) {\n        data += String.fromCharCode(this.uint8());\n      }\n      return data;\n    },\n    pcm8() {\n      const data = dataView.getUint8(pos) - 128;\n      pos += 1;\n      return data < 0 ? data / 128 : data / 127;\n    },\n    pcm8s() {\n      const data = dataView.getUint8(pos) - 127.5;\n      pos += 1;\n      return data / 127.5;\n    },\n    pcm16() {\n      const data = dataView.getInt16(pos, true);\n      pos += 2;\n      return data < 0 ? data / 32768 : data / 32767;\n    },\n    pcm16s() {\n      const data = dataView.getInt16(pos, true);\n      pos += 2;\n      return data / 32768;\n    },\n    pcm24() {\n      const x0 = dataView.getUint8(pos + 0);\n      const x1 = dataView.getUint8(pos + 1);\n      const x2 = dataView.getUint8(pos + 2);\n      const xx = x0 + x1 * 2 ** 8 + x2 * 2 ** 16;\n      const data = xx > 0x800000 ? xx - 0x1000000 : xx;\n      pos += 3;\n      return data < 0 ? data / 8388608 : data / 8388607;\n    },\n    pcm24s() {\n      const x0 = dataView.getUint8(pos + 0);\n      const x1 = dataView.getUint8(pos + 1);\n      const x2 = dataView.getUint8(pos + 2);\n      const xx = x0 + x1 * 2 ** 8 + x2 * 2 ** 16;\n      const data = xx > 0x800000 ? xx - 0x1000000 : xx;\n      pos += 3;\n      return data / 8388608;\n    },\n    pcm32() {\n      const data = dataView.getInt32(pos, true);\n      pos += 4;\n      return data < 0 ? data / 2147483648 : data / 2147483647;\n    },\n    pcm32s() {\n      const data = dataView.getInt32(pos, true);\n      pos += 4;\n      return data / 2147483648;\n    },\n    pcm32f() {\n      const data = dataView.getFloat32(pos, true);\n      pos += 4;\n      return data;\n    },\n    pcm64f() {\n      const data = dataView.getFloat64(pos, true);\n      pos += 8;\n      return data;\n    }\n  };\n}\nfunction writeString(view, offset, str) {\n  for (let i = 0; i < str.length; i += 1) {\n    view.setUint8(offset + i, str.charCodeAt(i));\n  }\n}\nfunction floatTo32BitPCM(output, _offset, _input) {\n  const input = new Int32Array(_input);\n  let offset = _offset;\n  for (let i = 0; i < input.length; i += 1, offset += 4) {\n    output.setInt32(offset, input[i], true);\n  }\n}\nfunction floatTo16BitPCM(output, _offset, _input) {\n  const input = new Int16Array(_input);\n  let offset = _offset;\n  for (let i = 0; i < input.length; i += 1, offset += 2) {\n    output.setInt16(offset, input[i], true);\n  }\n}\nfunction floatTo8BitPCM(output, _offset, _input) {\n  const input = new Int8Array(_input);\n  let offset = _offset;\n  for (let i = 0; i < input.length; i += 1, offset += 1) {\n    output.setInt8(offset, input[i]);\n  }\n}\nexport const addWavHeader = (samples, sampleRateTmp, sampleBits, channelCount) => {\n  const dataLength = samples.byteLength;\n  const buffer = new ArrayBuffer(44 + dataLength);\n  const view = new DataView(buffer);\n  let offset = 0;\n  /* Resource Interchange File Format */\n  writeString(view, offset, 'RIFF');\n  offset += 4;\n  /* datalength */\n  view.setUint32(offset, /* 32 */36 + dataLength, true);\n  offset += 4;\n  /* file type */\n  writeString(view, offset, 'WAVE');\n  offset += 4;\n  /* waveform format */\n  writeString(view, offset, 'fmt ');\n  offset += 4;\n  /* filter byte, 0x10 = 16 */\n  view.setUint32(offset, 16, true);\n  offset += 4;\n  /* pcm byte */\n  view.setUint16(offset, 1, true);\n  offset += 2;\n  /* channel count */\n  view.setUint16(offset, channelCount, true);\n  offset += 2;\n  /* sampleRate */\n  view.setUint32(offset, sampleRateTmp, true);\n  offset += 4;\n  /* bitrate */\n  view.setUint32(offset, sampleRateTmp * channelCount * (sampleBits / 8), true);\n  offset += 4;\n  /* sample byte */\n  view.setUint16(offset, channelCount * (sampleBits / 8), true);\n  offset += 2;\n  /* sample bits */\n  view.setUint16(offset, sampleBits, true);\n  offset += 2;\n  writeString(view, offset, 'data');\n  offset += 4;\n  /* sample datalength: datalength-44 */\n  view.setUint32(offset, dataLength, true);\n  offset += 4;\n  if (sampleBits === 16) {\n    floatTo16BitPCM(view, 44, samples);\n  } else if (sampleBits === 8) {\n    floatTo8BitPCM(view, 44, samples);\n  } else {\n    floatTo32BitPCM(view, 44, samples);\n  }\n  return view.buffer;\n};\nexport const parsePcmToWav = async (fileBuffer, sampleRateTmp, sampleBits, channelCount) => {\n  try {\n    const audioContext = new AudioContext({\n      sampleRate: sampleRateTmp\n    });\n    const arrayBuffer = addWavHeader(fileBuffer, sampleRateTmp, sampleBits, channelCount);\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n    return audioBuffer;\n  } catch (error) {\n    console.log('load pcm failed: ', error);\n    return null;\n  }\n};","map":{"version":3,"names":["parseAlawPcmToAudioData","data","dataView","DataView","reader","createReader","read","pcm16","length","byteLength","audioBuffer","AudioBuffer","numberOfChannels","sampleRate","channelData","getChannelData","i","pos","remain","skip","n","uint8","getUint8","int16","getInt16","uint16","getUint16","uint32","getUint32","string","String","fromCharCode","pcm8","pcm8s","pcm16s","pcm24","x0","x1","x2","xx","pcm24s","pcm32","getInt32","pcm32s","pcm32f","getFloat32","pcm64f","getFloat64","writeString","view","offset","str","setUint8","charCodeAt","floatTo32BitPCM","output","_offset","_input","input","Int32Array","setInt32","floatTo16BitPCM","Int16Array","setInt16","floatTo8BitPCM","Int8Array","setInt8","addWavHeader","samples","sampleRateTmp","sampleBits","channelCount","dataLength","buffer","ArrayBuffer","setUint32","setUint16","parsePcmToWav","fileBuffer","audioContext","AudioContext","arrayBuffer","decodeAudioData","error","console","log"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/utils/pcm.ts"],"sourcesContent":["export const parseAlawPcmToAudioData = (data: ArrayBufferLike) => {\n  const dataView = new DataView(data);\n  const reader = createReader(dataView);\n  const read = reader.pcm16;\n\n  const length = data.byteLength / 2;\n\n  const audioBuffer = new AudioBuffer({\n    numberOfChannels: 1,\n    length,\n    sampleRate: 8000,\n  });\n\n  const channelData = audioBuffer.getChannelData(0);\n\n  for (let i = 0; i < length; i += 1) {\n    channelData[i] = read();\n  }\n\n  return audioBuffer;\n};\n\nexport function createReader(dataView: DataView) {\n  let pos = 0;\n\n  return {\n    remain() {\n      return dataView.byteLength - pos;\n    },\n    skip(n: number) {\n      pos += n;\n    },\n    uint8() {\n      const data = dataView.getUint8(pos);\n\n      pos += 1;\n\n      return data;\n    },\n    int16() {\n      const data = dataView.getInt16(pos, true);\n\n      pos += 2;\n\n      return data;\n    },\n    uint16() {\n      const data = dataView.getUint16(pos, true);\n\n      pos += 2;\n\n      return data;\n    },\n    uint32() {\n      const data = dataView.getUint32(pos, true);\n\n      pos += 4;\n\n      return data;\n    },\n    string(n: number) {\n      let data = '';\n\n      for (let i = 0; i < n; i += 1) {\n        data += String.fromCharCode(this.uint8());\n      }\n\n      return data;\n    },\n    pcm8() {\n      const data = dataView.getUint8(pos) - 128;\n\n      pos += 1;\n\n      return data < 0 ? data / 128 : data / 127;\n    },\n    pcm8s() {\n      const data = dataView.getUint8(pos) - 127.5;\n\n      pos += 1;\n\n      return data / 127.5;\n    },\n    pcm16() {\n      const data = dataView.getInt16(pos, true);\n\n      pos += 2;\n\n      return data < 0 ? data / 32768 : data / 32767;\n    },\n    pcm16s() {\n      const data = dataView.getInt16(pos, true);\n\n      pos += 2;\n\n      return data / 32768;\n    },\n    pcm24() {\n      const x0 = dataView.getUint8(pos + 0);\n      const x1 = dataView.getUint8(pos + 1);\n      const x2 = dataView.getUint8(pos + 2);\n      const xx = (x0 + (x1 * 2 ** 8) + (x2 * 2 ** 16));\n      const data = xx > 0x800000 ? xx - 0x1000000 : xx;\n\n      pos += 3;\n\n      return data < 0 ? data / 8388608 : data / 8388607;\n    },\n    pcm24s() {\n      const x0 = dataView.getUint8(pos + 0);\n      const x1 = dataView.getUint8(pos + 1);\n      const x2 = dataView.getUint8(pos + 2);\n      const xx = (x0 + (x1 * 2 ** 8) + (x2 * 2 ** 16));\n      const data = xx > 0x800000 ? xx - 0x1000000 : xx;\n\n      pos += 3;\n\n      return data / 8388608;\n    },\n    pcm32() {\n      const data = dataView.getInt32(pos, true);\n\n      pos += 4;\n\n      return data < 0 ? data / 2147483648 : data / 2147483647;\n    },\n    pcm32s() {\n      const data = dataView.getInt32(pos, true);\n\n      pos += 4;\n\n      return data / 2147483648;\n    },\n    pcm32f() {\n      const data = dataView.getFloat32(pos, true);\n\n      pos += 4;\n\n      return data;\n    },\n    pcm64f() {\n      const data = dataView.getFloat64(pos, true);\n\n      pos += 8;\n\n      return data;\n    }\n  };\n}\n\nfunction writeString(view: DataView, offset: number, str: string) {\n  for (let i = 0; i < str.length; i += 1) {\n    view.setUint8(offset + i, str.charCodeAt(i));\n  }\n}\n\nfunction floatTo32BitPCM(output: DataView, _offset: number, _input: ArrayBuffer) {\n  const input = new Int32Array(_input);\n  let offset = _offset;\n  for (let i = 0; i < input.length; i += 1, offset += 4) {\n    output.setInt32(offset, input[i], true);\n  }\n}\nfunction floatTo16BitPCM(output: DataView, _offset: number, _input: ArrayBuffer) {\n  const input = new Int16Array(_input);\n  let offset = _offset;\n  for (let i = 0; i < input.length; i += 1, offset += 2) {\n    output.setInt16(offset, input[i], true);\n  }\n}\nfunction floatTo8BitPCM(output: DataView, _offset: number, _input: ArrayBuffer) {\n  const input = new Int8Array(_input);\n  let offset = _offset;\n  for (let i = 0; i < input.length; i += 1, offset += 1) {\n    output.setInt8(offset, input[i]);\n  }\n}\n\nexport const addWavHeader = (samples: ArrayBuffer, sampleRateTmp: number, sampleBits: number, channelCount: number) => {\n  const dataLength = samples.byteLength;\n  const buffer = new ArrayBuffer(44 + dataLength);\n  const view = new DataView(buffer);\n  let offset = 0;\n  /* Resource Interchange File Format */\n  writeString(view, offset, 'RIFF'); offset += 4;\n  /* datalength */\n  view.setUint32(offset, /* 32 */ 36 + dataLength, true); offset += 4;\n  /* file type */\n  writeString(view, offset, 'WAVE'); offset += 4;\n  /* waveform format */\n  writeString(view, offset, 'fmt '); offset += 4;\n  /* filter byte, 0x10 = 16 */\n  view.setUint32(offset, 16, true); offset += 4;\n  /* pcm byte */\n  view.setUint16(offset, 1, true); offset += 2;\n  /* channel count */\n  view.setUint16(offset, channelCount, true); offset += 2;\n  /* sampleRate */\n  view.setUint32(offset, sampleRateTmp, true); offset += 4;\n  /* bitrate */\n  view.setUint32(offset, sampleRateTmp * channelCount * (sampleBits / 8), true); offset += 4;\n  /* sample byte */\n  view.setUint16(offset, channelCount * (sampleBits / 8), true); offset += 2;\n  /* sample bits */\n  view.setUint16(offset, sampleBits, true); offset += 2;\n\n  writeString(view, offset, 'data'); offset += 4;\n  /* sample datalength: datalength-44 */\n  view.setUint32(offset, dataLength, true); offset += 4;\n\n  if (sampleBits === 16) {\n    floatTo16BitPCM(view, 44, samples);\n  } else if (sampleBits === 8) {\n    floatTo8BitPCM(view, 44, samples);\n  } else {\n    floatTo32BitPCM(view, 44, samples);\n  }\n  return view.buffer;\n};\n\nexport const parsePcmToWav = async (fileBuffer: ArrayBuffer, sampleRateTmp: number, sampleBits: number, channelCount: number) => {\n  try {\n    const audioContext = new AudioContext({ sampleRate: sampleRateTmp });\n    const arrayBuffer = addWavHeader(fileBuffer, sampleRateTmp, sampleBits, channelCount);\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n    return audioBuffer;\n  } catch (error) {\n    console.log('load pcm failed: ', error);\n    return null;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}