{"ast":null,"code":"import { action, makeAutoObservable, observable, toJS } from 'mobx';\nimport { notification } from 'antd';\nimport * as alawmulaw from 'alawmulaw';\nimport { isEqual } from 'lodash';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport WaveStore from './WaveStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport GlobalStore from './GlobalStore';\nimport ConfigStore from './ConfigStore';\nimport Crunker from '../utils/crunker';\nimport { loadInstancesFromResult, triggerForm, mergeChannel, decodeAudioData, decodeWavData, loadAudioChunk, getAudioFileSize } from '../utils';\nimport { ReviewResult, AudioMode } from '../types';\nimport i18n from '../locales';\nimport { parseAlawPcmToAudioData, parsePcmToWav } from '../../../utils/pcm';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, isTemplatePreview } from '../../../utils/tool-mode';\nimport { getWords, getFileExtension } from '../../../utils';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return this.annotationReadonly || this.global.annotateDisabled;\n  }\n  get annotationReadonly() {\n    return isAnnotationReadonly(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in template preview mode\n   */\n  get isTemplatePreview() {\n    return isTemplatePreview(this.jobProxy.toolMode);\n  }\n  constructor() {\n    this.ontology = void 0;\n    this.undo = void 0;\n    this.waveform = void 0;\n    this.setting = void 0;\n    this.review = void 0;\n    this.instance = void 0;\n    this.global = void 0;\n    this.config = void 0;\n    this.urls = [];\n    this.videoUrl = void 0;\n    /**\n     * job proxy\n     */\n    this.jobProxy = void 0;\n    /**\n     * is tool initialized\n     */\n    this.initialized = false;\n    /**\n     * load audio in chunks\n     */\n    this.loadInchunks = false;\n    /**\n     * pre-read audio duration\n     */\n    this.PreDuration = void 0;\n    /**\n     * loaded audio chunk\n     */\n    this.chunk = 0;\n    this.loadDuration = () => new Promise(resolve => {\n      if (this.urls.length > 1 || !this.setting.streamingLoad) {\n        resolve(false);\n        return;\n      }\n      const tail = getFileExtension(this.urls[0]);\n      if (tail !== 'mp3') {\n        resolve(false);\n        return;\n      }\n      // get duration by audio tag\n      const audio = document.createElement('audio');\n      document.body.appendChild(audio);\n      audio.addEventListener('loadedmetadata', () => {\n        var _audio$parentNode;\n        this.PreDuration = audio.duration;\n        (_audio$parentNode = audio.parentNode) === null || _audio$parentNode === void 0 ? void 0 : _audio$parentNode.removeChild(audio);\n        resolve(true);\n      });\n      audio.src = this.urls[0];\n    });\n    this.parserAudio = async payload => {\n      if (this.urls.length === 0) {\n        throw new Error();\n      }\n      const tail = this.urls.length === 1 ? getFileExtension(this.urls[0]) : undefined;\n      if (this.PreDuration) {\n        const url = this.urls[0];\n        const arrayBuffer = await loadAudioChunk(url, 0, 1024 * 256 - 1);\n        if (arrayBuffer === null || arrayBuffer === void 0 ? void 0 : arrayBuffer.byteLength) {\n          // eslint-disable-next-line no-await-in-loop\n          const chunkBuffer = await this.parserBuffer(arrayBuffer, tail);\n          if (chunkBuffer) {\n            const channelCount = 1; // chunkBuffer.numberOfChannels;\n            const audioBuffer = new AudioContext().createBuffer(channelCount, chunkBuffer.sampleRate * this.PreDuration, chunkBuffer.sampleRate);\n            await this.waveform.init(payload, audioBuffer);\n            this.loadBufferByChunk(url, audioBuffer);\n          }\n        }\n      } else {\n        const fileBuffer = this.urls.length > 1 ? await this.mergeAudios() : await this.loadBuffer(this.urls[0]);\n        const audioBuffer = this.setting.audioMode === AudioMode.SINGLE && fileBuffer && fileBuffer.numberOfChannels > 1 ? await mergeChannel(fileBuffer) : fileBuffer;\n        if (!audioBuffer) {\n          throw new Error(i18n.translate('AUDIO_LOAD_ERROR'));\n        }\n        await this.waveform.init(payload, audioBuffer);\n        this.waveform.setLoaded();\n      }\n    };\n    this.mergeAudios = async () => new Promise(async (resolve, reject) => {\n      try {\n        const buffers = [];\n        for (let i = 0; i < this.urls.length; i += 1) {\n          // eslint-disable-next-line no-await-in-loop\n          const audioBuffer = this.urls[i] ? await this.loadBuffer(this.urls[i]) : null;\n          if (audioBuffer) {\n            buffers.push(audioBuffer);\n          }\n        }\n        const crunker = new Crunker({\n          sampleRate: Math.min(...buffers.map(b => b.sampleRate))\n        });\n        const audioBuffer = crunker.mergeAudio(buffers, false);\n        resolve(audioBuffer);\n      } catch (error) {\n        reject({\n          message: i18n.translate('AUDIO_MULTI_LOAD_ERROR')\n        });\n      }\n    });\n    this.loadBufferByChunk = async (url, audioBuffer) => {\n      if (!this.PreDuration) {\n        return;\n      }\n      const audioFileSize = await getAudioFileSize(url);\n      if (!audioFileSize) {\n        return;\n      }\n      try {\n        const tail = getFileExtension(url);\n        const chunkSize = 1024 * 1024 * 5; // chunk size 1MB\n        let totalBuffer;\n        let chunk = 1;\n        while (chunk) {\n          let isContinue = false;\n          // eslint-disable-next-line no-await-in-loop\n          const chunkBuffer = await loadAudioChunk(url, chunkSize * (chunk - 1), chunkSize * chunk - 1);\n          if (chunkBuffer === null || chunkBuffer === void 0 ? void 0 : chunkBuffer.byteLength) {\n            let arrayBuffer = chunkBuffer;\n            if (totalBuffer) {\n              arrayBuffer = new ArrayBuffer(totalBuffer.byteLength + chunkBuffer.byteLength);\n              const concatenatedUint8Array = new Uint8Array(arrayBuffer);\n              concatenatedUint8Array.set(new Uint8Array(totalBuffer), 0);\n              concatenatedUint8Array.set(new Uint8Array(chunkBuffer), totalBuffer.byteLength);\n            }\n            totalBuffer = arrayBuffer;\n\n            // eslint-disable-next-line no-await-in-loop\n            const chunkAudioBuffer = await this.parserBuffer(arrayBuffer, tail);\n            if (chunkAudioBuffer) {\n              for (let c = 0; c < 1; c += 1) {\n                const channelBuffer = chunkAudioBuffer.getChannelData(c);\n                const audioChannelBuffer = audioBuffer.getChannelData(c);\n                const chunkLength = Math.min(audioChannelBuffer.length, channelBuffer.length);\n                const chunkChannelBuffer = channelBuffer.slice(0, chunkLength);\n                audioChannelBuffer.set(chunkChannelBuffer, 0);\n              }\n              this.chunk = chunk;\n              // whether continue\n              if (chunkSize * chunk < audioFileSize) {\n                isContinue = true;\n                chunk += 1;\n              }\n            }\n          }\n          if (!isContinue) {\n            console.log('>>>>> load audio chunk complete');\n            chunk = 0;\n          }\n        }\n      } catch (error) {\n        console.log('decode error', error);\n      }\n      if (this.chunk === 0) {\n        throw new Error(i18n.translate('AUDIO_LOAD_ERROR'));\n      }\n      this.waveform.setLoaded();\n    };\n    // Loads audio using Web Audio buffer backend.\n    this.loadBuffer = url => new Promise(async (resolve, reject) => {\n      try {\n        const tail = getFileExtension(url);\n        const arrayBuffer = await fetch(url).then(data => data.arrayBuffer());\n        const audioBuffer = await this.parserBuffer(arrayBuffer, tail);\n        resolve(audioBuffer);\n      } catch (error) {\n        console.log('decode error', error);\n        resolve(null);\n      }\n    });\n    /**\n     * get instance statistics\n     */\n    this.getInstanceStatistics = () => {\n      const objects = {\n        summary: [],\n        duration: 0,\n        // file duration\n        validDuration: 0,\n        annotationDuration: 0,\n        // annotation duration\n        approvedValidDuration: 0,\n        rejectedValidDuration: 0,\n        incrementDuration: 0,\n        annotationWordCount: 0\n      };\n      const {\n        duration: audioDuration\n      } = this.waveform;\n      const reviews = this.review.getReviewsForSave().filter(r => r.result !== ReviewResult.APPROVE);\n      const instancesList = Object.values(this.instance.instances).filter(v => !!v);\n      const lastInstances = JSON.parse(JSON.stringify(this.instance.lastInstances));\n      objects.duration = audioDuration * 1000;\n      for (let i = 0; i < instancesList.length; i += 1) {\n        const {\n          id,\n          start,\n          end,\n          isValid,\n          text\n        } = instancesList[i];\n        const words = getWords(text, this.config.wordCountItems);\n        objects.annotationWordCount += words.length;\n        const duration = (end - start) * 1000;\n        objects.annotationDuration += duration;\n\n        // changed segment\n        const equal = isEqual(instancesList[i], lastInstances[id]);\n        const incrementDuration = isValid && !equal ? duration : 0;\n        objects.incrementDuration += incrementDuration;\n        delete lastInstances[id];\n        if (isValid) {\n          objects.validDuration += duration;\n          const review = reviews.find(r => r.instanceId === id);\n          if ((review === null || review === void 0 ? void 0 : review.result) === ReviewResult.REJECT) {\n            objects.rejectedValidDuration += duration;\n          } else {\n            objects.approvedValidDuration += duration;\n          }\n        }\n      }\n\n      // removed segment\n      const keys = Object.keys(lastInstances);\n      for (let n = 0; n < keys.length; n += 1) {\n        const {\n          start,\n          end,\n          isValid\n        } = lastInstances[keys[n]];\n        if (isValid) {\n          objects.incrementDuration += (end - start) * 1000;\n        }\n      }\n      return {\n        ...objects,\n        duration: Number(objects.duration.toFixed(2)),\n        validDuration: Number(objects.validDuration.toFixed(2)),\n        annotationDuration: Number(objects.annotationDuration.toFixed(2)),\n        approvedValidDuration: Number(objects.approvedValidDuration.toFixed(2)),\n        rejectedValidDuration: Number(objects.rejectedValidDuration.toFixed(2)),\n        incrementDuration: Number(objects.incrementDuration.toFixed(2))\n      };\n    };\n    /**\n     * save file\n     * @param file\n     */\n    this.saveFile = file => this.jobProxy.saveFile(file);\n    makeAutoObservable(this, {\n      urls: observable,\n      initialized: observable,\n      chunk: observable,\n      initEnd: action,\n      parserAudio: action,\n      loadBufferByChunk: action\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.waveform = new WaveStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n    this.global = new GlobalStore(this);\n    this.config = new ConfigStore(this);\n  }\n  async init(payload) {\n    return new Promise(async (resolve, reject) => {\n      // init urls\n      this.urls = payload.audio ? payload.audio.split(',') : [];\n      if (payload.video_url) {\n        this.videoUrl = payload.video_url;\n      }\n      this.loadInchunks = payload.load_in_chunks === 'true' || payload.load_in_chunks === true;\n      if (this.loadInchunks) {\n        await this.loadDuration();\n      }\n\n      // init job proxy\n      this.jobProxy = payload.jobProxy;\n\n      // init common stores\n      try {\n        this.ontology.init(payload);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR')\n        });\n      }\n      this.setting.init(payload);\n      this.config.init(payload);\n      try {\n        this.global.init(payload);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_LOAD_GLOBAL_ERROR')\n        });\n      }\n      try {\n        await this.parserAudio(payload);\n      } catch (error) {\n        var _ref;\n        notification.error({\n          message: ((_ref = error) === null || _ref === void 0 ? void 0 : _ref.message) || i18n.translate('AUDIO_LOAD_ERROR')\n        });\n        this.setting.setLoading(false);\n        return;\n      }\n\n      // load result & init instances\n      try {\n        await this.loadResult(payload.ontology);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR')\n        });\n      }\n      // load & init reviews\n      try {\n        await this.loadReviews(payload);\n      } catch (error) {\n        notification.error({\n          message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR')\n        });\n      }\n      this.initEnd();\n      resolve(true);\n    });\n  }\n  async parserBuffer(buffer, tail) {\n    const {\n      streamingLoad,\n      pcmSampleRate: sampleRate,\n      pcmSampleBits,\n      pcmChannelCount\n    } = this.setting;\n    let audioBuffer = null;\n    if (tail === 'wav') {\n      try {\n        const audioCtx = new AudioContext({\n          sampleRate\n        });\n        audioBuffer = await audioCtx.decodeAudioData(buffer);\n      } catch (error) {\n        audioBuffer = decodeWavData(buffer);\n      }\n    } else if (tail === 'alaw') {\n      const alawOriginData = new Uint8Array(buffer);\n      const decodeAlaw = alawmulaw.alaw.decode(alawOriginData);\n      audioBuffer = parseAlawPcmToAudioData(decodeAlaw.buffer);\n    } else if (tail === 'mp4' || tail === 'flac') {\n      const audioCtx = new AudioContext({\n        sampleRate\n      });\n      audioBuffer = await audioCtx.decodeAudioData(buffer);\n    } else if (tail === 'pcm') {\n      audioBuffer = await parsePcmToWav(buffer, sampleRate, pcmSampleBits, pcmChannelCount);\n    } else if (tail === 'mp3' && streamingLoad) {\n      audioBuffer = await decodeAudioData(buffer, sampleRate, this.setting.audioMode === AudioMode.MULTI);\n    } else {\n      const audioCtx = new AudioContext({\n        sampleRate\n      });\n      audioBuffer = await audioCtx.decodeAudioData(buffer);\n    }\n    return audioBuffer;\n  }\n  initEnd() {\n    this.initialized = true;\n  }\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology) {\n    const savedResult = await this.jobProxy.loadSavedResult();\n    const reviewFromResult = await this.jobProxy.loadReviewFrom();\n    const result = savedResult || reviewFromResult;\n    if (result) {\n      if (result.channelAttribues) {\n        const resultChannelAttributes = Object.prototype.toString.call(result.channelAttribues) === '[object Object]' ? result.channelAttribues : {};\n        const channelAttribues = {};\n        Object.keys(resultChannelAttributes).forEach(channelName => {\n          const channelAttr = resultChannelAttributes[channelName];\n          const attributes = Object.prototype.toString.call(channelAttr) === '[object Object]' ? channelAttr : {};\n          const {\n            updatedValues\n          } = triggerForm(this.ontology.channelConfig, attributes);\n          channelAttribues[channelName] = updatedValues;\n        });\n        this.ontology.setAttribute(channelAttribues);\n      }\n      const attributes = Object.prototype.toString.call(result.attributes) === '[object Object]' ? result.attributes : {};\n      const {\n        updatedValues\n      } = triggerForm(this.global.globalConfig, attributes);\n      this.global.setAttributes(updatedValues);\n      // load instance\n      this.instance.init(result.instances ? loadInstancesFromResult(result === null || result === void 0 ? void 0 : result.instances, ontology) : []);\n      if (result.channelOffset) {\n        this.waveform.setChannelOffsets(result.channelOffset);\n      }\n      if (result.auditId) {\n        this.jobProxy.setAuditId(result.auditId);\n      }\n    }\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const {\n      channelOffset\n    } = this.waveform;\n    const {\n      updatedValues\n    } = triggerForm(this.global.globalConfig, this.global.attributes);\n    const channelAttribues = {};\n    Object.keys(this.ontology.channelAttribuesList).forEach(channelName => {\n      const attr = this.ontology.channelAttribuesList[channelName];\n      channelAttribues[channelName] = triggerForm(this.ontology.channelConfig, attr).updatedValues;\n    });\n    const newInstances = toJS(this.instance.allInstances).map(i => {\n      var _i$text;\n      return {\n        ...i,\n        text: (_i$text = i.text) === null || _i$text === void 0 ? void 0 : _i$text.trim(),\n        preAnnotationData: i.preAnnotationData ? {\n          ...i.preAnnotationData\n        } : undefined\n      };\n    }).map(({\n      isTranslationRequired,\n      ...instance\n    }) => instance);\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy.saveResultStat(statData);\n    return this.jobProxy.saveResult({\n      auditId: this.jobProxy.auditFileId,\n      attributes: updatedValues,\n      channelAttribues,\n      instances: newInstances,\n      channelOffset,\n      statistics\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload) {\n    this.review.init(payload);\n    const reviews = await this.jobProxy.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews(submit = false) {\n    return this.jobProxy.saveReviews(this.review.getReviewsForSave(submit), submit);\n  }\n}\nconst rootStore = new RootStore();\nexport default rootStore;","map":{"version":3,"names":["action","makeAutoObservable","observable","toJS","notification","alawmulaw","isEqual","OntologyStore","UndoStore","WaveStore","SettingsStore","ReviewsStore","InstanceStore","GlobalStore","ConfigStore","Crunker","loadInstancesFromResult","triggerForm","mergeChannel","decodeAudioData","decodeWavData","loadAudioChunk","getAudioFileSize","ReviewResult","AudioMode","i18n","parseAlawPcmToAudioData","parsePcmToWav","isAnnotationReadonly","isReviewEditable","isRework","isPreview","isTemplatePreview","getWords","getFileExtension","RootStore","readonly","annotationReadonly","global","annotateDisabled","jobProxy","toolMode","reviewable","constructor","ontology","undo","waveform","setting","review","instance","config","urls","videoUrl","initialized","loadInchunks","PreDuration","chunk","loadDuration","Promise","resolve","length","streamingLoad","tail","audio","document","createElement","body","appendChild","addEventListener","_audio$parentNode","duration","parentNode","removeChild","src","parserAudio","payload","Error","undefined","url","arrayBuffer","byteLength","chunkBuffer","parserBuffer","channelCount","audioBuffer","AudioContext","createBuffer","sampleRate","init","loadBufferByChunk","fileBuffer","mergeAudios","loadBuffer","audioMode","SINGLE","numberOfChannels","translate","setLoaded","reject","buffers","i","push","crunker","Math","min","map","b","mergeAudio","error","message","audioFileSize","chunkSize","totalBuffer","isContinue","ArrayBuffer","concatenatedUint8Array","Uint8Array","set","chunkAudioBuffer","c","channelBuffer","getChannelData","audioChannelBuffer","chunkLength","chunkChannelBuffer","slice","console","log","fetch","then","data","getInstanceStatistics","objects","summary","validDuration","annotationDuration","approvedValidDuration","rejectedValidDuration","incrementDuration","annotationWordCount","audioDuration","reviews","getReviewsForSave","filter","r","result","APPROVE","instancesList","Object","values","instances","v","lastInstances","JSON","parse","stringify","id","start","end","isValid","text","words","wordCountItems","equal","find","instanceId","REJECT","keys","n","Number","toFixed","saveFile","file","initEnd","split","video_url","load_in_chunks","_ref","setLoading","loadResult","loadReviews","buffer","pcmSampleRate","pcmSampleBits","pcmChannelCount","audioCtx","alawOriginData","decodeAlaw","alaw","decode","MULTI","savedResult","loadSavedResult","reviewFromResult","loadReviewFrom","channelAttribues","resultChannelAttributes","prototype","toString","call","forEach","channelName","channelAttr","attributes","updatedValues","channelConfig","setAttribute","globalConfig","setAttributes","channelOffset","setChannelOffsets","auditId","setAuditId","saveResult","submit","channelAttribuesList","attr","newInstances","allInstances","_i$text","trim","preAnnotationData","isTranslationRequired","statData","statistics","saveResultStat","auditFileId","setInitialData","saveReviews","rootStore"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/store/RootStore.ts"],"sourcesContent":["import { action, makeAutoObservable, observable, toJS } from 'mobx';\nimport { notification } from 'antd';\nimport * as alawmulaw from 'alawmulaw';\nimport { isEqual } from 'lodash';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport WaveStore from './WaveStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport GlobalStore from './GlobalStore';\nimport ConfigStore from './ConfigStore';\nimport Crunker from '../utils/crunker';\nimport { loadInstancesFromResult, triggerForm, mergeChannel, decodeAudioData, decodeWavData, loadAudioChunk, getAudioFileSize } from '../utils';\nimport { Payload, Instance, Ontology, ReviewResult, AudioMode, FormValue } from '../types';\nimport i18n from '../locales';\nimport JobProxy from '../../../libs/JobProxy';\nimport { parseAlawPcmToAudioData, parsePcmToWav } from '../../../utils/pcm';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, isTemplatePreview } from '../../../utils/tool-mode';\nimport { getWords, getFileExtension } from '../../../utils';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  ontology: OntologyStore;\n\n  undo: UndoStore;\n\n  waveform: WaveStore;\n\n  setting: SettingsStore;\n\n  review: ReviewsStore;\n\n  instance: InstanceStore;\n\n  global: GlobalStore;\n\n  config: ConfigStore;\n\n  urls: string[] = [];\n\n  videoUrl?: string;\n\n  /**\n   * job proxy\n   */\n  jobProxy?: JobProxy;\n\n  /**\n   * is tool initialized\n   */\n  initialized = false;\n\n  /**\n   * load audio in chunks\n   */\n  loadInchunks = false;\n\n  /**\n   * pre-read audio duration\n   */\n  PreDuration?: number;\n\n  /**\n   * loaded audio chunk\n   */\n  chunk = 0;\n\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return this.annotationReadonly || this.global.annotateDisabled;\n  }\n\n  get annotationReadonly() {\n    return isAnnotationReadonly(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in template preview mode\n   */\n  get isTemplatePreview() {\n    return isTemplatePreview(this.jobProxy!.toolMode);\n  }\n\n  constructor() {\n    makeAutoObservable(this, {\n      urls: observable,\n      initialized: observable,\n      chunk: observable,\n      initEnd: action,\n      parserAudio: action,\n      loadBufferByChunk: action,\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.waveform = new WaveStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n    this.global = new GlobalStore(this);\n    this.config = new ConfigStore(this);\n  }\n\n  loadDuration = () => new Promise((resolve) => {\n    if (this.urls.length > 1 || !this.setting.streamingLoad) {\n      resolve(false);\n      return;\n    }\n    const tail = getFileExtension(this.urls[0]) as string;\n    if (tail !== 'mp3') {\n      resolve(false);\n      return;\n    }\n    // get duration by audio tag\n    const audio = document.createElement('audio');\n    document.body.appendChild(audio);\n    audio.addEventListener('loadedmetadata', () => {\n      this.PreDuration = audio.duration;\n      audio.parentNode?.removeChild(audio);\n      resolve(true);\n    });\n    audio.src = this.urls[0];\n  });\n\n  async init(payload: Payload) {\n    return new Promise(async (resolve, reject) => {\n      // init urls\n      this.urls = payload.audio ? payload.audio.split(',') : [];\n      if (payload.video_url) {\n        this.videoUrl = payload.video_url;\n      }\n      this.loadInchunks = payload.load_in_chunks === 'true' || payload.load_in_chunks === true;\n      if (this.loadInchunks) {\n        await this.loadDuration();\n      }\n\n      // init job proxy\n      this.jobProxy = payload.jobProxy;\n\n      // init common stores\n      try {\n        this.ontology.init(payload);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR') });\n      }\n      this.setting.init(payload);\n      this.config.init(payload);\n\n      try {\n        this.global.init(payload);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_LOAD_GLOBAL_ERROR') });\n      }\n\n      try {\n        await this.parserAudio(payload);\n      } catch (error) {\n        notification.error({ message: (error as any)?.message || i18n.translate('AUDIO_LOAD_ERROR') });\n        this.setting.setLoading(false);\n        return;\n      }\n\n      // load result & init instances\n      try {\n        await this.loadResult(payload.ontology);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR') });\n      }\n      // load & init reviews\n      try {\n        await this.loadReviews(payload);\n      } catch (error) {\n        notification.error({ message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR') });\n      }\n      this.initEnd();\n      resolve(true);\n    });\n  }\n\n  parserAudio = async (payload: Payload) => {\n    if (this.urls.length === 0) {\n      throw new Error();\n    }\n    const tail = this.urls.length === 1 ? getFileExtension(this.urls[0]) : undefined;\n    if (this.PreDuration) {\n      const url = this.urls[0];\n      const arrayBuffer = await loadAudioChunk(url, 0, 1024 * 256 - 1);\n      if (arrayBuffer?.byteLength) {\n        // eslint-disable-next-line no-await-in-loop\n        const chunkBuffer = await this.parserBuffer(arrayBuffer, tail);\n        if (chunkBuffer) {\n          const channelCount = 1; // chunkBuffer.numberOfChannels;\n          const audioBuffer = new AudioContext().createBuffer(\n            channelCount,\n            chunkBuffer.sampleRate * this.PreDuration,\n            chunkBuffer.sampleRate,\n          );\n          await this.waveform.init(payload, audioBuffer);\n          this.loadBufferByChunk(url, audioBuffer);\n        }\n      }\n    } else {\n      const fileBuffer = this.urls.length > 1 ? await this.mergeAudios() : await this.loadBuffer(this.urls[0]);\n      const audioBuffer =\n        this.setting.audioMode === AudioMode.SINGLE\n        && fileBuffer && fileBuffer.numberOfChannels > 1\n          ? await mergeChannel(fileBuffer)\n          : fileBuffer;\n      if (!audioBuffer) {\n        throw new Error(i18n.translate('AUDIO_LOAD_ERROR'));\n      }\n      await this.waveform.init(payload, audioBuffer);\n      this.waveform.setLoaded();\n    }\n  };\n\n  mergeAudios = async () => new Promise<AudioBuffer>(async (resolve, reject) => {\n    try {\n      const buffers: AudioBuffer[] = [];\n      for (let i = 0; i < this.urls.length; i += 1) {\n        // eslint-disable-next-line no-await-in-loop\n        const audioBuffer = this.urls[i] ? await this.loadBuffer(this.urls[i]) : null;\n        if (audioBuffer) {\n          buffers.push(audioBuffer);\n        }\n      }\n      const crunker = new Crunker({ sampleRate: Math.min(...buffers.map((b) => b.sampleRate)) });\n      const audioBuffer = crunker.mergeAudio(buffers, false);\n      resolve(audioBuffer);\n    } catch (error) {\n      reject({ message: i18n.translate('AUDIO_MULTI_LOAD_ERROR') });\n    }\n  });\n\n  loadBufferByChunk = async (url: string, audioBuffer: AudioBuffer) => {\n    if (!this.PreDuration) {\n      return;\n    }\n    const audioFileSize = await getAudioFileSize(url);\n    if (!audioFileSize) {\n      return;\n    }\n    try {\n      const tail = getFileExtension(url);\n      const chunkSize = 1024 * 1024 * 5; // chunk size 1MB\n      let totalBuffer: ArrayBuffer | undefined;\n      let chunk = 1;\n      while (chunk) {\n        let isContinue = false;\n        // eslint-disable-next-line no-await-in-loop\n        const chunkBuffer = await loadAudioChunk(url, chunkSize * (chunk - 1), chunkSize * chunk - 1);\n        if (chunkBuffer?.byteLength) {\n          let arrayBuffer: ArrayBuffer = chunkBuffer;\n          if (totalBuffer) {\n            arrayBuffer = new ArrayBuffer(totalBuffer.byteLength + chunkBuffer.byteLength);\n            const concatenatedUint8Array = new Uint8Array(arrayBuffer);\n            concatenatedUint8Array.set(new Uint8Array(totalBuffer), 0);\n            concatenatedUint8Array.set(new Uint8Array(chunkBuffer), totalBuffer.byteLength);\n          }\n          totalBuffer = arrayBuffer;\n\n          // eslint-disable-next-line no-await-in-loop\n          const chunkAudioBuffer = await this.parserBuffer(arrayBuffer, tail);\n          if (chunkAudioBuffer) {\n            for (let c = 0; c < 1; c += 1) {\n              const channelBuffer = chunkAudioBuffer.getChannelData(c);\n              const audioChannelBuffer = audioBuffer.getChannelData(c);\n              const chunkLength = Math.min(audioChannelBuffer.length, channelBuffer.length);\n              const chunkChannelBuffer = channelBuffer.slice(0, chunkLength);\n              audioChannelBuffer.set(chunkChannelBuffer, 0);\n            }\n            this.chunk = chunk;\n            // whether continue\n            if (chunkSize * chunk < audioFileSize) {\n              isContinue = true;\n              chunk += 1;\n            }\n          }\n        }\n        if (!isContinue) {\n          console.log('>>>>> load audio chunk complete');\n          chunk = 0;\n        }\n      }\n    } catch (error) {\n      console.log('decode error', error);\n    }\n    if (this.chunk === 0) {\n      throw new Error(i18n.translate('AUDIO_LOAD_ERROR'));\n    }\n    this.waveform.setLoaded();\n  };\n\n  // Loads audio using Web Audio buffer backend.\n  loadBuffer = (url: string) => new Promise<AudioBuffer|null>(async (resolve, reject) => {\n    try {\n      const tail = getFileExtension(url);\n      const arrayBuffer = await fetch(url)\n        .then((data) => data.arrayBuffer());\n      const audioBuffer = await this.parserBuffer(arrayBuffer, tail);\n      resolve(audioBuffer);\n    } catch (error) {\n      console.log('decode error', error);\n      resolve(null);\n    }\n  });\n\n  async parserBuffer(buffer: ArrayBuffer, tail?: string) {\n    const { streamingLoad, pcmSampleRate: sampleRate, pcmSampleBits, pcmChannelCount } = this.setting;\n    let audioBuffer: AudioBuffer | null = null;\n    if (tail === 'wav') {\n      try {\n        const audioCtx = new AudioContext({ sampleRate });\n        audioBuffer = await audioCtx.decodeAudioData(buffer);\n      } catch (error) {\n        audioBuffer = decodeWavData(buffer);\n      }\n    } else if (tail === 'alaw') {\n      const alawOriginData = new Uint8Array(buffer);\n      const decodeAlaw = alawmulaw.alaw.decode(alawOriginData);\n      audioBuffer = parseAlawPcmToAudioData(decodeAlaw.buffer);\n    } else if (tail === 'mp4' || tail === 'flac') {\n      const audioCtx = new AudioContext({ sampleRate });\n      audioBuffer = await audioCtx.decodeAudioData(buffer);\n    } else if (tail === 'pcm') {\n      audioBuffer = await parsePcmToWav(buffer, sampleRate, pcmSampleBits, pcmChannelCount);\n    } else if (tail === 'mp3' && streamingLoad) {\n      audioBuffer = await decodeAudioData(buffer, sampleRate, this.setting.audioMode === AudioMode.MULTI);\n    } else {\n      const audioCtx = new AudioContext({ sampleRate });\n      audioBuffer = await audioCtx.decodeAudioData(buffer);\n    }\n    return audioBuffer;\n  }\n\n  initEnd() {\n    this.initialized = true;\n  };\n\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology: Ontology[]) {\n    const savedResult = await this.jobProxy!.loadSavedResult();\n    const reviewFromResult = await this.jobProxy!.loadReviewFrom();\n\n    const result = savedResult || reviewFromResult;\n    if (result) {\n      if (result.channelAttribues) {\n        const resultChannelAttributes = Object.prototype.toString.call(result.channelAttribues) === '[object Object]' ? result.channelAttribues : {};\n        const channelAttribues: Record<string, FormValue> = {};\n        Object.keys(resultChannelAttributes).forEach((channelName: string) => {\n          const channelAttr = resultChannelAttributes[channelName];\n          const attributes = Object.prototype.toString.call(channelAttr) === '[object Object]' ? channelAttr : {};\n          const { updatedValues } = triggerForm(this.ontology.channelConfig, attributes);\n          channelAttribues[channelName] = updatedValues;\n        });\n        this.ontology.setAttribute(channelAttribues);\n      }\n\n      const attributes = Object.prototype.toString.call(result.attributes) === '[object Object]' ? result.attributes : {};\n      const { updatedValues } = triggerForm(this.global.globalConfig, attributes);\n      this.global.setAttributes(updatedValues);\n      // load instance\n      this.instance.init(result.instances ? loadInstancesFromResult(result?.instances, ontology) : []);\n\n      if (result.channelOffset) {\n        this.waveform.setChannelOffsets(result.channelOffset);\n      }\n\n      if (result.auditId) {\n        this.jobProxy!.setAuditId(result.auditId);\n      }\n    }\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const { channelOffset } = this.waveform;\n    const { updatedValues } = triggerForm(this.global.globalConfig, this.global.attributes);\n\n    const channelAttribues: Record<string, FormValue> = {};\n    Object.keys(this.ontology.channelAttribuesList).forEach((channelName: string) => {\n      const attr = this.ontology.channelAttribuesList[channelName];\n      channelAttribues[channelName] = triggerForm(this.ontology.channelConfig, attr).updatedValues;\n    });\n\n    const newInstances: Instance[] = toJS(this.instance.allInstances)\n      .map((i) => ({\n        ...i,\n        text: i.text?.trim(),\n        preAnnotationData: i.preAnnotationData ? { ...i.preAnnotationData } : undefined,\n      }))\n      .map(({ isTranslationRequired, ...instance }) => instance);\n\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy!.saveResultStat(statData);\n    return this.jobProxy!.saveResult({\n      auditId: this.jobProxy!.auditFileId,\n      attributes: updatedValues,\n      channelAttribues,\n      instances: newInstances,\n      channelOffset,\n      statistics,\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload: Payload) {\n    this.review.init(payload);\n    const reviews = await this.jobProxy!.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews(submit = false) {\n    return this.jobProxy!.saveReviews(this.review.getReviewsForSave(submit), submit);\n  }\n\n  /**\n   * get instance statistics\n   */\n  getInstanceStatistics = () => {\n    const objects = {\n      summary: [],\n      duration: 0, // file duration\n      validDuration: 0,\n      annotationDuration: 0, // annotation duration\n      approvedValidDuration: 0,\n      rejectedValidDuration: 0,\n      incrementDuration: 0,\n      annotationWordCount: 0,\n    };\n    const { duration: audioDuration } = this.waveform;\n    const reviews = this.review.getReviewsForSave().filter((r) => r.result !== ReviewResult.APPROVE);\n    const instancesList = Object.values(this.instance.instances).filter((v) => !!v);\n    const lastInstances = JSON.parse(JSON.stringify(this.instance.lastInstances));\n\n    objects.duration = audioDuration * 1000;\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, start, end, isValid, text } = instancesList[i];\n\n      const words = getWords(text, this.config.wordCountItems);\n      objects.annotationWordCount += words.length;\n\n      const duration = (end - start) * 1000;\n      objects.annotationDuration += duration;\n\n      // changed segment\n      const equal = isEqual(instancesList[i], lastInstances[id]);\n      const incrementDuration = (isValid && !equal) ? duration : 0;\n      objects.incrementDuration += incrementDuration;\n      delete lastInstances[id];\n\n      if (isValid) {\n        objects.validDuration += duration;\n        const review = reviews.find((r) => r.instanceId === id);\n        if (review?.result === ReviewResult.REJECT) {\n          objects.rejectedValidDuration += duration;\n        } else {\n          objects.approvedValidDuration += duration;\n        }\n      }\n    }\n\n    // removed segment\n    const keys = Object.keys(lastInstances);\n    for (let n = 0; n < keys.length; n += 1) {\n      const { start, end, isValid } = lastInstances[keys[n]];\n      if (isValid) {\n        objects.incrementDuration += (end - start) * 1000;\n      }\n    }\n    return {\n      ...objects,\n      duration: Number(objects.duration.toFixed(2)),\n      validDuration: Number(objects.validDuration.toFixed(2)),\n      annotationDuration: Number(objects.annotationDuration.toFixed(2)),\n      approvedValidDuration: Number(objects.approvedValidDuration.toFixed(2)),\n      rejectedValidDuration: Number(objects.rejectedValidDuration.toFixed(2)),\n      incrementDuration: Number(objects.incrementDuration.toFixed(2)),\n    };\n  };\n\n  /**\n   * save file\n   * @param file\n   */\n  saveFile = (file: File) => this.jobProxy!.saveFile(file);\n}\n\nconst rootStore = new RootStore();\nexport type RootStoreType = typeof rootStore;\nexport default rootStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}