{"ast":null,"code":"import { makeAutoObservable, toJS } from 'mobx';\nimport { debounce } from 'lodash';\nimport { Graphics } from 'pixi.js';\nimport Validator from '../worker/validate.worker';\nimport CanvasValidator from '../worker/canvas-validate.worker';\nimport i18n from '../locales';\nimport { calcShapeArea } from '../utils';\nimport { ValidationType, ValidationInfoType, DisplayValidationType } from '../types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_MIN_AREA } from '../constants';\nimport { runCustomValidation } from '../../../utils';\nimport { ShapeType } from '../../common/shapes/types';\nimport PixelsData from '../../../utils/pixels';\nconst graphicsForEmptyArea = 'empty-area';\nconst graphicsForHighlight = 'highlight';\nfunction drawPolygon(ctx, polygon) {\n  if (polygon.length > 0) {\n    const side = polygon[0];\n    ctx.drawPolygon(side.flatMap(i => i));\n    const holes = polygon.slice(1);\n    holes.forEach(h => {\n      ctx.beginHole();\n      ctx.drawPolygon(h.flatMap(i => i));\n      ctx.endHole();\n    });\n  }\n}\nfunction drawPolygons(ctx, polygons) {\n  polygons.forEach(p => drawPolygon(ctx, p));\n}\n\n/**\n * store for validation\n * @class\n */\nexport default class ValidationStore {\n  /**\n   * all warning list\n   */\n  get warnings() {\n    return [...this.annotationWarnings, ...this.canvasWarnings];\n  }\n\n  /**\n   * warnings count\n   * @getter\n   */\n  get warningCount() {\n    return this.warnings.length + this.rootStore.review.rejectedCount;\n  }\n\n  /**\n   * should submit check\n   * @getter\n   */\n  get submitCheck() {\n    // 存在需要阻止提交的检查项，在提交前需执行检查\n    return Object.values(this.rootStore.config.validationConfig).some(i => i);\n  }\n\n  /**\n   * has error or blocked issue\n   * @getter\n   */\n  get blocked() {\n    return this.hasCustomError || this.warnings.filter(warning => warning.blockSubmit === true).length > 0;\n  }\n\n  /**\n   * is auto sync enabled\n   * @getter\n   */\n  get autoSyncEnabled() {\n    const {\n      validationConfig\n    } = this.rootStore.config;\n    return validationConfig.has(ValidationType.CUSTOM) || validationConfig.has(ValidationType.SCRIPT);\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * default validate worker\n     */\n    this.validator = new Validator();\n    /**\n     * canvas validate worker\n     */\n    this.canvasValidator = new CanvasValidator();\n    /**\n     * is validation tab active\n     */\n    this.tabActive = false;\n    /**\n     * annotation warning list\n     */\n    this.annotationWarnings = [];\n    /**\n     * canvas warning list\n     */\n    this.canvasWarnings = [];\n    /**\n     * has custom error\n     */\n    this.hasCustomError = false;\n    /**\n     * is checking\n     */\n    this.checking = false;\n    /**\n     * is canvas checking\n     */\n    this.canvasChecking = false;\n    /**\n     * empty area visibility\n     */\n    this.emptyAreaVisible = true;\n    /**\n     * highlight visibility\n     */\n    this.highlightVisible = true;\n    /**\n     * cached empty area results\n     */\n    this.emptyAreaResults = {};\n    /**\n     * cached highlight results\n     */\n    this.highlightResults = {};\n    /**\n     * highlighting timer\n     */\n    this.highlightingTimer = null;\n    /**\n     * trigger sync automatically\n     * @param savedResult\n     */\n    this.autoSync = debounce(savedResult => {\n      if (this.autoSyncEnabled && !this.tabActive && !this.checking) {\n        // do auto sync\n        this.defaultSync(false, savedResult);\n      }\n    }, 100);\n    /**\n     * stop canvas validation\n     */\n    this.stopValidate = () => {\n      this.canvasChecking = false;\n      this.canvasValidator.postMessage({\n        type: 'stop'\n      });\n    };\n    /**\n     * toggle pixels visibility by warning\n     * @param warning\n     */\n    this.togglePixelsVisibility = warning => {\n      if (warning.info) {\n        const {\n          camera = DEFAULT_CAMERA_NAME,\n          pixelsVisible\n        } = warning.info;\n        warning.info.pixelsVisible = !pixelsVisible;\n        if (warning.info.pixelsVisible && !this.highlightVisible) {\n          this.highlightVisible = true;\n        }\n        this.drawHighlight(camera);\n      }\n    };\n    /**\n     * set highlighting for warning\n     * @param warning\n     */\n    this.highlighting = warning => {\n      if (this.highlightingTimer !== null) {\n        window.clearInterval(this.highlightingTimer);\n        this.highlightingTimer = null;\n      }\n      const {\n        camera = DEFAULT_CAMERA_NAME,\n        pixelsData\n      } = warning.info || {};\n      if (pixelsData) {\n        let count = 10;\n        this.highlightingTimer = window.setInterval(() => {\n          this.drawHighlight(camera, pixelsData, count);\n          count -= 1;\n          if (count < 0) {\n            window.clearInterval(this.highlightingTimer);\n            this.highlightingTimer = null;\n          }\n        }, 60);\n      }\n    };\n    makeAutoObservable(this, {\n      rootStore: false,\n      validator: false,\n      canvasValidator: false,\n      tabActive: false,\n      emptyAreaResults: false,\n      blocked: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n    this.canvasValidator.addEventListener('message', e => {\n      const {\n        type,\n        finished = false\n      } = e.data;\n      if (this.canvasChecking && !finished) {\n        if (type === ValidationType.EMPTY_AREA) {\n          const {\n            cameraName,\n            frameIndex,\n            emptyPolygons\n          } = e.data;\n          this.saveEmptyAreaResults(cameraName, frameIndex, emptyPolygons);\n          const {\n            currentFrame\n          } = this.rootStore.frame;\n          if (frameIndex === currentFrame) {\n            this.drawEmptyArea(cameraName);\n          }\n        }\n        if (type === ValidationType.FULLY_COVERED) {\n          const {\n            cameraName,\n            frameIndex,\n            coveredShapes\n          } = e.data;\n          this.saveFullyCoveredResults(cameraName, frameIndex, coveredShapes);\n        }\n      } else if (finished) {\n        this.canvasChecking = false;\n      }\n    });\n    this.canvasValidator.addEventListener('error', () => {\n      this.canvasChecking = false;\n    });\n  }\n\n  /**\n   * set empty area visibility\n   * @param visible\n   */\n  setEmptyAreaVisibility(visible) {\n    this.emptyAreaVisible = visible;\n    this.redrawCheckLayer();\n  }\n\n  /**\n   * set highlight visibility\n   * @param visible\n   */\n  setHighlightVisibility(visible) {\n    this.highlightVisible = visible;\n    this.warnings.forEach(warning => {\n      const {\n        type\n      } = warning.info || {};\n      if (type === ValidationInfoType.HIGHLIGHT) {\n        if (!warning.info) {\n          warning.info = {};\n        }\n        warning.info.pixelsVisible = visible;\n      }\n    });\n    this.redrawCheckLayer();\n  }\n\n  /**\n   * trigger sync\n   */\n  async sync() {\n    if (this.checking || this.canvasChecking) {\n      return;\n    }\n    this.defaultSync();\n    // validate canvas\n    this.validateCanvas();\n  }\n  /**\n   * trigger default sync\n   * @param isSubmit\n   * @param savedResult\n   */\n  async defaultSync(isSubmit = false, savedResult) {\n    this.checking = true;\n    const {\n      validationConfig\n    } = this.rootStore.config;\n    const checkBoundary = validationConfig.has(ValidationType.OUT_OF_BOUNDARY);\n    if (checkBoundary && isSubmit) {\n      // only check all image boundary when submit\n      await this.rootStore.frame.fixImageSize();\n    }\n    let resultLink = (savedResult === null || savedResult === void 0 ? void 0 : savedResult.resultLink) || '';\n    let result = savedResult === null || savedResult === void 0 ? void 0 : savedResult.result;\n    if (!savedResult) {\n      if (this.rootStore.annotatable) {\n        try {\n          const res = await this.rootStore.saveResultPure();\n          resultLink = res.resultLink;\n          result = res.result;\n        } catch (e) {\n          // save error\n        }\n      } else if (typeof this.rootStore.initialLink === 'string' && this.rootStore.initialLink) {\n        // use initial data\n        resultLink = this.rootStore.initialLink;\n        result = await fetch(resultLink).then(res => res.text());\n      }\n    }\n    return new Promise(async resolve => {\n      const results = [];\n      let hasCustomError = false;\n      if (validationConfig.has(ValidationType.CUSTOM)) {\n        var _this$rootStore$confi, _this$rootStore$jobPr;\n        // custom check\n        const customResult = await runCustomValidation((_this$rootStore$confi = this.rootStore.config.customValidationConfig) !== null && _this$rootStore$confi !== void 0 ? _this$rootStore$confi : [], resultLink, (_this$rootStore$jobPr = this.rootStore.jobProxy) === null || _this$rootStore$jobPr === void 0 ? void 0 : _this$rootStore$jobPr.flowData);\n        customResult.results.forEach(r => {\n          results.push({\n            ...r,\n            blockSubmit: r.blockSubmit && validationConfig.get(ValidationType.CUSTOM),\n            type: DisplayValidationType.CUSTOM,\n            actualType: ValidationType.CUSTOM\n          });\n        });\n        hasCustomError = customResult.hasCustomError;\n      }\n      if (validationConfig.has(ValidationType.SCRIPT)) {\n        try {\n          var _this$rootStore$jobPr2, _this$rootStore$jobPr3, _this$rootStore$jobPr4;\n          const validateResults = (await ((_this$rootStore$jobPr2 = this.rootStore.jobProxy) === null || _this$rootStore$jobPr2 === void 0 ? void 0 : (_this$rootStore$jobPr3 = _this$rootStore$jobPr2.validateContent) === null || _this$rootStore$jobPr3 === void 0 ? void 0 : _this$rootStore$jobPr3.call(_this$rootStore$jobPr2, resultLink, (_this$rootStore$jobPr4 = this.rootStore.jobProxy) === null || _this$rootStore$jobPr4 === void 0 ? void 0 : _this$rootStore$jobPr4.flowData))) || [];\n          validateResults.forEach(r => {\n            var _r$data;\n            const out = JSON.parse((r === null || r === void 0 ? void 0 : (_r$data = r.data) === null || _r$data === void 0 ? void 0 : _r$data.out_str) || '{}');\n            if ((r === null || r === void 0 ? void 0 : r.status_code) === 200 && Array.isArray(out)) {\n              out.forEach(item => {\n                results.push({\n                  id: item.id,\n                  message: item.message,\n                  frames: item.frames,\n                  info: {\n                    ...item.info\n                  },\n                  blockSubmit: item.blockSubmit && validationConfig.get(ValidationType.SCRIPT),\n                  type: DisplayValidationType.SCRIPT,\n                  actualType: ValidationType.SCRIPT\n                });\n              });\n            } else {\n              hasCustomError = true;\n            }\n          });\n        } catch (error) {\n          hasCustomError = true;\n          console.log('script validation error', error);\n        }\n      }\n      const finishCheck = (workerResults = []) => {\n        this.annotationWarnings = results.concat(workerResults.map(r => ({\n          ...r,\n          message: i18n.translate(r.message, r.messageOptions)\n        })));\n        this.hasCustomError = hasCustomError;\n        // reset cached pixels data\n        this.highlightResults = {};\n        // redraw check layer\n        this.redrawCheckLayer();\n        this.checking = false;\n        resolve();\n      };\n      if (!result) {\n        finishCheck();\n      } else {\n        // do built-in validations\n        this.validator.onmessage = e => finishCheck(e.data.results);\n        this.validator.onerror = () => finishCheck();\n        this.validator.postMessage({\n          result,\n          config: toJS(validationConfig),\n          categories: toJS(this.rootStore.ontology.categories),\n          minArea: this.rootStore.config.minArea,\n          frameConfig: toJS(this.rootStore.frame.frameConfig),\n          commonFrameConfig: toJS(this.rootStore.frame.commonFrameConfig)\n        });\n      }\n    });\n  }\n\n  /**\n   * do canvas validation\n   */\n  validateCanvas() {\n    const {\n      validationConfig\n    } = this.rootStore.config;\n    if (validationConfig.has(ValidationType.EMPTY_AREA) || validationConfig.has(ValidationType.FULLY_COVERED)) {\n      this.canvasChecking = true;\n      this.canvasWarnings = [];\n      this.canvasValidator.postMessage({\n        config: toJS(this.rootStore.config.validationConfig),\n        cameras: toJS(this.rootStore.frame.cameraImages),\n        cameraAttributes: toJS(this.rootStore.frame.attributes),\n        instances: this.rootStore.instance.instancesJSON()\n      });\n    }\n  }\n  /**\n   * save empty area results\n   * @param camera\n   * @param frameIndex\n   * @param polygons\n   */\n  saveEmptyAreaResults(camera, frameIndex, polygons) {\n    if (!this.emptyAreaResults[camera]) {\n      this.emptyAreaResults[camera] = {};\n    }\n    this.emptyAreaResults[camera][frameIndex] = [];\n    polygons.forEach((p, i) => {\n      const side = p[0];\n      const area = calcShapeArea(ShapeType.POLYGON, {\n        points: side.map(point => ({\n          x: point[0],\n          y: point[1]\n        }))\n      });\n      if (area < DEFAULT_MIN_AREA) {\n        return;\n      }\n      this.emptyAreaResults[camera][frameIndex].push(p);\n      const xArr = side.map(pair => pair[0]);\n      const yArr = side.map(pair => pair[1]);\n      const left = Math.min(...xArr);\n      const right = Math.max(...xArr);\n      const top = Math.min(...yArr);\n      const bottom = Math.max(...yArr);\n      this.canvasWarnings.push({\n        type: DisplayValidationType.EMPTY_AREA,\n        actualType: ValidationType.EMPTY_AREA,\n        id: `${camera}-${frameIndex}-${i}`,\n        message: i18n.translate('VALIDATION_TYPE_EMPTY_AREA_MSG', {\n          values: {\n            frame: frameIndex + 1\n          }\n        }),\n        frames: [frameIndex],\n        info: {\n          index: i,\n          bbox: {\n            left,\n            top,\n            right,\n            bottom\n          },\n          camera\n        }\n      });\n    });\n  }\n\n  /**\n   * save fully covered results\n   * @param camera\n   * @param frameIndex\n   * @param items\n   */\n  saveFullyCoveredResults(camera, frameIndex, items) {\n    items.forEach(({\n      instanceId,\n      instanceItemId\n    }) => {\n      this.canvasWarnings.push({\n        type: DisplayValidationType.FULLY_COVERED,\n        actualType: ValidationType.FULLY_COVERED,\n        id: `${camera}-${frameIndex}-${instanceItemId}`,\n        message: i18n.translate('VALIDATION_TYPE_FULLY_COVERED_MSG', {\n          values: {\n            frame: frameIndex + 1\n          }\n        }),\n        frames: [frameIndex],\n        info: {\n          instanceId,\n          instanceItemId,\n          camera\n        }\n      });\n    });\n  }\n\n  /**\n   * draw empty area\n   * @param camera\n   */\n  drawEmptyArea(camera) {\n    const {\n      currentFrame,\n      cameraViews\n    } = this.rootStore.frame;\n    const cameraView = cameraViews[camera];\n    if (cameraView && cameraView.checkLayer) {\n      var _this$emptyAreaResult;\n      const og = cameraView.checkLayer.getChildByName(graphicsForEmptyArea);\n      if (og) {\n        cameraView.checkLayer.removeChild(og);\n      }\n      const emptyPolygons = (_this$emptyAreaResult = this.emptyAreaResults[camera]) === null || _this$emptyAreaResult === void 0 ? void 0 : _this$emptyAreaResult[currentFrame];\n      if (this.emptyAreaVisible && (emptyPolygons === null || emptyPolygons === void 0 ? void 0 : emptyPolygons.length) > 0) {\n        const g = new Graphics();\n        g.name = graphicsForEmptyArea;\n        g.lineStyle(4 / cameraView.viewScale, 0xFF0000);\n        g.beginFill(0xFFFF00, 0.5);\n        emptyPolygons.forEach(polygon => drawPolygon(g, polygon));\n        cameraView.checkLayer.addChild(g);\n      }\n    }\n  }\n\n  /**\n   * draw highlight\n   * @param camera\n   * @param highlightPixels\n   * @param highlightCount\n   */\n  drawHighlight(camera, highlightPixels, highlightCount) {\n    const {\n      currentFrame,\n      cameraViews\n    } = this.rootStore.frame;\n    const cameraView = cameraViews[camera];\n    if (cameraView && cameraView.checkLayer) {\n      var _this$highlightResult, _this$highlightResult2;\n      const og = cameraView.checkLayer.getChildByName(graphicsForHighlight);\n      if (og) {\n        cameraView.checkLayer.removeChild(og);\n      }\n      if (!((_this$highlightResult = this.highlightResults[camera]) === null || _this$highlightResult === void 0 ? void 0 : _this$highlightResult[currentFrame])) {\n        // not cached\n        for (let i = 0; i < this.warnings.length; i += 1) {\n          const {\n            frames,\n            info\n          } = this.warnings[i];\n          const {\n            type,\n            pixels,\n            camera: infoCamera = DEFAULT_CAMERA_NAME\n          } = info || {};\n          if (type === ValidationInfoType.HIGHLIGHT && pixels && infoCamera === camera && frames.includes(currentFrame)) {\n            try {\n              const pixelsData = new PixelsData({\n                data: pixels,\n                size: pixels.size\n              });\n              if (!this.highlightResults[camera]) {\n                this.highlightResults[camera] = {};\n              }\n              if (!this.highlightResults[camera][currentFrame]) {\n                this.highlightResults[camera][currentFrame] = [];\n              }\n              this.warnings[i].info.pixelsData = pixelsData;\n              this.warnings[i].info.pixelsVisible = true;\n              this.highlightResults[camera][currentFrame].push(this.warnings[i]);\n            } catch (e) {\n              // error\n            }\n          }\n        }\n      }\n      const cachedResults = (_this$highlightResult2 = this.highlightResults[camera]) === null || _this$highlightResult2 === void 0 ? void 0 : _this$highlightResult2[currentFrame];\n      if (this.highlightVisible && (cachedResults === null || cachedResults === void 0 ? void 0 : cachedResults.length) > 0) {\n        const g = new Graphics();\n        g.name = graphicsForHighlight;\n        g.beginFill(0xFF0000, 0.5);\n        cachedResults.forEach(warning => {\n          const {\n            pixelsData,\n            pixelsVisible\n          } = warning.info || {};\n          if (pixelsData && pixelsVisible) {\n            drawPolygons(g, pixelsData.cachedPolygons);\n          }\n        });\n        if (highlightPixels && highlightCount) {\n          const alpha = 0.1 + Math.sin(highlightCount) * 0.1;\n          g.beginFill(0xFFFFFF, alpha);\n          drawPolygons(g, highlightPixels.cachedPolygons);\n        }\n        cameraView.checkLayer.addChild(g);\n      }\n    }\n  }\n  /**\n   * redraw by current frame info\n   */\n  redrawCheckLayer() {\n    const {\n      cameraViews\n    } = this.rootStore.frame;\n    Object.keys(cameraViews).forEach(camera => {\n      const {\n        checkLayer\n      } = cameraViews[camera];\n      if (checkLayer) {\n        checkLayer.removeChildren();\n      }\n      this.drawEmptyArea(camera);\n      this.drawHighlight(camera);\n    });\n  }\n\n  /**\n   * redraw check layer by camera\n   * @param camera\n   */\n  redrawCheckLayerByCamera(camera) {\n    const {\n      cameraViews\n    } = this.rootStore.frame;\n    const view = cameraViews[camera];\n    if (view) {\n      const {\n        checkLayer\n      } = view;\n      if (checkLayer) {\n        checkLayer.removeChildren();\n      }\n      this.drawEmptyArea(camera);\n      this.drawHighlight(camera);\n    }\n  }\n\n  /**\n   * worker terminate\n   */\n  terminate() {\n    this.validator.terminate();\n    this.canvasValidator.terminate();\n  }\n}","map":{"version":3,"names":["makeAutoObservable","toJS","debounce","Graphics","Validator","CanvasValidator","i18n","calcShapeArea","ValidationType","ValidationInfoType","DisplayValidationType","DEFAULT_CAMERA_NAME","DEFAULT_MIN_AREA","runCustomValidation","ShapeType","PixelsData","graphicsForEmptyArea","graphicsForHighlight","drawPolygon","ctx","polygon","length","side","flatMap","i","holes","slice","forEach","h","beginHole","endHole","drawPolygons","polygons","p","ValidationStore","warnings","annotationWarnings","canvasWarnings","warningCount","rootStore","review","rejectedCount","submitCheck","Object","values","config","validationConfig","some","blocked","hasCustomError","filter","warning","blockSubmit","autoSyncEnabled","has","CUSTOM","SCRIPT","constructor","validator","canvasValidator","tabActive","checking","canvasChecking","emptyAreaVisible","highlightVisible","emptyAreaResults","highlightResults","highlightingTimer","autoSync","savedResult","defaultSync","stopValidate","postMessage","type","togglePixelsVisibility","info","camera","pixelsVisible","drawHighlight","highlighting","window","clearInterval","pixelsData","count","setInterval","autoBind","addEventListener","e","finished","data","EMPTY_AREA","cameraName","frameIndex","emptyPolygons","saveEmptyAreaResults","currentFrame","frame","drawEmptyArea","FULLY_COVERED","coveredShapes","saveFullyCoveredResults","setEmptyAreaVisibility","visible","redrawCheckLayer","setHighlightVisibility","HIGHLIGHT","sync","validateCanvas","isSubmit","checkBoundary","OUT_OF_BOUNDARY","fixImageSize","resultLink","result","annotatable","res","saveResultPure","initialLink","fetch","then","text","Promise","resolve","results","_this$rootStore$confi","_this$rootStore$jobPr","customResult","customValidationConfig","jobProxy","flowData","r","push","get","actualType","_this$rootStore$jobPr2","_this$rootStore$jobPr3","_this$rootStore$jobPr4","validateResults","validateContent","call","_r$data","out","JSON","parse","out_str","status_code","Array","isArray","item","id","message","frames","error","console","log","finishCheck","workerResults","concat","map","translate","messageOptions","onmessage","onerror","categories","ontology","minArea","frameConfig","commonFrameConfig","cameras","cameraImages","cameraAttributes","attributes","instances","instance","instancesJSON","area","POLYGON","points","point","x","y","xArr","pair","yArr","left","Math","min","right","max","top","bottom","index","bbox","items","instanceId","instanceItemId","cameraViews","cameraView","checkLayer","_this$emptyAreaResult","og","getChildByName","removeChild","g","name","lineStyle","viewScale","beginFill","addChild","highlightPixels","highlightCount","_this$highlightResult","_this$highlightResult2","pixels","infoCamera","includes","size","cachedResults","cachedPolygons","alpha","sin","keys","removeChildren","redrawCheckLayerByCamera","view","terminate"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/ValidationStore.ts"],"sourcesContent":["import { makeAutoObservable, toJS } from 'mobx';\nimport { debounce } from 'lodash';\nimport { Graphics } from 'pixi.js';\nimport { MultiPolygon, Polygon } from 'polygon-clipping';\nimport RootStore from './RootStore';\nimport Validator, { ValidationResultWithoutTranslation } from '../worker/validate.worker';\nimport CanvasValidator from '../worker/canvas-validate.worker';\nimport i18n from '../locales';\nimport { calcShapeArea } from '../utils';\nimport { ValidationType, ValidationResult, ValidationInfoType, DisplayValidationType } from '../types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_MIN_AREA } from '../constants';\nimport { runCustomValidation } from '../../../utils';\nimport { ShapeType } from '../../common/shapes/types';\nimport PixelsData from '../../../utils/pixels';\n\nconst graphicsForEmptyArea = 'empty-area';\nconst graphicsForHighlight = 'highlight';\nfunction drawPolygon(ctx: Graphics, polygon: Polygon) {\n  if (polygon.length > 0) {\n    const side = polygon[0];\n    ctx.drawPolygon(side.flatMap((i) => i));\n\n    const holes = polygon.slice(1);\n    holes.forEach((h) => {\n      ctx.beginHole();\n      ctx.drawPolygon(h.flatMap((i) => i));\n      ctx.endHole();\n    });\n  }\n}\nfunction drawPolygons(ctx: Graphics, polygons: MultiPolygon) {\n  polygons.forEach((p) => drawPolygon(ctx, p));\n}\n\n/**\n * store for validation\n * @class\n */\nexport default class ValidationStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * default validate worker\n   */\n  validator = new Validator();\n\n  /**\n   * canvas validate worker\n   */\n  canvasValidator = new CanvasValidator();\n\n  /**\n   * is validation tab active\n   */\n  tabActive = false;\n\n  /**\n   * annotation warning list\n   */\n  annotationWarnings: ValidationResult[] = [];\n\n  /**\n   * canvas warning list\n   */\n  canvasWarnings: ValidationResult[] = [];\n\n  /**\n   * has custom error\n   */\n  hasCustomError = false;\n\n  /**\n   * is checking\n   */\n  checking = false;\n\n  /**\n   * is canvas checking\n   */\n  canvasChecking = false;\n\n  /**\n   * empty area visibility\n   */\n  emptyAreaVisible = true;\n\n  /**\n   * highlight visibility\n   */\n  highlightVisible = true;\n\n  /**\n   * cached empty area results\n   */\n  emptyAreaResults: {\n    [camera: string]: {\n      [frameIndex: number]: MultiPolygon;\n    }\n  } = {};\n\n  /**\n   * cached highlight results\n   */\n  highlightResults: {\n    [camera: string]: {\n      [frameIndex: number]: ValidationResult[];\n    }\n  } = {};\n\n  /**\n   * highlighting timer\n   */\n  highlightingTimer: number | null = null;\n\n  /**\n   * all warning list\n   */\n  get warnings() {\n    return [\n      ...this.annotationWarnings,\n      ...this.canvasWarnings\n    ];\n  }\n\n  /**\n   * warnings count\n   * @getter\n   */\n  get warningCount() {\n    return this.warnings.length + this.rootStore.review.rejectedCount;\n  }\n\n  /**\n   * should submit check\n   * @getter\n   */\n  get submitCheck() {\n    // 存在需要阻止提交的检查项，在提交前需执行检查\n    return Object.values(this.rootStore.config.validationConfig).some((i) => i);\n  }\n\n  /**\n   * has error or blocked issue\n   * @getter\n   */\n  get blocked() {\n    return this.hasCustomError || this.warnings.filter((warning) => warning.blockSubmit === true).length > 0;\n  }\n\n  /**\n   * is auto sync enabled\n   * @getter\n   */\n  get autoSyncEnabled() {\n    const { validationConfig } = this.rootStore.config;\n    return validationConfig.has(ValidationType.CUSTOM) || validationConfig.has(ValidationType.SCRIPT);\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      validator: false,\n      canvasValidator: false,\n      tabActive: false,\n      emptyAreaResults: false,\n      blocked: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n    this.canvasValidator.addEventListener('message', (e: MessageEvent) => {\n      const { type, finished = false } = e.data;\n      if (this.canvasChecking && !finished) {\n        if (type === ValidationType.EMPTY_AREA) {\n          const { cameraName, frameIndex, emptyPolygons } = e.data;\n          this.saveEmptyAreaResults(cameraName, frameIndex, emptyPolygons);\n          const { currentFrame } = this.rootStore.frame;\n          if (frameIndex === currentFrame) {\n            this.drawEmptyArea(cameraName);\n          }\n        }\n        if (type === ValidationType.FULLY_COVERED) {\n          const { cameraName, frameIndex, coveredShapes } = e.data;\n          this.saveFullyCoveredResults(cameraName, frameIndex, coveredShapes);\n        }\n      } else if (finished) {\n        this.canvasChecking = false;\n      }\n    });\n    this.canvasValidator.addEventListener('error', () => {\n      this.canvasChecking = false;\n    });\n  }\n\n  /**\n   * set empty area visibility\n   * @param visible\n   */\n  setEmptyAreaVisibility(visible: boolean) {\n    this.emptyAreaVisible = visible;\n    this.redrawCheckLayer();\n  }\n\n  /**\n   * set highlight visibility\n   * @param visible\n   */\n  setHighlightVisibility(visible: boolean) {\n    this.highlightVisible = visible;\n    this.warnings.forEach((warning) => {\n      const { type } = warning.info || {};\n      if (type === ValidationInfoType.HIGHLIGHT) {\n        if (!warning.info) {\n          warning.info = {};\n        }\n        warning.info.pixelsVisible = visible;\n      }\n    });\n    this.redrawCheckLayer();\n  }\n\n  /**\n   * trigger sync\n   */\n  async sync() {\n    if (this.checking || this.canvasChecking) {\n      return;\n    }\n    this.defaultSync();\n    // validate canvas\n    this.validateCanvas();\n  }\n\n  /**\n   * trigger sync automatically\n   * @param savedResult\n   */\n  autoSync = debounce((savedResult: { resultLink: string; result: string }) => {\n    if (this.autoSyncEnabled && !this.tabActive && !this.checking) {\n      // do auto sync\n      this.defaultSync(false, savedResult);\n    }\n  }, 100);\n\n  /**\n   * trigger default sync\n   * @param isSubmit\n   * @param savedResult\n   */\n  async defaultSync(isSubmit = false, savedResult?: { resultLink: string; result: string }) {\n    this.checking = true;\n\n    const { validationConfig } = this.rootStore.config;\n\n    const checkBoundary = validationConfig.has(ValidationType.OUT_OF_BOUNDARY);\n    if (checkBoundary && isSubmit) {\n      // only check all image boundary when submit\n      await this.rootStore.frame.fixImageSize();\n    }\n\n    let resultLink = savedResult?.resultLink || '';\n    let result = savedResult?.result;\n\n    if (!savedResult) {\n      if (this.rootStore.annotatable) {\n        try {\n          const res = await this.rootStore.saveResultPure();\n          resultLink = res.resultLink;\n          result = res.result;\n        } catch (e) {\n          // save error\n        }\n      } else if (typeof this.rootStore.initialLink === 'string' && this.rootStore.initialLink) {\n        // use initial data\n        resultLink = this.rootStore.initialLink;\n        result = await fetch(resultLink).then((res) => res.text());\n      }\n    }\n\n    return new Promise<void>(async (resolve) => {\n      const results: ValidationResult[] = [];\n      let hasCustomError = false;\n\n      if (validationConfig.has(ValidationType.CUSTOM)) {\n        // custom check\n        const customResult = await runCustomValidation(this.rootStore.config.customValidationConfig ?? [], resultLink, this.rootStore.jobProxy?.flowData);\n        customResult.results.forEach((r) => {\n          results.push({\n            ...r,\n            blockSubmit: r.blockSubmit && validationConfig.get(ValidationType.CUSTOM),\n            type: DisplayValidationType.CUSTOM,\n            actualType: ValidationType.CUSTOM,\n          });\n        });\n        hasCustomError = customResult.hasCustomError;\n      }\n\n      if (validationConfig.has(ValidationType.SCRIPT)) {\n        try {\n          const validateResults = await this.rootStore.jobProxy?.validateContent?.(resultLink, this.rootStore.jobProxy?.flowData) || [];\n          validateResults.forEach((r: any) => {\n            const out = JSON.parse(r?.data?.out_str || '{}');\n            if (r?.status_code === 200 && Array.isArray(out)) {\n              out.forEach((item) => {\n                results.push({\n                  id: item.id,\n                  message: item.message,\n                  frames: item.frames,\n                  info: { ...item.info },\n                  blockSubmit: item.blockSubmit && validationConfig.get(ValidationType.SCRIPT),\n                  type: DisplayValidationType.SCRIPT,\n                  actualType: ValidationType.SCRIPT,\n                });\n              });\n            } else {\n              hasCustomError = true;\n            }\n          });\n        } catch (error) {\n          hasCustomError = true;\n          console.log('script validation error', error);\n        }\n      }\n\n      const finishCheck = (workerResults: ValidationResultWithoutTranslation[] = []) => {\n        this.annotationWarnings = results.concat(workerResults.map((r: ValidationResultWithoutTranslation) => ({\n          ...r,\n          message: i18n.translate(r.message, r.messageOptions),\n        })));\n        this.hasCustomError = hasCustomError;\n        // reset cached pixels data\n        this.highlightResults = {};\n        // redraw check layer\n        this.redrawCheckLayer();\n        this.checking = false;\n        resolve();\n      };\n\n      if (!result) {\n        finishCheck();\n      } else {\n        // do built-in validations\n        this.validator.onmessage = (e: MessageEvent) => finishCheck(e.data.results);\n        this.validator.onerror = () => finishCheck();\n        this.validator.postMessage({\n          result,\n          config: toJS(validationConfig),\n          categories: toJS(this.rootStore.ontology.categories),\n          minArea: this.rootStore.config.minArea,\n          frameConfig: toJS(this.rootStore.frame.frameConfig),\n          commonFrameConfig: toJS(this.rootStore.frame.commonFrameConfig),\n        });\n      }\n    });\n  }\n\n  /**\n   * do canvas validation\n   */\n  validateCanvas() {\n    const { validationConfig } = this.rootStore.config;\n    if (\n      validationConfig.has(ValidationType.EMPTY_AREA) ||\n      validationConfig.has(ValidationType.FULLY_COVERED)\n    ) {\n      this.canvasChecking = true;\n      this.canvasWarnings = [];\n      this.canvasValidator.postMessage({\n        config: toJS(this.rootStore.config.validationConfig),\n        cameras: toJS(this.rootStore.frame.cameraImages),\n        cameraAttributes: toJS(this.rootStore.frame.attributes),\n        instances: this.rootStore.instance.instancesJSON(),\n      });\n    }\n  }\n\n  /**\n   * stop canvas validation\n   */\n  stopValidate = () => {\n    this.canvasChecking = false;\n    this.canvasValidator.postMessage({\n      type: 'stop',\n    });\n  };\n\n  /**\n   * save empty area results\n   * @param camera\n   * @param frameIndex\n   * @param polygons\n   */\n  saveEmptyAreaResults(camera: string, frameIndex: number, polygons: MultiPolygon) {\n    if (!this.emptyAreaResults[camera]) {\n      this.emptyAreaResults[camera] = {};\n    }\n    this.emptyAreaResults[camera][frameIndex] = [];\n    polygons.forEach((p, i) => {\n      const side = p[0];\n      const area = calcShapeArea(ShapeType.POLYGON, { points: side.map((point) => ({ x: point[0], y: point[1] })) });\n      if (area < DEFAULT_MIN_AREA) {\n        return;\n      }\n      this.emptyAreaResults[camera][frameIndex].push(p);\n      const xArr = side.map((pair) => pair[0]);\n      const yArr = side.map((pair) => pair[1]);\n      const left = Math.min(...xArr);\n      const right = Math.max(...xArr);\n      const top = Math.min(...yArr);\n      const bottom = Math.max(...yArr);\n      this.canvasWarnings.push({\n        type: DisplayValidationType.EMPTY_AREA,\n        actualType: ValidationType.EMPTY_AREA,\n        id: `${camera}-${frameIndex}-${i}`,\n        message: i18n.translate('VALIDATION_TYPE_EMPTY_AREA_MSG', { values: { frame: frameIndex + 1 } }),\n        frames: [frameIndex],\n        info: {\n          index: i,\n          bbox: { left, top, right, bottom },\n          camera,\n        },\n      });\n    });\n  }\n\n  /**\n   * save fully covered results\n   * @param camera\n   * @param frameIndex\n   * @param items\n   */\n  saveFullyCoveredResults(camera: string, frameIndex: number, items: { instanceId: string; instanceItemId: string }[]) {\n    items.forEach(({ instanceId, instanceItemId }) => {\n      this.canvasWarnings.push({\n        type: DisplayValidationType.FULLY_COVERED,\n        actualType: ValidationType.FULLY_COVERED,\n        id: `${camera}-${frameIndex}-${instanceItemId}`,\n        message: i18n.translate('VALIDATION_TYPE_FULLY_COVERED_MSG', { values: { frame: frameIndex + 1 } }),\n        frames: [frameIndex],\n        info: {\n          instanceId,\n          instanceItemId,\n          camera,\n        },\n      });\n    });\n  }\n\n  /**\n   * draw empty area\n   * @param camera\n   */\n  drawEmptyArea(camera: string) {\n    const { currentFrame, cameraViews } = this.rootStore.frame;\n    const cameraView = cameraViews[camera];\n    if (cameraView && cameraView.checkLayer) {\n      const og = cameraView.checkLayer.getChildByName(graphicsForEmptyArea);\n      if (og) {\n        cameraView.checkLayer.removeChild(og);\n      }\n\n      const emptyPolygons = this.emptyAreaResults[camera]?.[currentFrame];\n      if (this.emptyAreaVisible && emptyPolygons?.length > 0) {\n        const g = new Graphics();\n        g.name = graphicsForEmptyArea;\n        g.lineStyle(4 / cameraView.viewScale, 0xFF0000);\n        g.beginFill(0xFFFF00, 0.5);\n        emptyPolygons.forEach((polygon) => drawPolygon(g, polygon));\n        cameraView.checkLayer.addChild(g);\n      }\n    }\n  }\n\n  /**\n   * draw highlight\n   * @param camera\n   * @param highlightPixels\n   * @param highlightCount\n   */\n  drawHighlight(camera: string, highlightPixels?: PixelsData, highlightCount?: number) {\n    const { currentFrame, cameraViews } = this.rootStore.frame;\n    const cameraView = cameraViews[camera];\n    if (cameraView && cameraView.checkLayer) {\n      const og = cameraView.checkLayer.getChildByName(graphicsForHighlight);\n      if (og) {\n        cameraView.checkLayer.removeChild(og);\n      }\n\n      if (!this.highlightResults[camera]?.[currentFrame]) {\n        // not cached\n        for (let i = 0; i < this.warnings.length; i += 1) {\n          const { frames, info } = this.warnings[i];\n          const {\n            type,\n            pixels,\n            camera: infoCamera = DEFAULT_CAMERA_NAME,\n          } = info || {};\n          if (type === ValidationInfoType.HIGHLIGHT && pixels && infoCamera === camera && frames.includes(currentFrame)) {\n            try {\n              const pixelsData = new PixelsData({ data: pixels, size: pixels.size });\n              if (!this.highlightResults[camera]) {\n                this.highlightResults[camera] = {};\n              }\n              if (!this.highlightResults[camera][currentFrame]) {\n                this.highlightResults[camera][currentFrame] = [];\n              }\n              this.warnings[i].info!.pixelsData = pixelsData;\n              this.warnings[i].info!.pixelsVisible = true;\n              this.highlightResults[camera][currentFrame].push(this.warnings[i]);\n            } catch (e) {\n              // error\n            }\n          }\n        }\n      }\n\n      const cachedResults = this.highlightResults[camera]?.[currentFrame];\n      if (this.highlightVisible && cachedResults?.length > 0) {\n        const g = new Graphics();\n        g.name = graphicsForHighlight;\n        g.beginFill(0xFF0000, 0.5);\n        cachedResults.forEach((warning) => {\n          const { pixelsData, pixelsVisible } = warning.info || {};\n          if (pixelsData && pixelsVisible) {\n            drawPolygons(g, pixelsData.cachedPolygons);\n          }\n        });\n\n        if (highlightPixels && highlightCount) {\n          const alpha = 0.1 + Math.sin(highlightCount) * 0.1;\n          g.beginFill(0xFFFFFF, alpha);\n          drawPolygons(g, highlightPixels.cachedPolygons);\n        }\n\n        cameraView.checkLayer.addChild(g);\n      }\n    }\n  }\n\n  /**\n   * toggle pixels visibility by warning\n   * @param warning\n   */\n  togglePixelsVisibility = (warning: ValidationResult) => {\n    if (warning.info) {\n      const { camera = DEFAULT_CAMERA_NAME, pixelsVisible } = warning.info;\n      warning.info.pixelsVisible = !pixelsVisible;\n      if (warning.info.pixelsVisible && !this.highlightVisible) {\n        this.highlightVisible = true;\n      }\n      this.drawHighlight(camera);\n    }\n  };\n\n  /**\n   * set highlighting for warning\n   * @param warning\n   */\n  highlighting = (warning: ValidationResult) => {\n    if (this.highlightingTimer !== null) {\n      window.clearInterval(this.highlightingTimer);\n      this.highlightingTimer = null;\n    }\n    const { camera = DEFAULT_CAMERA_NAME, pixelsData } = warning.info || {};\n    if (pixelsData) {\n      let count = 10;\n      this.highlightingTimer = window.setInterval(() => {\n        this.drawHighlight(camera, pixelsData, count);\n        count -= 1;\n        if (count < 0) {\n          window.clearInterval(this.highlightingTimer!);\n          this.highlightingTimer = null;\n        }\n      }, 60);\n    }\n  };\n\n  /**\n   * redraw by current frame info\n   */\n  redrawCheckLayer() {\n    const { cameraViews } = this.rootStore.frame;\n    Object.keys(cameraViews).forEach((camera) => {\n      const { checkLayer } = cameraViews[camera];\n      if (checkLayer) {\n        checkLayer.removeChildren();\n      }\n      this.drawEmptyArea(camera);\n      this.drawHighlight(camera);\n    });\n  }\n\n  /**\n   * redraw check layer by camera\n   * @param camera\n   */\n  redrawCheckLayerByCamera(camera: string) {\n    const { cameraViews } = this.rootStore.frame;\n    const view = cameraViews[camera];\n    if (view) {\n      const { checkLayer } = view;\n      if (checkLayer) {\n        checkLayer.removeChildren();\n      }\n      this.drawEmptyArea(camera);\n      this.drawHighlight(camera);\n    }\n  }\n\n  /**\n   * worker terminate\n   */\n  terminate() {\n    this.validator.terminate();\n    this.canvasValidator.terminate();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}