{"ast":null,"code":"import { Container } from 'pixi.js';\nimport polygonClipping from 'polygon-clipping';\nimport { ShapeType } from './types';\nimport ShapeGraphics from './ShapeGraphics';\nexport function coverTest(shape, shapes) {\n  if (shapes.length <= 0) {\n    return false;\n  }\n  const {\n    left: cLeft,\n    top: cTop,\n    right: cRight,\n    bottom: cBottom\n  } = shape.instance.getLocalBounds();\n  const shapeBounds = shapes.map(s => s.instance.getLocalBounds());\n  const intersectedBounds = [];\n\n  // if covered by any front shape, should be selected\n  const isCoveredByAnyShape = shapeBounds.some(bounds => {\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = bounds;\n    const covered = cLeft >= left && cRight <= right && cTop >= top && cBottom <= bottom;\n    const intersected = cLeft <= right && cRight >= left && cTop <= bottom && cBottom >= top;\n    if (intersected) {\n      intersectedBounds.push(bounds);\n    }\n    return covered;\n  });\n  if (isCoveredByAnyShape) {\n    return isCoveredByAnyShape;\n  }\n\n  // if covered by front shapes bounding box, should be selected\n  if (intersectedBounds.length <= 0) {\n    return false;\n  }\n  let {\n    left,\n    top,\n    right,\n    bottom\n  } = intersectedBounds[0];\n  for (let i = 1; i < intersectedBounds.length; i += 1) {\n    const bounds = intersectedBounds[i];\n    if (left <= bounds.right && right >= bounds.left && top <= bounds.bottom && bottom >= bounds.top) {\n      left = Math.min(left, bounds.left);\n      top = Math.min(top, bounds.top);\n      right = Math.max(right, bounds.right);\n      bottom = Math.max(bottom, bounds.bottom);\n    }\n  }\n  return cLeft >= left && cTop >= top && cRight <= right && cBottom <= bottom;\n}\nexport function hitTesting(point, localPoint, rootChildren) {\n  const allShapes = [];\n  let snappingPoint = null;\n  const getIntersections = children => {\n    let shapes = [];\n    for (let i = 0; i < children.length; i += 1) {\n      const child = children[i];\n      if (child.visible) {\n        if (child instanceof ShapeGraphics) {\n          if (!snappingPoint && child.shape.finished && !child.shape.resizing && !child.shape.dragging) {\n            const sp = child.shape.snapToPoint(localPoint);\n            if (sp) {\n              snappingPoint = sp;\n            }\n          }\n          if (child.interactive && child.shape.finished) {\n            allShapes.push(child.shape);\n            if (child.shape.shapeType === ShapeType.LINE) {\n              if (child.hitArea.contains(localPoint.x, localPoint.y)) {\n                shapes.push(child.shape);\n              }\n            } else if (child.containsPoint(point)) {\n              shapes.push(child.shape);\n            }\n          }\n        } else if (child instanceof Container) {\n          shapes = [...shapes, ...getIntersections(child.children)];\n        }\n      }\n    }\n    return shapes;\n  };\n  const originalIntersections = getIntersections(rootChildren);\n  const filteredIntersectionIds = [];\n  let intersections = [];\n  if (originalIntersections.length > 1) {\n    // filter out some shapes that cover all intersections\n    for (let i = 0; i < originalIntersections.length; i += 1) {\n      const curr = originalIntersections[i];\n      const others = [...originalIntersections.slice(0, i), ...originalIntersections.slice(i + 1)];\n      if (others.every(o => coverTest(o, [curr]))) {\n        filteredIntersectionIds.push(curr.uid);\n      } else {\n        intersections.push(curr);\n      }\n    }\n  } else {\n    intersections = [...originalIntersections];\n  }\n  intersections.sort((a, b) => {\n    const abox = a.instance.getLocalBounds();\n    const bbox = b.instance.getLocalBounds();\n    return abox.width * abox.height - bbox.width * bbox.height;\n  }); // sort by area, small shapes have higher priority\n\n  let intersection;\n  for (let i = 0; i < intersections.length; i += 1) {\n    const curr = intersections[i];\n    const otherIntersections = [...intersections.slice(0, i), ...intersections.slice(i + 1)];\n    if (coverTest(curr, otherIntersections)) {\n      // covered by other intersections\n      intersection = curr;\n      break;\n    }\n    const fronts = allShapes.filter(s => s.order > curr.order && !filteredIntersectionIds.includes(s.uid));\n    if (coverTest(curr, fronts)) {\n      // covered by front shapes\n      intersection = curr;\n      break;\n    }\n  }\n  return {\n    intersection: intersection || intersections[0],\n    snappingPoint\n  };\n}\nexport function findIntersections(currentShapeData, currentShapeBounds, currentShapeType, shapes) {\n  const intersections = [];\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    const {\n      shapeBounds\n    } = shape;\n    if (shapeBounds.left < currentShapeBounds.right && shapeBounds.right > currentShapeBounds.left && shapeBounds.top < currentShapeBounds.bottom && shapeBounds.bottom > currentShapeBounds.top) {\n      // bbox intersects\n      if (currentShapeType === ShapeType.DOT || shape.shapeType === ShapeType.DOT) {\n        // one of the shapes is dot\n        intersections.push(shape);\n      } else {\n        const shapeData = shape.getAreaAsGeoJSON();\n        const intersection = polygonClipping.intersection(currentShapeData, shapeData);\n        if (intersection.length > 0) {\n          intersections.push(shape);\n        }\n      }\n    }\n  }\n  return intersections;\n}\nexport function precise(num) {\n  return Math.round(num * 1000000) / 1000000;\n}\nexport function normalizePoints(points) {\n  const newPoints = [];\n  points.forEach((point, index) => {\n    const nextPoint = points[index === points.length - 1 ? 0 : index + 1];\n    const npx = precise(nextPoint[0]);\n    const npy = precise(nextPoint[1]);\n    const px = precise(point[0]);\n    const py = precise(point[1]);\n    if (px !== npx || py !== npy) {\n      newPoints.push({\n        x: px,\n        y: py\n      });\n    }\n  });\n  return newPoints;\n}\nexport function drawVertex(graphics, x, y, size) {\n  graphics.drawCircle(x, y, size);\n}","map":{"version":3,"names":["Container","polygonClipping","ShapeType","ShapeGraphics","coverTest","shape","shapes","length","left","cLeft","top","cTop","right","cRight","bottom","cBottom","instance","getLocalBounds","shapeBounds","map","s","intersectedBounds","isCoveredByAnyShape","some","bounds","covered","intersected","push","i","Math","min","max","hitTesting","point","localPoint","rootChildren","allShapes","snappingPoint","getIntersections","children","child","visible","finished","resizing","dragging","sp","snapToPoint","interactive","shapeType","LINE","hitArea","contains","x","y","containsPoint","originalIntersections","filteredIntersectionIds","intersections","curr","others","slice","every","o","uid","sort","a","b","abox","bbox","width","height","intersection","otherIntersections","fronts","filter","order","includes","findIntersections","currentShapeData","currentShapeBounds","currentShapeType","DOT","shapeData","getAreaAsGeoJSON","precise","num","round","normalizePoints","points","newPoints","forEach","index","nextPoint","npx","npy","px","py","drawVertex","graphics","size","drawCircle"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/utils.ts"],"sourcesContent":["import { Container, DisplayObject, Graphics, Point, Rectangle } from 'pixi.js';\nimport polygonClipping, { Geom } from 'polygon-clipping';\nimport { ShapeType, ShapeData } from './types';\nimport ShapeGraphics from './ShapeGraphics';\nimport type Shape from './Shape';\n\nexport function coverTest(shape: Shape<ShapeType>, shapes: Shape<ShapeType>[]) {\n  if (shapes.length <= 0) {\n    return false;\n  }\n  const { left: cLeft, top: cTop, right: cRight, bottom: cBottom } = shape.instance.getLocalBounds();\n  const shapeBounds = shapes.map((s) => s.instance.getLocalBounds());\n  const intersectedBounds: Rectangle[] = [];\n\n  // if covered by any front shape, should be selected\n  const isCoveredByAnyShape = shapeBounds.some((bounds) => {\n    const { left, top, right, bottom } = bounds;\n    const covered = cLeft >= left && cRight <= right && cTop >= top && cBottom <= bottom;\n    const intersected = cLeft <= right && cRight >= left && cTop <= bottom && cBottom >= top;\n    if (intersected) {\n      intersectedBounds.push(bounds);\n    }\n    return covered;\n  });\n  if (isCoveredByAnyShape) {\n    return isCoveredByAnyShape;\n  }\n\n  // if covered by front shapes bounding box, should be selected\n  if (intersectedBounds.length <= 0) {\n    return false;\n  }\n  let { left, top, right, bottom } = intersectedBounds[0];\n  for (let i = 1; i < intersectedBounds.length; i += 1) {\n    const bounds = intersectedBounds[i];\n    if (left <= bounds.right && right >= bounds.left && top <= bounds.bottom && bottom >= bounds.top) {\n      left = Math.min(left, bounds.left);\n      top = Math.min(top, bounds.top);\n      right = Math.max(right, bounds.right);\n      bottom = Math.max(bottom, bounds.bottom);\n    }\n  }\n  return cLeft >= left && cTop >= top && cRight <= right && cBottom <= bottom;\n}\n\nexport function hitTesting(point: Point, localPoint: Point, rootChildren: DisplayObject[]) {\n  const allShapes: Shape<ShapeType>[] = [];\n  let snappingPoint: Point | null = null;\n\n  const getIntersections = (children: DisplayObject[]) => {\n    let shapes: Shape<ShapeType>[] = [];\n    for (let i = 0; i < children.length; i += 1) {\n      const child = children[i];\n      if (child.visible) {\n        if (child instanceof ShapeGraphics) {\n          if (!snappingPoint && child.shape.finished && !child.shape.resizing && !child.shape.dragging) {\n            const sp = child.shape.snapToPoint(localPoint);\n            if (sp) {\n              snappingPoint = sp;\n            }\n          }\n          if (child.interactive && child.shape.finished) {\n            allShapes.push(child.shape);\n            if (child.shape.shapeType === ShapeType.LINE) {\n              if (child.hitArea.contains(localPoint.x, localPoint.y)) {\n                shapes.push(child.shape);\n              }\n            } else if (child.containsPoint(point)) {\n              shapes.push(child.shape);\n            }\n          }\n        } else if (child instanceof Container) {\n          shapes = [...shapes, ...getIntersections(child.children)];\n        }\n      }\n    }\n    return shapes;\n  };\n\n  const originalIntersections = getIntersections(rootChildren);\n  const filteredIntersectionIds: string[] = [];\n  let intersections: Shape<ShapeType>[] = [];\n  if (originalIntersections.length > 1) {\n    // filter out some shapes that cover all intersections\n    for (let i = 0; i < originalIntersections.length; i += 1) {\n      const curr = originalIntersections[i];\n      const others = [...originalIntersections.slice(0, i), ...originalIntersections.slice(i + 1)];\n      if (others.every((o) => coverTest(o, [curr]))) {\n        filteredIntersectionIds.push(curr.uid);\n      } else {\n        intersections.push(curr);\n      }\n    }\n  } else {\n    intersections = [...originalIntersections];\n  }\n\n  intersections.sort((a, b) => {\n    const abox = a.instance.getLocalBounds();\n    const bbox = b.instance.getLocalBounds();\n    return abox.width * abox.height - bbox.width * bbox.height;\n  }); // sort by area, small shapes have higher priority\n\n  let intersection;\n  for (let i = 0; i < intersections.length; i += 1) {\n    const curr = intersections[i];\n    const otherIntersections = [...intersections.slice(0, i), ...intersections.slice(i + 1)];\n    if (coverTest(curr, otherIntersections)) {\n      // covered by other intersections\n      intersection = curr;\n      break;\n    }\n    const fronts = allShapes.filter((s) => s.order > curr.order && !filteredIntersectionIds.includes(s.uid));\n    if (coverTest(curr, fronts)) {\n      // covered by front shapes\n      intersection = curr;\n      break;\n    }\n  }\n\n  return {\n    intersection: intersection || intersections[0],\n    snappingPoint,\n  };\n}\n\nexport function findIntersections(\n  currentShapeData: Geom,\n  currentShapeBounds: { left: number, top: number, right: number, bottom: number },\n  currentShapeType: ShapeType,\n  shapes: Shape<ShapeData>[],\n): Shape<ShapeData>[] {\n  const intersections: Shape<ShapeData>[] = [];\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    const { shapeBounds } = shape;\n    if (\n      shapeBounds.left < currentShapeBounds.right &&\n      shapeBounds.right > currentShapeBounds.left &&\n      shapeBounds.top < currentShapeBounds.bottom &&\n      shapeBounds.bottom > currentShapeBounds.top\n    ) {\n      // bbox intersects\n      if (currentShapeType === ShapeType.DOT || shape.shapeType === ShapeType.DOT) {\n        // one of the shapes is dot\n        intersections.push(shape);\n      } else {\n        const shapeData = shape.getAreaAsGeoJSON();\n        const intersection = polygonClipping.intersection(currentShapeData, shapeData);\n        if (intersection.length > 0) {\n          intersections.push(shape);\n        }\n      }\n    }\n  }\n  return intersections;\n}\n\nexport function precise(num: number) {\n  return Math.round(num * 1000000) / 1000000;\n}\n\nexport function normalizePoints(points: [number, number][]) {\n  const newPoints: { x: number; y: number }[] = [];\n  points.forEach((point, index) => {\n    const nextPoint = points[index === points.length - 1 ? 0 : index + 1];\n    const npx = precise(nextPoint[0]);\n    const npy = precise(nextPoint[1]);\n    const px = precise(point[0]);\n    const py = precise(point[1]);\n    if (px !== npx || py !== npy) {\n      newPoints.push({ x: px, y: py });\n    }\n  });\n  return newPoints;\n}\n\nexport function drawVertex(graphics: Graphics, x: number, y: number, size: number) {\n  graphics.drawCircle(x, y, size);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}