{"ast":null,"code":"/* eslint-disable no-bitwise, class-methods-use-this */\n\nimport { setStyle } from '../utils';\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wave.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wave.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wave with the plugin\n * var wave = WaveSurfer.create({\n *   // wave options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n  /**\n   * Timeline plugin definition factory\n   *\n   * This function must be used to create a plugin definition which can be\n   * used by wave to correctly instantiate the plugin.\n   *\n   * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n   * @return {PluginDefinition} an object representing the plugin\n   */\n  static create(params) {\n    return {\n      name: 'timeline',\n      params,\n      instance: TimelinePlugin\n    };\n  }\n\n  /**\n   * @returns {void}\n   */\n\n  /**\n   * Creates an instance of TimelinePlugin.\n   *\n   * You probably want to use TimelinePlugin.create()\n   *\n   * @param {TimelinePluginParams} params Plugin parameters\n   * @param {object} ws Wavesurfer instance\n   */\n  constructor(params) {\n    this.name = 'timeline';\n    /**\n     * wave instance\n     */\n    this.wave = void 0;\n    this.duration = 0;\n    /**\n     * timeline container\n     */\n    this.container = void 0;\n    /**\n     * drawer\n     */\n    this.drawer = void 0;\n    /**\n     * window pixel ratio\n     */\n    this.pixelRatio = 1;\n    /**\n     * timeline params\n     */\n    this.params = void 0;\n    this.canvas = null;\n    this.currentTimeLine = null;\n    /**\n     * timeline dom height\n     */\n    this.height = 0;\n    this._onRedraw = () => {\n      var _this$wave;\n      if (!((_this$wave = this.wave) === null || _this$wave === void 0 ? void 0 : _this$wave.isPlaying())) {\n        this.render();\n      }\n    };\n    this._onReady = () => {\n      this.container.addEventListener('click', this._onWrapperClick);\n      this.addCanvas();\n      this.initTimeline();\n      this.render();\n    };\n    /**\n     * @param {object} e Click event\n     */\n    this._onWrapperClick = e => {\n      e.preventDefault();\n      const relX = e.offsetX;\n      // this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);\n    };\n    this.renderTimeline = () => {\n      var _this$currentTimeLine;\n      this.resizeTimeline();\n      const context = (_this$currentTimeLine = this.currentTimeLine) === null || _this$currentTimeLine === void 0 ? void 0 : _this$currentTimeLine.getContext('2d');\n      if (context && this.wave) {\n        const {\n          width,\n          height\n        } = this.currentTimeLine.getBoundingClientRect();\n        const {\n          displayRange: {\n            start,\n            end\n          }\n        } = this.wave;\n        const current = this.wave.getCurrentTime() / this.duration;\n        if (current < start || current > end) return;\n        const startX = ((current - start) / (end - start) * width - 1) * this.pixelRatio;\n        context.save();\n        context.fillStyle = '#34CBD1';\n        context.strokeStyle = '#34CBD1';\n        context.lineWidth = 1 * this.pixelRatio;\n        context.moveTo(startX, 0);\n        context.lineTo(startX, height * this.pixelRatio);\n        context.stroke();\n        context.beginPath();\n        context.moveTo(startX - 6 * this.pixelRatio, 0);\n        context.lineTo(startX + 6 * this.pixelRatio, 0);\n        context.lineTo(startX, this.height / 2 * this.pixelRatio);\n        context.closePath();\n        context.fill();\n      }\n    };\n    this.container = typeof params.container === 'string' ? document.querySelector(params.container) : params.container;\n    if (!this.container) {\n      throw new Error('No container for wave timeline');\n    }\n    this.params = {\n      height: 20,\n      notchPercentHeight: 90,\n      labelPadding: 5,\n      unlabeledNotchColor: '#c0c0c0',\n      primaryColor: '#000',\n      secondaryColor: '#c0c0c0',\n      primaryFontColor: '#000',\n      secondaryFontColor: '#000',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      duration: 0,\n      zoomDebounce: false,\n      formatTimeCallback: this.defaultFormatTimeCallback,\n      timeInterval: this.defaultTimeInterval,\n      primaryLabelInterval: this.defaultPrimaryLabelInterval,\n      secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n      offset: 0,\n      ...params\n    };\n    this.height = this.params.height + 1;\n  }\n\n  /**\n   * Initialisation function used by the plugin API\n   */\n  init(wave) {\n    const ws = wave;\n    this.wave = ws;\n    this.drawer = ws.drawer;\n    this.pixelRatio = ws.params.pixelRatio;\n    ws.on('draw', this._onRedraw);\n    // Check if ws is ready\n    if (this.wave.isReady) {\n      this._onReady();\n    } else {\n      this.wave.once('ready', this._onReady);\n    }\n    this.duration = this.params.duration || this.wave.getDuration();\n  }\n\n  /**\n   * Destroy function used by the plugin API\n   */\n  destroy() {\n    if (this.wave) {\n      this.wave.un('draw', this._onRedraw);\n      this.wave.un('ready', this._onReady);\n    }\n    if (this.container && this.canvas) {\n      this.container.removeEventListener('click', this._onWrapperClick);\n      this.container.removeChild(this.canvas);\n    }\n  }\n\n  /**\n   * Render the timeline (also updates the already rendered timeline)\n   *\n   */\n  render() {\n    this.renderCanvases();\n    this.renderTimeline();\n  }\n\n  /**\n   * Add new timeline canvas\n   *\n   */\n  addCanvas() {\n    const canvas = this.container.appendChild(document.createElement('canvas'));\n    canvas.style.display = 'block';\n    this.canvas = canvas;\n  }\n\n  /**\n   * init tineline\n   */\n  initTimeline() {\n    var _this$wave2;\n    this.currentTimeLine = document.createElement('canvas');\n    this.currentTimeLine.style.display = 'block';\n    (_this$wave2 = this.wave) === null || _this$wave2 === void 0 ? void 0 : _this$wave2.params.container.appendChild(this.currentTimeLine);\n    this.currentTimeLine.className = 'wave-current_time';\n    const ctx = this.currentTimeLine.getContext('2d');\n    if (ctx) {\n      ctx.fillStyle = '#34CBD1';\n      ctx.strokeStyle = '#34CBD1';\n    }\n    setStyle(this.currentTimeLine, {\n      display: 'block',\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      zIndex: '99'\n    });\n  }\n  resizeCanvas() {\n    if (this.canvas && this.wave) {\n      const canvasWidth = this.wave.width;\n      // set dimensions and style\n      this.canvas.width = canvasWidth * this.pixelRatio;\n      // on certain pixel ratios the canvas appears cut off at the bottom,\n      // therefore leave 1px extra\n      this.canvas.height = (this.params.height + 1) * this.pixelRatio;\n      setStyle(this.canvas, {\n        width: `${canvasWidth}px`,\n        height: `${this.params.height + 1}px`\n      });\n    }\n  }\n  resizeTimeline() {\n    if (this.currentTimeLine && this.wave) {\n      var _this$wave3;\n      const canvasWidth = this.wave.width;\n      this.currentTimeLine.width = canvasWidth * this.pixelRatio;\n      this.currentTimeLine.height = ((_this$wave3 = this.wave) === null || _this$wave3 === void 0 ? void 0 : _this$wave3.params.container.clientHeight) * this.pixelRatio;\n    }\n  }\n  /**\n   * Render the timeline labels and notches\n   *\n   */\n  renderCanvases() {\n    if (!this.wave) return;\n    this.resizeCanvas();\n    const duration = this.params.duration || this.wave.getDuration();\n    if (duration <= 0 || !this.drawer) {\n      return;\n    }\n    const {\n      start,\n      end\n    } = this.wave.displayRange;\n    const startTime = start * duration;\n    const endTime = end * duration;\n    const wsParams = this.wave.params;\n    const fontSize = this.params.fontSize * wsParams.pixelRatio;\n    const visibleDuration = endTime - startTime;\n    const totalSeconds = parseInt(`${visibleDuration}`, 10) + 1;\n    const width = this.drawer.width * wsParams.pixelRatio;\n    const height1 = this.params.height * this.pixelRatio;\n    const height2 = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio;\n    const pixelsPerSecond = width / visibleDuration;\n    const formatTime = this.params.formatTimeCallback;\n    // if parameter is function, call the function with\n    // pixelsPerSecond, otherwise simply take the value as-is\n    const intervalFnOrVal = option => typeof option === 'function' ? option(pixelsPerSecond) : option;\n    const timeInterval = intervalFnOrVal(this.params.timeInterval);\n    const primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);\n    const secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);\n\n    // build an array of position data with index, second and pixel data,\n    // this is then used multiple times below\n    const positioning = [];\n    const drawStart = Math.ceil(startTime / timeInterval) * timeInterval;\n    const unitSize = pixelsPerSecond * timeInterval;\n    const offset = Math.floor(drawStart / timeInterval);\n    let curPixel = unitSize * ((drawStart - startTime) / timeInterval);\n    let curSeconds = drawStart;\n    for (let i = 0; i < totalSeconds / timeInterval; i += 1) {\n      positioning.push([i + offset, curSeconds, curPixel]);\n      curSeconds += timeInterval;\n      curPixel += unitSize;\n    }\n\n    // iterate over each position\n    const renderPositions = cb => {\n      positioning.forEach(pos => {\n        cb(pos[0], pos[1], pos[2]);\n      });\n    };\n\n    // render primary labels\n    this.setFillStyles(this.params.primaryColor);\n    this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n    this.setFillStyles(this.params.primaryFontColor);\n    renderPositions((i, _curSeconds, _curPixel) => {\n      if (i % primaryLabelInterval === 0) {\n        this.fillRect(_curPixel, 0, 1, height1);\n        this.fillText(formatTime(_curSeconds, pixelsPerSecond), _curPixel + this.params.labelPadding * this.pixelRatio, height1);\n      }\n    });\n\n    // render secondary labels\n    this.setFillStyles(this.params.secondaryColor);\n    this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n    this.setFillStyles(this.params.secondaryFontColor);\n    renderPositions((i, _curSeconds, _curPixel) => {\n      if (i % secondaryLabelInterval === 0) {\n        this.fillRect(_curPixel, 0, 1, height1);\n        this.fillText(formatTime(_curSeconds, pixelsPerSecond), _curPixel + this.params.labelPadding * this.pixelRatio, height1);\n      }\n    });\n\n    // render the actual notches (when no labels are used)\n    this.setFillStyles(this.params.unlabeledNotchColor);\n    renderPositions((i, _curSeconds, _curPixel) => {\n      if (i % secondaryLabelInterval !== 0 && i % primaryLabelInterval !== 0) {\n        this.fillRect(_curPixel, 0, 1, height2);\n      }\n    });\n  }\n\n  /**\n   * Set the canvas fill style\n   *\n   * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle Fill style to\n   * use\n   */\n  setFillStyles(fillStyle) {\n    var _this$canvas;\n    const context = (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.getContext('2d');\n    if (context) {\n      context.fillStyle = fillStyle;\n    }\n  }\n\n  /**\n   * Set the canvas font\n   *\n   * @param {DOMString} font Font to use\n   */\n  setFonts(font) {\n    var _this$canvas2;\n    const context = (_this$canvas2 = this.canvas) === null || _this$canvas2 === void 0 ? void 0 : _this$canvas2.getContext('2d');\n    if (context) {\n      context.font = font;\n    }\n  }\n\n  /**\n   * Draw a rectangle on the canvases\n   *\n   * (it figures out the offset for each canvas)\n   *\n   * @param {number} x X-position\n   * @param {number} y Y-position\n   * @param {number} width Width\n   * @param {number} height Height\n   */\n  fillRect(x, y, width, height) {\n    const intersection = {\n      x1: x,\n      y1: y,\n      x2: x + width,\n      y2: y + height\n    };\n    if (intersection.x1 < intersection.x2) {\n      var _this$canvas3;\n      const context = (_this$canvas3 = this.canvas) === null || _this$canvas3 === void 0 ? void 0 : _this$canvas3.getContext('2d');\n      if (context) {\n        context.fillRect(intersection.x1, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);\n      }\n    }\n  }\n\n  /**\n   * Fill a given text on the canvases\n   *\n   * @param {string} text Text to render\n   * @param {number} x X-position\n   * @param {number} y Y-position\n   */\n  fillText(text, x, y) {\n    var _this$canvas4;\n    let textWidth = 0;\n    let xOffset = 0;\n    const context = (_this$canvas4 = this.canvas) === null || _this$canvas4 === void 0 ? void 0 : _this$canvas4.getContext('2d');\n    if (context) {\n      const canvasWidth = context.canvas.width;\n      if (xOffset > x + textWidth) {\n        return;\n      }\n      if (xOffset + canvasWidth > x && context) {\n        textWidth = context.measureText(text).width;\n        context.fillText(text, x - xOffset, y);\n      }\n      xOffset += canvasWidth;\n    }\n  }\n\n  /**\n   * Turn the time into a suitable label for the time.\n   *\n   * @param {number} seconds Seconds to format\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Time\n   */\n  defaultFormatTimeCallback(_seconds) {\n    if (_seconds / 60 > 1) {\n      // calculate minutes and seconds from seconds count\n      const minutes = parseInt(`${_seconds / 60}`, 10);\n      const seconds = `00${parseInt(`${_seconds % 60}`, 10)}`.slice(-2);\n      return `${minutes}:${seconds}`;\n    }\n    return `${Math.round(_seconds * 1000) / 1000}`;\n  }\n\n  /**\n   * Return how many seconds should be between each notch\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Time\n   */\n  defaultTimeInterval(pxPerSec) {\n    if (pxPerSec >= 25) {\n      return 1;\n    }\n    if (pxPerSec * 5 >= 25) {\n      return 5;\n    }\n    if (pxPerSec * 15 >= 25) {\n      return 15;\n    }\n    return Math.ceil(0.5 / pxPerSec) * 60;\n  }\n\n  /**\n   * Return the cadence of notches that get labels in the primary color.\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Cadence\n   */\n  defaultPrimaryLabelInterval(pxPerSec) {\n    if (pxPerSec >= 25) {\n      return 10;\n    }\n    if (pxPerSec * 5 >= 25) {\n      return 6;\n    }\n    if (pxPerSec * 15 >= 25) {\n      return 4;\n    }\n    return 4;\n  }\n\n  /**\n   * Return the cadence of notches that get labels in the secondary color.\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Cadence\n   */\n  defaultSecondaryLabelInterval(pxPerSec) {\n    if (pxPerSec >= 25) {\n      return 5;\n    }\n    if (pxPerSec * 5 >= 25) {\n      return 2;\n    }\n    if (pxPerSec * 15 >= 25) {\n      return 2;\n    }\n    return 2;\n  }\n}","map":{"version":3,"names":["setStyle","TimelinePlugin","create","params","name","instance","constructor","wave","duration","container","drawer","pixelRatio","canvas","currentTimeLine","height","_onRedraw","_this$wave","isPlaying","render","_onReady","addEventListener","_onWrapperClick","addCanvas","initTimeline","e","preventDefault","relX","offsetX","renderTimeline","_this$currentTimeLine","resizeTimeline","context","getContext","width","getBoundingClientRect","displayRange","start","end","current","getCurrentTime","startX","save","fillStyle","strokeStyle","lineWidth","moveTo","lineTo","stroke","beginPath","closePath","fill","document","querySelector","Error","notchPercentHeight","labelPadding","unlabeledNotchColor","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","zoomDebounce","formatTimeCallback","defaultFormatTimeCallback","timeInterval","defaultTimeInterval","primaryLabelInterval","defaultPrimaryLabelInterval","secondaryLabelInterval","defaultSecondaryLabelInterval","offset","init","ws","on","isReady","once","getDuration","destroy","un","removeEventListener","removeChild","renderCanvases","appendChild","createElement","style","display","_this$wave2","className","ctx","position","top","left","pointerEvents","zIndex","resizeCanvas","canvasWidth","_this$wave3","clientHeight","startTime","endTime","wsParams","visibleDuration","totalSeconds","parseInt","height1","height2","pixelsPerSecond","formatTime","intervalFnOrVal","option","positioning","drawStart","Math","ceil","unitSize","floor","curPixel","curSeconds","i","push","renderPositions","cb","forEach","pos","setFillStyles","setFonts","_curSeconds","_curPixel","fillRect","fillText","_this$canvas","font","_this$canvas2","x","y","intersection","x1","y1","x2","y2","_this$canvas3","text","_this$canvas4","textWidth","xOffset","measureText","_seconds","minutes","seconds","slice","round","pxPerSec"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/common/Wave/Timeline/index.ts"],"sourcesContent":["/* eslint-disable no-bitwise, class-methods-use-this */\nimport Wave from '../index';\nimport WaveDrawer from '../waveDrawer';\nimport { setStyle } from '../utils';\n\nexport interface TimelineOptions {\n  container: string | HTMLElement;\n  notchPercentHeight?: number;\n  unlabeledNotchColor?: string;\n  primaryColor?: string;\n  secondaryColor?: string;\n  primaryFontColor?: string;\n  secondaryFontColor?: string;\n  labelPadding?: number;\n  zoomDebounce?: boolean;\n  duration?: number;\n  offset?: number;\n  fontSize?: number;\n  formatTimeCallback?: (sec: number, pxPerSec: number) => string;\n  timeInterval?: (pxPerSec: number) => number;\n  primaryLabelInterval?: (pxPerSec: number) => number;\n  secondaryLabelInterval?: (pxPerSec: number) => number;\n}\n\ninterface TimelineParams {\n  height: number;\n  notchPercentHeight: number;\n  unlabeledNotchColor: string;\n  primaryColor: string;\n  secondaryColor: string;\n  primaryFontColor: string;\n  secondaryFontColor: string;\n  labelPadding: number;\n  zoomDebounce: boolean;\n  duration: number;\n  fontFamily: string;\n  fontSize: number;\n  offset: number;\n  formatTimeCallback: (sec: number, pxPerSec: number) => string;\n  timeInterval: (pxPerSec: number) => number;\n  primaryLabelInterval: (pxPerSec: number) => number;\n  secondaryLabelInterval: (pxPerSec: number) => number;\n}\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wave.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wave.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wave with the plugin\n * var wave = WaveSurfer.create({\n *   // wave options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n  name = 'timeline';\n\n  /**\n   * wave instance\n   */\n  wave?: Wave;\n\n  duration = 0;\n\n  /**\n   * timeline container\n   */\n  container: HTMLElement;\n\n  /**\n   * drawer\n   */\n  drawer?: WaveDrawer;\n\n  /**\n   * window pixel ratio\n   */\n  pixelRatio = 1;\n\n  /**\n   * timeline params\n   */\n  params: TimelineParams;\n\n  canvas: HTMLCanvasElement | null = null;\n\n  currentTimeLine: HTMLCanvasElement | null = null;\n\n  /**\n   * timeline dom height\n   */\n  height = 0;\n\n  /**\n   * Timeline plugin definition factory\n   *\n   * This function must be used to create a plugin definition which can be\n   * used by wave to correctly instantiate the plugin.\n   *\n   * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n   * @return {PluginDefinition} an object representing the plugin\n   */\n  static create(params: TimelineOptions) {\n    return {\n      name: 'timeline',\n      params,\n      instance: TimelinePlugin\n    };\n  }\n\n  /**\n   * @returns {void}\n   */\n  _onRedraw = () => {\n    if (!this.wave?.isPlaying()) {\n      this.render();\n    }\n  };\n\n  _onReady = () => {\n    this.container.addEventListener('click', this._onWrapperClick);\n    this.addCanvas();\n    this.initTimeline();\n    this.render();\n  };\n\n  /**\n   * @param {object} e Click event\n   */\n  _onWrapperClick = (e: MouseEvent) => {\n    e.preventDefault();\n    const relX = e.offsetX;\n    // this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);\n  };\n\n  /**\n   * Creates an instance of TimelinePlugin.\n   *\n   * You probably want to use TimelinePlugin.create()\n   *\n   * @param {TimelinePluginParams} params Plugin parameters\n   * @param {object} ws Wavesurfer instance\n   */\n  constructor(params: TimelineOptions) {\n    this.container = typeof params.container === 'string'\n      ? document.querySelector(params.container) as HTMLElement\n      : params.container;\n\n    if (!this.container) {\n      throw new Error('No container for wave timeline');\n    }\n\n    this.params = {\n      height: 20,\n      notchPercentHeight: 90,\n      labelPadding: 5,\n      unlabeledNotchColor: '#c0c0c0',\n      primaryColor: '#000',\n      secondaryColor: '#c0c0c0',\n      primaryFontColor: '#000',\n      secondaryFontColor: '#000',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      duration: 0,\n      zoomDebounce: false,\n      formatTimeCallback: this.defaultFormatTimeCallback,\n      timeInterval: this.defaultTimeInterval,\n      primaryLabelInterval: this.defaultPrimaryLabelInterval,\n      secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n      offset: 0,\n      ...params\n    };\n\n    this.height = this.params.height + 1;\n  }\n\n  /**\n   * Initialisation function used by the plugin API\n   */\n  init(wave: Wave) {\n    const ws = wave;\n    this.wave = ws;\n    this.drawer = ws.drawer;\n    this.pixelRatio = ws.params.pixelRatio;\n    ws.on('draw', this._onRedraw);\n    // Check if ws is ready\n    if (this.wave.isReady) {\n      this._onReady();\n    } else {\n      this.wave.once('ready', this._onReady);\n    }\n    this.duration = this.params.duration || this.wave.getDuration();\n  }\n\n  /**\n   * Destroy function used by the plugin API\n   */\n  destroy() {\n    if (this.wave) {\n      this.wave.un('draw', this._onRedraw);\n      this.wave.un('ready', this._onReady);\n    }\n    if (this.container && this.canvas) {\n      this.container.removeEventListener('click', this._onWrapperClick);\n      this.container.removeChild(this.canvas);\n    }\n  }\n\n  /**\n   * Render the timeline (also updates the already rendered timeline)\n   *\n   */\n  render() {\n    this.renderCanvases();\n    this.renderTimeline();\n  }\n\n  /**\n   * Add new timeline canvas\n   *\n   */\n  addCanvas() {\n    const canvas = this.container.appendChild(\n      document.createElement('canvas')\n    );\n    canvas.style.display = 'block';\n    this.canvas = canvas;\n  }\n\n  /**\n   * init tineline\n   */\n  initTimeline() {\n    this.currentTimeLine = document.createElement('canvas');\n    this.currentTimeLine.style.display = 'block';\n    this.wave?.params.container.appendChild(this.currentTimeLine);\n    this.currentTimeLine.className = 'wave-current_time';\n    const ctx = this.currentTimeLine.getContext('2d');\n    if (ctx) {\n      ctx.fillStyle = '#34CBD1';\n      ctx.strokeStyle = '#34CBD1';\n    }\n    setStyle(this.currentTimeLine, {\n      display: 'block',\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      zIndex: '99'\n    });\n  }\n\n  resizeCanvas() {\n    if (this.canvas && this.wave) {\n      const canvasWidth = this.wave.width;\n      // set dimensions and style\n      this.canvas.width = canvasWidth * this.pixelRatio;\n      // on certain pixel ratios the canvas appears cut off at the bottom,\n      // therefore leave 1px extra\n      this.canvas.height = (this.params.height + 1) * this.pixelRatio;\n      setStyle(this.canvas, {\n        width: `${canvasWidth}px`,\n        height: `${this.params.height + 1}px`,\n      });\n    }\n  }\n\n  resizeTimeline() {\n    if (this.currentTimeLine && this.wave) {\n      const canvasWidth = this.wave.width;\n      this.currentTimeLine.width = canvasWidth * this.pixelRatio;\n      this.currentTimeLine.height = this.wave?.params.container.clientHeight * this.pixelRatio;\n    }\n  }\n\n  renderTimeline = () => {\n    this.resizeTimeline();\n    const context = this.currentTimeLine?.getContext('2d');\n    if (context && this.wave) {\n      const { width, height } = this.currentTimeLine!.getBoundingClientRect();\n      const { displayRange: { start, end } } = this.wave;\n      const current = this.wave.getCurrentTime() / this.duration;\n      if (current < start || current > end) return;\n      const startX = (((current - start) / (end - start)) * width - 1) * this.pixelRatio;\n\n      context.save();\n      context.fillStyle = '#34CBD1';\n      context.strokeStyle = '#34CBD1';\n      context.lineWidth = 1 * this.pixelRatio;\n      context.moveTo(startX, 0);\n      context.lineTo(startX, height * this.pixelRatio);\n      context.stroke();\n      context.beginPath();\n      context.moveTo(startX - 6 * this.pixelRatio, 0);\n      context.lineTo(startX + 6 * this.pixelRatio, 0);\n      context.lineTo(startX, (this.height / 2) * this.pixelRatio);\n      context.closePath();\n      context.fill();\n    }\n  };\n\n  /**\n   * Render the timeline labels and notches\n   *\n   */\n  renderCanvases() {\n    if (!this.wave) return;\n    this.resizeCanvas();\n    const duration =\n            this.params.duration ||\n            this.wave.getDuration();\n    if (duration <= 0 || !this.drawer) {\n      return;\n    }\n    const { start, end } = this.wave.displayRange;\n    const startTime = start * duration;\n    const endTime = end * duration;\n    const wsParams = this.wave.params;\n    const fontSize = this.params.fontSize * wsParams.pixelRatio;\n    const visibleDuration = endTime - startTime;\n    const totalSeconds = parseInt(`${visibleDuration}`, 10) + 1;\n    const width = this.drawer.width * wsParams.pixelRatio;\n    const height1 = this.params.height * this.pixelRatio;\n    const height2 =\n            this.params.height *\n            (this.params.notchPercentHeight / 100) *\n            this.pixelRatio;\n    const pixelsPerSecond = width / visibleDuration;\n\n    const formatTime = this.params.formatTimeCallback;\n    // if parameter is function, call the function with\n    // pixelsPerSecond, otherwise simply take the value as-is\n    const intervalFnOrVal = (option: (pxPerSec: number) => number) => (typeof option === 'function' ? option(pixelsPerSecond) : option);\n    const timeInterval = intervalFnOrVal(this.params.timeInterval);\n    const primaryLabelInterval = intervalFnOrVal(\n      this.params.primaryLabelInterval\n    );\n    const secondaryLabelInterval = intervalFnOrVal(\n      this.params.secondaryLabelInterval\n    );\n\n    // build an array of position data with index, second and pixel data,\n    // this is then used multiple times below\n    const positioning:number[][] = [];\n    const drawStart = Math.ceil(startTime / timeInterval) * timeInterval;\n    const unitSize = pixelsPerSecond * timeInterval;\n    const offset = Math.floor(drawStart / timeInterval);\n    let curPixel = unitSize * ((drawStart - startTime) / timeInterval);\n    let curSeconds = drawStart;\n    for (let i = 0; i < totalSeconds / timeInterval; i += 1) {\n      positioning.push([i + offset, curSeconds, curPixel]);\n      curSeconds += timeInterval;\n      curPixel += unitSize;\n    }\n\n    // iterate over each position\n    const renderPositions = (cb: (i: number, _curSeconds: number, _curPixel: number) => void) => {\n      positioning.forEach((pos) => {\n        cb(pos[0], pos[1], pos[2]);\n      });\n    };\n\n    // render primary labels\n    this.setFillStyles(this.params.primaryColor);\n    this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n    this.setFillStyles(this.params.primaryFontColor);\n    renderPositions((i, _curSeconds, _curPixel) => {\n      if (i % primaryLabelInterval === 0) {\n        this.fillRect(_curPixel, 0, 1, height1);\n        this.fillText(\n          formatTime(_curSeconds, pixelsPerSecond),\n          _curPixel + this.params.labelPadding * this.pixelRatio,\n          height1\n        );\n      }\n    });\n\n    // render secondary labels\n    this.setFillStyles(this.params.secondaryColor);\n    this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n    this.setFillStyles(this.params.secondaryFontColor);\n    renderPositions((i, _curSeconds, _curPixel) => {\n      if (i % secondaryLabelInterval === 0) {\n        this.fillRect(_curPixel, 0, 1, height1);\n        this.fillText(\n          formatTime(_curSeconds, pixelsPerSecond),\n          _curPixel + this.params.labelPadding * this.pixelRatio,\n          height1\n        );\n      }\n    });\n\n    // render the actual notches (when no labels are used)\n    this.setFillStyles(this.params.unlabeledNotchColor);\n    renderPositions((i, _curSeconds, _curPixel) => {\n      if (\n        i % secondaryLabelInterval !== 0 &&\n                i % primaryLabelInterval !== 0\n      ) {\n        this.fillRect(_curPixel, 0, 1, height2);\n      }\n    });\n  }\n\n  /**\n   * Set the canvas fill style\n   *\n   * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle Fill style to\n   * use\n   */\n  setFillStyles(fillStyle: string) {\n    const context = this.canvas?.getContext('2d');\n    if (context) {\n      context.fillStyle = fillStyle;\n    }\n  }\n\n  /**\n   * Set the canvas font\n   *\n   * @param {DOMString} font Font to use\n   */\n  setFonts(font: string) {\n    const context = this.canvas?.getContext('2d');\n    if (context) {\n      context.font = font;\n    }\n  }\n\n  /**\n   * Draw a rectangle on the canvases\n   *\n   * (it figures out the offset for each canvas)\n   *\n   * @param {number} x X-position\n   * @param {number} y Y-position\n   * @param {number} width Width\n   * @param {number} height Height\n   */\n  fillRect(x: number, y: number, width: number, height: number) {\n    const intersection = {\n      x1: x,\n      y1: y,\n      x2: x + width,\n      y2: y + height\n    };\n\n    if (intersection.x1 < intersection.x2) {\n      const context = this.canvas?.getContext('2d');\n      if (context) {\n        context\n          .fillRect(\n            intersection.x1,\n            intersection.y1,\n            intersection.x2 - intersection.x1,\n            intersection.y2 - intersection.y1\n          );\n      }\n    }\n  }\n\n  /**\n   * Fill a given text on the canvases\n   *\n   * @param {string} text Text to render\n   * @param {number} x X-position\n   * @param {number} y Y-position\n   */\n  fillText(text: string, x: number, y: number) {\n    let textWidth = 0;\n    let xOffset = 0;\n\n    const context = this.canvas?.getContext('2d');\n    if (context) {\n      const canvasWidth = context.canvas.width;\n\n      if (xOffset > x + textWidth) {\n        return;\n      }\n\n      if (xOffset + canvasWidth > x && context) {\n        textWidth = context.measureText(text).width;\n        context.fillText(text, x - xOffset, y);\n      }\n\n      xOffset += canvasWidth;\n    }\n  }\n\n  /**\n   * Turn the time into a suitable label for the time.\n   *\n   * @param {number} seconds Seconds to format\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Time\n   */\n  defaultFormatTimeCallback(_seconds: number) {\n    if (_seconds / 60 > 1) {\n      // calculate minutes and seconds from seconds count\n      const minutes = parseInt(`${_seconds / 60}`, 10);\n      const seconds = `00${parseInt(`${_seconds % 60}`, 10)}`.slice(-2);\n      return `${minutes}:${seconds}`;\n    }\n    return `${Math.round(_seconds * 1000) / 1000}`;\n  }\n\n  /**\n   * Return how many seconds should be between each notch\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Time\n   */\n  defaultTimeInterval(pxPerSec: number) {\n    if (pxPerSec >= 25) {\n      return 1;\n    } if (pxPerSec * 5 >= 25) {\n      return 5;\n    } if (pxPerSec * 15 >= 25) {\n      return 15;\n    }\n    return Math.ceil(0.5 / pxPerSec) * 60;\n  }\n\n  /**\n   * Return the cadence of notches that get labels in the primary color.\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Cadence\n   */\n  defaultPrimaryLabelInterval(pxPerSec: number) {\n    if (pxPerSec >= 25) {\n      return 10;\n    } if (pxPerSec * 5 >= 25) {\n      return 6;\n    } if (pxPerSec * 15 >= 25) {\n      return 4;\n    }\n    return 4;\n  }\n\n  /**\n   * Return the cadence of notches that get labels in the secondary color.\n   *\n   * @param {number} pxPerSec Pixels per second\n   * @returns {number} Cadence\n   */\n  defaultSecondaryLabelInterval(pxPerSec: number) {\n    if (pxPerSec >= 25) {\n      return 5;\n    } if (pxPerSec * 5 >= 25) {\n      return 2;\n    } if (pxPerSec * 15 >= 25) {\n      return 2;\n    }\n    return 2;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}