{"ast":null,"code":"/* eslint-disable no-bitwise,class-methods-use-this */\nimport Observer from '../../utils/observer';\n\n// using constants to prevent someone writing the string wrong\nconst PLAYING = 'playing';\nconst PAUSED = 'paused';\nconst FINISHED = 'finished';\n\n/**\n * WebAudio backend\n *\n * @extends {Observer}\n */\nexport default class WebAudio extends Observer {\n  /**\n   * Does the browser support this backend\n   *\n   * @return {boolean} Whether or not this browser supports this backend\n   */\n  supportsWebAudio() {\n    return !!(window.AudioContext || window.webkitAudioContext);\n  }\n\n  /**\n   * Get the audio context used by this backend or create one\n   *\n   * @return {AudioContext} Existing audio context, or creates a new one\n   */\n  getAudioContext() {\n    if (!window.WaveSurferAudioContext) {\n      window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)();\n    }\n    return window.WaveSurferAudioContext;\n  }\n\n  /**\n   * Get the offline audio context used by this backend or create one\n   *\n   * @param {number} sampleRate The sample rate to use\n   * @return {OfflineAudioContext} Existing offline audio context, or creates\n   * a new one\n   */\n  getOfflineAudioContext(sampleRate) {\n    if (!window.WaveSurferOfflineAudioContext) {\n      window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, sampleRate);\n    }\n    return window.WaveSurferOfflineAudioContext;\n  }\n\n  /**\n   * Construct the backend\n   *\n   * @param {WavesurferParams} params Wavesurfer parameters\n   */\n  constructor(params) {\n    super();\n    /** @private */\n    /** audioContext: allows to process audio with WebAudio API */\n    this.audioContext = null;\n    /** @private */\n    this.offlineAudioContext = null;\n    /** @private */\n    this.stateBehaviors = {\n      [PLAYING]: {\n        init() {\n          this.addOnAudioProcess();\n        },\n        getPlayedPercents() {\n          const duration = this.getDuration();\n          return this.getCurrentTime() / duration || 0;\n        },\n        getCurrentTime() {\n          return this.startPosition + this.getPlayedTime();\n        }\n      },\n      [PAUSED]: {\n        init() {\n          this.removeOnAudioProcess();\n        },\n        getPlayedPercents() {\n          const duration = this.getDuration();\n          return this.getCurrentTime() / duration || 0;\n        },\n        getCurrentTime() {\n          return this.startPosition;\n        }\n      },\n      [FINISHED]: {\n        init() {\n          this.removeOnAudioProcess();\n          this.fireEvent('finish');\n        },\n        getPlayedPercents() {\n          return 1;\n        },\n        getCurrentTime() {\n          return this.getDuration();\n        }\n      }\n    };\n    this.params = params;\n    /** ac: Audio Context instance */\n    this.ac = params.audioContext || (this.supportsWebAudio() ? this.getAudioContext() : {});\n    /** @private */\n    this.lastPlay = this.ac.currentTime;\n    /** @private */\n    this.startPosition = 0;\n    this.scheduledPause = undefined;\n    /** @private */\n    this.states = {\n      [PLAYING]: Object.create(this.stateBehaviors[PLAYING]),\n      [PAUSED]: Object.create(this.stateBehaviors[PAUSED]),\n      [FINISHED]: Object.create(this.stateBehaviors[FINISHED])\n    };\n    /** @private */\n    this.buffer = null;\n    /** @private */\n    this.filters = [];\n    /** gainNode: allows to control audio volume */\n    this.gainNode = [];\n    /** @private */\n    this.mergedPeaks = null;\n    /** @private */\n    this.offlineAc = null;\n    /** @private */\n    this.playbackRate = 1;\n    this.splitterNode = null;\n    this.mergerNode = null;\n    /** scriptNode: allows processing audio */\n    this.scriptNode = null;\n    /** @private */\n    this.source = null;\n    /** @private */\n    this.state = null;\n    /** @private */\n    this.explicitDuration = params.duration;\n    /**\n         * Boolean indicating if the backend was destroyed.\n         */\n    this.destroyed = false;\n  }\n\n  /**\n   * Initialise the backend, called in `wavesurfer.createBackend()`\n   */\n  init() {\n    this.createMergerNode();\n    this.createScriptNode();\n    this.createSplitterNode();\n    this.setState(PAUSED);\n    this.setPlaybackRate(this.params.audioRate);\n  }\n\n  /**\n   * @private\n   *\n   * @param {string} state The new state\n   */\n  setState(state) {\n    if (this.state !== this.states[state]) {\n      this.state = this.states[state];\n      this.state.init.call(this);\n    }\n  }\n\n  /** Create ScriptProcessorNode to process audio */\n  createScriptNode() {\n    if (this.params.audioScriptProcessor) {\n      this.scriptNode = this.params.audioScriptProcessor;\n    } else if (this.ac.createScriptProcessor) {\n      this.scriptNode = this.ac.createScriptProcessor(WebAudio.scriptBufferSize);\n    } else {\n      this.scriptNode = this.ac.createJavaScriptNode(WebAudio.scriptBufferSize);\n    }\n    this.mergerNode.connect(this.ac.destination);\n    this.scriptNode.connect(this.ac.destination);\n  }\n\n  /** @private */\n  addOnAudioProcess() {\n    this.scriptNode.onaudioprocess = () => {\n      const time = this.getCurrentTime();\n      if (time >= this.getDuration()) {\n        this.setState(FINISHED);\n        this.fireEvent('pause');\n      } else if (time >= this.scheduledPause) {\n        this.pause();\n      } else if (this.state === this.states[PLAYING]) {\n        this.fireEvent('audioprocess', time);\n      }\n    };\n  }\n\n  /** @private */\n  removeOnAudioProcess() {\n    this.scriptNode.onaudioprocess = null;\n  }\n  createSplitterNode() {\n    var _this$params;\n    this.splitterNode = this.ac.createChannelSplitter(((_this$params = this.params) === null || _this$params === void 0 ? void 0 : _this$params.wave.channelCount) || 2);\n    this.createVolumeNode();\n    this.connectChannels();\n  }\n  createMergerNode() {\n    this.mergerNode = this.ac.createChannelMerger(2);\n  }\n  connectChannels() {\n    const {\n      wave\n    } = this.params;\n    this.splitterNode.disconnect();\n    if (wave && wave.channelCount) {\n      const {\n        channelCount,\n        hideChannels\n      } = wave;\n      for (let i = 0; i < channelCount; i += 1) {\n        if (hideChannels.indexOf(i) < 0) {\n          this.splitterNode.connect(this.gainNode[i], i);\n        }\n      }\n    } else if (this.gainNode && this.gainNode[0]) {\n      this.splitterNode.connect(this.gainNode[0]);\n    }\n    this.gainNode.forEach((gainNode, i) => {\n      gainNode.connect(this.mergerNode, 0, 0);\n      gainNode.connect(this.mergerNode, 0, 1);\n    });\n  }\n\n  /**\n   * Create the gain node needed to control the playback volume.\n   *\n   */\n  createVolumeNode() {\n    // Create gain node using the AudioContext\n    const create = () => {\n      let gainNode;\n      if (this.ac.createGain) {\n        gainNode = this.ac.createGain();\n      } else {\n        gainNode = this.ac.createGainNode();\n      }\n      this.gainNode.push(gainNode);\n    };\n    const {\n      wave\n    } = this.params;\n    if (wave === null || wave === void 0 ? void 0 : wave.channelCount) {\n      for (let i = 0; i < wave.channelCount; i += 1) {\n        create();\n      }\n    } else {\n      create();\n    }\n  }\n\n  /**\n   * Set the sink id for the media player\n   *\n   * @param {string} deviceId String value representing audio device id.\n   * @returns {Promise} A Promise that resolves to `undefined` when there\n   * are no errors.\n   */\n  setSinkId(deviceId) {\n    if (deviceId) {\n      /**\n       * The webaudio API doesn't currently support setting the device\n       * output. Here we create an HTMLAudioElement, connect the\n       * webaudio stream to that element and setSinkId there.\n       */\n      const audio = new window.Audio();\n      if (!audio.setSinkId) {\n        return Promise.reject(new Error('setSinkId is not supported in your browser'));\n      }\n      audio.autoplay = true;\n      const dest = this.ac.createMediaStreamDestination();\n      for (let i = 0; i < this.gainNode.length; i += 1) {\n        const gainNode = this.gainNode;\n        gainNode.disconnect();\n        gainNode.connect(dest);\n      }\n      audio.srcObject = dest.stream;\n      return audio.setSinkId(deviceId);\n    }\n    return Promise.reject(new Error(`Invalid deviceId: ${deviceId}`));\n  }\n\n  /**\n   * Set the audio volume\n   *\n   * @param {number} value A floating point value between 0 and 1.\n   * @param {number} channelIndex channel index\n   */\n  setVolume(value, channelIndex) {\n    this.gainNode[channelIndex].gain.setValueAtTime(value, this.ac.currentTime);\n  }\n\n  /**\n   * Get the current volume\n   *\n   * @return {number} value A floating point value between 0 and 1.\n   */\n  getVolume() {\n    return this.gainNode[0].gain.value;\n  }\n\n  /**\n   * Get the position from 0 to 1\n   *\n   * @return {number} Position\n   */\n  getPlayedPercents() {\n    return this.state.getPlayedPercents.call(this);\n  }\n\n  /** @private */\n  disconnectSource() {\n    if (this.source) {\n      this.source.disconnect();\n    }\n  }\n\n  /**\n   * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context\n   */\n  destroyWebAudio() {\n    this.disconnectSource();\n    for (let i = 0; i < this.gainNode.length; i += 1) {\n      this.gainNode[i].disconnect();\n    }\n    this.scriptNode.disconnect();\n\n    // close the audioContext if closeAudioContext option is set to true\n    if (this.params.closeAudioContext) {\n      // check if browser supports AudioContext.close()\n      if (typeof this.ac.close === 'function' && this.ac.state !== 'closed') {\n        this.ac.close();\n      }\n      // clear the reference to the audiocontext\n      this.ac = null;\n      // clear the actual audiocontext, either passed as param or the\n      // global singleton\n      if (!this.params.audioContext) {\n        window.WaveSurferAudioContext = null;\n      } else {\n        this.params.audioContext = null;\n      }\n      // clear the offlineAudioContext\n      window.WaveSurferOfflineAudioContext = null;\n    }\n  }\n\n  /**\n   * This is called when wavesurfer is destroyed\n   */\n  destroy() {\n    if (!this.isPaused()) {\n      this.pause();\n    }\n    this.unAll();\n    this.buffer = null;\n    this.destroyed = true;\n    this.destroyWebAudio();\n  }\n\n  /**\n   * Loaded a decoded audio buffer\n   *\n   * @param {Object} buffer Decoded audio buffer to load\n   */\n  load(buffer) {\n    this.startPosition = 0;\n    this.lastPlay = this.ac.currentTime;\n    this.buffer = buffer;\n    this.createSource();\n  }\n\n  /** @private */\n  createSource() {\n    this.disconnectSource();\n    this.source = this.ac.createBufferSource();\n\n    // adjust for old browsers\n    this.source.start = this.source.start || this.source.noteGrainOn;\n    this.source.stop = this.source.stop || this.source.noteOff;\n    this.setPlaybackRate(this.playbackRate);\n    this.source.buffer = this.buffer;\n    this.source.connect(this.splitterNode);\n  }\n\n  /**\n   * @private\n   *\n   * some browsers require an explicit call to #resume before they will play back audio\n   */\n  resumeAudioContext() {\n    if (this.ac.state === 'suspended' && this.ac.resume) {\n      this.ac.resume();\n    }\n  }\n\n  /**\n   * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`\n   *\n   * @return {boolean} Whether or not this backend is currently paused\n   */\n  isPaused() {\n    return this.state !== this.states[PLAYING];\n  }\n\n  /**\n   * Used by `wavesurfer.getDuration()`\n   *\n   * @return {number} Duration of loaded buffer\n   */\n  getDuration() {\n    if (this.explicitDuration) {\n      return this.explicitDuration;\n    }\n    if (!this.buffer) {\n      return 0;\n    }\n    return this.buffer.duration;\n  }\n\n  /**\n   * Used by `wavesurfer.seekTo()`\n   *\n   * @param {number|undefined} _start Position to start at in seconds\n   * @param {number|undefined} _end Position to end at in seconds\n   * @return {{start: number, end: number}} Object containing start and end\n   * positions\n   */\n  seekTo(_start, _end) {\n    if (!this.buffer) {\n      return;\n    }\n    this.setPlayEnd(null);\n    let start = _start;\n    let end = _end;\n    if (start === undefined) {\n      start = this.getCurrentTime();\n      if (start >= this.getDuration()) {\n        start = 0;\n      }\n    }\n    if (!end) {\n      end = this.getDuration();\n    }\n    this.startPosition = start;\n    this.lastPlay = this.ac.currentTime;\n    if (this.state === this.states[FINISHED]) {\n      this.setState(PAUSED);\n    }\n    return {\n      start,\n      end\n    };\n  }\n\n  /**\n   * Get the playback position in seconds\n   *\n   * @return {number} The playback position in seconds\n   */\n  getPlayedTime() {\n    return (this.ac.currentTime - this.lastPlay) * this.playbackRate;\n  }\n\n  /**\n   * Plays the loaded audio region.\n   *\n   * @param {number|undefined} _start Start offset in seconds, relative to the beginning\n   * of a clip.\n   * @param {number|undefined} _end When to stop relative to the beginning of a clip.\n   */\n  play(_start, _end) {\n    if (!this.buffer) {\n      return;\n    }\n\n    // need to re-create source on each playback\n    this.createSource();\n    const {\n      start,\n      end\n    } = this.seekTo(_start, _end);\n    this.setPlayEnd(end);\n    this.source.start(0, start);\n    this.resumeAudioContext();\n    this.setState(PLAYING);\n    this.fireEvent('play');\n  }\n\n  /**\n     * Pauses the loaded audio.\n     */\n  pause() {\n    this.setPlayEnd(null);\n    this.startPosition += this.getPlayedTime();\n    try {\n      var _this$source;\n      (_this$source = this.source) === null || _this$source === void 0 ? void 0 : _this$source.stop(0);\n    } catch (err) {\n      // Calling stop can throw the following 2 errors:\n      // - RangeError (The value specified for when is negative.)\n      // - InvalidStateNode (The node has not been started by calling start().)\n      // We can safely ignore both errors, because:\n      // - The range is surely correct\n      // - The node might not have been started yet, in which case we just want to carry on without causing any trouble.\n    }\n    this.setState(PAUSED);\n    this.fireEvent('pause');\n  }\n\n  /**\n   * Returns the current time in seconds relative to the audio-clip's\n   * duration.\n   *\n   * @return {number} The current time in seconds\n   */\n  getCurrentTime() {\n    return this.state.getCurrentTime.call(this);\n  }\n\n  /**\n   * Returns the current playback rate. (0=no playback, 1=normal playback)\n   *\n   * @return {number} The current playback rate\n   */\n  getPlaybackRate() {\n    return this.playbackRate;\n  }\n\n  /**\n   * Set the audio source playback rate.\n   *\n   * @param {number} value The playback rate to use\n   */\n  setPlaybackRate(value) {\n    if (this.source) {\n      this.playbackRate = value || 1;\n      this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime);\n    }\n  }\n\n  /**\n   * Set a point in seconds for playback to stop at.\n   *\n   * @param {number} end Position to end at\n   * @version 3.3.0\n   */\n  setPlayEnd(end) {\n    this.scheduledPause = end;\n  }\n  getPlayEnd() {\n    return this.scheduledPause;\n  }\n}\n/** scriptBufferSize: size of the processing buffer */\nWebAudio.scriptBufferSize = 256;","map":{"version":3,"names":["Observer","PLAYING","PAUSED","FINISHED","WebAudio","supportsWebAudio","window","AudioContext","webkitAudioContext","getAudioContext","WaveSurferAudioContext","getOfflineAudioContext","sampleRate","WaveSurferOfflineAudioContext","OfflineAudioContext","webkitOfflineAudioContext","constructor","params","audioContext","offlineAudioContext","stateBehaviors","init","addOnAudioProcess","getPlayedPercents","duration","getDuration","getCurrentTime","startPosition","getPlayedTime","removeOnAudioProcess","fireEvent","ac","lastPlay","currentTime","scheduledPause","undefined","states","Object","create","buffer","filters","gainNode","mergedPeaks","offlineAc","playbackRate","splitterNode","mergerNode","scriptNode","source","state","explicitDuration","destroyed","createMergerNode","createScriptNode","createSplitterNode","setState","setPlaybackRate","audioRate","call","audioScriptProcessor","createScriptProcessor","scriptBufferSize","createJavaScriptNode","connect","destination","onaudioprocess","time","pause","_this$params","createChannelSplitter","wave","channelCount","createVolumeNode","connectChannels","createChannelMerger","disconnect","hideChannels","i","indexOf","forEach","createGain","createGainNode","push","setSinkId","deviceId","audio","Audio","Promise","reject","Error","autoplay","dest","createMediaStreamDestination","length","srcObject","stream","setVolume","value","channelIndex","gain","setValueAtTime","getVolume","disconnectSource","destroyWebAudio","closeAudioContext","close","destroy","isPaused","unAll","load","createSource","createBufferSource","start","noteGrainOn","stop","noteOff","resumeAudioContext","resume","seekTo","_start","_end","setPlayEnd","end","play","_this$source","err","getPlaybackRate","getPlayEnd"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/components/Wave/webaudio.js"],"sourcesContent":["/* eslint-disable no-bitwise,class-methods-use-this */\nimport Observer from '../../utils/observer';\n\n// using constants to prevent someone writing the string wrong\nconst PLAYING = 'playing';\nconst PAUSED = 'paused';\nconst FINISHED = 'finished';\n\n/**\n * WebAudio backend\n *\n * @extends {Observer}\n */\nexport default class WebAudio extends Observer {\n  /** scriptBufferSize: size of the processing buffer */\n  static scriptBufferSize = 256;\n\n  /** audioContext: allows to process audio with WebAudio API */\n  audioContext = null;\n\n  /** @private */\n  offlineAudioContext = null;\n\n  /** @private */\n  stateBehaviors = {\n    [PLAYING]: {\n      init() {\n        this.addOnAudioProcess();\n      },\n      getPlayedPercents() {\n        const duration = this.getDuration();\n        return this.getCurrentTime() / duration || 0;\n      },\n      getCurrentTime() {\n        return this.startPosition + this.getPlayedTime();\n      }\n    },\n    [PAUSED]: {\n      init() {\n        this.removeOnAudioProcess();\n      },\n      getPlayedPercents() {\n        const duration = this.getDuration();\n        return this.getCurrentTime() / duration || 0;\n      },\n      getCurrentTime() {\n        return this.startPosition;\n      }\n    },\n    [FINISHED]: {\n      init() {\n        this.removeOnAudioProcess();\n        this.fireEvent('finish');\n      },\n      getPlayedPercents() {\n        return 1;\n      },\n      getCurrentTime() {\n        return this.getDuration();\n      }\n    }\n  };\n\n  /**\n   * Does the browser support this backend\n   *\n   * @return {boolean} Whether or not this browser supports this backend\n   */\n  supportsWebAudio() {\n    return !!(window.AudioContext || window.webkitAudioContext);\n  }\n\n  /**\n   * Get the audio context used by this backend or create one\n   *\n   * @return {AudioContext} Existing audio context, or creates a new one\n   */\n  getAudioContext() {\n    if (!window.WaveSurferAudioContext) {\n      window.WaveSurferAudioContext = new (window.AudioContext ||\n                window.webkitAudioContext)();\n    }\n    return window.WaveSurferAudioContext;\n  }\n\n  /**\n   * Get the offline audio context used by this backend or create one\n   *\n   * @param {number} sampleRate The sample rate to use\n   * @return {OfflineAudioContext} Existing offline audio context, or creates\n   * a new one\n   */\n  getOfflineAudioContext(sampleRate) {\n    if (!window.WaveSurferOfflineAudioContext) {\n      window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext ||\n                window.webkitOfflineAudioContext)(1, 2, sampleRate);\n    }\n    return window.WaveSurferOfflineAudioContext;\n  }\n\n  /**\n   * Construct the backend\n   *\n   * @param {WavesurferParams} params Wavesurfer parameters\n   */\n  constructor(params) {\n    super();\n    /** @private */\n    this.params = params;\n    /** ac: Audio Context instance */\n    this.ac =\n            params.audioContext ||\n            (this.supportsWebAudio() ? this.getAudioContext() : {});\n    /** @private */\n    this.lastPlay = this.ac.currentTime;\n    /** @private */\n    this.startPosition = 0;\n\n    this.scheduledPause = undefined;\n    /** @private */\n    this.states = {\n      [PLAYING]: Object.create(this.stateBehaviors[PLAYING]),\n      [PAUSED]: Object.create(this.stateBehaviors[PAUSED]),\n      [FINISHED]: Object.create(this.stateBehaviors[FINISHED])\n    };\n    /** @private */\n    this.buffer = null;\n    /** @private */\n    this.filters = [];\n    /** gainNode: allows to control audio volume */\n    this.gainNode = [];\n    /** @private */\n    this.mergedPeaks = null;\n    /** @private */\n    this.offlineAc = null;\n    /** @private */\n    this.playbackRate = 1;\n    this.splitterNode = null;\n    this.mergerNode = null;\n    /** scriptNode: allows processing audio */\n    this.scriptNode = null;\n    /** @private */\n    this.source = null;\n    /** @private */\n    this.state = null;\n    /** @private */\n    this.explicitDuration = params.duration;\n    /**\n         * Boolean indicating if the backend was destroyed.\n         */\n    this.destroyed = false;\n  }\n\n  /**\n   * Initialise the backend, called in `wavesurfer.createBackend()`\n   */\n  init() {\n    this.createMergerNode();\n    this.createScriptNode();\n    this.createSplitterNode();\n\n    this.setState(PAUSED);\n    this.setPlaybackRate(this.params.audioRate);\n  }\n\n  /**\n   * @private\n   *\n   * @param {string} state The new state\n   */\n  setState(state) {\n    if (this.state !== this.states[state]) {\n      this.state = this.states[state];\n      this.state.init.call(this);\n    }\n  }\n\n  /** Create ScriptProcessorNode to process audio */\n  createScriptNode() {\n    if (this.params.audioScriptProcessor) {\n      this.scriptNode = this.params.audioScriptProcessor;\n    } else if (this.ac.createScriptProcessor) {\n      this.scriptNode = this.ac.createScriptProcessor(\n        WebAudio.scriptBufferSize\n      );\n    } else {\n      this.scriptNode = this.ac.createJavaScriptNode(\n        WebAudio.scriptBufferSize\n      );\n    }\n    this.mergerNode.connect(this.ac.destination);\n    this.scriptNode.connect(this.ac.destination);\n  }\n\n  /** @private */\n  addOnAudioProcess() {\n    this.scriptNode.onaudioprocess = () => {\n      const time = this.getCurrentTime();\n\n      if (time >= this.getDuration()) {\n        this.setState(FINISHED);\n        this.fireEvent('pause');\n      } else if (time >= this.scheduledPause) {\n        this.pause();\n      } else if (this.state === this.states[PLAYING]) {\n        this.fireEvent('audioprocess', time);\n      }\n    };\n  }\n\n  /** @private */\n  removeOnAudioProcess() {\n    this.scriptNode.onaudioprocess = null;\n  }\n\n  createSplitterNode() {\n    this.splitterNode = this.ac.createChannelSplitter(this.params?.wave.channelCount || 2);\n    this.createVolumeNode();\n    this.connectChannels();\n  }\n\n  createMergerNode() {\n    this.mergerNode = this.ac.createChannelMerger(2);\n  }\n\n  connectChannels() {\n    const { wave } = this.params;\n    this.splitterNode.disconnect();\n    if (wave && wave.channelCount) {\n      const { channelCount, hideChannels } = wave;\n      for (let i = 0; i < channelCount; i += 1) {\n        if (hideChannels.indexOf(i) < 0) {\n          this.splitterNode.connect(this.gainNode[i], i);\n        }\n      }\n    } else if (this.gainNode && this.gainNode[0]) {\n      this.splitterNode.connect(this.gainNode[0]);\n    }\n\n    this.gainNode.forEach((gainNode, i) => {\n      gainNode.connect(this.mergerNode, 0, 0);\n      gainNode.connect(this.mergerNode, 0, 1);\n    });\n  }\n\n  /**\n   * Create the gain node needed to control the playback volume.\n   *\n   */\n  createVolumeNode() {\n    // Create gain node using the AudioContext\n    const create = () => {\n      let gainNode;\n      if (this.ac.createGain) {\n        gainNode = this.ac.createGain();\n      } else {\n        gainNode = this.ac.createGainNode();\n      }\n      this.gainNode.push(gainNode);\n    };\n    const { wave } = this.params;\n    if (wave?.channelCount) {\n      for (let i = 0; i < wave.channelCount; i += 1) {\n        create();\n      }\n    } else {\n      create();\n    }\n  }\n\n  /**\n   * Set the sink id for the media player\n   *\n   * @param {string} deviceId String value representing audio device id.\n   * @returns {Promise} A Promise that resolves to `undefined` when there\n   * are no errors.\n   */\n  setSinkId(deviceId) {\n    if (deviceId) {\n      /**\n       * The webaudio API doesn't currently support setting the device\n       * output. Here we create an HTMLAudioElement, connect the\n       * webaudio stream to that element and setSinkId there.\n       */\n      const audio = new window.Audio();\n      if (!audio.setSinkId) {\n        return Promise.reject(\n          new Error('setSinkId is not supported in your browser')\n        );\n      }\n      audio.autoplay = true;\n      const dest = this.ac.createMediaStreamDestination();\n      for (let i = 0; i < this.gainNode.length; i += 1) {\n        const gainNode = this.gainNode;\n        gainNode.disconnect();\n        gainNode.connect(dest);\n      }\n      audio.srcObject = dest.stream;\n\n      return audio.setSinkId(deviceId);\n    }\n    return Promise.reject(new Error(`Invalid deviceId: ${deviceId}`));\n  }\n\n  /**\n   * Set the audio volume\n   *\n   * @param {number} value A floating point value between 0 and 1.\n   * @param {number} channelIndex channel index\n   */\n  setVolume(value, channelIndex) {\n    this.gainNode[channelIndex].gain.setValueAtTime(value, this.ac.currentTime);\n  }\n\n  /**\n   * Get the current volume\n   *\n   * @return {number} value A floating point value between 0 and 1.\n   */\n  getVolume() {\n    return this.gainNode[0].gain.value;\n  }\n\n  /**\n   * Get the position from 0 to 1\n   *\n   * @return {number} Position\n   */\n  getPlayedPercents() {\n    return this.state.getPlayedPercents.call(this);\n  }\n\n  /** @private */\n  disconnectSource() {\n    if (this.source) {\n      this.source.disconnect();\n    }\n  }\n\n  /**\n   * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context\n   */\n  destroyWebAudio() {\n    this.disconnectSource();\n    for (let i = 0; i < this.gainNode.length; i += 1) {\n      this.gainNode[i].disconnect();\n    }\n    this.scriptNode.disconnect();\n\n    // close the audioContext if closeAudioContext option is set to true\n    if (this.params.closeAudioContext) {\n      // check if browser supports AudioContext.close()\n      if (\n        typeof this.ac.close === 'function' &&\n                this.ac.state !== 'closed'\n      ) {\n        this.ac.close();\n      }\n      // clear the reference to the audiocontext\n      this.ac = null;\n      // clear the actual audiocontext, either passed as param or the\n      // global singleton\n      if (!this.params.audioContext) {\n        window.WaveSurferAudioContext = null;\n      } else {\n        this.params.audioContext = null;\n      }\n      // clear the offlineAudioContext\n      window.WaveSurferOfflineAudioContext = null;\n    }\n  }\n\n  /**\n   * This is called when wavesurfer is destroyed\n   */\n  destroy() {\n    if (!this.isPaused()) {\n      this.pause();\n    }\n    this.unAll();\n    this.buffer = null;\n    this.destroyed = true;\n\n    this.destroyWebAudio();\n  }\n\n  /**\n   * Loaded a decoded audio buffer\n   *\n   * @param {Object} buffer Decoded audio buffer to load\n   */\n  load(buffer) {\n    this.startPosition = 0;\n    this.lastPlay = this.ac.currentTime;\n    this.buffer = buffer;\n    this.createSource();\n  }\n\n  /** @private */\n  createSource() {\n    this.disconnectSource();\n    this.source = this.ac.createBufferSource();\n\n    // adjust for old browsers\n    this.source.start = this.source.start || this.source.noteGrainOn;\n    this.source.stop = this.source.stop || this.source.noteOff;\n\n    this.setPlaybackRate(this.playbackRate);\n    this.source.buffer = this.buffer;\n    this.source.connect(this.splitterNode);\n  }\n\n  /**\n   * @private\n   *\n   * some browsers require an explicit call to #resume before they will play back audio\n   */\n  resumeAudioContext() {\n    if (this.ac.state === 'suspended' && this.ac.resume) {\n      this.ac.resume();\n    }\n  }\n\n  /**\n   * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`\n   *\n   * @return {boolean} Whether or not this backend is currently paused\n   */\n  isPaused() {\n    return this.state !== this.states[PLAYING];\n  }\n\n  /**\n   * Used by `wavesurfer.getDuration()`\n   *\n   * @return {number} Duration of loaded buffer\n   */\n  getDuration() {\n    if (this.explicitDuration) {\n      return this.explicitDuration;\n    }\n    if (!this.buffer) {\n      return 0;\n    }\n    return this.buffer.duration;\n  }\n\n  /**\n   * Used by `wavesurfer.seekTo()`\n   *\n   * @param {number|undefined} _start Position to start at in seconds\n   * @param {number|undefined} _end Position to end at in seconds\n   * @return {{start: number, end: number}} Object containing start and end\n   * positions\n   */\n  seekTo(_start, _end) {\n    if (!this.buffer) {\n      return;\n    }\n    this.setPlayEnd(null);\n    let start = _start;\n    let end = _end;\n    if (start === undefined) {\n      start = this.getCurrentTime();\n      if (start >= this.getDuration()) {\n        start = 0;\n      }\n    }\n    if (!end) {\n      end = this.getDuration();\n    }\n    this.startPosition = start;\n    this.lastPlay = this.ac.currentTime;\n\n    if (this.state === this.states[FINISHED]) {\n      this.setState(PAUSED);\n    }\n\n    return {\n      start,\n      end\n    };\n  }\n\n  /**\n   * Get the playback position in seconds\n   *\n   * @return {number} The playback position in seconds\n   */\n  getPlayedTime() {\n    return (this.ac.currentTime - this.lastPlay) * this.playbackRate;\n  }\n\n  /**\n   * Plays the loaded audio region.\n   *\n   * @param {number|undefined} _start Start offset in seconds, relative to the beginning\n   * of a clip.\n   * @param {number|undefined} _end When to stop relative to the beginning of a clip.\n   */\n  play(_start, _end) {\n    if (!this.buffer) {\n      return;\n    }\n\n    // need to re-create source on each playback\n    this.createSource();\n\n    const { start, end } = this.seekTo(_start, _end);\n\n    this.setPlayEnd(end);\n\n    this.source.start(0, start);\n\n    this.resumeAudioContext();\n\n    this.setState(PLAYING);\n\n    this.fireEvent('play');\n  }\n\n  /**\n     * Pauses the loaded audio.\n     */\n  pause() {\n    this.setPlayEnd(null);\n\n    this.startPosition += this.getPlayedTime();\n    try {\n      this.source?.stop(0);\n    } catch (err) {\n      // Calling stop can throw the following 2 errors:\n      // - RangeError (The value specified for when is negative.)\n      // - InvalidStateNode (The node has not been started by calling start().)\n      // We can safely ignore both errors, because:\n      // - The range is surely correct\n      // - The node might not have been started yet, in which case we just want to carry on without causing any trouble.\n    }\n\n    this.setState(PAUSED);\n\n    this.fireEvent('pause');\n  }\n\n  /**\n   * Returns the current time in seconds relative to the audio-clip's\n   * duration.\n   *\n   * @return {number} The current time in seconds\n   */\n  getCurrentTime() {\n    return this.state.getCurrentTime.call(this);\n  }\n\n  /**\n   * Returns the current playback rate. (0=no playback, 1=normal playback)\n   *\n   * @return {number} The current playback rate\n   */\n  getPlaybackRate() {\n    return this.playbackRate;\n  }\n\n  /**\n   * Set the audio source playback rate.\n   *\n   * @param {number} value The playback rate to use\n   */\n  setPlaybackRate(value) {\n    if (this.source) {\n      this.playbackRate = value || 1;\n      this.source.playbackRate.setValueAtTime(\n        this.playbackRate,\n        this.ac.currentTime\n      );\n    }\n  }\n\n  /**\n   * Set a point in seconds for playback to stop at.\n   *\n   * @param {number} end Position to end at\n   * @version 3.3.0\n   */\n  setPlayEnd(end) {\n    this.scheduledPause = end;\n  }\n\n  getPlayEnd() {\n    return this.scheduledPause;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}