{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport { message } from 'antd';\nimport i18n from '../locales';\nimport ReviewItem from '../model/ReviewItem';\nconst STACK_SIZE = 20;\n;\n/**\n * undo & redo store\n * @class\n */\nexport default class UndoStore {\n  /**\n   * is undo disabled\n   * @getter\n   */\n  get undoDisabled() {\n    return this.pointer <= 0;\n  }\n\n  /**\n   * is redo disabled\n   * @getter\n   */\n  get redoDisabled() {\n    return this.pointer >= this.stack.length;\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * current pointer\n     */\n    this.pointer = 0;\n    /**\n     * last stored data uuid\n     */\n    this.lastStoreId = '';\n    /**\n     * saved status\n     */\n    this.stack = [];\n    /**\n     * current data uuid\n     */\n    this.storeId = '';\n    /**\n     * saved data copy\n     */\n    this.savedData = {};\n    makeAutoObservable(this, {\n      rootStore: false,\n      stack: false,\n      storeId: false,\n      savedData: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * preserve current data\n   * @param data\n   */\n  preserve(data = {}) {\n    this.storeId = uuidv4();\n    this.savedData = cloneDeep(data);\n    return this.storeId;\n  }\n\n  /**\n   * save to stack\n   * @param uid\n   * @param data\n   */\n  save(uid, data = {}) {\n    if (uid === this.storeId) {\n      // same command\n      this.stack = this.stack.slice(0, this.pointer);\n      this.stack.push({\n        before: this.savedData,\n        after: cloneDeep(data)\n      });\n      if (this.stack.length > STACK_SIZE) {\n        this.stack.shift();\n      } else {\n        this.pointer += 1;\n      }\n      this.lastStoreId = uid;\n    }\n    this.storeId = '';\n    this.savedData = {};\n  }\n\n  /**\n   * push state by prev & curr state\n   * @param prevState\n   * @param currState\n   */\n  push(prevState, currState) {\n    this.stack = this.stack.slice(0, this.pointer);\n    this.stack.push({\n      before: cloneDeep(prevState),\n      after: cloneDeep(currState)\n    });\n    if (this.stack.length > STACK_SIZE) {\n      this.stack.shift();\n    } else {\n      this.pointer += 1;\n    }\n    this.lastStoreId = uuidv4();\n  }\n\n  /**\n   * undo\n   */\n  undo() {\n    if (this.undoDisabled || this.rootStore.config.isAnyModalOpened || this.rootStore.shape.isDrawing) {\n      return;\n    }\n    if (this.pointer > 0) {\n      this.pointer -= 1;\n      const item = this.stack[this.pointer];\n      if (item && item.before) {\n        this.updateData(item.before, item.after);\n        message.success(i18n.translate('UNDO_SUCCESS'));\n      }\n    }\n  }\n\n  /**\n   * redo\n   */\n  redo() {\n    if (this.redoDisabled || this.rootStore.config.isAnyModalOpened || this.rootStore.shape.isDrawing) {\n      return;\n    }\n    if (this.pointer < this.stack.length) {\n      this.pointer += 1;\n      const item = this.stack[this.pointer - 1];\n      if (item && item.after) {\n        this.updateData(item.after, item.before);\n        message.success(i18n.translate('REDO_SUCCESS'));\n      }\n    }\n  }\n\n  /**\n   * update data (used for undo / redo)\n   * @param curr\n   * @param prev\n   */\n  updateData(curr, prev) {\n    var _prev$instances, _curr$instances, _prev$frames, _curr$frames, _prev$reviews, _curr$reviews;\n    const {\n      selectedInstances,\n      selectedInstanceItems,\n      getInstanceById,\n      deleteInstance,\n      deleteInstanceItem,\n      createInstanceFromData\n    } = this.rootStore.instance;\n    const {\n      getShapeByInstanceItem,\n      deleteShape,\n      setupShape\n    } = this.rootStore.shape;\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const selectedInstanceMap = {};\n    selectedInstances.forEach(instance => {\n      selectedInstanceMap[instance.id] = selectedInstanceItems.filter(i => i.instance === instance).map(i => i.id);\n    });\n    (_prev$instances = prev.instances) === null || _prev$instances === void 0 ? void 0 : _prev$instances.forEach(affectedInstance => {\n      if (affectedInstance) {\n        const instance = getInstanceById(affectedInstance.id);\n        if (instance) {\n          affectedInstance.children.forEach(affectedItem => {\n            const item = instance.items[affectedItem.id];\n            if (item) {\n              affectedItem.cameras.forEach(affectedCamera => {\n                const camera = item.cameras[affectedCamera.camera];\n                if (camera) {\n                  // delete frame\n                  affectedCamera.frames.forEach(affectedFrame => {\n                    if (affectedFrame.frameIndex === currentFrame) {\n                      // remove shapes if needed\n                      const shape = getShapeByInstanceItem(item, camera.camera);\n                      if (shape) {\n                        deleteShape(shape);\n                      }\n                    }\n                    // delete frame data\n                    delete camera.frames[affectedFrame.frameIndex];\n                  });\n                  // delete camera if needed\n                  if (camera.isEmpty) {\n                    delete item.cameras[camera.camera];\n                  }\n                  // delete instance item if needed\n                  if (item.isEmpty) {\n                    deleteInstanceItem(item);\n                  }\n                  // delete instance if needed\n                  if (instance.isEmpty) {\n                    deleteInstance(instance);\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n    (_curr$instances = curr.instances) === null || _curr$instances === void 0 ? void 0 : _curr$instances.forEach(affectedInstance => {\n      if (affectedInstance) {\n        const instance = getInstanceById(affectedInstance.id);\n        if (instance) {\n          instance.attributes = cloneDeep(affectedInstance.attributes);\n          instance.setDynamicAttributes(affectedInstance.dynamicAttributes);\n          affectedInstance.children.forEach(affectedItem => {\n            const item = instance.items[affectedItem.id];\n            if (item) {\n              affectedItem.cameras.forEach(affectedCamera => {\n                const camera = item.cameras[affectedCamera.camera];\n                if (camera) {\n                  // update frame\n                  affectedCamera.frames.forEach(affectedFrame => {\n                    camera.createFrameFromData(affectedFrame);\n                  });\n                } else {\n                  // no camera, create\n                  item.createCameraFromData(affectedCamera);\n                }\n                // readd shape\n                setupShape(item, affectedCamera.camera);\n              });\n            } else {\n              // no instance item, create\n              instance.createItemFromData(affectedItem);\n              const createdItem = instance.items[affectedItem.id];\n              // readd shapes\n              affectedItem.cameras.forEach(affectedCamera => {\n                setupShape(createdItem, affectedCamera.camera);\n              });\n            }\n          });\n          if (instance.number !== affectedInstance.number) {\n            instance.number = affectedInstance.number;\n            Object.values(instance.items).forEach(item => {\n              Object.keys(item.cameras).forEach(camera => {\n                setupShape(item, camera);\n              });\n            });\n          }\n        } else {\n          // no instance, create\n          createInstanceFromData(affectedInstance);\n          const createdInstance = getInstanceById(affectedInstance.id);\n          affectedInstance.children.forEach(affectedItem => {\n            const item = createdInstance.items[affectedItem.id];\n            // readd shapes\n            affectedItem.cameras.forEach(affectedCamera => {\n              setupShape(item, affectedCamera.camera);\n            });\n          });\n        }\n      }\n    });\n    (_prev$frames = prev.frames) === null || _prev$frames === void 0 ? void 0 : _prev$frames.forEach(affectedCamera => {\n      const {\n        camera,\n        frames\n      } = affectedCamera;\n      if (this.rootStore.frame.attributes[camera]) {\n        frames.forEach(({\n          frameIndex\n        }) => {\n          delete this.rootStore.frame.attributes[camera][frameIndex];\n        });\n      }\n    });\n    (_curr$frames = curr.frames) === null || _curr$frames === void 0 ? void 0 : _curr$frames.forEach(affectedCamera => {\n      const {\n        camera,\n        frames\n      } = affectedCamera;\n      if (!this.rootStore.frame.attributes[camera]) {\n        this.rootStore.frame.attributes[camera] = {};\n      }\n      frames.forEach(({\n        frameIndex,\n        ...attributes\n      }) => {\n        this.rootStore.frame.attributes[camera][frameIndex] = {\n          frameIndex,\n          ...attributes\n        };\n      });\n    });\n    (_prev$reviews = prev.reviews) === null || _prev$reviews === void 0 ? void 0 : _prev$reviews.forEach(affectedReview => {\n      const {\n        id,\n        frameIndex\n      } = affectedReview;\n      const frameReviews = this.rootStore.review.reviews[frameIndex] || [];\n      const index = frameReviews.findIndex(r => r.id === id);\n      if (index >= 0) {\n        frameReviews.splice(index, 1);\n      }\n      const {\n        anchor\n      } = this.rootStore.review.anchors[id] || {};\n      if (anchor) {\n        delete this.rootStore.review.anchors[id];\n        anchor.destroy();\n      }\n    });\n    (_curr$reviews = curr.reviews) === null || _curr$reviews === void 0 ? void 0 : _curr$reviews.forEach(affectedReview => {\n      const {\n        frameIndex,\n        camera\n      } = affectedReview;\n      const review = new ReviewItem(affectedReview);\n      if (!this.rootStore.review.reviews[frameIndex]) {\n        this.rootStore.review.reviews[frameIndex] = [];\n      }\n      this.rootStore.review.reviews[frameIndex].push(review);\n      if (frameIndex === currentFrame) {\n        const cameraView = this.rootStore.frame.cameraViews[camera];\n        if (cameraView && cameraView.reviewLayer) {\n          const anchor = this.rootStore.review.createReviewAnchor(review.result, review.x, review.y, cameraView.reviewLayer, cameraView.viewScale);\n          if (anchor) {\n            this.rootStore.review.anchors[review.id] = {\n              anchor,\n              camera\n            };\n          }\n        }\n      }\n    });\n\n    // reselect instance or instance item\n    if (Object.keys(selectedInstanceMap).length > 0) {\n      const instances = [];\n      const instanceItems = [];\n      Object.keys(selectedInstanceMap).forEach(instanceId => {\n        const instance = getInstanceById(instanceId);\n        if (instance) {\n          instances.push(instance);\n          const itemIds = selectedInstanceMap[instanceId];\n          Object.values(instance.items).forEach(item => {\n            if (itemIds.includes(item.id)) {\n              instanceItems.push(item);\n            }\n          });\n        }\n      });\n      if (instanceItems.length > 0) {\n        this.rootStore.instance.selectInstanceItem(instanceItems);\n      } else if (instances.length > 0) {\n        this.rootStore.instance.selectInstance(instances);\n      }\n    }\n    this.rootStore.shape.predict();\n\n    // reselect review item\n    if (this.rootStore.review.selectedReviewId) {\n      const review = this.rootStore.review.allReviews.find(r => r.id === this.rootStore.review.selectedReviewId);\n      if (review) {\n        const {\n          anchor\n        } = this.rootStore.review.anchors[review.id] || {};\n        if (anchor) {\n          this.rootStore.review.selectReview(review, anchor);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["makeAutoObservable","v4","uuidv4","cloneDeep","message","i18n","ReviewItem","STACK_SIZE","UndoStore","undoDisabled","pointer","redoDisabled","stack","length","constructor","rootStore","lastStoreId","storeId","savedData","autoBind","preserve","data","save","uid","slice","push","before","after","shift","prevState","currState","undo","config","isAnyModalOpened","shape","isDrawing","item","updateData","success","translate","redo","curr","prev","_prev$instances","_curr$instances","_prev$frames","_curr$frames","_prev$reviews","_curr$reviews","selectedInstances","selectedInstanceItems","getInstanceById","deleteInstance","deleteInstanceItem","createInstanceFromData","instance","getShapeByInstanceItem","deleteShape","setupShape","currentFrame","frame","selectedInstanceMap","forEach","id","filter","i","map","instances","affectedInstance","children","affectedItem","items","cameras","affectedCamera","camera","frames","affectedFrame","frameIndex","isEmpty","attributes","setDynamicAttributes","dynamicAttributes","createFrameFromData","createCameraFromData","createItemFromData","createdItem","number","Object","values","keys","createdInstance","reviews","affectedReview","frameReviews","review","index","findIndex","r","splice","anchor","anchors","destroy","cameraView","cameraViews","reviewLayer","createReviewAnchor","result","x","y","viewScale","instanceItems","instanceId","itemIds","includes","selectInstanceItem","selectInstance","predict","selectedReviewId","allReviews","find","selectReview"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/UndoStore.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport { v4 as uuidv4 } from 'uuid';\nimport { cloneDeep } from 'lodash';\nimport { message } from 'antd';\nimport RootStore from './RootStore';\nimport i18n from '../locales';\nimport { Instance, Review, CameraFrameAttributes } from '../types';\nimport ReviewItem from '../model/ReviewItem';\nimport MInstance from '../model/Instance';\nimport MInstanceItem from '../model/InstanceItem';\n\nconst STACK_SIZE = 20;\n\nexport interface StoreData {\n  // for instances\n  instances?: Instance[];\n  // for reviews\n  reviews?: Review[];\n  // for frame attributes\n  frames?: CameraFrameAttributes[];\n};\n\ninterface StoreItem {\n  before: StoreData;\n  after: StoreData;\n}\n\n/**\n * undo & redo store\n * @class\n */\nexport default class UndoStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * current pointer\n   */\n  pointer = 0;\n\n  /**\n   * last stored data uuid\n   */\n  lastStoreId = '';\n\n  /**\n   * saved status\n   */\n  stack: StoreItem[] = [];\n\n  /**\n   * current data uuid\n   */\n  storeId = '';\n\n  /**\n   * saved data copy\n   */\n  savedData: StoreData = {};\n\n  /**\n   * is undo disabled\n   * @getter\n   */\n  get undoDisabled() {\n    return this.pointer <= 0;\n  }\n\n  /**\n   * is redo disabled\n   * @getter\n   */\n  get redoDisabled() {\n    return this.pointer >= this.stack.length;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      stack: false,\n      storeId: false,\n      savedData: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * preserve current data\n   * @param data\n   */\n  preserve(data: StoreData = {}) {\n    this.storeId = uuidv4();\n    this.savedData = cloneDeep(data);\n    return this.storeId;\n  }\n\n  /**\n   * save to stack\n   * @param uid\n   * @param data\n   */\n  save(uid: string, data: StoreData = {}) {\n    if (uid === this.storeId) { // same command\n      this.stack = this.stack.slice(0, this.pointer);\n      this.stack.push({\n        before: this.savedData,\n        after: cloneDeep(data),\n      });\n      if (this.stack.length > STACK_SIZE) {\n        this.stack.shift();\n      } else {\n        this.pointer += 1;\n      }\n      this.lastStoreId = uid;\n    }\n    this.storeId = '';\n    this.savedData = {};\n  }\n\n  /**\n   * push state by prev & curr state\n   * @param prevState\n   * @param currState\n   */\n  push(prevState: StoreData, currState: StoreData) {\n    this.stack = this.stack.slice(0, this.pointer);\n    this.stack.push({\n      before: cloneDeep(prevState),\n      after: cloneDeep(currState),\n    });\n    if (this.stack.length > STACK_SIZE) {\n      this.stack.shift();\n    } else {\n      this.pointer += 1;\n    }\n    this.lastStoreId = uuidv4();\n  }\n\n  /**\n   * undo\n   */\n  undo() {\n    if (this.undoDisabled || this.rootStore.config.isAnyModalOpened || this.rootStore.shape.isDrawing) {\n      return;\n    }\n    if (this.pointer > 0) {\n      this.pointer -= 1;\n      const item = this.stack[this.pointer];\n      if (item && item.before) {\n        this.updateData(item.before, item.after);\n        message.success(i18n.translate('UNDO_SUCCESS'));\n      }\n    }\n  }\n\n  /**\n   * redo\n   */\n  redo() {\n    if (this.redoDisabled || this.rootStore.config.isAnyModalOpened || this.rootStore.shape.isDrawing) {\n      return;\n    }\n    if (this.pointer < this.stack.length) {\n      this.pointer += 1;\n      const item = this.stack[this.pointer - 1];\n      if (item && item.after) {\n        this.updateData(item.after, item.before);\n        message.success(i18n.translate('REDO_SUCCESS'));\n      }\n    }\n  }\n\n  /**\n   * update data (used for undo / redo)\n   * @param curr\n   * @param prev\n   */\n  updateData(curr: StoreData, prev: StoreData) {\n    const {\n      selectedInstances,\n      selectedInstanceItems,\n      getInstanceById,\n      deleteInstance,\n      deleteInstanceItem,\n      createInstanceFromData,\n    } = this.rootStore.instance;\n    const {\n      getShapeByInstanceItem,\n      deleteShape,\n      setupShape,\n    } = this.rootStore.shape;\n    const {\n      currentFrame,\n    } = this.rootStore.frame;\n    const selectedInstanceMap: { [instanceId: string]: string[] } = {};\n    selectedInstances.forEach((instance) => {\n      selectedInstanceMap[instance.id] = selectedInstanceItems.filter((i) => i.instance === instance).map((i) => i.id);\n    });\n\n    prev.instances?.forEach((affectedInstance) => {\n      if (affectedInstance) {\n        const instance = getInstanceById(affectedInstance.id);\n        if (instance) {\n          affectedInstance.children.forEach((affectedItem) => {\n            const item = instance.items[affectedItem.id];\n            if (item) {\n              affectedItem.cameras.forEach((affectedCamera) => {\n                const camera = item.cameras[affectedCamera.camera];\n                if (camera) {\n                  // delete frame\n                  affectedCamera.frames.forEach((affectedFrame) => {\n                    if (affectedFrame.frameIndex === currentFrame) {\n                      // remove shapes if needed\n                      const shape = getShapeByInstanceItem(item, camera.camera);\n                      if (shape) {\n                        deleteShape(shape);\n                      }\n                    }\n                    // delete frame data\n                    delete camera.frames[affectedFrame.frameIndex];\n                  });\n                  // delete camera if needed\n                  if (camera.isEmpty) {\n                    delete item.cameras[camera.camera];\n                  }\n                  // delete instance item if needed\n                  if (item.isEmpty) {\n                    deleteInstanceItem(item);\n                  }\n                  // delete instance if needed\n                  if (instance.isEmpty) {\n                    deleteInstance(instance);\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n    curr.instances?.forEach((affectedInstance) => {\n      if (affectedInstance) {\n        const instance = getInstanceById(affectedInstance.id);\n        if (instance) {\n          instance.attributes = cloneDeep(affectedInstance.attributes);\n          instance.setDynamicAttributes(affectedInstance.dynamicAttributes);\n          affectedInstance.children.forEach((affectedItem) => {\n            const item = instance.items[affectedItem.id];\n            if (item) {\n              affectedItem.cameras.forEach((affectedCamera) => {\n                const camera = item.cameras[affectedCamera.camera];\n                if (camera) {\n                  // update frame\n                  affectedCamera.frames.forEach((affectedFrame) => {\n                    camera.createFrameFromData(affectedFrame);\n                  });\n                } else {\n                  // no camera, create\n                  item.createCameraFromData(affectedCamera);\n                }\n                // readd shape\n                setupShape(item, affectedCamera.camera);\n              });\n            } else {\n              // no instance item, create\n              instance.createItemFromData(affectedItem);\n              const createdItem = instance.items[affectedItem.id];\n              // readd shapes\n              affectedItem.cameras.forEach((affectedCamera) => {\n                setupShape(createdItem, affectedCamera.camera);\n              });\n            }\n          });\n          if (instance.number !== affectedInstance.number) {\n            instance.number = affectedInstance.number;\n            Object.values(instance.items).forEach((item) => {\n              Object.keys(item.cameras).forEach((camera) => {\n                setupShape(item, camera);\n              });\n            });\n          }\n        } else {\n          // no instance, create\n          createInstanceFromData(affectedInstance);\n          const createdInstance = getInstanceById(affectedInstance.id);\n          affectedInstance.children.forEach((affectedItem) => {\n            const item = createdInstance.items[affectedItem.id];\n            // readd shapes\n            affectedItem.cameras.forEach((affectedCamera) => {\n              setupShape(item, affectedCamera.camera);\n            });\n          });\n        }\n      }\n    });\n\n    prev.frames?.forEach((affectedCamera) => {\n      const { camera, frames } = affectedCamera;\n      if (this.rootStore.frame.attributes[camera]) {\n        frames.forEach(({ frameIndex }) => {\n          delete this.rootStore.frame.attributes[camera][frameIndex];\n        });\n      }\n    });\n    curr.frames?.forEach((affectedCamera) => {\n      const { camera, frames } = affectedCamera;\n      if (!this.rootStore.frame.attributes[camera]) {\n        this.rootStore.frame.attributes[camera] = {};\n      }\n      frames.forEach(({ frameIndex, ...attributes }) => {\n        this.rootStore.frame.attributes[camera][frameIndex] = { frameIndex, ...attributes };\n      });\n    });\n\n    prev.reviews?.forEach((affectedReview) => {\n      const { id, frameIndex } = affectedReview;\n      const frameReviews = this.rootStore.review.reviews[frameIndex] || [];\n      const index = frameReviews.findIndex((r) => r.id === id);\n      if (index >= 0) {\n        frameReviews.splice(index, 1);\n      }\n      const { anchor } = this.rootStore.review.anchors[id] || {};\n      if (anchor) {\n        delete this.rootStore.review.anchors[id];\n        anchor.destroy();\n      }\n    });\n    curr.reviews?.forEach((affectedReview) => {\n      const { frameIndex, camera } = affectedReview;\n      const review = new ReviewItem(affectedReview);\n      if (!this.rootStore.review.reviews[frameIndex]) {\n        this.rootStore.review.reviews[frameIndex] = [];\n      }\n      this.rootStore.review.reviews[frameIndex].push(review);\n      if (frameIndex === currentFrame) {\n        const cameraView = this.rootStore.frame.cameraViews[camera];\n        if (cameraView && cameraView.reviewLayer) {\n          const anchor = this.rootStore.review.createReviewAnchor(review.result, review.x, review.y, cameraView.reviewLayer, cameraView.viewScale);\n          if (anchor) {\n            this.rootStore.review.anchors[review.id] = {\n              anchor,\n              camera,\n            };\n          }\n        }\n      }\n    });\n\n    // reselect instance or instance item\n    if (Object.keys(selectedInstanceMap).length > 0) {\n      const instances: MInstance[] = [];\n      const instanceItems: MInstanceItem[] = [];\n      Object.keys(selectedInstanceMap).forEach((instanceId) => {\n        const instance = getInstanceById(instanceId);\n        if (instance) {\n          instances.push(instance);\n          const itemIds = selectedInstanceMap[instanceId];\n          Object.values(instance.items).forEach((item) => {\n            if (itemIds.includes(item.id)) {\n              instanceItems.push(item);\n            }\n          });\n        }\n      });\n      if (instanceItems.length > 0) {\n        this.rootStore.instance.selectInstanceItem(instanceItems);\n      } else if (instances.length > 0) {\n        this.rootStore.instance.selectInstance(instances);\n      }\n    }\n    this.rootStore.shape.predict();\n\n    // reselect review item\n    if (this.rootStore.review.selectedReviewId) {\n      const review = this.rootStore.review.allReviews.find((r) => r.id === this.rootStore.review.selectedReviewId);\n      if (review) {\n        const { anchor } = this.rootStore.review.anchors[review.id] || {};\n        if (anchor) {\n          this.rootStore.review.selectReview(review, anchor);\n        }\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}