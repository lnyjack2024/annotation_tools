{"ast":null,"code":"/**\n * vector based on canvas coordinates\n * @class\n */export class Vector{get norm(){return Math.sqrt(this.x**2+this.y**2);}get normalVector(){return new Vector(this.y,-this.x);}constructor(){this.x=void 0;this.y=void 0;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}const[arg1,arg2]=args;if(typeof arg1==='number'&&typeof arg2==='number'){this.x=arg1;this.y=arg2;}else if(arg1&&arg1.x!==undefined&&arg1.y!==undefined&&arg2&&arg2.x!==undefined&&arg2.y!==undefined){this.x=arg1.x-arg2.x;this.y=arg1.y-arg2.y;}else{throw new Error('wrong arguments');}}/**\n   * add vector\n   * @param vector\n   */add(vector){this.x+=vector.x;this.y+=vector.y;return this;}/**\n   * divide num\n   * @param num\n   */divide(num){this.x/=num;this.y/=num;return this;}/**\n   * normalize norm to base\n   * @param base\n   */normalize(){let base=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;const a=base/this.norm;this.x*=a;this.y*=a;return this;}/**\n   * dot of another vector\n   * @param vector\n   */dot(vector){return this.x*vector.x+this.y*vector.y;}/**\n   * clone a new vector\n   * @returns\n   */clone(){return new Vector(this.x,this.y);}}export function calcOutlineForLine(points,width){const list1=[];const list2=[];let lastSegVector;for(let i=0;i<points.length-1;i+=1){const p1=points[i];const p2=points[i+1];const vector=new Vector(p1,p2).normalVector.normalize(width);// first point\nif(i===0){list1.push({x:p1.x+vector.x,y:p1.y+vector.y});list2.unshift({x:p1.x-vector.x,y:p1.y-vector.y});}// points between first & last\nif(lastSegVector){const pointVector=vector.clone().add(lastSegVector);const dot=vector.dot(pointVector)+1;// add 1 to fix cos = 0 issue\nconst cos=dot/(vector.norm*pointVector.norm);const dis=width/cos;const actualVector=pointVector.normalize(dis);list1.push({x:p1.x+actualVector.x,y:p1.y+actualVector.y});list2.unshift({x:p1.x-actualVector.x,y:p1.y-actualVector.y});}lastSegVector=vector;// last point\nif(i===points.length-2){list1.push({x:p2.x+vector.x,y:p2.y+vector.y});list2.unshift({x:p2.x-vector.x,y:p2.y-vector.y});}}return list1.concat(list2);}","map":{"version":3,"names":["Vector","norm","Math","sqrt","x","y","normalVector","constructor","_len","arguments","length","args","Array","_key","arg1","arg2","undefined","Error","add","vector","divide","num","normalize","base","a","dot","clone","calcOutlineForLine","points","width","list1","list2","lastSegVector","i","p1","p2","push","unshift","pointVector","cos","dis","actualVector","concat"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/utils/vector.ts"],"sourcesContent":["interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * vector based on canvas coordinates\n * @class\n */\nexport class Vector {\n  x: number;\n\n  y: number;\n\n  get norm() {\n    return Math.sqrt(this.x ** 2 + this.y ** 2);\n  }\n\n  get normalVector() {\n    return new Vector(this.y, -this.x);\n  }\n\n  constructor(...args: [number, number] | [Point, Point]) {\n    const [arg1, arg2] = args;\n    if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n      this.x = arg1;\n      this.y = arg2;\n    } else if (\n      arg1 && (arg1 as Point).x !== undefined && (arg1 as Point).y !== undefined &&\n      arg2 && (arg2 as Point).x !== undefined && (arg2 as Point).y !== undefined\n    ) {\n      this.x = (arg1 as Point).x - (arg2 as Point).x;\n      this.y = (arg1 as Point).y - (arg2 as Point).y;\n    } else {\n      throw new Error('wrong arguments');\n    }\n  }\n\n  /**\n   * add vector\n   * @param vector\n   */\n  add(vector: Vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n    return this;\n  }\n\n  /**\n   * divide num\n   * @param num\n   */\n  divide(num: number) {\n    this.x /= num;\n    this.y /= num;\n    return this;\n  }\n\n  /**\n   * normalize norm to base\n   * @param base\n   */\n  normalize(base = 1) {\n    const a = base / this.norm;\n    this.x *= a;\n    this.y *= a;\n    return this;\n  }\n\n  /**\n   * dot of another vector\n   * @param vector\n   */\n  dot(vector: Vector) {\n    return this.x * vector.x + this.y * vector.y;\n  }\n\n  /**\n   * clone a new vector\n   * @returns\n   */\n  clone() {\n    return new Vector(this.x, this.y);\n  }\n}\n\nexport function calcOutlineForLine(points: Point[], width: number) {\n  const list1: Point[] = [];\n  const list2: Point[] = [];\n\n  let lastSegVector: Vector | undefined;\n  for (let i = 0; i < points.length - 1; i += 1) {\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const vector = new Vector(p1, p2).normalVector.normalize(width);\n\n    // first point\n    if (i === 0) {\n      list1.push({\n        x: p1.x + vector.x,\n        y: p1.y + vector.y,\n      });\n      list2.unshift({\n        x: p1.x - vector.x,\n        y: p1.y - vector.y,\n      });\n    }\n\n    // points between first & last\n    if (lastSegVector) {\n      const pointVector = vector.clone().add(lastSegVector);\n      const dot = vector.dot(pointVector) + 1; // add 1 to fix cos = 0 issue\n      const cos = dot / (vector.norm * pointVector.norm);\n      const dis = width / cos;\n      const actualVector = pointVector.normalize(dis);\n      list1.push({\n        x: p1.x + actualVector.x,\n        y: p1.y + actualVector.y,\n      });\n      list2.unshift({\n        x: p1.x - actualVector.x,\n        y: p1.y - actualVector.y,\n      });\n    }\n    lastSegVector = vector;\n\n    // last point\n    if (i === points.length - 2) {\n      list1.push({\n        x: p2.x + vector.x,\n        y: p2.y + vector.y,\n      });\n      list2.unshift({\n        x: p2.x - vector.x,\n        y: p2.y - vector.y,\n      });\n    }\n  }\n\n  return list1.concat(list2);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}