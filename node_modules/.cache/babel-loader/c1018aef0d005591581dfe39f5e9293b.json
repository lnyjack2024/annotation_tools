{"ast":null,"code":"// copied from prism-react-renderer\n// https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/prism-react-renderer/src/utils/normalizeTokens.ts\nconst newlineRe=/\\r\\n|\\r|\\n/;// Empty lines need to contain a single empty token, denoted with { empty: true }\nconst normalizeEmptyLines=line=>{if(line.length===0){line.push({types:['plain'],content:'\\n',empty:true});}else if(line.length===1&&line[0].content===''){line[0].content='\\n';line[0].empty=true;}};const appendTypes=(types,add)=>{const typesSize=types.length;if(typesSize>0&&types[typesSize-1]===add){return types;}return types.concat(add);};// Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\nconst normalizeTokens=tokens=>{const typeArrStack=[[]];const tokenArrStack=[tokens];const tokenArrIndexStack=[0];const tokenArrSizeStack=[tokens.length];let i=0;let stackIndex=0;let currentLine=[];const acc=[currentLine];while(stackIndex>-1){while(// eslint-disable-next-line no-cond-assign, no-plusplus\n(i=tokenArrIndexStack[stackIndex]++)<tokenArrSizeStack[stackIndex]){let content;let types=typeArrStack[stackIndex];const tokenArr=tokenArrStack[stackIndex];const token=tokenArr[i];// Determine content and append type to types if necessary\nif(typeof token==='string'){types=stackIndex>0?types:['plain'];content=token;}else{types=appendTypes(types,token.type);if(token.alias){types=appendTypes(types,token.alias);}content=token.content;}// If token.content is an array, increase the stack depth and repeat this while-loop\nif(typeof content!=='string'){stackIndex+=1;typeArrStack.push(types);tokenArrStack.push(content);tokenArrIndexStack.push(0);tokenArrSizeStack.push(content.length);// eslint-disable-next-line no-continue\ncontinue;}// Split by newlines\nconst splitByNewlines=content.split(newlineRe);const newlineCount=splitByNewlines.length;currentLine.push({types,content:splitByNewlines[0]});// Create a new line for each string on a new line\nfor(let j=1;j<newlineCount;j+=1){normalizeEmptyLines(currentLine);acc.push(currentLine=[]);currentLine.push({types,content:splitByNewlines[j]});}}// Decreate the stack depth\nstackIndex-=1;typeArrStack.pop();tokenArrStack.pop();tokenArrIndexStack.pop();tokenArrSizeStack.pop();}normalizeEmptyLines(currentLine);return acc;};export default normalizeTokens;","map":{"version":3,"names":["newlineRe","normalizeEmptyLines","line","length","push","types","content","empty","appendTypes","add","typesSize","concat","normalizeTokens","tokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","i","stackIndex","currentLine","acc","tokenArr","token","type","alias","splitByNewlines","split","newlineCount","j","pop"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/code/normalizeTokens.ts"],"sourcesContent":["// copied from prism-react-renderer\n// https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/prism-react-renderer/src/utils/normalizeTokens.ts\n\nimport type { Token as PrismToken, TokenStream } from 'prismjs';\n\nexport type Token = {\n  types: string[];\n  content: string;\n  empty?: boolean;\n};\n\nconst newlineRe = /\\r\\n|\\r|\\n/;\n\n// Empty lines need to contain a single empty token, denoted with { empty: true }\nconst normalizeEmptyLines = (line: Token[]) => {\n  if (line.length === 0) {\n    line.push({\n      types: ['plain'],\n      content: '\\n',\n      empty: true,\n    });\n  } else if (line.length === 1 && line[0].content === '') {\n    line[0].content = '\\n';\n    line[0].empty = true;\n  }\n};\n\nconst appendTypes = (types: string[], add: string[] | string): string[] => {\n  const typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n};\n\n// Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\nconst normalizeTokens = (tokens: (PrismToken | string)[]): Token[][] => {\n  const typeArrStack: string[][] = [[]];\n  const tokenArrStack = [tokens];\n  const tokenArrIndexStack = [0];\n  const tokenArrSizeStack = [tokens.length];\n  let i = 0;\n  let stackIndex = 0;\n  let currentLine: Token[] = [];\n  const acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while (\n      // eslint-disable-next-line no-cond-assign, no-plusplus\n      (i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]\n    ) {\n      let content: TokenStream;\n      let types = typeArrStack[stackIndex];\n      const tokenArr = tokenArrStack[stackIndex];\n      const token = tokenArr[i];\n\n      // Determine content and append type to types if necessary\n      if (typeof token === 'string') {\n        types = stackIndex > 0 ? types : ['plain'];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      }\n\n      // If token.content is an array, increase the stack depth and repeat this while-loop\n      if (typeof content !== 'string') {\n        stackIndex += 1;\n        typeArrStack.push(types);\n        tokenArrStack.push(content as PrismToken[]);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // Split by newlines\n      const splitByNewlines = content.split(newlineRe);\n      const newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types,\n        content: splitByNewlines[0],\n      });\n\n      // Create a new line for each string on a new line\n      for (let j = 1; j < newlineCount; j += 1) {\n        normalizeEmptyLines(currentLine);\n        acc.push((currentLine = []));\n        currentLine.push({\n          types,\n          content: splitByNewlines[j],\n        });\n      }\n    }\n\n    // Decreate the stack depth\n    stackIndex -= 1;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nexport default normalizeTokens;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}