{"ast":null,"code":"import { Base64 } from 'js-base64';\nimport Flatten from '@flatten-js/core';\nimport imageLoader from 'blueimp-load-image';\nimport Papa from 'papaparse';\nimport { utils as formUtils } from '@appen-china/easy-form';\nimport { FieldControlType, Mode } from '@appen-china/easy-form/es/types';\nimport { Tool, CVModel, TrafficSignModelMappingType } from './types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_FRAME_IMAGE_NAME } from './constants';\nimport { fetchResultByUrl } from '../../utils';\nimport { computeRotatedPosition, getEllipseBounds, precise } from '../../utils/math';\nimport { calcControlsForPairs, discretizeCurve } from '../../utils/bezier';\nimport { ShapeType } from '../common/shapes/types';\n/**\n * parse frames\n * @param frames\n */\nexport function parseFrames(frames) {\n  if (typeof frames === 'string') {\n    // eg. 'https://1.jpg,https://2.jpg,...'\n    return frames.split(',').map(f => ({\n      [DEFAULT_FRAME_IMAGE_NAME]: f.trim()\n    }));\n  }\n  if (Array.isArray(frames)) {\n    return frames.map(f => {\n      if (typeof f === 'string') {\n        // eg.\n        // [\n        //   'https://1.jpg',\n        //   'https://2.jpg',\n        //   ...\n        // ]\n        // or\n        // [\n        //   'https://11.jpg,https://12.jpg,...',\n        //   'https://21.jpg,https://22.jpg,...',\n        //   ...\n        // ]\n        const urls = f.split(',');\n        return urls.reduce((acc, curr, i) => ({\n          ...acc,\n          [`${DEFAULT_FRAME_IMAGE_NAME}${i === 0 ? '' : `_${i}`}`]: curr.trim()\n        }), {});\n      }\n      if (Array.isArray(f)) {\n        // eg.\n        // [\n        //   ['https://11.jpg', 'https://12.jpg', ...],\n        //   ['https://21.jpg', 'https://22.jpg', ...],\n        //   ...\n        // ]\n        // or\n        // [\n        //   [{ url: 'https://11.jpg', name: 'img1' }, { url: 'https://12.jpg', name: 'img2' }, ...],\n        //   [{ url: 'https://21.jpg', name: 'img1' }, { url: 'https://22.jpg', name: 'img2' }, ...],\n        //   ...\n        // ]\n        return f.reduce((acc, curr, i) => {\n          const url = typeof curr === 'string' ? curr : curr.url || '';\n          const name = curr.name || `${DEFAULT_FRAME_IMAGE_NAME}${i === 0 ? '' : `_${i}`}`;\n          return {\n            ...acc,\n            [name]: url.trim()\n          };\n        }, {});\n      }\n\n      // default empty frame\n      return {\n        [DEFAULT_FRAME_IMAGE_NAME]: ''\n      };\n    });\n  }\n  return [];\n}\n\n/**\n * parse frames config from cameras\n * @param cameras\n */\nfunction parseFramesFromCamera(cameras) {\n  if (Array.isArray(cameras) && cameras.length > 0 && cameras.every(c => c && c.camera && (typeof c.frames === 'string' || Array.isArray(c.frames)))) {\n    const allCameras = cameras.map(c => ({\n      camera: `${c.camera}`,\n      images: parseFrames(c.frames),\n      data: c.data,\n      calibrations: c.calibrations,\n      ...((typeof c.embeddings === 'string' || Array.isArray(c.embeddings)) && {\n        embeddings: parseFrames(c.embeddings)\n      })\n    }));\n    const maxFrameCount = Math.max(...allCameras.map(c => c.images.length));\n    allCameras.forEach(c => {\n      if (c.images.length < maxFrameCount) {\n        c.images = c.images.concat(Array.from({\n          length: maxFrameCount - c.images.length\n        }).map(() => ({\n          [DEFAULT_FRAME_IMAGE_NAME]: ''\n        })));\n      }\n    });\n    return allCameras;\n  }\n  return null;\n}\n\n/**\n * parse frames config from frames\n * @param frames\n * @param embeddings\n */\nfunction parseFramesFromFrames(frames, embeddings) {\n  if (typeof frames === 'string' && frames || Array.isArray(frames)) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      images: parseFrames(frames),\n      ...((typeof embeddings === 'string' || Array.isArray(embeddings)) && {\n        embeddings: parseFrames(embeddings)\n      })\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames config from main\n * @param frames\n */\nfunction parseFramesFromMain(main) {\n  if (main && main.image) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      images: parseFrames([main.image])\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames from payload\n * @param payload\n */\nexport async function parseFramesByPaylod({\n  frames,\n  embeddings,\n  base_url\n}, rootStore) {\n  const niftiUrl = getNIFTIUrl({\n    frames,\n    base_url\n  });\n  if (niftiUrl) {\n    return {\n      niftiUrl\n    };\n  }\n  const dicomDirUrl = getDicomDirUrl({\n    frames,\n    base_url\n  });\n  if (dicomDirUrl) {\n    return {\n      dicomDirUrl\n    };\n  }\n  const parseFromFrames = parseFramesFromFrames(frames, embeddings);\n  if (parseFromFrames !== null) {\n    return {\n      cameras: parseFromFrames\n    };\n  }\n  if (base_url) {\n    let res;\n    try {\n      res = JSON.parse(base_url);\n    } catch (e) {\n      // parse error\n    }\n    if (!res) {\n      try {\n        res = await fetchResultByUrl(base_url);\n      } catch (e) {\n        // fetch error\n      }\n    }\n    if (res) {\n      if (res.main) {\n        const parseFromMainResult = parseFramesFromMain(res.main);\n        if (parseFromMainResult !== null) {\n          if (res.frames && rootStore) {\n            rootStore.config.setNeedThumbnailLayer(true);\n            rootStore.thumbnail.setThumbnails(res.frames);\n          }\n          return {\n            cameras: parseFromMainResult\n          };\n        }\n      }\n      const parseFromCameraResult = parseFramesFromCamera(res.cameras);\n      if (parseFromCameraResult !== null) {\n        return {\n          cameras: parseFromCameraResult\n        };\n      }\n      const parseFromFramesResult = parseFramesFromFrames(res.frames, res.embeddings);\n      if (parseFromFramesResult !== null) {\n        return {\n          cameras: parseFromFramesResult\n        };\n      }\n    }\n  }\n  return {\n    cameras: [{\n      camera: DEFAULT_CAMERA_NAME,\n      images: []\n    }]\n  };\n}\nfunction getNIFTIUrl({\n  frames\n}) {\n  if (typeof frames === 'string') {\n    const frameList = frames.split(',');\n    if (frameList.length === 1) {\n      // 当前仅支持单个nifti文件\n      const frameUrl = frameList[0].trim();\n      if (isNIFTIUrl(frameUrl)) {\n        return frameUrl;\n      }\n    }\n  }\n  return '';\n}\nfunction getDicomDirUrl({\n  frames\n}) {\n  if (typeof frames === 'string' && (frames === null || frames === void 0 ? void 0 : frames.endsWith('DICOMDIR'))) {\n    // FIXME: 可能需要支持更复杂的结构\n    return frames;\n  }\n  return '';\n}\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result) {\n  const instances = [];\n  if (result && result.instances && Array.isArray(result.instances)) {\n    // legacy data no longer supported\n\n    // result.instances.forEach((instance: any) => {\n    //   if (instance.frames) {\n    //     // legacy data\n    //     const defaultCamera: CameraData = {\n    //       camera: DEFAULT_CAMERA_NAME,\n    //       frames: instance.frames,\n    //     };\n    //     const defaultItem: InstanceItem = {\n    //       id: uuidv4(),\n    //       name: DEFAULT_CATEGORY_ITEM,\n    //       number: 1,\n    //       cameras: [defaultCamera],\n    //     };\n    //     const newInstance: Instance = {\n    //       id: instance.id,\n    //       category: instance.category,\n    //       number: instance.number,\n    //       children: [defaultItem],\n    //     };\n    //     instances.push(newInstance);\n    //     // TODO: fix string points attribute for rectangle\n    //   } else {\n    //     instances.push(instance);\n    //   }\n    // });\n\n    return result.instances;\n  }\n  return instances;\n}\n\n/**\n * format frames as string\n * @param frames\n */\nexport function formatFrames(frames) {\n  if (frames.length === 1) {\n    return frames[0] + 1;\n  }\n  const ranges = [];\n  if (frames.length > 1) {\n    let currMin = frames[0];\n    let currMax = frames[0];\n    let i = 1;\n    while (i < frames.length) {\n      if (frames[i] - frames[i - 1] > 1) {\n        currMax = frames[i - 1];\n        ranges.push([currMin, currMax]);\n        currMin = frames[i];\n        currMax = frames[i];\n      }\n      i += 1;\n    }\n    currMax = frames[frames.length - 1];\n    ranges.push([currMin, currMax]);\n  }\n  return ranges.reduce((acc, curr) => `${acc ? `${acc}, ` : ''}${curr[0] === curr[1] ? curr[0] + 1 : `${curr[0] + 1}-${curr[1] + 1}`}`, '');\n}\n\n/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */\nexport function predictShapeData(currentFrame, frames, precision, bounds) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame, precision);\n    }\n  }\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const {\n        shapeType,\n        shape\n      } = frames[prevKeyFrameIndexes[0]];\n      return {\n        shapeType,\n        shape\n      };\n    }\n  }\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const {\n      shapeType,\n      shape\n    } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame, precision);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return {\n        shapeType,\n        shape\n      };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const {\n      shapeType,\n      shape\n    } = frames[prevKeyFrameIndexes[0]];\n    return {\n      shapeType,\n      shape\n    };\n  }\n  return null;\n}\n\n/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getLastKeyFrames(count, currentFrame, frames) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map(f => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getNextKeyFrames(count, currentFrame, frames) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map(f => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */\nexport function getShapeFromFrames(frames, startFrame, endFrame, baseFrame, currentFrame, precision) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape\n  };\n  if (Object.values(frames).filter(f => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some(f => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE:\n    case ShapeType.SQUARE:\n      {\n        const shape = calculate(startShape, endShape, baseShape, frameScale, precision);\n        const {\n          x: startX,\n          width: startW,\n          center: startCenter\n        } = startShape;\n        const {\n          x: endX,\n          width: endW,\n          center: endCenter\n        } = endShape;\n        const {\n          x: baseX,\n          width: baseW,\n          center: baseCenter\n        } = baseShape;\n        let center;\n        if (startCenter !== undefined && endCenter !== undefined && baseCenter !== undefined) {\n          const startCenterScale = (startCenter - startX) / startW;\n          const endCenterScale = (endCenter - endX) / endW;\n          const baseCenterScale = (baseCenter - baseX) / baseW;\n          const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n          center = precise(Math.min(Math.max(centerScale * shape.width + shape.x, shape.x), shape.x + shape.width), precision);\n        }\n        const right = precise(shape.x + shape.width, precision);\n        const bottom = precise(shape.y + shape.height, precision);\n        const points = [{\n          x: shape.x,\n          y: shape.y\n        }, {\n          x: right,\n          y: shape.y\n        }, {\n          x: right,\n          y: bottom\n        }, {\n          x: shape.x,\n          y: bottom\n        }];\n        if (shape.rotation) {\n          points.forEach(p => {\n            const point = computeRotatedPosition({\n              x: shape.x + shape.width / 2,\n              y: shape.y + shape.height / 2\n            }, p, shape.rotation);\n            p.x = precise(point.x, precision);\n            p.y = precise(point.y, precision);\n          });\n        }\n        shape.points = points;\n        shapeInfo.shape = {\n          ...shape,\n          center\n        };\n        break;\n      }\n    case ShapeType.ELLIPSE:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale, precision);\n        break;\n      }\n    case ShapeType.CIRCLE:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale, precision);\n        break;\n      }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID:\n      {\n        const {\n          front: startFront,\n          back: startBack,\n          points: startPoints\n        } = startShape;\n        const {\n          front: endFront,\n          back: endBack,\n          points: endPoints\n        } = endShape;\n        const {\n          front: baseFront,\n          back: baseBack,\n          points: basePoints\n        } = baseShape;\n        const front = calculate(startFront, endFront, baseFront, frameScale, precision);\n        const back = calculate(startBack, endBack, baseBack, frameScale, precision);\n        shapeInfo.shape = {\n          front,\n          back\n        };\n        if (startPoints && endPoints && basePoints) {\n          const startClockwise = startPoints[0].x < startPoints[1].x;\n          const endClockwise = endPoints[0].x < endPoints[1].x;\n          const baseClockwise = basePoints[0].x < basePoints[1].x;\n          if (startClockwise === endClockwise && startClockwise === baseClockwise) {\n            // same direction\n            shapeInfo.shape.points = startClockwise ? [{\n              x: front.x,\n              y: front.y\n            }, {\n              x: precise(front.x + front.width, precision),\n              y: front.y\n            }, {\n              x: precise(front.x + front.width, precision),\n              y: precise(front.y + front.height, precision)\n            }, {\n              x: front.x,\n              y: precise(front.y + front.height, precision)\n            }, {\n              x: back.x,\n              y: back.y\n            }, {\n              x: precise(back.x + back.width, precision),\n              y: back.y\n            }, {\n              x: precise(back.x + back.width, precision),\n              y: precise(back.y + back.height, precision)\n            }, {\n              x: back.x,\n              y: precise(back.y + back.height, precision)\n            }] : [{\n              x: precise(front.x + front.width, precision),\n              y: front.y\n            }, {\n              x: front.x,\n              y: front.y\n            }, {\n              x: front.x,\n              y: precise(front.y + front.height, precision)\n            }, {\n              x: precise(front.x + front.width, precision),\n              y: precise(front.y + front.height, precision)\n            }, {\n              x: precise(back.x + back.width, precision),\n              y: back.y\n            }, {\n              x: back.x,\n              y: back.y\n            }, {\n              x: back.x,\n              y: precise(back.y + back.height, precision)\n            }, {\n              x: precise(back.x + back.width, precision),\n              y: precise(back.y + back.height, precision)\n            }];\n          }\n        }\n        break;\n      }\n    case ShapeType.LSHAPE:\n      {\n        const {\n          front: startFront,\n          sidePoints: startSidePoints,\n          center: startCenter\n        } = startShape;\n        const {\n          front: endFront,\n          sidePoints: endSidePoints,\n          center: endCenter\n        } = endShape;\n        const {\n          front: baseFront,\n          sidePoints: baseSidePoints,\n          center: baseCenter\n        } = baseShape;\n        const front = calculate(startFront, endFront, baseFront, frameScale, precision);\n        const sidePoints = startSidePoints.map((_, index) => calculate(startSidePoints[index], endSidePoints[index], baseSidePoints[index], frameScale, precision));\n        const startCenterScale = (startCenter - startFront.x) / startFront.width;\n        const endCenterScale = (endCenter - endFront.x) / endFront.width;\n        const baseCenterScale = (baseCenter - baseFront.x) / baseFront.width;\n        const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n        const center = precise(Math.min(Math.max(centerScale * front.width + front.x, front.x), front.x + front.width), precision);\n        shapeInfo.shape = {\n          front,\n          sidePoints,\n          center\n        };\n        break;\n      }\n    case ShapeType.DOT:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale, precision);\n        break;\n      }\n    default:\n  }\n\n  // recalc shape bounds\n  if (baseShape.shapeBounds) {\n    shapeInfo.shape.shapeBounds = calcShapeBounds(shapeInfo.shapeType, shapeInfo.shape);\n  }\n  // recalc shape area\n  const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n  if (!Number.isNaN(area)) {\n    shapeInfo.shape.area = area;\n  }\n  return shapeInfo;\n}\n\n/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */\nfunction calculate(start, end, base, scale, precision) {\n  const calculatedObject = {};\n  Object.keys(base).forEach(key => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = precise(base[key] + (end[key] - start[key]) * scale, precision);\n    }\n  });\n  return calculatedObject;\n}\n\n/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */\nexport function checkShapeInBounds(shape, shapeType, bounds) {\n  if (shapeType === ShapeType.PIXEL) {\n    // no need to check\n    return true;\n  }\n  const shapeBounds = calcShapeBounds(shapeType, shape);\n  if (shapeBounds) {\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = shapeBounds;\n    return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n  }\n  return true;\n}\n\n/**\n * get snapshot image data url by shape data\n * @param imageUrl\n * @param imageRotation\n * @param shape\n * @param resizeTo\n */\nexport function getSnapshot(imageUrl, imageRotation, shape, pdfDocument, pdfPage, resizeTo) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const imageCanvas = document.createElement('canvas');\n    const imageCtx = imageCanvas.getContext('2d');\n    if (!ctx || !imageCtx) {\n      reject();\n    }\n    const drawSnapshot = (image, imageWidth, imageHeight) => {\n      imageCanvas.width = imageRotation % Math.PI === 0 ? image.width : image.height;\n      imageCanvas.height = imageRotation % Math.PI === 0 ? image.height : image.width;\n      imageCtx.translate(imageCanvas.width / 2, imageCanvas.height / 2);\n      imageCtx.rotate(imageRotation);\n      imageCtx.drawImage(image, -image.width / 2, -image.height / 2);\n      const shapeScale = {\n        x: image.width / imageWidth,\n        y: image.height / imageHeight\n      };\n      if (shape && Array.isArray(shape.points)) {\n        // use points as boundary\n        // polygon, line, or rotatable rectangle\n        const s = shape;\n        const points = s.points.map(p => ({\n          x: p.x * shapeScale.x,\n          y: p.y * shapeScale.y\n        }));\n        let minX = points[0].x;\n        let minY = points[0].y;\n        let maxX = minX;\n        let maxY = minY;\n        for (let i = 1; i < points.length; i += 1) {\n          const {\n            x,\n            y\n          } = points[i];\n          if (x < minX) {\n            minX = x;\n          }\n          if (x > maxX) {\n            maxX = x;\n          }\n          if (y < minY) {\n            minY = y;\n          }\n          if (y > maxY) {\n            maxY = y;\n          }\n        }\n        const xScale = (resizeTo === null || resizeTo === void 0 ? void 0 : resizeTo.width) ? resizeTo.width / (maxX - minX) : 1;\n        const yScale = (resizeTo === null || resizeTo === void 0 ? void 0 : resizeTo.height) ? resizeTo.height / (maxY - minY) : 1;\n        canvas.width = (maxX - minX) * xScale;\n        canvas.height = (maxY - minY) * yScale;\n        points.forEach((p, i) => {\n          if (i === 0) {\n            ctx.moveTo((p.x - minX) * xScale, (p.y - minY) * yScale);\n          } else {\n            ctx.lineTo((p.x - minX) * xScale, (p.y - minY) * yScale);\n          }\n        });\n        ctx.lineTo((points[0].x - minX) * xScale, (points[0].y - minY) * yScale);\n        ctx.clip();\n        ctx.drawImage(imageCanvas, minX, minY, maxX - minX, maxY - minY, 0, 0, canvas.width, canvas.height);\n        resolve(canvas.toDataURL());\n      } else {\n        var _ref, _ref2, _ref3;\n        // use bbox as boundary\n        let sx = 0;\n        let sy = 0;\n        let sw = imageCanvas.width;\n        let sh = imageCanvas.height;\n        if (((_ref = shape) === null || _ref === void 0 ? void 0 : _ref.halfWidth) !== undefined && ((_ref2 = shape) === null || _ref2 === void 0 ? void 0 : _ref2.halfHeight) !== undefined) {\n          const {\n            x,\n            y,\n            halfWidth,\n            halfHeight,\n            rotation = 0\n          } = shape;\n          const {\n            left,\n            top,\n            right,\n            bottom\n          } = getEllipseBounds(x, y, halfWidth, halfHeight, rotation);\n          sx = left * shapeScale.x;\n          sy = top * shapeScale.y;\n          sw = (right - left) * shapeScale.x;\n          sh = (bottom - top) * shapeScale.y;\n        } else if (((_ref3 = shape) === null || _ref3 === void 0 ? void 0 : _ref3.radius) !== undefined) {\n          const {\n            x,\n            y,\n            radius\n          } = shape;\n          sx = (x - radius) * shapeScale.x;\n          sy = (y - radius) * shapeScale.y;\n          sw = radius * 2 * shapeScale.x;\n          sh = radius * 2 * shapeScale.y;\n        }\n        canvas.width = (resizeTo === null || resizeTo === void 0 ? void 0 : resizeTo.width) || sw;\n        canvas.height = (resizeTo === null || resizeTo === void 0 ? void 0 : resizeTo.height) || sh;\n        ctx.drawImage(imageCanvas, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n        resolve(canvas.toDataURL());\n      }\n    };\n    if (pdfDocument && pdfPage !== undefined) {\n      pdfDocument.loadPage(pdfPage).then(data => drawSnapshot(data.canvas, data.width, data.height)).catch(() => reject());\n    } else {\n      imageLoader(imageUrl, data => {\n        const loadError = data instanceof Event && data.type === 'error';\n        if (loadError) {\n          reject();\n          return;\n        }\n        const c = data;\n        drawSnapshot(c, c.width, c.height);\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous'\n      });\n    }\n  });\n}\n\n/**\n * parse hotkeys config\n * @param hotkeysConfig\n */\nexport function parseHotkeysConfig(hotkeysConfig) {\n  const supportedAffectedTypes = ['point'];\n  const supportedTypes = ['overwrite', 'upsert'];\n  const supportedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n  const hotkeyMap = {};\n  if (hotkeysConfig && typeof hotkeysConfig === 'object') {\n    Object.keys(hotkeysConfig).forEach(affected => {\n      if (supportedAffectedTypes.includes(affected)) {\n        const items = hotkeysConfig[affected];\n        if (Array.isArray(items)) {\n          items.forEach(item => {\n            if (item && item.key && supportedKeys.includes(item.key)) {\n              const {\n                key,\n                type,\n                color,\n                shape,\n                attributes\n              } = item;\n              const hotkeyItem = {\n                key,\n                affected,\n                type,\n                color,\n                shape,\n                attributes\n              };\n              if (!supportedTypes.includes(type)) {\n                // eslint-disable-next-line prefer-destructuring\n                hotkeyItem.type = supportedTypes[0];\n              }\n              if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n                hotkeyItem.attributes = {};\n              }\n              if (!hotkeyMap[key]) {\n                hotkeyMap[key] = [];\n              }\n              hotkeyMap[key].push(hotkeyItem);\n            }\n          });\n        }\n      }\n    });\n  }\n  return hotkeyMap;\n}\n\n/**\n * get shape type by tool name\n * @param tool\n */\nexport function getShapeTypeByTool(tool) {\n  switch (tool) {\n    case Tool.RECTANGLE:\n    case Tool.FOUR_DOTS_RECTANGLE:\n    case Tool.CENTERLINE_RECTANGLE:\n    case Tool.OCR:\n      return ShapeType.RECTANGLE;\n    case Tool.SQUARE:\n      return ShapeType.SQUARE;\n    case Tool.POLYGON:\n    case Tool.OCR_POLYGON:\n    case Tool.FORMULA_POLYGON:\n    case Tool.RECOGNITION:\n      return ShapeType.POLYGON;\n    case Tool.PARALLELOGRAM:\n      return ShapeType.PARALLELOGRAM;\n    case Tool.ELLIPSE:\n      return ShapeType.ELLIPSE;\n    case Tool.CIRCLE:\n      return ShapeType.CIRCLE;\n    case Tool.CUBOID:\n      return ShapeType.CUBOID;\n    case Tool.LSHAPE:\n      return ShapeType.LSHAPE;\n    case Tool.QUAD_PRISM:\n      return ShapeType.QUAD_PRISM;\n    case Tool.ORIENTED_QUAD_PRISM:\n      return ShapeType.ORIENTED_QUAD_PRISM;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.CURVE:\n      return ShapeType.CURVE;\n    case Tool.CURVE_PAIR:\n      return ShapeType.CURVE_PAIR;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    case Tool.GRID:\n      return ShapeType.GRID;\n    case Tool.PIXEL:\n      return ShapeType.PIXEL;\n    case Tool.ARROW:\n      return ShapeType.ARROW;\n    case Tool.FLEX_LINE:\n      return ShapeType.FLEX_LINE;\n    case Tool.TWO_SIDES_CUBOID:\n      return ShapeType.TWO_SIDES_CUBOID;\n    case Tool.KEYPOINTS:\n      return ShapeType.KEYPOINTS;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * get tool type from frame data\n * @param shape\n */\nexport function getToolTypeFromFrameData(shape) {\n  switch (shape === null || shape === void 0 ? void 0 : shape.shapeType) {\n    case ShapeType.RECTANGLE:\n      if (shape.isOCR) {\n        return Tool.OCR;\n      }\n      if (shape.shape.center) {\n        return Tool.CENTERLINE_RECTANGLE;\n      }\n      return Tool.RECTANGLE;\n    case ShapeType.SQUARE:\n      return Tool.SQUARE;\n    case ShapeType.POLYGON:\n      if (shape.isOCR) {\n        return Tool.OCR_POLYGON;\n      }\n      if (shape.isFormula) {\n        return Tool.FORMULA_POLYGON;\n      }\n      return Tool.POLYGON;\n    case ShapeType.PARALLELOGRAM:\n      return Tool.PARALLELOGRAM;\n    case ShapeType.ELLIPSE:\n      return Tool.ELLIPSE;\n    case ShapeType.CIRCLE:\n      return Tool.CIRCLE;\n    case ShapeType.CUBOID:\n      return Tool.CUBOID;\n    case ShapeType.LSHAPE:\n      return Tool.LSHAPE;\n    case ShapeType.QUAD_PRISM:\n      return Tool.QUAD_PRISM;\n    case ShapeType.ORIENTED_QUAD_PRISM:\n      return Tool.ORIENTED_QUAD_PRISM;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.CURVE:\n      return Tool.CURVE;\n    case ShapeType.CURVE_PAIR:\n      return Tool.CURVE_PAIR;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    case ShapeType.GRID:\n      return Tool.GRID;\n    case ShapeType.ARROW:\n      return Tool.ARROW;\n    case ShapeType.FLEX_LINE:\n      return Tool.FLEX_LINE;\n    case ShapeType.TWO_SIDES_CUBOID:\n      return Tool.TWO_SIDES_CUBOID;\n    case ShapeType.PIXEL:\n      return Tool.PIXEL;\n    case ShapeType.KEYPOINTS:\n      return Tool.KEYPOINTS;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * check tools include tool\n * @param tool\n * @param tools\n */\nexport function includeSameTool(tool, tools) {\n  const checkTools = [...tools];\n  if (tools.includes(Tool.FOUR_DOTS_RECTANGLE)) {\n    // same shape type, no difference\n    checkTools.push(Tool.RECTANGLE);\n  }\n  if (tools.includes(Tool.RECOGNITION)) {\n    // same shape type, no difference\n    checkTools.push(Tool.POLYGON);\n  }\n  return checkTools.includes(tool);\n}\n\n/**\n * parse label config\n * @param labelConfigStr\n */\nexport function parseLabelConfig(labelConfigStr) {\n  if (labelConfigStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(labelConfigStr));\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\n/**\n * parse tool styles\n * @param item\n */\nexport function parseToolStyles(config) {\n  const styles = {};\n  if (typeof config.fill_color === 'string') {\n    styles.fillColor = config.fill_color;\n  }\n  if (typeof config.point_color === 'string') {\n    styles.pointColor = config.point_color;\n  }\n  if (typeof config.point_type === 'string') {\n    styles.pointType = config.point_type;\n  }\n  if (typeof config.edge_color === 'string') {\n    styles.edgeColor = config.edge_color;\n  }\n  if (typeof config.edge_type === 'string') {\n    styles.edgeType = config.edge_type;\n  }\n  if (typeof config.edge_bold === 'boolean') {\n    styles.edgeBold = config.edge_bold;\n  } else if (typeof config.edge_bold === 'string') {\n    styles.edgeBold = config.edge_bold === 'true';\n  }\n  if (Array.isArray(config.points_color) && config.points_color.length > 0) {\n    styles.pointsColor = [...config.points_color];\n  }\n  if (Array.isArray(config.points_type) && config.points_type.length > 0) {\n    styles.pointsType = [...config.points_type];\n  }\n  if (Array.isArray(config.edges_color) && config.edges_color.length > 0) {\n    styles.edgesColor = [...config.edges_color];\n  }\n  if (Array.isArray(config.edges_type) && config.edges_type.length > 0) {\n    styles.edgesType = [...config.edges_type];\n  }\n  if (Array.isArray(config.edges_bold) && config.edges_bold.length > 0) {\n    styles.edgesBold = config.edges_bold.map(i => i === true || i === 'true');\n  }\n  return styles;\n}\n\n/**\n * parse tool config\n * @param tool\n * @param config\n */\nexport function parseToolConfig(tool, config) {\n  if (tool === Tool.RECTANGLE) {\n    // parse for rectangle\n    const cfg = {};\n    const {\n      ratio,\n      auxiliary_lines\n    } = config || {};\n    if (typeof ratio === 'number' && ratio > 0) {\n      cfg.ratio = ratio;\n    }\n    if (Array.isArray(auxiliary_lines)) {\n      cfg.auxiliaryLines = [];\n      auxiliary_lines.forEach(({\n        type,\n        color,\n        value,\n        start,\n        end\n      }) => {\n        if ((type === 'vertical' || type === 'horizonal') && typeof color === 'string' && color && typeof value === 'number' && value >= 0 && value <= 1 && typeof start === 'number' && start >= 0 && start <= 1 && typeof end === 'number' && end >= 0 && end <= 1) {\n          cfg.auxiliaryLines.push({\n            type,\n            color,\n            value,\n            start,\n            end\n          });\n        }\n      });\n    }\n    return {\n      config: cfg\n    };\n  }\n  if (tool === Tool.ORIENTED_QUAD_PRISM) {\n    // parse for oriented quad prism\n    const cfg = {};\n    const {\n      displayIndexes,\n      upright\n    } = config || {};\n    if (Array.isArray(displayIndexes) && displayIndexes.length > 0) {\n      cfg.displayIndexes = [...displayIndexes];\n    }\n    if (upright !== undefined) {\n      cfg.upright = upright === 'true' || upright === true;\n    }\n    return {\n      config: cfg\n    };\n  }\n  if (tool === Tool.KEYPOINTS) {\n    // parse for keypoints\n    const cfg = {\n      groups: [],\n      lines: []\n    };\n    const {\n      groups,\n      lines\n    } = config || {};\n    if (Array.isArray(groups)) {\n      groups.forEach(group => {\n        const {\n          name,\n          range\n        } = group;\n        const rangeStart = range === null || range === void 0 ? void 0 : range[0];\n        const rangeEnd = range === null || range === void 0 ? void 0 : range[1];\n        if (name && typeof rangeStart === 'number' && typeof rangeEnd === 'number' && rangeEnd >= rangeStart) {\n          if (cfg.groups.every(g => g.range[0] > rangeEnd || g.range[1] < rangeStart)) {\n            // no overlap\n            cfg.groups.push({\n              name,\n              range: [rangeStart, rangeEnd]\n            });\n          }\n        }\n      });\n    }\n    if (Array.isArray(lines)) {\n      lines.forEach(line => {\n        const {\n          points,\n          color,\n          type\n        } = line;\n        if (Array.isArray(points) && points.length >= 2 && points.every(p => typeof p === 'number')) {\n          cfg.lines.push({\n            points: [...points],\n            color,\n            type\n          });\n        }\n      });\n    }\n    return {\n      config: cfg\n    };\n  }\n  return {};\n}\n\n/**\n * parse model config\n * @param config\n */\nexport function parseModelConfig(config) {\n  if (config && config[CVModel.TRAFFIC_SIGN] && Array.isArray(config[CVModel.TRAFFIC_SIGN])) {\n    const mappings = [];\n    config[CVModel.TRAFFIC_SIGN].forEach(mapping => {\n      const {\n        type,\n        field,\n        options\n      } = mapping;\n      if (Object.values(TrafficSignModelMappingType).includes(type) && field) {\n        const mOptions = [];\n        (options || []).forEach(o => {\n          const {\n            value,\n            data\n          } = o;\n          if (value !== undefined && value !== null && (data === null || data === void 0 ? void 0 : data.every(i => i.category && i.main_class && i.sub_class))) {\n            mOptions.push({\n              value,\n              data\n            });\n          }\n        });\n        mappings.push({\n          type,\n          field,\n          options: mOptions\n        });\n      }\n    });\n    if (mappings.length > 0) {\n      return {\n        modelConfig: {\n          [CVModel.TRAFFIC_SIGN]: mappings\n        }\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields, values) {\n  return fields.map(field => ({\n    ...field,\n    ...(values && values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n}\n\n/**\n * generate fields config\n * @param fields\n * @param attributes\n */\nexport function generateFieldsConfig(fields, attributes) {\n  let config = [];\n  const newFields = fields && fields.map(field => {\n    const tempField = {\n      ...field\n    };\n    if ((field === null || field === void 0 ? void 0 : field.type) === FieldControlType.RADIO) {\n      tempField.type = FieldControlType.SELECT;\n    }\n    if ((field === null || field === void 0 ? void 0 : field.type) === FieldControlType.CHECKBOX) {\n      tempField.type = FieldControlType.SELECT;\n      tempField.mode = Mode.MULTIPLE;\n    }\n    return tempField;\n  });\n  config = setInitialValues(newFields || [], attributes);\n  return config;\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config) {\n  const map = {};\n  ((config === null || config === void 0 ? void 0 : config.fields) || []).forEach(field => {\n    const {\n      name,\n      label,\n      type,\n      valueType,\n      options = []\n    } = field;\n    const newField = {\n      name,\n      type,\n      label\n    };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * Get the latest form property\n * @param config form config\n * @param values from values\n */\nexport const triggerForm = (config, values = {}) => {\n  const {\n    fields: configFields,\n    conditions = [],\n    effects = [],\n    rules = []\n  } = config;\n  const fields = (configFields || []).map(field => ({\n    ...field,\n    ...(values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n  const parsedValue = formUtils.parseFormFields(fields);\n  // trigger rule effects\n  const {\n    updatedValues: triggerValues,\n    updatedFields\n  } = rules.reduce((acc, curr) => formUtils.ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects), {\n    updatedFields: parsedValue.fields,\n    updatedValues: parsedValue.initialValues\n  });\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter(f => f.visible === false).forEach(f => {\n    delete updatedValues[f.name];\n  });\n  return {\n    updatedValues,\n    updatedFields\n  };\n};\n\n/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUpperShape(targetShape, shapes) {\n  let upperShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order > targetShape.order) {\n      // upper\n      if (!upperShape) {\n        upperShape = shape;\n      } else if (upperShape.order > shape.order) {\n        upperShape = shape;\n      }\n    }\n  }\n  return upperShape;\n}\n\n/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUnderShape(targetShape, shapes) {\n  let underShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order < targetShape.order) {\n      // under\n      if (!underShape) {\n        underShape = shape;\n      } else if (underShape.order < shape.order) {\n        underShape = shape;\n      }\n    }\n  }\n  return underShape;\n}\n\n/**\n * calculate shape area\n * @param shapeType\n * @param shapeData\n */\nexport function calcShapeArea(shapeType, shapeData) {\n  let area = NaN;\n  switch (shapeType) {\n    case ShapeType.POLYGON:\n      {\n        const {\n          points\n        } = shapeData;\n        const polygon = new Flatten.Polygon();\n        polygon.addFace(points.map(p => new Flatten.Point(p.x, p.y)));\n        area = polygon.faces.values().next().value.area();\n        break;\n      }\n    case ShapeType.RECTANGLE:\n    case ShapeType.SQUARE:\n      {\n        const {\n          width,\n          height\n        } = shapeData;\n        area = width * height;\n        break;\n      }\n    case ShapeType.ELLIPSE:\n      {\n        const {\n          halfWidth,\n          halfHeight\n        } = shapeData;\n        area = Math.PI * halfWidth * halfHeight;\n        break;\n      }\n    case ShapeType.CIRCLE:\n      {\n        const {\n          radius\n        } = shapeData;\n        area = Math.PI * radius ** 2;\n        break;\n      }\n    case ShapeType.PIXEL:\n      {\n        const {\n          data\n        } = shapeData;\n        const {\n          counts\n        } = data;\n        area = 0;\n        for (let i = 0; i < counts.length; i += 1) {\n          if (i % 2 === 1) {\n            area += counts[i];\n          }\n        }\n        break;\n      }\n    default:\n  }\n  return area;\n}\n\n/**\n * calculate shape bounds\n * @param shapeType\n * @param shapeData\n */\nexport function calcShapeBounds(shapeType, shapeData) {\n  switch (shapeType) {\n    case ShapeType.CIRCLE:\n      {\n        const {\n          x,\n          y,\n          radius\n        } = shapeData;\n        return {\n          left: x - radius,\n          top: y - radius,\n          right: x + radius,\n          bottom: y + radius\n        };\n      }\n    case ShapeType.ELLIPSE:\n      {\n        const {\n          x,\n          y,\n          halfWidth,\n          halfHeight\n        } = shapeData;\n        return {\n          left: x - halfWidth,\n          top: y - halfHeight,\n          right: x + halfWidth,\n          bottom: y + halfHeight\n        };\n      }\n    case ShapeType.LINE:\n    case ShapeType.ARROW:\n    case ShapeType.POLYGON:\n    case ShapeType.RECTANGLE:\n    case ShapeType.SQUARE:\n    case ShapeType.PARALLELOGRAM:\n    case ShapeType.QUAD_PRISM:\n    case ShapeType.ORIENTED_QUAD_PRISM:\n    case ShapeType.KEYPOINTS:\n      {\n        const {\n          points\n        } = shapeData;\n        const allX = points.map(p => p.x);\n        const allY = points.map(p => p.y);\n        return {\n          left: Math.min(...allX),\n          top: Math.min(...allY),\n          right: Math.max(...allX),\n          bottom: Math.max(...allY)\n        };\n      }\n    case ShapeType.CURVE:\n    case ShapeType.FLEX_LINE:\n      {\n        const {\n          points\n        } = shapeData;\n        const discretePoints = discretizeCurve(points);\n        const [p1, ...ps] = discretePoints;\n        let left = p1.x;\n        let right = p1.x;\n        let top = p1.y;\n        let bottom = p1.y;\n        for (let i = 0; i < ps.length; i += 1) {\n          const {\n            x,\n            y\n          } = ps[i];\n          if (x < left) {\n            left = x;\n          } else if (x > right) {\n            right = x;\n          }\n          if (y < top) {\n            top = y;\n          } else if (y > bottom) {\n            bottom = y;\n          }\n        }\n        return {\n          left,\n          top,\n          right,\n          bottom\n        };\n      }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID:\n      {\n        const {\n          front,\n          back\n        } = shapeData;\n        const fx1 = front.x;\n        const fy1 = front.y;\n        const fx2 = front.x + front.width;\n        const fy2 = front.y + front.height;\n        const bx1 = back.x;\n        const by1 = back.y;\n        const bx2 = back.x + back.width;\n        const by2 = back.y + back.height;\n        return {\n          left: Math.min(fx1, fx2, bx1, bx2),\n          top: Math.min(fy1, fy2, by1, by2),\n          right: Math.max(fx1, fx2, bx1, bx2),\n          bottom: Math.max(fy1, fy2, by1, by2)\n        };\n      }\n    case ShapeType.LSHAPE:\n      {\n        const {\n          front,\n          sidePoints\n        } = shapeData;\n        const fx1 = front.x;\n        const fy1 = front.y;\n        const fx2 = front.x + front.width;\n        const fy2 = front.y + front.height;\n        const sidePointsX = sidePoints.map(p => p.x);\n        const sidePointsY = sidePoints.map(p => p.y);\n        return {\n          left: Math.min(fx1, fx2, ...sidePointsX),\n          top: Math.min(fy1, fy2, ...sidePointsY),\n          right: Math.max(fx1, fx2, ...sidePointsX),\n          bottom: Math.max(fy1, fy2, ...sidePointsY)\n        };\n      }\n    case ShapeType.CURVE_PAIR:\n      {\n        const {\n          pairs\n        } = shapeData;\n        const line1 = [];\n        const line2 = [];\n        pairs.forEach(({\n          p1,\n          p2,\n          controls\n        }, i) => {\n          const nextPair = pairs[i + 1];\n          const {\n            control1 = undefined,\n            control2 = undefined\n          } = nextPair ? calcControlsForPairs({\n            p1,\n            p2,\n            controls\n          }, nextPair) : {};\n          line1.push({\n            ...p1,\n            ...(control1 && {\n              controls: [{\n                x: control1.x,\n                y: control1.y\n              }, {\n                x: control1.x,\n                y: control1.y\n              }]\n            })\n          });\n          line2.push({\n            ...p2,\n            ...(control2 && {\n              controls: [{\n                x: control2.x,\n                y: control2.y\n              }, {\n                x: control2.x,\n                y: control2.y\n              }]\n            })\n          });\n        });\n        const line1Points = discretizeCurve(line1);\n        const line2Points = discretizeCurve(line2);\n        const [p1, ...ps] = line1Points.concat(line2Points);\n        let left = p1.x;\n        let right = p1.x;\n        let top = p1.y;\n        let bottom = p1.y;\n        for (let i = 0; i < ps.length; i += 1) {\n          const {\n            x,\n            y\n          } = ps[i];\n          if (x < left) {\n            left = x;\n          } else if (x > right) {\n            right = x;\n          }\n          if (y < top) {\n            top = y;\n          } else if (y > bottom) {\n            bottom = y;\n          }\n        }\n        return {\n          left,\n          top,\n          right,\n          bottom\n        };\n      }\n    case ShapeType.DOT:\n      {\n        const {\n          x,\n          y\n        } = shapeData;\n        return {\n          left: x,\n          top: y,\n          right: x,\n          bottom: y\n        };\n      }\n    case ShapeType.GRID:\n      {\n        const {\n          cols,\n          rows\n        } = shapeData;\n        const allX = cols.map(c => c.x);\n        const allY = rows.map(r => r.y);\n        return {\n          left: Math.min(...allX),\n          top: Math.min(...allY),\n          right: Math.max(...allX),\n          bottom: Math.max(...allY)\n        };\n      }\n    case ShapeType.PIXEL:\n      {\n        var _left, _top, _right, _bottom;\n        const {\n          data\n        } = shapeData;\n        const {\n          counts,\n          size\n        } = data;\n        const height = size[0];\n        let left;\n        let top;\n        let right;\n        let bottom;\n        let decodedSize = 0;\n        for (let i = 0; i < counts.length; i += 1) {\n          const count = counts[i];\n          const flag = i % 2;\n          if (flag === 1) {\n            for (let j = decodedSize; j < decodedSize + count; j += 1) {\n              const x = Math.floor(j / height);\n              const y = j % height;\n              if (left === undefined) {\n                left = x;\n              } else if (x < left) {\n                left = x;\n              }\n              if (right === undefined) {\n                right = x;\n              } else if (x > right) {\n                right = x;\n              }\n              if (top === undefined) {\n                top = y;\n              } else if (y < top) {\n                top = y;\n              }\n              if (bottom === undefined) {\n                bottom = y;\n              } else if (y > bottom) {\n                bottom = y;\n              }\n            }\n          }\n          decodedSize += count;\n        }\n        return {\n          left: (_left = left) !== null && _left !== void 0 ? _left : 0,\n          top: (_top = top) !== null && _top !== void 0 ? _top : 0,\n          right: (_right = right) !== null && _right !== void 0 ? _right : 0,\n          bottom: (_bottom = bottom) !== null && _bottom !== void 0 ? _bottom : 0\n        };\n      }\n    default:\n      return undefined;\n  }\n}\n\n/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */\nexport function preciseShapeByType(shapeType, shapeData, precision) {\n  if (shapeType !== ShapeType.PIXEL) {\n    preciseData(shapeData, precision);\n  }\n}\n\n/**\n * precise data\n * @param data\n */\nexport function preciseData(data, precision) {\n  if (Number.isNaN(precision)) {\n    // no need to precise\n    return;\n  }\n  if (Array.isArray(data)) {\n    // array\n    data.forEach((item, i) => {\n      if (typeof item === 'number') {\n        data[i] = precise(item, precision);\n      } else {\n        preciseData(item, precision);\n      }\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    // object\n    const skipKeys = ['rotation',\n    // shape rotation\n    'area',\n    // shape area\n    'userData' // shape point user data\n    ];\n    const allKeys = Object.keys(data);\n    allKeys.forEach(key => {\n      if (skipKeys.includes(key)) {\n        return;\n      }\n      const keyData = data[key];\n      if (typeof keyData === 'number') {\n        data[key] = precise(keyData, precision);\n      } else {\n        preciseData(keyData, precision);\n      }\n    });\n  }\n}\n\n/**\n * check attributes pass condition\n * @param attributes\n * @param condition\n */\nexport function isAttributesPassCondition(attributes, condition) {\n  if (!attributes || !condition) {\n    return false;\n  }\n  return Object.keys(condition).every(key => {\n    var _ref4;\n    return (Array.isArray(condition[key]) ? condition[key].sort() : condition[key]).toString() === ((_ref4 = Array.isArray(attributes[key]) ? attributes[key].sort() : attributes[key]) === null || _ref4 === void 0 ? void 0 : _ref4.toString());\n  });\n}\n\n/**\n * ocr request limit\n */\nconst storagePrefixKey = 'video-tracking-v2-ocr';\nexport function checkOCRRequestCount(imageUrl, type = 'ocr') {\n  const data = JSON.parse(localStorage.getItem(storagePrefixKey) || '{}');\n  if (data[imageUrl]) {\n    // has config\n    const count = data[imageUrl][type];\n    if (count > 0) {\n      // count valid\n      const limits = {\n        ocr: 1000,\n        formula: 30,\n        formulaText: 20\n      };\n      return count < limits[type];\n    }\n  }\n  return true;\n}\nexport function updateOCRRequestCount(imageUrl, type = 'ocr') {\n  // saved storage\n  const data = JSON.parse(localStorage.getItem(storagePrefixKey) || '{}');\n  // new data to store\n  const newData = {};\n  // current time\n  const current = Date.now();\n  // one month duration\n  // const month = 30 * 24 * 60 * 60 * 1000;\n\n  Object.keys(data).forEach(key => {\n    const {\n      ocr,\n      formula,\n      formulaText,\n      lastModified\n    } = data[key];\n    if (ocr > 0 || formula > 0 || formulaText > 0) {\n      newData[key] = {\n        ocr: ocr > 0 ? ocr : 0,\n        formula: formula > 0 ? formula : 0,\n        formulaText: formulaText > 0 ? formulaText : 0,\n        lastModified\n      };\n    }\n  });\n  if (newData[imageUrl]) {\n    // already exits, update\n    newData[imageUrl][type] += 1;\n    newData[imageUrl].lastModified = current;\n  } else {\n    const allImageKeys = Object.keys(newData);\n    if (allImageKeys.length >= 200) {\n      // should remove oldest config\n      allImageKeys.sort((a, b) => newData[a].lastModified - newData[b].lastModified);\n      const oldest = allImageKeys[0];\n      delete newData[oldest];\n    }\n    // add\n    newData[imageUrl] = {\n      ocr: 0,\n      formula: 0,\n      formulaText: 0,\n      [type]: 1,\n      lastModified: current\n    };\n  }\n  localStorage.setItem(storagePrefixKey, JSON.stringify(newData));\n}\n\n/**\n * parse formula template by link\n * @param templateLink\n */\nexport function parseFormulaTemplate(templateLink) {\n  if (!templateLink) {\n    return Promise.resolve(null);\n  }\n  return new Promise(resolve => {\n    Papa.parse(templateLink, {\n      download: true,\n      complete: res => {\n        const {\n          data\n        } = res;\n        if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n          const header = data[0];\n          let categoryIndex = -1;\n          let nameIndex = -1;\n          let valueIndex = -1;\n          header.forEach((item, index) => {\n            const col = item.trim();\n            if (col === 'category') {\n              categoryIndex = index;\n            } else if (col === 'name') {\n              nameIndex = index;\n            } else if (col === 'value') {\n              valueIndex = index;\n            }\n          });\n          if (categoryIndex >= 0 && valueIndex >= 0) {\n            const template = {};\n            for (let i = 1; i < data.length; i += 1) {\n              const item = data[i];\n              const category = item[categoryIndex];\n              const name = item[nameIndex];\n              const value = item[valueIndex];\n              if (category) {\n                // has category\n                if (!template.categories) {\n                  template.categories = {};\n                }\n                if (!template.categories[category]) {\n                  template.categories[category] = [];\n                }\n                template.categories[category].push({\n                  name,\n                  value\n                });\n              } else {\n                // no category, add to global\n                if (!template.global) {\n                  template.global = [];\n                }\n                template.global.push({\n                  name,\n                  value\n                });\n              }\n            }\n            resolve(template);\n            return;\n          }\n        }\n        resolve(null);\n      },\n      error: () => {\n        resolve(null);\n      }\n    });\n  });\n}\nexport function getAttributesByModelData(modelData, type, config) {\n  if (config) {\n    const attrs = {};\n    for (let i = 0; i < config.length; i += 1) {\n      if (config[i].type === type) {\n        const {\n          field,\n          options\n        } = config[i];\n        const fitOption = options.find(o => o.data.some(d => d.category === modelData.category && d.main_class === modelData.main_class && d.sub_class === modelData.sub_class));\n        if (fitOption) {\n          attrs[field] = fitOption.value;\n        }\n      }\n    }\n    return attrs;\n  }\n  return {\n    category: modelData.category,\n    [modelData.category]: modelData.main_class,\n    [modelData.main_class]: modelData.sub_class\n  };\n}\nexport const isContained = (value, options) => {\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const valueItem = value[index];\n      if (!isContained(valueItem, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return !!(options === null || options === void 0 ? void 0 : options.find(i => i.value === value));\n};\n\n/**\n * options contained value for nested structures\n * @param values\n * @param options\n */\nexport function isContainedForNested(values = [], options) {\n  const result = values.reduce((preVal, currVal) => {\n    var _preVal$options;\n    if (!preVal.isContained || !preVal.options || preVal.options.length < 1) {\n      return preVal;\n    }\n    const option = (_preVal$options = preVal.options) === null || _preVal$options === void 0 ? void 0 : _preVal$options.find(o => o.value === currVal);\n    if (option) {\n      preVal.isContained = true;\n      if (option.children && option.children.length > 0) {\n        preVal.options = option.children;\n      }\n    } else {\n      preVal.isContained = false;\n    }\n    return preVal;\n  }, {\n    options,\n    isContained: true\n  });\n  return result.isContained;\n}\n\n/**\n * update attributes by fields compare\n * @param sourceFields\n * @param destinationFields\n * @param sourceAttributes\n * @param initialValues\n */\nexport const updateAttributesByFieldsCompare = (sourceFields, destinationFields, sourceAttributes = {}, initialValues = {}) => {\n  const sourceFieldsMap = Object.fromEntries(sourceFields.map(item => [item.name, item]));\n  const destinationFieldsMap = Object.fromEntries(destinationFields.map(item => [item.name, item]));\n  const newInitialValues = {\n    ...initialValues\n  };\n  Object.keys(destinationFieldsMap).forEach(item => {\n    if (sourceFieldsMap[item] && destinationFieldsMap[item].type === sourceFieldsMap[item].type && destinationFieldsMap[item].valueType === sourceFieldsMap[item].valueType) {\n      if (destinationFieldsMap[item].options && sourceFieldsMap[item].options) {\n        const isContain = destinationFieldsMap[item].type === FieldControlType.CASCADER ? isContainedForNested(sourceAttributes[item], destinationFieldsMap[item].options || []) : isContained(sourceAttributes[item], destinationFieldsMap[item].options || []);\n        if (isContain) {\n          newInitialValues[item] = sourceAttributes[item];\n        }\n      } else {\n        newInitialValues[item] = sourceAttributes[item];\n      }\n    }\n  });\n  return newInitialValues;\n};\n\n/**\n * check dynamic attributes\n * @param instance\n * @param dynamicInstanceConfig\n */\nexport const checkDynamicAttributes = (instance, dynamicInstanceConfig) => {\n  if (!dynamicInstanceConfig) {\n    return false;\n  }\n  let failed = false;\n  for (let i = 0; i < instance.children.length; i += 1) {\n    if (failed) {\n      break;\n    }\n    const {\n      cameras\n    } = instance.children[i];\n    for (let j = 0; j < cameras.length; j += 1) {\n      var _instance$dynamicAttr;\n      if (failed) {\n        break;\n      }\n      const {\n        camera,\n        frames\n      } = cameras[j];\n      const dynamicAttributes = (_instance$dynamicAttr = instance.dynamicAttributes) === null || _instance$dynamicAttr === void 0 ? void 0 : _instance$dynamicAttr.find(attr => attr.camera === camera);\n      for (let k = 0; k < frames.length; k += 1) {\n        const {\n          frameIndex\n        } = frames[k];\n        const {\n          attributes\n        } = (dynamicAttributes === null || dynamicAttributes === void 0 ? void 0 : dynamicAttributes.frames.find(f => f.frameIndex === frameIndex)) || {};\n        if (!formUtils.validate(dynamicInstanceConfig, attributes || {}, {\n          check: true\n        })) {\n          failed = true;\n          break;\n        }\n      }\n    }\n  }\n  return failed;\n};\nexport function minifyShapeData(shapeType, shapeData) {\n  // FIXME: temp reduce saved file size\n  if (shapeType === ShapeType.PIXEL) {\n    shapeData.polygons = [];\n  }\n  return shapeData;\n}\nexport function isShapeDataMinified(shapeType, shapeData) {\n  if (shapeType === ShapeType.PIXEL) {\n    const {\n      polygons\n    } = shapeData;\n    return !polygons || polygons.length === 0;\n  }\n  return false;\n}\nexport function isCategoryChangeAllowed(mode) {\n  const category = mode === null || mode === void 0 ? void 0 : mode[1];\n  return category !== '0';\n}\nexport function isNumberChangeAllowed(mode) {\n  const number = mode === null || mode === void 0 ? void 0 : mode[3];\n  if (number !== undefined) {\n    return number !== '0';\n  }\n  return isCategoryChangeAllowed(mode);\n}\nexport function isMatrixChangeAllowed(mode) {\n  const matrix = mode === null || mode === void 0 ? void 0 : mode[0];\n  return matrix !== '0';\n}\nexport function isDeleteAllowed(mode) {\n  const del = mode === null || mode === void 0 ? void 0 : mode[4];\n  if (del !== undefined) {\n    return del !== '0';\n  }\n  return isMatrixChangeAllowed(mode);\n}\nexport function isAttrChangeAllowed(mode) {\n  const attr = mode === null || mode === void 0 ? void 0 : mode[2];\n  return attr !== '0';\n}\nexport function parseCategoryHotkey(shortcut) {\n  if (shortcut) {\n    // TODO: current only single alphabet is supported\n    if (/^[a-zA-Z]$/.test(shortcut)) {\n      const categoryHotkey = {\n        key: shortcut.toLowerCase(),\n        shiftKey: false,\n        ctrlKey: false,\n        altKey: false\n      };\n      return categoryHotkey;\n    }\n  }\n  return undefined;\n}\nfunction getExtension(url) {\n  if (!url) {\n    return '';\n  }\n  try {\n    const u = new URL(url);\n    const filename = u.pathname.split('/').pop();\n    const extension = filename === null || filename === void 0 ? void 0 : filename.split('.').slice(1).join('.');\n    return extension !== null && extension !== void 0 ? extension : '';\n  } catch (e) {\n    // parse error\n  }\n  return '';\n}\nexport function isPDFUrl(url) {\n  const extension = getExtension(url);\n  return ['pdf'].includes(extension === null || extension === void 0 ? void 0 : extension.toLowerCase());\n}\nexport function isVideoUrl(url) {\n  const extension = getExtension(url);\n  return ['mp4', 'webm', 'mov'].includes(extension === null || extension === void 0 ? void 0 : extension.toLowerCase());\n}\nexport function isNIFTIUrl(url) {\n  const extension = getExtension(url);\n  return ['nii', 'nii.gz'].includes(extension === null || extension === void 0 ? void 0 : extension.toLowerCase());\n}","map":{"version":3,"names":["Base64","Flatten","imageLoader","Papa","utils","formUtils","FieldControlType","Mode","Tool","CVModel","TrafficSignModelMappingType","DEFAULT_CAMERA_NAME","DEFAULT_FRAME_IMAGE_NAME","fetchResultByUrl","computeRotatedPosition","getEllipseBounds","precise","calcControlsForPairs","discretizeCurve","ShapeType","parseFrames","frames","split","map","f","trim","Array","isArray","urls","reduce","acc","curr","i","url","name","parseFramesFromCamera","cameras","length","every","c","camera","allCameras","images","data","calibrations","embeddings","maxFrameCount","Math","max","forEach","concat","from","parseFramesFromFrames","defaultCamera","parseFramesFromMain","main","image","parseFramesByPaylod","base_url","rootStore","niftiUrl","getNIFTIUrl","dicomDirUrl","getDicomDirUrl","parseFromFrames","res","JSON","parse","e","parseFromMainResult","config","setNeedThumbnailLayer","thumbnail","setThumbnails","parseFromCameraResult","parseFromFramesResult","frameList","frameUrl","isNIFTIUrl","endsWith","loadInstancesFromResult","result","instances","formatFrames","ranges","currMin","currMax","push","predictShapeData","currentFrame","precision","bounds","prevKeyFrameIndexes","getLastKeyFrames","nextKeyFrameIndexes","getNextKeyFrames","startFrame","endFrame","shapeType","getShapeFromFrames","shape","checkShapeInBounds","count","keyFrameIndexes","minFrame","min","Object","values","frameIndex","isKeyFrame","maxFrame","baseFrame","frameShapeType","shapeInfo","filter","some","startShape","endShape","baseShape","frameScale","RECTANGLE","SQUARE","calculate","x","startX","width","startW","center","startCenter","endX","endW","endCenter","baseX","baseW","baseCenter","undefined","startCenterScale","endCenterScale","baseCenterScale","centerScale","right","bottom","y","height","points","rotation","p","point","ELLIPSE","CIRCLE","CUBOID","TWO_SIDES_CUBOID","front","startFront","back","startBack","startPoints","endFront","endBack","endPoints","baseFront","baseBack","basePoints","startClockwise","endClockwise","baseClockwise","LSHAPE","sidePoints","startSidePoints","endSidePoints","baseSidePoints","_","index","DOT","shapeBounds","calcShapeBounds","area","calcShapeArea","Number","isNaN","start","end","base","scale","calculatedObject","keys","key","PIXEL","left","top","getSnapshot","imageUrl","imageRotation","pdfDocument","pdfPage","resizeTo","Promise","resolve","reject","canvas","document","createElement","ctx","getContext","imageCanvas","imageCtx","drawSnapshot","imageWidth","imageHeight","PI","translate","rotate","drawImage","shapeScale","s","minX","minY","maxX","maxY","xScale","yScale","moveTo","lineTo","clip","toDataURL","_ref","_ref2","_ref3","sx","sy","sw","sh","halfWidth","halfHeight","radius","loadPage","then","catch","loadError","Event","type","orientation","crossOrigin","parseHotkeysConfig","hotkeysConfig","supportedAffectedTypes","supportedTypes","supportedKeys","hotkeyMap","affected","includes","items","item","color","attributes","hotkeyItem","getShapeTypeByTool","tool","FOUR_DOTS_RECTANGLE","CENTERLINE_RECTANGLE","OCR","POLYGON","OCR_POLYGON","FORMULA_POLYGON","RECOGNITION","PARALLELOGRAM","QUAD_PRISM","ORIENTED_QUAD_PRISM","LINE","CURVE","CURVE_PAIR","GRID","ARROW","FLEX_LINE","KEYPOINTS","getToolTypeFromFrameData","isOCR","isFormula","includeSameTool","tools","checkTools","parseLabelConfig","labelConfigStr","labelConfig","decode","parseToolStyles","styles","fill_color","fillColor","point_color","pointColor","point_type","pointType","edge_color","edgeColor","edge_type","edgeType","edge_bold","edgeBold","points_color","pointsColor","points_type","pointsType","edges_color","edgesColor","edges_type","edgesType","edges_bold","edgesBold","parseToolConfig","cfg","ratio","auxiliary_lines","auxiliaryLines","value","displayIndexes","upright","groups","lines","group","range","rangeStart","rangeEnd","g","line","parseModelConfig","TRAFFIC_SIGN","mappings","mapping","field","options","mOptions","o","category","main_class","sub_class","modelConfig","setInitialValues","fields","defaultValue","generateFieldsConfig","newFields","tempField","RADIO","SELECT","CHECKBOX","mode","MULTIPLE","parseFields","label","valueType","newField","CASCADER","parseOptions","triggerForm","configFields","conditions","effects","rules","parsedValue","parseFormFields","updatedValues","triggerValues","updatedFields","ruleTrigger","initialValues","visible","getUpperShape","targetShape","shapes","upperShape","order","getUnderShape","underShape","shapeData","NaN","polygon","Polygon","addFace","Point","faces","next","counts","allX","allY","discretePoints","p1","ps","fx1","fy1","fx2","fy2","bx1","by1","bx2","by2","sidePointsX","sidePointsY","pairs","line1","line2","p2","controls","nextPair","control1","control2","line1Points","line2Points","cols","rows","r","_left","_top","_right","_bottom","size","decodedSize","flag","j","floor","preciseShapeByType","preciseData","skipKeys","allKeys","keyData","isAttributesPassCondition","condition","_ref4","sort","toString","storagePrefixKey","checkOCRRequestCount","localStorage","getItem","limits","ocr","formula","formulaText","updateOCRRequestCount","newData","current","Date","now","lastModified","allImageKeys","a","b","oldest","setItem","stringify","parseFormulaTemplate","templateLink","download","complete","header","categoryIndex","nameIndex","valueIndex","col","template","categories","global","error","getAttributesByModelData","modelData","attrs","fitOption","find","d","isContained","valueItem","isContainedForNested","preVal","currVal","_preVal$options","option","children","updateAttributesByFieldsCompare","sourceFields","destinationFields","sourceAttributes","sourceFieldsMap","fromEntries","destinationFieldsMap","newInitialValues","isContain","checkDynamicAttributes","instance","dynamicInstanceConfig","failed","_instance$dynamicAttr","dynamicAttributes","attr","k","validate","check","minifyShapeData","polygons","isShapeDataMinified","isCategoryChangeAllowed","isNumberChangeAllowed","number","isMatrixChangeAllowed","matrix","isDeleteAllowed","del","isAttrChangeAllowed","parseCategoryHotkey","shortcut","test","categoryHotkey","toLowerCase","shiftKey","ctrlKey","altKey","getExtension","u","URL","filename","pathname","pop","extension","slice","join","isPDFUrl","isVideoUrl"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/utils.ts"],"sourcesContent":["import { Base64 } from 'js-base64';\nimport Flatten from '@flatten-js/core';\nimport imageLoader from 'blueimp-load-image';\nimport Papa from 'papaparse';\nimport { utils as formUtils } from '@appen-china/easy-form';\nimport { Field, FieldControlType, FieldValue, FormConfig, Mode, FieldOption } from '@appen-china/easy-form/es/types';\nimport { Instance, FrameData, HotkeyItem, Tool, LabelConfig, FieldConfig, Styles, ToolStyles, FormulaTemplate, ToolConfig, OrientedQuadPrismToolConfig, CVModel, TrafficSignModelConfig, TrafficSignModelMappingType, TrafficSignModelMapping, TrafficSignModelData, RectangleConfig, Payload, Camera, EditMode, CategoryHotkey, KeypointsConfig } from './types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_FRAME_IMAGE_NAME } from './constants';\nimport { fetchResultByUrl } from '../../utils';\nimport { computeRotatedPosition, getEllipseBounds, precise } from '../../utils/math';\nimport { CurvePoint, calcControlsForPairs, discretizeCurve } from '../../utils/bezier';\nimport { ShapeData, ShapeDataWithArea, ShapeType } from '../common/shapes/types';\nimport type Shape from '../common/shapes/Shape';\nimport { RectangleData } from '../common/shapes/Rectangle';\nimport { PolygonData } from '../common/shapes/Polygon';\nimport { ParallelogramData } from '../common/shapes/Parallelogram';\nimport { EllipseData } from '../common/shapes/Ellipse';\nimport { CircleData } from '../common/shapes/Circle';\nimport { CuboidData } from '../common/shapes/Cuboid';\nimport { LShapeData } from '../common/shapes/LShape';\nimport { QuadPrismData } from '../common/shapes/QuadPrism';\nimport { LineData } from '../common/shapes/Line';\nimport { CurveData } from '../common/shapes/Curve';\nimport { CurvePairData } from '../common/shapes/CurvePair';\nimport { DotData } from '../common/shapes/Dot';\nimport { GridData } from '../common/shapes/Grid';\nimport { PixelData } from '../common/shapes/Pixel';\nimport { KeypointsData } from '../common/shapes/Keypoints';\nimport { OrientedQuadPrismData } from '../common/shapes/OrientedQuadPrism';\nimport RootStore from './store/RootStore';\nimport PDFDocument from '../../libs/pdf/PDFDocument';\n\n/**\n * parse frames\n * @param frames\n */\nexport function parseFrames(frames: unknown): Record<string, string>[] {\n  if (typeof frames === 'string') {\n    // eg. 'https://1.jpg,https://2.jpg,...'\n    return frames.split(',').map((f) => ({\n      [DEFAULT_FRAME_IMAGE_NAME]: f.trim(),\n    }));\n  }\n\n  if (Array.isArray(frames)) {\n    return frames.map((f) => {\n      if (typeof f === 'string') {\n        // eg.\n        // [\n        //   'https://1.jpg',\n        //   'https://2.jpg',\n        //   ...\n        // ]\n        // or\n        // [\n        //   'https://11.jpg,https://12.jpg,...',\n        //   'https://21.jpg,https://22.jpg,...',\n        //   ...\n        // ]\n        const urls = f.split(',');\n        return urls.reduce((acc, curr, i) => ({\n          ...acc,\n          [`${DEFAULT_FRAME_IMAGE_NAME}${i === 0 ? '' : `_${i}`}`]: curr.trim(),\n        }), {});\n      }\n\n      if (Array.isArray(f)) {\n        // eg.\n        // [\n        //   ['https://11.jpg', 'https://12.jpg', ...],\n        //   ['https://21.jpg', 'https://22.jpg', ...],\n        //   ...\n        // ]\n        // or\n        // [\n        //   [{ url: 'https://11.jpg', name: 'img1' }, { url: 'https://12.jpg', name: 'img2' }, ...],\n        //   [{ url: 'https://21.jpg', name: 'img1' }, { url: 'https://22.jpg', name: 'img2' }, ...],\n        //   ...\n        // ]\n        return f.reduce((acc, curr, i) => {\n          const url = typeof curr === 'string' ? curr : (curr.url || '');\n          const name = curr.name || `${DEFAULT_FRAME_IMAGE_NAME}${i === 0 ? '' : `_${i}`}`;\n          return {\n            ...acc,\n            [name]: url.trim(),\n          };\n        }, {});\n      }\n\n      // default empty frame\n      return {\n        [DEFAULT_FRAME_IMAGE_NAME]: '',\n      };\n    });\n  }\n\n  return [];\n}\n\n/**\n * parse frames config from cameras\n * @param cameras\n */\nfunction parseFramesFromCamera(cameras: unknown): Camera[] | null {\n  if (Array.isArray(cameras) && cameras.length > 0\n    && cameras.every((c) => c && c.camera && (typeof c.frames === 'string' || Array.isArray(c.frames)))) {\n    const allCameras = cameras.map((c) => ({\n      camera: `${c.camera}`,\n      images: parseFrames(c.frames),\n      data: c.data,\n      calibrations: c.calibrations,\n      ...(typeof c.embeddings === 'string' || Array.isArray(c.embeddings)) && {\n        embeddings: parseFrames(c.embeddings),\n      },\n    }));\n    const maxFrameCount = Math.max(...allCameras.map((c) => c.images.length));\n    allCameras.forEach((c) => {\n      if (c.images.length < maxFrameCount) {\n        c.images = c.images.concat(\n          Array.from({ length: maxFrameCount - c.images.length }).map(() => ({\n            [DEFAULT_FRAME_IMAGE_NAME]: '',\n          })),\n        );\n      }\n    });\n    return allCameras;\n  }\n  return null;\n}\n\n/**\n * parse frames config from frames\n * @param frames\n * @param embeddings\n */\nfunction parseFramesFromFrames(frames: unknown, embeddings: unknown): Camera[] | null {\n  if ((typeof frames === 'string' && frames) || Array.isArray(frames)) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      images: parseFrames(frames),\n      ...(typeof embeddings === 'string' || Array.isArray(embeddings)) && {\n        embeddings: parseFrames(embeddings),\n      },\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames config from main\n * @param frames\n */\nfunction parseFramesFromMain(main: {image: string}) {\n  if (main && main.image) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      images: parseFrames([main.image]),\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames from payload\n * @param payload\n */\nexport async function parseFramesByPaylod({ frames, embeddings, base_url }: {\n  frames?: Payload['frames'];\n  embeddings?: Payload['embeddings'];\n  base_url?: Payload['base_url'];\n}, rootStore?: typeof RootStore): Promise<{ cameras?: Camera[]; niftiUrl?: string; dicomDirUrl?: string }> {\n  const niftiUrl = getNIFTIUrl({ frames, base_url });\n  if (niftiUrl) {\n    return {\n      niftiUrl,\n    };\n  }\n\n  const dicomDirUrl = getDicomDirUrl({ frames, base_url });\n  if (dicomDirUrl) {\n    return {\n      dicomDirUrl,\n    };\n  }\n\n  const parseFromFrames = parseFramesFromFrames(frames, embeddings);\n  if (parseFromFrames !== null) {\n    return {\n      cameras: parseFromFrames,\n    };\n  }\n\n  if (base_url) {\n    let res;\n    try {\n      res = JSON.parse(base_url);\n    } catch (e) {\n      // parse error\n    }\n    if (!res) {\n      try {\n        res = await fetchResultByUrl(base_url);\n      } catch (e) {\n        // fetch error\n      }\n    }\n    if (res) {\n      if (res.main) {\n        const parseFromMainResult = parseFramesFromMain(res.main);\n        if (parseFromMainResult !== null) {\n          if (res.frames && rootStore) {\n            rootStore.config.setNeedThumbnailLayer(true);\n            rootStore.thumbnail.setThumbnails(res.frames);\n          }\n          return {\n            cameras: parseFromMainResult,\n          };\n        }\n      }\n      const parseFromCameraResult = parseFramesFromCamera(res.cameras);\n      if (parseFromCameraResult !== null) {\n        return {\n          cameras: parseFromCameraResult,\n        };\n      }\n      const parseFromFramesResult = parseFramesFromFrames(res.frames, res.embeddings);\n      if (parseFromFramesResult !== null) {\n        return {\n          cameras: parseFromFramesResult,\n        };\n      }\n    }\n  }\n  return {\n    cameras: [{\n      camera: DEFAULT_CAMERA_NAME,\n      images: [],\n    }],\n  };\n}\n\nfunction getNIFTIUrl({ frames }: {\n  frames?: Payload['frames'];\n  base_url?: Payload['base_url'];\n}) {\n  if (typeof frames === 'string') {\n    const frameList = frames.split(',');\n    if (frameList.length === 1) {\n      // 当前仅支持单个nifti文件\n      const frameUrl = frameList[0].trim();\n      if (isNIFTIUrl(frameUrl)) {\n        return frameUrl;\n      }\n    }\n  }\n  return '';\n}\n\nfunction getDicomDirUrl({ frames }: {\n  frames?: Payload['frames'];\n  base_url?: Payload['base_url'];\n}) {\n  if (typeof frames === 'string' && frames?.endsWith('DICOMDIR')) {\n    // FIXME: 可能需要支持更复杂的结构\n    return frames;\n  }\n  return '';\n}\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result: any) {\n  const instances: Instance[] = [];\n\n  if (result && result.instances && Array.isArray(result.instances)) {\n    // legacy data no longer supported\n\n    // result.instances.forEach((instance: any) => {\n    //   if (instance.frames) {\n    //     // legacy data\n    //     const defaultCamera: CameraData = {\n    //       camera: DEFAULT_CAMERA_NAME,\n    //       frames: instance.frames,\n    //     };\n    //     const defaultItem: InstanceItem = {\n    //       id: uuidv4(),\n    //       name: DEFAULT_CATEGORY_ITEM,\n    //       number: 1,\n    //       cameras: [defaultCamera],\n    //     };\n    //     const newInstance: Instance = {\n    //       id: instance.id,\n    //       category: instance.category,\n    //       number: instance.number,\n    //       children: [defaultItem],\n    //     };\n    //     instances.push(newInstance);\n    //     // TODO: fix string points attribute for rectangle\n    //   } else {\n    //     instances.push(instance);\n    //   }\n    // });\n\n    return result.instances;\n  }\n\n  return instances;\n}\n\n/**\n * format frames as string\n * @param frames\n */\nexport function formatFrames(frames: number[]) {\n  if (frames.length === 1) {\n    return frames[0] + 1;\n  }\n\n  const ranges = [];\n  if (frames.length > 1) {\n    let currMin = frames[0];\n    let currMax = frames[0];\n    let i = 1;\n    while (i < frames.length) {\n      if (frames[i] - frames[i - 1] > 1) {\n        currMax = frames[i - 1];\n        ranges.push([currMin, currMax]);\n        currMin = frames[i];\n        currMax = frames[i];\n      }\n      i += 1;\n    }\n    currMax = frames[frames.length - 1];\n    ranges.push([currMin, currMax]);\n  }\n\n  return ranges.reduce((acc, curr) => `${acc ? `${acc}, ` : ''}${curr[0] === curr[1] ? (curr[0] + 1) : `${curr[0] + 1}-${curr[1] + 1}`}`, '');\n}\n\n/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */\nexport function predictShapeData(\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n  precision: number,\n  bounds?: { top: number; right: number; bottom: number; left: number },\n) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame, precision);\n    }\n  }\n\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n      return { shapeType, shape };\n    }\n  }\n\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const { shapeType, shape } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame, precision);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return { shapeType, shape };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n    return { shapeType, shape };\n  }\n\n  return null;\n}\n\n/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getLastKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map((f) => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getNextKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map((f) => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */\nexport function getShapeFromFrames(\n  frames: {[frameIndex: number]: FrameData},\n  startFrame: number,\n  endFrame: number,\n  baseFrame: number,\n  currentFrame: number,\n  precision: number,\n) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape,\n  };\n\n  if (Object.values(frames).filter((f) => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some((f) => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE:\n    case ShapeType.SQUARE: {\n      const shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      ) as unknown as RectangleData;\n      const { x: startX, width: startW, center: startCenter } = startShape as RectangleData;\n      const { x: endX, width: endW, center: endCenter } = endShape as RectangleData;\n      const { x: baseX, width: baseW, center: baseCenter } = baseShape as RectangleData;\n      let center;\n      if (startCenter !== undefined && endCenter !== undefined && baseCenter !== undefined) {\n        const startCenterScale = (startCenter - startX) / startW;\n        const endCenterScale = (endCenter - endX) / endW;\n        const baseCenterScale = (baseCenter - baseX) / baseW;\n        const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n        center = precise(Math.min(Math.max(centerScale * shape.width + shape.x, shape.x), shape.x + shape.width), precision);\n      }\n      const right = precise(shape.x + shape.width, precision);\n      const bottom = precise(shape.y + shape.height, precision);\n      const points = [\n        { x: shape.x, y: shape.y },\n        { x: right, y: shape.y },\n        { x: right, y: bottom },\n        { x: shape.x, y: bottom },\n      ];\n      if (shape.rotation) {\n        points.forEach((p) => {\n          const point = computeRotatedPosition({ x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }, p, shape.rotation as number);\n          p.x = precise(point.x, precision);\n          p.y = precise(point.y, precision);\n        });\n      }\n\n      shape.points = points;\n      shapeInfo.shape = { ...shape, center };\n      break;\n    }\n    case ShapeType.ELLIPSE: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      ) as unknown as EllipseData;\n      break;\n    }\n    case ShapeType.CIRCLE: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      ) as unknown as CircleData;\n      break;\n    }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID: {\n      const { front: startFront, back: startBack, points: startPoints, } = startShape as CuboidData;\n      const { front: endFront, back: endBack, points: endPoints } = endShape as CuboidData;\n      const { front: baseFront, back: baseBack, points: basePoints } = baseShape as CuboidData;\n      const front = calculate(\n        startFront as unknown as { [key: string]: number; },\n        endFront as unknown as { [key: string]: number; },\n        baseFront as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      ) as unknown as CuboidData['front'];\n      const back = calculate(\n        startBack as unknown as { [key: string]: number; },\n        endBack as unknown as { [key: string]: number; },\n        baseBack as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      ) as unknown as CuboidData['back'];\n      shapeInfo.shape = { front, back };\n      if (startPoints && endPoints && basePoints) {\n        const startClockwise = startPoints[0].x < startPoints[1].x;\n        const endClockwise = endPoints[0].x < endPoints[1].x;\n        const baseClockwise = basePoints[0].x < basePoints[1].x;\n        if (startClockwise === endClockwise && startClockwise === baseClockwise) {\n          // same direction\n          shapeInfo.shape.points = startClockwise ? [\n            { x: front.x, y: front.y },\n            { x: precise(front.x + front.width, precision), y: front.y },\n            { x: precise(front.x + front.width, precision), y: precise(front.y + front.height, precision) },\n            { x: front.x, y: precise(front.y + front.height, precision) },\n            { x: back.x, y: back.y },\n            { x: precise(back.x + back.width, precision), y: back.y },\n            { x: precise(back.x + back.width, precision), y: precise(back.y + back.height, precision) },\n            { x: back.x, y: precise(back.y + back.height, precision) },\n          ] : [\n            { x: precise(front.x + front.width, precision), y: front.y },\n            { x: front.x, y: front.y },\n            { x: front.x, y: precise(front.y + front.height, precision) },\n            { x: precise(front.x + front.width, precision), y: precise(front.y + front.height, precision) },\n            { x: precise(back.x + back.width, precision), y: back.y },\n            { x: back.x, y: back.y },\n            { x: back.x, y: precise(back.y + back.height, precision) },\n            { x: precise(back.x + back.width, precision), y: precise(back.y + back.height, precision) },\n          ];\n        }\n      }\n      break;\n    }\n    case ShapeType.LSHAPE: {\n      const { front: startFront, sidePoints: startSidePoints, center: startCenter } = startShape as LShapeData;\n      const { front: endFront, sidePoints: endSidePoints, center: endCenter } = endShape as LShapeData;\n      const { front: baseFront, sidePoints: baseSidePoints, center: baseCenter } = baseShape as LShapeData;\n      const front = calculate(\n        startFront as unknown as { [key: string]: number; },\n        endFront as unknown as { [key: string]: number; },\n        baseFront as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      ) as unknown as LShapeData['front'];\n      const sidePoints = startSidePoints.map((_, index) => calculate(\n        startSidePoints[index] as unknown as { [key: string]: number; },\n        endSidePoints[index] as unknown as { [key: string]: number; },\n        baseSidePoints[index] as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      )) as unknown as LShapeData['sidePoints'];\n      const startCenterScale = (startCenter - startFront.x) / startFront.width;\n      const endCenterScale = (endCenter - endFront.x) / endFront.width;\n      const baseCenterScale = (baseCenter - baseFront.x) / baseFront.width;\n      const centerScale = baseCenterScale + (endCenterScale - startCenterScale) * frameScale;\n      const center = precise(Math.min(Math.max(centerScale * front.width + front.x, front.x), front.x + front.width), precision);\n      shapeInfo.shape = { front, sidePoints, center };\n      break;\n    }\n    case ShapeType.DOT: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n        precision,\n      ) as unknown as EllipseData;\n      break;\n    }\n    default:\n  }\n\n  // recalc shape bounds\n  if (baseShape.shapeBounds) {\n    shapeInfo.shape.shapeBounds = calcShapeBounds(shapeInfo.shapeType, shapeInfo.shape);\n  }\n  // recalc shape area\n  const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n  if (!Number.isNaN(area)) {\n    (shapeInfo.shape as ShapeDataWithArea).area = area;\n  }\n\n  return shapeInfo;\n}\n\n/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */\nfunction calculate(\n  start: {[key: string]: number},\n  end: {[key: string]: number},\n  base: {[key: string]: number},\n  scale: number,\n  precision: number,\n) {\n  const calculatedObject: {[key: string]: number} = {};\n  Object.keys(base).forEach((key) => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = precise(base[key] + (end[key] - start[key]) * scale, precision);\n    }\n  });\n  return calculatedObject;\n}\n\n/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */\nexport function checkShapeInBounds(\n  shape: ShapeData,\n  shapeType: ShapeType,\n  bounds: { top: number; right: number; bottom: number; left: number },\n) {\n  if (shapeType === ShapeType.PIXEL) {\n    // no need to check\n    return true;\n  }\n  const shapeBounds = calcShapeBounds(shapeType, shape);\n  if (shapeBounds) {\n    const { left, top, right, bottom } = shapeBounds;\n    return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n  }\n  return true;\n}\n\n/**\n * get snapshot image data url by shape data\n * @param imageUrl\n * @param imageRotation\n * @param shape\n * @param resizeTo\n */\nexport function getSnapshot(\n  imageUrl: string,\n  imageRotation: number,\n  shape?: ShapeData,\n  pdfDocument?: PDFDocument,\n  pdfPage?: number,\n  resizeTo?: { width: number, height: number },\n) {\n  return new Promise<string>((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const imageCanvas = document.createElement('canvas');\n    const imageCtx = imageCanvas.getContext('2d');\n\n    if (!ctx || !imageCtx) {\n      reject();\n    }\n\n    const drawSnapshot = (image: HTMLCanvasElement, imageWidth: number, imageHeight: number) => {\n      imageCanvas.width = imageRotation % Math.PI === 0 ? image.width : image.height;\n      imageCanvas.height = imageRotation % Math.PI === 0 ? image.height : image.width;\n      imageCtx!.translate(imageCanvas.width / 2, imageCanvas.height / 2);\n      imageCtx!.rotate(imageRotation);\n      imageCtx!.drawImage(image, -image.width / 2, -image.height / 2);\n\n      const shapeScale = {\n        x: image.width / imageWidth,\n        y: image.height / imageHeight,\n      };\n\n      if (shape && Array.isArray((shape as PolygonData | LineData | RectangleData).points)) {\n        // use points as boundary\n        // polygon, line, or rotatable rectangle\n        const s = shape as PolygonData | LineData | RectangleData;\n        const points = s.points.map((p) => ({ x: p.x * shapeScale.x, y: p.y * shapeScale.y }));\n        let minX = points[0].x;\n        let minY = points[0].y;\n        let maxX = minX;\n        let maxY = minY;\n        for (let i = 1; i < points.length; i += 1) {\n          const { x, y } = points[i];\n          if (x < minX) {\n            minX = x;\n          }\n          if (x > maxX) {\n            maxX = x;\n          }\n          if (y < minY) {\n            minY = y;\n          }\n          if (y > maxY) {\n            maxY = y;\n          }\n        }\n        const xScale = resizeTo?.width ? resizeTo.width / (maxX - minX) : 1;\n        const yScale = resizeTo?.height ? resizeTo.height / (maxY - minY) : 1;\n        canvas.width = (maxX - minX) * xScale;\n        canvas.height = (maxY - minY) * yScale;\n        points.forEach((p, i) => {\n          if (i === 0) {\n            ctx!.moveTo((p.x - minX) * xScale, (p.y - minY) * yScale);\n          } else {\n            ctx!.lineTo((p.x - minX) * xScale, (p.y - minY) * yScale);\n          }\n        });\n        ctx!.lineTo((points[0].x - minX) * xScale, (points[0].y - minY) * yScale);\n        ctx!.clip();\n        ctx!.drawImage(imageCanvas, minX, minY, maxX - minX, maxY - minY, 0, 0, canvas.width, canvas.height);\n        resolve(canvas.toDataURL());\n      } else {\n        // use bbox as boundary\n        let sx = 0;\n        let sy = 0;\n        let sw = imageCanvas.width;\n        let sh = imageCanvas.height;\n\n        if ((shape as EllipseData)?.halfWidth !== undefined && (shape as EllipseData)?.halfHeight !== undefined) {\n          const { x, y, halfWidth, halfHeight, rotation = 0 } = shape as EllipseData;\n          const { left, top, right, bottom } = getEllipseBounds(x, y, halfWidth, halfHeight, rotation);\n          sx = left * shapeScale.x;\n          sy = top * shapeScale.y;\n          sw = (right - left) * shapeScale.x;\n          sh = (bottom - top) * shapeScale.y;\n        } else if ((shape as CircleData)?.radius !== undefined) {\n          const { x, y, radius } = shape as CircleData;\n          sx = (x - radius) * shapeScale.x;\n          sy = (y - radius) * shapeScale.y;\n          sw = radius * 2 * shapeScale.x;\n          sh = radius * 2 * shapeScale.y;\n        }\n\n        canvas.width = resizeTo?.width || sw;\n        canvas.height = resizeTo?.height || sh;\n        ctx!.drawImage(imageCanvas, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n        resolve(canvas.toDataURL());\n      }\n    };\n\n    if (pdfDocument && pdfPage !== undefined) {\n      pdfDocument\n        .loadPage(pdfPage)\n        .then((data) => drawSnapshot(data.canvas, data.width, data.height))\n        .catch(() => reject());\n    } else {\n      imageLoader(imageUrl, (data) => {\n        const loadError = data instanceof Event && data.type === 'error';\n        if (loadError) {\n          reject();\n          return;\n        }\n        const c = data as HTMLCanvasElement;\n        drawSnapshot(c, c.width, c.height);\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous',\n      });\n    }\n  });\n}\n\n/**\n * parse hotkeys config\n * @param hotkeysConfig\n */\nexport function parseHotkeysConfig(hotkeysConfig: any) {\n  const supportedAffectedTypes = ['point'];\n  const supportedTypes = ['overwrite', 'upsert'];\n  const supportedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\n  const hotkeyMap: {[key: string]: HotkeyItem[]} = {};\n  if (hotkeysConfig && typeof hotkeysConfig === 'object') {\n    Object.keys(hotkeysConfig).forEach((affected) => {\n      if (supportedAffectedTypes.includes(affected)) {\n        const items = hotkeysConfig[affected];\n        if (Array.isArray(items)) {\n          items.forEach((item) => {\n            if (item && item.key && supportedKeys.includes(item.key)) {\n              const { key, type, color, shape, attributes } = item;\n              const hotkeyItem: HotkeyItem = {\n                key,\n                affected,\n                type,\n                color,\n                shape,\n                attributes,\n              };\n\n              if (!supportedTypes.includes(type)) {\n                // eslint-disable-next-line prefer-destructuring\n                hotkeyItem.type = supportedTypes[0];\n              }\n\n              if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n                hotkeyItem.attributes = {};\n              }\n\n              if (!hotkeyMap[key]) {\n                hotkeyMap[key] = [];\n              }\n              hotkeyMap[key].push(hotkeyItem);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  return hotkeyMap;\n}\n\n/**\n * get shape type by tool name\n * @param tool\n */\nexport function getShapeTypeByTool(tool: Tool): ShapeType | undefined {\n  switch (tool) {\n    case Tool.RECTANGLE:\n    case Tool.FOUR_DOTS_RECTANGLE:\n    case Tool.CENTERLINE_RECTANGLE:\n    case Tool.OCR:\n      return ShapeType.RECTANGLE;\n    case Tool.SQUARE:\n      return ShapeType.SQUARE;\n    case Tool.POLYGON:\n    case Tool.OCR_POLYGON:\n    case Tool.FORMULA_POLYGON:\n    case Tool.RECOGNITION:\n      return ShapeType.POLYGON;\n    case Tool.PARALLELOGRAM:\n      return ShapeType.PARALLELOGRAM;\n    case Tool.ELLIPSE:\n      return ShapeType.ELLIPSE;\n    case Tool.CIRCLE:\n      return ShapeType.CIRCLE;\n    case Tool.CUBOID:\n      return ShapeType.CUBOID;\n    case Tool.LSHAPE:\n      return ShapeType.LSHAPE;\n    case Tool.QUAD_PRISM:\n      return ShapeType.QUAD_PRISM;\n    case Tool.ORIENTED_QUAD_PRISM:\n      return ShapeType.ORIENTED_QUAD_PRISM;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.CURVE:\n      return ShapeType.CURVE;\n    case Tool.CURVE_PAIR:\n      return ShapeType.CURVE_PAIR;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    case Tool.GRID:\n      return ShapeType.GRID;\n    case Tool.PIXEL:\n      return ShapeType.PIXEL;\n    case Tool.ARROW:\n      return ShapeType.ARROW;\n    case Tool.FLEX_LINE:\n      return ShapeType.FLEX_LINE;\n    case Tool.TWO_SIDES_CUBOID:\n      return ShapeType.TWO_SIDES_CUBOID;\n    case Tool.KEYPOINTS:\n      return ShapeType.KEYPOINTS;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * get tool type from frame data\n * @param shape\n */\nexport function getToolTypeFromFrameData(shape?: FrameData) {\n  switch (shape?.shapeType) {\n    case ShapeType.RECTANGLE:\n      if (shape.isOCR) {\n        return Tool.OCR;\n      }\n      if ((shape.shape as RectangleData).center) {\n        return Tool.CENTERLINE_RECTANGLE;\n      }\n      return Tool.RECTANGLE;\n    case ShapeType.SQUARE:\n      return Tool.SQUARE;\n    case ShapeType.POLYGON:\n      if (shape.isOCR) {\n        return Tool.OCR_POLYGON;\n      }\n      if (shape.isFormula) {\n        return Tool.FORMULA_POLYGON;\n      }\n      return Tool.POLYGON;\n    case ShapeType.PARALLELOGRAM:\n      return Tool.PARALLELOGRAM;\n    case ShapeType.ELLIPSE:\n      return Tool.ELLIPSE;\n    case ShapeType.CIRCLE:\n      return Tool.CIRCLE;\n    case ShapeType.CUBOID:\n      return Tool.CUBOID;\n    case ShapeType.LSHAPE:\n      return Tool.LSHAPE;\n    case ShapeType.QUAD_PRISM:\n      return Tool.QUAD_PRISM;\n    case ShapeType.ORIENTED_QUAD_PRISM:\n      return Tool.ORIENTED_QUAD_PRISM;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.CURVE:\n      return Tool.CURVE;\n    case ShapeType.CURVE_PAIR:\n      return Tool.CURVE_PAIR;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    case ShapeType.GRID:\n      return Tool.GRID;\n    case ShapeType.ARROW:\n      return Tool.ARROW;\n    case ShapeType.FLEX_LINE:\n      return Tool.FLEX_LINE;\n    case ShapeType.TWO_SIDES_CUBOID:\n      return Tool.TWO_SIDES_CUBOID;\n    case ShapeType.PIXEL:\n      return Tool.PIXEL;\n    case ShapeType.KEYPOINTS:\n      return Tool.KEYPOINTS;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * check tools include tool\n * @param tool\n * @param tools\n */\nexport function includeSameTool(tool: Tool, tools: Tool[]) {\n  const checkTools = [...tools];\n  if (tools.includes(Tool.FOUR_DOTS_RECTANGLE)) {\n    // same shape type, no difference\n    checkTools.push(Tool.RECTANGLE);\n  }\n  if (tools.includes(Tool.RECOGNITION)) {\n    // same shape type, no difference\n    checkTools.push(Tool.POLYGON);\n  }\n  return checkTools.includes(tool);\n}\n\n/**\n * parse label config\n * @param labelConfigStr\n */\nexport function parseLabelConfig(labelConfigStr?: string) {\n  if (labelConfigStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(labelConfigStr));\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\n/**\n * parse tool styles\n * @param item\n */\nexport function parseToolStyles(config: Styles) {\n  const styles: ToolStyles = {};\n  if (typeof config.fill_color === 'string') {\n    styles.fillColor = config.fill_color;\n  }\n  if (typeof config.point_color === 'string') {\n    styles.pointColor = config.point_color;\n  }\n  if (typeof config.point_type === 'string') {\n    styles.pointType = config.point_type;\n  }\n  if (typeof config.edge_color === 'string') {\n    styles.edgeColor = config.edge_color;\n  }\n  if (typeof config.edge_type === 'string') {\n    styles.edgeType = config.edge_type;\n  }\n  if (typeof config.edge_bold === 'boolean') {\n    styles.edgeBold = config.edge_bold;\n  } else if (typeof config.edge_bold === 'string') {\n    styles.edgeBold = config.edge_bold === 'true';\n  }\n  if (Array.isArray(config.points_color) && config.points_color.length > 0) {\n    styles.pointsColor = [...config.points_color];\n  }\n  if (Array.isArray(config.points_type) && config.points_type.length > 0) {\n    styles.pointsType = [...config.points_type];\n  }\n  if (Array.isArray(config.edges_color) && config.edges_color.length > 0) {\n    styles.edgesColor = [...config.edges_color];\n  }\n  if (Array.isArray(config.edges_type) && config.edges_type.length > 0) {\n    styles.edgesType = [...config.edges_type];\n  }\n  if (Array.isArray(config.edges_bold) && config.edges_bold.length > 0) {\n    styles.edgesBold = (config.edges_bold as (boolean | string)[]).map((i) => i === true || i === 'true');\n  }\n  return styles;\n}\n\n/**\n * parse tool config\n * @param tool\n * @param config\n */\nexport function parseToolConfig(tool: Tool, config: any): { config?: ToolConfig } {\n  if (tool === Tool.RECTANGLE) {\n    // parse for rectangle\n    const cfg: RectangleConfig = {};\n    const { ratio, auxiliary_lines } = config || {};\n    if (typeof ratio === 'number' && ratio > 0) {\n      cfg.ratio = ratio;\n    }\n    if (Array.isArray(auxiliary_lines)) {\n      cfg.auxiliaryLines = [];\n      auxiliary_lines.forEach(({ type, color, value, start, end }) => {\n        if (\n          (type === 'vertical' || type === 'horizonal') &&\n          typeof color === 'string' && color &&\n          typeof value === 'number' && value >= 0 && value <= 1 &&\n          typeof start === 'number' && start >= 0 && start <= 1 &&\n          typeof end === 'number' && end >= 0 && end <= 1\n        ) {\n          cfg.auxiliaryLines!.push({\n            type,\n            color,\n            value,\n            start,\n            end,\n          });\n        }\n      });\n    }\n    return {\n      config: cfg,\n    };\n  }\n  if (tool === Tool.ORIENTED_QUAD_PRISM) {\n    // parse for oriented quad prism\n    const cfg: OrientedQuadPrismToolConfig = {};\n    const { displayIndexes, upright } = config || {};\n    if (Array.isArray(displayIndexes) && displayIndexes.length > 0) {\n      cfg.displayIndexes = [...displayIndexes];\n    }\n    if (upright !== undefined) {\n      cfg.upright = upright === 'true' || upright === true;\n    }\n    return {\n      config: cfg,\n    };\n  }\n  if (tool === Tool.KEYPOINTS) {\n    // parse for keypoints\n    const cfg: KeypointsConfig = {\n      groups: [],\n      lines: [],\n    };\n    const { groups, lines } = config || {};\n    if (Array.isArray(groups)) {\n      groups.forEach((group) => {\n        const { name, range } = group;\n        const rangeStart = range?.[0];\n        const rangeEnd = range?.[1];\n        if (name && typeof rangeStart === 'number' && typeof rangeEnd === 'number' && rangeEnd >= rangeStart) {\n          if (cfg.groups.every((g) => g.range[0] > rangeEnd || g.range[1] < rangeStart)) {\n            // no overlap\n            cfg.groups.push({\n              name,\n              range: [rangeStart, rangeEnd],\n            });\n          }\n        }\n      });\n    }\n    if (Array.isArray(lines)) {\n      lines.forEach((line) => {\n        const { points, color, type } = line;\n        if (Array.isArray(points) && points.length >= 2 && points.every((p) => typeof p === 'number')) {\n          cfg.lines.push({\n            points: [...points],\n            color,\n            type,\n          });\n        }\n      });\n    }\n    return {\n      config: cfg,\n    };\n  }\n  return {};\n}\n\n/**\n * parse model config\n * @param config\n */\nexport function parseModelConfig(config?: any) {\n  if (config && config[CVModel.TRAFFIC_SIGN] && Array.isArray(config[CVModel.TRAFFIC_SIGN])) {\n    const mappings: TrafficSignModelConfig = [];\n    config[CVModel.TRAFFIC_SIGN].forEach((mapping: any) => {\n      const { type, field, options } = mapping;\n      if (Object.values(TrafficSignModelMappingType).includes(type) && field) {\n        const mOptions: TrafficSignModelMapping['options'] = [];\n        (options || []).forEach((o: any) => {\n          const { value, data } = o;\n          if (value !== undefined && value !== null && data?.every((i: any) => i.category && i.main_class && i.sub_class)) {\n            mOptions.push({ value, data });\n          }\n        });\n        mappings.push({\n          type,\n          field,\n          options: mOptions,\n        });\n      }\n    });\n    if (mappings.length > 0) {\n      return {\n        modelConfig: {\n          [CVModel.TRAFFIC_SIGN]: mappings,\n        },\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields: Field[], values: any) {\n  return fields.map((field) => ({\n    ...field,\n    ...values && values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n}\n\n/**\n * generate fields config\n * @param fields\n * @param attributes\n */\nexport function generateFieldsConfig(fields: Field[], attributes: any) {\n  let config: Field[] = [];\n  const newFields = fields && fields.map((field) => {\n    const tempField = { ...field };\n    if (field?.type === FieldControlType.RADIO) {\n      tempField.type = FieldControlType.SELECT;\n    }\n    if (field?.type === FieldControlType.CHECKBOX) {\n      tempField.type = FieldControlType.SELECT;\n      tempField.mode = Mode.MULTIPLE;\n    }\n    return tempField;\n  });\n  config = setInitialValues(newFields || [], attributes);\n  return config;\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config?: LabelConfig) {\n  const map: { [fieldName: string]: FieldConfig } = {};\n  (config?.fields || []).forEach((field) => {\n    const { name, label, type, valueType, options = [] } = field;\n    const newField: FieldConfig = { name, type, label };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX || type === FieldControlType.CASCADER) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * Get the latest form property\n * @param config form config\n * @param values from values\n */\nexport const triggerForm = (config: FormConfig, values:{[key: string]: any} = {}) => {\n  const { fields: configFields, conditions = [], effects = [], rules = [] } = config;\n  const fields = (configFields || []).map((field) => ({\n    ...field,\n    ...values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n\n  const parsedValue = formUtils.parseFormFields(fields);\n  // trigger rule effects\n  const { updatedValues: triggerValues, updatedFields } = rules.reduce(\n    (acc, curr) => formUtils.ruleTrigger(\n      curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects,\n    ),\n    { updatedFields: parsedValue.fields, updatedValues: parsedValue.initialValues },\n  );\n\n  const updatedValues = {\n    ...triggerValues\n  };\n  updatedFields.filter((f) => f.visible === false).forEach((f) => {\n    delete updatedValues[f.name];\n  });\n  return {\n    updatedValues,\n    updatedFields,\n  };\n};\n\n/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUpperShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let upperShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order > targetShape.order) { // upper\n      if (!upperShape) {\n        upperShape = shape;\n      } else if (upperShape.order > shape.order) {\n        upperShape = shape;\n      }\n    }\n  }\n  return upperShape;\n}\n\n/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUnderShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let underShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order < targetShape.order) { // under\n      if (!underShape) {\n        underShape = shape;\n      } else if (underShape.order < shape.order) {\n        underShape = shape;\n      }\n    }\n  }\n  return underShape;\n}\n\n/**\n * calculate shape area\n * @param shapeType\n * @param shapeData\n */\nexport function calcShapeArea(shapeType: ShapeType, shapeData: ShapeData) {\n  let area = NaN;\n  switch (shapeType) {\n    case ShapeType.POLYGON: {\n      const { points } = shapeData as PolygonData;\n      const polygon = new Flatten.Polygon();\n      polygon.addFace(points.map((p) => new Flatten.Point(p.x, p.y)));\n      area = polygon.faces.values().next().value.area();\n      break;\n    }\n    case ShapeType.RECTANGLE:\n    case ShapeType.SQUARE: {\n      const { width, height } = shapeData as RectangleData;\n      area = width * height;\n      break;\n    }\n    case ShapeType.ELLIPSE: {\n      const { halfWidth, halfHeight } = shapeData as EllipseData;\n      area = Math.PI * halfWidth * halfHeight;\n      break;\n    }\n    case ShapeType.CIRCLE: {\n      const { radius } = shapeData as CircleData;\n      area = Math.PI * radius ** 2;\n      break;\n    }\n    case ShapeType.PIXEL: {\n      const { data } = shapeData as PixelData;\n      const { counts } = data;\n      area = 0;\n      for (let i = 0; i < counts.length; i += 1) {\n        if (i % 2 === 1) {\n          area += counts[i];\n        }\n      }\n      break;\n    }\n    default:\n  }\n  return area;\n}\n\n/**\n * calculate shape bounds\n * @param shapeType\n * @param shapeData\n */\nexport function calcShapeBounds(shapeType: ShapeType, shapeData: ShapeData) {\n  switch (shapeType) {\n    case ShapeType.CIRCLE: {\n      const { x, y, radius } = shapeData as CircleData;\n      return {\n        left: x - radius,\n        top: y - radius,\n        right: x + radius,\n        bottom: y + radius,\n      };\n    }\n    case ShapeType.ELLIPSE: {\n      const { x, y, halfWidth, halfHeight } = shapeData as EllipseData;\n      return {\n        left: x - halfWidth,\n        top: y - halfHeight,\n        right: x + halfWidth,\n        bottom: y + halfHeight,\n      };\n    }\n    case ShapeType.LINE:\n    case ShapeType.ARROW:\n    case ShapeType.POLYGON:\n    case ShapeType.RECTANGLE:\n    case ShapeType.SQUARE:\n    case ShapeType.PARALLELOGRAM:\n    case ShapeType.QUAD_PRISM:\n    case ShapeType.ORIENTED_QUAD_PRISM:\n    case ShapeType.KEYPOINTS: {\n      const { points } = shapeData as LineData | PolygonData | RectangleData | ParallelogramData | QuadPrismData | OrientedQuadPrismData | KeypointsData;\n      const allX = points!.map((p) => p.x);\n      const allY = points!.map((p) => p.y);\n      return {\n        left: Math.min(...allX),\n        top: Math.min(...allY),\n        right: Math.max(...allX),\n        bottom: Math.max(...allY),\n      };\n    }\n    case ShapeType.CURVE:\n    case ShapeType.FLEX_LINE: {\n      const { points } = shapeData as CurveData;\n      const discretePoints = discretizeCurve(points);\n      const [p1, ...ps] = discretePoints;\n      let left = p1.x;\n      let right = p1.x;\n      let top = p1.y;\n      let bottom = p1.y;\n      for (let i = 0; i < ps.length; i += 1) {\n        const { x, y } = ps[i];\n        if (x < left) {\n          left = x;\n        } else if (x > right) {\n          right = x;\n        }\n        if (y < top) {\n          top = y;\n        } else if (y > bottom) {\n          bottom = y;\n        }\n      }\n      return { left, top, right, bottom };\n    }\n    case ShapeType.CUBOID:\n    case ShapeType.TWO_SIDES_CUBOID: {\n      const { front, back } = shapeData as CuboidData;\n      const fx1 = front.x;\n      const fy1 = front.y;\n      const fx2 = front.x + front.width;\n      const fy2 = front.y + front.height;\n      const bx1 = back.x;\n      const by1 = back.y;\n      const bx2 = back.x + back.width;\n      const by2 = back.y + back.height;\n      return {\n        left: Math.min(fx1, fx2, bx1, bx2),\n        top: Math.min(fy1, fy2, by1, by2),\n        right: Math.max(fx1, fx2, bx1, bx2),\n        bottom: Math.max(fy1, fy2, by1, by2),\n      };\n    }\n    case ShapeType.LSHAPE: {\n      const { front, sidePoints } = shapeData as LShapeData;\n      const fx1 = front.x;\n      const fy1 = front.y;\n      const fx2 = front.x + front.width;\n      const fy2 = front.y + front.height;\n      const sidePointsX = sidePoints.map((p) => p.x);\n      const sidePointsY = sidePoints.map((p) => p.y);\n      return {\n        left: Math.min(fx1, fx2, ...sidePointsX),\n        top: Math.min(fy1, fy2, ...sidePointsY),\n        right: Math.max(fx1, fx2, ...sidePointsX),\n        bottom: Math.max(fy1, fy2, ...sidePointsY),\n      };\n    }\n    case ShapeType.CURVE_PAIR: {\n      const { pairs } = shapeData as CurvePairData;\n      const line1: CurvePoint[] = [];\n      const line2: CurvePoint[] = [];\n      pairs.forEach(({ p1, p2, controls }, i) => {\n        const nextPair = pairs[i + 1];\n        const { control1 = undefined, control2 = undefined } = nextPair\n          ? calcControlsForPairs({ p1, p2, controls }, nextPair)\n          : {};\n        line1.push({\n          ...p1,\n          ...control1 && {\n            controls: [{\n              x: control1.x,\n              y: control1.y,\n            }, {\n              x: control1.x,\n              y: control1.y,\n            }],\n          },\n        });\n        line2.push({\n          ...p2,\n          ...control2 && {\n            controls: [{\n              x: control2.x,\n              y: control2.y,\n            }, {\n              x: control2.x,\n              y: control2.y,\n            }],\n          },\n        });\n      });\n      const line1Points = discretizeCurve(line1);\n      const line2Points = discretizeCurve(line2);\n      const [p1, ...ps] = line1Points.concat(line2Points);\n      let left = p1.x;\n      let right = p1.x;\n      let top = p1.y;\n      let bottom = p1.y;\n      for (let i = 0; i < ps.length; i += 1) {\n        const { x, y } = ps[i];\n        if (x < left) {\n          left = x;\n        } else if (x > right) {\n          right = x;\n        }\n        if (y < top) {\n          top = y;\n        } else if (y > bottom) {\n          bottom = y;\n        }\n      }\n      return { left, top, right, bottom };\n    }\n    case ShapeType.DOT: {\n      const { x, y } = shapeData as DotData;\n      return {\n        left: x,\n        top: y,\n        right: x,\n        bottom: y,\n      };\n    }\n    case ShapeType.GRID: {\n      const { cols, rows } = shapeData as GridData;\n      const allX = cols.map((c) => c.x);\n      const allY = rows.map((r) => r.y);\n      return {\n        left: Math.min(...allX),\n        top: Math.min(...allY),\n        right: Math.max(...allX),\n        bottom: Math.max(...allY),\n      };\n    }\n    case ShapeType.PIXEL: {\n      const { data } = shapeData as PixelData;\n      const { counts, size } = data;\n      const height = size[0];\n      let left: number | undefined;\n      let top: number | undefined;\n      let right: number | undefined;\n      let bottom: number | undefined;\n      let decodedSize = 0;\n      for (let i = 0; i < counts.length; i += 1) {\n        const count = counts[i];\n        const flag = i % 2;\n        if (flag === 1) {\n          for (let j = decodedSize; j < decodedSize + count; j += 1) {\n            const x = Math.floor(j / height);\n            const y = j % height;\n            if (left === undefined) {\n              left = x;\n            } else if (x < left) {\n              left = x;\n            }\n            if (right === undefined) {\n              right = x;\n            } else if (x > right) {\n              right = x;\n            }\n            if (top === undefined) {\n              top = y;\n            } else if (y < top) {\n              top = y;\n            }\n            if (bottom === undefined) {\n              bottom = y;\n            } else if (y > bottom) {\n              bottom = y;\n            }\n          }\n        }\n        decodedSize += count;\n      }\n      return {\n        left: left ?? 0,\n        top: top ?? 0,\n        right: right ?? 0,\n        bottom: bottom ?? 0,\n      };\n    }\n    default:\n      return undefined;\n  }\n}\n\n/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */\nexport function preciseShapeByType(shapeType: ShapeType, shapeData: ShapeData, precision: number) {\n  if (shapeType !== ShapeType.PIXEL) {\n    preciseData(shapeData, precision);\n  }\n}\n\n/**\n * precise data\n * @param data\n */\nexport function preciseData(data: any, precision: number) {\n  if (Number.isNaN(precision)) {\n    // no need to precise\n    return;\n  }\n  if (Array.isArray(data)) {\n    // array\n    data.forEach((item, i) => {\n      if (typeof item === 'number') {\n        data[i] = precise(item, precision);\n      } else {\n        preciseData(item, precision);\n      }\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    // object\n    const skipKeys = [\n      'rotation', // shape rotation\n      'area', // shape area\n      'userData', // shape point user data\n    ];\n    const allKeys = Object.keys(data);\n    allKeys.forEach((key) => {\n      if (skipKeys.includes(key)) {\n        return;\n      }\n      const keyData = data[key];\n      if (typeof keyData === 'number') {\n        data[key] = precise(keyData, precision);\n      } else {\n        preciseData(keyData, precision);\n      }\n    });\n  }\n}\n\n/**\n * check attributes pass condition\n * @param attributes\n * @param condition\n */\nexport function isAttributesPassCondition(attributes: any, condition: any) {\n  if (!attributes || !condition) {\n    return false;\n  }\n  return Object.keys(condition).every((key) => (\n    Array.isArray(condition[key]) ? condition[key].sort() : condition[key]).toString()\n    ===\n    (Array.isArray(attributes[key]) ? attributes[key].sort() : attributes[key])?.toString());\n}\n\n/**\n * ocr request limit\n */\nconst storagePrefixKey = 'video-tracking-v2-ocr';\nexport function checkOCRRequestCount(imageUrl: string, type: 'ocr' | 'formula' | 'formulaText' = 'ocr') {\n  const data = JSON.parse(localStorage.getItem(storagePrefixKey) || '{}');\n  if (data[imageUrl]) {\n    // has config\n    const count = data[imageUrl][type];\n    if (count > 0) {\n      // count valid\n      const limits = {\n        ocr: 1000,\n        formula: 30,\n        formulaText: 20,\n      };\n      return count < limits[type];\n    }\n  }\n  return true;\n}\nexport function updateOCRRequestCount(imageUrl: string, type: 'ocr' | 'formula' | 'formulaText' = 'ocr') {\n  // saved storage\n  const data = JSON.parse(localStorage.getItem(storagePrefixKey) || '{}');\n  // new data to store\n  const newData: {\n    [image: string]: {\n      ocr: number; // limit for OCR shape\n      formula: number; // limit to get formula for formula shape\n      formulaText: number; // limit to get text for formula shape\n      lastModified: number;\n    }\n  } = {};\n  // current time\n  const current = Date.now();\n  // one month duration\n  // const month = 30 * 24 * 60 * 60 * 1000;\n\n  Object.keys(data).forEach((key) => {\n    const { ocr, formula, formulaText, lastModified } = data[key];\n    if (ocr > 0 || formula > 0 || formulaText > 0) {\n      newData[key] = {\n        ocr: ocr > 0 ? ocr : 0,\n        formula: formula > 0 ? formula : 0,\n        formulaText: formulaText > 0 ? formulaText : 0,\n        lastModified,\n      };\n    }\n  });\n\n  if (newData[imageUrl]) {\n    // already exits, update\n    newData[imageUrl][type] += 1;\n    newData[imageUrl].lastModified = current;\n  } else {\n    const allImageKeys = Object.keys(newData);\n    if (allImageKeys.length >= 200) {\n      // should remove oldest config\n      allImageKeys.sort((a, b) => newData[a].lastModified - newData[b].lastModified);\n      const oldest = allImageKeys[0];\n      delete newData[oldest];\n    }\n    // add\n    newData[imageUrl] = {\n      ocr: 0,\n      formula: 0,\n      formulaText: 0,\n      [type]: 1,\n      lastModified: current,\n    };\n  }\n\n  localStorage.setItem(storagePrefixKey, JSON.stringify(newData));\n}\n\n/**\n * parse formula template by link\n * @param templateLink\n */\nexport function parseFormulaTemplate(templateLink?: string) {\n  if (!templateLink) {\n    return Promise.resolve(null);\n  }\n  return new Promise<FormulaTemplate | null>((resolve) => {\n    Papa.parse(templateLink, {\n      download: true,\n      complete: (res) => {\n        const { data } = res;\n        if (data?.length > 0) {\n          const header = data[0] as string[];\n          let categoryIndex = -1;\n          let nameIndex = -1;\n          let valueIndex = -1;\n          header.forEach((item, index) => {\n            const col = item.trim();\n            if (col === 'category') {\n              categoryIndex = index;\n            } else if (col === 'name') {\n              nameIndex = index;\n            } else if (col === 'value') {\n              valueIndex = index;\n            }\n          });\n\n          if (categoryIndex >= 0 && valueIndex >= 0) {\n            const template: FormulaTemplate = {};\n            for (let i = 1; i < data.length; i += 1) {\n              const item = data[i] as string[];\n              const category = item[categoryIndex];\n              const name = item[nameIndex];\n              const value = item[valueIndex];\n              if (category) {\n                // has category\n                if (!template.categories) {\n                  template.categories = {};\n                }\n                if (!template.categories[category]) {\n                  template.categories[category] = [];\n                }\n                template.categories[category].push({ name, value });\n              } else {\n                // no category, add to global\n                if (!template.global) {\n                  template.global = [];\n                }\n                template.global.push({ name, value });\n              }\n            }\n            resolve(template);\n            return;\n          }\n        }\n        resolve(null);\n      },\n      error: () => {\n        resolve(null);\n      },\n    });\n  });\n}\n\nexport function getAttributesByModelData(\n  modelData: TrafficSignModelData,\n  type: TrafficSignModelMappingType,\n  config?: TrafficSignModelConfig,\n) {\n  if (config) {\n    const attrs: Record<string, FieldValue> = {};\n    for (let i = 0; i < config.length; i += 1) {\n      if (config[i].type === type) {\n        const { field, options } = config[i];\n        const fitOption = options.find((o) => o.data.some((d) => (\n          d.category === modelData.category &&\n          d.main_class === modelData.main_class &&\n          d.sub_class === modelData.sub_class\n        )));\n        if (fitOption) {\n          attrs[field] = fitOption.value;\n        }\n      }\n    }\n    return attrs;\n  }\n  return {\n    category: modelData.category,\n    [modelData.category]: modelData.main_class,\n    [modelData.main_class]: modelData.sub_class,\n  };\n}\nexport const isContained = (value: any | any[], options: FieldOption[]) => {\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const valueItem = value[index];\n      if (!isContained(valueItem, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return !!options?.find((i) => i.value === value);\n};\n\n/**\n * options contained value for nested structures\n * @param values\n * @param options\n */\nexport function isContainedForNested(values: FieldValue[] = [], options: FieldOption[]): boolean {\n  const result = values.reduce((preVal: { options: FieldOption[], isContained: boolean}, currVal: FieldValue) => {\n    if (!preVal.isContained || !preVal.options || preVal.options.length < 1) {\n      return preVal;\n    }\n    const option = preVal.options?.find((o) => o.value === currVal);\n    if (option) {\n      preVal.isContained = true;\n      if (option.children && option.children.length > 0) {\n        preVal.options = option.children;\n      }\n    } else {\n      preVal.isContained = false;\n    }\n    return preVal;\n  }, { options, isContained: true });\n  return result.isContained;\n}\n\n/**\n * update attributes by fields compare\n * @param sourceFields\n * @param destinationFields\n * @param sourceAttributes\n * @param initialValues\n */\nexport const updateAttributesByFieldsCompare = (sourceFields: Field[], destinationFields: Field[], sourceAttributes: any = {}, initialValues: { [x: string]: any; } = {}) => {\n  const sourceFieldsMap = Object.fromEntries(sourceFields.map((item) => [item.name, item]));\n  const destinationFieldsMap = Object.fromEntries(destinationFields.map((item) => [item.name, item]));\n  const newInitialValues = { ...initialValues };\n  Object.keys(destinationFieldsMap).forEach((item) => {\n    if (\n      sourceFieldsMap[item] &&\n      destinationFieldsMap[item].type === sourceFieldsMap[item].type &&\n      destinationFieldsMap[item].valueType === sourceFieldsMap[item].valueType\n    ) {\n      if (destinationFieldsMap[item].options && sourceFieldsMap[item].options) {\n        const isContain = destinationFieldsMap[item].type === FieldControlType.CASCADER ?\n          isContainedForNested(sourceAttributes[item], destinationFieldsMap[item].options || []) :\n          isContained(sourceAttributes[item], destinationFieldsMap[item].options || []);\n        if (isContain) {\n          newInitialValues[item] = sourceAttributes[item];\n        }\n      } else {\n        newInitialValues[item] = sourceAttributes[item];\n      }\n    }\n  });\n  return newInitialValues;\n};\n\n/**\n * check dynamic attributes\n * @param instance\n * @param dynamicInstanceConfig\n */\nexport const checkDynamicAttributes = (instance: Instance, dynamicInstanceConfig?: LabelConfig): boolean => {\n  if (!dynamicInstanceConfig) {\n    return false;\n  }\n\n  let failed = false;\n  for (let i = 0; i < instance.children.length; i += 1) {\n    if (failed) {\n      break;\n    }\n    const { cameras } = instance.children[i];\n    for (let j = 0; j < cameras.length; j += 1) {\n      if (failed) {\n        break;\n      }\n      const { camera, frames } = cameras[j];\n      const dynamicAttributes = instance.dynamicAttributes?.find((attr) => attr.camera === camera);\n      for (let k = 0; k < frames.length; k += 1) {\n        const { frameIndex } = frames[k];\n        const { attributes } = dynamicAttributes?.frames.find((f) => f.frameIndex === frameIndex) || {};\n        if (!formUtils.validate(dynamicInstanceConfig, attributes || {}, { check: true })) {\n          failed = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return failed;\n};\n\nexport function minifyShapeData(shapeType: ShapeType, shapeData: ShapeData) {\n  // FIXME: temp reduce saved file size\n  if (shapeType === ShapeType.PIXEL) {\n    (shapeData as PixelData).polygons = [];\n  }\n  return shapeData;\n}\n\nexport function isShapeDataMinified(shapeType: ShapeType, shapeData: ShapeData) {\n  if (shapeType === ShapeType.PIXEL) {\n    const { polygons } = shapeData as PixelData;\n    return !polygons || polygons.length === 0;\n  }\n  return false;\n}\n\nexport function isCategoryChangeAllowed(mode?: EditMode) {\n  const category = mode?.[1];\n  return category !== '0';\n}\n\nexport function isNumberChangeAllowed(mode?: EditMode) {\n  const number = mode?.[3];\n  if (number !== undefined) {\n    return number !== '0';\n  }\n  return isCategoryChangeAllowed(mode);\n}\n\nexport function isMatrixChangeAllowed(mode?: EditMode) {\n  const matrix = mode?.[0];\n  return matrix !== '0';\n}\n\nexport function isDeleteAllowed(mode?: EditMode) {\n  const del = mode?.[4];\n  if (del !== undefined) {\n    return del !== '0';\n  }\n  return isMatrixChangeAllowed(mode);\n}\n\nexport function isAttrChangeAllowed(mode?: EditMode) {\n  const attr = mode?.[2];\n  return attr !== '0';\n}\n\nexport function parseCategoryHotkey(shortcut?: string) {\n  if (shortcut) {\n    // TODO: current only single alphabet is supported\n    if (/^[a-zA-Z]$/.test(shortcut)) {\n      const categoryHotkey: CategoryHotkey = {\n        key: shortcut.toLowerCase(),\n        shiftKey: false,\n        ctrlKey: false,\n        altKey: false,\n      };\n      return categoryHotkey;\n    }\n  }\n  return undefined;\n}\n\nfunction getExtension(url?: string) {\n  if (!url) {\n    return '';\n  }\n  try {\n    const u = new URL(url);\n    const filename = u.pathname.split('/').pop();\n    const extension = filename?.split('.').slice(1).join('.');\n    return extension ?? '';\n  } catch (e) {\n    // parse error\n  }\n  return '';\n}\n\nexport function isPDFUrl(url?: string) {\n  const extension = getExtension(url);\n  return ['pdf'].includes(extension?.toLowerCase());\n}\n\nexport function isVideoUrl(url?: string) {\n  const extension = getExtension(url);\n  return ['mp4', 'webm', 'mov'].includes(extension?.toLowerCase());\n}\n\nexport function isNIFTIUrl(url?: string) {\n  const extension = getExtension(url);\n  return ['nii', 'nii.gz'].includes(extension?.toLowerCase());\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}