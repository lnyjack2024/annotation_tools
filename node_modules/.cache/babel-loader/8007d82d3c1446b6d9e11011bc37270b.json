{"ast":null,"code":"import { makeAutoObservable, toJS } from 'mobx';\nimport { xor, findIndex, isEqual } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport { ReviewItemResult, TAG } from '../types';\nimport { MISSING_LABEL } from './constant';\nimport { generateConfigKeyByKeys, getConfigByKeys, getNextInLoopList, getTextByInsertion } from '../utils/helper';\nimport { isConnection, isInsertion, isLabel, isQATag } from './tag_mode';\nimport localMessage from '../locale';\nconst missKeys = generateConfigKeyByKeys(MISSING_LABEL.keys);\n/**\n * store for config\n * @class\n */\nexport default class OntologyStore {\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    this.ontologyConfigMap = new Map();\n    this.ontologiesStatusMap = new Map();\n    this.ontologies = void 0;\n    this.results = {\n      labels: [],\n      insertions: [],\n      connections: []\n    };\n    this.text = '';\n    this.formatOntologyItem = (ontologyItem, type, keys = []) => {\n      if (!ontologyItem) {\n        return [];\n      }\n      const result = [];\n      ontologyItem.forEach(item => {\n        const newKeys = [...keys];\n        newKeys.push(item.text);\n        const {\n          children,\n          ...restProps\n        } = item;\n        const newOntologyItem = {\n          ...restProps,\n          type,\n          keys: newKeys\n        };\n        if (item.children && item.children.length > 0) {\n          newOntologyItem.children = this.formatOntologyItem(item.children, type, newKeys);\n        }\n        result.push(newOntologyItem);\n      });\n      return result;\n    };\n    this.updateOntologiesCollapseStatus = (keys, collapseStatus) => {\n      const configKey = generateConfigKeyByKeys(keys);\n      const currentStatus = this.ontologiesStatusMap.get(configKey);\n      if (!currentStatus) {\n        return;\n      }\n      this.ontologiesStatusMap.set(configKey, {\n        ...currentStatus,\n        isCollapse: collapseStatus\n      });\n      this.updateOntologiesStatusMap();\n    };\n    this.getItemPosition = item => {\n      if (!item) {\n        return -1;\n      }\n      if (isLabel(item.type)) {\n        return item.start;\n      }\n      if (isInsertion(item.type)) {\n        return item.at;\n      }\n      if (isConnection(item.type)) {\n        const startTag = this.getItem(item.fromType, item.fromId);\n        return this.getItemPosition(startTag);\n      }\n      return -1;\n    };\n    makeAutoObservable(this, {\n      rootStore: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n  getOntologiesStatusMap() {\n    return toJS(this.ontologiesStatusMap);\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload) {\n    const {\n      labels,\n      insertions,\n      connections,\n      content\n    } = payload;\n    this.text = content;\n    this.formatOntologies(labels, insertions, connections);\n    this.generateConfigMap(labels, insertions, connections);\n  }\n  formatOntologies(labels, insertions, connections) {\n    const formattedLabels = this.formatOntologyItem(labels, TAG.LABEL);\n    const formattedInsertions = this.formatOntologyItem(insertions, TAG.INSERTION);\n    const formattedConnections = this.formatOntologyItem(connections, TAG.CONNECTION);\n    if (this.rootStore.reviewable || this.rootStore.isRework) {\n      const missingLabel = [{\n        ...MISSING_LABEL,\n        type: TAG.LABEL_QA,\n        text: localMessage(MISSING_LABEL.text)\n      }];\n      this.ontologies = {\n        labels_qa: missingLabel\n      };\n    }\n    this.ontologies = {\n      ...this.ontologies,\n      labels: formattedLabels,\n      insertions: formattedInsertions,\n      connections: formattedConnections\n    };\n  }\n  generateConfigMap(labels, insertions, connections) {\n    if (this.rootStore.reviewable || this.rootStore.isRework) {\n      this.ontologyConfigMap.set(generateConfigKeyByKeys(MISSING_LABEL.keys), {\n        ...MISSING_LABEL,\n        type: TAG.LABEL_QA,\n        text: localMessage(MISSING_LABEL.text)\n      });\n    }\n    if (labels) {\n      this.generateConfigMapItem(labels, TAG.LABEL);\n    }\n    if (insertions) {\n      this.generateConfigMapItem(insertions, TAG.INSERTION);\n    }\n    if (connections) {\n      this.generateConfigMapItem(connections, TAG.CONNECTION);\n    }\n  }\n  generateConfigMapItem(tags, type, key = [], isChild = false, childKeys = []) {\n    tags.forEach(tag => {\n      childKeys.push(tag.text);\n      let newKey = [...key];\n      newKey.push(tag.text);\n      const newTag = {\n        type,\n        color: tag.color,\n        displayName: tag.displayName,\n        text: tag.text,\n        isChild,\n        keys: newKey,\n        childKeys: []\n      };\n      if (tag.children && tag.children.length > 0) {\n        const childKeysArr = this.generateConfigMapItem(tag.children, type, newKey, true);\n        newTag.childKeys = childKeysArr;\n        this.ontologyConfigMap.set(generateConfigKeyByKeys(newKey), newTag);\n      } else {\n        this.ontologyConfigMap.set(generateConfigKeyByKeys(newKey), newTag);\n        newKey = [];\n      }\n    });\n    return childKeys;\n  }\n  calcCountItem(ontology) {\n    const {\n      labels,\n      insertions,\n      connections\n    } = this.results;\n    const {\n      missing\n    } = this.rootStore.review.reviews;\n    const {\n      keys,\n      type,\n      children\n    } = ontology;\n    const configKey = generateConfigKeyByKeys(keys);\n    const currentStatus = this.ontologiesStatusMap.get(configKey);\n    const newItem = {\n      isCollapse: true,\n      keys,\n      tagCount: 0,\n      tagCountContainChildren: 0,\n      rejectCount: 0,\n      rejectCountContainChildren: 0,\n      approveCount: 0\n    };\n    if (currentStatus) {\n      newItem.isCollapse = currentStatus.isCollapse;\n      newItem.keys = currentStatus.keys;\n    }\n    let tagCount = 0;\n    let rejectCount = 0;\n    let childRejectCount = 0;\n    let childTagCount = 0;\n    let approveCount = 0;\n    if (type === TAG.LABEL_QA) {\n      tagCount = missing.length;\n      this.ontologiesStatusMap.set(missKeys, {\n        isCollapse: false,\n        keys: MISSING_LABEL.keys,\n        tagCount\n      });\n    }\n    if (type === TAG.LABEL) {\n      labels.forEach(label => {\n        if (isEqual(label.keys, keys)) {\n          tagCount += 1;\n          const review = this.rootStore.review.getReview(label.id);\n          if (review) {\n            if (review.result === ReviewItemResult.REJECT) {\n              rejectCount += 1;\n            } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewItemResult.PASS) {\n              approveCount += 1;\n            }\n          }\n        }\n      });\n    }\n    if (type === TAG.INSERTION) {\n      insertions.forEach(insertion => {\n        if (isEqual(insertion.keys, keys)) {\n          tagCount += 1;\n          const review = this.rootStore.review.getReview(insertion.id);\n          if (review) {\n            if (review.result === ReviewItemResult.REJECT) {\n              rejectCount += 1;\n            } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewItemResult.PASS) {\n              approveCount += 1;\n            }\n          }\n        }\n      });\n    }\n    if (type === TAG.CONNECTION) {\n      connections.forEach(connection => {\n        if (isEqual(connection.keys, keys)) {\n          tagCount += 1;\n          const review = this.rootStore.review.getReview(connection.id);\n          if (review) {\n            if (review.result === ReviewItemResult.REJECT) {\n              rejectCount += 1;\n            } else if ((review === null || review === void 0 ? void 0 : review.result) === ReviewItemResult.PASS) {\n              approveCount += 1;\n            }\n          }\n        }\n      });\n    }\n    if (children && children.length > 0) {\n      const childCountInfo = this.calcCount(children);\n      childRejectCount = childCountInfo.rejectCount;\n      childTagCount = childCountInfo.tagCount;\n    }\n    newItem.tagCount = tagCount;\n    newItem.rejectCount = rejectCount;\n    newItem.approveCount = approveCount;\n    newItem.rejectCountContainChildren = rejectCount + childRejectCount;\n    newItem.tagCountContainChildren = tagCount + childTagCount;\n    return {\n      configKey,\n      newItem\n    };\n  }\n  calcCount(ontologies) {\n    const result = {\n      rejectCount: 0,\n      tagCount: 0\n    };\n    ontologies.forEach(ontology => {\n      const {\n        configKey,\n        newItem\n      } = this.calcCountItem(ontology);\n      this.ontologiesStatusMap.set(configKey, newItem);\n      result.tagCount += newItem.tagCountContainChildren;\n      result.rejectCount += newItem.rejectCountContainChildren;\n    });\n    return result;\n  }\n  updateOntologiesStatusMap() {\n    if (!this.ontologies) {\n      return;\n    }\n    Object.values(this.ontologies).forEach(ontologies => {\n      this.calcCount(ontologies);\n    });\n  }\n  updateOntologiesCollapseStatusAll(collapseStatus) {\n    this.ontologiesStatusMap.forEach((value, key) => {\n      if (key !== missKeys) {\n        value.isCollapse = collapseStatus;\n      }\n    });\n    this.updateOntologiesStatusMap();\n  }\n  parseResults(newResult) {\n    var _newResult$labels, _newResult$labels2, _newResult$insertions, _newResult$insertions2, _newResult$connection, _newResult$connection2;\n    if (!newResult) return;\n    const {\n      results\n    } = this;\n    const length = strlen(this.text);\n    // parse label\n    (_newResult$labels = newResult.labels) === null || _newResult$labels === void 0 ? void 0 : _newResult$labels.forEach(label => {\n      var _getConfigByKeys;\n      // invalid start & end\n      if (typeof label !== 'object') return;\n      if (Number.isNaN(label.start) || label.start === null || label.start < 0 || label.start >= length) {\n        label.dirty = true;\n        return;\n      }\n      if (Number.isNaN(label.end) || label.end === null || label.end < 0 || label.end >= length + 1) {\n        label.dirty = true;\n        return;\n      }\n      if (!label.keys) {\n        this.ontologyConfigMap.forEach((value, key) => {\n          const keys = value.keys;\n          if (keys[keys.length - 1] === label.value) {\n            label.keys = value.keys;\n          }\n        });\n      }\n      // invalid value\n      if (!isLabel((_getConfigByKeys = getConfigByKeys(this.ontologyConfigMap, label.keys)) === null || _getConfigByKeys === void 0 ? void 0 : _getConfigByKeys.type)) {\n        label.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      if (!label.id) {\n        label.id = uuidv4();\n      }\n      if (!label.type) {\n        label.type = TAG.LABEL;\n      }\n      // missing text\n      if (!label.text) label.text = substr(this.text, label.start, label.end - label.start);\n    });\n    if (!(results === null || results === void 0 ? void 0 : results.labels)) {\n      results.labels = [];\n    }\n    results.labels = ((_newResult$labels2 = newResult.labels) === null || _newResult$labels2 === void 0 ? void 0 : _newResult$labels2.filter(label => typeof label === 'object' && !label.dirty)) || [];\n\n    // parse insertion\n    (_newResult$insertions = newResult.insertions) === null || _newResult$insertions === void 0 ? void 0 : _newResult$insertions.forEach(insertion => {\n      var _getConfigByKeys2;\n      // invalid start & end\n      if (typeof insertion !== 'object') return;\n      if (Number.isNaN(insertion.at) || insertion.at === null || insertion.at < 0 || insertion.at >= length) {\n        insertion.dirty = true;\n        return;\n      }\n      if (!insertion.keys) {\n        this.ontologyConfigMap.forEach((value, key) => {\n          const keys = value.keys;\n          if (keys[keys.length - 1] === insertion.value) {\n            insertion.keys = value.keys;\n          }\n        });\n      }\n      // invalid value\n      if (!isInsertion((_getConfigByKeys2 = getConfigByKeys(this.ontologyConfigMap, insertion.keys)) === null || _getConfigByKeys2 === void 0 ? void 0 : _getConfigByKeys2.type)) {\n        insertion.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      if (!insertion.id) {\n        insertion.id = uuidv4();\n      }\n      if (!insertion.type) {\n        insertion.type = TAG.INSERTION;\n      }\n      // missing text\n      if (!insertion.text) insertion.text = getTextByInsertion(this.text, insertion);\n    });\n    if (!(results === null || results === void 0 ? void 0 : results.insertions)) {\n      results.insertions = [];\n    }\n    results.insertions = ((_newResult$insertions2 = newResult.insertions) === null || _newResult$insertions2 === void 0 ? void 0 : _newResult$insertions2.filter(insertion => typeof insertion === 'object' && !insertion.dirty)) || [];\n    // parse connection\n    (_newResult$connection = newResult.connections) === null || _newResult$connection === void 0 ? void 0 : _newResult$connection.forEach(connection => {\n      var _getConfigByKeys3;\n      // invalid start & end\n      if (typeof connection !== 'object') return;\n      if (!connection.keys) {\n        this.ontologyConfigMap.forEach((value, key) => {\n          const keys = value.keys;\n          if (keys[keys.length - 1] === connection.value) {\n            connection.keys = value.keys;\n          }\n        });\n      }\n      if (!connection.fromId && connection.from) {\n        connection.fromId = connection.from;\n      }\n      if (!connection.fromType && connection.from) {\n        const target = this.getItemById(connection.from);\n        if (target) {\n          connection.fromType = target.type;\n        }\n      }\n      if (!connection.toId && connection.to) {\n        connection.toId = connection.to;\n      }\n      if (!connection.toType && connection.to) {\n        const target = this.getItemById(connection.to);\n        if (target) {\n          connection.toType = target.type;\n        }\n      }\n      // invalid value\n      if (!isConnection((_getConfigByKeys3 = getConfigByKeys(this.ontologyConfigMap, connection.keys)) === null || _getConfigByKeys3 === void 0 ? void 0 : _getConfigByKeys3.type)) {\n        connection.dirty = true;\n        return;\n      }\n      // invalid from & to\n      if (findIndex(newResult.labels, {\n        id: connection.fromId\n      }) === -1 && findIndex(newResult.insertions, {\n        id: connection.fromId\n      }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      if (findIndex(newResult.labels, {\n        id: connection.toId\n      }) === -1 && findIndex(newResult.insertions, {\n        id: connection.toId\n      }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      if (!connection.type) {\n        connection.type = TAG.CONNECTION;\n      }\n      // invalid & missing id\n      if (!connection.id) {\n        connection.id = uuidv4();\n      }\n    });\n    if (!(results === null || results === void 0 ? void 0 : results.connections)) {\n      results.connections = [];\n    }\n    results.connections = ((_newResult$connection2 = newResult.connections) === null || _newResult$connection2 === void 0 ? void 0 : _newResult$connection2.filter(connection => typeof connection === 'object' && !connection.dirty)) || [];\n    console.log('results parse', results);\n  }\n  getResults(withMissing = true) {\n    const {\n      labels,\n      insertions,\n      connections\n    } = this.results;\n    const {\n      missing\n    } = this.rootStore.review.reviews;\n    let allLabels = labels;\n    if (withMissing) {\n      allLabels = labels.concat(missing);\n    }\n    return {\n      labels: allLabels.map(item => toJS(item)),\n      insertions: insertions.map(item => toJS(item)),\n      connections: connections.map(item => toJS(item))\n    };\n  }\n  setResults(newResults = {}) {\n    const results = JSON.parse(JSON.stringify(newResults));\n    this.results = {\n      labels: results.labels || [],\n      insertions: results.insertions || [],\n      connections: results.connections || []\n    };\n  }\n  addResultItem(newItem, relatedConnections = []) {\n    const {\n      insertions,\n      labels,\n      connections\n    } = this.results;\n    const {\n      type\n    } = newItem;\n    switch (true) {\n      case isLabel(type):\n        {\n          labels.unshift(newItem);\n          labels.sort((a, b) => a.start - b.start);\n          relatedConnections.forEach(connection => {\n            connections.unshift(connection);\n          });\n          break;\n        }\n      case isConnection(type):\n        {\n          connections.unshift(newItem);\n          break;\n        }\n      case isInsertion(type):\n        {\n          insertions.unshift(newItem);\n          insertions.sort((a, b) => a.at - b.at);\n          relatedConnections.forEach(connection => {\n            connections.unshift(connection);\n          });\n          break;\n        }\n      default:\n        break;\n    }\n  }\n  deleteTag(type, id) {\n    const {\n      connections,\n      labels,\n      insertions\n    } = this.results;\n    switch (true) {\n      case isLabel(type):\n        {\n          const index = findIndex(labels, {\n            id\n          });\n          const label = labels[index];\n          labels.splice(index, 1);\n          const nextConnections = connections.filter(connection => connection.fromId !== id && connection.toId !== id);\n          const relatedConnections = xor(connections, nextConnections);\n          this.results.connections = nextConnections;\n          return {\n            relatedConnections,\n            label\n          };\n        }\n      case isConnection(type):\n        {\n          const index = findIndex(connections, {\n            id\n          });\n          const connection = connections[index];\n          connections.splice(index, 1);\n          return {\n            connection\n          };\n        }\n      case isInsertion(type):\n        {\n          const index = findIndex(insertions, {\n            id\n          });\n          const insertion = insertions[index];\n          insertions.splice(index, 1);\n          const nextConnections = connections.filter(connection => connection.fromId !== id && connection.toId !== id);\n          const relatedConnections = xor(connections, nextConnections);\n          this.results.connections = nextConnections;\n          return {\n            relatedConnections,\n            insertion\n          };\n        }\n      default:\n        break;\n    }\n  }\n  getItemById(id) {\n    const {\n      labels,\n      insertions,\n      connections\n    } = this.results;\n    const {\n      missing\n    } = this.rootStore.review.reviews;\n    const targetArr = [];\n    return targetArr.concat(missing).concat(labels).concat(insertions).concat(connections).find(item => item.id === id);\n  }\n  getItem(type, id) {\n    const {\n      labels,\n      insertions,\n      connections\n    } = this.results;\n    const {\n      missing\n    } = this.rootStore.review.reviews;\n    switch (true) {\n      case isQATag(type):\n        {\n          const index = findIndex(missing, {\n            id\n          });\n          return missing[index];\n        }\n      case isLabel(type):\n        {\n          const index = findIndex(labels, {\n            id\n          });\n          return labels[index];\n        }\n      case isConnection(type):\n        {\n          const index = findIndex(connections, {\n            id\n          });\n          return connections[index];\n        }\n      case isInsertion(type):\n        {\n          const index = findIndex(insertions, {\n            id\n          });\n          return insertions[index];\n        }\n      default:\n        return null;\n    }\n  }\n  stepToTag(id, step) {\n    const {\n      labels,\n      connections,\n      insertions\n    } = this.results;\n    const {\n      missing\n    } = this.rootStore.review.reviews;\n    let targetList;\n    switch (true) {\n      case isQATag(id):\n        targetList = missing;\n        break;\n      case isLabel(id):\n        targetList = labels;\n        break;\n      case isConnection(id):\n        targetList = connections;\n        break;\n      case isInsertion(id):\n        targetList = insertions;\n        break;\n      default:\n        break;\n    }\n    if (!targetList) {\n      return null;\n    }\n    const index = findIndex(targetList, {\n      id\n    });\n    return getNextInLoopList(targetList, index, step);\n  }\n  moveToTagByStep(id, step, reviewOnly = false) {\n    const {\n      labels,\n      connections,\n      insertions\n    } = this.results;\n    const {\n      missing,\n      data\n    } = this.rootStore.review.reviews;\n    if (reviewOnly) {\n      const list = Object.keys(data).map(key => this.getItem(TAG.LABEL_QA, key)).sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n      if (!data[id]) {\n        // if id is not reviewed item then start from 0\n        return list[0];\n      }\n      return getNextInLoopList(list, findIndex(list, {\n        id\n      }), step);\n    }\n    let list = [];\n    list = list.concat(missing).concat(labels).concat(connections).concat(insertions);\n    list.sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n    return getNextInLoopList(list, findIndex(list, {\n      id\n    }), step);\n  }\n  tagMove(prevStart, prevEnd, offset) {\n    const {\n      text\n    } = this;\n    this.results.labels = this.results.labels.map(label => {\n      const newLabel = {\n        ...label\n      };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) {\n        // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) {\n        // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) {\n        // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.map(insertion => {\n      const newInsertion = {\n        ...insertion\n      };\n      // insertions behind slice\n      if (insertion.at >= prevEnd) {\n        newInsertion.at += offset;\n      } else if (insertion.at > prevStart && insertion.at < prevEnd) newInsertion.dirty = true; // insertions contained slice\n      // insertions before slice\n      // nothing happened\n      if (insertion.at > prevStart - 5 && insertion.at < prevEnd + 5) {\n        newInsertion.text = getTextByInsertion(text, {\n          at: newInsertion.at,\n          value: newInsertion.value\n        });\n      }\n      return newInsertion;\n    });\n    this.rootStore.review.reviews.missing = this.rootStore.review.reviews.missing.map(label => {\n      const newLabel = {\n        ...label\n      };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) {\n        // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) {\n        // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) {\n        // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.filter(insertion => !insertion.dirty);\n    this.results.labels = this.results.labels.filter(label => !label.dirty);\n    this.rootStore.review.reviews.missing = this.rootStore.review.reviews.missing.filter(label => !label.dirty);\n  }\n}","map":{"version":3,"names":["makeAutoObservable","toJS","xor","findIndex","isEqual","substr","strlen","v4","uuidv4","ReviewItemResult","TAG","MISSING_LABEL","generateConfigKeyByKeys","getConfigByKeys","getNextInLoopList","getTextByInsertion","isConnection","isInsertion","isLabel","isQATag","localMessage","missKeys","keys","OntologyStore","constructor","rootStore","ontologyConfigMap","Map","ontologiesStatusMap","ontologies","results","labels","insertions","connections","text","formatOntologyItem","ontologyItem","type","result","forEach","item","newKeys","push","children","restProps","newOntologyItem","length","updateOntologiesCollapseStatus","collapseStatus","configKey","currentStatus","get","set","isCollapse","updateOntologiesStatusMap","getItemPosition","start","at","startTag","getItem","fromType","fromId","autoBind","getOntologiesStatusMap","init","payload","content","formatOntologies","generateConfigMap","formattedLabels","LABEL","formattedInsertions","INSERTION","formattedConnections","CONNECTION","reviewable","isRework","missingLabel","LABEL_QA","labels_qa","generateConfigMapItem","tags","key","isChild","childKeys","tag","newKey","newTag","color","displayName","childKeysArr","calcCountItem","ontology","missing","review","reviews","newItem","tagCount","tagCountContainChildren","rejectCount","rejectCountContainChildren","approveCount","childRejectCount","childTagCount","label","getReview","id","REJECT","PASS","insertion","connection","childCountInfo","calcCount","Object","values","updateOntologiesCollapseStatusAll","value","parseResults","newResult","_newResult$labels","_newResult$labels2","_newResult$insertions","_newResult$insertions2","_newResult$connection","_newResult$connection2","_getConfigByKeys","Number","isNaN","dirty","end","filter","_getConfigByKeys2","_getConfigByKeys3","from","target","getItemById","toId","to","toType","console","log","getResults","withMissing","allLabels","concat","map","setResults","newResults","JSON","parse","stringify","addResultItem","relatedConnections","unshift","sort","a","b","deleteTag","index","splice","nextConnections","targetArr","find","stepToTag","step","targetList","moveToTagByStep","reviewOnly","data","list","tagMove","prevStart","prevEnd","offset","newLabel","newInsertion"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/editable-text/store/OntologyStore.ts"],"sourcesContent":["import { makeAutoObservable, toJS } from 'mobx';\nimport { xor, findIndex, isEqual } from 'lodash';\nimport { substr, strlen } from 'fbjs/lib/UnicodeUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport RootStore from './RootStore';\nimport { ConnectionItem, InsertionItem, LabelItem, MissingItem, Ontologies, OntologiesStatus, OntologyConfigMap, OntologyItem, OntologyItemPayLoad, OntologyItemType, OntologyResult, Payload, ReviewDataItem, ReviewItemResult, ReviewResult, TAG } from '../types';\nimport { MISSING_LABEL } from './constant';\nimport { generateConfigKeyByKeys, getConfigByKeys, getNextInLoopList, getTextByInsertion } from '../utils/helper';\nimport { isConnection, isInsertion, isLabel, isQATag } from './tag_mode';\nimport localMessage from '../locale';\n\nconst missKeys = generateConfigKeyByKeys(MISSING_LABEL.keys);\n/**\n * store for config\n * @class\n */\nexport default class OntologyStore {\n  /**\n   * root store\n   */\n  rootStore;\n\n  ontologyConfigMap = new Map();\n\n  ontologiesStatusMap: Map<string, OntologiesStatus> = new Map();\n\n  ontologies: Ontologies | undefined;\n\n  results: OntologyResult = { labels: [], insertions: [], connections: [] };\n\n  text = '';\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  getOntologiesStatusMap() {\n    return toJS(this.ontologiesStatusMap);\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload: Payload) {\n    const { labels, insertions, connections, content } = payload;\n\n    this.text = content;\n    this.formatOntologies(labels, insertions, connections);\n    this.generateConfigMap(labels, insertions, connections);\n  }\n\n  formatOntologyItem = (ontologyItem: OntologyItemPayLoad[] | undefined, type: OntologyItemType, keys: string[] = []) => {\n    if (!ontologyItem) {\n      return [];\n    }\n    const result: OntologyItem[] = [];\n    ontologyItem.forEach((item) => {\n      const newKeys = [...keys];\n      newKeys.push(item.text);\n      const { children, ...restProps } = item;\n      const newOntologyItem: OntologyItem = {\n        ...restProps,\n        type,\n        keys: newKeys\n      };\n      if (item.children && item.children.length > 0) {\n        newOntologyItem.children = this.formatOntologyItem(item.children, type, newKeys);\n      }\n      result.push(newOntologyItem);\n    });\n    return result;\n  };\n\n  formatOntologies(labels: OntologyItemPayLoad[] | undefined, insertions: OntologyItemPayLoad[] | undefined, connections: OntologyItemPayLoad[] | undefined) {\n    const formattedLabels = this.formatOntologyItem(labels, TAG.LABEL);\n    const formattedInsertions = this.formatOntologyItem(insertions, TAG.INSERTION);\n    const formattedConnections = this.formatOntologyItem(connections, TAG.CONNECTION);\n    if (this.rootStore.reviewable || this.rootStore.isRework) {\n      const missingLabel: OntologyItem[] = [{ ...MISSING_LABEL, type: TAG.LABEL_QA, text: localMessage(MISSING_LABEL.text) }];\n      this.ontologies = { labels_qa: missingLabel };\n    }\n    this.ontologies = {\n      ...this.ontologies,\n      labels: formattedLabels,\n      insertions: formattedInsertions,\n      connections: formattedConnections\n    };\n  };\n\n  generateConfigMap(labels: OntologyItemPayLoad[] | undefined, insertions: OntologyItemPayLoad[] | undefined, connections: OntologyItemPayLoad[] | undefined) {\n    if (this.rootStore.reviewable || this.rootStore.isRework) {\n      this.ontologyConfigMap.set(generateConfigKeyByKeys(MISSING_LABEL.keys), { ...MISSING_LABEL, type: TAG.LABEL_QA, text: localMessage(MISSING_LABEL.text) });\n    }\n    if (labels) { this.generateConfigMapItem(labels, TAG.LABEL); }\n    if (insertions) { this.generateConfigMapItem(insertions, TAG.INSERTION); }\n    if (connections) { this.generateConfigMapItem(connections, TAG.CONNECTION); }\n  };\n\n  generateConfigMapItem(tags: OntologyItemPayLoad[], type: OntologyItemType, key: string[] = [], isChild = false, childKeys: string[] = []) {\n    tags.forEach((tag) => {\n      childKeys.push(tag.text);\n      let newKey = [...key];\n      newKey.push(tag.text);\n      const newTag: OntologyConfigMap = {\n        type,\n        color: tag.color,\n        displayName: tag.displayName,\n        text: tag.text,\n        isChild,\n        keys: newKey,\n        childKeys: []\n      };\n\n      if (tag.children && tag.children.length > 0) {\n        const childKeysArr = this.generateConfigMapItem(tag.children, type, newKey, true);\n        newTag.childKeys = childKeysArr;\n        this.ontologyConfigMap.set(generateConfigKeyByKeys(newKey), newTag);\n      } else {\n        this.ontologyConfigMap.set(generateConfigKeyByKeys(newKey), newTag);\n\n        newKey = [];\n      }\n    });\n    return childKeys;\n  };\n\n  calcCountItem(ontology: OntologyItem) {\n    const { labels, insertions, connections } = this.results;\n    const { missing } = this.rootStore.review.reviews;\n    const { keys, type, children } = ontology;\n    const configKey = generateConfigKeyByKeys(keys);\n    const currentStatus = this.ontologiesStatusMap.get(configKey);\n    const newItem: OntologiesStatus = {\n      isCollapse: true,\n      keys,\n      tagCount: 0,\n      tagCountContainChildren: 0,\n      rejectCount: 0,\n      rejectCountContainChildren: 0,\n      approveCount: 0,\n    };\n    if (currentStatus) {\n      newItem.isCollapse = currentStatus.isCollapse;\n      newItem.keys = currentStatus.keys;\n    }\n    let tagCount = 0;\n    let rejectCount = 0;\n    let childRejectCount = 0;\n    let childTagCount = 0;\n    let approveCount = 0;\n\n    if (type === TAG.LABEL_QA) {\n      tagCount = missing.length;\n      this.ontologiesStatusMap.set(missKeys,\n        {\n          isCollapse: false, keys: MISSING_LABEL.keys, tagCount\n        });\n    }\n    if (type === TAG.LABEL) {\n      labels.forEach((label) => {\n        if (isEqual(label.keys, keys)) {\n          tagCount += 1;\n          const review = this.rootStore.review.getReview(label.id);\n          if (review) {\n            if (review.result === ReviewItemResult.REJECT) {\n              rejectCount += 1;\n            } else if (review?.result === ReviewItemResult.PASS) {\n              approveCount += 1;\n            }\n          }\n        }\n      });\n    }\n    if (type === TAG.INSERTION) {\n      insertions.forEach((insertion) => {\n        if (isEqual(insertion.keys, keys)) {\n          tagCount += 1;\n          const review = this.rootStore.review.getReview(insertion.id);\n          if (review) {\n            if (review.result === ReviewItemResult.REJECT) {\n              rejectCount += 1;\n            } else if (review?.result === ReviewItemResult.PASS) {\n              approveCount += 1;\n            }\n          }\n        }\n      });\n    }\n    if (type === TAG.CONNECTION) {\n      connections.forEach((connection) => {\n        if (isEqual(connection.keys, keys)) {\n          tagCount += 1;\n          const review = this.rootStore.review.getReview(connection.id);\n          if (review) {\n            if (review.result === ReviewItemResult.REJECT) {\n              rejectCount += 1;\n            } else if (review?.result === ReviewItemResult.PASS) {\n              approveCount += 1;\n            }\n          }\n        }\n      });\n    }\n    if (children && children.length > 0) {\n      const childCountInfo = this.calcCount(children);\n      childRejectCount = childCountInfo.rejectCount;\n      childTagCount = childCountInfo.tagCount;\n    }\n    newItem.tagCount = tagCount;\n    newItem.rejectCount = rejectCount;\n    newItem.approveCount = approveCount;\n    newItem.rejectCountContainChildren = rejectCount + childRejectCount;\n    newItem.tagCountContainChildren = tagCount + childTagCount;\n    return { configKey, newItem };\n  }\n\n  calcCount(ontologies: OntologyItem[]) {\n    const result = {\n      rejectCount: 0,\n      tagCount: 0,\n    };\n    ontologies.forEach((ontology: OntologyItem) => {\n      const { configKey, newItem } = this.calcCountItem(ontology);\n      this.ontologiesStatusMap.set(configKey, newItem);\n      result.tagCount += newItem.tagCountContainChildren!;\n      result.rejectCount += newItem.rejectCountContainChildren!;\n    });\n    return result;\n  }\n\n  updateOntologiesStatusMap() {\n    if (!this.ontologies) {\n      return;\n    }\n    Object.values(this.ontologies).forEach((ontologies) => {\n      this.calcCount(ontologies);\n    });\n  }\n\n  updateOntologiesCollapseStatusAll(collapseStatus: boolean) {\n    this.ontologiesStatusMap.forEach((value, key) => {\n      if (key !== missKeys) {\n        value.isCollapse = collapseStatus;\n      }\n    });\n    this.updateOntologiesStatusMap();\n  }\n\n  updateOntologiesCollapseStatus = (keys: string[], collapseStatus: boolean) => {\n    const configKey = generateConfigKeyByKeys(keys);\n    const currentStatus = this.ontologiesStatusMap.get(configKey);\n    if (!currentStatus) {\n      return;\n    }\n    this.ontologiesStatusMap.set(configKey, { ...currentStatus, isCollapse: collapseStatus });\n    this.updateOntologiesStatusMap();\n  };\n\n  parseResults(newResult: OntologyResult) {\n    if (!newResult) return;\n    const { results } = this;\n    const length = strlen(this.text);\n    // parse label\n    newResult.labels?.forEach((label) => {\n      // invalid start & end\n      if (typeof (label) !== 'object') return;\n      if (Number.isNaN(label.start) || label.start === null || label.start < 0 || label.start >= length) {\n        label.dirty = true;\n        return;\n      }\n      if (Number.isNaN(label.end) || label.end === null || label.end < 0 || label.end >= length + 1) {\n        label.dirty = true;\n        return;\n      }\n\n      if (!label.keys) {\n        this.ontologyConfigMap.forEach((value, key) => {\n          const keys = value.keys;\n          if (keys[keys.length - 1] === label.value) {\n            label.keys = value.keys;\n          }\n        });\n      }\n      // invalid value\n      if (!isLabel(getConfigByKeys(this.ontologyConfigMap, label.keys)?.type)) {\n        label.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      if (!label.id) {\n        label.id = uuidv4();\n      }\n      if (!label.type) {\n        label.type = TAG.LABEL;\n      }\n      // missing text\n      if (!label.text) label.text = substr(this.text, label.start, label.end - label.start);\n    });\n    if (!results?.labels) {\n      results.labels = [];\n    }\n    results.labels = newResult.labels?.filter((label) => typeof (label) === 'object' && !label.dirty) || [];\n\n    // parse insertion\n    newResult.insertions?.forEach((insertion) => {\n      // invalid start & end\n      if (typeof (insertion) !== 'object') return;\n      if (Number.isNaN(insertion.at) || insertion.at === null || insertion.at < 0 || insertion.at >= length) {\n        insertion.dirty = true;\n        return;\n      }\n      if (!insertion.keys) {\n        this.ontologyConfigMap.forEach((value, key) => {\n          const keys = value.keys;\n          if (keys[keys.length - 1] === insertion.value) {\n            insertion.keys = value.keys;\n          }\n        });\n      }\n      // invalid value\n      if (!isInsertion(getConfigByKeys(this.ontologyConfigMap, insertion.keys)?.type)) {\n        insertion.dirty = true;\n        return;\n      }\n      // invalid & missing id\n      if (!insertion.id) {\n        insertion.id = uuidv4();\n      }\n      if (!insertion.type) {\n        insertion.type = TAG.INSERTION;\n      }\n      // missing text\n      if (!insertion.text) insertion.text = getTextByInsertion(this.text, insertion);\n    });\n    if (!results?.insertions) {\n      results.insertions = [];\n    }\n    results.insertions = newResult.insertions?.filter((insertion) => typeof (insertion) === 'object' && !insertion.dirty) || [];\n    // parse connection\n    newResult.connections?.forEach((connection) => {\n      // invalid start & end\n      if (typeof (connection) !== 'object') return;\n\n      if (!connection.keys) {\n        this.ontologyConfigMap.forEach((value, key) => {\n          const keys = value.keys;\n          if (keys[keys.length - 1] === connection.value) {\n            connection.keys = value.keys;\n          }\n        });\n      }\n      if (!connection.fromId && connection.from) {\n        connection.fromId = connection.from;\n      }\n      if (!connection.fromType && connection.from) {\n        const target = this.getItemById(connection.from);\n        if (target) {\n          connection.fromType = target.type;\n        }\n      }\n      if (!connection.toId && connection.to) {\n        connection.toId = connection.to;\n      }\n      if (!connection.toType && connection.to) {\n        const target = this.getItemById(connection.to);\n        if (target) {\n          connection.toType = target.type;\n        }\n      }\n      // invalid value\n      if (!isConnection(getConfigByKeys(this.ontologyConfigMap, connection.keys)?.type)) {\n        connection.dirty = true;\n        return;\n      }\n      // invalid from & to\n      if (findIndex(newResult.labels, { id: connection.fromId }) === -1 && findIndex(newResult.insertions, { id: connection.fromId }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      if (findIndex(newResult.labels, { id: connection.toId }) === -1 && findIndex(newResult.insertions, { id: connection.toId }) === -1) {\n        connection.dirty = true;\n        return;\n      }\n      if (!connection.type) {\n        connection.type = TAG.CONNECTION;\n      }\n      // invalid & missing id\n      if (!connection.id) {\n        connection.id = uuidv4();\n      }\n    });\n    if (!results?.connections) {\n      results.connections = [];\n    }\n    results.connections = newResult.connections?.filter((connection) => typeof (connection) === 'object' && !connection.dirty) || [];\n    console.log('results parse', results)\n  }\n\n  getResults(withMissing = true) {\n    const { labels, insertions, connections } = this.results;\n    const { missing } = this.rootStore.review.reviews;\n    let allLabels = labels;\n    if (withMissing) {\n      allLabels = labels.concat(missing);\n    }\n    return {\n      labels: allLabels.map((item) => toJS(item)),\n      insertions: insertions.map((item) => toJS(item)),\n      connections: connections.map((item) => toJS(item)),\n    };\n  }\n\n  setResults(newResults = {}) {\n    const results = JSON.parse(JSON.stringify(newResults));\n    this.results = {\n      labels: results.labels || [],\n      insertions: results.insertions || [],\n      connections: results.connections || [],\n    };\n  }\n\n  addResultItem(newItem: LabelItem | InsertionItem | ConnectionItem, relatedConnections = []) {\n    const { insertions, labels, connections } = this.results;\n    const { type } = newItem;\n    switch (true) {\n      case (isLabel(type)): {\n        labels.unshift(newItem as LabelItem);\n        labels.sort((a, b) => (a.start - b.start));\n        relatedConnections.forEach((connection) => {\n          connections.unshift((connection));\n        });\n        break;\n      }\n      case (isConnection(type)): {\n        connections.unshift(newItem as ConnectionItem);\n        break;\n      }\n      case (isInsertion(type)): {\n        insertions.unshift(newItem as InsertionItem);\n        insertions.sort((a, b) => a.at - b.at);\n        relatedConnections.forEach((connection) => {\n          connections.unshift(connection);\n        });\n        break;\n      }\n      default: break;\n    }\n  }\n\n  deleteTag(type: OntologyItemType, id: string) {\n    const { connections, labels, insertions } = this.results;\n\n    switch (true) {\n      case (isLabel(type)): {\n        const index = findIndex(labels, { id });\n        const label = labels[index];\n        labels.splice(index, 1);\n        const nextConnections = connections.filter((connection) => connection.fromId !== id && connection.toId !== id);\n        const relatedConnections = xor(connections, nextConnections);\n        this.results.connections = nextConnections;\n        return { relatedConnections, label };\n      }\n      case (isConnection(type)): {\n        const index = findIndex(connections, { id });\n        const connection = connections[index];\n        connections.splice(index, 1);\n        return { connection };\n      }\n      case (isInsertion(type)): {\n        const index = findIndex(insertions, { id });\n        const insertion = insertions[index];\n        insertions.splice(index, 1);\n        const nextConnections = connections.filter((connection) => connection.fromId !== id && connection.toId !== id);\n        const relatedConnections = xor(connections, nextConnections);\n        this.results.connections = nextConnections;\n\n        return { relatedConnections, insertion };\n      }\n      default:\n        break;\n    }\n  }\n\n  getItemById(id: string) {\n    const { labels, insertions, connections } = this.results;\n    const { missing } = this.rootStore.review.reviews;\n    const targetArr: (MissingItem | LabelItem | InsertionItem | ConnectionItem)[] = [];\n    return targetArr.concat(missing).concat(labels).concat(insertions).concat(connections)\n      .find((item) => item.id === id);\n  }\n\n  getItem(type: OntologyItemType, id: string) {\n    const { labels, insertions, connections } = this.results;\n    const { missing } = this.rootStore.review.reviews;\n    switch (true) {\n      case (isQATag(type)): {\n        const index = findIndex(missing, { id });\n        return missing[index];\n      }\n      case (isLabel(type)): {\n        const index = findIndex(labels, { id });\n        return labels[index];\n      }\n      case (isConnection(type)): {\n        const index = findIndex(connections, { id });\n        return connections[index];\n      }\n      case (isInsertion(type)): {\n        const index = findIndex(insertions, { id });\n        return insertions[index];\n      }\n      default: return null;\n    }\n  }\n\n  stepToTag(id: string, step: number) {\n    const { labels, connections, insertions } = this.results;\n    const { missing } = this.rootStore.review.reviews;\n    let targetList: (MissingItem | LabelItem | ConnectionItem | InsertionItem)[] | undefined;\n    switch (true) {\n      case (isQATag(id)): targetList = missing; break;\n      case (isLabel(id)): targetList = labels; break;\n      case (isConnection(id)): targetList = connections; break;\n      case (isInsertion(id)): targetList = insertions; break;\n      default: break;\n    }\n    if (!targetList) {\n      return null;\n    }\n    const index = findIndex(targetList, { id });\n\n    return getNextInLoopList(targetList, index, step);\n  }\n\n  getItemPosition = (item: MissingItem | LabelItem | ConnectionItem | InsertionItem | null): number => {\n    if (!item) {\n      return -1;\n    }\n    if (isLabel(item.type)) {\n      return (item as LabelItem | MissingItem).start;\n    }\n    if (isInsertion(item.type)) {\n      return (item as InsertionItem).at;\n    }\n    if (isConnection(item.type)) {\n      const startTag = this.getItem((item as ConnectionItem).fromType, (item as ConnectionItem).fromId);\n      return this.getItemPosition(startTag);\n    }\n    return -1;\n  };\n\n  moveToTagByStep(id: string, step: number, reviewOnly = false) {\n    const { labels, connections, insertions } = this.results;\n    const { missing, data } = this.rootStore.review.reviews;\n\n    if (reviewOnly) {\n      const list = Object.keys(data).map((key) => this.getItem(TAG.LABEL_QA, key))\n        .sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n      if (!data[id]) { // if id is not reviewed item then start from 0\n        return list[0];\n      }\n      return getNextInLoopList(list, findIndex(list, { id }), step);\n    }\n\n    let list: (MissingItem | LabelItem | ConnectionItem | InsertionItem)[] = [];\n    list = list.concat(missing).concat(labels).concat(connections).concat(insertions);\n    list.sort((a, b) => this.getItemPosition(a) - this.getItemPosition(b));\n    return getNextInLoopList(list, findIndex(list, { id }), step);\n  }\n\n  tagMove(prevStart: number, prevEnd: number, offset: number) {\n    const { text } = this;\n    this.results.labels = this.results.labels.map((label) => {\n      const newLabel = { ...label };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) { // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) { // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) { // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.map((insertion) => {\n      const newInsertion = { ...insertion };\n      // insertions behind slice\n      if (insertion.at >= prevEnd) {\n        newInsertion.at += offset;\n      } else if (insertion.at > prevStart && insertion.at < prevEnd) newInsertion.dirty = true; // insertions contained slice\n      // insertions before slice\n      // nothing happened\n      if (insertion.at > prevStart - 5 && insertion.at < prevEnd + 5) {\n        newInsertion.text = getTextByInsertion(text, { at: newInsertion.at, value: newInsertion.value });\n      }\n      return newInsertion;\n    });\n    this.rootStore.review.reviews.missing = this.rootStore.review.reviews.missing.map((label) => {\n      const newLabel = { ...label };\n      // labels overlap & before slice\n      if (label.start < prevStart && label.end > prevStart && label.end <= prevEnd) {\n        newLabel.end = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start >= prevStart && label.end <= prevEnd) newLabel.dirty = true; // labels contained slice\n      else if (label.start >= prevStart && label.start < prevEnd && label.end > prevEnd) { // labels overlap & behind slice\n        newLabel.end += offset;\n        newLabel.start = prevEnd + offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start < prevStart && label.end > prevEnd) { // labels contain slice\n        newLabel.end += offset;\n        newLabel.text = substr(text, newLabel.start, newLabel.end - newLabel.start);\n      } else if (label.start > prevEnd) { // labels behind slice\n        newLabel.end += offset;\n        newLabel.start += offset;\n      }\n      // labels before slice\n      // nothing happened\n      return newLabel;\n    });\n    this.results.insertions = this.results.insertions.filter((insertion) => !insertion.dirty);\n    this.results.labels = this.results.labels.filter((label) => !label.dirty);\n    this.rootStore.review.reviews.missing = this.rootStore.review.reviews.missing.filter((label) => !label.dirty);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}