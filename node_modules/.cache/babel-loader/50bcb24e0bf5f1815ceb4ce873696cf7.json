{"ast":null,"code":"import { Point, Text, BitmapText, Rectangle } from 'pixi.js';\nimport Flatten from '@flatten-js/core';\n// import simplify from 'simplify-js';\nimport { cloneDeep } from 'lodash';\nimport polygonClipping from 'polygon-clipping';\nimport pointOnLine from '@turf/boolean-point-on-line';\nimport { lineString, point as turfPoint } from '@turf/helpers';\nimport Shape, { EventAction } from './Shape';\nimport { ShapeType } from './types';\nimport ControlPoint from './controls/ControlPoint';\nimport { precise, normalizePoints } from './utils';\nimport Cursor from '../Cursor';\nexport let PolygonType = /*#__PURE__*/function (PolygonType) {\n  PolygonType[\"DEFAULT\"] = \"default\";\n  PolygonType[\"RECOGNITION\"] = \"recognition\";\n  return PolygonType;\n}({});\n/**\n * Polygon shape\n * @class\n */\nexport default class Polygon extends Shape {\n  /**\n   * get is cutting\n   * @getter\n   */\n  get isCutting() {\n    return this._isCutting;\n  }\n\n  /**\n   * set is cutting\n   * @setter\n   */\n  set isCutting(cutting) {\n    this._isCutting = cutting;\n    this.cuttingOtherPolygon = null;\n    this.draggable = !cutting;\n    if (cutting) {\n      // add event listener\n      this.app.view.addEventListener('mousedown', this._viewMouseDown, false);\n      this.app.view.addEventListener('mousemove', this._viewMouseMove, false);\n      this.app.view.addEventListener('mouseup', this._viewMouseUp, false);\n    } else {\n      // remove event listener\n      this.app.view.removeEventListener('mousedown', this._viewMouseDown, false);\n      this.app.view.removeEventListener('mousemove', this._viewMouseMove, false);\n      this.app.view.removeEventListener('mouseup', this._viewMouseUp, false);\n    }\n    if (this._cutPathPoints.length > 0) {\n      // remove cutting path\n      this._cutPathPoints = [];\n      this.drawShape();\n    }\n    // remove selected control\n    this._controls.forEach(c => {\n      if (cutting) {\n        c.control.interactive = false;\n        if (c.selected) {\n          c.selected = false;\n        }\n      } else {\n        c.control.interactive = true;\n      }\n    });\n  }\n\n  /**\n   * get points\n   * @getter\n   */\n  get points() {\n    return this._points.map(p => ({\n      x: p.x,\n      y: p.y,\n      ...(p.userData && {\n        userData: p.userData\n      })\n    }));\n  }\n\n  /**\n   * set points\n   * @setter\n   */\n  set points(points) {\n    this._points = points.map(p => ({\n      x: p.x,\n      y: p.y,\n      userData: cloneDeep(p.userData)\n    }));\n    this.normalize();\n  }\n\n  /**\n   * get position\n   * @getter\n   */\n  get position() {\n    return new Point(this._points[0].x, this._points[0].y);\n  }\n\n  /**\n   * set position\n   * @setter\n   */\n  set position(point) {\n    const offsetX = point.x - this._points[0].x;\n    const offsetY = point.y - this._points[0].y;\n    this._points.forEach(p => {\n      p.x = precise(p.x + offsetX);\n      p.y = precise(p.y + offsetY);\n    });\n    this.updateGeometory();\n    this.drawShape();\n  }\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  get shapeBounds() {\n    const shapePoints = this.points;\n    const left = Math.min(...shapePoints.map(p => p.x));\n    const right = Math.max(...shapePoints.map(p => p.x));\n    const top = Math.min(...shapePoints.map(p => p.y));\n    const bottom = Math.max(...shapePoints.map(p => p.y));\n    return {\n      left,\n      top,\n      right,\n      bottom\n    };\n  }\n\n  /**\n   * shape area\n   * @getter\n   */\n  get area() {\n    return this._geometory.faces.values().next().value.area();\n  }\n\n  /**\n   * set styles for point\n   */\n\n  constructor(options) {\n    super(options);\n    this.shapeType = ShapeType.POLYGON;\n    /**\n     * polygon points\n     * @private\n     */\n    this._points = [];\n    /**\n     * polygon creating type\n     * @private\n     */\n    this._polygonType = PolygonType.DEFAULT;\n    /**\n     * default polygon edges count\n     * @private\n     */\n    this._defaultEdges = void 0;\n    /**\n     * indicate next point when creating\n     * @private\n     */\n    this._nextPoint = null;\n    /**\n     * is mouse down\n     * @private\n     */\n    this._isDown = false;\n    /**\n     * is dragging\n     * @private\n     */\n    this._isDragging = false;\n    /**\n     * is created by dragging\n     * @private\n     */\n    this._createdByDragging = false;\n    /**\n     * rectangle used for recognition\n     * @private\n     */\n    this._recognitionRect = null;\n    /**\n     * rectangle finished\n     * @private\n     */\n    this._recognitionRectFinished = false;\n    /**\n     * control points used for recognition\n     * @private\n     */\n    this._recognitionControlPoints = [];\n    /**\n     * control points adding mode\n     */\n    this._recognitionControlMode = 'none';\n    /**\n     * mouse down on recognition controls\n     */\n    this._isRecognitionConrtolDown = false;\n    /**\n     * control instances for recognition\n     */\n    this._recognitionControls = [];\n    /**\n     * polygon geometory data\n     */\n    this._geometory = new Flatten.Polygon();\n    /**\n     * cut path points\n     */\n    this._cutPathPoints = [];\n    /**\n     * is polygon in cut mode\n     */\n    this._isCutting = false;\n    /**\n     * is key v down\n     */\n    this._vKeyDown = false;\n    /**\n     * is key h down\n     */\n    this._hKeyDown = false;\n    /**\n     * cutting mode\n     */\n    this.cuttingMode = 'cut';\n    /**\n     * other polygon by cutting\n     */\n    this.cuttingOtherPolygon = null;\n    this.pointStyler = void 0;\n    /**\n     * set styles for edge\n     */\n    this.edgeStyler = void 0;\n    /**\n     * mouse down listener when creating\n     * @private\n     */\n    this._mouseDown = e => {\n      if (e.button === 0 && !this._isRecognitionConrtolDown) {\n        // not right click, not recognition control click\n        this._isDown = true;\n      }\n    };\n    /**\n     * mouse move listener when creating\n     * @private\n     * @param event\n     */\n    this._mouseMove = event => {\n      if (this._isDown) {\n        this._isDragging = true;\n      }\n      let localPoint = this.globalSnappingPoint;\n      if (!localPoint) {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        localPoint = this._mapStageToLocalPosition(point);\n      }\n      const p = this._straighten(this._keepPointInBounds(localPoint), this._points[this._points.length - 1]);\n      if (this._isDragging) {\n        // add point directly when dragging to draw a polygon\n        const lastPoint = this.points[this.points.length - 1] || {\n          x: 0,\n          y: 0\n        };\n        const tolerance = 10 / this.scale;\n        if (Math.abs(p.x - lastPoint.x) > tolerance || Math.abs(p.y - lastPoint.y) > tolerance) {\n          this._createdByDragging = true;\n          this.addPoint(p);\n        }\n        this._nextPoint = null;\n      } else {\n        this._nextPoint = p;\n        this.drawShape();\n      }\n    };\n    /**\n     * mouse up listener when creating\n     * @private\n     * @param event\n     */\n    this._mouseUp = event => {\n      if (this._isDown && !this._isDragging) {\n        let localPoint = this.globalSnappingPoint;\n        if (!localPoint) {\n          const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n          localPoint = this._mapStageToLocalPosition(point);\n        }\n        const p = this._straighten(this._keepPointInBounds(localPoint), this._points[this._points.length - 1]);\n        this.addPoint(p);\n      }\n      this._isDown = false;\n      this._isDragging = false;\n\n      // auto finish\n      if (this._defaultEdges !== undefined && this._points.length >= this._defaultEdges) {\n        this.finishCreate();\n      }\n    };\n    /**\n     * finish by double clicking\n     * @private\n     */\n    this._finishByDoubleClick = () => {\n      this.finishCreate();\n    };\n    /**\n     * key down handler\n     * @private\n     * @param e\n     */\n    this._keyDown = e => {\n      switch (e.key.toLowerCase()) {\n        case 'q':\n          if (!this._finished && this._polygonType === PolygonType.DEFAULT) {\n            e.preventDefault();\n            this.removePoint(this.points.length - 1);\n          }\n          break;\n        case 'enter':\n          if (!this._finished) {\n            e.preventDefault();\n            this.finishCreate();\n          }\n          break;\n        case 'v':\n          // e.preventDefault();\n          this._vKeyDown = true;\n          break;\n        case 'h':\n          // e.preventDefault();\n          this._hKeyDown = true;\n          break;\n        default:\n          break;\n      }\n    };\n    /**\n     * key up handler\n     */\n    this._keyUp = () => {\n      this._vKeyDown = false;\n      this._hKeyDown = false;\n    };\n    /**\n     * mouse move for recognition\n     * @param event\n     */\n    this._mouseMoveForRecognition = event => {\n      if (this._isDown && !this._recognitionRectFinished) {\n        // creating rectangle\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        const localPoint = this._mapStageToLocalPosition(point);\n        const p = this._keepPointInBounds(localPoint);\n        if (!this._recognitionRect) {\n          this._recognitionRect = new Rectangle(p.x, p.y, 0, 0);\n        } else {\n          this._recognitionRect.width = p.x - this._recognitionRect.x;\n          this._recognitionRect.height = p.y - this._recognitionRect.y;\n        }\n        this._drawRecognition();\n      }\n    };\n    /**\n     * mouse up for recognition\n     * @param event\n     */\n    this._mouseUpForRecognition = event => {\n      if (this._recognitionRect && !this._recognitionRectFinished) {\n        // finish creating rectangle\n        this._recognitionRectFinished = true;\n        // add default control point\n        const {\n          x,\n          y,\n          width,\n          height\n        } = this._recognitionRect;\n        this._recognitionControlPoints.push({\n          flag: true,\n          x: x + width / 2,\n          y: y + height / 2\n        });\n        this._drawRecognition();\n        this.recognition();\n      } else if (this._recognitionRect && this._recognitionRectFinished && this._isDown && this._recognitionControlMode !== 'none') {\n        // add control points\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        const {\n          x,\n          y\n        } = this._mapStageToLocalPosition(point);\n        const {\n          left,\n          top,\n          right,\n          bottom\n        } = this._recognitionRect;\n        if (x >= left && x <= right && y >= top && y <= bottom) {\n          // in rectangle\n          this._recognitionControlPoints.push({\n            flag: this._recognitionControlMode === 'plus',\n            x,\n            y\n          });\n          this._attachRecognitionControls();\n          this.recognition();\n        }\n      }\n      this._isDown = false;\n    };\n    /**\n     * finish create\n     */\n    this.finishCreate = () => {\n      this.normalize();\n      this._finish();\n      this._removeListeners();\n      this._resetRecognition();\n    };\n    /**\n     * mouse down on view\n     * @param event\n     */\n    this._viewMouseDown = event => {\n      if (event.button === 2) {\n        return;\n      }\n      if (this.isCutting) {\n        this._isDown = true;\n        if (this._snappingPoint) {\n          // click on the shape edge\n          if (this._cutPathPoints.length > 0) {\n            // end cut\n            if (this._cutPathPoints.length > 1) {\n              this._cutPathPoints.pop(); // remove moving point\n            }\n            this._cutPathPoints.push(this._snappingPoint);\n            this._finishCut();\n          } else {\n            // start cut\n            this._cutPathPoints.push(this._snappingPoint);\n          }\n        } else if (this._cutPathPoints.length > 0) {\n          // add point\n          let localPoint = this.globalSnappingPoint;\n          if (!localPoint) {\n            const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n            localPoint = this._mapStageToLocalPosition(point);\n          }\n          const p = this._keepPointInBounds(localPoint);\n          if (this.cuttingMode === 'split' && !this.instance.containsPoint(this.instance.toGlobal(p))) {\n            return;\n          }\n          if (this._cutPathPoints.length > 1) {\n            // last point is the moving point\n            this._cutPathPoints.splice(this._cutPathPoints.length - 1, 0, p);\n          } else {\n            this._cutPathPoints.push(p);\n          }\n        }\n      }\n    };\n    /**\n     * mouse move on view\n     * @param event\n     */\n    this._viewMouseMove = event => {\n      if (event.button === 2) {\n        return;\n      }\n      if (this.isCutting && this._cutPathPoints.length > 0) {\n        let localPoint = this.globalSnappingPoint;\n        if (!localPoint) {\n          const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n          localPoint = this._mapStageToLocalPosition(point);\n        }\n        const p = this._keepPointInBounds(localPoint);\n        if (this._isDown && this.cuttingMode !== 'split') {\n          const lastPoint = this._cutPathPoints[this._cutPathPoints.length - 1];\n          const tolerance = 10 / this.scale;\n          if (Math.abs(p.x - lastPoint.x) > tolerance || Math.abs(p.y - lastPoint.y) > tolerance) {\n            this._cutPathPoints.push(p);\n            this.drawShape();\n          }\n        } else {\n          if (this._cutPathPoints.length > 1) {\n            // remove last point\n            this._cutPathPoints.pop();\n          }\n          this._cutPathPoints.push(p);\n          this.drawShape();\n        }\n      }\n    };\n    /**\n     * mouse up on view\n     */\n    this._viewMouseUp = () => {\n      this._isDown = false;\n    };\n    const {\n      points,\n      polygonType = PolygonType.DEFAULT,\n      defaultEdges,\n      pointStyler,\n      edgeStyler\n    } = options;\n    this._polygonType = polygonType;\n    this._defaultEdges = defaultEdges;\n    this.pointStyler = pointStyler;\n    this.edgeStyler = edgeStyler;\n    if (Array.isArray(points) && points.every(p => p.x !== undefined && p.y !== undefined)) {\n      this.points = points;\n    }\n    document.addEventListener('keydown', this._keyDown, false);\n    document.addEventListener('keyup', this._keyUp, false);\n  }\n\n  /**\n   * get point style\n   * @param pointIndex\n   */\n  getPointStyle(pointIndex) {\n    let color = this.displayVertexColor;\n    let type = this.vertexType;\n    if (this.pointStyler) {\n      const {\n        userData\n      } = this._points[pointIndex];\n      const styles = this.pointStyler(pointIndex, userData, this);\n      if (styles.color) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n    }\n    return {\n      color,\n      type\n    };\n  }\n\n  /**\n   * get edge style\n   * @param pointIndex\n   */\n  getEdgeStyle(pointIndex) {\n    let color = this.displayBorderColor;\n    let type = this.borderType;\n    let bold = this.borderBold;\n    if (this.edgeStyler) {\n      const {\n        userData\n      } = this._points[pointIndex];\n      const styles = this.edgeStyler(pointIndex, userData, this);\n      if (styles.color && !this.selected && !this.hovered) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n      if (styles.bold) {\n        bold = true;\n      }\n    }\n    return {\n      color,\n      type,\n      bold\n    };\n  }\n\n  /**\n   * draw shape\n   */\n  drawShape() {\n    if (!this.finished && this._polygonType === PolygonType.RECOGNITION) {\n      // draw recognition\n      this._drawRecognition();\n      return;\n    }\n    this.instance.clear();\n    this._drawShapeFill();\n    this._drawShapeLine();\n    this._drawShapeVertex();\n    this._drawSnappingPoint();\n    this.drawPointUserData();\n    if (this._finished) {\n      this.drawShapeLabel();\n      this.attachControlPoints();\n      this._drawCutPath();\n    }\n  }\n\n  /**\n   * draw shape fill\n   * @private\n   */\n  _drawShapeFill() {\n    if (this._finished) {\n      this.instance.beginFill(this.fillColor, this.alpha);\n      this.instance.drawPolygon(this._points.map(({\n        x,\n        y\n      }) => new Point(x, y)));\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw shape border\n   * @private\n   */\n  _drawShapeLine() {\n    if (this._points.length === 0) return;\n    const baseWidth = this.borderWidth / this.scale;\n    const boldWidth = baseWidth * 4;\n    this.instance.moveTo(this._points[0].x, this._points[0].y);\n    this._points.slice(1).forEach((point, i) => {\n      const {\n        color,\n        type,\n        bold\n      } = this.getEdgeStyle(i);\n      this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n      this.instance.drawLine(point.x, point.y, this.borderStyle, type);\n    });\n    const {\n      color,\n      type,\n      bold\n    } = this.getEdgeStyle(this._points.length - 1);\n    this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n    if (this._finished) {\n      this.instance.drawLine(this._points[0].x, this._points[0].y, this.borderStyle, type);\n      // this.instance.closePath();\n    } else if (this._nextPoint) {\n      this.instance.drawLine(this._nextPoint.x, this._nextPoint.y, this.borderStyle, type);\n    }\n  }\n\n  /**\n   * draw shape vertexes\n   * @private\n   */\n  _drawShapeVertex() {\n    this.vertexesContainer.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n    const r = this.vertexSize / this.scale;\n    const offset = this.showVertex ? r : 4 / this.scale;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this._points.forEach((point, index) => {\n      if (this.showVertex && (!this.editable || !this.selected)) {\n        // draw vertex dot\n        const {\n          color,\n          type\n        } = this.getPointStyle(index);\n        this.instance.beginFill(color, this.borderAlpha);\n        this.instance.drawVertex(point.x, point.y, r, type);\n        this.instance.endFill();\n      }\n      if (this.showVertexOrder) {\n        // draw vertext order\n        const text = new BitmapText(`${this.vertexStart + index} `, {\n          fontName: 'ALPHA_NUMERIC'\n        });\n        text.scale.set(1 / this.scale);\n        text.position.set(point.x + offset, point.y + offset);\n        this.vertexesContainer.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * draw snapping point\n   */\n  _drawSnappingPoint() {\n    if (this._snappingPoint) {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(this._snappingPoint.x, this._snappingPoint.y, 3 / this.scale);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw point user data\n   */\n  drawPointUserData() {\n    this.userDataContainer.removeChildren();\n    let offsetX = 4 / this.scale; // default use 4 as offset\n    let offsetY = 4 / this.scale;\n    if (this.showVertex) {\n      const r = this.vertexSize / this.scale;\n      offsetX = r;\n      offsetY = r;\n    }\n    if (this.showVertexOrder) {\n      offsetY += 14 / this.scale;\n    }\n    this.points.forEach(point => {\n      if (point.userData && Object.keys(point.userData).length > 0) {\n        const x = point.x + offsetX;\n        const y = point.y + offsetY;\n        const text = new Text(this.userDataFormatter ? this.userDataFormatter(point.userData) : Object.keys(point.userData).map(key => `${key}: ${point.userData[key]}`).join(', '), {\n          fontSize: 12,\n          lineHeight: 14,\n          fill: '#FFFFFF',\n          dropShadow: true,\n          dropShadowAlpha: 0.8,\n          dropShadowBlur: 2,\n          dropShadowDistance: 1\n        });\n        text.scale.set(1 / this.scale);\n        text.position.set(x, y);\n        this.userDataContainer.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * draw cut path\n   */\n  _drawCutPath() {\n    if (this.isCutting && this._cutPathPoints.length > 1) {\n      this.instance.lineStyle(2 / this.scale, 0xFF0000);\n      this._cutPathPoints.forEach((point, index) => {\n        if (index === 0) {\n          this.instance.moveTo(point.x, point.y);\n        } else {\n          this.instance.lineTo(point.x, point.y);\n        }\n      });\n    }\n  }\n\n  /**\n   * create by click to add point\n   * @param point\n   */\n  create() {\n    this.app.view.addEventListener('mousedown', this._mouseDown, false);\n    if (this._polygonType === PolygonType.DEFAULT) {\n      // default creating method\n      document.addEventListener('mousemove', this._mouseMove, false);\n      document.addEventListener('mouseup', this._mouseUp, false);\n      this.app.view.addEventListener('dblclick', this._finishByDoubleClick, false);\n    } else if (this._polygonType === PolygonType.RECOGNITION) {\n      // recognition method\n      document.addEventListener('mousemove', this._mouseMoveForRecognition, false);\n      document.addEventListener('mouseup', this._mouseUpForRecognition, false);\n    }\n    this._finished = false;\n    this._nextPoint = null;\n    this._isDown = true; // create start is mouse down\n    this._isDragging = false;\n    this._createdByDragging = false;\n    this._resetRecognition();\n  }\n  /**\n   * draw recognition shapes\n   */\n  _drawRecognition() {\n    this.instance.clear();\n    this._drawRecognitionRect();\n    this._drawRecognizedPolygon();\n    this._attachRecognitionControls();\n  }\n\n  /**\n   * draw recognition rectangle\n   */\n  _drawRecognitionRect() {\n    if (this._recognitionRect) {\n      // draw rectangle\n      const {\n        x,\n        y,\n        width,\n        height\n      } = this._recognitionRect;\n      this.instance.lineStyle(this.borderWidth / this.scale, this._recognitionRectFinished ? this.selectedColor : this.displayBorderColor, this.borderAlpha);\n      this.instance.beginFill(this.color, this._recognitionRectFinished ? 0 : this.alpha);\n      this.instance.drawRect(x, y, width, height);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw recognized polygon\n   */\n  _drawRecognizedPolygon() {\n    if (this.points.length < 3) return;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.selectedColor, this.borderAlpha);\n    this.instance.moveTo(this._points[0].x, this._points[0].y);\n    this._points.slice(1).forEach(point => this.instance.lineTo(point.x, point.y));\n    this.instance.lineTo(this._points[0].x, this._points[0].y);\n  }\n\n  /**\n   * attach recognition controls\n   */\n  _attachRecognitionControls() {\n    if (this._recognitionRect && this._recognitionRectFinished) {\n      // draw controls for rectangle\n      [{\n        x: this._recognitionRect.left,\n        y: this._recognitionRect.top\n      }, {\n        x: this._recognitionRect.right,\n        y: this._recognitionRect.bottom\n      }].forEach((point, i) => {\n        if (!this._recognitionControls[i]) {\n          this._recognitionControls[i] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            cursor: Cursor.POINTER,\n            onPositionChange: (px, py) => {\n              const {\n                x,\n                y\n              } = this._keepPointInBounds(new Point(px, py));\n              if (i === 0) {\n                this._recognitionRect.width -= x - this._recognitionRect.x;\n                this._recognitionRect.height -= y - this._recognitionRect.y;\n                this._recognitionRect.x = x;\n                this._recognitionRect.y = y;\n              } else {\n                this._recognitionRect.width = x - this._recognitionRect.x;\n                this._recognitionRect.height = y - this._recognitionRect.y;\n              }\n              this._drawRecognition();\n            },\n            onFinish: () => {\n              this._isRecognitionConrtolDown = false;\n              this.recognition();\n            },\n            onClick: () => {\n              this._isRecognitionConrtolDown = true;\n            }\n          });\n        }\n        this._recognitionControls[i].position = point;\n        this._recognitionControls[i].scale = this.scale;\n        this._recognitionControls[i].add();\n      });\n      // draw recognition controls\n      this._recognitionControlPoints.forEach((point, i) => {\n        const index = i + 2;\n        const position = {\n          x: point.x,\n          y: point.y\n        };\n        if (!this._recognitionControls[index]) {\n          this._recognitionControls[index] = new ControlPoint({\n            position,\n            container: this.controlsContainer,\n            scale: this.scale,\n            size: 8,\n            color: 0xFFFFFF,\n            fillColor: point.flag ? 0x4A90E2 : 0xDC4624,\n            cursor: Cursor.POINTER,\n            onPositionChange: (px, py) => {\n              const {\n                x,\n                y\n              } = this._keepPointInBounds(new Point(px, py));\n              this._recognitionControlPoints[i].x = x;\n              this._recognitionControlPoints[i].y = y;\n            },\n            onFinish: () => {\n              this._isRecognitionConrtolDown = false;\n              this.recognition();\n            },\n            onClick: () => {\n              this._isRecognitionConrtolDown = true;\n            }\n          });\n        }\n        this._recognitionControls[index].position = position;\n        this._recognitionControls[index].scale = this.scale;\n        this._recognitionControls[index].add();\n      });\n    }\n  }\n\n  /**\n   * reset params for recognition\n   */\n  _resetRecognition() {\n    this._recognitionRect = null;\n    this._recognitionRectFinished = false;\n    this._recognitionControlPoints = [];\n    this._recognitionControlMode = 'none';\n    this._isRecognitionConrtolDown = false;\n    this._recognitionControls.forEach(control => {\n      control.destroy();\n    });\n    this._recognitionControls = [];\n  }\n\n  /**\n   * do recognition\n   */\n  recognition() {\n    if (this._recognitionRect && this._recognitionRectFinished) {\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = this._recognitionRect;\n      const x = Math.min(left, right);\n      const y = Math.min(top, bottom);\n      const width = Math.abs(right - left);\n      const height = Math.abs(bottom - top);\n      this._emit(EventAction.RECOGNITION, {\n        bounds: {\n          x,\n          y,\n          width,\n          height\n        },\n        controls: this._recognitionControlPoints.map(p => ({\n          flag: p.flag,\n          x: p.x - x,\n          y: p.y - y\n        }))\n      });\n    }\n  }\n\n  /**\n   * set recognized polygon\n   * @param points\n   */\n  setRecognizedPolygon(points) {\n    if (this._recognitionRect && this._recognitionRectFinished) {\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = this._recognitionRect;\n      const x = Math.min(left, right);\n      const y = Math.min(top, bottom);\n      this._points = points.map(p => ({\n        x: p.x + x,\n        y: p.y + y\n      }));\n      this._drawRecognition();\n    }\n  }\n\n  /**\n   * set recognition control mode\n   * @param mode\n   */\n  setRecognitionControlMode(mode) {\n    this._recognitionControlMode = mode;\n  }\n  /**\n   * finish cut\n   */\n  _finishCut() {\n    if (this._cutPathPoints.length >= 2) {\n      const firstPoint = this._cutPathPoints[0];\n      const lastPoint = this._cutPathPoints[this._cutPathPoints.length - 1];\n      const {\n        previousPointIndex: firstPointPrevIndex\n      } = this._findEdgeByPointPosition(firstPoint);\n      const {\n        previousPointIndex: lastPointPrevIndex\n      } = this._findEdgeByPointPosition(lastPoint);\n      let p1; // last next -> first prev -> cut path\n      let p2; // first next -> last prev -> reversed cut path\n      if (firstPointPrevIndex < lastPointPrevIndex) {\n        // first point before last point\n        p1 = [...this._points.slice(lastPointPrevIndex + 1), ...this._points.slice(0, firstPointPrevIndex + 1), ...this._cutPathPoints];\n        p2 = [...this._points.slice(firstPointPrevIndex + 1, lastPointPrevIndex + 1), ...this._cutPathPoints.reverse()];\n      } else if (firstPointPrevIndex > lastPointPrevIndex) {\n        // first point after last point\n        p1 = [...this._points.slice(lastPointPrevIndex + 1, firstPointPrevIndex + 1), ...this._cutPathPoints];\n        p2 = [...this._points.slice(firstPointPrevIndex + 1), ...this._points.slice(0, lastPointPrevIndex + 1), ...this._cutPathPoints.reverse()];\n      } else {\n        // on the same edge\n        p1 = [...this._cutPathPoints];\n        p2 = [...this._points];\n        const edgePoint = this._points[firstPointPrevIndex];\n        const d1 = (firstPoint.x - edgePoint.x) ** 2 + (firstPoint.y - edgePoint.y) ** 2;\n        const d2 = (lastPoint.x - edgePoint.x) ** 2 + (lastPoint.y - edgePoint.y) ** 2;\n        (d1 < d2 ? this._cutPathPoints.reverse() : this._cutPathPoints).forEach(p => {\n          p2.splice(firstPointPrevIndex + 1, 0, p);\n        });\n      }\n      const polygon1 = new Flatten.Polygon();\n      polygon1.addFace(p1.map(p => new Flatten.Point(p.x, p.y)));\n      const area1 = polygon1.faces.values().next().value.area();\n      const polygon2 = new Flatten.Polygon();\n      polygon2.addFace(p2.map(p => new Flatten.Point(p.x, p.y)));\n      const area2 = polygon2.faces.values().next().value.area();\n      this._cutPathPoints = [];\n      this.points = area1 > area2 ? p1 : p2;\n      this.cuttingOtherPolygon = {\n        points: (area1 > area2 ? p2 : p1).map(p => ({\n          x: p.x,\n          y: p.y\n        }))\n      };\n      this._changed();\n    }\n  }\n\n  /**\n   * remove all listeners\n   * @private\n   */\n  _removeListeners() {\n    this.app.view.removeEventListener('mousedown', this._mouseDown, false);\n    document.removeEventListener('mousemove', this._mouseMove, false);\n    document.removeEventListener('mousemove', this._mouseMoveForRecognition, false);\n    document.removeEventListener('mouseup', this._mouseUp, false);\n    document.removeEventListener('mouseup', this._mouseUpForRecognition, false);\n    this.app.view.removeEventListener('dblclick', this._finishByDoubleClick, false);\n  }\n\n  /**\n   * get label position\n   */\n  getLabelPosition() {\n    const sorted = [...this._points].sort((a, b) => {\n      if (a.y === b.y) return a.x - b.x;\n      return a.y - b.y;\n    });\n    return new Point(sorted[0].x, sorted[0].y);\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      points: this.points\n    };\n  }\n\n  /**\n   * get geo json\n   */\n  getAreaAsGeoJSON() {\n    return [[this.points.map(p => [p.x, p.y])]];\n  }\n\n  /**\n   * delete selected points\n   */\n  deleteSelectedPoints() {\n    if (this.selected) {\n      const deletedIndexes = [];\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          deletedIndexes.push(i);\n          c.selected = false;\n        }\n      });\n      if (deletedIndexes.length > 0) {\n        this._points = this._points.filter((_, i) => !deletedIndexes.includes(i));\n        this.normalize();\n        this._changed();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * snap to point\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point, tolerance = 8) {\n    const t = tolerance / this.scale;\n\n    // bbox\n    const {\n      x,\n      y\n    } = point;\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.shapeBounds;\n    if (x < left - t || x > right + t || y < top - t || y > bottom + t) {\n      return null;\n    }\n\n    // points\n    let nearestPoint;\n    let d;\n    this.points.forEach(p => {\n      const pointDistance = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);\n      if (pointDistance < t && (d === undefined || pointDistance < d)) {\n        d = pointDistance;\n        nearestPoint = p;\n      }\n    });\n    if (nearestPoint) {\n      return new Point(nearestPoint.x, nearestPoint.y);\n    }\n\n    // edges\n    const location = new Flatten.Point(x, y);\n    const [distance, segment] = this._geometory.distanceTo(location);\n    if (distance < t) {\n      const {\n        ps,\n        pe\n      } = segment;\n      const edgePoint = ps.equalTo(location) ? pe : ps;\n      return new Point(edgePoint.x, edgePoint.y);\n    }\n    return null;\n  }\n\n  /**\n   * snap to polygon edges\n   */\n  snap(event) {\n    if (event.data.originalEvent.altKey || this.isCutting) {\n      const point = event.data.getLocalPosition(this.container);\n      const location = new Flatten.Point(point.x, point.y);\n      const [distance, segment] = this._geometory.distanceTo(location);\n      if (distance < 8 / this.scale) {\n        const {\n          ps,\n          pe\n        } = segment;\n        const edgePoint = ps.equalTo(location) ? pe : ps;\n        this._snappingPoint = new Point(edgePoint.x, edgePoint.y);\n        this.drawShape();\n        return true;\n      }\n    }\n    if (this._snappingPoint) {\n      this._snappingPoint = null;\n      this.drawShape();\n    }\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    if (this._snappingPoint && !this.isCutting) {\n      const {\n        point,\n        edge,\n        previousPointIndex\n      } = this._findEdgeByPointPosition(this._snappingPoint);\n      const x = precise(point.x);\n      const y = precise(point.y);\n      this._geometory.addVertex(new Flatten.Point(x, y), edge);\n      this._points.splice(previousPointIndex + 1, 0, {\n        x,\n        y\n      });\n      this._snappingPoint = null;\n      this._controls.forEach(c => {\n        c.selected = false;\n      });\n      this.drawShape();\n      this._changed();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * find edge for new point position\n   * @param point\n   */\n  _findEdgeByPointPosition({\n    x,\n    y\n  }) {\n    const point = new Flatten.Point(x, y);\n    const edge = this._geometory.findEdgeByPoint(point);\n    const {\n      start,\n      end\n    } = edge;\n    // find the edge segment point index in points array\n    let i = 0;\n    while (i < this._points.length) {\n      const p1 = this._points[i];\n      const p2 = this._points[(i + 1) % this._points.length];\n      if (p1.x === start.x && p1.y === start.y && p2.x === end.x && p2.y === end.y || p1.x === end.x && p1.y === end.y && p2.x === start.x && p2.y === start.y) {\n        // if has more than one edge that has the same start-end point, just use the first found one\n        // in canvas when snapping point added, just the first of the overlapped edge can be divided\n        break;\n      }\n      i += 1;\n    }\n    return {\n      point,\n      edge,\n      previousPointIndex: i\n    };\n  }\n\n  /**\n   * attach control points\n   */\n  attachControlPoints() {\n    if (!this.editable) {\n      this.removeControls();\n      return;\n    }\n    [...this._points].forEach((point, index) => {\n      if (this.selected || this.hovered && this.showVertex) {\n        const {\n          color: fillColor,\n          type\n        } = this.getPointStyle(index);\n\n        // create if never created before\n        if (!this._controls[index]) {\n          this._controls[index] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.displayBorderColor,\n            fillColor,\n            type,\n            cursor: Cursor.POINTER,\n            onPositionChange: (x, y) => this._updateByPointPosition(index, x, y),\n            onFinish: () => this._finishResize(),\n            onClick: () => this._updatePointSelectedStatus(index)\n          });\n        }\n\n        // update\n        this._controls[index].fillColor = fillColor;\n        this._controls[index].type = type;\n        this._controls[index].color = this.displayBorderColor;\n        this._controls[index].size = this.selected ? 4 : this.vertexSize;\n        this._controls[index].position = point;\n        this._controls[index].add();\n      } else if (this._controls[index]) {\n        // remove\n        this._controls[index].selected = false;\n        this._controls[index].remove();\n      }\n    });\n    if (this._controls.length > this._points.length) {\n      // remove redundant control points\n      this._controls.slice(this._points.length).forEach(c => {\n        c.remove();\n      });\n      this._controls = this._controls.slice(0, this._points.length);\n    }\n  }\n\n  /**\n   * update polygon point\n   * @private\n   * @param index point index\n   * @param x new position x\n   * @param y new position y\n   */\n  _updateByPointPosition(index, x, y) {\n    if (this.isCutting) {\n      return;\n    }\n    const lastPoint = this._points[index - 1 < 0 ? this._points.length - 1 : index - 1];\n    const position = this._straighten(this._keepPointInBounds(this.globalSnappingPoint || new Point(x, y)), lastPoint);\n    const deltaX = position.x - this._points[index].x;\n    const deltaY = position.y - this._points[index].y;\n    this.updateSelectedPointsPosistion(deltaX, deltaY);\n    this._resizing({\n      deltaX,\n      deltaY\n    });\n  }\n\n  /**\n   * update selected points position\n   * @param deltaX\n   * @param deltaY\n   */\n  updateSelectedPointsPosistion(deltaX, deltaY) {\n    // move together\n    this._controls.forEach((c, i) => {\n      if (c.selected) {\n        const position = this._keepPointInBounds(new Point(this._points[i].x + deltaX, this._points[i].y + deltaY));\n        this._points[i].x = position.x;\n        this._points[i].y = position.y;\n      }\n    });\n    this.drawShape();\n  }\n\n  /**\n   * update selected point\n   * @private\n   * @param index\n   */\n  _updatePointSelectedStatus(index) {\n    if (!this.isCutting && !this._controls[index].selected) {\n      this._emit(EventAction.VERTEX_SELECTED, index);\n      this._controls.forEach((c, i) => {\n        if (i === index) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * when finish resize\n   */\n  _finishResize() {\n    this.resizing = false;\n    this.normalize();\n    this._changed();\n  }\n\n  /**\n   * add a point\n   * @param point\n   * @param index\n   */\n  addPoint(point, index) {\n    const pIndex = index === undefined ? this._points.length : index;\n    this._points.splice(pIndex, 0, {\n      x: precise(point.x),\n      y: precise(point.y)\n    });\n    this.drawShape();\n  }\n\n  /**\n   * remove a point\n   * @param index\n   */\n  removePoint(index) {\n    if (index >= 0 && index < this._points.length) {\n      this._points.splice(index, 1);\n      this.drawShape();\n    }\n  }\n\n  /**\n   * normalize polygon shape, remove it if necessary\n   */\n  normalize() {\n    // simplify may be useful in segmentation but may cause issues in default object annotation\n    // do simplify\n    // if (this._createdByDragging) {\n    //   this._points = simplify(this._points, 0.1, true);\n    //   this._createdByDragging = false;\n    // }\n\n    // remove duplicated points\n    const points = [];\n    this._points.forEach((point, index) => {\n      if (index === this._points.length - 1 || point.x !== this._points[index + 1].x || point.y !== this._points[index + 1].y) {\n        points.push(point);\n      }\n    });\n    this._points = points;\n\n    // crossing\n    if (this._points.length > 3) {\n      try {\n        this.splitPolygon();\n      } catch (e) {\n        this._remove();\n        return;\n      }\n    }\n    if (this._points.length < 3) {\n      this._remove();\n      return;\n    }\n    this._points.forEach(p => {\n      p.x = precise(p.x);\n      p.y = precise(p.y);\n    });\n    this.updateGeometory();\n    if (this.area <= 0) {\n      this._remove();\n      return;\n    }\n    this.drawShape();\n  }\n\n  // has crossing\n  splitPolygon() {\n    const pointsData = [[this.points.map(p => [p.x, p.y])]];\n    const intersection = polygonClipping.intersection(pointsData);\n    let points = [];\n    if (intersection.length > 1) {\n      // crossing\n      let maxArea = {\n        size: 0,\n        index: 0\n      };\n      intersection.forEach((i, index) => {\n        const polygon = new Flatten.Polygon();\n        polygon.addFace(i[0].map(p => new Flatten.Point(p[0], p[1])));\n        const area = polygon.faces.values().next().value.area();\n        if (area > maxArea.size) {\n          maxArea = {\n            size: area,\n            index\n          };\n        }\n      });\n      points = intersection[maxArea.index][0];\n    } else if (intersection.length === 1 && intersection[0].length > 0) {\n      const polygonData = lineString(intersection[0][0]);\n      const allPointsOnEdge = this.points.every(p => pointOnLine(turfPoint([p.x, p.y]), polygonData));\n      if (!allPointsOnEdge) {\n        // contains\n        points = intersection[0][0];\n      }\n    }\n    if (points.length > 0) {\n      const setPoints = {};\n      points.slice(0, points.length - 1).forEach(point => {\n        setPoints[point.join(',')] = point;\n      });\n      this._points = Object.values(setPoints).map(p => ({\n        x: p[0],\n        y: p[1]\n      }));\n      this.setSelectedPoints([]);\n      // this._emit(EventAction.VERTEX_SELECTED, -1); // unselect the vertex\n    }\n  }\n\n  /**\n   * update geometory\n   */\n  updateGeometory() {\n    this._geometory.faces.forEach(face => this._geometory.deleteFace(face));\n    this._geometory.addFace(this._points.map(p => new Flatten.Point(p.x, p.y)));\n  }\n\n  /**\n   * shape destroy\n   */\n  destroy() {\n    this.app.view.removeEventListener('mousedown', this._viewMouseDown, false);\n    this.app.view.removeEventListener('mousemove', this._viewMouseMove, false);\n    this.app.view.removeEventListener('mouseup', this._viewMouseUp, false);\n    document.removeEventListener('keydown', this._keyDown, false);\n    document.removeEventListener('keyup', this._keyUp, false);\n    this._removeListeners();\n    this._resetRecognition();\n    // call parent\n    super.destroy();\n  }\n\n  /**\n   * selected points with point index & point instance\n   * @returns\n   */\n  getSelectedPoints() {\n    if (!this._finished) {\n      const lastPointIndex = this._points.length - 1;\n      return [{\n        index: lastPointIndex,\n        point: this._points[lastPointIndex]\n      }];\n    }\n    const selectedPoints = [];\n    const points = [...this.points];\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          selectedPoints.push({\n            index: i,\n            point: points[i]\n          });\n        }\n      });\n    }\n    return selectedPoints;\n  }\n\n  /**\n   * set selected points\n   * @param pointsIndex\n   */\n  setSelectedPoints(pointsIndex) {\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (pointsIndex.includes(i)) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * set points user data\n   * @param pointsData\n   */\n  setPointsUserData(pointsData) {\n    pointsData.forEach(({\n      index,\n      userData\n    }) => {\n      this._points[index].userData = cloneDeep(userData);\n    });\n    this.drawShape();\n    if (this._finished) {\n      this._changed();\n    }\n  }\n\n  /**\n   * straighten line segment\n   * @param type\n   */\n  _straighten(currPoint, lastPoint) {\n    if (!lastPoint) {\n      return currPoint;\n    }\n    if (this._vKeyDown) {\n      currPoint.x = lastPoint.x;\n    } else if (this._hKeyDown) {\n      currPoint.y = lastPoint.y;\n    }\n    return currPoint;\n  }\n  static getPolygons(shapes) {\n    return shapes.filter(i => i.shapeType === ShapeType.POLYGON);\n  }\n  findInnerPolygons(shapes) {\n    const polygons = Polygon.getPolygons(shapes).filter(i => i.uid !== this.uid);\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.shapeBounds;\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const {\n        left: l,\n        right: r,\n        top: t,\n        bottom: b\n      } = polygon.shapeBounds;\n      if (l >= left && r <= right && t <= top && b >= bottom) {\n        //\n      }\n    }\n  }\n  findIntersectPolygons(shapes) {\n    const polygons = Polygon.getPolygons(shapes).filter(i => i.uid !== this.uid);\n    const pointsData = [[this.points.map(p => [p.x, p.y])]];\n    const intersects = [];\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const points = [[polygon.points.map(p => [p.x, p.y])]];\n      const intersection = polygonClipping.intersection(pointsData, points);\n      // has crossing, check include\n      if (intersection.length > 0) {\n        const differenceA = polygonClipping.difference(pointsData, points);\n        const differenceB = polygonClipping.difference(points, pointsData);\n        if (differenceA.length > 0 && differenceB.length > 0) {\n          intersects.push(polygon.uid);\n        }\n      }\n    }\n    return intersects;\n  }\n  merge(polygon) {\n    const pointsData = [[this.points.map(p => [p.x, p.y])]];\n    const polygonPoints = [[polygon.points.map(p => [p.x, p.y])]];\n    const mergedPolygonPoints = polygonClipping.union(pointsData, polygonPoints);\n    return (mergedPolygonPoints[0] || []).map(points => ({\n      points: normalizePoints(points)\n    }));\n  }\n  subtract(shapes) {\n    const polygons = shapes.filter(i => i.shapeType === ShapeType.POLYGON);\n    if (polygons.length === 0) return null;\n    const pointsData = [this.points.map(p => [p.x, p.y])];\n    const polygonsPoints = polygons.map(i => [i.points.map(p => [p.x, p.y])]);\n    const subtractData = polygonClipping.difference(pointsData, ...polygonsPoints).map(i => {\n      const polygon = new Flatten.Polygon();\n      polygon.addFace(i[0].map(p => new Flatten.Point(p[0], p[1])));\n      // return Object.values(polygon.faces);\n      const area = polygon.faces.values().next().value.area();\n      return {\n        p: i,\n        area\n      };\n    }).sort((a, b) => b.area - a.area).map(i => i.p);\n    return subtractData.map(i => i.map(points => ({\n      points: normalizePoints(points)\n    })));\n  }\n}","map":{"version":3,"names":["Point","Text","BitmapText","Rectangle","Flatten","cloneDeep","polygonClipping","pointOnLine","lineString","point","turfPoint","Shape","EventAction","ShapeType","ControlPoint","precise","normalizePoints","Cursor","PolygonType","Polygon","isCutting","_isCutting","cutting","cuttingOtherPolygon","draggable","app","view","addEventListener","_viewMouseDown","_viewMouseMove","_viewMouseUp","removeEventListener","_cutPathPoints","length","drawShape","_controls","forEach","c","control","interactive","selected","points","_points","map","p","x","y","userData","normalize","position","offsetX","offsetY","updateGeometory","shapeBounds","shapePoints","left","Math","min","right","max","top","bottom","area","_geometory","faces","values","next","value","constructor","options","shapeType","POLYGON","_polygonType","DEFAULT","_defaultEdges","_nextPoint","_isDown","_isDragging","_createdByDragging","_recognitionRect","_recognitionRectFinished","_recognitionControlPoints","_recognitionControlMode","_isRecognitionConrtolDown","_recognitionControls","_vKeyDown","_hKeyDown","cuttingMode","pointStyler","edgeStyler","_mouseDown","e","button","_mouseMove","event","localPoint","globalSnappingPoint","_mapScreenToStagePosition","clientX","clientY","_mapStageToLocalPosition","_straighten","_keepPointInBounds","lastPoint","tolerance","scale","abs","addPoint","_mouseUp","undefined","finishCreate","_finishByDoubleClick","_keyDown","key","toLowerCase","_finished","preventDefault","removePoint","_keyUp","_mouseMoveForRecognition","width","height","_drawRecognition","_mouseUpForRecognition","push","flag","recognition","_attachRecognitionControls","_finish","_removeListeners","_resetRecognition","_snappingPoint","pop","_finishCut","instance","containsPoint","toGlobal","splice","polygonType","defaultEdges","Array","isArray","every","document","getPointStyle","pointIndex","color","displayVertexColor","type","vertexType","styles","getEdgeStyle","displayBorderColor","borderType","bold","borderBold","hovered","finished","RECOGNITION","clear","_drawShapeFill","_drawShapeLine","_drawShapeVertex","_drawSnappingPoint","drawPointUserData","drawShapeLabel","attachControlPoints","_drawCutPath","beginFill","fillColor","alpha","drawPolygon","endFill","baseWidth","borderWidth","boldWidth","moveTo","slice","i","lineStyle","borderAlpha","drawLine","borderStyle","vertexesContainer","removeChildren","showVertex","showVertexOrder","r","vertexSize","offset","index","editable","drawVertex","text","vertexStart","fontName","set","addChild","selectedColor","drawCircle","userDataContainer","Object","keys","userDataFormatter","join","fontSize","lineHeight","fill","dropShadow","dropShadowAlpha","dropShadowBlur","dropShadowDistance","lineTo","create","_drawRecognitionRect","_drawRecognizedPolygon","drawRect","container","controlsContainer","cursor","POINTER","onPositionChange","px","py","onFinish","onClick","add","size","destroy","_emit","bounds","controls","setRecognizedPolygon","setRecognitionControlMode","mode","firstPoint","previousPointIndex","firstPointPrevIndex","_findEdgeByPointPosition","lastPointPrevIndex","p1","p2","reverse","edgePoint","d1","d2","polygon1","addFace","area1","polygon2","area2","_changed","getLabelPosition","sorted","sort","a","b","getData","getAreaAsGeoJSON","deleteSelectedPoints","deletedIndexes","filter","_","includes","snapToPoint","t","nearestPoint","d","pointDistance","sqrt","location","distance","segment","distanceTo","ps","pe","equalTo","snap","data","originalEvent","altKey","getLocalPosition","addSnappingPointToShape","edge","addVertex","findEdgeByPoint","start","end","removeControls","_updateByPointPosition","_finishResize","_updatePointSelectedStatus","remove","deltaX","deltaY","updateSelectedPointsPosistion","_resizing","VERTEX_SELECTED","resizing","pIndex","splitPolygon","_remove","pointsData","intersection","maxArea","polygon","polygonData","allPointsOnEdge","setPoints","setSelectedPoints","face","deleteFace","getSelectedPoints","lastPointIndex","selectedPoints","pointsIndex","setPointsUserData","currPoint","getPolygons","shapes","findInnerPolygons","polygons","uid","l","findIntersectPolygons","intersects","differenceA","difference","differenceB","merge","polygonPoints","mergedPolygonPoints","union","subtract","polygonsPoints","subtractData"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/common/shapes/Polygon.ts"],"sourcesContent":["import { Point, Text, BitmapText, InteractionEvent, Rectangle } from 'pixi.js';\nimport Flatten from '@flatten-js/core';\n// import simplify from 'simplify-js';\nimport { cloneDeep } from 'lodash';\nimport polygonClipping, { Ring } from 'polygon-clipping';\nimport pointOnLine from '@turf/boolean-point-on-line';\nimport { lineString, point as turfPoint } from '@turf/helpers';\nimport Shape, { ShapeOptions, EventAction } from './Shape';\nimport { ShapeData, ShapeType, ShapeVertexType, VertexStyles, EdgeStyles } from './types';\nimport ControlPoint from './controls/ControlPoint';\nimport { precise, normalizePoints } from './utils';\nimport Cursor from '../Cursor';\n\nexport enum PolygonType {\n  DEFAULT = 'default',\n  RECOGNITION = 'recognition',\n}\n\ninterface RecognitionControlPoint {\n  flag: boolean;\n  x: number;\n  y: number;\n}\n\ninterface IPoint {\n  x: number;\n  y: number;\n  userData?: any;\n}\n\nexport interface PolygonData {\n  points: IPoint[];\n}\n\nexport interface PolygonOptions extends ShapeOptions {\n  points?: IPoint[];\n  polygonType?: PolygonType;\n  defaultEdges?: number;\n  pointStyler?: (pointIndex: number, userData: any, shape: Shape<ShapeData>) => VertexStyles;\n  edgeStyler?: (startPointIndex: number, userData: any, shape: Shape<ShapeData>) => EdgeStyles;\n}\n\n/**\n * Polygon shape\n * @class\n */\nexport default class Polygon extends Shape<PolygonData> {\n  shapeType = ShapeType.POLYGON;\n\n  /**\n   * polygon points\n   * @private\n   */\n  private _points: IPoint[] = [];\n\n  /**\n   * polygon creating type\n   * @private\n   */\n  private _polygonType = PolygonType.DEFAULT;\n\n  /**\n   * default polygon edges count\n   * @private\n   */\n  private _defaultEdges?: number;\n\n  /**\n   * indicate next point when creating\n   * @private\n   */\n  private _nextPoint: IPoint | null = null;\n\n  /**\n   * is mouse down\n   * @private\n   */\n  private _isDown = false;\n\n  /**\n   * is dragging\n   * @private\n   */\n  private _isDragging = false;\n\n  /**\n   * is created by dragging\n   * @private\n   */\n  private _createdByDragging = false;\n\n  /**\n   * rectangle used for recognition\n   * @private\n   */\n  private _recognitionRect: Rectangle | null = null;\n\n  /**\n   * rectangle finished\n   * @private\n   */\n  private _recognitionRectFinished = false;\n\n  /**\n   * control points used for recognition\n   * @private\n   */\n  private _recognitionControlPoints: RecognitionControlPoint[] = [];\n\n  /**\n   * control points adding mode\n   */\n  private _recognitionControlMode: 'none' | 'plus' | 'minus' = 'none';\n\n  /**\n   * mouse down on recognition controls\n   */\n  private _isRecognitionConrtolDown = false;\n\n  /**\n   * control instances for recognition\n   */\n  private _recognitionControls: ControlPoint[] = [];\n\n  /**\n   * polygon geometory data\n   */\n  private _geometory = new Flatten.Polygon();\n\n  /**\n   * cut path points\n   */\n  private _cutPathPoints: Point[] = [];\n\n  /**\n   * is polygon in cut mode\n   */\n  private _isCutting = false;\n\n  /**\n   * is key v down\n   */\n  private _vKeyDown = false;\n\n  /**\n   * is key h down\n   */\n  private _hKeyDown = false;\n\n  /**\n   * cutting mode\n   */\n  cuttingMode: 'cut' | 'split' = 'cut';\n\n  /**\n   * other polygon by cutting\n   */\n  cuttingOtherPolygon: PolygonData | null = null;\n\n  /**\n   * get is cutting\n   * @getter\n   */\n  get isCutting() {\n    return this._isCutting;\n  }\n\n  /**\n   * set is cutting\n   * @setter\n   */\n  set isCutting(cutting: boolean) {\n    this._isCutting = cutting;\n    this.cuttingOtherPolygon = null;\n    this.draggable = !cutting;\n    if (cutting) {\n      // add event listener\n      this.app.view.addEventListener('mousedown', this._viewMouseDown, false);\n      this.app.view.addEventListener('mousemove', this._viewMouseMove, false);\n      this.app.view.addEventListener('mouseup', this._viewMouseUp, false);\n    } else {\n      // remove event listener\n      this.app.view.removeEventListener('mousedown', this._viewMouseDown, false);\n      this.app.view.removeEventListener('mousemove', this._viewMouseMove, false);\n      this.app.view.removeEventListener('mouseup', this._viewMouseUp, false);\n    }\n    if (this._cutPathPoints.length > 0) {\n      // remove cutting path\n      this._cutPathPoints = [];\n      this.drawShape();\n    }\n    // remove selected control\n    this._controls.forEach((c) => {\n      if (cutting) {\n        c.control.interactive = false;\n        if (c.selected) {\n          c.selected = false;\n        }\n      } else {\n        c.control.interactive = true;\n      }\n    });\n  }\n\n  /**\n   * get points\n   * @getter\n   */\n  get points() {\n    return this._points.map((p) => ({\n      x: p.x,\n      y: p.y,\n      ...p.userData && { userData: p.userData },\n    }));\n  }\n\n  /**\n   * set points\n   * @setter\n   */\n  set points(points: IPoint[]) {\n    this._points = points.map((p) => ({ x: p.x, y: p.y, userData: cloneDeep(p.userData) }));\n    this.normalize();\n  }\n\n  /**\n   * get position\n   * @getter\n   */\n  get position() {\n    return new Point(this._points[0].x, this._points[0].y);\n  }\n\n  /**\n   * set position\n   * @setter\n   */\n  set position(point: Point) {\n    const offsetX = point.x - this._points[0].x;\n    const offsetY = point.y - this._points[0].y;\n    this._points.forEach((p) => {\n      p.x = precise(p.x + offsetX);\n      p.y = precise(p.y + offsetY);\n    });\n    this.updateGeometory();\n    this.drawShape();\n  }\n\n  /**\n   * shape bounds\n   * @getter\n   */\n  get shapeBounds() {\n    const shapePoints = this.points;\n    const left = Math.min(...shapePoints.map((p) => p.x));\n    const right = Math.max(...shapePoints.map((p) => p.x));\n    const top = Math.min(...shapePoints.map((p) => p.y));\n    const bottom = Math.max(...shapePoints.map((p) => p.y));\n    return { left, top, right, bottom };\n  }\n\n  /**\n   * shape area\n   * @getter\n   */\n  get area() {\n    return this._geometory.faces.values().next().value.area();\n  }\n\n  /**\n   * set styles for point\n   */\n  pointStyler?: (pointIndex: number, userData: any, shape: Shape<ShapeData>) => VertexStyles;\n\n  /**\n   * set styles for edge\n   */\n  edgeStyler?: (startPointIndex: number, userData: any, shape: Shape<ShapeData>) => EdgeStyles;\n\n  constructor(options: PolygonOptions) {\n    super(options);\n\n    const { points, polygonType = PolygonType.DEFAULT, defaultEdges, pointStyler, edgeStyler } = options;\n    this._polygonType = polygonType;\n    this._defaultEdges = defaultEdges;\n    this.pointStyler = pointStyler;\n    this.edgeStyler = edgeStyler;\n    if (Array.isArray(points) && points.every((p) => p.x !== undefined && p.y !== undefined)) {\n      this.points = points;\n    }\n\n    document.addEventListener('keydown', this._keyDown, false);\n    document.addEventListener('keyup', this._keyUp, false);\n  }\n\n  /**\n   * get point style\n   * @param pointIndex\n   */\n  getPointStyle(pointIndex: number) {\n    let color = this.displayVertexColor;\n    let type = this.vertexType;\n    if (this.pointStyler) {\n      const { userData } = this._points[pointIndex];\n      const styles = this.pointStyler(pointIndex, userData, this);\n      if (styles.color) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n    }\n    return { color, type };\n  }\n\n  /**\n   * get edge style\n   * @param pointIndex\n   */\n  getEdgeStyle(pointIndex: number) {\n    let color = this.displayBorderColor;\n    let type = this.borderType;\n    let bold = this.borderBold;\n    if (this.edgeStyler) {\n      const { userData } = this._points[pointIndex];\n      const styles = this.edgeStyler(pointIndex, userData, this);\n      if (styles.color && !this.selected && !this.hovered) {\n        color = styles.color;\n      }\n      if (styles.type) {\n        type = styles.type;\n      }\n      if (styles.bold) {\n        bold = true;\n      }\n    }\n    return { color, type, bold };\n  }\n\n  /**\n   * draw shape\n   */\n  drawShape() {\n    if (!this.finished && this._polygonType === PolygonType.RECOGNITION) {\n      // draw recognition\n      this._drawRecognition();\n      return;\n    }\n    this.instance.clear();\n    this._drawShapeFill();\n    this._drawShapeLine();\n    this._drawShapeVertex();\n    this._drawSnappingPoint();\n    this.drawPointUserData();\n    if (this._finished) {\n      this.drawShapeLabel();\n      this.attachControlPoints();\n      this._drawCutPath();\n    }\n  }\n\n  /**\n   * draw shape fill\n   * @private\n   */\n  private _drawShapeFill() {\n    if (this._finished) {\n      this.instance.beginFill(this.fillColor, this.alpha);\n      this.instance.drawPolygon(this._points.map(({ x, y }) => new Point(x, y)));\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw shape border\n   * @private\n   */\n  private _drawShapeLine() {\n    if (this._points.length === 0) return;\n    const baseWidth = this.borderWidth / this.scale;\n    const boldWidth = baseWidth * 4;\n    this.instance.moveTo(this._points[0].x, this._points[0].y);\n    this._points.slice(1).forEach((point, i) => {\n      const { color, type, bold } = this.getEdgeStyle(i);\n      this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n      this.instance.drawLine(point.x, point.y, this.borderStyle, type);\n    });\n    const { color, type, bold } = this.getEdgeStyle(this._points.length - 1);\n    this.instance.lineStyle(bold ? boldWidth : baseWidth, color, this.borderAlpha);\n    if (this._finished) {\n      this.instance.drawLine(this._points[0].x, this._points[0].y, this.borderStyle, type);\n      // this.instance.closePath();\n    } else if (this._nextPoint) {\n      this.instance.drawLine(this._nextPoint.x, this._nextPoint.y, this.borderStyle, type);\n    }\n  }\n\n  /**\n   * draw shape vertexes\n   * @private\n   */\n  private _drawShapeVertex() {\n    this.vertexesContainer.removeChildren();\n    if (!this.showVertex && !this.showVertexOrder) {\n      return;\n    }\n\n    const r = this.vertexSize / this.scale;\n    const offset = this.showVertex ? r : 4 / this.scale;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.displayBorderColor, this.borderAlpha);\n    this._points.forEach((point, index) => {\n      if (this.showVertex && (!this.editable || !this.selected)) {\n        // draw vertex dot\n        const { color, type } = this.getPointStyle(index);\n        this.instance.beginFill(color, this.borderAlpha);\n        this.instance.drawVertex(point.x, point.y, r, type);\n        this.instance.endFill();\n      }\n      if (this.showVertexOrder) {\n        // draw vertext order\n        const text = new BitmapText(`${this.vertexStart + index} `, { fontName: 'ALPHA_NUMERIC' });\n        text.scale.set(1 / this.scale);\n        text.position.set(point.x + offset, point.y + offset);\n        this.vertexesContainer.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * draw snapping point\n   */\n  private _drawSnappingPoint() {\n    if (this._snappingPoint) {\n      this.instance.beginFill(this.selectedColor);\n      this.instance.drawCircle(this._snappingPoint.x, this._snappingPoint.y, 3 / this.scale);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw point user data\n   */\n  drawPointUserData() {\n    this.userDataContainer.removeChildren();\n    let offsetX = 4 / this.scale; // default use 4 as offset\n    let offsetY = 4 / this.scale;\n    if (this.showVertex) {\n      const r = this.vertexSize / this.scale;\n      offsetX = r;\n      offsetY = r;\n    }\n    if (this.showVertexOrder) {\n      offsetY += 14 / this.scale;\n    }\n\n    this.points.forEach((point) => {\n      if (point.userData && Object.keys(point.userData).length > 0) {\n        const x = point.x + offsetX;\n        const y = point.y + offsetY;\n\n        const text = new Text(this.userDataFormatter\n          ? this.userDataFormatter(point.userData)\n          : Object.keys(point.userData).map((key) => `${key}: ${point.userData[key]}`).join(', '), {\n          fontSize: 12,\n          lineHeight: 14,\n          fill: '#FFFFFF',\n          dropShadow: true,\n          dropShadowAlpha: 0.8,\n          dropShadowBlur: 2,\n          dropShadowDistance: 1,\n        });\n        text.scale.set(1 / this.scale);\n        text.position.set(x, y);\n\n        this.userDataContainer.addChild(text);\n      }\n    });\n  }\n\n  /**\n   * draw cut path\n   */\n  private _drawCutPath() {\n    if (this.isCutting && this._cutPathPoints.length > 1) {\n      this.instance.lineStyle(2 / this.scale, 0xFF0000);\n      this._cutPathPoints.forEach((point, index) => {\n        if (index === 0) {\n          this.instance.moveTo(point.x, point.y);\n        } else {\n          this.instance.lineTo(point.x, point.y);\n        }\n      });\n    }\n  }\n\n  /**\n   * create by click to add point\n   * @param point\n   */\n  create() {\n    this.app.view.addEventListener('mousedown', this._mouseDown, false);\n    if (this._polygonType === PolygonType.DEFAULT) {\n      // default creating method\n      document.addEventListener('mousemove', this._mouseMove, false);\n      document.addEventListener('mouseup', this._mouseUp, false);\n      this.app.view.addEventListener('dblclick', this._finishByDoubleClick, false);\n    } else if (this._polygonType === PolygonType.RECOGNITION) {\n      // recognition method\n      document.addEventListener('mousemove', this._mouseMoveForRecognition, false);\n      document.addEventListener('mouseup', this._mouseUpForRecognition, false);\n    }\n\n    this._finished = false;\n    this._nextPoint = null;\n    this._isDown = true; // create start is mouse down\n    this._isDragging = false;\n    this._createdByDragging = false;\n    this._resetRecognition();\n  }\n\n  /**\n   * mouse down listener when creating\n   * @private\n   */\n  private _mouseDown = (e: MouseEvent) => {\n    if (e.button === 0 && !this._isRecognitionConrtolDown) { // not right click, not recognition control click\n      this._isDown = true;\n    }\n  };\n\n  /**\n   * mouse move listener when creating\n   * @private\n   * @param event\n   */\n  private _mouseMove = (event: MouseEvent) => {\n    if (this._isDown) {\n      this._isDragging = true;\n    }\n\n    let localPoint = this.globalSnappingPoint;\n    if (!localPoint) {\n      const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n      localPoint = this._mapStageToLocalPosition(point);\n    }\n    const p = this._straighten(this._keepPointInBounds(localPoint), this._points[this._points.length - 1]);\n    if (this._isDragging) {\n      // add point directly when dragging to draw a polygon\n      const lastPoint = this.points[this.points.length - 1] || { x: 0, y: 0 };\n      const tolerance = 10 / this.scale;\n      if (Math.abs(p.x - lastPoint.x) > tolerance || Math.abs(p.y - lastPoint.y) > tolerance) {\n        this._createdByDragging = true;\n        this.addPoint(p);\n      }\n      this._nextPoint = null;\n    } else {\n      this._nextPoint = p;\n      this.drawShape();\n    }\n  };\n\n  /**\n   * mouse up listener when creating\n   * @private\n   * @param event\n   */\n  private _mouseUp = (event: MouseEvent) => {\n    if (this._isDown && !this._isDragging) {\n      let localPoint = this.globalSnappingPoint;\n      if (!localPoint) {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        localPoint = this._mapStageToLocalPosition(point);\n      }\n      const p = this._straighten(this._keepPointInBounds(localPoint), this._points[this._points.length - 1]);\n      this.addPoint(p);\n    }\n    this._isDown = false;\n    this._isDragging = false;\n\n    // auto finish\n    if (this._defaultEdges !== undefined && this._points.length >= this._defaultEdges) {\n      this.finishCreate();\n    }\n  };\n\n  /**\n   * finish by double clicking\n   * @private\n   */\n  private _finishByDoubleClick = () => {\n    this.finishCreate();\n  };\n\n  /**\n   * key down handler\n   * @private\n   * @param e\n   */\n  private _keyDown = (e: KeyboardEvent) => {\n    switch (e.key.toLowerCase()) {\n      case 'q':\n        if (!this._finished && this._polygonType === PolygonType.DEFAULT) {\n          e.preventDefault();\n          this.removePoint(this.points.length - 1);\n        }\n        break;\n      case 'enter':\n        if (!this._finished) {\n          e.preventDefault();\n          this.finishCreate();\n        }\n        break;\n      case 'v':\n        // e.preventDefault();\n        this._vKeyDown = true;\n        break;\n      case 'h':\n        // e.preventDefault();\n        this._hKeyDown = true;\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * key up handler\n   */\n  private _keyUp = () => {\n    this._vKeyDown = false;\n    this._hKeyDown = false;\n  };\n\n  /**\n   * mouse move for recognition\n   * @param event\n   */\n  private _mouseMoveForRecognition = (event: MouseEvent) => {\n    if (this._isDown && !this._recognitionRectFinished) {\n      // creating rectangle\n      const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this._mapStageToLocalPosition(point);\n      const p = this._keepPointInBounds(localPoint);\n      if (!this._recognitionRect) {\n        this._recognitionRect = new Rectangle(p.x, p.y, 0, 0);\n      } else {\n        this._recognitionRect.width = p.x - this._recognitionRect.x;\n        this._recognitionRect.height = p.y - this._recognitionRect.y;\n      }\n      this._drawRecognition();\n    }\n  };\n\n  /**\n   * mouse up for recognition\n   * @param event\n   */\n  private _mouseUpForRecognition = (event: MouseEvent) => {\n    if (this._recognitionRect && !this._recognitionRectFinished) {\n      // finish creating rectangle\n      this._recognitionRectFinished = true;\n      // add default control point\n      const { x, y, width, height } = this._recognitionRect;\n      this._recognitionControlPoints.push({\n        flag: true,\n        x: x + width / 2,\n        y: y + height / 2,\n      });\n      this._drawRecognition();\n      this.recognition();\n    } else if (this._recognitionRect && this._recognitionRectFinished && this._isDown && this._recognitionControlMode !== 'none') {\n      // add control points\n      const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n      const { x, y } = this._mapStageToLocalPosition(point);\n      const { left, top, right, bottom } = this._recognitionRect;\n      if (x >= left && x <= right && y >= top && y <= bottom) {\n        // in rectangle\n        this._recognitionControlPoints.push({ flag: this._recognitionControlMode === 'plus', x, y });\n        this._attachRecognitionControls();\n        this.recognition();\n      }\n    }\n    this._isDown = false;\n  };\n\n  /**\n   * draw recognition shapes\n   */\n  private _drawRecognition() {\n    this.instance.clear();\n    this._drawRecognitionRect();\n    this._drawRecognizedPolygon();\n    this._attachRecognitionControls();\n  }\n\n  /**\n   * draw recognition rectangle\n   */\n  private _drawRecognitionRect() {\n    if (this._recognitionRect) {\n      // draw rectangle\n      const { x, y, width, height } = this._recognitionRect;\n      this.instance.lineStyle(this.borderWidth / this.scale, this._recognitionRectFinished ? this.selectedColor : this.displayBorderColor, this.borderAlpha);\n      this.instance.beginFill(this.color, this._recognitionRectFinished ? 0 : this.alpha);\n      this.instance.drawRect(x, y, width, height);\n      this.instance.endFill();\n    }\n  }\n\n  /**\n   * draw recognized polygon\n   */\n  private _drawRecognizedPolygon() {\n    if (this.points.length < 3) return;\n    this.instance.lineStyle(this.borderWidth / this.scale, this.selectedColor, this.borderAlpha);\n    this.instance.moveTo(this._points[0].x, this._points[0].y);\n    this._points.slice(1).forEach((point) => this.instance.lineTo(point.x, point.y));\n    this.instance.lineTo(this._points[0].x, this._points[0].y);\n  }\n\n  /**\n   * attach recognition controls\n   */\n  private _attachRecognitionControls() {\n    if (this._recognitionRect && this._recognitionRectFinished) {\n      // draw controls for rectangle\n      [\n        { x: this._recognitionRect.left, y: this._recognitionRect.top },\n        { x: this._recognitionRect.right, y: this._recognitionRect.bottom },\n      ].forEach((point, i) => {\n        if (!this._recognitionControls[i]) {\n          this._recognitionControls[i] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.selectedColor,\n            cursor: Cursor.POINTER,\n            onPositionChange: (px, py) => {\n              const { x, y } = this._keepPointInBounds(new Point(px, py));\n              if (i === 0) {\n                this._recognitionRect!.width -= x - this._recognitionRect!.x;\n                this._recognitionRect!.height -= y - this._recognitionRect!.y;\n                this._recognitionRect!.x = x;\n                this._recognitionRect!.y = y;\n              } else {\n                this._recognitionRect!.width = x - this._recognitionRect!.x;\n                this._recognitionRect!.height = y - this._recognitionRect!.y;\n              }\n              this._drawRecognition();\n            },\n            onFinish: () => {\n              this._isRecognitionConrtolDown = false;\n              this.recognition();\n            },\n            onClick: () => {\n              this._isRecognitionConrtolDown = true;\n            },\n          });\n        }\n        this._recognitionControls[i].position = point;\n        this._recognitionControls[i].scale = this.scale;\n        this._recognitionControls[i].add();\n      });\n      // draw recognition controls\n      this._recognitionControlPoints.forEach((point, i) => {\n        const index = i + 2;\n        const position = { x: point.x, y: point.y };\n        if (!this._recognitionControls[index]) {\n          this._recognitionControls[index] = new ControlPoint({\n            position,\n            container: this.controlsContainer,\n            scale: this.scale,\n            size: 8,\n            color: 0xFFFFFF,\n            fillColor: point.flag ? 0x4A90E2 : 0xDC4624,\n            cursor: Cursor.POINTER,\n            onPositionChange: (px, py) => {\n              const { x, y } = this._keepPointInBounds(new Point(px, py));\n              this._recognitionControlPoints[i].x = x;\n              this._recognitionControlPoints[i].y = y;\n            },\n            onFinish: () => {\n              this._isRecognitionConrtolDown = false;\n              this.recognition();\n            },\n            onClick: () => {\n              this._isRecognitionConrtolDown = true;\n            },\n          });\n        }\n        this._recognitionControls[index].position = position;\n        this._recognitionControls[index].scale = this.scale;\n        this._recognitionControls[index].add();\n      });\n    }\n  }\n\n  /**\n   * reset params for recognition\n   */\n  private _resetRecognition() {\n    this._recognitionRect = null;\n    this._recognitionRectFinished = false;\n    this._recognitionControlPoints = [];\n    this._recognitionControlMode = 'none';\n    this._isRecognitionConrtolDown = false;\n    this._recognitionControls.forEach((control) => {\n      control.destroy();\n    });\n    this._recognitionControls = [];\n  }\n\n  /**\n   * do recognition\n   */\n  recognition() {\n    if (this._recognitionRect && this._recognitionRectFinished) {\n      const { left, top, right, bottom } = this._recognitionRect;\n      const x = Math.min(left, right);\n      const y = Math.min(top, bottom);\n      const width = Math.abs(right - left);\n      const height = Math.abs(bottom - top);\n      this._emit(EventAction.RECOGNITION, {\n        bounds: { x, y, width, height },\n        controls: this._recognitionControlPoints.map((p) => ({\n          flag: p.flag,\n          x: p.x - x,\n          y: p.y - y,\n        })),\n      });\n    }\n  }\n\n  /**\n   * set recognized polygon\n   * @param points\n   */\n  setRecognizedPolygon(points: IPoint[]) {\n    if (this._recognitionRect && this._recognitionRectFinished) {\n      const { left, top, right, bottom } = this._recognitionRect;\n      const x = Math.min(left, right);\n      const y = Math.min(top, bottom);\n      this._points = points.map((p) => ({ x: p.x + x, y: p.y + y }));\n      this._drawRecognition();\n    }\n  }\n\n  /**\n   * set recognition control mode\n   * @param mode\n   */\n  setRecognitionControlMode(mode: 'none' | 'plus' | 'minus') {\n    this._recognitionControlMode = mode;\n  }\n\n  /**\n   * finish create\n   */\n  finishCreate = () => {\n    this.normalize();\n    this._finish();\n    this._removeListeners();\n    this._resetRecognition();\n  };\n\n  /**\n   * mouse down on view\n   * @param event\n   */\n  private _viewMouseDown = (event: MouseEvent) => {\n    if (event.button === 2) {\n      return;\n    }\n    if (this.isCutting) {\n      this._isDown = true;\n      if (this._snappingPoint) {\n        // click on the shape edge\n        if (this._cutPathPoints.length > 0) {\n          // end cut\n          if (this._cutPathPoints.length > 1) {\n            this._cutPathPoints.pop(); // remove moving point\n          }\n          this._cutPathPoints.push(this._snappingPoint);\n          this._finishCut();\n        } else {\n          // start cut\n          this._cutPathPoints.push(this._snappingPoint);\n        }\n      } else if (this._cutPathPoints.length > 0) {\n        // add point\n        let localPoint = this.globalSnappingPoint;\n        if (!localPoint) {\n          const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n          localPoint = this._mapStageToLocalPosition(point);\n        }\n        const p = this._keepPointInBounds(localPoint);\n        if (this.cuttingMode === 'split' && !this.instance.containsPoint(this.instance.toGlobal(p))) {\n          return;\n        }\n        if (this._cutPathPoints.length > 1) {\n          // last point is the moving point\n          this._cutPathPoints.splice(this._cutPathPoints.length - 1, 0, p);\n        } else {\n          this._cutPathPoints.push(p);\n        }\n      }\n    }\n  };\n\n  /**\n   * mouse move on view\n   * @param event\n   */\n  private _viewMouseMove = (event: MouseEvent) => {\n    if (event.button === 2) {\n      return;\n    }\n    if (this.isCutting && this._cutPathPoints.length > 0) {\n      let localPoint = this.globalSnappingPoint;\n      if (!localPoint) {\n        const point = this._mapScreenToStagePosition(event.clientX, event.clientY);\n        localPoint = this._mapStageToLocalPosition(point);\n      }\n      const p = this._keepPointInBounds(localPoint);\n      if (this._isDown && this.cuttingMode !== 'split') {\n        const lastPoint = this._cutPathPoints[this._cutPathPoints.length - 1];\n        const tolerance = 10 / this.scale;\n        if (Math.abs(p.x - lastPoint.x) > tolerance || Math.abs(p.y - lastPoint.y) > tolerance) {\n          this._cutPathPoints.push(p);\n          this.drawShape();\n        }\n      } else {\n        if (this._cutPathPoints.length > 1) {\n          // remove last point\n          this._cutPathPoints.pop();\n        }\n        this._cutPathPoints.push(p);\n        this.drawShape();\n      }\n    }\n  };\n\n  /**\n   * mouse up on view\n   */\n  private _viewMouseUp = () => {\n    this._isDown = false;\n  };\n\n  /**\n   * finish cut\n   */\n  private _finishCut() {\n    if (this._cutPathPoints.length >= 2) {\n      const firstPoint = this._cutPathPoints[0];\n      const lastPoint = this._cutPathPoints[this._cutPathPoints.length - 1];\n      const { previousPointIndex: firstPointPrevIndex } = this._findEdgeByPointPosition(firstPoint);\n      const { previousPointIndex: lastPointPrevIndex } = this._findEdgeByPointPosition(lastPoint);\n\n      let p1: IPoint[]; // last next -> first prev -> cut path\n      let p2: IPoint[]; // first next -> last prev -> reversed cut path\n      if (firstPointPrevIndex < lastPointPrevIndex) {\n        // first point before last point\n        p1 = [...this._points.slice(lastPointPrevIndex + 1), ...this._points.slice(0, firstPointPrevIndex + 1), ...this._cutPathPoints];\n        p2 = [...this._points.slice(firstPointPrevIndex + 1, lastPointPrevIndex + 1), ...this._cutPathPoints.reverse()];\n      } else if (firstPointPrevIndex > lastPointPrevIndex) {\n        // first point after last point\n        p1 = [...this._points.slice(lastPointPrevIndex + 1, firstPointPrevIndex + 1), ...this._cutPathPoints];\n        p2 = [...this._points.slice(firstPointPrevIndex + 1), ...this._points.slice(0, lastPointPrevIndex + 1), ...this._cutPathPoints.reverse()];\n      } else {\n        // on the same edge\n        p1 = [...this._cutPathPoints];\n        p2 = [...this._points];\n        const edgePoint = this._points[firstPointPrevIndex];\n        const d1 = (firstPoint.x - edgePoint.x) ** 2 + (firstPoint.y - edgePoint.y) ** 2;\n        const d2 = (lastPoint.x - edgePoint.x) ** 2 + (lastPoint.y - edgePoint.y) ** 2;\n        (d1 < d2 ? this._cutPathPoints.reverse() : this._cutPathPoints).forEach((p) => {\n          p2.splice(firstPointPrevIndex + 1, 0, p);\n        });\n      }\n\n      const polygon1 = new Flatten.Polygon();\n      polygon1.addFace(p1.map((p) => new Flatten.Point(p.x, p.y)));\n      const area1 = polygon1.faces.values().next().value.area();\n      const polygon2 = new Flatten.Polygon();\n      polygon2.addFace(p2.map((p) => new Flatten.Point(p.x, p.y)));\n      const area2 = polygon2.faces.values().next().value.area();\n\n      this._cutPathPoints = [];\n      this.points = area1 > area2 ? p1 : p2;\n      this.cuttingOtherPolygon = {\n        points: (area1 > area2 ? p2 : p1).map((p) => ({ x: p.x, y: p.y })),\n      };\n      this._changed();\n    }\n  }\n\n  /**\n   * remove all listeners\n   * @private\n   */\n  private _removeListeners() {\n    this.app.view.removeEventListener('mousedown', this._mouseDown, false);\n    document.removeEventListener('mousemove', this._mouseMove, false);\n    document.removeEventListener('mousemove', this._mouseMoveForRecognition, false);\n    document.removeEventListener('mouseup', this._mouseUp, false);\n    document.removeEventListener('mouseup', this._mouseUpForRecognition, false);\n    this.app.view.removeEventListener('dblclick', this._finishByDoubleClick, false);\n  }\n\n  /**\n   * get label position\n   */\n  getLabelPosition() {\n    const sorted = [...this._points].sort((a, b) => {\n      if (a.y === b.y) return a.x - b.x;\n      return a.y - b.y;\n    });\n    return new Point(sorted[0].x, sorted[0].y);\n  }\n\n  /**\n   * get shape data\n   */\n  getData() {\n    return {\n      points: this.points,\n    };\n  }\n\n  /**\n   * get geo json\n   */\n  getAreaAsGeoJSON() {\n    return [[this.points.map((p) => [p.x, p.y] as [number, number])]];\n  }\n\n  /**\n   * delete selected points\n   */\n  deleteSelectedPoints() {\n    if (this.selected) {\n      const deletedIndexes: number[] = [];\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          deletedIndexes.push(i);\n          c.selected = false;\n        }\n      });\n      if (deletedIndexes.length > 0) {\n        this._points = this._points.filter((_, i) => !deletedIndexes.includes(i));\n        this.normalize();\n        this._changed();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * snap to point\n   * @param point\n   * @param tolerance\n   */\n  snapToPoint(point: Point, tolerance = 8) {\n    const t = tolerance / this.scale;\n\n    // bbox\n    const { x, y } = point;\n    const { left, right, top, bottom } = this.shapeBounds;\n    if (x < left - t || x > right + t || y < top - t || y > bottom + t) {\n      return null;\n    }\n\n    // points\n    let nearestPoint: IPoint | undefined;\n    let d: number | undefined;\n    this.points.forEach((p) => {\n      const pointDistance = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);\n      if (pointDistance < t && (d === undefined || pointDistance < d)) {\n        d = pointDistance;\n        nearestPoint = p;\n      }\n    });\n    if (nearestPoint) {\n      return new Point(nearestPoint.x, nearestPoint.y);\n    }\n\n    // edges\n    const location = new Flatten.Point(x, y);\n    const [distance, segment] = this._geometory.distanceTo(location);\n    if (distance < t) {\n      const { ps, pe } = segment;\n      const edgePoint = ps.equalTo(location) ? pe : ps;\n      return new Point(edgePoint.x, edgePoint.y);\n    }\n\n    return null;\n  }\n\n  /**\n   * snap to polygon edges\n   */\n  snap(event: InteractionEvent) {\n    if (event.data.originalEvent.altKey || this.isCutting) {\n      const point = event.data.getLocalPosition(this.container);\n      const location = new Flatten.Point(point.x, point.y);\n      const [distance, segment] = this._geometory.distanceTo(location);\n      if (distance < 8 / this.scale) {\n        const { ps, pe } = segment;\n        const edgePoint = ps.equalTo(location) ? pe : ps;\n        this._snappingPoint = new Point(edgePoint.x, edgePoint.y);\n        this.drawShape();\n        return true;\n      }\n    }\n\n    if (this._snappingPoint) {\n      this._snappingPoint = null;\n      this.drawShape();\n    }\n    return false;\n  }\n\n  /**\n   * add snapping point to shape\n   */\n  addSnappingPointToShape() {\n    if (this._snappingPoint && !this.isCutting) {\n      const { point, edge, previousPointIndex } = this._findEdgeByPointPosition(this._snappingPoint);\n      const x = precise(point.x);\n      const y = precise(point.y);\n      this._geometory.addVertex(new Flatten.Point(x, y), edge);\n      this._points.splice(previousPointIndex + 1, 0, { x, y });\n      this._snappingPoint = null;\n      this._controls.forEach((c) => {\n        c.selected = false;\n      });\n      this.drawShape();\n      this._changed();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * find edge for new point position\n   * @param point\n   */\n  private _findEdgeByPointPosition({ x, y }: { x: number; y: number }) {\n    const point = new Flatten.Point(x, y);\n    const edge = this._geometory.findEdgeByPoint(point);\n    const { start, end } = edge;\n    // find the edge segment point index in points array\n    let i = 0;\n    while (i < this._points.length) {\n      const p1 = this._points[i];\n      const p2 = this._points[(i + 1) % this._points.length];\n      if (\n        (p1.x === start.x && p1.y === start.y && p2.x === end.x && p2.y === end.y) ||\n        (p1.x === end.x && p1.y === end.y && p2.x === start.x && p2.y === start.y)\n      ) {\n        // if has more than one edge that has the same start-end point, just use the first found one\n        // in canvas when snapping point added, just the first of the overlapped edge can be divided\n        break;\n      }\n      i += 1;\n    }\n    return { point, edge, previousPointIndex: i };\n  }\n\n  /**\n   * attach control points\n   */\n  attachControlPoints() {\n    if (!this.editable) {\n      this.removeControls();\n      return;\n    }\n\n    [...this._points].forEach((point, index) => {\n      if (this.selected || (this.hovered && this.showVertex)) {\n        const { color: fillColor, type } = this.getPointStyle(index);\n\n        // create if never created before\n        if (!this._controls[index]) {\n          this._controls[index] = new ControlPoint({\n            position: point,\n            container: this.controlsContainer,\n            scale: this.scale,\n            color: this.displayBorderColor,\n            fillColor,\n            type,\n            cursor: Cursor.POINTER,\n            onPositionChange: (x, y) => this._updateByPointPosition(index, x, y),\n            onFinish: () => this._finishResize(),\n            onClick: () => this._updatePointSelectedStatus(index),\n          });\n        }\n\n        // update\n        (this._controls[index] as ControlPoint).fillColor = fillColor;\n        (this._controls[index] as ControlPoint).type = type;\n        this._controls[index].color = this.displayBorderColor;\n        this._controls[index].size = this.selected ? 4 : this.vertexSize;\n        this._controls[index].position = point;\n        this._controls[index].add();\n      } else if (this._controls[index]) {\n        // remove\n        this._controls[index].selected = false;\n        this._controls[index].remove();\n      }\n    });\n    if (this._controls.length > this._points.length) {\n      // remove redundant control points\n      this._controls.slice(this._points.length).forEach((c) => {\n        c.remove();\n      });\n      this._controls = this._controls.slice(0, this._points.length);\n    }\n  }\n\n  /**\n   * update polygon point\n   * @private\n   * @param index point index\n   * @param x new position x\n   * @param y new position y\n   */\n  private _updateByPointPosition(index: number, x: number, y: number) {\n    if (this.isCutting) {\n      return;\n    }\n    const lastPoint = this._points[index - 1 < 0 ? this._points.length - 1 : index - 1];\n    const position = this._straighten(this._keepPointInBounds(this.globalSnappingPoint || new Point(x, y)), lastPoint);\n    const deltaX = position.x - this._points[index].x;\n    const deltaY = position.y - this._points[index].y;\n    this.updateSelectedPointsPosistion(deltaX, deltaY);\n    this._resizing({ deltaX, deltaY });\n  }\n\n  /**\n   * update selected points position\n   * @param deltaX\n   * @param deltaY\n   */\n  updateSelectedPointsPosistion(deltaX: number, deltaY: number) {\n    // move together\n    this._controls.forEach((c, i) => {\n      if (c.selected) {\n        const position = this._keepPointInBounds(new Point(this._points[i].x + deltaX, this._points[i].y + deltaY));\n        this._points[i].x = position.x;\n        this._points[i].y = position.y;\n      }\n    });\n    this.drawShape();\n  }\n\n  /**\n   * update selected point\n   * @private\n   * @param index\n   */\n  private _updatePointSelectedStatus(index: number) {\n    if (!this.isCutting && !this._controls[index].selected) {\n      this._emit(EventAction.VERTEX_SELECTED, index);\n      this._controls.forEach((c, i) => {\n        if (i === index) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * when finish resize\n   */\n  private _finishResize() {\n    this.resizing = false;\n    this.normalize();\n    this._changed();\n  }\n\n  /**\n   * add a point\n   * @param point\n   * @param index\n   */\n  addPoint(point: IPoint | Point, index?: number) {\n    const pIndex = index === undefined ? this._points.length : index;\n    this._points.splice(pIndex, 0, { x: precise(point.x), y: precise(point.y) });\n    this.drawShape();\n  }\n\n  /**\n   * remove a point\n   * @param index\n   */\n  removePoint(index: number) {\n    if (index >= 0 && index < this._points.length) {\n      this._points.splice(index, 1);\n      this.drawShape();\n    }\n  }\n\n  /**\n   * normalize polygon shape, remove it if necessary\n   */\n  normalize() {\n    // simplify may be useful in segmentation but may cause issues in default object annotation\n    // do simplify\n    // if (this._createdByDragging) {\n    //   this._points = simplify(this._points, 0.1, true);\n    //   this._createdByDragging = false;\n    // }\n\n    // remove duplicated points\n    const points: IPoint[] = [];\n    this._points.forEach((point, index) => {\n      if (index === this._points.length - 1 || point.x !== this._points[index + 1].x || point.y !== this._points[index + 1].y) {\n        points.push(point);\n      }\n    });\n    this._points = points;\n\n    // crossing\n    if (this._points.length > 3) {\n      try {\n        this.splitPolygon();\n      } catch (e) {\n        this._remove();\n        return;\n      }\n    }\n\n    if (this._points.length < 3) {\n      this._remove();\n      return;\n    }\n\n    this._points.forEach((p) => {\n      p.x = precise(p.x);\n      p.y = precise(p.y);\n    });\n\n    this.updateGeometory();\n\n    if (this.area <= 0) {\n      this._remove();\n      return;\n    }\n\n    this.drawShape();\n  }\n\n  // has crossing\n  splitPolygon() {\n    const pointsData: polygonClipping.Geom = [[this.points.map((p) => [p.x, p.y])]];\n    const intersection = polygonClipping.intersection(pointsData);\n    let points: Ring = [];\n    if (intersection.length > 1) {\n      // crossing\n      let maxArea = {\n        size: 0,\n        index: 0\n      };\n      intersection.forEach((i, index) => {\n        const polygon = new Flatten.Polygon();\n        polygon.addFace(i[0].map((p) => new Flatten.Point(p[0], p[1])));\n        const area = polygon.faces.values().next().value.area();\n        if (area > maxArea.size) {\n          maxArea = {\n            size: area,\n            index\n          };\n        }\n      });\n      points = intersection[maxArea.index][0];\n    } else if (intersection.length === 1 && intersection[0].length > 0) {\n      const polygonData = lineString(intersection[0][0]);\n      const allPointsOnEdge = this.points.every((p) => pointOnLine(turfPoint([p.x, p.y]), polygonData));\n      if (!allPointsOnEdge) {\n        // contains\n        points = intersection[0][0];\n      }\n    }\n    if (points.length > 0) {\n      const setPoints: {[key: string]: number[]} = {};\n      points.slice(0, points.length - 1).forEach((point) => {\n        setPoints[point.join(',')] = point;\n      });\n      this._points = Object.values(setPoints).map((p) => ({ x: p[0], y: p[1] }));\n      this.setSelectedPoints([]);\n      // this._emit(EventAction.VERTEX_SELECTED, -1); // unselect the vertex\n    }\n  }\n\n  /**\n   * update geometory\n   */\n  updateGeometory() {\n    this._geometory.faces.forEach((face) => this._geometory.deleteFace(face));\n    this._geometory.addFace(this._points.map((p) => new Flatten.Point(p.x, p.y)));\n  }\n\n  /**\n   * shape destroy\n   */\n  destroy() {\n    this.app.view.removeEventListener('mousedown', this._viewMouseDown, false);\n    this.app.view.removeEventListener('mousemove', this._viewMouseMove, false);\n    this.app.view.removeEventListener('mouseup', this._viewMouseUp, false);\n    document.removeEventListener('keydown', this._keyDown, false);\n    document.removeEventListener('keyup', this._keyUp, false);\n    this._removeListeners();\n    this._resetRecognition();\n    // call parent\n    super.destroy();\n  }\n\n  /**\n   * selected points with point index & point instance\n   * @returns\n   */\n  getSelectedPoints() {\n    if (!this._finished) {\n      const lastPointIndex = this._points.length - 1;\n      return [{ index: lastPointIndex, point: this._points[lastPointIndex] }];\n    }\n    const selectedPoints: {index: number; point: IPoint}[] = [];\n    const points = [...this.points];\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (c.selected) {\n          selectedPoints.push({\n            index: i,\n            point: points[i],\n          });\n        }\n      });\n    }\n    return selectedPoints;\n  }\n\n  /**\n   * set selected points\n   * @param pointsIndex\n   */\n  setSelectedPoints(pointsIndex: number[]) {\n    if (this.selected) {\n      this._controls.forEach((c, i) => {\n        if (pointsIndex.includes(i)) {\n          c.selected = true;\n        } else {\n          c.selected = false;\n        }\n      });\n    }\n  }\n\n  /**\n   * set points user data\n   * @param pointsData\n   */\n  setPointsUserData(pointsData: {index: number; userData: any}[]) {\n    pointsData.forEach(({ index, userData }) => {\n      this._points[index].userData = cloneDeep(userData);\n    });\n    this.drawShape();\n    if (this._finished) {\n      this._changed();\n    }\n  }\n\n  /**\n   * straighten line segment\n   * @param type\n   */\n  private _straighten(currPoint: Point, lastPoint: IPoint) {\n    if (!lastPoint) {\n      return currPoint;\n    }\n    if (this._vKeyDown) {\n      currPoint.x = lastPoint.x;\n    } else if (this._hKeyDown) {\n      currPoint.y = lastPoint.y;\n    }\n    return currPoint;\n  }\n\n  static getPolygons(shapes: Shape<ShapeData>[]) {\n    return shapes.filter((i) => i.shapeType === ShapeType.POLYGON) as Polygon[];\n  }\n\n  findInnerPolygons(shapes: Shape<ShapeData>[]) {\n    const polygons = Polygon.getPolygons(shapes).filter((i) => i.uid !== this.uid);\n\n    const { left, right, top, bottom } = this.shapeBounds;\n\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const { left: l, right: r, top: t, bottom: b } = polygon.shapeBounds;\n      if (l >= left && r <= right && t <= top && b >= bottom) {\n        //\n      }\n    }\n  }\n\n  findIntersectPolygons(shapes: Shape<ShapeData>[]) {\n    const polygons = Polygon.getPolygons(shapes).filter((i) => i.uid !== this.uid);\n    const pointsData: polygonClipping.Geom = [[this.points.map((p) => [p.x, p.y])]];\n\n    const intersects: string[] = [];\n    for (let i = 0; i < polygons.length; i += 1) {\n      const polygon = polygons[i];\n      const points: polygonClipping.Geom = [[polygon.points.map((p) => [p.x, p.y])]];\n      const intersection = polygonClipping.intersection(pointsData, points);\n      // has crossing, check include\n      if (intersection.length > 0) {\n        const differenceA = polygonClipping.difference(pointsData, points);\n        const differenceB = polygonClipping.difference(points, pointsData);\n        if (differenceA.length > 0 && differenceB.length > 0) {\n          intersects.push(polygon.uid);\n        }\n      }\n    }\n\n    return intersects;\n  }\n\n  merge(polygon: Polygon): PolygonData[] {\n    const pointsData: polygonClipping.Geom = [[this.points.map((p) => [p.x, p.y])]];\n    const polygonPoints: polygonClipping.Geom = [[polygon.points.map((p) => [p.x, p.y])]];\n\n    const mergedPolygonPoints = polygonClipping.union(pointsData, polygonPoints);\n    return (mergedPolygonPoints[0] || []).map((points) => ({\n      points: normalizePoints(points),\n    }));\n  }\n\n  subtract(shapes: Shape<ShapeData>[]): PolygonData[][] | null {\n    const polygons = shapes.filter((i) => i.shapeType === ShapeType.POLYGON) as Polygon[];\n    if (polygons.length === 0) return null;\n    const pointsData: polygonClipping.Geom = [this.points.map((p) => [p.x, p.y] as polygonClipping.Pair)];\n    const polygonsPoints = polygons.map((i) => [i.points.map((p) => [p.x, p.y] as polygonClipping.Pair)]) as polygonClipping.Geom[];\n\n    const subtractData = polygonClipping.difference(pointsData, ...polygonsPoints)\n      .map((i) => {\n        const polygon = new Flatten.Polygon();\n        polygon.addFace(i[0].map((p) => new Flatten.Point(p[0], p[1])));\n        // return Object.values(polygon.faces);\n        const area = polygon.faces.values().next().value.area();\n        return {\n          p: i, area,\n        };\n      })\n      .sort((a, b) => b.area - a.area)\n      .map((i) => i.p);\n    return subtractData.map((i) => i.map((points) => ({\n      points: normalizePoints(points),\n    })));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}