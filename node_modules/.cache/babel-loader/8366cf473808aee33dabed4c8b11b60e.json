{"ast":null,"code":"/*!\n * @pixi/canvas-sprite - v6.2.2\n * Compiled Wed, 26 Jan 2022 16:23:27 UTC\n *\n * @pixi/canvas-sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Matrix, groupD8 } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { Sprite } from '@pixi/sprite';\nvar canvasRenderWorldTransform = new Matrix();\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nvar CanvasSpriteRenderer = /** @class */function () {\n  /** @param renderer - A reference to the current renderer */\n  function CanvasSpriteRenderer(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * Renders the sprite object.\n   *\n   * @param sprite - the sprite to render when using this spritebatch\n   */\n  CanvasSpriteRenderer.prototype.render = function (sprite) {\n    var texture = sprite._texture;\n    var renderer = this.renderer;\n    var context = renderer.context;\n    if (!texture.valid) {\n      return;\n    }\n    var width = texture._frame.width;\n    var height = texture._frame.height;\n    var wt = sprite.transform.worldTransform;\n    var dx = 0;\n    var dy = 0;\n    var source = texture.baseTexture.getDrawableSource();\n    if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source) {\n      return;\n    }\n    renderer.setBlendMode(sprite.blendMode, true);\n    renderer.context.globalAlpha = sprite.worldAlpha;\n    // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n    var smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n    if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {\n      context[renderer.smoothProperty] = smoothingEnabled;\n    }\n    if (texture.trim) {\n      dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;\n      dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;\n    } else {\n      dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n      dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n    }\n    if (texture.rotate) {\n      wt.copyTo(canvasRenderWorldTransform);\n      wt = canvasRenderWorldTransform;\n      groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n      // the anchor has already been applied above, so lets set it to zero\n      dx = 0;\n      dy = 0;\n    }\n    dx -= width / 2;\n    dy -= height / 2;\n    renderer.setContextTransform(wt, sprite.roundPixels, 1);\n    // Allow for pixel rounding\n    if (sprite.roundPixels) {\n      dx = dx | 0;\n      dy = dy | 0;\n    }\n    var resolution = texture.baseTexture.resolution;\n    var outerBlend = renderer._outerBlend;\n    if (outerBlend) {\n      context.save();\n      context.beginPath();\n      context.rect(dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n      context.clip();\n    }\n    if (sprite.tint !== 0xFFFFFF) {\n      if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID) {\n        sprite._cachedTint = sprite.tint;\n        // TODO clean up caching - how to clean up the caches?\n        sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);\n      }\n      context.drawImage(sprite._tintedCanvas, 0, 0, Math.floor(width * resolution), Math.floor(height * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(width * renderer.resolution), Math.floor(height * renderer.resolution));\n    } else {\n      context.drawImage(source, texture._frame.x * resolution, texture._frame.y * resolution, Math.floor(width * resolution), Math.floor(height * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(width * renderer.resolution), Math.floor(height * renderer.resolution));\n    }\n    if (outerBlend) {\n      context.restore();\n    }\n    // just in case, leaking outer blend here will be catastrophic!\n    renderer.setBlendMode(BLEND_MODES.NORMAL);\n  };\n  /** destroy the sprite object */\n  CanvasSpriteRenderer.prototype.destroy = function () {\n    this.renderer = null;\n  };\n  return CanvasSpriteRenderer;\n}();\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.Sprite#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nSprite.prototype._tintedCanvas = null;\n/**\n* Renders the object using the Canvas renderer\n*\n* @private\n* @method _renderCanvas\n* @memberof PIXI.Sprite#\n* @param {PIXI.CanvasRenderer} renderer - The renderer\n*/\nSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n  renderer.plugins.sprite.render(this);\n};\nexport { CanvasSpriteRenderer };","map":{"version":3,"sources":["../../src/CanvasSpriteRenderer.ts","../../src/Sprite.ts"],"names":[],"mappings":"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","sourcesContent":["import { SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Matrix, groupD8 } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { Sprite } from '@pixi/sprite';\n\nconst canvasRenderWorldTransform = new Matrix();\n\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasSpriteRenderer\n{\n    /** A reference to the current renderer */\n    protected renderer: CanvasRenderer;\n\n    /** @param renderer - A reference to the current renderer */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the sprite object.\n     *\n     * @param sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite: Sprite): void\n    {\n        const texture = sprite._texture;\n        const renderer = this.renderer;\n        const context = renderer.context;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        const width = texture._frame.width;\n        const height = texture._frame.height;\n\n        let wt = sprite.transform.worldTransform;\n        let dx = 0;\n        let dy = 0;\n\n        const source = texture.baseTexture.getDrawableSource();\n\n        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source)\n        {\n            return;\n        }\n\n        renderer.setBlendMode(sprite.blendMode, true);\n\n        renderer.context.globalAlpha = sprite.worldAlpha;\n\n        // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n        const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n        if (renderer.smoothProperty\n            && renderer.context[renderer.smoothProperty] !== smoothingEnabled)\n        {\n            context[renderer.smoothProperty] = smoothingEnabled;\n        }\n\n        if (texture.trim)\n        {\n            dx = (texture.trim.width / 2) + texture.trim.x - (sprite.anchor.x * texture.orig.width);\n            dy = (texture.trim.height / 2) + texture.trim.y - (sprite.anchor.y * texture.orig.height);\n        }\n        else\n        {\n            dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n            dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n        }\n\n        if (texture.rotate)\n        {\n            wt.copyTo(canvasRenderWorldTransform);\n            wt = canvasRenderWorldTransform;\n            groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n            // the anchor has already been applied above, so lets set it to zero\n            dx = 0;\n            dy = 0;\n        }\n\n        dx -= width / 2;\n        dy -= height / 2;\n\n        renderer.setContextTransform(wt, sprite.roundPixels, 1);\n        // Allow for pixel rounding\n        if (sprite.roundPixels)\n        {\n            dx = dx | 0;\n            dy = dy | 0;\n        }\n\n        const resolution = texture.baseTexture.resolution;\n        const outerBlend = renderer._outerBlend;\n\n        if (outerBlend)\n        {\n            context.save();\n            context.beginPath();\n            context.rect(\n                dx * renderer.resolution,\n                dy * renderer.resolution,\n                width * renderer.resolution,\n                height * renderer.resolution\n            );\n            context.clip();\n        }\n\n        if (sprite.tint !== 0xFFFFFF)\n        {\n            if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID)\n            {\n                sprite._cachedTint = sprite.tint;\n\n                // TODO clean up caching - how to clean up the caches?\n                sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);\n            }\n\n            context.drawImage(\n                sprite._tintedCanvas,\n                0,\n                0,\n                Math.floor(width * resolution),\n                Math.floor(height * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(width * renderer.resolution),\n                Math.floor(height * renderer.resolution)\n            );\n        }\n        else\n        {\n            context.drawImage(\n                source,\n                texture._frame.x * resolution,\n                texture._frame.y * resolution,\n                Math.floor(width * resolution),\n                Math.floor(height * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(width * renderer.resolution),\n                Math.floor(height * renderer.resolution)\n            );\n        }\n\n        if (outerBlend)\n        {\n            context.restore();\n        }\n        // just in case, leaking outer blend here will be catastrophic!\n        renderer.setBlendMode(BLEND_MODES.NORMAL);\n    }\n\n    /** destroy the sprite object */\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n","import { Sprite } from '@pixi/sprite';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.Sprite#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nSprite.prototype._tintedCanvas = null;\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @private\n* @method _renderCanvas\n* @memberof PIXI.Sprite#\n* @param {PIXI.CanvasRenderer} renderer - The renderer\n*/\nSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    renderer.plugins.sprite.render(this);\n};\n"]},"metadata":{},"sourceType":"module"}