{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport getScrollbarSize from 'dom-helpers/scrollbarSize';\n\n// @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar IS_SCROLLING_TIMEOUT = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\nvar CollectionView = /*#__PURE__*/function (_React$PureComponent) {\n  function CollectionView() {\n    var _this;\n    _classCallCheck(this, CollectionView);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, CollectionView, [].concat(args));\n\n    // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n    _defineProperty(_this, \"state\", {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    });\n    _defineProperty(_this, \"_calculateSizeAndPositionDataOnNextUpdate\", false);\n    // Invokes callbacks only when their values have changed.\n    _defineProperty(_this, \"_onSectionRenderedMemoizer\", createCallbackMemoizer());\n    _defineProperty(_this, \"_onScrollMemoizer\", createCallbackMemoizer(false));\n    _defineProperty(_this, \"_invokeOnSectionRenderedHelper\", function () {\n      var _this$props = _this.props,\n        cellLayoutManager = _this$props.cellLayoutManager,\n        onSectionRendered = _this$props.onSectionRendered;\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    });\n    _defineProperty(_this, \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n    _defineProperty(_this, \"_updateScrollPositionForScrollToCell\", function () {\n      var _this$props2 = _this.props,\n        cellLayoutManager = _this$props2.cellLayoutManager,\n        height = _this$props2.height,\n        scrollToAlignment = _this$props2.scrollToAlignment,\n        scrollToCell = _this$props2.scrollToCell,\n        width = _this$props2.width;\n      var _this$state = _this.state,\n        scrollLeft = _this$state.scrollLeft,\n        scrollTop = _this$state.scrollTop;\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    });\n    _defineProperty(_this, \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      _this._enablePointerEventsAfterDelay();\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n      var _this$props3 = _this.props,\n        cellLayoutManager = _this$props3.cellLayoutManager,\n        height = _this$props3.height,\n        isScrollingChange = _this$props3.isScrollingChange,\n        width = _this$props3.width;\n      var scrollbarSize = _this._scrollbarSize;\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n        totalHeight = _cellLayoutManager$ge.height,\n        totalWidth = _cellLayoutManager$ge.width;\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;\n\n        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    });\n    _this._scrollbarSize = getScrollbarSize();\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n    return _this;\n  }\n\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n  _inherits(CollectionView, _React$PureComponent);\n  return _createClass(CollectionView, [{\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n        cellLayoutManager = _this$props4.cellLayoutManager,\n        scrollLeft = _this$props4.scrollLeft,\n        scrollToCell = _this$props4.scrollToCell,\n        scrollTop = _this$props4.scrollTop;\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = getScrollbarSize();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n      }\n\n      // Update onSectionRendered callback.\n      this._invokeOnSectionRenderedHelper();\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n        totalHeight = _cellLayoutManager$ge2.height,\n        totalWidth = _cellLayoutManager$ge2.width;\n\n      // Initialize onScroll callback.\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$props5 = this.props,\n        height = _this$props5.height,\n        scrollToAlignment = _this$props5.scrollToAlignment,\n        scrollToCell = _this$props5.scrollToCell,\n        width = _this$props5.width;\n      var _this$state2 = this.state,\n        scrollLeft = _this$state2.scrollLeft,\n        scrollPositionChangeReason = _this$state2.scrollPositionChangeReason,\n        scrollTop = _this$state2.scrollTop;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Update scroll offsets if the current :scrollToCell values requires it\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n        autoHeight = _this$props6.autoHeight,\n        cellCount = _this$props6.cellCount,\n        cellLayoutManager = _this$props6.cellLayoutManager,\n        className = _this$props6.className,\n        height = _this$props6.height,\n        horizontalOverscanSize = _this$props6.horizontalOverscanSize,\n        id = _this$props6.id,\n        noContentRenderer = _this$props6.noContentRenderer,\n        style = _this$props6.style,\n        verticalOverscanSize = _this$props6.verticalOverscanSize,\n        width = _this$props6.width;\n      var _this$state3 = this.state,\n        isScrolling = _this$state3.isScrolling,\n        scrollLeft = _this$state3.scrollLeft,\n        scrollTop = _this$state3.scrollTop;\n\n      // Memoization reset\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n        totalHeight = _cellLayoutManager$ge3.height,\n        totalWidth = _cellLayoutManager$ge3.width;\n\n      // Safely expand the rendered area by the specified overscan amount\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      };\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      return /*#__PURE__*/React.createElement(\"div\", {\n        ref: this._setScrollingContainerRef,\n        \"aria-label\": this.props['aria-label'],\n        className: clsx('ReactVirtualized__Collection', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: \"grid\",\n        style: _objectSpread(_objectSpread({}, collectionStyle), style),\n        tabIndex: 0\n      }, cellCount > 0 && /*#__PURE__*/React.createElement(\"div\", {\n        className: \"ReactVirtualized__Collection__innerScrollContainer\",\n        style: {\n          height: totalHeight,\n          maxHeight: totalHeight,\n          maxWidth: totalWidth,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          width: totalWidth\n        }\n      }, childrenToDisplay), cellCount === 0 && noContentRenderer());\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n  }, {\n    key: \"_enablePointerEventsAfterDelay\",\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n        isScrollingChange(false);\n        _this2._disablePointerEventsTimeoutId = null;\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref) {\n      var _this3 = this;\n      var scrollLeft = _ref.scrollLeft,\n        scrollTop = _ref.scrollTop,\n        totalHeight = _ref.totalHeight,\n        totalWidth = _ref.totalWidth;\n      this._onScrollMemoizer({\n        callback: function callback(_ref2) {\n          var scrollLeft = _ref2.scrollLeft,\n            scrollTop = _ref2.scrollTop;\n          var _this3$props = _this3.props,\n            height = _this3$props.height,\n            onScroll = _this3$props.onScroll,\n            width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_setScrollPosition\",\n    value: function _setScrollPosition(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n        scrollTop = _ref3.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      }\n      return null;\n    }\n  }]);\n}(React.PureComponent);\n_defineProperty(CollectionView, \"defaultProps\", {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n});\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool,\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: PropTypes.object.isRequired,\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: PropTypes.string,\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: PropTypes.number.isRequired,\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: PropTypes.string,\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: PropTypes.number.isRequired,\n  isScrollingChange: PropTypes.func,\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: PropTypes.func.isRequired,\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: PropTypes.func.isRequired,\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: PropTypes.func.isRequired,\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: PropTypes.number,\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: PropTypes.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: PropTypes.number.isRequired,\n  /**\n   * Vertical offset.\n   */\n  scrollTop: PropTypes.number,\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: PropTypes.object,\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: PropTypes.number.isRequired,\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: PropTypes.number.isRequired\n} : {};\npolyfill(CollectionView);\nexport default CollectionView;","map":{"version":3,"names":["_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_inherits","_defineProperty","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","_callSuper","_isNativeReflectConstruct","Reflect","construct","constructor","Boolean","prototype","valueOf","call","clsx","PropTypes","React","polyfill","createCallbackMemoizer","getScrollbarSize","IS_SCROLLING_TIMEOUT","SCROLL_POSITION_CHANGE_REASONS","OBSERVED","REQUESTED","CollectionView","_React$PureComponent","_this","_len","args","Array","_key","concat","isScrolling","scrollLeft","scrollTop","_this$props","props","cellLayoutManager","onSectionRendered","_onSectionRenderedMemoizer","callback","indices","getLastRenderedIndices","ref","_scrollingContainer","_this$props2","height","scrollToAlignment","scrollToCell","width","_this$state","state","scrollPosition","getScrollPositionForCell","align","cellIndex","_setScrollPosition","event","target","_enablePointerEventsAfterDelay","_this$props3","isScrollingChange","scrollbarSize","_scrollbarSize","_cellLayoutManager$ge","getTotalSize","totalHeight","totalWidth","Math","max","min","scrollPositionChangeReason","cancelable","setState","_invokeOnScrollMemoizer","undefined","_scrollbarSizeMeasured","key","value","recomputeCellSizesAndPositions","_calculateSizeAndPositionDataOnNextUpdate","forceUpdate","componentDidMount","_this$props4","_updateScrollPositionForScrollToCell","_invokeOnSectionRenderedHelper","_cellLayoutManager$ge2","componentDidUpdate","prevProps","prevState","_this$props5","_this$state2","componentWillUnmount","_disablePointerEventsTimeoutId","clearTimeout","render","_this$props6","autoHeight","cellCount","className","horizontalOverscanSize","id","noContentRenderer","style","verticalOverscanSize","_this$state3","_lastRenderedCellCount","_lastRenderedCellLayoutManager","calculateSizeAndPositionData","_cellLayoutManager$ge3","left","top","right","bottom","childrenToDisplay","cellRenderers","x","y","collectionStyle","boxSizing","direction","position","WebkitOverflowScrolling","willChange","verticalScrollBarSize","horizontalScrollBarSize","overflowX","overflowY","createElement","_setScrollingContainerRef","onScroll","_onScroll","role","tabIndex","maxHeight","maxWidth","overflow","pointerEvents","_this2","setTimeout","_ref","_this3","_onScrollMemoizer","_ref2","_this3$props","clientHeight","clientWidth","scrollHeight","scrollWidth","_ref3","newState","getDerivedStateFromProps","nextProps","PureComponent","propTypes","process","env","NODE_ENV","string","bool","number","isRequired","object","func","oneOf"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/react-virtualized/dist/es/Collection/CollectionView.js"],"sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport getScrollbarSize from 'dom-helpers/scrollbarSize';\n\n// @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar IS_SCROLLING_TIMEOUT = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\nvar CollectionView = /*#__PURE__*/function (_React$PureComponent) {\n  function CollectionView() {\n    var _this;\n    _classCallCheck(this, CollectionView);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, CollectionView, [].concat(args));\n\n    // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n    _defineProperty(_this, \"state\", {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    });\n    _defineProperty(_this, \"_calculateSizeAndPositionDataOnNextUpdate\", false);\n    // Invokes callbacks only when their values have changed.\n    _defineProperty(_this, \"_onSectionRenderedMemoizer\", createCallbackMemoizer());\n    _defineProperty(_this, \"_onScrollMemoizer\", createCallbackMemoizer(false));\n    _defineProperty(_this, \"_invokeOnSectionRenderedHelper\", function () {\n      var _this$props = _this.props,\n        cellLayoutManager = _this$props.cellLayoutManager,\n        onSectionRendered = _this$props.onSectionRendered;\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    });\n    _defineProperty(_this, \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n    _defineProperty(_this, \"_updateScrollPositionForScrollToCell\", function () {\n      var _this$props2 = _this.props,\n        cellLayoutManager = _this$props2.cellLayoutManager,\n        height = _this$props2.height,\n        scrollToAlignment = _this$props2.scrollToAlignment,\n        scrollToCell = _this$props2.scrollToCell,\n        width = _this$props2.width;\n      var _this$state = _this.state,\n        scrollLeft = _this$state.scrollLeft,\n        scrollTop = _this$state.scrollTop;\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    });\n    _defineProperty(_this, \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      _this._enablePointerEventsAfterDelay();\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n      var _this$props3 = _this.props,\n        cellLayoutManager = _this$props3.cellLayoutManager,\n        height = _this$props3.height,\n        isScrollingChange = _this$props3.isScrollingChange,\n        width = _this$props3.width;\n      var scrollbarSize = _this._scrollbarSize;\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n        totalHeight = _cellLayoutManager$ge.height,\n        totalWidth = _cellLayoutManager$ge.width;\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;\n\n        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    });\n    _this._scrollbarSize = getScrollbarSize();\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n    return _this;\n  }\n\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n  _inherits(CollectionView, _React$PureComponent);\n  return _createClass(CollectionView, [{\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n        cellLayoutManager = _this$props4.cellLayoutManager,\n        scrollLeft = _this$props4.scrollLeft,\n        scrollToCell = _this$props4.scrollToCell,\n        scrollTop = _this$props4.scrollTop;\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = getScrollbarSize();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n      }\n\n      // Update onSectionRendered callback.\n      this._invokeOnSectionRenderedHelper();\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n        totalHeight = _cellLayoutManager$ge2.height,\n        totalWidth = _cellLayoutManager$ge2.width;\n\n      // Initialize onScroll callback.\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$props5 = this.props,\n        height = _this$props5.height,\n        scrollToAlignment = _this$props5.scrollToAlignment,\n        scrollToCell = _this$props5.scrollToCell,\n        width = _this$props5.width;\n      var _this$state2 = this.state,\n        scrollLeft = _this$state2.scrollLeft,\n        scrollPositionChangeReason = _this$state2.scrollPositionChangeReason,\n        scrollTop = _this$state2.scrollTop;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Update scroll offsets if the current :scrollToCell values requires it\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n        autoHeight = _this$props6.autoHeight,\n        cellCount = _this$props6.cellCount,\n        cellLayoutManager = _this$props6.cellLayoutManager,\n        className = _this$props6.className,\n        height = _this$props6.height,\n        horizontalOverscanSize = _this$props6.horizontalOverscanSize,\n        id = _this$props6.id,\n        noContentRenderer = _this$props6.noContentRenderer,\n        style = _this$props6.style,\n        verticalOverscanSize = _this$props6.verticalOverscanSize,\n        width = _this$props6.width;\n      var _this$state3 = this.state,\n        isScrolling = _this$state3.isScrolling,\n        scrollLeft = _this$state3.scrollLeft,\n        scrollTop = _this$state3.scrollTop;\n\n      // Memoization reset\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n        totalHeight = _cellLayoutManager$ge3.height,\n        totalWidth = _cellLayoutManager$ge3.width;\n\n      // Safely expand the rendered area by the specified overscan amount\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      };\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      return /*#__PURE__*/React.createElement(\"div\", {\n        ref: this._setScrollingContainerRef,\n        \"aria-label\": this.props['aria-label'],\n        className: clsx('ReactVirtualized__Collection', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: \"grid\",\n        style: _objectSpread(_objectSpread({}, collectionStyle), style),\n        tabIndex: 0\n      }, cellCount > 0 && /*#__PURE__*/React.createElement(\"div\", {\n        className: \"ReactVirtualized__Collection__innerScrollContainer\",\n        style: {\n          height: totalHeight,\n          maxHeight: totalHeight,\n          maxWidth: totalWidth,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          width: totalWidth\n        }\n      }, childrenToDisplay), cellCount === 0 && noContentRenderer());\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n  }, {\n    key: \"_enablePointerEventsAfterDelay\",\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n        isScrollingChange(false);\n        _this2._disablePointerEventsTimeoutId = null;\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref) {\n      var _this3 = this;\n      var scrollLeft = _ref.scrollLeft,\n        scrollTop = _ref.scrollTop,\n        totalHeight = _ref.totalHeight,\n        totalWidth = _ref.totalWidth;\n      this._onScrollMemoizer({\n        callback: function callback(_ref2) {\n          var scrollLeft = _ref2.scrollLeft,\n            scrollTop = _ref2.scrollTop;\n          var _this3$props = _this3.props,\n            height = _this3$props.height,\n            onScroll = _this3$props.onScroll,\n            width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_setScrollPosition\",\n    value: function _setScrollPosition(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n        scrollTop = _ref3.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n        };\n      }\n      return null;\n    }\n  }]);\n}(React.PureComponent);\n_defineProperty(CollectionView, \"defaultProps\", {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n});\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool,\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: PropTypes.object.isRequired,\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: PropTypes.string,\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: PropTypes.number.isRequired,\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: PropTypes.string,\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: PropTypes.number.isRequired,\n  isScrollingChange: PropTypes.func,\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: PropTypes.func.isRequired,\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: PropTypes.func.isRequired,\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: PropTypes.func.isRequired,\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: PropTypes.number,\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: PropTypes.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: PropTypes.number.isRequired,\n  /**\n   * Vertical offset.\n   */\n  scrollTop: PropTypes.number,\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: PropTypes.object,\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: PropTypes.number.isRequired,\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: PropTypes.number.isRequired\n} : {};\npolyfill(CollectionView);\nexport default CollectionView;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}