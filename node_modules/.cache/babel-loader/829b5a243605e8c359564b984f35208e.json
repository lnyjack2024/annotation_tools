{"ast":null,"code":"/* eslint-disable no-bitwise */\nimport WaveDrawer from './waveDrawer';\nimport WavDecoder from '../../utils/wav-decoder';\nimport Observer from '../../utils/observer';\nimport WebAudio from './webaudio';\nimport TimelinePlugin from './Timeline';\nimport RegionPlugin from './Region';\nimport { lawToWav } from '../../../../utils';\nexport let DrawType = /*#__PURE__*/function (DrawType) {\n  DrawType[\"INIT\"] = \"init\";\n  DrawType[\"RESIZE\"] = \"resize\";\n  DrawType[\"SCROLL\"] = \"scroll\";\n  DrawType[\"ZOOM\"] = \"zoom\";\n  return DrawType;\n}({});\nexport let PluginType = /*#__PURE__*/function (PluginType) {\n  PluginType[\"TIMELINE\"] = \"timeline\";\n  PluginType[\"REGION\"] = \"region\";\n  return PluginType;\n}({});\n;\nexport let OffsetType = /*#__PURE__*/function (OffsetType) {\n  OffsetType[\"OVERALL\"] = \"overall\";\n  OffsetType[\"CHANNEL\"] = \"channel\";\n  return OffsetType;\n}({});\nexport default class Wave extends Observer {\n  constructor({\n    container,\n    source,\n    offsetChannels,\n    ...options\n  }) {\n    super();\n    this.isReady = false;\n    this.params = void 0;\n    /**\n     * draw peaks\n     */\n    this.peaks = [];\n    this.drawer = void 0;\n    this.isDestroyed = false;\n    /**\n     * source file arraybuffer\n     */\n    this.arraybuffer = new ArrayBuffer(0);\n    /**\n     * source file audiobuffer\n     */\n    this.sourceBuffer = null;\n    /**\n     * draw audiobuffer\n     */\n    this.buffer = null;\n    /**\n     * multi channels peaks\n     */\n    this.splitPeaks = [];\n    /**\n     * merged channel peaks\n     */\n    this.mergedPeaks = [];\n    /**\n     * chanel count\n     */\n    this.channelCount = 0;\n    /**\n     * zoom\n     */\n    this.pxPerSec = 1;\n    /**\n     * cursor time\n     */\n    this.cursorTime = 0;\n    /**\n     * selected time\n     */\n    this.currentTime = 0;\n    /**\n     * wave width\n     */\n    this.width = 0;\n    /**\n     * wave height\n     */\n    this.height = 0;\n    /**\n     * waveform center\n     */\n    this.center = 0.5;\n    /**\n     * visible range precent\n     */\n    this.displayRange = {\n      start: 0,\n      end: 1\n    };\n    /**\n     * wave plugins\n     */\n    this.plugins = {};\n    this.initialisedPluginList = {};\n    this.backend = void 0;\n    this.isMuted = false;\n    // Used to save the current volume when muting so we can\n    this.savedVolume = 0;\n    this.hideChannels = [];\n    this.visibleChannelCount = 0;\n    this.channelOptions = [];\n    this.offsetChannels = [];\n    // Loads audio using Web Audio buffer backend.\n    this.loadBuffer = async url => {\n      try {\n        const tail = url.split('.').pop();\n        const arrayBuffer = await fetch(url).then(data => data.arrayBuffer());\n        this.loadArrayBuffer(arrayBuffer, tail);\n      } catch (error) {\n        this.fireEvent('load_error');\n      }\n    };\n    // Decode buffer and load\n    this.loadArrayBuffer = async (arraybuffer, format) => {\n      try {\n        this.arraybuffer = arraybuffer;\n        let audioBuffer = null;\n        if (format === 'wav') {\n          const decodeData = WavDecoder.decodeSync(arraybuffer);\n          audioBuffer = new AudioBuffer({\n            numberOfChannels: decodeData.numberOfChannels,\n            sampleRate: decodeData.sampleRate,\n            length: decodeData.length\n          });\n          for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n            const audioChannelBuffer = audioBuffer.getChannelData(i);\n            for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n              audioChannelBuffer[j] = decodeData.channelData[i][j];\n            }\n          }\n        } else if (format === 'alaw' || format === 'ulaw') {\n          audioBuffer = lawToWav(arraybuffer, format);\n        } else {\n          const audioCtx = new AudioContext();\n          audioBuffer = await audioCtx.decodeAudioData(arraybuffer);\n        }\n        this.loadAudioBuffer(audioBuffer);\n      } catch (error) {\n        this.fireEvent('load_error');\n      }\n    };\n    this.redraw = type => {\n      const {\n        clientHeight: parentHeight\n      } = this.params.container.parentNode;\n      const {\n        clientWidth\n      } = this.params.container;\n      let tiedupHeight = 0;\n      if (this.initialisedPluginList.timeline === true) {\n        tiedupHeight += this.plugins.timeline.height;\n      }\n      this.height = parentHeight - tiedupHeight;\n      this.params.container.style.height = `${parentHeight}px`;\n      if (this.width !== clientWidth && type === DrawType.RESIZE || type !== DrawType.RESIZE) {\n        const {\n          start,\n          end\n        } = this.displayRange;\n        this.width = clientWidth;\n        const length = this.pxPerSec * this.width;\n        this.setLength(clientWidth);\n        this.initPeaks(length, Math.floor(length * start), Math.floor(length * end));\n      }\n      if (this.drawer) {\n        this.drawBuffer();\n      }\n    };\n    this.scroll = ({\n      start,\n      end\n    }) => {\n      this.displayRange = {\n        start,\n        end\n      };\n      this.center = (start + end) / 2;\n      this.redraw(DrawType.SCROLL);\n    };\n    this.params = {\n      container,\n      audioContext: new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: 16000\n      }),\n      audioRate: 1,\n      autoCenter: true,\n      waveColor: '#A1A1A1',\n      disabledColor: '#A2A2A3',\n      backgroundColor: '#343846',\n      selectedBackgoundColor: '#000000',\n      cursorColor: '#34CBD1',\n      cursorWidth: 1,\n      duration: 0,\n      zoomEnabled: true,\n      mediaType: 'audio',\n      normalize: true,\n      pixelRatio: 1,\n      splitChannels: false,\n      ...options\n    };\n    if (offsetChannels !== undefined) {\n      this.offsetChannels = offsetChannels;\n    }\n  }\n  loadAudioBuffer(buffer) {\n    if (buffer) {\n      this.channelCount = buffer.numberOfChannels;\n      this.visibleChannelCount = this.channelCount;\n      this.buffer = buffer;\n      this.setSourceBuffer();\n      this.fireEvent('load');\n      this.init();\n    }\n  }\n\n  // copy audiobuffer use for offset\n  setSourceBuffer() {\n    if (this.buffer) {\n      this.sourceBuffer = new AudioBuffer({\n        numberOfChannels: this.buffer.numberOfChannels,\n        sampleRate: this.buffer.sampleRate,\n        length: this.buffer.length\n      });\n      for (let i = 0; i < this.channelCount; i += 1) {\n        this.sourceBuffer.copyToChannel(this.buffer.getChannelData(i), i, 0);\n      }\n    }\n  }\n\n  // offset channel\n  handleOffsetChannel(channel, offset, type = OffsetType.CHANNEL) {\n    if (this.buffer && this.sourceBuffer) {\n      const frameCount = Math.abs(this.sourceBuffer.sampleRate * offset);\n      const fillArray = new Float32Array(frameCount);\n      const audioChannelBuffer = this.sourceBuffer.getChannelData(channel);\n      const result = new Float32Array(audioChannelBuffer.length);\n      if (offset > 0) {\n        const channelArray = audioChannelBuffer.slice(0, audioChannelBuffer.length - frameCount);\n        result.set(fillArray, 0);\n        result.set(channelArray, fillArray.length);\n      } else if (offset < 0) {\n        const channelArray = audioChannelBuffer.slice(frameCount);\n        result.set(channelArray, 0);\n        result.set(fillArray, channelArray.length);\n      } else {\n        result.set(audioChannelBuffer, 0);\n      }\n      this.pause();\n      this.setCurrentTime(0);\n      this.buffer.copyToChannel(result, channel, 0);\n      if (type === OffsetType.CHANNEL) {\n        this.offsetChannels[channel] = offset;\n        this.handleOffset();\n      }\n    }\n  }\n  handleOffsetOverall(offsetChannels) {\n    this.offsetChannels = offsetChannels;\n    for (let i = 0; i < this.channelCount; i += 1) {\n      this.handleOffsetChannel(i, this.offsetChannels[i] || 0, OffsetType.OVERALL);\n    }\n    this.handleOffset();\n  }\n  handleOffset() {\n    var _this$backend;\n    (_this$backend = this.backend) === null || _this$backend === void 0 ? void 0 : _this$backend.load(this.buffer);\n    this.redraw(DrawType.INIT);\n  }\n  init() {\n    this.createBackend();\n    this.createDrawer();\n    this.handleOffsetOverall(this.offsetChannels);\n    this.registerPlugins(this.params.plugins);\n    this.isReady = true;\n    this.fireEvent('ready', this.getDuration(), this.channelCount);\n  }\n  createDrawer() {\n    const {\n      container,\n      backgroundColor,\n      selectedBackgoundColor,\n      pixelRatio,\n      splitChannels,\n      splitChannelsOptions,\n      channels\n    } = this.params;\n    this.drawer = new WaveDrawer({\n      wave: this,\n      container,\n      backgroundColor,\n      selectedBackgoundColor,\n      pixelRatio,\n      splitChannels,\n      splitChannelsOptions,\n      channels,\n      normalize: this.params.normalize\n    });\n    this.setDrawIndex([]);\n  }\n\n  /**\n   * Get the correct peaks for current wave view-port and render wave\n   *\n   * @private\n   */\n  drawBuffer() {\n    var _this$drawer;\n    const peaks = this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;\n    (_this$drawer = this.drawer) === null || _this$drawer === void 0 ? void 0 : _this$drawer.drawPeaks(peaks, this.width, this.height);\n    this.fireEvent('draw', this.displayRange);\n  }\n  getDuration() {\n    var _this$backend2;\n    return ((_this$backend2 = this.backend) === null || _this$backend2 === void 0 ? void 0 : _this$backend2.getDuration()) || 0;\n  }\n\n  // Set the rendered length (different from the length of the audio)\n  setLength(length) {\n    // No resize, we can preserve the cached peaks.\n    if (this.mergedPeaks && length === 2 * this.mergedPeaks.length - 1 + 2) {\n      return;\n    }\n    this.splitPeaks = [];\n    this.mergedPeaks = [];\n    // Set the last element of the sparse array so the peak arrays are\n    // appropriately sized for other calculations.\n    const channels = this.buffer ? this.buffer.numberOfChannels : 1;\n    let c;\n    for (c = 0; c < channels; c += 1) {\n      this.splitPeaks[c] = [];\n      this.splitPeaks[c][2 * (length - 1)] = 0;\n      this.splitPeaks[c][2 * (length - 1) + 1] = 0;\n    }\n    this.mergedPeaks[2 * (length - 1)] = 0;\n    this.mergedPeaks[2 * (length - 1) + 1] = 0;\n  }\n\n  // Compute the max and min value of the waveform when broken into <length> subranges.\n  initPeaks(length, _first, _last) {\n    if (!this.buffer) {\n      return;\n    }\n    const first = _first || 0;\n    const last = _last || length - 1;\n    const sampleSize = this.buffer.length / length;\n    const sampleStep = ~~(sampleSize / 10) || 1;\n    const channels = this.buffer.numberOfChannels;\n    let c;\n    for (c = 0; c < channels; c += 1) {\n      const peaks = this.splitPeaks[c];\n      const chan = this.buffer.getChannelData(c);\n      let i;\n      for (i = first; i <= last; i += 1) {\n        const start = ~~(i * sampleSize);\n        const end = ~~(start + sampleSize);\n        /**\n         * Initialize the max and min to the first sample of this\n         * subrange, so that even if the samples are entirely\n         * on one side of zero, we still return the true max and\n         * min values in the subrange.\n         */\n        let min = chan[start];\n        let max = min;\n        let j;\n        for (j = start; j < end; j += sampleStep) {\n          const value = chan[j];\n          if (value > max) {\n            max = value;\n          }\n          if (value < min) {\n            min = value;\n          }\n        }\n        const n = i - first;\n        peaks[2 * n] = max;\n        peaks[2 * n + 1] = min;\n        if (c === 0 || max > this.mergedPeaks[2 * n]) {\n          this.mergedPeaks[2 * n] = max;\n        }\n        if (c === 0 || min < this.mergedPeaks[2 * n + 1]) {\n          this.mergedPeaks[2 * n + 1] = min;\n        }\n      }\n    }\n  }\n  zoom(pxPerSec = 1, cursorPrecent) {\n    const {\n      start\n    } = this.displayRange;\n    let newstart = start + (pxPerSec - this.pxPerSec) / pxPerSec * (cursorPrecent - start);\n    newstart = newstart <= 0 ? 0 : newstart;\n    let newend = newstart + 1 / pxPerSec;\n    if (newend >= 1) {\n      newend = 1;\n      newstart = newend - 1 / pxPerSec;\n    }\n    this.displayRange = {\n      start: newstart,\n      end: newend\n    };\n    this.pxPerSec = pxPerSec;\n    this.center = (newstart + newend) / 2;\n    this.fireEvent('zoom', this.displayRange);\n    this.redraw(DrawType.ZOOM);\n  }\n\n  /**\n   * Add and initialise array of plugins,\n   * this function is called in the init function of wavesurfer\n   */\n  registerPlugins(plugins) {\n    if (plugins) {\n      const names = Object.keys(plugins);\n      // first instantiate all the plugins\n      names.forEach(name => this.addPlugin(name, plugins[name]));\n\n      // now run the init functions\n      names.forEach(name => {\n        // in that case you would manually use initPlugins()\n        this.initPlugin(name);\n      });\n      this.fireEvent('plugins-registered', plugins);\n    }\n    return this;\n  }\n\n  /**\n   * Add a plugin object to wavesurfer\n   */\n  addPlugin(name, options) {\n    if (!name) {\n      throw new Error('Plugin does not have a name!');\n    }\n    if (!options) {\n      throw new Error(`Plugin ${name} is missing required parameters!`);\n    }\n    if (Object.keys(PluginType).indexOf(name.toUpperCase()) < 0) {\n      throw new Error(`Plugin ${name} does not have an instance property!`);\n    }\n\n    /**\n     * Instantiated plugin classes are added as a property of the wavesurfer\n     * instance\n     * @type {Object}\n     */\n    if (name === PluginType.TIMELINE) {\n      this.plugins.timeline = new TimelinePlugin(options);\n    } else if (name === PluginType.REGION) {\n      this.plugins.region = new RegionPlugin(options);\n    }\n    this.fireEvent('plugin-added', name);\n    return this;\n  }\n\n  // Initialise a plugin\n  initPlugin(name) {\n    var _this$plugins$name;\n    if (!this.plugins[name]) {\n      throw new Error(`Plugin ${name} has not been added yet!`);\n    }\n    if (this.initialisedPluginList[name]) {\n      // destroy any already initialised plugins\n      this.destroyPlugin(name);\n    }\n    (_this$plugins$name = this.plugins[name]) === null || _this$plugins$name === void 0 ? void 0 : _this$plugins$name.init(this);\n    this.initialisedPluginList[name] = true;\n    this.fireEvent('plugin-initialised', name);\n    return this;\n  }\n\n  // Destroy a plugin\n  destroyPlugin(name) {\n    if (!this.plugins[name] || !this.plugins[name]) {\n      throw new Error(`Plugin ${name} has not been added yet and cannot be destroyed!`);\n    }\n    if (!this.initialisedPluginList[name]) {\n      throw new Error(`Plugin ${name} is not active and cannot be destroyed!`);\n    }\n    if (typeof this.plugins[name].destroy !== 'function') {\n      throw new Error(`Plugin ${name} does not have a destroy function!`);\n    }\n    this.plugins[name].destroy();\n    delete this.initialisedPluginList[name];\n    this.fireEvent('plugin-destroyed', name);\n    return this;\n  }\n\n  /**\n   * Destroy all initialised plugins. Convenience function to use when\n   * wavesurfer is removed\n   */\n  destroyAllPlugins() {\n    Object.keys(this.initialisedPluginList).forEach(name => this.destroyPlugin(name));\n  }\n\n  /**\n   * Create the backend\n   *\n   * @private\n   * @emits WaveSurfer#backend-created\n   */\n  createBackend() {\n    var _this$backend4, _this$backend5, _this$backend6, _this$backend7, _this$backend8;\n    if (this.backend) {\n      var _this$backend3;\n      (_this$backend3 = this.backend) === null || _this$backend3 === void 0 ? void 0 : _this$backend3.destroy();\n    }\n    this.backend = new WebAudio({\n      ...this.params,\n      wave: this\n    });\n    (_this$backend4 = this.backend) === null || _this$backend4 === void 0 ? void 0 : _this$backend4.init();\n    this.fireEvent('backend-created', this.backend);\n    (_this$backend5 = this.backend) === null || _this$backend5 === void 0 ? void 0 : _this$backend5.on('finish', () => {\n      this.fireEvent('finish');\n    });\n    (_this$backend6 = this.backend) === null || _this$backend6 === void 0 ? void 0 : _this$backend6.on('play', () => {\n      this.fireEvent('play');\n    });\n    (_this$backend7 = this.backend) === null || _this$backend7 === void 0 ? void 0 : _this$backend7.on('pause', () => {\n      this.fireEvent('pause');\n    });\n    (_this$backend8 = this.backend) === null || _this$backend8 === void 0 ? void 0 : _this$backend8.on('audioprocess', time => {\n      this.fireEvent('audioprocess', time);\n    });\n  }\n\n  /**\n   * Get the current playback position\n   */\n  getCurrentTime() {\n    var _this$backend9;\n    return ((_this$backend9 = this.backend) === null || _this$backend9 === void 0 ? void 0 : _this$backend9.getCurrentTime()) || 0;\n  }\n  moveCurrentTime(duration) {\n    this.setCurrentTime(this.getCurrentTime() + duration);\n  }\n\n  /**\n   * Set the current play time in seconds.\n   */\n  setCurrentTime(_seconds) {\n    var _ref;\n    const duration = this.getDuration();\n    let seconds = _seconds;\n    if (seconds >= duration) {\n      seconds = duration;\n    } else if (seconds < 0) {\n      seconds = 0;\n    }\n    this.seekTo(seconds / this.getDuration());\n    this.fireEvent('change-time', seconds);\n    (_ref = this.plugins.timeline) === null || _ref === void 0 ? void 0 : _ref.renderTimeline();\n  }\n\n  /**\n   * Starts playback from the current position. Optional start and end\n   * measured in seconds can be used to set the range of audio to play.\n   *\n   * @param {?number} start Position to start at\n   * @param {?number} end Position to end at\n   * @emits WaveSurfer#interaction\n   * @return {Promise} Result of the backend play method\n   * @example\n   * // play from second 1 to 5\n   * wavesurfer.play(1, 5);\n   */\n  play(start, end) {\n    return this.soloPlay(undefined, start, end);\n  }\n  soloPlay(channelIndex, start, end) {\n    var _this$backend0;\n    if (this.getCurrentTime() === this.getDuration()) {\n      this.setCurrentTime(0);\n    }\n    this.setChannelOptions(this.channelOptions, channelIndex !== undefined, channelIndex);\n    this.fireEvent('interaction', () => this.play(start, end));\n    return (_this$backend0 = this.backend) === null || _this$backend0 === void 0 ? void 0 : _this$backend0.play(start, end);\n  }\n\n  /**\n   * Set a point in seconds for playback to stop at.\n   *\n   * @param {number} position Position (in seconds) to stop at\n   */\n  setPlayEnd(position) {\n    var _this$backend1;\n    (_this$backend1 = this.backend) === null || _this$backend1 === void 0 ? void 0 : _this$backend1.setPlayEnd(position);\n  }\n\n  /**\n   * Stops and pauses playback\n   *\n   * @example wavesurfer.pause();\n   * @return {Promise} Result of the backend pause method\n   */\n  pause() {\n    var _this$backend10;\n    if (!((_this$backend10 = this.backend) === null || _this$backend10 === void 0 ? void 0 : _this$backend10.isPaused())) {\n      var _this$backend11;\n      return (_this$backend11 = this.backend) === null || _this$backend11 === void 0 ? void 0 : _this$backend11.pause();\n    }\n  }\n\n  /**\n   * Toggle playback\n   *\n   * @example wavesurfer.playPause();\n   * @return {Promise} Result of the backend play or pause method\n   */\n  playPause() {\n    var _this$backend12;\n    return ((_this$backend12 = this.backend) === null || _this$backend12 === void 0 ? void 0 : _this$backend12.isPaused()) ? this.play() : this.pause();\n  }\n\n  /**\n  * Get the current playback state\n  *\n  * @example const isPlaying = wavesurfer.isPlaying();\n  * @return {boolean} False if paused, true if playing\n  */\n  isPlaying() {\n    var _this$backend13;\n    return !((_this$backend13 = this.backend) === null || _this$backend13 === void 0 ? void 0 : _this$backend13.isPaused());\n  }\n\n  /**\n  * Skip backward\n  *\n  * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n  * is used\n  * @example wavesurfer.skipBackward();\n  */\n  skipBackward(seconds) {\n    this.skip(-(seconds || 0));\n  }\n\n  /**\n  * Skip forward\n  *\n  * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n  * is used\n  * @example wavesurfer.skipForward();\n  */\n  skipForward(seconds) {\n    this.skip(seconds);\n  }\n\n  /**\n   * Skip a number of seconds from the current position (use a negative value\n   * to go backwards).\n   *\n   * @param {number} offset Amount to skip back or forwards\n   * @example\n   * // go back 2 seconds\n   * wavesurfer.skip(-2);\n   */\n  skip(offset) {\n    const duration = this.getDuration() || 1;\n    let position = this.getCurrentTime() || 0;\n    position = Math.max(0, Math.min(duration, position + (offset || 0)));\n    this.seekAndCenter(position / duration);\n  }\n\n  /**\n   * Seeks to a position and centers the view\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @example\n   * // seek and go to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekAndCenter(progress) {\n    this.seekTo(progress);\n  }\n\n  /**\n   * Seeks to a position\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @emits WaveSurfer#interaction\n   * @emits WaveSurfer#seek\n   * @example\n   * // seek to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekTo(progress) {\n    var _this$backend14, _this$backend16;\n    this.fireEvent('interaction', () => this.seekTo(progress));\n    const paused = (_this$backend14 = this.backend) === null || _this$backend14 === void 0 ? void 0 : _this$backend14.isPaused();\n    if (!paused) {\n      var _this$backend15;\n      (_this$backend15 = this.backend) === null || _this$backend15 === void 0 ? void 0 : _this$backend15.pause();\n    }\n\n    // avoid small scrolls while paused seeking\n    (_this$backend16 = this.backend) === null || _this$backend16 === void 0 ? void 0 : _this$backend16.seekTo(progress * this.getDuration(), undefined);\n    if (!paused) {\n      var _this$backend17;\n      (_this$backend17 = this.backend) === null || _this$backend17 === void 0 ? void 0 : _this$backend17.play(undefined, undefined);\n    }\n    this.fireEvent('seek', progress);\n  }\n\n  /**\n   * Stops and goes to the beginning.\n   *\n   * @example wavesurfer.stop();\n   */\n  stop() {\n    this.pause();\n    this.seekTo(0);\n  }\n\n  /**\n   * Sets the ID of the audio device to use for output and returns a Promise.\n   *\n   * @param {string} deviceId String value representing underlying output\n   * device\n   * @returns {Promise} `Promise` that resolves to `undefined` when there are\n   * no errors detected.\n   */\n  setSinkId(deviceId) {\n    var _this$backend18;\n    return (_this$backend18 = this.backend) === null || _this$backend18 === void 0 ? void 0 : _this$backend18.setSinkId(deviceId);\n  }\n\n  /**\n   * Set the playback volume.\n   *\n   * @param {number} newVolume A value between 0 and 1, 0 being no\n   * @param {number} channelIndex channel index\n   * volume and 1 being full volume.\n   * @emits WaveSurfer#volume\n   */\n  setVolume(newVolume, channelIndex) {\n    var _this$backend19;\n    (_this$backend19 = this.backend) === null || _this$backend19 === void 0 ? void 0 : _this$backend19.setVolume(newVolume, channelIndex);\n    this.fireEvent('volume', newVolume);\n  }\n\n  /**\n   * Get the playback volume.\n   *\n   * @return {number} A value between 0 and 1, 0 being no\n   * volume and 1 being full volume.\n   */\n  getVolume() {\n    var _this$backend20;\n    return (_this$backend20 = this.backend) === null || _this$backend20 === void 0 ? void 0 : _this$backend20.getVolume();\n  }\n\n  /**\n   * Set the playback rate.\n   *\n   * @param {number} rate A positive number. E.g. 0.5 means half the normal\n   * speed, 2 means double speed and so on.\n   * @example wavesurfer.setPlaybackRate(2);\n   */\n  setPlaybackRate(rate) {\n    var _this$backend21, _this$backend22;\n    const scheduledPause = (_this$backend21 = this.backend) === null || _this$backend21 === void 0 ? void 0 : _this$backend21.scheduledPause;\n    const currentTime = this.getCurrentTime();\n    (_this$backend22 = this.backend) === null || _this$backend22 === void 0 ? void 0 : _this$backend22.setPlaybackRate(rate);\n    this.setCurrentTime(currentTime);\n    if (scheduledPause) {\n      this.setPlayEnd(scheduledPause);\n    }\n  }\n\n  /**\n   * Get the playback rate.\n   *\n   * @return {number} The current playback rate.\n   */\n  getPlaybackRate() {\n    var _this$backend23;\n    return (_this$backend23 = this.backend) === null || _this$backend23 === void 0 ? void 0 : _this$backend23.getPlaybackRate();\n  }\n  getPlayEnd() {\n    var _this$backend24;\n    return (_this$backend24 = this.backend) === null || _this$backend24 === void 0 ? void 0 : _this$backend24.getPlayEnd();\n  }\n\n  /**\n   * Toggle the volume on and off. If not currently muted it will save the\n   * current volume value and turn the volume off. If currently muted then it\n   * will restore the volume to the saved value, and then rest the saved\n   * value.\n   *\n   * @example wavesurfer.toggleMute();\n   */\n  toggleMute(channelIndex) {\n    this.setMute(!this.isMuted, channelIndex);\n  }\n\n  /**\n   * Enable or disable muted audio\n   *\n   * @param {boolean} mute Specify `true` to mute audio.\n   * @param {number} channelIndex\n   * @emits WaveSurfer#volume\n   * @emits WaveSurfer#mute\n   * @example\n   * // unmute\n   * wavesurfer.setMute(false);\n   * console.log(wavesurfer.getMute()) // logs false\n   */\n  setMute(mute, channelIndex) {\n    // ignore all muting requests if the audio is already in that state\n    if (mute === this.isMuted) {\n      this.fireEvent('mute', this.isMuted);\n      return;\n    }\n    if (mute) {\n      var _this$backend25, _this$backend26;\n      // If currently not muted then save current volume,\n      // turn off the volume and update the mute properties\n      this.savedVolume = ((_this$backend25 = this.backend) === null || _this$backend25 === void 0 ? void 0 : _this$backend25.getVolume()) || 0;\n      (_this$backend26 = this.backend) === null || _this$backend26 === void 0 ? void 0 : _this$backend26.setVolume(0, channelIndex);\n      this.isMuted = true;\n      this.fireEvent('volume', 0);\n    } else {\n      var _this$backend27;\n      // If currently muted then restore to the saved volume\n      // and update the mute properties\n      (_this$backend27 = this.backend) === null || _this$backend27 === void 0 ? void 0 : _this$backend27.setVolume(this.savedVolume, channelIndex);\n      this.isMuted = false;\n      this.fireEvent('volume', this.savedVolume);\n    }\n    this.fireEvent('mute', this.isMuted);\n  }\n\n  /**\n  * Get the current mute status.\n  *\n  * @example const isMuted = wavesurfer.getMute();\n  * @return {boolean} Current mute status\n  */\n  getMute() {\n    return this.isMuted;\n  }\n\n  /**\n   * Remove events, elements and disconnect WebAudio nodes.\n   *\n   * @emits WaveSurfer#destroy\n   */\n  destroy() {\n    this.destroyAllPlugins();\n    this.fireEvent('destroy');\n    this.isDestroyed = true;\n    this.isReady = false;\n    this.buffer = null;\n  }\n  setHideChannels(hideChannels) {\n    this.setDrawIndex(hideChannels);\n    this.redraw(DrawType.RESIZE);\n  }\n  setDrawIndex(hideChannels) {\n    var _this$drawer2;\n    this.hideChannels = hideChannels;\n    const channels = Array.from({\n      length: this.channelCount\n    }).map((v, i) => i);\n    const filteredChannels = channels.filter(v => hideChannels.indexOf(v) < 0);\n    const drawIndex = {};\n    channels.forEach(i => {\n      drawIndex[i] = filteredChannels.indexOf(i);\n    });\n    (_this$drawer2 = this.drawer) === null || _this$drawer2 === void 0 ? void 0 : _this$drawer2.setDrawIndex(drawIndex);\n    this.visibleChannelCount = filteredChannels.length;\n  }\n  setChannelOptions(options, isSolo, channelIndex) {\n    this.channelOptions = options;\n    options.forEach(({\n      volume,\n      mute,\n      index\n    }) => {\n      var _this$backend28;\n      const isMute = mute || isSolo && channelIndex !== undefined && index !== channelIndex;\n      (_this$backend28 = this.backend) === null || _this$backend28 === void 0 ? void 0 : _this$backend28.setVolume(isMute ? 0 : volume, index);\n    });\n  }\n}","map":{"version":3,"names":["WaveDrawer","WavDecoder","Observer","WebAudio","TimelinePlugin","RegionPlugin","lawToWav","DrawType","PluginType","OffsetType","Wave","constructor","container","source","offsetChannels","options","isReady","params","peaks","drawer","isDestroyed","arraybuffer","ArrayBuffer","sourceBuffer","buffer","splitPeaks","mergedPeaks","channelCount","pxPerSec","cursorTime","currentTime","width","height","center","displayRange","start","end","plugins","initialisedPluginList","backend","isMuted","savedVolume","hideChannels","visibleChannelCount","channelOptions","loadBuffer","url","tail","split","pop","arrayBuffer","fetch","then","data","loadArrayBuffer","error","fireEvent","format","audioBuffer","decodeData","decodeSync","AudioBuffer","numberOfChannels","sampleRate","length","i","audioChannelBuffer","getChannelData","j","channelData","audioCtx","AudioContext","decodeAudioData","loadAudioBuffer","redraw","type","clientHeight","parentHeight","parentNode","clientWidth","tiedupHeight","timeline","style","RESIZE","setLength","initPeaks","Math","floor","drawBuffer","scroll","SCROLL","audioContext","window","webkitAudioContext","audioRate","autoCenter","waveColor","disabledColor","backgroundColor","selectedBackgoundColor","cursorColor","cursorWidth","duration","zoomEnabled","mediaType","normalize","pixelRatio","splitChannels","undefined","setSourceBuffer","init","copyToChannel","handleOffsetChannel","channel","offset","CHANNEL","frameCount","abs","fillArray","Float32Array","result","channelArray","slice","set","pause","setCurrentTime","handleOffset","handleOffsetOverall","OVERALL","_this$backend","load","INIT","createBackend","createDrawer","registerPlugins","getDuration","splitChannelsOptions","channels","wave","setDrawIndex","_this$drawer","drawPeaks","_this$backend2","c","_first","_last","first","last","sampleSize","sampleStep","chan","min","max","value","n","zoom","cursorPrecent","newstart","newend","ZOOM","names","Object","keys","forEach","name","addPlugin","initPlugin","Error","indexOf","toUpperCase","TIMELINE","REGION","region","_this$plugins$name","destroyPlugin","destroy","destroyAllPlugins","_this$backend4","_this$backend5","_this$backend6","_this$backend7","_this$backend8","_this$backend3","on","time","getCurrentTime","_this$backend9","moveCurrentTime","_seconds","_ref","seconds","seekTo","renderTimeline","play","soloPlay","channelIndex","_this$backend0","setChannelOptions","setPlayEnd","position","_this$backend1","_this$backend10","isPaused","_this$backend11","playPause","_this$backend12","isPlaying","_this$backend13","skipBackward","skip","skipForward","seekAndCenter","progress","_this$backend14","_this$backend16","paused","_this$backend15","_this$backend17","stop","setSinkId","deviceId","_this$backend18","setVolume","newVolume","_this$backend19","getVolume","_this$backend20","setPlaybackRate","rate","_this$backend21","_this$backend22","scheduledPause","getPlaybackRate","_this$backend23","getPlayEnd","_this$backend24","toggleMute","setMute","mute","_this$backend25","_this$backend26","_this$backend27","getMute","setHideChannels","_this$drawer2","Array","from","map","v","filteredChannels","filter","drawIndex","isSolo","volume","index","_this$backend28","isMute"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/multi-channel/components/Wave/index.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport WaveDrawer from './waveDrawer';\nimport WavDecoder from '../../utils/wav-decoder';\nimport Observer from '../../utils/observer';\nimport WebAudio from './webaudio';\nimport TimelinePlugin, { TimelineOptions } from './Timeline';\nimport RegionPlugin, { RegionOptions } from './Region';\nimport { lawToWav } from '../../../../utils';\nimport { ChannelOptions, Channel, CustomChannelOptions } from './types';\n\nexport enum DrawType {\n  INIT = 'init',\n  RESIZE = 'resize',\n  SCROLL = 'scroll',\n  ZOOM = 'zoom',\n}\n\nexport enum PluginType {\n  TIMELINE = 'timeline',\n  REGION = 'region',\n};\n\nexport enum OffsetType {\n  OVERALL = 'overall',\n  CHANNEL = 'channel',\n}\n\ntype PluginOptions = TimelineOptions | RegionOptions;\n\nexport type Plugins = {\n  [PluginType.REGION]?: RegionPlugin,\n  [PluginType.TIMELINE]?: TimelinePlugin,\n};\n\ninterface WaveOptions {\n  container: HTMLElement;\n  source?: string;\n  audioContext?: AudioContext;\n  audioRate?: number;\n  autoCenter?: boolean;\n  waveColor?: string;\n  disabledColor?: string;\n  backgroundColor?: string;\n  selectedBackgoundColor?: string;\n  cursorColor?: string;\n  cursorWidth?: number;\n  duration?: number;\n  height?: number;\n  zoomEnabled?: boolean;\n  scrollEnabled?: boolean;\n  mediaType?: string;\n  normalize?: boolean;\n  pixelRatio?: number;\n  splitChannels?: boolean;\n  splitChannelsOptions?: ChannelOptions;\n  channels: Channel[];\n  plugins?: {[key in PluginType]?: PluginOptions};\n  offsetChannels?: number[];\n}\n\ninterface WaveParams {\n  container: HTMLElement;\n  audioContext: AudioContext;\n  audioRate: number;\n  autoCenter: boolean;\n  waveColor: string;\n  disabledColor: string;\n  backgroundColor: string;\n  selectedBackgoundColor: string;\n  cursorColor: string;\n  cursorWidth: number;\n  duration: number;\n  zoomEnabled: boolean;\n  mediaType: string;\n  normalize: boolean;\n  pixelRatio: number;\n  splitChannels: boolean;\n  splitChannelsOptions?: ChannelOptions;\n  channels: Channel[];\n  plugins?: {[key in PluginType]?: PluginOptions};\n}\n\nexport default class Wave extends Observer {\n  isReady = false;\n\n  params: WaveParams;\n\n  /**\n   * draw peaks\n   */\n  peaks: number[] | number[][] = [];\n\n  drawer?: WaveDrawer;\n\n  isDestroyed = false;\n\n  /**\n   * source file arraybuffer\n   */\n  arraybuffer: ArrayBuffer = new ArrayBuffer(0);\n\n  /**\n   * source file audiobuffer\n   */\n  sourceBuffer: AudioBuffer | null = null;\n\n  /**\n   * draw audiobuffer\n   */\n  buffer: AudioBuffer | null = null;\n\n  /**\n   * multi channels peaks\n   */\n  splitPeaks: number[][] = [];\n\n  /**\n   * merged channel peaks\n   */\n  mergedPeaks: number[] = [];\n\n  /**\n   * chanel count\n   */\n  channelCount = 0;\n\n  /**\n   * zoom\n   */\n  pxPerSec = 1;\n\n  /**\n   * cursor time\n   */\n  cursorTime = 0;\n\n  /**\n   * selected time\n   */\n  currentTime = 0;\n\n  /**\n   * wave width\n   */\n  width = 0;\n\n  /**\n   * wave height\n   */\n  height = 0;\n\n  /**\n   * waveform center\n   */\n  center = 0.5;\n\n  /**\n   * visible range precent\n   */\n  displayRange = {\n    start: 0,\n    end: 1,\n  };\n\n  /**\n   * wave plugins\n   */\n  plugins: Plugins = {};\n\n  initialisedPluginList: {[key in PluginType]?: boolean} = {};\n\n  backend?: WebAudio;\n\n  isMuted = false;\n\n  // Used to save the current volume when muting so we can\n  savedVolume = 0;\n\n  hideChannels: number[] = [];\n\n  visibleChannelCount = 0;\n\n  channelOptions: CustomChannelOptions[] = [];\n\n  offsetChannels: number[] = [];\n\n  constructor({ container, source, offsetChannels, ...options }: WaveOptions) {\n    super();\n    this.params = {\n      container,\n      audioContext: new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: 16000 }),\n      audioRate: 1,\n      autoCenter: true,\n      waveColor: '#A1A1A1',\n      disabledColor: '#A2A2A3',\n      backgroundColor: '#343846',\n      selectedBackgoundColor: '#000000',\n      cursorColor: '#34CBD1',\n      cursorWidth: 1,\n      duration: 0,\n      zoomEnabled: true,\n      mediaType: 'audio',\n      normalize: true,\n      pixelRatio: 1,\n      splitChannels: false,\n      ...options,\n    };\n\n    if (offsetChannels !== undefined) {\n      this.offsetChannels = offsetChannels;\n    }\n  }\n\n  // Loads audio using Web Audio buffer backend.\n  loadBuffer = async (url: string) => {\n    try {\n      const tail = url.split('.').pop();\n      const arrayBuffer = await fetch(url)\n        .then((data) => data.arrayBuffer());\n      this.loadArrayBuffer(arrayBuffer, tail);\n    } catch (error) {\n      this.fireEvent('load_error');\n    }\n  };\n\n  // Decode buffer and load\n  loadArrayBuffer = async (arraybuffer: ArrayBuffer, format?: string) => {\n    try {\n      this.arraybuffer = arraybuffer;\n      let audioBuffer: AudioBuffer | null = null;\n      if (format === 'wav') {\n        const decodeData = WavDecoder.decodeSync(arraybuffer);\n        audioBuffer = new AudioBuffer({\n          numberOfChannels: decodeData.numberOfChannels,\n          sampleRate: decodeData.sampleRate,\n          length: decodeData.length,\n        });\n        for (let i = 0; i < decodeData.numberOfChannels; i += 1) {\n          const audioChannelBuffer = audioBuffer.getChannelData(i);\n          for (let j = 0; j < decodeData.channelData[i].length; j += 1) {\n            audioChannelBuffer[j] = decodeData.channelData[i][j];\n          }\n        }\n      } else if (format === 'alaw' || format === 'ulaw') {\n        audioBuffer = lawToWav(arraybuffer, format);\n      } else {\n        const audioCtx = new AudioContext();\n        audioBuffer = await audioCtx.decodeAudioData(arraybuffer);\n      }\n      this.loadAudioBuffer(audioBuffer);\n    } catch (error) {\n      this.fireEvent('load_error');\n    }\n  };\n\n  loadAudioBuffer(buffer?: AudioBuffer) {\n    if (buffer) {\n      this.channelCount = buffer.numberOfChannels;\n      this.visibleChannelCount = this.channelCount;\n      this.buffer = buffer;\n      this.setSourceBuffer();\n      this.fireEvent('load');\n      this.init();\n    }\n  }\n\n  // copy audiobuffer use for offset\n  setSourceBuffer() {\n    if (this.buffer) {\n      this.sourceBuffer = new AudioBuffer({\n        numberOfChannels: this.buffer.numberOfChannels,\n        sampleRate: this.buffer.sampleRate,\n        length: this.buffer.length,\n      });\n      for (let i = 0; i < this.channelCount; i += 1) {\n        this.sourceBuffer.copyToChannel(this.buffer.getChannelData(i), i, 0);\n      }\n    }\n  }\n\n  // offset channel\n  handleOffsetChannel(channel: number, offset: number, type = OffsetType.CHANNEL) {\n    if (this.buffer && this.sourceBuffer) {\n      const frameCount = Math.abs(this.sourceBuffer.sampleRate * offset);\n      const fillArray = new Float32Array(frameCount);\n      const audioChannelBuffer = this.sourceBuffer.getChannelData(channel);\n      const result = new Float32Array(audioChannelBuffer.length);\n      if (offset > 0) {\n        const channelArray = audioChannelBuffer.slice(0, audioChannelBuffer.length - frameCount);\n        result.set(fillArray, 0);\n        result.set(channelArray, fillArray.length);\n      } else if (offset < 0) {\n        const channelArray = audioChannelBuffer.slice(frameCount);\n        result.set(channelArray, 0);\n        result.set(fillArray, channelArray.length);\n      } else {\n        result.set(audioChannelBuffer, 0);\n      }\n      this.pause();\n      this.setCurrentTime(0);\n      this.buffer.copyToChannel(result, channel, 0);\n      if (type === OffsetType.CHANNEL) {\n        this.offsetChannels[channel] = offset;\n        this.handleOffset();\n      }\n    }\n  }\n\n  handleOffsetOverall(offsetChannels: number[]) {\n    this.offsetChannels = offsetChannels;\n    for (let i = 0; i < this.channelCount; i += 1) {\n      this.handleOffsetChannel(i, this.offsetChannels[i] || 0, OffsetType.OVERALL);\n    }\n    this.handleOffset();\n  }\n\n  handleOffset() {\n    this.backend?.load(this.buffer!);\n    this.redraw(DrawType.INIT);\n  }\n\n  init() {\n    this.createBackend();\n    this.createDrawer();\n    this.handleOffsetOverall(this.offsetChannels);\n    this.registerPlugins(this.params.plugins);\n    this.isReady = true;\n    this.fireEvent('ready', this.getDuration(), this.channelCount);\n  }\n\n  redraw = (type?: DrawType) => {\n    const { clientHeight: parentHeight } = this.params.container.parentNode as HTMLElement;\n    const { clientWidth } = this.params.container;\n    let tiedupHeight = 0;\n    if (this.initialisedPluginList.timeline === true) {\n      tiedupHeight += (this.plugins.timeline as TimelinePlugin).height;\n    }\n    this.height = parentHeight - tiedupHeight;\n    this.params.container.style.height = `${parentHeight}px`;\n    if ((this.width !== clientWidth && type === DrawType.RESIZE) || type !== DrawType.RESIZE) {\n      const { start, end } = this.displayRange;\n      this.width = clientWidth;\n      const length = this.pxPerSec * this.width;\n      this.setLength(clientWidth);\n      this.initPeaks(length, Math.floor(length * start), Math.floor(length * end));\n    }\n\n    if (this.drawer) {\n      this.drawBuffer();\n    }\n  };\n\n  scroll = ({ start, end }: { start: number; end: number }) => {\n    this.displayRange = {\n      start,\n      end,\n    };\n    this.center = (start + end) / 2;\n    this.redraw(DrawType.SCROLL);\n  };\n\n  createDrawer() {\n    const {\n      container, backgroundColor, selectedBackgoundColor, pixelRatio,\n      splitChannels, splitChannelsOptions, channels,\n    } = this.params;\n    this.drawer = new WaveDrawer({\n      wave: this,\n      container,\n      backgroundColor,\n      selectedBackgoundColor,\n      pixelRatio,\n      splitChannels,\n      splitChannelsOptions,\n      channels,\n      normalize: this.params.normalize,\n    });\n    this.setDrawIndex([]);\n  }\n\n  /**\n   * Get the correct peaks for current wave view-port and render wave\n   *\n   * @private\n   */\n  drawBuffer() {\n    const peaks = this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;\n    this.drawer?.drawPeaks(peaks, this.width, this.height);\n    this.fireEvent('draw', this.displayRange);\n  }\n\n  getDuration() {\n    return this.backend?.getDuration() || 0;\n  }\n\n  // Set the rendered length (different from the length of the audio)\n  setLength(length: number) {\n    // No resize, we can preserve the cached peaks.\n    if (this.mergedPeaks && length === 2 * this.mergedPeaks.length - 1 + 2) {\n      return;\n    }\n\n    this.splitPeaks = [];\n    this.mergedPeaks = [];\n    // Set the last element of the sparse array so the peak arrays are\n    // appropriately sized for other calculations.\n    const channels = this.buffer ? this.buffer.numberOfChannels : 1;\n    let c;\n    for (c = 0; c < channels; c += 1) {\n      this.splitPeaks[c] = [];\n      this.splitPeaks[c][2 * (length - 1)] = 0;\n      this.splitPeaks[c][2 * (length - 1) + 1] = 0;\n    }\n    this.mergedPeaks[2 * (length - 1)] = 0;\n    this.mergedPeaks[2 * (length - 1) + 1] = 0;\n  }\n\n  // Compute the max and min value of the waveform when broken into <length> subranges.\n  initPeaks(length: number, _first?: number, _last?: number) {\n    if (!this.buffer) {\n      return;\n    }\n    const first = _first || 0;\n    const last = _last || length - 1;\n\n    const sampleSize = this.buffer.length / length;\n    const sampleStep = ~~(sampleSize / 10) || 1;\n    const channels = this.buffer.numberOfChannels;\n    let c;\n\n    for (c = 0; c < channels; c += 1) {\n      const peaks = this.splitPeaks[c];\n      const chan = this.buffer.getChannelData(c);\n      let i;\n      for (i = first; i <= last; i += 1) {\n        const start = ~~(i * sampleSize);\n        const end = ~~(start + sampleSize);\n        /**\n         * Initialize the max and min to the first sample of this\n         * subrange, so that even if the samples are entirely\n         * on one side of zero, we still return the true max and\n         * min values in the subrange.\n         */\n        let min = chan[start];\n        let max = min;\n        let j;\n\n        for (j = start; j < end; j += sampleStep) {\n          const value = chan[j];\n\n          if (value > max) {\n            max = value;\n          }\n\n          if (value < min) {\n            min = value;\n          }\n        }\n        const n = i - first;\n        peaks[2 * n] = max;\n        peaks[2 * n + 1] = min;\n        if (c === 0 || max > this.mergedPeaks[2 * n]) {\n          this.mergedPeaks[2 * n] = max;\n        }\n        if (c === 0 || min < this.mergedPeaks[2 * n + 1]) {\n          this.mergedPeaks[2 * n + 1] = min;\n        }\n      }\n    }\n  }\n\n  zoom(pxPerSec = 1, cursorPrecent: number) {\n    const { start } = this.displayRange;\n    let newstart = start + ((pxPerSec - this.pxPerSec) / pxPerSec) * (cursorPrecent - start);\n    newstart = newstart <= 0 ? 0 : newstart;\n    let newend = newstart + 1 / pxPerSec;\n    if (newend >= 1) {\n      newend = 1;\n      newstart = newend - 1 / pxPerSec;\n    }\n    this.displayRange = {\n      start: newstart,\n      end: newend\n    };\n    this.pxPerSec = pxPerSec;\n    this.center = (newstart + newend) / 2;\n    this.fireEvent('zoom', this.displayRange);\n    this.redraw(DrawType.ZOOM);\n  }\n\n  /**\n   * Add and initialise array of plugins,\n   * this function is called in the init function of wavesurfer\n   */\n  registerPlugins(plugins?: {[key in PluginType]?: PluginOptions}) {\n    if (plugins) {\n      const names = Object.keys(plugins) as PluginType[];\n      // first instantiate all the plugins\n      names.forEach((name) => this.addPlugin(name, plugins[name]));\n\n      // now run the init functions\n      names.forEach((name) => {\n        // in that case you would manually use initPlugins()\n        this.initPlugin(name);\n      });\n      this.fireEvent('plugins-registered', plugins);\n    }\n    return this;\n  }\n\n  /**\n   * Add a plugin object to wavesurfer\n   */\n  addPlugin(name: string, options?: PluginOptions) {\n    if (!name) {\n      throw new Error('Plugin does not have a name!');\n    }\n    if (!options) {\n      throw new Error(`Plugin ${name} is missing required parameters!`);\n    }\n    if (Object.keys(PluginType).indexOf(name.toUpperCase()) < 0) {\n      throw new Error(\n        `Plugin ${name} does not have an instance property!`\n      );\n    }\n\n    /**\n     * Instantiated plugin classes are added as a property of the wavesurfer\n     * instance\n     * @type {Object}\n     */\n    if (name === PluginType.TIMELINE) {\n      this.plugins.timeline = new TimelinePlugin(options as TimelineOptions);\n    } else if (name === PluginType.REGION) {\n      this.plugins.region = new RegionPlugin(options as RegionOptions);\n    }\n    this.fireEvent('plugin-added', name);\n    return this;\n  }\n\n  // Initialise a plugin\n  initPlugin(name: PluginType) {\n    if (!this.plugins[name]) {\n      throw new Error(`Plugin ${name} has not been added yet!`);\n    }\n    if (this.initialisedPluginList[name]) {\n      // destroy any already initialised plugins\n      this.destroyPlugin(name);\n    }\n\n    this.plugins[name]?.init(this);\n\n    this.initialisedPluginList[name] = true;\n    this.fireEvent('plugin-initialised', name);\n    return this;\n  }\n\n  // Destroy a plugin\n  destroyPlugin(name: PluginType) {\n    if (!this.plugins[name] || !this.plugins[name]) {\n      throw new Error(\n        `Plugin ${name} has not been added yet and cannot be destroyed!`\n      );\n    }\n    if (!this.initialisedPluginList[name]) {\n      throw new Error(\n        `Plugin ${name} is not active and cannot be destroyed!`\n      );\n    }\n    if (typeof this.plugins[name]!.destroy !== 'function') {\n      throw new Error(`Plugin ${name} does not have a destroy function!`);\n    }\n\n    this.plugins[name]!.destroy();\n    delete this.initialisedPluginList[name];\n    this.fireEvent('plugin-destroyed', name);\n    return this;\n  }\n\n  /**\n   * Destroy all initialised plugins. Convenience function to use when\n   * wavesurfer is removed\n   */\n  destroyAllPlugins() {\n    Object.keys(this.initialisedPluginList).forEach((name) => this.destroyPlugin(name as PluginType));\n  }\n\n  /**\n   * Create the backend\n   *\n   * @private\n   * @emits WaveSurfer#backend-created\n   */\n  createBackend() {\n    if (this.backend) {\n      this.backend?.destroy();\n    }\n\n    this.backend = new WebAudio({\n      ...this.params,\n      wave: this,\n    });\n    this.backend?.init();\n    this.fireEvent('backend-created', this.backend);\n\n    this.backend?.on('finish', () => {\n      this.fireEvent('finish');\n    });\n    this.backend?.on('play', () => {\n      this.fireEvent('play');\n    });\n    this.backend?.on('pause', () => {\n      this.fireEvent('pause');\n    });\n\n    this.backend?.on('audioprocess', (time: number) => {\n      this.fireEvent('audioprocess', time);\n    });\n  }\n\n  /**\n   * Get the current playback position\n   */\n  getCurrentTime() {\n    return this.backend?.getCurrentTime() || 0;\n  }\n\n  moveCurrentTime(duration: number) {\n    this.setCurrentTime(this.getCurrentTime() + duration);\n  }\n\n  /**\n   * Set the current play time in seconds.\n   */\n  setCurrentTime(_seconds: number) {\n    const duration = this.getDuration();\n    let seconds = _seconds;\n    if (seconds >= duration) {\n      seconds = duration;\n    } else if (seconds < 0) {\n      seconds = 0;\n    }\n    this.seekTo(seconds / this.getDuration());\n    this.fireEvent('change-time', seconds);\n\n    (this.plugins.timeline as TimelinePlugin)?.renderTimeline();\n  }\n\n  /**\n   * Starts playback from the current position. Optional start and end\n   * measured in seconds can be used to set the range of audio to play.\n   *\n   * @param {?number} start Position to start at\n   * @param {?number} end Position to end at\n   * @emits WaveSurfer#interaction\n   * @return {Promise} Result of the backend play method\n   * @example\n   * // play from second 1 to 5\n   * wavesurfer.play(1, 5);\n   */\n  play(start?: number, end?: number) {\n    return this.soloPlay(undefined, start, end);\n  }\n\n  soloPlay(channelIndex?: number, start?: number, end?: number) {\n    if (this.getCurrentTime() === this.getDuration()) {\n      this.setCurrentTime(0);\n    }\n    this.setChannelOptions(this.channelOptions, channelIndex !== undefined, channelIndex);\n    this.fireEvent('interaction', () => this.play(start, end));\n    return this.backend?.play(start, end);\n  }\n\n  /**\n   * Set a point in seconds for playback to stop at.\n   *\n   * @param {number} position Position (in seconds) to stop at\n   */\n  setPlayEnd(position: number) {\n    this.backend?.setPlayEnd(position);\n  }\n\n  /**\n   * Stops and pauses playback\n   *\n   * @example wavesurfer.pause();\n   * @return {Promise} Result of the backend pause method\n   */\n  pause() {\n    if (!this.backend?.isPaused()) {\n      return this.backend?.pause();\n    }\n  }\n\n  /**\n   * Toggle playback\n   *\n   * @example wavesurfer.playPause();\n   * @return {Promise} Result of the backend play or pause method\n   */\n  playPause() {\n    return this.backend?.isPaused() ? this.play() : this.pause();\n  }\n\n  /**\n * Get the current playback state\n *\n * @example const isPlaying = wavesurfer.isPlaying();\n * @return {boolean} False if paused, true if playing\n */\n  isPlaying() {\n    return !this.backend?.isPaused();\n  }\n\n  /**\n * Skip backward\n *\n * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n * is used\n * @example wavesurfer.skipBackward();\n */\n  skipBackward(seconds?: number) {\n    this.skip(-(seconds || 0));\n  }\n\n  /**\n * Skip forward\n *\n * @param {?number} seconds Amount to skip back, if not specified `skipLength`\n * is used\n * @example wavesurfer.skipForward();\n */\n  skipForward(seconds?: number) {\n    this.skip(seconds);\n  }\n\n  /**\n   * Skip a number of seconds from the current position (use a negative value\n   * to go backwards).\n   *\n   * @param {number} offset Amount to skip back or forwards\n   * @example\n   * // go back 2 seconds\n   * wavesurfer.skip(-2);\n   */\n  skip(offset?: number) {\n    const duration = this.getDuration() || 1;\n    let position = this.getCurrentTime() || 0;\n    position = Math.max(0, Math.min(duration, position + (offset || 0)));\n    this.seekAndCenter(position / duration);\n  }\n\n  /**\n   * Seeks to a position and centers the view\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @example\n   * // seek and go to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekAndCenter(progress: number) {\n    this.seekTo(progress);\n  }\n\n  /**\n   * Seeks to a position\n   *\n   * @param {number} progress Between 0 (=beginning) and 1 (=end)\n   * @emits WaveSurfer#interaction\n   * @emits WaveSurfer#seek\n   * @example\n   * // seek to the middle of the audio\n   * wavesurfer.seekTo(0.5);\n   */\n  seekTo(progress: number) {\n    this.fireEvent('interaction', () => this.seekTo(progress));\n    const paused = this.backend?.isPaused();\n\n    if (!paused) {\n      this.backend?.pause();\n    }\n\n    // avoid small scrolls while paused seeking\n    this.backend?.seekTo(progress * this.getDuration(), undefined);\n\n    if (!paused) {\n      this.backend?.play(undefined, undefined);\n    }\n    this.fireEvent('seek', progress);\n  }\n\n  /**\n   * Stops and goes to the beginning.\n   *\n   * @example wavesurfer.stop();\n   */\n  stop() {\n    this.pause();\n    this.seekTo(0);\n  }\n\n  /**\n   * Sets the ID of the audio device to use for output and returns a Promise.\n   *\n   * @param {string} deviceId String value representing underlying output\n   * device\n   * @returns {Promise} `Promise` that resolves to `undefined` when there are\n   * no errors detected.\n   */\n  setSinkId(deviceId: string) {\n    return this.backend?.setSinkId(deviceId);\n  }\n\n  /**\n   * Set the playback volume.\n   *\n   * @param {number} newVolume A value between 0 and 1, 0 being no\n   * @param {number} channelIndex channel index\n   * volume and 1 being full volume.\n   * @emits WaveSurfer#volume\n   */\n  setVolume(newVolume: number, channelIndex: number) {\n    this.backend?.setVolume(newVolume, channelIndex);\n    this.fireEvent('volume', newVolume);\n  }\n\n  /**\n   * Get the playback volume.\n   *\n   * @return {number} A value between 0 and 1, 0 being no\n   * volume and 1 being full volume.\n   */\n  getVolume() {\n    return this.backend?.getVolume();\n  }\n\n  /**\n   * Set the playback rate.\n   *\n   * @param {number} rate A positive number. E.g. 0.5 means half the normal\n   * speed, 2 means double speed and so on.\n   * @example wavesurfer.setPlaybackRate(2);\n   */\n  setPlaybackRate(rate: number) {\n    const scheduledPause = this.backend?.scheduledPause;\n    const currentTime = this.getCurrentTime();\n    this.backend?.setPlaybackRate(rate);\n    this.setCurrentTime(currentTime);\n    if (scheduledPause) {\n      this.setPlayEnd(scheduledPause);\n    }\n  }\n\n  /**\n   * Get the playback rate.\n   *\n   * @return {number} The current playback rate.\n   */\n  getPlaybackRate() {\n    return this.backend?.getPlaybackRate();\n  }\n\n  getPlayEnd() {\n    return this.backend?.getPlayEnd();\n  }\n\n  /**\n   * Toggle the volume on and off. If not currently muted it will save the\n   * current volume value and turn the volume off. If currently muted then it\n   * will restore the volume to the saved value, and then rest the saved\n   * value.\n   *\n   * @example wavesurfer.toggleMute();\n   */\n  toggleMute(channelIndex: number) {\n    this.setMute(!this.isMuted, channelIndex);\n  }\n\n  /**\n   * Enable or disable muted audio\n   *\n   * @param {boolean} mute Specify `true` to mute audio.\n   * @param {number} channelIndex\n   * @emits WaveSurfer#volume\n   * @emits WaveSurfer#mute\n   * @example\n   * // unmute\n   * wavesurfer.setMute(false);\n   * console.log(wavesurfer.getMute()) // logs false\n   */\n  setMute(mute: boolean, channelIndex: number) {\n    // ignore all muting requests if the audio is already in that state\n    if (mute === this.isMuted) {\n      this.fireEvent('mute', this.isMuted);\n      return;\n    }\n\n    if (mute) {\n      // If currently not muted then save current volume,\n      // turn off the volume and update the mute properties\n      this.savedVolume = this.backend?.getVolume() || 0;\n      this.backend?.setVolume(0, channelIndex);\n      this.isMuted = true;\n      this.fireEvent('volume', 0);\n    } else {\n      // If currently muted then restore to the saved volume\n      // and update the mute properties\n      this.backend?.setVolume(this.savedVolume, channelIndex);\n      this.isMuted = false;\n      this.fireEvent('volume', this.savedVolume);\n    }\n    this.fireEvent('mute', this.isMuted);\n  }\n\n  /**\n * Get the current mute status.\n *\n * @example const isMuted = wavesurfer.getMute();\n * @return {boolean} Current mute status\n */\n  getMute() {\n    return this.isMuted;\n  }\n\n  /**\n   * Remove events, elements and disconnect WebAudio nodes.\n   *\n   * @emits WaveSurfer#destroy\n   */\n  destroy() {\n    this.destroyAllPlugins();\n    this.fireEvent('destroy');\n    this.isDestroyed = true;\n    this.isReady = false;\n    this.buffer = null;\n  }\n\n  setHideChannels(hideChannels: number[]) {\n    this.setDrawIndex(hideChannels);\n    this.redraw(DrawType.RESIZE);\n  }\n\n  setDrawIndex(hideChannels: number[]) {\n    this.hideChannels = hideChannels;\n    const channels = Array.from({ length: this.channelCount }).map((v, i) => i);\n    const filteredChannels = channels.filter((v) => hideChannels.indexOf(v) < 0);\n    const drawIndex:{ [channelIndex: number]: number} = {};\n    channels.forEach((i) => {\n      drawIndex[i] = filteredChannels.indexOf(i);\n    });\n    this.drawer?.setDrawIndex(drawIndex);\n    this.visibleChannelCount = filteredChannels.length;\n  }\n\n  setChannelOptions(options: CustomChannelOptions[], isSolo?: boolean, channelIndex?: number) {\n    this.channelOptions = options;\n    options.forEach(({ volume, mute, index }) => {\n      const isMute = mute || (isSolo && channelIndex !== undefined && index !== channelIndex);\n      this.backend?.setVolume(isMute ? 0 : volume, index);\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}