{"ast":null,"code":"/* eslint-disable class-methods-use-this */\nimport EventEmitter from 'eventemitter3';\nimport { cloneDeep } from 'lodash';\nimport { drawLine, drawRect, drawRectBorder, drawRoundedRect, drawCircle, drawScale, drawText, drawRhombus } from '../utils/canvas';\nimport Cursor from '../components/common/Cursor';\nexport let FrameItemType = /*#__PURE__*/function (FrameItemType) {\n  FrameItemType[\"DEFAULT\"] = \"default\";\n  FrameItemType[\"CARD\"] = \"card\";\n  FrameItemType[\"TEXT\"] = \"text\";\n  FrameItemType[\"ENDPOINT\"] = \"endpoint\";\n  return FrameItemType;\n}({});\nexport let EventAction = /*#__PURE__*/function (EventAction) {\n  EventAction[\"HEIGHT_CHANGE\"] = \"height-change\";\n  EventAction[\"VISIBLE_FRAMES_UPDATE\"] = \"visible-frames-update\";\n  EventAction[\"CURRENT_FRAME_CHANGE\"] = \"current-frame-change\";\n  EventAction[\"ITEMS_OFFSET_CHANGE\"] = \"items-offset-change\";\n  EventAction[\"BLOCK_HOVERED\"] = \"block-hovered\";\n  EventAction[\"BLOCK_SELECTED\"] = \"block-selected\";\n  EventAction[\"FRAME_STATUS_CHANGED\"] = \"frame-status-changed\";\n  return EventAction;\n}({});\nvar HoverType = /*#__PURE__*/function (HoverType) {\n  HoverType[\"SCROLLBAR_X\"] = \"scrollbarX\";\n  HoverType[\"SCROLLBAR_Y\"] = \"scrollbarY\";\n  HoverType[\"SCROLLBAR_X_CONTAINER\"] = \"scrollbarXContainer\";\n  HoverType[\"SCROLLBAR_Y_CONTAINER\"] = \"scrollbarYContainer\";\n  return HoverType;\n}(HoverType || {});\nconst rangeFramesSet = [1000, 500, 200, 100, 50, 20, 10, 5]; // set of supported frames per range\nconst scrollbarColor = '#777B82';\nconst scrollbarContainerColor = '#22262D';\nconst borderColor = '#484C59';\nexport default class FramesRenderer extends EventEmitter {\n  /**\n   * get scrollable\n   * @getter\n   */\n  get scrollable() {\n    return this._scrollable;\n  }\n\n  /**\n   * set scrollable\n   * @setter\n   */\n  set scrollable(scrollable) {\n    const shouldUpdate = this._scrollable !== scrollable;\n    this._scrollable = scrollable;\n    if (shouldUpdate) {\n      this.setupCanvas();\n    }\n  }\n\n  /**\n   * invalid frames\n   */\n\n  /**\n   * set invalid frames\n   * @setter\n   */\n  set invalidFrames(frames) {\n    this._invalidFrames = [...frames];\n    this.drawFrames();\n  }\n\n  /**\n   * frame items\n   * @private\n   */\n\n  /**\n   * get frame items\n   * @getter\n   */\n  get items() {\n    return this._items;\n  }\n\n  /**\n   * set frame items\n   * @setter\n   */\n  set items(items) {\n    const originItemsLen = Object.keys(this._items).length;\n    this._items = cloneDeep(items);\n    this._allItems = [];\n    this._itemBlocks = [];\n    const itemKeys = Object.keys(this._items);\n    for (let i = 0; i < itemKeys.length; i += 1) {\n      const itemKey = itemKeys[i];\n      this._allItems[i] = {\n        id: itemKey,\n        index: i\n      };\n      this._itemBlocks[i] = {};\n      const {\n        frameStatus = {},\n        type,\n        draggable = false\n      } = this._items[itemKey];\n      const statusFrames = Object.keys(frameStatus).map(f => Number(f));\n      let lastStartIndex = 0;\n      for (let j = 0; j < statusFrames.length; j += 1) {\n        const startFrame = statusFrames[lastStartIndex];\n        const endFrame = statusFrames[j] + 1;\n        const framesBreak = j === statusFrames.length - 1 || statusFrames[j + 1] - statusFrames[j] > 1;\n        const framesChange = frameStatus[endFrame] !== frameStatus[startFrame];\n        if (framesBreak || (type === FrameItemType.TEXT || type === FrameItemType.ENDPOINT) && framesChange) {\n          this._itemBlocks[i][startFrame] = {\n            startFrame,\n            endFrame,\n            value: frameStatus[startFrame],\n            hovered: false,\n            selected: false,\n            draggable\n          };\n          lastStartIndex = j + 1;\n        }\n      }\n    }\n    const height = Object.keys(this._items).length * this.itemHeight;\n    if (height > this.itemsContainerHeight && !this.scrollable) {\n      this._scrollable = true;\n      this.setupCanvas();\n    } else if (height <= this.itemsContainerHeight && this.scrollable && !this.fixHeight) {\n      this._scrollable = false;\n      this.setupCanvas();\n    }\n    if (originItemsLen !== Object.keys(items).length && !this.scrollable) {\n      // when items length changes, and not scrollable, need resize canvas and redraw\n      this.setupCanvas();\n    } else {\n      // just redraw\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * all items with id and actual index\n   * @private\n   */\n\n  /**\n   * get current frame\n   * @getter\n   */\n  get currentFrame() {\n    return this._currentFrame;\n  }\n\n  /**\n   * set current frame\n   * @setter\n   */\n  set currentFrame(frameIndex) {\n    const shouldUpdate = this._currentFrame !== frameIndex;\n    this._currentFrame = frameIndex;\n    if (shouldUpdate) {\n      this.focusFrame(frameIndex);\n    }\n  }\n\n  /**\n   * hovered frame index\n   * @private\n   */\n\n  /**\n   * get current range index\n   * @getter\n   */\n  get currentRangeIndex() {\n    return this._currentRangeIndex;\n  }\n\n  /**\n   * set current range index\n   * @setters\n   */\n  set currentRangeIndex(index) {\n    const rangeIndex = Math.min(Math.max(index, this._initialRangeIndex), rangeFramesSet.length - 1);\n    const shouldUpdate = this._currentRangeIndex !== rangeIndex;\n    this._currentRangeIndex = rangeIndex;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * current range start frame (used for drawing)\n   * @private\n   */\n\n  /**\n   * get items offset\n   * @getter\n   */\n  get itemsOffset() {\n    return this._itemsOffset;\n  }\n\n  /**\n   * set items offset\n   * @setter\n   */\n  set itemsOffset(o) {\n    const offset = o * window.devicePixelRatio;\n    const shouldUpdate = this._itemsOffset !== offset;\n    this._itemsOffset = offset;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * vertical scrollbar height\n   * @private\n   */\n\n  /**\n   * get item height\n   */\n  get itemHeight() {\n    return this._itemHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames height\n   * @private\n   */\n\n  /**\n   * get frames height\n   */\n  get framesHeight() {\n    return this._framesHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames scale enable\n   */\n\n  /**\n   * base range width\n   */\n  get baseRangeWidth() {\n    return 18 * 5 * window.devicePixelRatio;\n  }\n\n  /**\n   * canvas padding right\n   */\n  get paddingRight() {\n    return 18 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar container height\n   */\n  get scrollbarXContainerHeight() {\n    return 22 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar height\n   */\n  get scrollbarXHeight() {\n    return 16 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar width\n   */\n  get scrollbarYWidth() {\n    return 10 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar offset x (from items container right)\n   */\n  get scrollbarYOffsetX() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block height\n   */\n  get itemBlockHeight() {\n    return 12 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block offset y (in the item container)\n   */\n  get itemBlockOffsetY() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item text block height\n   */\n  get itemTextBlockHeight() {\n    return 18 * window.devicePixelRatio;\n  }\n\n  /**\n   * item text block offset y (in the item container)\n   */\n  get itemTextBlockOffsetY() {\n    return 1 * window.devicePixelRatio;\n  }\n\n  /**\n   * item endpoint block height\n   */\n  get itemEndpointBlockHeight() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item text block offset y (in the item container)\n   */\n  get itemEndpointBlockOffsetY() {\n    return 8 * window.devicePixelRatio;\n  }\n\n  /**\n   * item card height\n   */\n  get itemCardHeight() {\n    return 16 * window.devicePixelRatio;\n  }\n\n  /**\n   * items container height (when not collapsed)\n   */\n  get itemsContainerHeight() {\n    return 275 * window.devicePixelRatio;\n  }\n\n  /**\n   * frames container height\n   */\n  get itemsTotalHeight() {\n    if (this.scrollable) {\n      return this.itemsContainerHeight;\n    }\n    return Object.keys(this._items).length * this.itemHeight;\n  }\n\n  /**\n   * current range frames\n   */\n  get rangeFrames() {\n    return rangeFramesSet[this._currentRangeIndex];\n  }\n\n  /**\n   * current per frame width\n   */\n  get perFrameWidth() {\n    return this._currentRangeIndex <= this._initialRangeIndex ? (this.canvas.width - this.paddingRight) / this.frameCount : this.baseRangeWidth / this.rangeFrames;\n  }\n\n  /**\n   * current card width\n   */\n  get cardWidth() {\n    return this.perFrameWidth - this.cardOffsetX * 2;\n  }\n\n  /**\n   * card offset x (base on item)\n   */\n  get cardOffsetX() {\n    return 1 * window.devicePixelRatio;\n  }\n\n  /**\n   * card offset y (base on item)\n   */\n  get cardOffsetY() {\n    return (this.itemHeight - this.itemCardHeight) / 2 - 1;\n  }\n\n  /**\n   * constructor\n   * @param canvas\n   * @param frameCount\n   * @param options\n   */\n  constructor(container, frameCount, {\n    itemHeight,\n    framesHeight,\n    bgColor,\n    itemColor,\n    itemSelectedColor,\n    cardColor,\n    scaleEnabled,\n    fixHeight\n  } = {}) {\n    super();\n    /**\n     * canvas container\n     * @member\n     */\n    this.container = void 0;\n    /**\n     * canvas dom element\n     * @member\n     */\n    this.canvas = void 0;\n    /**\n     * frame tip element\n     * @member\n     */\n    this.frameTip = void 0;\n    /**\n     * frames count\n     * @member\n     */\n    this.frameCount = void 0;\n    /**\n     * frames background color\n     * @member\n     */\n    this.bgColor = void 0;\n    /**\n     * item default color\n     * @member\n     */\n    this.itemColor = void 0;\n    /**\n     * item selected color\n     * @member\n     */\n    this.itemSelectedColor = void 0;\n    /**\n     * card color\n     * @member\n     */\n    this.cardColor = void 0;\n    /**\n     * is frames container height fix\n     * @member\n     */\n    this.fixHeight = false;\n    /**\n     * scrollable\n     * @private\n     */\n    this._scrollable = false;\n    this._invalidFrames = [];\n    this._items = {};\n    this._allItems = [];\n    /**\n     * all item blocks\n     * @private\n     */\n    this._itemBlocks = [];\n    /**\n     * current frame index\n     * @private\n     */\n    this._currentFrame = 0;\n    this._hoveredFrame = -1;\n    /**\n     * hovered item index\n     * @private\n     */\n    this._hoveredItemIndex = -1;\n    /**\n     * hovered block\n     */\n    this._hoveredBlock = null;\n    /**\n     * selected block\n     */\n    this._selectedBlock = null;\n    /**\n     * pending block matches start frame\n     */\n    this._pendingStartBlock = null;\n    /**\n     * pending block matches end frame\n     */\n    this._pendingEndBlock = null;\n    /**\n     * is editing pending blocks by dragging\n     */\n    this._pendingEditing = false;\n    /**\n     * cursor offset when editing pending blocks\n     */\n    this._pendingCursorOffset = -1;\n    /**\n     * initial calculated range index (largest frames per range)\n     * @private\n     */\n    this._initialRangeIndex = 0;\n    /**\n     * current range index in the rangeFramesSet\n     * @private\n     */\n    this._currentRangeIndex = 0;\n    this._currentRangeStart = 0;\n    /**\n     * current range start frame offset (used for drawing)\n     * @private\n     */\n    this._currentRangeStartOffset = 0;\n    /**\n     * current offset in canvas when zooming, dragging and so on\n     * @private\n     */\n    this._baseOffset = 0;\n    /**\n     * current offset frame index in canvas when zooming, dragging and so on\n     * @private\n     */\n    this._baseOffsetFrame = 0;\n    /**\n     * is mouse down on horizontal scrollbar\n     * @private\n     */\n    this._isScrollXDown = false;\n    /**\n     * base offset when mouse down on horizontal scrollbar\n     * @private\n     */\n    this._scrollXDownBaseOffsetFrame = 0;\n    /**\n     * client X when mouse down on horizontal scrollbar\n     * @private\n     */\n    this._scrollXDownClientX = 0;\n    /**\n     * horizontal scrollbar width\n     * @private\n     */\n    this._scrollXWidth = 0;\n    /**\n     * horizontal scrollbar offset\n     * @private\n     */\n    this._scrollXOffset = 0;\n    /**\n     * items offset\n     * @private\n     */\n    this._itemsOffset = 0;\n    this._scrollYHeight = 0;\n    /**\n     * vertical scrollbar offset\n     * @private\n     */\n    this._scrollYOffset = 0;\n    /**\n     * is mouse down on vertical scrollbar\n     * @private\n     */\n    this._isScrollYDown = false;\n    /**\n     * items offset when mouse down on vertical scrollbar\n     * @private\n     */\n    this._scrollYDownItemsOffset = 0;\n    /**\n     * client y when mouse down on vertical scrollbar\n     * @private\n     */\n    this._scrollYDownClientY = 0;\n    /**\n     * item height\n     * @private\n     */\n    this._itemHeight = 20;\n    this._framesHeight = 44;\n    this._scaleEnabled = true;\n    /**\n     * set up canvas size\n     */\n    this.setupCanvas = () => {\n      const {\n        width\n      } = this.canvas.getBoundingClientRect();\n      const originCanvasWidth = this.canvas.width;\n      this.canvas.width = width * window.devicePixelRatio;\n      this.canvas.height = this.itemsTotalHeight + this.framesHeight;\n      this.emit(EventAction.HEIGHT_CHANGE, this.canvas.height / window.devicePixelRatio);\n      this.setupRangeIndexes(originCanvasWidth !== this.canvas.width);\n      this.drawFrames();\n    };\n    /**\n     * mouse wheel\n     * @param e\n     */\n    this.wheel = e => {\n      if (e.altKey) {\n        this.zoom(e);\n      } else {\n        // scroll y\n        this.updateItemsScroll(this._itemsOffset + e.deltaY);\n      }\n    };\n    /**\n     * zooming\n     * @param e\n     */\n    this.zoom = e => {\n      const hover = this.getMouseHover(e.clientX, e.clientY);\n      if (hover === HoverType.SCROLLBAR_Y_CONTAINER || hover === HoverType.SCROLLBAR_Y) {\n        return;\n      }\n      // zoom to scale frames\n      const {\n        left\n      } = this.canvas.getBoundingClientRect();\n      this._baseOffset = (e.clientX - left) * window.devicePixelRatio;\n      this._baseOffsetFrame = this.getFrameByClientX(e.clientX);\n      if (e.deltaY > 0) {\n        this._currentRangeIndex += 1;\n      } else {\n        this._currentRangeIndex -= 1;\n      }\n      this._currentRangeIndex = Math.min(Math.max(this._currentRangeIndex, this._initialRangeIndex), rangeFramesSet.length - 1);\n      this.emit(EventAction.VISIBLE_FRAMES_UPDATE, this._currentRangeIndex, rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex));\n      this.drawFrames();\n      this.canvasMove(e);\n    };\n    /**\n     * mouse down on canvas\n     * @param e\n     */\n    this.canvasDown = e => {\n      const hover = this.getMouseHover(e.clientX, e.clientY);\n      if (hover === HoverType.SCROLLBAR_X) {\n        // click on horizontal scrollbar\n        this._isScrollXDown = true;\n        this._scrollXDownBaseOffsetFrame = this._baseOffsetFrame;\n        this._scrollXDownClientX = e.clientX;\n      } else if (hover === HoverType.SCROLLBAR_Y) {\n        // click on vertical scrollbar\n        this._isScrollYDown = true;\n        this._scrollYDownItemsOffset = this._itemsOffset;\n        this._scrollYDownClientY = e.clientY;\n      } else if (this._pendingStartBlock || this._pendingEndBlock) {\n        this._pendingEditing = true;\n        this.emit(EventAction.BLOCK_HOVERED, this._hoveredBlock);\n      } else if (this._hoveredBlock) {\n        this.currentFrame = this._hoveredFrame;\n        this.emit(EventAction.CURRENT_FRAME_CHANGE, this._currentFrame, this._hoveredItemIndex);\n        if (e.buttons === 2) {\n          // activate\n          this._selectedBlock = this._hoveredBlock;\n          this._selectedBlock.selected = true;\n          this.drawFrames();\n          const hoveredItemY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n          this.emit(EventAction.BLOCK_SELECTED, this._selectedBlock, this._hoveredItemIndex, e.clientX, (this.canvas.height - hoveredItemY) / window.devicePixelRatio);\n        }\n      } else if (this._hoveredFrame >= 0) {\n        this.currentFrame = this._hoveredFrame;\n        this.emit(EventAction.CURRENT_FRAME_CHANGE, this._currentFrame, this._hoveredItemIndex);\n      }\n    };\n    /**\n     * mouse move on canvas\n     * @param e\n     */\n    this.canvasMove = e => {\n      if (this._pendingEditing) {\n        this._hoveredFrame = this.getFrameByClientX(e.clientX);\n        this.updateFrameTip();\n        return;\n      }\n      this.setCursor(Cursor.DEFAULT);\n      const hover = this.getMouseHover(e.clientX, e.clientY);\n      if (hover === HoverType.SCROLLBAR_X) {\n        // hover on horizontal scrollbar\n        this.canvasLeave();\n        this.setCursor(Cursor.POINTER);\n      } else if (hover === HoverType.SCROLLBAR_Y) {\n        this.canvasLeave();\n        this.setCursor(Cursor.POINTER);\n      } else if (hover === HoverType.SCROLLBAR_X_CONTAINER || hover === HoverType.SCROLLBAR_Y_CONTAINER) {\n        this.canvasLeave();\n      } else {\n        this._hoveredFrame = this.getFrameByClientX(e.clientX);\n        this._hoveredItemIndex = this.getItemIndexByClientY(e.clientY);\n        if (this._hoveredBlock) {\n          this._hoveredBlock.hovered = false;\n        }\n        this._hoveredBlock = null;\n        this._pendingStartBlock = null;\n        this._pendingEndBlock = null;\n        const {\n          left\n        } = this.canvas.getBoundingClientRect();\n        const cursorOffset = (e.clientX - left) * window.devicePixelRatio;\n        const threshold = 6 * window.devicePixelRatio;\n        this._itemBlocks.forEach((blocks, i) => {\n          Object.values(blocks).forEach(item => {\n            if (i === this._hoveredItemIndex) {\n              const {\n                startFrame,\n                endFrame,\n                value\n              } = item;\n              // check block hovered\n              item.hovered = this._hoveredFrame >= startFrame && this._hoveredFrame < endFrame && typeof value !== 'boolean';\n              if (item.hovered) {\n                this._hoveredBlock = item;\n              }\n              // check draggable block is pending\n              if (item.draggable && (this._hoveredFrame === startFrame || this._hoveredFrame === startFrame - 1)) {\n                // match the block beginning\n                const frameOffset = this._currentRangeStartOffset + (startFrame - this._currentRangeStart) * this.perFrameWidth;\n                if (Math.abs(cursorOffset - frameOffset) < threshold) {\n                  this.setCursor(Cursor.COL_RESIZE);\n                  this._pendingStartBlock = item;\n                }\n              }\n              if (item.draggable && (this._hoveredFrame === endFrame || this._hoveredFrame === endFrame - 1)) {\n                // match the block ending\n                const frameOffset = this._currentRangeStartOffset + (endFrame - this._currentRangeStart) * this.perFrameWidth;\n                if (Math.abs(cursorOffset - frameOffset) < threshold) {\n                  this.setCursor(Cursor.COL_RESIZE);\n                  this._pendingEndBlock = item;\n                }\n              }\n            }\n          });\n        });\n        this.drawFrames();\n        this.updateFrameTip();\n        const hoveredItemY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n        this.emit(EventAction.BLOCK_HOVERED, this._hoveredBlock, this._hoveredFrame, this._hoveredItemIndex, e.clientX, (this.canvas.height - hoveredItemY) / window.devicePixelRatio);\n      }\n    };\n    /**\n     * mouse leave canvas\n     */\n    this.canvasLeave = () => {\n      this._hoveredFrame = -1;\n      this._hoveredItemIndex = -1;\n      if (this._hoveredBlock) {\n        this._hoveredBlock.hovered = false;\n      }\n      this._hoveredBlock = null;\n      this._pendingStartBlock = null;\n      this._pendingEndBlock = null;\n      this.drawFrames();\n      this.updateFrameTip();\n      this.emit(EventAction.BLOCK_HOVERED, this._hoveredBlock);\n    };\n    /**\n     * mouse move on document (dragging scrollbar)\n     * @param e\n     */\n    this.cursorMove = e => {\n      if (this._pendingEditing) {\n        const {\n          left\n        } = this.canvas.getBoundingClientRect();\n        this._pendingCursorOffset = (e.clientX - left) * window.devicePixelRatio;\n        this.drawFrames();\n      } else if (this._isScrollXDown) {\n        // move horizontal scrollbar\n        const offset = (e.clientX - this._scrollXDownClientX) * window.devicePixelRatio;\n        const frames = Math.floor(offset / (this.canvas.width - this.paddingRight) * this.frameCount);\n        this._baseOffsetFrame = this._scrollXDownBaseOffsetFrame + frames;\n        this._hoveredFrame = -1;\n        this._hoveredItemIndex = -1;\n        this.drawFrames();\n        this.updateFrameTip();\n      } else if (this._isScrollYDown) {\n        // move vertical scrollbar\n        const offset = (e.clientY - this._scrollYDownClientY) * window.devicePixelRatio;\n        const itemsOffset = this._scrollYDownItemsOffset + offset / this.itemsContainerHeight * this._allItems.length * this.itemHeight;\n        this.updateItemsScroll(itemsOffset);\n      }\n    };\n    /**\n     * mouse up on document (dragging scrollbar)\n     */\n    this.cursorUp = () => {\n      if (this._pendingEditing && this._pendingCursorOffset >= 0) {\n        var _this$_pendingStartBl, _this$_pendingEndBloc;\n        let frame = this._currentRangeStart + Math.round((this._pendingCursorOffset - this._currentRangeStartOffset) / this.perFrameWidth);\n        if (frame > this.frameCount) {\n          frame = this.frameCount;\n        } else if (frame < 0) {\n          frame = 0;\n        }\n        const updatedFrameStatus = {};\n        const pendingStartFrame = (_this$_pendingStartBl = this._pendingStartBlock) === null || _this$_pendingStartBl === void 0 ? void 0 : _this$_pendingStartBl.startFrame;\n        const pendingEndFrame = (_this$_pendingEndBloc = this._pendingEndBlock) === null || _this$_pendingEndBloc === void 0 ? void 0 : _this$_pendingEndBloc.endFrame;\n        if (pendingStartFrame !== undefined) {\n          if (frame > pendingStartFrame) {\n            // move -> right\n            for (let i = pendingStartFrame; i < frame; i += 1) {\n              updatedFrameStatus[i] = null;\n            }\n            if (pendingEndFrame !== undefined) {\n              for (let i = pendingEndFrame; i < frame; i += 1) {\n                updatedFrameStatus[i] = pendingEndFrame - 1;\n              }\n            }\n          } else if (frame < pendingStartFrame) {\n            // move -> left\n            if (pendingEndFrame !== undefined) {\n              for (let i = frame; i < pendingEndFrame; i += 1) {\n                updatedFrameStatus[i] = null;\n              }\n            }\n            for (let i = frame; i < pendingStartFrame; i += 1) {\n              updatedFrameStatus[i] = pendingStartFrame;\n            }\n          }\n        } else if (pendingEndFrame !== undefined) {\n          if (frame > pendingEndFrame) {\n            // move -> right\n            for (let i = pendingEndFrame; i < frame; i += 1) {\n              updatedFrameStatus[i] = pendingEndFrame - 1;\n            }\n          } else if (frame < pendingEndFrame) {\n            // move -> left\n            for (let i = frame; i < pendingEndFrame; i += 1) {\n              updatedFrameStatus[i] = null;\n            }\n          }\n        }\n        if (Object.keys(updatedFrameStatus).length > 0) {\n          this.emit(EventAction.FRAME_STATUS_CHANGED, updatedFrameStatus, this._hoveredItemIndex);\n        }\n      }\n      this._pendingEditing = false;\n      this._pendingCursorOffset = -1;\n      if (this._isScrollXDown) {\n        this._isScrollXDown = false;\n        this._scrollXDownBaseOffsetFrame = 0;\n        this._scrollXDownClientX = 0;\n      }\n      if (this._isScrollYDown) {\n        this._isScrollYDown = false;\n        this._scrollYDownItemsOffset = 0;\n        this._scrollYDownClientY = 0;\n      }\n    };\n    this._scaleEnabled = scaleEnabled === undefined ? true : scaleEnabled;\n    this.container = container;\n    this.frameCount = frameCount;\n    if (itemHeight) {\n      this._itemHeight = itemHeight;\n    }\n    if (framesHeight) {\n      this._framesHeight = framesHeight;\n    }\n    this.bgColor = bgColor || '#3D424D';\n    this.itemColor = itemColor || '#343846';\n    this.itemSelectedColor = itemSelectedColor || '#2F3340';\n    this.cardColor = cardColor || '#5C5F6B';\n    this.fixHeight = fixHeight || false;\n    this.container.style.position = 'relative';\n    // create canvas dom\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this.canvas.style.display = 'block';\n    this.container.appendChild(this.canvas);\n    // create tip dom\n    this.frameTip = document.createElement('div');\n    this.frameTip.style.position = 'absolute';\n    this.frameTip.style.background = '#34CBD1';\n    this.frameTip.style.padding = '0 2px';\n    this.frameTip.style.borderRadius = '2px';\n    this.frameTip.style.fontSize = '10px';\n    this.frameTip.style.color = '#252935';\n    this.frameTip.style.lineHeight = '12px';\n    this.frameTip.style.height = '12px';\n    this.frameTip.style.top = '8px';\n    this.frameTip.style.display = 'none';\n    this.container.appendChild(this.frameTip);\n    this.container.oncontextmenu = e => e.preventDefault();\n    this.addEventListeners();\n    this.setupCanvas();\n  }\n\n  /**\n   * update one item's frame status\n   * @param id\n   * @param frameStatus\n   */\n  updateItemFrameStatus(id, frameStatus) {\n    if (this._items[id]) {\n      this._items[id].frameStatus = cloneDeep(frameStatus);\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * add event listeners\n   */\n  addEventListeners() {\n    document.addEventListener('mousemove', this.cursorMove);\n    document.addEventListener('mouseup', this.cursorUp);\n    window.addEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').addEventListener('change', this.setupCanvas);\n    this.canvas.addEventListener('wheel', this.wheel);\n    this.canvas.addEventListener('mousedown', this.canvasDown);\n    this.canvas.addEventListener('mousemove', this.canvasMove);\n    this.canvas.addEventListener('mouseleave', this.canvasLeave);\n  }\n\n  /**\n   * remove event listeners\n   */\n  removeEventListeners() {\n    document.removeEventListener('mousemove', this.cursorMove);\n    document.removeEventListener('mouseup', this.cursorUp);\n    window.removeEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').removeEventListener('change', this.setupCanvas);\n    this.canvas.removeEventListener('wheel', this.wheel);\n    this.canvas.removeEventListener('mousedown', this.canvasDown);\n    this.canvas.removeEventListener('mousemove', this.canvasMove);\n    this.canvas.removeEventListener('mouseleave', this.canvasLeave);\n  }\n  /**\n   * calculate initial range index\n   */\n  setupRangeIndexes(update) {\n    if (update) {\n      const estimatedRangeFrames = this.frameCount / (this.canvas.width - this.paddingRight) * this.baseRangeWidth;\n      let rangeIndex = 0;\n      while (rangeFramesSet[rangeIndex] > estimatedRangeFrames && rangeIndex < rangeFramesSet.length) {\n        rangeIndex += 1;\n      }\n      this._initialRangeIndex = rangeIndex > 0 ? rangeIndex - 1 : 0;\n      this._currentRangeIndex = this._initialRangeIndex;\n    }\n    this.emit(EventAction.VISIBLE_FRAMES_UPDATE, this._currentRangeIndex, rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex));\n  }\n\n  /**\n   * draw frames\n   */\n  drawFrames() {\n    const ctx = this.canvas.getContext('2d');\n    if (ctx) {\n      ctx.save();\n\n      // clear canvas\n      const {\n        width,\n        height\n      } = this.canvas;\n      ctx.clearRect(0, 0, width, height);\n\n      // calc current range\n      this._currentRangeStart = Math.floor(this._baseOffsetFrame / this.rangeFrames) * this.rangeFrames;\n      if (this._currentRangeStart === 0) {\n        // reset offset to 0\n        this._currentRangeStartOffset = 0;\n      } else {\n        this._currentRangeStartOffset = this._baseOffset - (this._baseOffsetFrame - this._currentRangeStart) * this.perFrameWidth;\n        const firstFrameOffset = this._baseOffset - this._baseOffsetFrame * this.perFrameWidth;\n        const lastFrameOffset = this._baseOffset + (this.frameCount - this._baseOffsetFrame) * this.perFrameWidth;\n        if (firstFrameOffset > 0) {\n          this._currentRangeStartOffset -= firstFrameOffset;\n        } else if (lastFrameOffset < width - this.paddingRight) {\n          this._currentRangeStartOffset += width - this.paddingRight - lastFrameOffset;\n        }\n      }\n      this.drawFrameItems(ctx);\n      this.drawFrameScales(ctx);\n      ctx.restore();\n    }\n  }\n\n  /**\n   * draw frame items\n   * @param ctx\n   */\n  drawFrameItems(ctx) {\n    if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n      // block cursor & cards\n      this.drawItems(ctx, 'blocks');\n      this.drawFrameHint(ctx);\n      this.drawItems(ctx, 'cards');\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    } else {\n      // line cursor & blocks\n      this.drawItems(ctx);\n      this.drawFrameHint(ctx);\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    }\n  }\n\n  /**\n   * draw items\n   * @param ctx\n   * @param type empty means all items\n   */\n  drawItems(ctx, type) {\n    let items = this._allItems;\n    if (type === 'blocks') {\n      items = items.filter(({\n        id\n      }) => !this._items[id].showCards && this._items[id].type !== FrameItemType.CARD);\n    } else if (type === 'cards') {\n      items = items.filter(({\n        id\n      }) => this._items[id].showCards || this._items[id].type === FrameItemType.CARD);\n    }\n    const width = this.canvas.width - this.paddingRight;\n    items.forEach(({\n      id,\n      index\n    }) => {\n      const {\n        frameStatus = {},\n        frameColor = {},\n        color,\n        type: frameItemType,\n        showCards,\n        selected\n      } = this._items[id];\n      const itemOffset = index * this.itemHeight;\n      if (itemOffset + this.itemHeight <= this._itemsOffset || itemOffset - this._itemsOffset >= this.itemsTotalHeight) {\n        // out of container\n        return;\n      }\n      const height = this.itemHeight;\n      const offsetY = itemOffset - this._itemsOffset + this.scrollbarXContainerHeight;\n\n      // draw background\n      let bgColor = this.itemColor;\n      if (frameItemType === FrameItemType.TEXT && this._hoveredItemIndex === index) {\n        // text block hovered\n        bgColor = this.itemSelectedColor;\n      } else if (selected) {\n        bgColor = this.itemSelectedColor;\n      }\n      drawRect(ctx, 0, offsetY, width, height, bgColor);\n      // draw bottom line\n      drawLine(ctx, 0, offsetY + height - 1, width, offsetY + height - 1, borderColor);\n      if ((showCards || frameItemType === FrameItemType.CARD) && this._currentRangeIndex === rangeFramesSet.length - 1) {\n        // draw cards\n        const drawCard = (frame, frameOffset) => {\n          if (frameOffset + this.cardOffsetX < width) {\n            let cWidth = this.cardWidth;\n            if (frameOffset + this.cardOffsetX + cWidth > width) {\n              cWidth = width - (frameOffset + this.cardOffsetX);\n            }\n            if (frameStatus[frame] !== undefined) {\n              const cardColor = frameColor[frame] || this.cardColor;\n              drawRect(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, cardColor);\n              if (frameStatus[frame] === true && frameOffset + this.perFrameWidth / 2 < width) {\n                drawCircle(ctx, frameOffset + this.perFrameWidth / 2, offsetY + this.itemHeight / 2, 2, '#FFFFFF');\n              }\n            }\n            if (frame === this._currentFrame && selected) {\n              drawRectBorder(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, '#FFFFFF');\n            }\n          }\n        };\n        const drawRangeCards = (start, offset) => {\n          Array.from({\n            length: 5\n          }).forEach((_, i) => {\n            const frame = start + i;\n            if (frameStatus[frame] !== undefined || frame === this._currentFrame && selected) {\n              const frameOffset = offset + this.perFrameWidth * i;\n              drawCard(frame, frameOffset);\n            }\n          });\n        };\n        if (this._currentRangeIndex <= this._initialRangeIndex) {\n          // just draw all frames\n          Array.from({\n            length: this.frameCount\n          }).forEach((_, i) => {\n            drawCard(i, this.perFrameWidth * i);\n          });\n        } else {\n          let rangeStart = this._currentRangeStart;\n          let rangeStartOffset = this._currentRangeStartOffset;\n          while (rangeStartOffset + this.baseRangeWidth >= 0 && rangeStart >= 0) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart -= this.rangeFrames;\n            rangeStartOffset -= this.baseRangeWidth;\n          }\n          rangeStart = this._currentRangeStart + this.rangeFrames;\n          rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n          while (rangeStartOffset < width && rangeStart < this.frameCount) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart += this.rangeFrames;\n            rangeStartOffset += this.baseRangeWidth;\n          }\n        }\n      } else {\n        const drawTextBlock = (startOffset, endOffset, text, blockColor, blockSelected) => {\n          if (endOffset > startOffset) {\n            const o = 1 * window.devicePixelRatio;\n            const itemOffsetX = startOffset + o;\n            const itemOffsetY = offsetY + this.itemTextBlockOffsetY;\n            const blockWidth = endOffset - startOffset - o * 2;\n            drawRect(ctx, itemOffsetX, itemOffsetY, blockWidth, this.itemTextBlockHeight, blockColor);\n            if (blockSelected) {\n              const currentFrameOffset = this._currentRangeStartOffset + (this.currentFrame - this._currentRangeStart) * this.perFrameWidth;\n              drawRect(ctx, currentFrameOffset, itemOffsetY, this.perFrameWidth, this.itemTextBlockHeight, '#4A90E2');\n            }\n            const textOffsetX = itemOffsetX + o * 2;\n            const textOffsetY = itemOffsetY + o * 4;\n            const textWidth = blockWidth - o * 4;\n            drawText(ctx, text, textOffsetX, textOffsetY, '#FFFFFF', 12, textWidth);\n          }\n        };\n        const drawEndpointBlock = (startOffset, endOffset) => {\n          if (endOffset >= startOffset) {\n            const startOffsetX = startOffset + this.perFrameWidth / 2;\n            if (endOffset > startOffset) {\n              drawRect(ctx, startOffsetX, offsetY + this.itemEndpointBlockOffsetY, endOffset - startOffset - this.perFrameWidth, this.itemEndpointBlockHeight, color);\n            }\n            drawRhombus(ctx, startOffsetX, offsetY + this.itemHeight / 2, 6, '#4A90E2');\n          }\n        };\n        const drawBlock = (startOffset, endOffset) => {\n          if (endOffset > startOffset) {\n            drawRect(ctx, startOffset, offsetY + this.itemBlockOffsetY, endOffset - startOffset, this.itemBlockHeight, color);\n          }\n        };\n        const allBlocks = Object.values(this._itemBlocks[index]);\n        allBlocks.forEach(block => {\n          const {\n            startFrame,\n            endFrame\n          } = block;\n          let startOffset = this._currentRangeStartOffset + (startFrame - this._currentRangeStart) * this.perFrameWidth;\n          let endOffset = this._currentRangeStartOffset + (endFrame - this._currentRangeStart) * this.perFrameWidth;\n          if (this._pendingEditing) {\n            if (block === this._pendingStartBlock) {\n              startOffset = this._pendingCursorOffset;\n            } else if (block === this._pendingEndBlock) {\n              endOffset = this._pendingCursorOffset;\n            } else if (index === this._hoveredItemIndex) {\n              const pendingStartFrame = this._pendingEndBlock ? this._pendingEndBlock.startFrame : this._pendingStartBlock.startFrame;\n              const pendingEndFrame = this._pendingStartBlock ? this._pendingStartBlock.endFrame : this._pendingEndBlock.endFrame;\n              if (startFrame >= pendingEndFrame) {\n                // blocks on the right\n                if (this._pendingCursorOffset > startOffset) {\n                  startOffset = this._pendingCursorOffset;\n                  if (this._pendingCursorOffset > endOffset) {\n                    endOffset = this._pendingCursorOffset;\n                  }\n                }\n              } else if (endFrame <= pendingStartFrame) {\n                // blocks on the left\n                if (this._pendingCursorOffset < endOffset) {\n                  endOffset = this._pendingCursorOffset;\n                  if (this._pendingCursorOffset < startOffset) {\n                    startOffset = this._pendingCursorOffset;\n                  }\n                }\n              }\n            }\n          }\n          startOffset = Math.min(Math.max(startOffset, 0), width);\n          endOffset = Math.min(Math.max(endOffset, 0), width);\n          if (frameItemType === FrameItemType.TEXT) {\n            const blockColor = block.hovered ? '#777B82' : color;\n            drawTextBlock(startOffset, endOffset, `${frameStatus[startFrame]}`, blockColor, block.selected);\n          } else if (frameItemType === FrameItemType.ENDPOINT) {\n            drawEndpointBlock(startOffset, endOffset);\n          } else {\n            drawBlock(startOffset, endOffset);\n          }\n        });\n      }\n    });\n    if (type !== 'cards') {\n      // no need to draw vertical scroll bar when drawing cards\n      const visibleItemsCount = this.itemsTotalHeight / this.itemHeight;\n      if (visibleItemsCount < this._allItems.length) {\n        // draw scroll y\n        this._scrollYHeight = visibleItemsCount / this._allItems.length * this.itemsTotalHeight;\n        this._scrollYOffset = this._itemsOffset / (this._allItems.length * this.itemHeight) * this.itemsTotalHeight + this.scrollbarXContainerHeight;\n        drawRoundedRect(ctx, width + this.scrollbarYOffsetX, this._scrollYOffset, this.scrollbarYWidth, this._scrollYHeight, 6, scrollbarColor);\n      } else {\n        this._scrollYHeight = 0;\n        this._scrollYOffset = 0;\n      }\n    }\n  }\n\n  /**\n   * draw invalid frame style\n   * @param ctx\n   */\n  drawInvalidFrames(ctx) {\n    // draw invalid frames\n    this._invalidFrames.forEach(frameIndex => {\n      const offsetX = this.getOffsetByFrame(frameIndex);\n      if (offsetX >= 0) {\n        drawRect(ctx, offsetX, this.scrollbarXContainerHeight, Math.max(this.perFrameWidth, 1 * window.devicePixelRatio), this.itemsTotalHeight, 'rgba(220, 70, 36, 0.3)');\n      }\n    });\n  }\n\n  /**\n   * draw frame hint (for current frame & hovered frame)\n   * @param ctx\n   * @param type\n   */\n  drawFrameHint(ctx, type) {\n    const frame = type === 'hover' ? this._hoveredFrame : this._currentFrame;\n    const shouldDraw = type !== 'hover' || this._hoveredFrame !== this._currentFrame;\n    if (shouldDraw) {\n      const offsetX = this.getOffsetByFrame(frame);\n      if (offsetX >= 0) {\n        if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n          // block\n          drawRect(ctx, offsetX, this.scrollbarXContainerHeight, this.perFrameWidth, this.itemsTotalHeight, 'rgba(41, 44, 56, 0.4)');\n          if (type === 'hover' && this._hoveredItemIndex >= 0) {\n            var _this$_allItems$this$;\n            const hoveredItem = this.items[(_this$_allItems$this$ = this._allItems[this._hoveredItemIndex]) === null || _this$_allItems$this$ === void 0 ? void 0 : _this$_allItems$this$.id];\n            if ((hoveredItem === null || hoveredItem === void 0 ? void 0 : hoveredItem.showCards) || (hoveredItem === null || hoveredItem === void 0 ? void 0 : hoveredItem.type) === FrameItemType.CARD || (hoveredItem === null || hoveredItem === void 0 ? void 0 : hoveredItem.type) === FrameItemType.TEXT) {\n              const offsetY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n              drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, 'rgba(255, 255, 255, 0.4)');\n            }\n          }\n          if (type !== 'hover') {\n            const selectedIndex = this._allItems.findIndex(i => this.items[i.id].selected);\n            const offsetY = selectedIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n            drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, '#FFFFFF');\n          }\n        } else {\n          // line\n          drawLine(ctx, offsetX + 0.5, this.scrollbarXContainerHeight, offsetX + 0.5, this.itemsTotalHeight + this.scrollbarXContainerHeight, type === 'hover' ? 'rgba(255, 255, 255, 0.4)' : '#34CBD1');\n        }\n      }\n    }\n  }\n\n  /**\n   * draw frame scales\n   * @param ctx\n   */\n  drawFrameScales(ctx) {\n    if (!this._scaleEnabled) return;\n    const width = this.canvas.width - this.paddingRight;\n    const offsetY = this.itemsTotalHeight + this.scrollbarXContainerHeight;\n    const scaleWidth = this.perFrameWidth * this.rangeFrames;\n    const scaleHeight = 16 * window.devicePixelRatio;\n    const scaleHeightShort = 4 * window.devicePixelRatio;\n\n    // draw scales top border\n    drawRect(ctx, 0, offsetY, width, this.itemHeight, this.bgColor);\n    drawLine(ctx, 0, offsetY - 1, width, offsetY - 1, borderColor);\n    if (this._currentRangeIndex <= this._initialRangeIndex) {\n      const rangeCount = this.frameCount / this.rangeFrames;\n      const rangeWidth = width / rangeCount;\n      if (rangeWidth > this.baseRangeWidth * 5) {\n        for (let i = 0; i < this.frameCount; i += 1) {\n          drawScale(ctx, i * this.perFrameWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i, false);\n        }\n      } else {\n        for (let i = 0; i < rangeCount; i += 1) {\n          drawScale(ctx, i * rangeWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i * this.rangeFrames);\n        }\n      }\n      this._scrollXWidth = 0;\n      this._scrollXOffset = 0;\n    } else {\n      let rangeStart = this._currentRangeStart;\n      let rangeStartOffset = this._currentRangeStartOffset;\n      while (rangeStartOffset + this.baseRangeWidth >= 0 && rangeStart >= 0) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart -= this.rangeFrames;\n        rangeStartOffset -= this.baseRangeWidth;\n      }\n      rangeStart = this._currentRangeStart + this.rangeFrames;\n      rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n      while (rangeStartOffset < width && rangeStart < this.frameCount) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart += this.rangeFrames;\n        rangeStartOffset += this.baseRangeWidth;\n      }\n    }\n\n    // draw scrollbar\n    this._scrollXWidth = Math.max(Math.ceil(width / this.perFrameWidth / this.frameCount * width), 42);\n    this._scrollXOffset = (this._currentRangeStart - this._currentRangeStartOffset / this.perFrameWidth) / this.frameCount * width;\n    // scrollbar container background\n    drawRect(ctx, 0, 0, width, this.scrollbarXContainerHeight, scrollbarContainerColor);\n    drawLine(ctx, 0, this.scrollbarXContainerHeight - 1, width, this.scrollbarXContainerHeight - 1, borderColor);\n    // scrollbar thumbnail\n    const scrollbarXOffsetY = (this.scrollbarXContainerHeight - this.scrollbarXHeight) / 2 - 1;\n    drawRoundedRect(ctx, this._scrollXOffset, scrollbarXOffsetY, this._scrollXWidth, this.scrollbarXHeight, 2, scrollbarColor);\n    const o = 2 * window.devicePixelRatio;\n    const h = this.scrollbarXHeight - o * 4;\n    drawRect(ctx, this._scrollXOffset + o, scrollbarXOffsetY + o * 2, o, h, scrollbarContainerColor);\n    drawRect(ctx, this._scrollXOffset + this._scrollXWidth - o * 2, scrollbarXOffsetY + o * 2, o, h, scrollbarContainerColor);\n    // draw current frame\n    const frameOffset = this._currentFrame / this.frameCount * width;\n    drawLine(ctx, frameOffset + 0.5, 0, frameOffset + 0.5, this.scrollbarXContainerHeight, '#34CBD1');\n  }\n\n  /**\n   * update frame tip text and posistion\n   */\n  updateFrameTip() {\n    if (this._hoveredFrame >= 0) {\n      this.frameTip.innerText = `${this._hoveredFrame + 1}`;\n      const {\n        width\n      } = this.frameTip.getBoundingClientRect();\n      const frameOffset = this.getOffsetByFrame(this._hoveredFrame) / window.devicePixelRatio;\n      let offset = frameOffset - width / 2;\n      if (this.currentRangeIndex === rangeFramesSet.length - 1) {\n        offset += this.perFrameWidth / 2 / window.devicePixelRatio;\n      }\n      this.frameTip.style.left = `${offset}px`;\n      this.frameTip.style.display = 'block';\n    } else {\n      this.frameTip.style.display = 'none';\n    }\n  }\n\n  /**\n   * update items scroll and emit event\n   */\n  updateItemsScroll(itemsOffset) {\n    const allItemsHeight = this._allItems.length * this.itemHeight;\n    if (allItemsHeight <= this.itemsContainerHeight) {\n      // not scrollable\n      return;\n    }\n    this._itemsOffset = itemsOffset;\n    if (this._itemsOffset < 0) {\n      this._itemsOffset = 0;\n    } else if (this._itemsOffset > allItemsHeight - this.itemsTotalHeight) {\n      this._itemsOffset = allItemsHeight - this.itemsTotalHeight;\n    }\n    this.drawFrames();\n    this.emit(EventAction.ITEMS_OFFSET_CHANGE, this._itemsOffset / window.devicePixelRatio);\n  }\n\n  /**\n   * get frame by clientX\n   * @param clientX\n   * @returns\n   */\n  getFrameByClientX(clientX) {\n    const {\n      left\n    } = this.canvas.getBoundingClientRect();\n    const offset = (clientX - left) * window.devicePixelRatio;\n    let frame = this._currentRangeStart + Math.floor((offset - this._currentRangeStartOffset) / this.perFrameWidth);\n    if (frame >= this.frameCount) {\n      frame = this.frameCount - 1;\n    } else if (frame < 0) {\n      frame = 0;\n    }\n    return frame;\n  }\n\n  /**\n   * get item index by clientY\n   * @param clientY\n   * @returns\n   */\n  getItemIndexByClientY(clientY) {\n    const {\n      top\n    } = this.canvas.getBoundingClientRect();\n    const offset = (clientY - top) * window.devicePixelRatio;\n    const index = Math.floor((offset + this._itemsOffset - this.scrollbarXContainerHeight) / this.itemHeight);\n    if (index > Object.keys(this._items).length - 1) {\n      return -1;\n    }\n    return index;\n  }\n\n  /**\n   * get offset by frame index\n   * @param frame\n   * @param checkOutside\n   * @returns\n   */\n  getOffsetByFrame(frame, checkOutside = true) {\n    const offset = this._currentRangeStartOffset + (frame - this._currentRangeStart) * this.perFrameWidth;\n    if (checkOutside && (offset < 0 || offset > this.canvas.width - this.paddingRight)) {\n      return -1;\n    }\n    return offset;\n  }\n\n  /**\n   * check hover item\n   * @param clientX\n   * @param clientY\n   * @returns\n   */\n  getMouseHover(clientX, clientY) {\n    const {\n      width: canvasWidth,\n      height: canvasHeight\n    } = this.canvas;\n    const {\n      left,\n      top,\n      width,\n      height\n    } = this.canvas.getBoundingClientRect();\n    const offsetX = clientX - left;\n    const offsetY = clientY - top;\n    if (offsetX / width >= this._scrollXOffset / canvasWidth && offsetX / width <= (this._scrollXOffset + this._scrollXWidth) / canvasWidth && offsetY / height <= this.scrollbarXContainerHeight / canvasHeight) {\n      return HoverType.SCROLLBAR_X;\n    }\n    if (offsetY / height <= this.scrollbarXContainerHeight / canvasHeight) {\n      return HoverType.SCROLLBAR_X_CONTAINER;\n    }\n    const scrollbarOffsetX = canvasWidth - this.paddingRight + this.scrollbarYOffsetX;\n    if (offsetX / width >= scrollbarOffsetX / canvasWidth && offsetX / width <= (scrollbarOffsetX + this.scrollbarYWidth) / canvasWidth && offsetY / height >= this._scrollYOffset / canvasHeight && offsetY / height <= (this._scrollYOffset + this._scrollYHeight) / canvasHeight) {\n      return HoverType.SCROLLBAR_Y;\n    }\n    if (offsetX * window.devicePixelRatio > canvasWidth - this.paddingRight && offsetX * window.devicePixelRatio <= canvasWidth) {\n      return HoverType.SCROLLBAR_Y_CONTAINER;\n    }\n    return undefined;\n  }\n\n  /**\n   * set cursor for progress bar\n   * @param cursor\n   */\n  setCursor(cursor) {\n    if (this.canvas.style.cursor !== cursor) {\n      this.canvas.style.cursor = cursor;\n    }\n  }\n\n  /**\n   * unselect block\n   */\n  unselectBlock() {\n    if (this._selectedBlock) {\n      this._selectedBlock.selected = false;\n      this._selectedBlock = null;\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * focus to specific frame if not in the progress bar view\n   * @param frame\n   */\n  focusFrame(frame) {\n    const offset = this.getOffsetByFrame(frame, false);\n    const right = this.canvas.width - this.paddingRight - this.perFrameWidth;\n    if (offset < 0) {\n      // move left\n      this._baseOffsetFrame = frame;\n      this._baseOffset = this.perFrameWidth;\n    } else if (offset > right) {\n      // move right\n      this._baseOffsetFrame = frame;\n      this._baseOffset = right - this.perFrameWidth;\n    }\n    this.drawFrames();\n  }\n}","map":{"version":3,"names":["EventEmitter","cloneDeep","drawLine","drawRect","drawRectBorder","drawRoundedRect","drawCircle","drawScale","drawText","drawRhombus","Cursor","FrameItemType","EventAction","HoverType","rangeFramesSet","scrollbarColor","scrollbarContainerColor","borderColor","FramesRenderer","scrollable","_scrollable","shouldUpdate","setupCanvas","invalidFrames","frames","_invalidFrames","drawFrames","items","_items","originItemsLen","Object","keys","length","_allItems","_itemBlocks","itemKeys","i","itemKey","id","index","frameStatus","type","draggable","statusFrames","map","f","Number","lastStartIndex","j","startFrame","endFrame","framesBreak","framesChange","TEXT","ENDPOINT","value","hovered","selected","height","itemHeight","itemsContainerHeight","fixHeight","currentFrame","_currentFrame","frameIndex","focusFrame","currentRangeIndex","_currentRangeIndex","rangeIndex","Math","min","max","_initialRangeIndex","itemsOffset","_itemsOffset","o","offset","window","devicePixelRatio","_itemHeight","framesHeight","_framesHeight","baseRangeWidth","paddingRight","scrollbarXContainerHeight","scrollbarXHeight","scrollbarYWidth","scrollbarYOffsetX","itemBlockHeight","itemBlockOffsetY","itemTextBlockHeight","itemTextBlockOffsetY","itemEndpointBlockHeight","itemEndpointBlockOffsetY","itemCardHeight","itemsTotalHeight","rangeFrames","perFrameWidth","canvas","width","frameCount","cardWidth","cardOffsetX","cardOffsetY","constructor","container","bgColor","itemColor","itemSelectedColor","cardColor","scaleEnabled","frameTip","_hoveredFrame","_hoveredItemIndex","_hoveredBlock","_selectedBlock","_pendingStartBlock","_pendingEndBlock","_pendingEditing","_pendingCursorOffset","_currentRangeStart","_currentRangeStartOffset","_baseOffset","_baseOffsetFrame","_isScrollXDown","_scrollXDownBaseOffsetFrame","_scrollXDownClientX","_scrollXWidth","_scrollXOffset","_scrollYHeight","_scrollYOffset","_isScrollYDown","_scrollYDownItemsOffset","_scrollYDownClientY","_scaleEnabled","getBoundingClientRect","originCanvasWidth","emit","HEIGHT_CHANGE","setupRangeIndexes","wheel","e","altKey","zoom","updateItemsScroll","deltaY","hover","getMouseHover","clientX","clientY","SCROLLBAR_Y_CONTAINER","SCROLLBAR_Y","left","getFrameByClientX","VISIBLE_FRAMES_UPDATE","_","slice","canvasMove","canvasDown","SCROLLBAR_X","BLOCK_HOVERED","CURRENT_FRAME_CHANGE","buttons","hoveredItemY","BLOCK_SELECTED","updateFrameTip","setCursor","DEFAULT","canvasLeave","POINTER","SCROLLBAR_X_CONTAINER","getItemIndexByClientY","cursorOffset","threshold","forEach","blocks","values","item","frameOffset","abs","COL_RESIZE","cursorMove","floor","cursorUp","_this$_pendingStartBl","_this$_pendingEndBloc","frame","round","updatedFrameStatus","pendingStartFrame","pendingEndFrame","undefined","FRAME_STATUS_CHANGED","style","position","document","createElement","display","appendChild","background","padding","borderRadius","fontSize","color","lineHeight","top","oncontextmenu","preventDefault","addEventListeners","updateItemFrameStatus","addEventListener","matchMedia","removeEventListeners","removeEventListener","update","estimatedRangeFrames","ctx","getContext","save","clearRect","firstFrameOffset","lastFrameOffset","drawFrameItems","drawFrameScales","restore","drawItems","drawFrameHint","drawInvalidFrames","filter","showCards","CARD","frameColor","frameItemType","itemOffset","offsetY","drawCard","cWidth","drawRangeCards","start","Array","from","rangeStart","rangeStartOffset","drawTextBlock","startOffset","endOffset","text","blockColor","blockSelected","itemOffsetX","itemOffsetY","blockWidth","currentFrameOffset","textOffsetX","textOffsetY","textWidth","drawEndpointBlock","startOffsetX","drawBlock","allBlocks","block","visibleItemsCount","offsetX","getOffsetByFrame","shouldDraw","_this$_allItems$this$","hoveredItem","selectedIndex","findIndex","scaleWidth","scaleHeight","scaleHeightShort","rangeCount","rangeWidth","ceil","scrollbarXOffsetY","h","innerText","allItemsHeight","ITEMS_OFFSET_CHANGE","checkOutside","canvasWidth","canvasHeight","scrollbarOffsetX","cursor","unselectBlock","right"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/libs/FramesRenderer.ts"],"sourcesContent":["/* eslint-disable class-methods-use-this */\nimport EventEmitter from 'eventemitter3';\nimport { cloneDeep } from 'lodash';\nimport { drawLine, drawRect, drawRectBorder, drawRoundedRect, drawCircle, drawScale, drawText, drawRhombus } from '../utils/canvas';\nimport Cursor from '../components/common/Cursor';\n\nexport interface FrameItem {\n  frameStatus: {\n    [frameIndex: number]: boolean | string; // boolean true means key frame, string used in other cases\n  };\n  frameColor?: {\n    [frameIndex: number]: string;\n  };\n  color: string;\n  type?: FrameItemType;\n  showCards?: boolean;\n  selected?: boolean;\n  draggable?: boolean;\n}\n\nexport interface FrameBlock {\n  startFrame: number;\n  endFrame: number;\n  value: boolean | string;\n  hovered: boolean;\n  selected: boolean;\n  draggable: boolean;\n}\n\nexport enum FrameItemType {\n  DEFAULT = 'default',\n  CARD = 'card',\n  TEXT = 'text',\n  ENDPOINT = 'endpoint',\n}\n\nexport enum EventAction {\n  HEIGHT_CHANGE = 'height-change',\n  VISIBLE_FRAMES_UPDATE = 'visible-frames-update',\n  CURRENT_FRAME_CHANGE = 'current-frame-change',\n  ITEMS_OFFSET_CHANGE = 'items-offset-change',\n  BLOCK_HOVERED = 'block-hovered',\n  BLOCK_SELECTED = 'block-selected',\n  FRAME_STATUS_CHANGED = 'frame-status-changed',\n}\n\nenum HoverType {\n  SCROLLBAR_X = 'scrollbarX',\n  SCROLLBAR_Y = 'scrollbarY',\n  SCROLLBAR_X_CONTAINER = 'scrollbarXContainer',\n  SCROLLBAR_Y_CONTAINER = 'scrollbarYContainer',\n}\n\nconst rangeFramesSet = [1000, 500, 200, 100, 50, 20, 10, 5]; // set of supported frames per range\nconst scrollbarColor = '#777B82';\nconst scrollbarContainerColor = '#22262D';\nconst borderColor = '#484C59';\n\nexport default class FramesRenderer extends EventEmitter {\n  /**\n   * canvas container\n   * @member\n   */\n  container: HTMLDivElement;\n\n  /**\n   * canvas dom element\n   * @member\n   */\n  canvas: HTMLCanvasElement;\n\n  /**\n   * frame tip element\n   * @member\n   */\n  frameTip: HTMLDivElement;\n\n  /**\n   * frames count\n   * @member\n   */\n  frameCount: number;\n\n  /**\n   * frames background color\n   * @member\n   */\n  bgColor: string;\n\n  /**\n   * item default color\n   * @member\n   */\n  itemColor: string;\n\n  /**\n   * item selected color\n   * @member\n   */\n  itemSelectedColor: string;\n\n  /**\n   * card color\n   * @member\n   */\n  cardColor: string;\n\n  /**\n   * is frames container height fix\n   * @member\n   */\n  fixHeight = false;\n\n  /**\n   * scrollable\n   * @private\n   */\n  private _scrollable = false;\n\n  /**\n   * get scrollable\n   * @getter\n   */\n  get scrollable() {\n    return this._scrollable;\n  }\n\n  /**\n   * set scrollable\n   * @setter\n   */\n  set scrollable(scrollable: boolean) {\n    const shouldUpdate = this._scrollable !== scrollable;\n    this._scrollable = scrollable;\n    if (shouldUpdate) {\n      this.setupCanvas();\n    }\n  }\n\n  /**\n   * invalid frames\n   */\n  private _invalidFrames: number[] = [];\n\n  /**\n   * set invalid frames\n   * @setter\n   */\n  set invalidFrames(frames: number[]) {\n    this._invalidFrames = [...frames];\n    this.drawFrames();\n  }\n\n  /**\n   * frame items\n   * @private\n   */\n  private _items: { [id: string]: FrameItem } = {};\n\n  /**\n   * get frame items\n   * @getter\n   */\n  get items() {\n    return this._items;\n  }\n\n  /**\n   * set frame items\n   * @setter\n   */\n  set items(items: { [id: string]: FrameItem }) {\n    const originItemsLen = Object.keys(this._items).length;\n    this._items = cloneDeep(items);\n    this._allItems = [];\n    this._itemBlocks = [];\n\n    const itemKeys = Object.keys(this._items);\n    for (let i = 0; i < itemKeys.length; i += 1) {\n      const itemKey = itemKeys[i];\n      this._allItems[i] = { id: itemKey, index: i };\n      this._itemBlocks[i] = {};\n\n      const { frameStatus = {}, type, draggable = false } = this._items[itemKey];\n      const statusFrames = Object.keys(frameStatus).map((f) => Number(f));\n      let lastStartIndex = 0;\n      for (let j = 0; j < statusFrames.length; j += 1) {\n        const startFrame = statusFrames[lastStartIndex];\n        const endFrame = statusFrames[j] + 1;\n        const framesBreak = j === statusFrames.length - 1 || statusFrames[j + 1] - statusFrames[j] > 1;\n        const framesChange = frameStatus[endFrame] !== frameStatus[startFrame];\n        if (framesBreak || ((type === FrameItemType.TEXT || type === FrameItemType.ENDPOINT) && framesChange)) {\n          this._itemBlocks[i][startFrame] = {\n            startFrame,\n            endFrame,\n            value: frameStatus[startFrame],\n            hovered: false,\n            selected: false,\n            draggable,\n          };\n          lastStartIndex = j + 1;\n        }\n      }\n    }\n\n    const height = Object.keys(this._items).length * this.itemHeight;\n    if (height > this.itemsContainerHeight && !this.scrollable) {\n      this._scrollable = true;\n      this.setupCanvas();\n    } else if (height <= this.itemsContainerHeight && this.scrollable && !this.fixHeight) {\n      this._scrollable = false;\n      this.setupCanvas();\n    } if (originItemsLen !== Object.keys(items).length && !this.scrollable) {\n      // when items length changes, and not scrollable, need resize canvas and redraw\n      this.setupCanvas();\n    } else {\n      // just redraw\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * all items with id and actual index\n   * @private\n   */\n  private _allItems: { id: string; index: number }[] = [];\n\n  /**\n   * all item blocks\n   * @private\n   */\n  private _itemBlocks: {\n    [startFrame: number]: FrameBlock;\n  }[] = [];\n\n  /**\n   * current frame index\n   * @private\n   */\n  private _currentFrame = 0;\n\n  /**\n   * get current frame\n   * @getter\n   */\n  get currentFrame() {\n    return this._currentFrame;\n  }\n\n  /**\n   * set current frame\n   * @setter\n   */\n  set currentFrame(frameIndex: number) {\n    const shouldUpdate = this._currentFrame !== frameIndex;\n    this._currentFrame = frameIndex;\n    if (shouldUpdate) {\n      this.focusFrame(frameIndex);\n    }\n  }\n\n  /**\n   * hovered frame index\n   * @private\n   */\n  private _hoveredFrame = -1;\n\n  /**\n   * hovered item index\n   * @private\n   */\n  private _hoveredItemIndex = -1;\n\n  /**\n   * hovered block\n   */\n  private _hoveredBlock: FrameBlock | null = null;\n\n  /**\n   * selected block\n   */\n  private _selectedBlock: FrameBlock | null = null;\n\n  /**\n   * pending block matches start frame\n   */\n  _pendingStartBlock: FrameBlock | null = null;\n\n  /**\n   * pending block matches end frame\n   */\n  _pendingEndBlock: FrameBlock | null = null;\n\n  /**\n   * is editing pending blocks by dragging\n   */\n  _pendingEditing = false;\n\n  /**\n   * cursor offset when editing pending blocks\n   */\n  _pendingCursorOffset = -1;\n\n  /**\n   * initial calculated range index (largest frames per range)\n   * @private\n   */\n  private _initialRangeIndex = 0;\n\n  /**\n   * current range index in the rangeFramesSet\n   * @private\n   */\n  private _currentRangeIndex = 0;\n\n  /**\n   * get current range index\n   * @getter\n   */\n  get currentRangeIndex() {\n    return this._currentRangeIndex;\n  }\n\n  /**\n   * set current range index\n   * @setters\n   */\n  set currentRangeIndex(index: number) {\n    const rangeIndex = Math.min(Math.max(index, this._initialRangeIndex), rangeFramesSet.length - 1);\n    const shouldUpdate = this._currentRangeIndex !== rangeIndex;\n    this._currentRangeIndex = rangeIndex;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * current range start frame (used for drawing)\n   * @private\n   */\n  private _currentRangeStart = 0;\n\n  /**\n   * current range start frame offset (used for drawing)\n   * @private\n   */\n  private _currentRangeStartOffset = 0;\n\n  /**\n   * current offset in canvas when zooming, dragging and so on\n   * @private\n   */\n  private _baseOffset = 0;\n\n  /**\n   * current offset frame index in canvas when zooming, dragging and so on\n   * @private\n   */\n  private _baseOffsetFrame = 0;\n\n  /**\n   * is mouse down on horizontal scrollbar\n   * @private\n   */\n  private _isScrollXDown = false;\n\n  /**\n   * base offset when mouse down on horizontal scrollbar\n   * @private\n   */\n  private _scrollXDownBaseOffsetFrame = 0;\n\n  /**\n   * client X when mouse down on horizontal scrollbar\n   * @private\n   */\n  private _scrollXDownClientX = 0;\n\n  /**\n   * horizontal scrollbar width\n   * @private\n   */\n  private _scrollXWidth = 0;\n\n  /**\n   * horizontal scrollbar offset\n   * @private\n   */\n  private _scrollXOffset = 0;\n\n  /**\n   * items offset\n   * @private\n   */\n  private _itemsOffset = 0;\n\n  /**\n   * get items offset\n   * @getter\n   */\n  get itemsOffset() {\n    return this._itemsOffset;\n  }\n\n  /**\n   * set items offset\n   * @setter\n   */\n  set itemsOffset(o: number) {\n    const offset = o * window.devicePixelRatio;\n    const shouldUpdate = this._itemsOffset !== offset;\n    this._itemsOffset = offset;\n    if (shouldUpdate) {\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * vertical scrollbar height\n   * @private\n   */\n  private _scrollYHeight = 0;\n\n  /**\n   * vertical scrollbar offset\n   * @private\n   */\n  private _scrollYOffset = 0;\n\n  /**\n   * is mouse down on vertical scrollbar\n   * @private\n   */\n  private _isScrollYDown = false;\n\n  /**\n   * items offset when mouse down on vertical scrollbar\n   * @private\n   */\n  private _scrollYDownItemsOffset = 0;\n\n  /**\n   * client y when mouse down on vertical scrollbar\n   * @private\n   */\n  private _scrollYDownClientY = 0;\n\n  /**\n   * item height\n   * @private\n   */\n  private _itemHeight = 20;\n\n  /**\n   * get item height\n   */\n  get itemHeight() {\n    return this._itemHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames height\n   * @private\n   */\n  private _framesHeight = 44;\n\n  /**\n   * get frames height\n   */\n  get framesHeight() {\n    return this._framesHeight * window.devicePixelRatio;\n  }\n\n  /**\n   * frames scale enable\n   */\n  private _scaleEnabled = true;\n\n  /**\n   * base range width\n   */\n  get baseRangeWidth() {\n    return 18 * 5 * window.devicePixelRatio;\n  }\n\n  /**\n   * canvas padding right\n   */\n  get paddingRight() {\n    return 18 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar container height\n   */\n  get scrollbarXContainerHeight() {\n    return 22 * window.devicePixelRatio;\n  }\n\n  /**\n   * horizontal scrollbar height\n   */\n  get scrollbarXHeight() {\n    return 16 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar width\n   */\n  get scrollbarYWidth() {\n    return 10 * window.devicePixelRatio;\n  }\n\n  /**\n   * vertical scrollbar offset x (from items container right)\n   */\n  get scrollbarYOffsetX() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block height\n   */\n  get itemBlockHeight() {\n    return 12 * window.devicePixelRatio;\n  }\n\n  /**\n   * item block offset y (in the item container)\n   */\n  get itemBlockOffsetY() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item text block height\n   */\n  get itemTextBlockHeight() {\n    return 18 * window.devicePixelRatio;\n  }\n\n  /**\n   * item text block offset y (in the item container)\n   */\n  get itemTextBlockOffsetY() {\n    return 1 * window.devicePixelRatio;\n  }\n\n  /**\n   * item endpoint block height\n   */\n  get itemEndpointBlockHeight() {\n    return 4 * window.devicePixelRatio;\n  }\n\n  /**\n   * item text block offset y (in the item container)\n   */\n  get itemEndpointBlockOffsetY() {\n    return 8 * window.devicePixelRatio;\n  }\n\n  /**\n   * item card height\n   */\n  get itemCardHeight() {\n    return 16 * window.devicePixelRatio;\n  }\n\n  /**\n   * items container height (when not collapsed)\n   */\n  get itemsContainerHeight() {\n    return 275 * window.devicePixelRatio;\n  }\n\n  /**\n   * frames container height\n   */\n  get itemsTotalHeight() {\n    if (this.scrollable) {\n      return this.itemsContainerHeight;\n    }\n    return Object.keys(this._items).length * this.itemHeight;\n  }\n\n  /**\n   * current range frames\n   */\n  get rangeFrames() {\n    return rangeFramesSet[this._currentRangeIndex];\n  }\n\n  /**\n   * current per frame width\n   */\n  get perFrameWidth() {\n    return this._currentRangeIndex <= this._initialRangeIndex\n      ? (this.canvas.width - this.paddingRight) / this.frameCount\n      : this.baseRangeWidth / this.rangeFrames;\n  }\n\n  /**\n   * current card width\n   */\n  get cardWidth() {\n    return this.perFrameWidth - this.cardOffsetX * 2;\n  }\n\n  /**\n   * card offset x (base on item)\n   */\n  get cardOffsetX() {\n    return 1 * window.devicePixelRatio;\n  }\n\n  /**\n   * card offset y (base on item)\n   */\n  get cardOffsetY() {\n    return (this.itemHeight - this.itemCardHeight) / 2 - 1;\n  }\n\n  /**\n   * constructor\n   * @param canvas\n   * @param frameCount\n   * @param options\n   */\n  constructor(\n    container: HTMLDivElement,\n    frameCount: number,\n    { itemHeight, framesHeight, bgColor, itemColor, itemSelectedColor, cardColor, scaleEnabled, fixHeight }: {\n      itemHeight?: number,\n      framesHeight?: number,\n      bgColor?: string,\n      itemColor?: string,\n      itemSelectedColor?: string,\n      cardColor?: string,\n      scaleEnabled?: boolean,\n      fixHeight?: boolean,\n    } = {},\n  ) {\n    super();\n    this._scaleEnabled = scaleEnabled === undefined ? true : scaleEnabled;\n    this.container = container;\n    this.frameCount = frameCount;\n    if (itemHeight) {\n      this._itemHeight = itemHeight;\n    }\n    if (framesHeight) {\n      this._framesHeight = framesHeight;\n    }\n    this.bgColor = bgColor || '#3D424D';\n    this.itemColor = itemColor || '#343846';\n    this.itemSelectedColor = itemSelectedColor || '#2F3340';\n    this.cardColor = cardColor || '#5C5F6B';\n    this.fixHeight = fixHeight || false;\n\n    this.container.style.position = 'relative';\n    // create canvas dom\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this.canvas.style.display = 'block';\n    this.container.appendChild(this.canvas);\n    // create tip dom\n    this.frameTip = document.createElement('div');\n    this.frameTip.style.position = 'absolute';\n    this.frameTip.style.background = '#34CBD1';\n    this.frameTip.style.padding = '0 2px';\n    this.frameTip.style.borderRadius = '2px';\n    this.frameTip.style.fontSize = '10px';\n    this.frameTip.style.color = '#252935';\n    this.frameTip.style.lineHeight = '12px';\n    this.frameTip.style.height = '12px';\n    this.frameTip.style.top = '8px';\n    this.frameTip.style.display = 'none';\n    this.container.appendChild(this.frameTip);\n    this.container.oncontextmenu = (e) => e.preventDefault();\n\n    this.addEventListeners();\n    this.setupCanvas();\n  }\n\n  /**\n   * update one item's frame status\n   * @param id\n   * @param frameStatus\n   */\n  updateItemFrameStatus(id: string, frameStatus: { [frameIndex: number]: boolean }) {\n    if (this._items[id]) {\n      this._items[id].frameStatus = cloneDeep(frameStatus);\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * add event listeners\n   */\n  addEventListeners() {\n    document.addEventListener('mousemove', this.cursorMove);\n    document.addEventListener('mouseup', this.cursorUp);\n    window.addEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').addEventListener('change', this.setupCanvas);\n    this.canvas.addEventListener('wheel', this.wheel);\n    this.canvas.addEventListener('mousedown', this.canvasDown);\n    this.canvas.addEventListener('mousemove', this.canvasMove);\n    this.canvas.addEventListener('mouseleave', this.canvasLeave);\n  }\n\n  /**\n   * remove event listeners\n   */\n  removeEventListeners() {\n    document.removeEventListener('mousemove', this.cursorMove);\n    document.removeEventListener('mouseup', this.cursorUp);\n    window.removeEventListener('resize', this.setupCanvas);\n    window.matchMedia('screen and (min-resolution: 2dppx)').removeEventListener('change', this.setupCanvas);\n    this.canvas.removeEventListener('wheel', this.wheel);\n    this.canvas.removeEventListener('mousedown', this.canvasDown);\n    this.canvas.removeEventListener('mousemove', this.canvasMove);\n    this.canvas.removeEventListener('mouseleave', this.canvasLeave);\n  }\n\n  /**\n   * set up canvas size\n   */\n  setupCanvas = () => {\n    const { width } = this.canvas.getBoundingClientRect();\n    const originCanvasWidth = this.canvas.width;\n    this.canvas.width = width * window.devicePixelRatio;\n    this.canvas.height = this.itemsTotalHeight + this.framesHeight;\n    this.emit(EventAction.HEIGHT_CHANGE, this.canvas.height / window.devicePixelRatio);\n\n    this.setupRangeIndexes(originCanvasWidth !== this.canvas.width);\n    this.drawFrames();\n  };\n\n  /**\n   * calculate initial range index\n   */\n  setupRangeIndexes(update: boolean) {\n    if (update) {\n      const estimatedRangeFrames = (this.frameCount / (this.canvas.width - this.paddingRight)) * this.baseRangeWidth;\n      let rangeIndex = 0;\n      while (rangeFramesSet[rangeIndex] > estimatedRangeFrames && rangeIndex < rangeFramesSet.length) {\n        rangeIndex += 1;\n      }\n      this._initialRangeIndex = rangeIndex > 0 ? rangeIndex - 1 : 0;\n      this._currentRangeIndex = this._initialRangeIndex;\n    }\n    this.emit(\n      EventAction.VISIBLE_FRAMES_UPDATE,\n      this._currentRangeIndex,\n      rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex),\n    );\n  }\n\n  /**\n   * draw frames\n   */\n  drawFrames() {\n    const ctx = this.canvas.getContext('2d');\n    if (ctx) {\n      ctx.save();\n\n      // clear canvas\n      const { width, height } = this.canvas;\n      ctx.clearRect(0, 0, width, height);\n\n      // calc current range\n      this._currentRangeStart = Math.floor(this._baseOffsetFrame / this.rangeFrames) * this.rangeFrames;\n      if (this._currentRangeStart === 0) {\n        // reset offset to 0\n        this._currentRangeStartOffset = 0;\n      } else {\n        this._currentRangeStartOffset = this._baseOffset - (this._baseOffsetFrame - this._currentRangeStart) * this.perFrameWidth;\n        const firstFrameOffset = this._baseOffset - this._baseOffsetFrame * this.perFrameWidth;\n        const lastFrameOffset = this._baseOffset + (this.frameCount - this._baseOffsetFrame) * this.perFrameWidth;\n        if (firstFrameOffset > 0) {\n          this._currentRangeStartOffset -= firstFrameOffset;\n        } else if (lastFrameOffset < (width - this.paddingRight)) {\n          this._currentRangeStartOffset += width - this.paddingRight - lastFrameOffset;\n        }\n      }\n\n      this.drawFrameItems(ctx);\n      this.drawFrameScales(ctx);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n   * draw frame items\n   * @param ctx\n   */\n  drawFrameItems(ctx: CanvasRenderingContext2D) {\n    if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n      // block cursor & cards\n      this.drawItems(ctx, 'blocks');\n      this.drawFrameHint(ctx);\n      this.drawItems(ctx, 'cards');\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    } else {\n      // line cursor & blocks\n      this.drawItems(ctx);\n      this.drawFrameHint(ctx);\n      this.drawInvalidFrames(ctx);\n      this.drawFrameHint(ctx, 'hover');\n    }\n  }\n\n  /**\n   * draw items\n   * @param ctx\n   * @param type empty means all items\n   */\n  drawItems(ctx: CanvasRenderingContext2D, type?: string) {\n    let items = this._allItems;\n    if (type === 'blocks') {\n      items = items.filter(({ id }) => !this._items[id].showCards && this._items[id].type !== FrameItemType.CARD);\n    } else if (type === 'cards') {\n      items = items.filter(({ id }) => this._items[id].showCards || this._items[id].type === FrameItemType.CARD);\n    }\n\n    const width = this.canvas.width - this.paddingRight;\n    items.forEach(({ id, index }) => {\n      const { frameStatus = {}, frameColor = {}, color, type: frameItemType, showCards, selected } = this._items[id];\n      const itemOffset = index * this.itemHeight;\n      if ((itemOffset + this.itemHeight) <= this._itemsOffset || (itemOffset - this._itemsOffset) >= this.itemsTotalHeight) {\n        // out of container\n        return;\n      }\n\n      const height = this.itemHeight;\n      const offsetY = itemOffset - this._itemsOffset + this.scrollbarXContainerHeight;\n\n      // draw background\n      let bgColor = this.itemColor;\n      if (frameItemType === FrameItemType.TEXT && this._hoveredItemIndex === index) {\n        // text block hovered\n        bgColor = this.itemSelectedColor;\n      } else if (selected) {\n        bgColor = this.itemSelectedColor;\n      }\n      drawRect(ctx, 0, offsetY, width, height, bgColor);\n      // draw bottom line\n      drawLine(ctx, 0, offsetY + height - 1, width, offsetY + height - 1, borderColor);\n\n      if ((showCards || frameItemType === FrameItemType.CARD) && this._currentRangeIndex === rangeFramesSet.length - 1) {\n        // draw cards\n        const drawCard = (frame: number, frameOffset: number) => {\n          if (frameOffset + this.cardOffsetX < width) {\n            let cWidth = this.cardWidth;\n            if (frameOffset + this.cardOffsetX + cWidth > width) {\n              cWidth = width - (frameOffset + this.cardOffsetX);\n            }\n            if (frameStatus[frame] !== undefined) {\n              const cardColor = frameColor[frame] || this.cardColor;\n              drawRect(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, cardColor);\n              if (frameStatus[frame] === true && frameOffset + this.perFrameWidth / 2 < width) {\n                drawCircle(ctx, frameOffset + this.perFrameWidth / 2, offsetY + this.itemHeight / 2, 2, '#FFFFFF');\n              }\n            }\n            if (frame === this._currentFrame && selected) {\n              drawRectBorder(ctx, frameOffset + this.cardOffsetX, offsetY + this.cardOffsetY, cWidth, this.itemCardHeight, '#FFFFFF');\n            }\n          }\n        };\n        const drawRangeCards = (start: number, offset: number) => {\n          Array.from({ length: 5 }).forEach((_, i) => {\n            const frame = start + i;\n            if (frameStatus[frame] !== undefined || (frame === this._currentFrame && selected)) {\n              const frameOffset = offset + this.perFrameWidth * i;\n              drawCard(frame, frameOffset);\n            }\n          });\n        };\n\n        if (this._currentRangeIndex <= this._initialRangeIndex) {\n          // just draw all frames\n          Array.from({ length: this.frameCount }).forEach((_, i) => {\n            drawCard(i, this.perFrameWidth * i);\n          });\n        } else {\n          let rangeStart = this._currentRangeStart;\n          let rangeStartOffset = this._currentRangeStartOffset;\n          while ((rangeStartOffset + this.baseRangeWidth) >= 0 && rangeStart >= 0) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart -= this.rangeFrames;\n            rangeStartOffset -= this.baseRangeWidth;\n          }\n          rangeStart = this._currentRangeStart + this.rangeFrames;\n          rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n          while (rangeStartOffset < width && rangeStart < this.frameCount) {\n            drawRangeCards(rangeStart, rangeStartOffset);\n            rangeStart += this.rangeFrames;\n            rangeStartOffset += this.baseRangeWidth;\n          }\n        }\n      } else {\n        const drawTextBlock = (startOffset: number, endOffset: number, text: string, blockColor: string, blockSelected: boolean) => {\n          if (endOffset > startOffset) {\n            const o = 1 * window.devicePixelRatio;\n            const itemOffsetX = startOffset + o;\n            const itemOffsetY = offsetY + this.itemTextBlockOffsetY;\n            const blockWidth = endOffset - startOffset - o * 2;\n            drawRect(ctx, itemOffsetX, itemOffsetY, blockWidth, this.itemTextBlockHeight, blockColor);\n            if (blockSelected) {\n              const currentFrameOffset = this._currentRangeStartOffset + (this.currentFrame - this._currentRangeStart) * this.perFrameWidth;\n              drawRect(ctx, currentFrameOffset, itemOffsetY, this.perFrameWidth, this.itemTextBlockHeight, '#4A90E2');\n            }\n            const textOffsetX = itemOffsetX + o * 2;\n            const textOffsetY = itemOffsetY + o * 4;\n            const textWidth = blockWidth - o * 4;\n            drawText(ctx, text, textOffsetX, textOffsetY, '#FFFFFF', 12, textWidth);\n          }\n        };\n        const drawEndpointBlock = (startOffset: number, endOffset: number) => {\n          if (endOffset >= startOffset) {\n            const startOffsetX = startOffset + this.perFrameWidth / 2;\n            if (endOffset > startOffset) {\n              drawRect(ctx, startOffsetX, offsetY + this.itemEndpointBlockOffsetY, endOffset - startOffset - this.perFrameWidth, this.itemEndpointBlockHeight, color);\n            }\n            drawRhombus(ctx, startOffsetX, offsetY + this.itemHeight / 2, 6, '#4A90E2');\n          }\n        };\n        const drawBlock = (startOffset: number, endOffset: number) => {\n          if (endOffset > startOffset) {\n            drawRect(ctx, startOffset, offsetY + this.itemBlockOffsetY, endOffset - startOffset, this.itemBlockHeight, color);\n          }\n        };\n\n        const allBlocks = Object.values(this._itemBlocks[index]);\n        allBlocks.forEach((block) => {\n          const { startFrame, endFrame } = block;\n          let startOffset = this._currentRangeStartOffset + (startFrame - this._currentRangeStart) * this.perFrameWidth;\n          let endOffset = this._currentRangeStartOffset + (endFrame - this._currentRangeStart) * this.perFrameWidth;\n          if (this._pendingEditing) {\n            if (block === this._pendingStartBlock) {\n              startOffset = this._pendingCursorOffset;\n            } else if (block === this._pendingEndBlock) {\n              endOffset = this._pendingCursorOffset;\n            } else if (index === this._hoveredItemIndex) {\n              const pendingStartFrame = this._pendingEndBlock ? this._pendingEndBlock.startFrame : this._pendingStartBlock!.startFrame;\n              const pendingEndFrame = this._pendingStartBlock ? this._pendingStartBlock.endFrame : this._pendingEndBlock!.endFrame;\n              if (startFrame >= pendingEndFrame) {\n                // blocks on the right\n                if (this._pendingCursorOffset > startOffset) {\n                  startOffset = this._pendingCursorOffset;\n                  if (this._pendingCursorOffset > endOffset) {\n                    endOffset = this._pendingCursorOffset;\n                  }\n                }\n              } else if (endFrame <= pendingStartFrame) {\n                // blocks on the left\n                if (this._pendingCursorOffset < endOffset) {\n                  endOffset = this._pendingCursorOffset;\n                  if (this._pendingCursorOffset < startOffset) {\n                    startOffset = this._pendingCursorOffset;\n                  }\n                }\n              }\n            }\n          }\n          startOffset = Math.min(Math.max(startOffset, 0), width);\n          endOffset = Math.min(Math.max(endOffset, 0), width);\n          if (frameItemType === FrameItemType.TEXT) {\n            const blockColor = block.hovered ? '#777B82' : color;\n            drawTextBlock(startOffset, endOffset, `${frameStatus[startFrame]}`, blockColor, block.selected);\n          } else if (frameItemType === FrameItemType.ENDPOINT) {\n            drawEndpointBlock(startOffset, endOffset);\n          } else {\n            drawBlock(startOffset, endOffset);\n          }\n        });\n      }\n    });\n\n    if (type !== 'cards') {\n      // no need to draw vertical scroll bar when drawing cards\n      const visibleItemsCount = this.itemsTotalHeight / this.itemHeight;\n      if (visibleItemsCount < this._allItems.length) {\n        // draw scroll y\n        this._scrollYHeight = (visibleItemsCount / this._allItems.length) * this.itemsTotalHeight;\n        this._scrollYOffset = (this._itemsOffset / (this._allItems.length * this.itemHeight)) * this.itemsTotalHeight + this.scrollbarXContainerHeight;\n        drawRoundedRect(ctx, width + this.scrollbarYOffsetX, this._scrollYOffset, this.scrollbarYWidth, this._scrollYHeight, 6, scrollbarColor);\n      } else {\n        this._scrollYHeight = 0;\n        this._scrollYOffset = 0;\n      }\n    }\n  }\n\n  /**\n   * draw invalid frame style\n   * @param ctx\n   */\n  drawInvalidFrames(ctx: CanvasRenderingContext2D) {\n    // draw invalid frames\n    this._invalidFrames.forEach((frameIndex) => {\n      const offsetX = this.getOffsetByFrame(frameIndex);\n      if (offsetX >= 0) {\n        drawRect(ctx, offsetX, this.scrollbarXContainerHeight, Math.max(this.perFrameWidth, 1 * window.devicePixelRatio), this.itemsTotalHeight, 'rgba(220, 70, 36, 0.3)');\n      }\n    });\n  }\n\n  /**\n   * draw frame hint (for current frame & hovered frame)\n   * @param ctx\n   * @param type\n   */\n  drawFrameHint(ctx: CanvasRenderingContext2D, type?: string) {\n    const frame = type === 'hover' ? this._hoveredFrame : this._currentFrame;\n    const shouldDraw = type !== 'hover' || this._hoveredFrame !== this._currentFrame;\n    if (shouldDraw) {\n      const offsetX = this.getOffsetByFrame(frame);\n      if (offsetX >= 0) {\n        if (this._currentRangeIndex === rangeFramesSet.length - 1) {\n          // block\n          drawRect(ctx, offsetX, this.scrollbarXContainerHeight, this.perFrameWidth, this.itemsTotalHeight, 'rgba(41, 44, 56, 0.4)');\n          if (type === 'hover' && this._hoveredItemIndex >= 0) {\n            const hoveredItem = this.items[this._allItems[this._hoveredItemIndex]?.id];\n            if (hoveredItem?.showCards || hoveredItem?.type === FrameItemType.CARD || hoveredItem?.type === FrameItemType.TEXT) {\n              const offsetY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n              drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, 'rgba(255, 255, 255, 0.4)');\n            }\n          }\n          if (type !== 'hover') {\n            const selectedIndex = this._allItems.findIndex((i) => this.items[i.id].selected);\n            const offsetY = selectedIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n            drawRectBorder(ctx, offsetX + this.cardOffsetX, offsetY + this.cardOffsetY, this.cardWidth, this.itemCardHeight, '#FFFFFF');\n          }\n        } else {\n          // line\n          drawLine(ctx, offsetX + 0.5, this.scrollbarXContainerHeight, offsetX + 0.5, this.itemsTotalHeight + this.scrollbarXContainerHeight, type === 'hover' ? 'rgba(255, 255, 255, 0.4)' : '#34CBD1');\n        }\n      }\n    }\n  }\n\n  /**\n   * draw frame scales\n   * @param ctx\n   */\n  drawFrameScales(ctx: CanvasRenderingContext2D) {\n    if (!this._scaleEnabled) return;\n    const width = this.canvas.width - this.paddingRight;\n    const offsetY = this.itemsTotalHeight + this.scrollbarXContainerHeight;\n    const scaleWidth = this.perFrameWidth * this.rangeFrames;\n    const scaleHeight = 16 * window.devicePixelRatio;\n    const scaleHeightShort = 4 * window.devicePixelRatio;\n\n    // draw scales top border\n    drawRect(ctx, 0, offsetY, width, this.itemHeight, this.bgColor);\n    drawLine(ctx, 0, offsetY - 1, width, offsetY - 1, borderColor);\n\n    if (this._currentRangeIndex <= this._initialRangeIndex) {\n      const rangeCount = this.frameCount / this.rangeFrames;\n      const rangeWidth = width / rangeCount;\n      if (rangeWidth > this.baseRangeWidth * 5) {\n        for (let i = 0; i < this.frameCount; i += 1) {\n          drawScale(ctx, i * this.perFrameWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i, false);\n        }\n      } else {\n        for (let i = 0; i < rangeCount; i += 1) {\n          drawScale(ctx, i * rangeWidth, offsetY, scaleWidth, scaleHeight, scaleHeightShort, i * this.rangeFrames);\n        }\n      }\n\n      this._scrollXWidth = 0;\n      this._scrollXOffset = 0;\n    } else {\n      let rangeStart = this._currentRangeStart;\n      let rangeStartOffset = this._currentRangeStartOffset;\n      while ((rangeStartOffset + this.baseRangeWidth) >= 0 && rangeStart >= 0) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart -= this.rangeFrames;\n        rangeStartOffset -= this.baseRangeWidth;\n      }\n      rangeStart = this._currentRangeStart + this.rangeFrames;\n      rangeStartOffset = this._currentRangeStartOffset + this.baseRangeWidth;\n      while (rangeStartOffset < width && rangeStart < this.frameCount) {\n        drawScale(ctx, rangeStartOffset, offsetY, scaleWidth, scaleHeight, scaleHeightShort, rangeStart);\n        rangeStart += this.rangeFrames;\n        rangeStartOffset += this.baseRangeWidth;\n      }\n    }\n\n    // draw scrollbar\n    this._scrollXWidth = Math.max(Math.ceil((width / this.perFrameWidth / this.frameCount) * width), 42);\n    this._scrollXOffset = ((this._currentRangeStart - this._currentRangeStartOffset / this.perFrameWidth) / this.frameCount) * width;\n    // scrollbar container background\n    drawRect(ctx, 0, 0, width, this.scrollbarXContainerHeight, scrollbarContainerColor);\n    drawLine(ctx, 0, this.scrollbarXContainerHeight - 1, width, this.scrollbarXContainerHeight - 1, borderColor);\n    // scrollbar thumbnail\n    const scrollbarXOffsetY = (this.scrollbarXContainerHeight - this.scrollbarXHeight) / 2 - 1;\n    drawRoundedRect(ctx, this._scrollXOffset, scrollbarXOffsetY, this._scrollXWidth, this.scrollbarXHeight, 2, scrollbarColor);\n    const o = 2 * window.devicePixelRatio;\n    const h = this.scrollbarXHeight - o * 4;\n    drawRect(ctx, this._scrollXOffset + o, scrollbarXOffsetY + o * 2, o, h, scrollbarContainerColor);\n    drawRect(ctx, this._scrollXOffset + this._scrollXWidth - o * 2, scrollbarXOffsetY + o * 2, o, h, scrollbarContainerColor);\n    // draw current frame\n    const frameOffset = (this._currentFrame / this.frameCount) * width;\n    drawLine(ctx, frameOffset + 0.5, 0, frameOffset + 0.5, this.scrollbarXContainerHeight, '#34CBD1');\n  }\n\n  /**\n   * update frame tip text and posistion\n   */\n  updateFrameTip() {\n    if (this._hoveredFrame >= 0) {\n      this.frameTip.innerText = `${this._hoveredFrame + 1}`;\n      const { width } = this.frameTip.getBoundingClientRect();\n      const frameOffset = this.getOffsetByFrame(this._hoveredFrame) / window.devicePixelRatio;\n      let offset = frameOffset - width / 2;\n      if (this.currentRangeIndex === rangeFramesSet.length - 1) {\n        offset += (this.perFrameWidth / 2) / window.devicePixelRatio;\n      }\n      this.frameTip.style.left = `${offset}px`;\n      this.frameTip.style.display = 'block';\n    } else {\n      this.frameTip.style.display = 'none';\n    }\n  }\n\n  /**\n   * update items scroll and emit event\n   */\n  updateItemsScroll(itemsOffset: number) {\n    const allItemsHeight = this._allItems.length * this.itemHeight;\n    if (allItemsHeight <= this.itemsContainerHeight) {\n      // not scrollable\n      return;\n    }\n    this._itemsOffset = itemsOffset;\n    if (this._itemsOffset < 0) {\n      this._itemsOffset = 0;\n    } else if (this._itemsOffset > allItemsHeight - this.itemsTotalHeight) {\n      this._itemsOffset = allItemsHeight - this.itemsTotalHeight;\n    }\n    this.drawFrames();\n    this.emit(EventAction.ITEMS_OFFSET_CHANGE, this._itemsOffset / window.devicePixelRatio);\n  }\n\n  /**\n   * get frame by clientX\n   * @param clientX\n   * @returns\n   */\n  getFrameByClientX(clientX: number) {\n    const { left } = this.canvas.getBoundingClientRect();\n    const offset = (clientX - left) * window.devicePixelRatio;\n    let frame = this._currentRangeStart + Math.floor((offset - this._currentRangeStartOffset) / this.perFrameWidth);\n    if (frame >= this.frameCount) {\n      frame = this.frameCount - 1;\n    } else if (frame < 0) {\n      frame = 0;\n    }\n    return frame;\n  }\n\n  /**\n   * get item index by clientY\n   * @param clientY\n   * @returns\n   */\n  getItemIndexByClientY(clientY: number) {\n    const { top } = this.canvas.getBoundingClientRect();\n    const offset = (clientY - top) * window.devicePixelRatio;\n    const index = Math.floor((offset + this._itemsOffset - this.scrollbarXContainerHeight) / this.itemHeight);\n    if (index > Object.keys(this._items).length - 1) {\n      return -1;\n    }\n    return index;\n  }\n\n  /**\n   * get offset by frame index\n   * @param frame\n   * @param checkOutside\n   * @returns\n   */\n  getOffsetByFrame(frame: number, checkOutside = true) {\n    const offset = this._currentRangeStartOffset + (frame - this._currentRangeStart) * this.perFrameWidth;\n    if (checkOutside && (offset < 0 || offset > (this.canvas.width - this.paddingRight))) {\n      return -1;\n    }\n    return offset;\n  }\n\n  /**\n   * check hover item\n   * @param clientX\n   * @param clientY\n   * @returns\n   */\n  getMouseHover(clientX: number, clientY: number) {\n    const { width: canvasWidth, height: canvasHeight } = this.canvas;\n    const { left, top, width, height } = this.canvas.getBoundingClientRect();\n    const offsetX = clientX - left;\n    const offsetY = clientY - top;\n\n    if (\n      offsetX / width >= this._scrollXOffset / canvasWidth &&\n      offsetX / width <= (this._scrollXOffset + this._scrollXWidth) / canvasWidth &&\n      offsetY / height <= this.scrollbarXContainerHeight / canvasHeight\n    ) {\n      return HoverType.SCROLLBAR_X;\n    }\n\n    if (\n      offsetY / height <= this.scrollbarXContainerHeight / canvasHeight\n    ) {\n      return HoverType.SCROLLBAR_X_CONTAINER;\n    }\n\n    const scrollbarOffsetX = canvasWidth - this.paddingRight + this.scrollbarYOffsetX;\n    if (\n      offsetX / width >= scrollbarOffsetX / canvasWidth &&\n      offsetX / width <= (scrollbarOffsetX + this.scrollbarYWidth) / canvasWidth &&\n      offsetY / height >= this._scrollYOffset / canvasHeight &&\n      offsetY / height <= (this._scrollYOffset + this._scrollYHeight) / canvasHeight\n    ) {\n      return HoverType.SCROLLBAR_Y;\n    }\n\n    if (\n      offsetX * window.devicePixelRatio > canvasWidth - this.paddingRight &&\n      offsetX * window.devicePixelRatio <= canvasWidth\n    ) {\n      return HoverType.SCROLLBAR_Y_CONTAINER;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * set cursor for progress bar\n   * @param cursor\n   */\n  setCursor(cursor: Cursor) {\n    if (this.canvas.style.cursor !== cursor) {\n      this.canvas.style.cursor = cursor;\n    }\n  }\n\n  /**\n   * unselect block\n   */\n  unselectBlock() {\n    if (this._selectedBlock) {\n      this._selectedBlock.selected = false;\n      this._selectedBlock = null;\n      this.drawFrames();\n    }\n  }\n\n  /**\n   * focus to specific frame if not in the progress bar view\n   * @param frame\n   */\n  focusFrame(frame: number) {\n    const offset = this.getOffsetByFrame(frame, false);\n    const right = this.canvas.width - this.paddingRight - this.perFrameWidth;\n    if (offset < 0) {\n      // move left\n      this._baseOffsetFrame = frame;\n      this._baseOffset = this.perFrameWidth;\n    } else if (offset > right) {\n      // move right\n      this._baseOffsetFrame = frame;\n      this._baseOffset = right - this.perFrameWidth;\n    }\n    this.drawFrames();\n  }\n\n  /**\n   * mouse wheel\n   * @param e\n   */\n  wheel = (e: WheelEvent) => {\n    if (e.altKey) {\n      this.zoom(e);\n    } else {\n      // scroll y\n      this.updateItemsScroll(this._itemsOffset + e.deltaY);\n    }\n  };\n\n  /**\n   * zooming\n   * @param e\n   */\n  zoom = (e: WheelEvent) => {\n    const hover = this.getMouseHover(e.clientX, e.clientY);\n    if (hover === HoverType.SCROLLBAR_Y_CONTAINER || hover === HoverType.SCROLLBAR_Y) {\n      return;\n    }\n    // zoom to scale frames\n    const { left } = this.canvas.getBoundingClientRect();\n    this._baseOffset = (e.clientX - left) * window.devicePixelRatio;\n    this._baseOffsetFrame = this.getFrameByClientX(e.clientX);\n    if (e.deltaY > 0) {\n      this._currentRangeIndex += 1;\n    } else {\n      this._currentRangeIndex -= 1;\n    }\n    this._currentRangeIndex = Math.min(Math.max(this._currentRangeIndex, this._initialRangeIndex), rangeFramesSet.length - 1);\n    this.emit(EventAction.VISIBLE_FRAMES_UPDATE, this._currentRangeIndex, rangeFramesSet.map((_, i) => i).slice(this._initialRangeIndex));\n    this.drawFrames();\n    this.canvasMove(e);\n  };\n\n  /**\n   * mouse down on canvas\n   * @param e\n   */\n  canvasDown = (e: MouseEvent) => {\n    const hover = this.getMouseHover(e.clientX, e.clientY);\n    if (hover === HoverType.SCROLLBAR_X) {\n      // click on horizontal scrollbar\n      this._isScrollXDown = true;\n      this._scrollXDownBaseOffsetFrame = this._baseOffsetFrame;\n      this._scrollXDownClientX = e.clientX;\n    } else if (hover === HoverType.SCROLLBAR_Y) {\n      // click on vertical scrollbar\n      this._isScrollYDown = true;\n      this._scrollYDownItemsOffset = this._itemsOffset;\n      this._scrollYDownClientY = e.clientY;\n    } else if (this._pendingStartBlock || this._pendingEndBlock) {\n      this._pendingEditing = true;\n      this.emit(EventAction.BLOCK_HOVERED, this._hoveredBlock);\n    } else if (this._hoveredBlock) {\n      this.currentFrame = this._hoveredFrame;\n      this.emit(EventAction.CURRENT_FRAME_CHANGE, this._currentFrame, this._hoveredItemIndex);\n      if (e.buttons === 2) {\n        // activate\n        this._selectedBlock = this._hoveredBlock;\n        this._selectedBlock.selected = true;\n        this.drawFrames();\n        const hoveredItemY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n        this.emit(EventAction.BLOCK_SELECTED, this._selectedBlock, this._hoveredItemIndex, e.clientX, (this.canvas.height - hoveredItemY) / window.devicePixelRatio);\n      }\n    } else if (this._hoveredFrame >= 0) {\n      this.currentFrame = this._hoveredFrame;\n      this.emit(EventAction.CURRENT_FRAME_CHANGE, this._currentFrame, this._hoveredItemIndex);\n    }\n  };\n\n  /**\n   * mouse move on canvas\n   * @param e\n   */\n  canvasMove = (e: MouseEvent) => {\n    if (this._pendingEditing) {\n      this._hoveredFrame = this.getFrameByClientX(e.clientX);\n      this.updateFrameTip();\n      return;\n    }\n\n    this.setCursor(Cursor.DEFAULT);\n    const hover = this.getMouseHover(e.clientX, e.clientY);\n    if (hover === HoverType.SCROLLBAR_X) {\n      // hover on horizontal scrollbar\n      this.canvasLeave();\n      this.setCursor(Cursor.POINTER);\n    } else if (hover === HoverType.SCROLLBAR_Y) {\n      this.canvasLeave();\n      this.setCursor(Cursor.POINTER);\n    } else if (hover === HoverType.SCROLLBAR_X_CONTAINER || hover === HoverType.SCROLLBAR_Y_CONTAINER) {\n      this.canvasLeave();\n    } else {\n      this._hoveredFrame = this.getFrameByClientX(e.clientX);\n      this._hoveredItemIndex = this.getItemIndexByClientY(e.clientY);\n      if (this._hoveredBlock) {\n        this._hoveredBlock.hovered = false;\n      }\n      this._hoveredBlock = null;\n      this._pendingStartBlock = null;\n      this._pendingEndBlock = null;\n\n      const { left } = this.canvas.getBoundingClientRect();\n      const cursorOffset = (e.clientX - left) * window.devicePixelRatio;\n      const threshold = 6 * window.devicePixelRatio;\n      this._itemBlocks.forEach((blocks, i) => {\n        Object.values(blocks).forEach((item) => {\n          if (i === this._hoveredItemIndex) {\n            const { startFrame, endFrame, value } = item;\n            // check block hovered\n            item.hovered = this._hoveredFrame >= startFrame && this._hoveredFrame < endFrame && typeof value !== 'boolean';\n            if (item.hovered) {\n              this._hoveredBlock = item;\n            }\n            // check draggable block is pending\n            if (item.draggable && (this._hoveredFrame === startFrame || this._hoveredFrame === startFrame - 1)) {\n              // match the block beginning\n              const frameOffset = this._currentRangeStartOffset + (startFrame - this._currentRangeStart) * this.perFrameWidth;\n              if (Math.abs(cursorOffset - frameOffset) < threshold) {\n                this.setCursor(Cursor.COL_RESIZE);\n                this._pendingStartBlock = item;\n              }\n            }\n            if (item.draggable && (this._hoveredFrame === endFrame || this._hoveredFrame === endFrame - 1)) {\n              // match the block ending\n              const frameOffset = this._currentRangeStartOffset + (endFrame - this._currentRangeStart) * this.perFrameWidth;\n              if (Math.abs(cursorOffset - frameOffset) < threshold) {\n                this.setCursor(Cursor.COL_RESIZE);\n                this._pendingEndBlock = item;\n              }\n            }\n          }\n        });\n      });\n\n      this.drawFrames();\n      this.updateFrameTip();\n\n      const hoveredItemY = this._hoveredItemIndex * this.itemHeight - this._itemsOffset + this.scrollbarXContainerHeight;\n      this.emit(\n        EventAction.BLOCK_HOVERED,\n        this._hoveredBlock,\n        this._hoveredFrame,\n        this._hoveredItemIndex,\n        e.clientX,\n        (this.canvas.height - hoveredItemY) / window.devicePixelRatio,\n      );\n    }\n  };\n\n  /**\n   * mouse leave canvas\n   */\n  canvasLeave = () => {\n    this._hoveredFrame = -1;\n    this._hoveredItemIndex = -1;\n    if (this._hoveredBlock) {\n      this._hoveredBlock.hovered = false;\n    }\n    this._hoveredBlock = null;\n    this._pendingStartBlock = null;\n    this._pendingEndBlock = null;\n    this.drawFrames();\n    this.updateFrameTip();\n    this.emit(EventAction.BLOCK_HOVERED, this._hoveredBlock);\n  };\n\n  /**\n   * mouse move on document (dragging scrollbar)\n   * @param e\n   */\n  cursorMove = (e: MouseEvent) => {\n    if (this._pendingEditing) {\n      const { left } = this.canvas.getBoundingClientRect();\n      this._pendingCursorOffset = (e.clientX - left) * window.devicePixelRatio;\n      this.drawFrames();\n    } else if (this._isScrollXDown) {\n      // move horizontal scrollbar\n      const offset = (e.clientX - this._scrollXDownClientX) * window.devicePixelRatio;\n      const frames = Math.floor((offset / (this.canvas.width - this.paddingRight)) * this.frameCount);\n      this._baseOffsetFrame = this._scrollXDownBaseOffsetFrame + frames;\n      this._hoveredFrame = -1;\n      this._hoveredItemIndex = -1;\n      this.drawFrames();\n      this.updateFrameTip();\n    } else if (this._isScrollYDown) {\n      // move vertical scrollbar\n      const offset = (e.clientY - this._scrollYDownClientY) * window.devicePixelRatio;\n      const itemsOffset = this._scrollYDownItemsOffset + (offset / this.itemsContainerHeight) * this._allItems.length * this.itemHeight;\n      this.updateItemsScroll(itemsOffset);\n    }\n  };\n\n  /**\n   * mouse up on document (dragging scrollbar)\n   */\n  cursorUp = () => {\n    if (this._pendingEditing && this._pendingCursorOffset >= 0) {\n      let frame = this._currentRangeStart + Math.round((this._pendingCursorOffset - this._currentRangeStartOffset) / this.perFrameWidth);\n      if (frame > this.frameCount) {\n        frame = this.frameCount;\n      } else if (frame < 0) {\n        frame = 0;\n      }\n\n      const updatedFrameStatus: {\n        [frameIndex: number]: number | null;\n      } = {};\n      const pendingStartFrame = this._pendingStartBlock?.startFrame;\n      const pendingEndFrame = this._pendingEndBlock?.endFrame;\n      if (pendingStartFrame !== undefined) {\n        if (frame > pendingStartFrame) {\n          // move -> right\n          for (let i = pendingStartFrame; i < frame; i += 1) {\n            updatedFrameStatus[i] = null;\n          }\n          if (pendingEndFrame !== undefined) {\n            for (let i = pendingEndFrame; i < frame; i += 1) {\n              updatedFrameStatus[i] = pendingEndFrame - 1;\n            }\n          }\n        } else if (frame < pendingStartFrame) {\n          // move -> left\n          if (pendingEndFrame !== undefined) {\n            for (let i = frame; i < pendingEndFrame; i += 1) {\n              updatedFrameStatus[i] = null;\n            }\n          }\n          for (let i = frame; i < pendingStartFrame; i += 1) {\n            updatedFrameStatus[i] = pendingStartFrame;\n          }\n        }\n      } else if (pendingEndFrame !== undefined) {\n        if (frame > pendingEndFrame) {\n          // move -> right\n          for (let i = pendingEndFrame; i < frame; i += 1) {\n            updatedFrameStatus[i] = pendingEndFrame - 1;\n          }\n        } else if (frame < pendingEndFrame) {\n          // move -> left\n          for (let i = frame; i < pendingEndFrame; i += 1) {\n            updatedFrameStatus[i] = null;\n          }\n        }\n      }\n      if (Object.keys(updatedFrameStatus).length > 0) {\n        this.emit(EventAction.FRAME_STATUS_CHANGED, updatedFrameStatus, this._hoveredItemIndex);\n      }\n    }\n    this._pendingEditing = false;\n    this._pendingCursorOffset = -1;\n    if (this._isScrollXDown) {\n      this._isScrollXDown = false;\n      this._scrollXDownBaseOffsetFrame = 0;\n      this._scrollXDownClientX = 0;\n    }\n    if (this._isScrollYDown) {\n      this._isScrollYDown = false;\n      this._scrollYDownItemsOffset = 0;\n      this._scrollYDownClientY = 0;\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}