{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport { message } from 'antd';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape, calcShapeArea } from '../utils';\nimport { ReviewResult } from '../types';\nimport { BorderStyle } from '../../common/shapes/Shape';\nimport Rectangle from '../../common/shapes/Rectangle';\nimport Dot from '../../common/shapes/Dot';\nimport { SelectedStyle } from '../../common/shapes/canvas/GridContainer';\n\n/**\n * store for grid view\n * @class\n */\nexport default class GridStore {\n  /**\n   * grid size\n   * @getter\n   */\n  get gridSize() {\n    return this.gridSizes[this.gridSizeIndex];\n  }\n\n  /**\n   * grids\n   * @getter\n   */\n  get grids() {\n    const {\n      frames,\n      currentFrame,\n      currentCamera\n    } = this.rootStore.frame;\n    const {\n      isMultiSelected,\n      selectedInstances,\n      selectedInstanceItems\n    } = this.rootStore.instance;\n    const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n    const selectedInstanceItem = !isMultiSelected ? selectedInstanceItems[0] : undefined;\n    return frames.map((frame, index) => {\n      let borderColor = 0x1A1B1E;\n      let selectedStyle = SelectedStyle.LINE;\n      if ((selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.frameStatus[index]) !== undefined) {\n        borderColor = 0xA4A9BB;\n        selectedStyle = SelectedStyle.FILL;\n        if (selectedInstanceItem) {\n          const reviewResult = this.rootStore.review.getReviewForInstanceItem(selectedInstanceItem, currentCamera, index);\n          if (reviewResult) {\n            selectedStyle = SelectedStyle.LINE;\n            if (reviewResult === ReviewResult.APPROVE) {\n              borderColor = 0x3A5F54;\n            } else if (reviewResult === ReviewResult.REJECT) {\n              borderColor = 0x7C433C;\n            } else if (reviewResult === ReviewResult.SUSPEND) {\n              borderColor = 0x897D2E;\n            }\n          }\n        }\n      }\n      return {\n        imageUrl: frame,\n        imageRotation: this.rootStore.frame.getFrameRotation(currentCamera, index),\n        title: `${index + 1}`,\n        borderColor,\n        selectedStyle,\n        defaultSelected: index === currentFrame,\n        ...((selectedInstanceItem === null || selectedInstanceItem === void 0 ? void 0 : selectedInstanceItem.frameStatus[index]) && {\n          info: i18n.translate('GRID_KEY_FRAME')\n        })\n      };\n    });\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * grid sizes array\n     */\n    this.gridSizes = [200, 300, 400, 600, 800];\n    /**\n     * grid size index\n     */\n    this.gridSizeIndex = 2;\n    /**\n     * grid canvas reference\n     */\n    this.gridCanvas = void 0;\n    /**\n     * add predicted shapes to instance\n     * @param instance\n     * @param camera\n     */\n    this.addShapesToInstance = (instance, camera = this.rootStore.frame.currentCamera) => {\n      if (this.gridCanvas) {\n        const {\n          currentFrame\n        } = this.rootStore.frame;\n        const grid = this.gridCanvas.getGrid(currentFrame);\n        if (grid) {\n          const instanceItems = [];\n          Object.values(instance.items).forEach(instanceItem => {\n            const cameraData = instanceItem.cameras[camera];\n            if (!cameraData || !cameraData.frames[currentFrame]) {\n              // not exist in current frame\n              const shapeInfo = instanceItem.predictShape(camera, currentFrame, grid.imageBounds, true);\n              if (shapeInfo) {\n                const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n                if (area < this.rootStore.config.minArea) {\n                  return;\n                }\n                instanceItems.push({\n                  instanceItem,\n                  frameIndex: currentFrame,\n                  order: this.rootStore.frame.getNextShapeOrder(currentFrame, camera),\n                  camera,\n                  ...shapeInfo\n                });\n              }\n            }\n          });\n          if (instanceItems.length > 0) {\n            this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n            this.rootStore.instance.selectInstanceItem(null);\n            this.rootStore.instance.selectInstance(instance);\n            this.rootStore.instance.autoOpenAttributesModal();\n          }\n        }\n      }\n    };\n    /**\n     * update shapes interactive\n     * @param interactive\n     * @param ignoreIds\n     */\n    this.updateShapesInteractive = (interactive, ignoreIds) => {\n      if (this.gridCanvas) {\n        const {\n          isSingleSelected,\n          selectedInstanceItems\n        } = this.rootStore.instance;\n        const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            if (ignoreIds && ignoreIds.includes(shape.uid)) {\n              return;\n            }\n            shape.interactive = interactive;\n            if (interactive && shape.data === selectedInstanceItem) {\n              shape.selected = true;\n            }\n          });\n        });\n      }\n    };\n    /**\n     * move shape up\n     * @param toTop\n     */\n    this.moveFront = (toTop = false) => {\n      if (this.gridCanvas && this.rootStore.instance.isSingleSelected) {\n        const shapes = this.gridCanvas.getGridShapes(this.rootStore.frame.currentFrame);\n        const selectedShape = shapes.find(s => s.selected);\n        if (selectedShape) {\n          if (toTop) {\n            this.rootStore.shape.moveToTop(selectedShape.data);\n            return;\n          }\n          const intersections = selectedShape.findIntersections(shapes);\n          if (intersections.length > 0) {\n            const upperShape = getUpperShape(selectedShape, intersections);\n            if (upperShape) {\n              this.exchangeShapeOrder(selectedShape, upperShape);\n              message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n            } else {\n              message.warning(i18n.translate('ORDER_FRONT_MOST'));\n            }\n          } else {\n            message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n          }\n        }\n      }\n    };\n    /**\n     * move shape down\n     * @param toBottom\n     */\n    this.moveBack = (toBottom = false) => {\n      if (this.gridCanvas && this.rootStore.instance.isSingleSelected) {\n        const shapes = this.gridCanvas.getGridShapes(this.rootStore.frame.currentFrame);\n        const selectedShape = shapes.find(s => s.selected);\n        if (selectedShape) {\n          if (toBottom) {\n            this.rootStore.shape.moveToBottom(selectedShape.data);\n            return;\n          }\n          const intersections = selectedShape.findIntersections(shapes);\n          if (intersections.length > 0) {\n            const underShape = getUnderShape(selectedShape, intersections);\n            if (underShape) {\n              this.exchangeShapeOrder(selectedShape, underShape);\n              message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n            } else {\n              message.warning(i18n.translate('ORDER_BACK_MOST'));\n            }\n          } else {\n            message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n          }\n        }\n      }\n    };\n    this.updateShapesFill = fill => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            shape.alpha = fill ? this.rootStore.shape.config.alpha / 100 : 0;\n          });\n        });\n      }\n    };\n    this.updateShapesAlpha = alpha => {\n      if (this.gridCanvas && this.rootStore.shape.config.fill) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            shape.alpha = alpha;\n          });\n        });\n      }\n    };\n    this.updateShapesToleranceFill = fill => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            if (shape instanceof Rectangle) {\n              shape.toleranceAlpha = fill ? this.rootStore.shape.config.toleranceAlpha / 100 : 0;\n            }\n          });\n        });\n      }\n    };\n    this.updateShapesToleranceAlpha = alpha => {\n      if (this.gridCanvas && this.rootStore.shape.config.toleranceFill) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            if (shape instanceof Rectangle) {\n              shape.toleranceAlpha = alpha;\n            }\n          });\n        });\n      }\n    };\n    this.updateShapesBorderAlpha = borderAlpha => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            shape.borderAlpha = borderAlpha;\n          });\n        });\n      }\n    };\n    this.updateShapesBorderWidth = borderWidth => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            shape.borderWidth = borderWidth;\n          });\n        });\n      }\n    };\n    this.updateDotsRadius = dotRadius => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            if (shape instanceof Dot) {\n              shape.dotRadius = dotRadius;\n            }\n          });\n        });\n      }\n    };\n    this.updateShowVertex = showVertex => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            shape.showVertex = showVertex;\n          });\n        });\n      }\n    };\n    this.updateShowVertexOrder = showVertexOrder => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            shape.showVertexOrder = showVertexOrder;\n          });\n        });\n      }\n    };\n    this.updateVertexSize = vertexSize => {\n      if (this.gridCanvas) {\n        Object.values(this.gridCanvas.cachedGrids).forEach(grid => {\n          grid.shapes.forEach(shape => {\n            shape.vertexSize = vertexSize;\n          });\n        });\n      }\n    };\n    makeAutoObservable(this, {\n      rootStore: false,\n      gridSizes: false,\n      gridCanvas: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * set grid size index\n   * @param sizeIndex\n   */\n  setGridSizeIndex(sizeIndex) {\n    this.gridSizeIndex = sizeIndex;\n  }\n\n  /**\n   * get selected shape in current grid\n   */\n  getCurrentSelectedShape() {\n    var _this$gridCanvas;\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const shapes = ((_this$gridCanvas = this.gridCanvas) === null || _this$gridCanvas === void 0 ? void 0 : _this$gridCanvas.getGridShapes(currentFrame)) || [];\n    const selectedShape = shapes.find(s => s.selected && s.borderStyle !== BorderStyle.DASHED);\n    return selectedShape;\n  }\n\n  /**\n   * get drawing shape in current grid\n   */\n  getCurrentDrawingShape() {\n    var _this$gridCanvas2;\n    const {\n      currentFrame\n    } = this.rootStore.frame;\n    const shapes = ((_this$gridCanvas2 = this.gridCanvas) === null || _this$gridCanvas2 === void 0 ? void 0 : _this$gridCanvas2.getGridShapes(currentFrame)) || [];\n    const drawingShape = shapes.find(s => !s.finished);\n    return drawingShape;\n  }\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete() {\n    // currently, grid view only support single shape selected\n    const {\n      selectedInstanceItems\n    } = this.rootStore.instance;\n    if (this.gridCanvas && selectedInstanceItems.length === 1) {\n      const selectedShape = this.getCurrentSelectedShape();\n      if (selectedShape) {\n        const pointsDeleted = selectedShape.deleteSelectedPoints();\n        if (!pointsDeleted) {\n          this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItems[0], [this.rootStore.frame.currentFrame]);\n        }\n      }\n    }\n  }\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem(instanceItem, camera = this.rootStore.frame.currentCamera) {\n    if (this.gridCanvas) {\n      const {\n        currentFrame\n      } = this.rootStore.frame;\n      const grid = this.gridCanvas.getGrid(currentFrame);\n      if (grid) {\n        const shapeInfo = instanceItem.predictShape(camera, currentFrame, grid.imageBounds, true);\n        if (shapeInfo) {\n          const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n          if (area < this.rootStore.config.minArea) {\n            message.warning(i18n.translate('MIN_AREA_ALERT'));\n            return;\n          }\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, shapeInfo.shapeType, shapeInfo.shape, this.rootStore.frame.getNextShapeOrder(currentFrame, camera), camera);\n          this.rootStore.instance.selectInstanceItem(instanceItem);\n          this.rootStore.instance.autoOpenAttributesModal();\n        }\n      }\n    }\n  }\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA, shapeB) {\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const instanceItemA = shapeA.data;\n    const instanceItemB = shapeB.data;\n    const instanceInfo = instanceItemA.instance.getBasicInfo();\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      }]\n    });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      }]\n    });\n  }\n}","map":{"version":3,"names":["makeAutoObservable","message","i18n","getUnderShape","getUpperShape","calcShapeArea","ReviewResult","BorderStyle","Rectangle","Dot","SelectedStyle","GridStore","gridSize","gridSizes","gridSizeIndex","grids","frames","currentFrame","currentCamera","rootStore","frame","isMultiSelected","selectedInstances","selectedInstanceItems","instance","selectedInstance","undefined","selectedInstanceItem","map","index","borderColor","selectedStyle","LINE","frameStatus","FILL","reviewResult","review","getReviewForInstanceItem","APPROVE","REJECT","SUSPEND","imageUrl","imageRotation","getFrameRotation","title","defaultSelected","info","translate","constructor","gridCanvas","addShapesToInstance","camera","grid","getGrid","instanceItems","Object","values","items","forEach","instanceItem","cameraData","cameras","shapeInfo","predictShape","imageBounds","area","shapeType","shape","config","minArea","push","frameIndex","order","getNextShapeOrder","length","updateFrameShapeForInstanceItems","selectInstanceItem","selectInstance","autoOpenAttributesModal","updateShapesInteractive","interactive","ignoreIds","isSingleSelected","cachedGrids","shapes","includes","uid","data","selected","moveFront","toTop","getGridShapes","selectedShape","find","s","moveToTop","intersections","findIntersections","upperShape","exchangeShapeOrder","success","warning","moveBack","toBottom","moveToBottom","underShape","updateShapesFill","fill","alpha","updateShapesAlpha","updateShapesToleranceFill","toleranceAlpha","updateShapesToleranceAlpha","toleranceFill","updateShapesBorderAlpha","borderAlpha","updateShapesBorderWidth","borderWidth","updateDotsRadius","dotRadius","updateShowVertex","showVertex","updateShowVertexOrder","showVertexOrder","updateVertexSize","vertexSize","autoBind","setGridSizeIndex","sizeIndex","getCurrentSelectedShape","_this$gridCanvas","borderStyle","DASHED","getCurrentDrawingShape","_this$gridCanvas2","drawingShape","finished","delete","pointsDeleted","deleteSelectedPoints","deleteFramesFromInstanceItem","addShapeToInstanceItem","updateFrameShapeForInstanceItem","shapeA","shapeB","orderA","orderB","instanceItemA","instanceItemB","instanceInfo","getBasicInfo","storeId","undo","preserve","instances","children","toJSON","save"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/GridStore.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport { message } from 'antd';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape, calcShapeArea } from '../utils';\nimport { ReviewResult } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\nimport Shape, { BorderStyle } from '../../common/shapes/Shape';\nimport Rectangle from '../../common/shapes/Rectangle';\nimport Dot from '../../common/shapes/Dot';\nimport GridCanvas from '../../common/shapes/canvas/GridCanvas';\nimport { SelectedStyle } from '../../common/shapes/canvas/GridContainer';\n\n/**\n * store for grid view\n * @class\n */\nexport default class GridStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * grid sizes array\n   */\n  gridSizes = [200, 300, 400, 600, 800];\n\n  /**\n   * grid size index\n   */\n  gridSizeIndex = 2;\n\n  /**\n   * grid canvas reference\n   */\n  gridCanvas?: GridCanvas;\n\n  /**\n   * grid size\n   * @getter\n   */\n  get gridSize() {\n    return this.gridSizes[this.gridSizeIndex];\n  }\n\n  /**\n   * grids\n   * @getter\n   */\n  get grids() {\n    const { frames, currentFrame, currentCamera } = this.rootStore.frame;\n    const { isMultiSelected, selectedInstances, selectedInstanceItems } = this.rootStore.instance;\n    const selectedInstance = !isMultiSelected ? selectedInstances[0] : undefined;\n    const selectedInstanceItem = !isMultiSelected ? selectedInstanceItems[0] : undefined;\n    return frames.map((frame, index) => {\n      let borderColor = 0x1A1B1E;\n      let selectedStyle = SelectedStyle.LINE;\n\n      if (selectedInstance?.frameStatus[index] !== undefined) {\n        borderColor = 0xA4A9BB;\n        selectedStyle = SelectedStyle.FILL;\n        if (selectedInstanceItem) {\n          const reviewResult = this.rootStore.review.getReviewForInstanceItem(selectedInstanceItem, currentCamera, index);\n          if (reviewResult) {\n            selectedStyle = SelectedStyle.LINE;\n            if (reviewResult === ReviewResult.APPROVE) {\n              borderColor = 0x3A5F54;\n            } else if (reviewResult === ReviewResult.REJECT) {\n              borderColor = 0x7C433C;\n            } else if (reviewResult === ReviewResult.SUSPEND) {\n              borderColor = 0x897D2E;\n            }\n          }\n        }\n      }\n\n      return {\n        imageUrl: frame,\n        imageRotation: this.rootStore.frame.getFrameRotation(currentCamera, index),\n        title: `${index + 1}`,\n        borderColor,\n        selectedStyle,\n        defaultSelected: index === currentFrame,\n        ...selectedInstanceItem?.frameStatus[index] && { info: i18n.translate('GRID_KEY_FRAME') },\n      };\n    });\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      gridSizes: false,\n      gridCanvas: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * set grid size index\n   * @param sizeIndex\n   */\n  setGridSizeIndex(sizeIndex: number) {\n    this.gridSizeIndex = sizeIndex;\n  }\n\n  /**\n   * get selected shape in current grid\n   */\n  getCurrentSelectedShape() {\n    const { currentFrame } = this.rootStore.frame;\n    const shapes = this.gridCanvas?.getGridShapes(currentFrame) || [];\n    const selectedShape = shapes.find((s) => s.selected && s.borderStyle !== BorderStyle.DASHED);\n    return selectedShape;\n  }\n\n  /**\n   * get drawing shape in current grid\n   */\n  getCurrentDrawingShape() {\n    const { currentFrame } = this.rootStore.frame;\n    const shapes = this.gridCanvas?.getGridShapes(currentFrame) || [];\n    const drawingShape = shapes.find((s) => !s.finished);\n    return drawingShape;\n  }\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete() {\n    // currently, grid view only support single shape selected\n    const { selectedInstanceItems } = this.rootStore.instance;\n    if (this.gridCanvas && selectedInstanceItems.length === 1) {\n      const selectedShape = this.getCurrentSelectedShape();\n      if (selectedShape) {\n        const pointsDeleted = selectedShape.deleteSelectedPoints();\n        if (!pointsDeleted) {\n          this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItems[0], [this.rootStore.frame.currentFrame]);\n        }\n      }\n    }\n  }\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem(instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) {\n    if (this.gridCanvas) {\n      const { currentFrame } = this.rootStore.frame;\n\n      const grid = this.gridCanvas.getGrid(currentFrame);\n      if (grid) {\n        const shapeInfo = instanceItem.predictShape(camera, currentFrame, grid.imageBounds, true);\n        if (shapeInfo) {\n          const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n          if (area < this.rootStore.config.minArea) {\n            message.warning(i18n.translate('MIN_AREA_ALERT'));\n            return;\n          }\n          this.rootStore.instance.updateFrameShapeForInstanceItem(\n            instanceItem,\n            currentFrame,\n            shapeInfo.shapeType,\n            shapeInfo.shape,\n            this.rootStore.frame.getNextShapeOrder(currentFrame, camera),\n            camera,\n          );\n          this.rootStore.instance.selectInstanceItem(instanceItem);\n          this.rootStore.instance.autoOpenAttributesModal();\n        }\n      }\n    }\n  }\n\n  /**\n   * add predicted shapes to instance\n   * @param instance\n   * @param camera\n   */\n  addShapesToInstance = (instance: Instance, camera = this.rootStore.frame.currentCamera) => {\n    if (this.gridCanvas) {\n      const { currentFrame } = this.rootStore.frame;\n\n      const grid = this.gridCanvas.getGrid(currentFrame);\n      if (grid) {\n        const instanceItems: {\n          instanceItem: InstanceItem,\n          frameIndex: number,\n          shapeType: ShapeType,\n          shape: ShapeData,\n          order: number,\n          camera: string,\n        }[] = [];\n        Object.values(instance.items).forEach((instanceItem) => {\n          const cameraData = instanceItem.cameras[camera];\n          if (!cameraData || !cameraData.frames[currentFrame]) {\n            // not exist in current frame\n            const shapeInfo = instanceItem.predictShape(camera, currentFrame, grid.imageBounds, true);\n            if (shapeInfo) {\n              const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n              if (area < this.rootStore.config.minArea) {\n                return;\n              }\n              instanceItems.push({\n                instanceItem,\n                frameIndex: currentFrame,\n                order: this.rootStore.frame.getNextShapeOrder(currentFrame, camera),\n                camera,\n                ...shapeInfo,\n              });\n            }\n          }\n        });\n\n        if (instanceItems.length > 0) {\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.rootStore.instance.selectInstanceItem(null);\n          this.rootStore.instance.selectInstance(instance);\n          this.rootStore.instance.autoOpenAttributesModal();\n        }\n      }\n    }\n  };\n\n  /**\n   * update shapes interactive\n   * @param interactive\n   * @param ignoreIds\n   */\n  updateShapesInteractive = (interactive: boolean, ignoreIds?: string[]) => {\n    if (this.gridCanvas) {\n      const { isSingleSelected, selectedInstanceItems } = this.rootStore.instance;\n      const selectedInstanceItem = isSingleSelected ? selectedInstanceItems[0] : undefined;\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          if (ignoreIds && ignoreIds.includes(shape.uid)) {\n            return;\n          }\n          shape.interactive = interactive;\n          if (interactive && shape.data === selectedInstanceItem) {\n            shape.selected = true;\n          }\n        });\n      });\n    }\n  };\n\n  /**\n   * move shape up\n   * @param toTop\n   */\n  moveFront = (toTop = false) => {\n    if (this.gridCanvas && this.rootStore.instance.isSingleSelected) {\n      const shapes = this.gridCanvas.getGridShapes(this.rootStore.frame.currentFrame);\n      const selectedShape = shapes.find((s) => s.selected);\n      if (selectedShape) {\n        if (toTop) {\n          this.rootStore.shape.moveToTop(selectedShape.data);\n          return;\n        }\n        const intersections = selectedShape.findIntersections(shapes);\n        if (intersections.length > 0) {\n          const upperShape = getUpperShape(selectedShape, intersections);\n          if (upperShape) {\n            this.exchangeShapeOrder(selectedShape, upperShape);\n            message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_FRONT_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    }\n  };\n\n  /**\n   * move shape down\n   * @param toBottom\n   */\n  moveBack = (toBottom = false) => {\n    if (this.gridCanvas && this.rootStore.instance.isSingleSelected) {\n      const shapes = this.gridCanvas.getGridShapes(this.rootStore.frame.currentFrame);\n      const selectedShape = shapes.find((s) => s.selected);\n      if (selectedShape) {\n        if (toBottom) {\n          this.rootStore.shape.moveToBottom(selectedShape.data);\n          return;\n        }\n        const intersections = selectedShape.findIntersections(shapes);\n        if (intersections.length > 0) {\n          const underShape = getUnderShape(selectedShape, intersections);\n          if (underShape) {\n            this.exchangeShapeOrder(selectedShape, underShape);\n            message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_BACK_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    }\n  };\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA: Shape<ShapeData>, shapeB: Shape<ShapeData>) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const instanceItemA = shapeA.data;\n    const instanceItemB = shapeB.data;\n    const instanceInfo = instanceItemA.instance.getBasicInfo();\n\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      }],\n    });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      }],\n    });\n  }\n\n  updateShapesFill = (fill: boolean) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          shape.alpha = fill ? this.rootStore.shape.config.alpha / 100 : 0;\n        });\n      });\n    }\n  };\n\n  updateShapesAlpha = (alpha: number) => {\n    if (this.gridCanvas && this.rootStore.shape.config.fill) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          shape.alpha = alpha;\n        });\n      });\n    }\n  };\n\n  updateShapesToleranceFill = (fill: boolean) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          if (shape instanceof Rectangle) {\n            shape.toleranceAlpha = fill ? this.rootStore.shape.config.toleranceAlpha / 100 : 0;\n          }\n        });\n      });\n    }\n  };\n\n  updateShapesToleranceAlpha = (alpha: number) => {\n    if (this.gridCanvas && this.rootStore.shape.config.toleranceFill) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          if (shape instanceof Rectangle) {\n            shape.toleranceAlpha = alpha;\n          }\n        });\n      });\n    }\n  };\n\n  updateShapesBorderAlpha = (borderAlpha: number) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          shape.borderAlpha = borderAlpha;\n        });\n      });\n    }\n  };\n\n  updateShapesBorderWidth = (borderWidth: number) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          shape.borderWidth = borderWidth;\n        });\n      });\n    }\n  };\n\n  updateDotsRadius = (dotRadius: number) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          if (shape instanceof Dot) {\n            shape.dotRadius = dotRadius;\n          }\n        });\n      });\n    }\n  };\n\n  updateShowVertex = (showVertex: boolean) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          shape.showVertex = showVertex;\n        });\n      });\n    }\n  };\n\n  updateShowVertexOrder = (showVertexOrder: boolean) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          shape.showVertexOrder = showVertexOrder;\n        });\n      });\n    }\n  };\n\n  updateVertexSize = (vertexSize: number) => {\n    if (this.gridCanvas) {\n      Object.values(this.gridCanvas.cachedGrids).forEach((grid) => {\n        grid.shapes.forEach((shape) => {\n          shape.vertexSize = vertexSize;\n        });\n      });\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}