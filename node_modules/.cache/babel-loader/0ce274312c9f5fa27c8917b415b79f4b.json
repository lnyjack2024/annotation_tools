{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst DEFAULT_PORTS = {\n  'http:': '80',\n  'https:': '443'\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n * @param {string} src\n * @return {string} The URL's origin\n */\n\nvar _default = src => {\n  if (src && opaqueOriginSchemes.find(scheme => src.startsWith(scheme))) {\n    // The origin of the child document is an opaque origin and its\n    // serialization is \"null\"\n    // https://html.spec.whatwg.org/multipage/origin.html#origin\n    return 'null';\n  } // Note that if src is undefined, then srcdoc is being used instead of src\n  // and we can follow this same logic below to get the origin of the parent,\n  // which is the origin that we will need to use.\n\n  const location = document.location;\n  const regexResult = URL_REGEX.exec(src);\n  let protocol;\n  let hostname;\n  let port;\n  if (regexResult) {\n    // It's an absolute URL. Use the parsed info.\n    // regexResult[1] will be undefined if the URL starts with //\n    protocol = regexResult[1] ? regexResult[1] : location.protocol;\n    hostname = regexResult[2];\n    port = regexResult[4];\n  } else {\n    // It's a relative path. Use the current location's info.\n    protocol = location.protocol;\n    hostname = location.hostname;\n    port = location.port;\n  } // If the port is the default for the protocol, we don't want to add it to the origin string\n  // or it won't match the message's event.origin.\n\n  const portSuffix = port && port !== DEFAULT_PORTS[protocol] ? \":\".concat(port) : '';\n  return \"\".concat(protocol, \"//\").concat(hostname).concat(portSuffix);\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","DEFAULT_PORTS","URL_REGEX","opaqueOriginSchemes","_default","src","find","scheme","startsWith","location","document","regexResult","exec","protocol","hostname","port","portSuffix","concat","module"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/penpal/lib/getOriginFromSrc.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst DEFAULT_PORTS = {\n  'http:': '80',\n  'https:': '443'\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n * @param {string} src\n * @return {string} The URL's origin\n */\n\nvar _default = src => {\n  if (src && opaqueOriginSchemes.find(scheme => src.startsWith(scheme))) {\n    // The origin of the child document is an opaque origin and its\n    // serialization is \"null\"\n    // https://html.spec.whatwg.org/multipage/origin.html#origin\n    return 'null';\n  } // Note that if src is undefined, then srcdoc is being used instead of src\n  // and we can follow this same logic below to get the origin of the parent,\n  // which is the origin that we will need to use.\n\n\n  const location = document.location;\n  const regexResult = URL_REGEX.exec(src);\n  let protocol;\n  let hostname;\n  let port;\n\n  if (regexResult) {\n    // It's an absolute URL. Use the parsed info.\n    // regexResult[1] will be undefined if the URL starts with //\n    protocol = regexResult[1] ? regexResult[1] : location.protocol;\n    hostname = regexResult[2];\n    port = regexResult[4];\n  } else {\n    // It's a relative path. Use the current location's info.\n    protocol = location.protocol;\n    hostname = location.hostname;\n    port = location.port;\n  } // If the port is the default for the protocol, we don't want to add it to the origin string\n  // or it won't match the message's event.origin.\n\n\n  const portSuffix = port && port !== DEFAULT_PORTS[protocol] ? `:${port}` : '';\n  return `${protocol}//${hostname}${portSuffix}`;\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB,MAAMC,aAAa,GAAG;EACpB,OAAO,EAAE,IAAI;EACb,QAAQ,EAAE;AACZ,CAAC;AACD,MAAMC,SAAS,GAAG,mCAAmC;AACrD,MAAMC,mBAAmB,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC;AAC9C;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAGC,GAAG,IAAI;EACpB,IAAIA,GAAG,IAAIF,mBAAmB,CAACG,IAAI,CAACC,MAAM,IAAIF,GAAG,CAACG,UAAU,CAACD,MAAM,CAAC,CAAC,EAAE;IACrE;IACA;IACA;IACA,OAAO,MAAM;EACf,CAAC,CAAC;EACF;EACA;;EAGA,MAAME,QAAQ,GAAGC,QAAQ,CAACD,QAAQ;EAClC,MAAME,WAAW,GAAGT,SAAS,CAACU,IAAI,CAACP,GAAG,CAAC;EACvC,IAAIQ,QAAQ;EACZ,IAAIC,QAAQ;EACZ,IAAIC,IAAI;EAER,IAAIJ,WAAW,EAAE;IACf;IACA;IACAE,QAAQ,GAAGF,WAAW,CAAC,CAAC,CAAC,GAAGA,WAAW,CAAC,CAAC,CAAC,GAAGF,QAAQ,CAACI,QAAQ;IAC9DC,QAAQ,GAAGH,WAAW,CAAC,CAAC,CAAC;IACzBI,IAAI,GAAGJ,WAAW,CAAC,CAAC,CAAC;EACvB,CAAC,MAAM;IACL;IACAE,QAAQ,GAAGJ,QAAQ,CAACI,QAAQ;IAC5BC,QAAQ,GAAGL,QAAQ,CAACK,QAAQ;IAC5BC,IAAI,GAAGN,QAAQ,CAACM,IAAI;EACtB,CAAC,CAAC;EACF;;EAGA,MAAMC,UAAU,GAAGD,IAAI,IAAIA,IAAI,KAAKd,aAAa,CAACY,QAAQ,CAAC,OAAAI,MAAA,CAAOF,IAAI,IAAK,EAAE;EAC7E,UAAAE,MAAA,CAAUJ,QAAQ,QAAAI,MAAA,CAAKH,QAAQ,EAAAG,MAAA,CAAGD,UAAU;AAC9C,CAAC;AAEDlB,OAAO,CAACE,OAAO,GAAGI,QAAQ;AAC1Bc,MAAM,CAACpB,OAAO,GAAGA,OAAO,CAACE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script"}