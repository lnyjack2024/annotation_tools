{"ast":null,"code":"import _applyDecoratedDescriptor from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nvar _class,\n  _class2,\n  _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/components/Canvas.tsx\";\n/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable, computed, reaction } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport { debounce } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { Spin, Button } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool from '../tools/Tool';\nimport { AttributesMode } from '../store/SettingsStore';\nimport rootStore from '../store/RootStore';\nimport formatMessage from '../locales';\nimport { CategoryPathShape, LandmarkEditType, LabelStyle, PathStyles } from '../types';\nimport Cursor from '../../common/Cursor';\nimport { resetAttrLabelPosition, getValuesLabel, resizeLabel } from '../utils';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport './Canvas.scss';\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 12;\nexport const POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  KEYPOINT: 'keypoint',\n  PATH: 'path',\n  KEYPOINT_BOX: 'keypoint_box',\n  INSTANCE: 'instance',\n  GROUP: 'group',\n  RECTANGLE_POINT: 'rectangle_point',\n  RECTANGLE_PATH: 'rectangle_path',\n  RECTANGLE_GROUP: 'rectangle_group',\n  RECTANGLE: 'rectangle',\n  WARNGIN: 'warning'\n};\nvar LabelType = /*#__PURE__*/function (LabelType) {\n  LabelType[\"KEYPOINT\"] = \"keypoint\";\n  LabelType[\"OBJECT\"] = \"object\";\n  return LabelType;\n}(LabelType || {});\nlet Canvas = observer(_class = (_class2 = class Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    this.cursor = Cursor.DEFAULT;\n    this.canvas = React.createRef();\n    this.canvasContainer = React.createRef();\n    this.imageCanvas = void 0;\n    this.imageData = void 0;\n    this.raster = void 0;\n    this.rasterLayer = void 0;\n    this.gridLayer = void 0;\n    this.labelLayer = void 0;\n    this.attrLayer = void 0;\n    this.mainLayer = void 0;\n    this.warningLayer = void 0;\n    this.tool = void 0;\n    this.hits = void 0;\n    this.selectedHit = void 0;\n    this.warningBtn = void 0;\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    this.smoothPath = null;\n    this.shownLabel = null;\n    this.fillOpacity = 0.3;\n    this.resizeObserve = null;\n    this.catchZoom = void 0;\n    this.prevRaster = null;\n    this.resizeDebounced = void 0;\n    this.paperZoom = 1;\n    this.currentWarnings = [];\n    this.resize = (isWindow = false) => {\n      if (this.canvasContainer.current) {\n        // set view size\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n        const viewCenter = new Paper.Point({\n          x: viewWidth / 2,\n          y: viewHeight / 2\n        });\n        if (this.catchZoom) {\n          const {\n            center,\n            zoom\n          } = this.catchZoom;\n          if (isWindow) {\n            Paper.view.center = viewCenter;\n            this.catchZoom.center = viewCenter;\n          } else {\n            Paper.view.center = center;\n          }\n          Paper.view.zoom = zoom;\n        } else {\n          Paper.view.center = viewCenter;\n          Paper.view.zoom = 1;\n        }\n        if (this.imageCanvas && this.raster) {\n          // resize image\n          const {\n            width: imgWidth,\n            height: imgHeight\n          } = this.imageCanvas;\n          const viewRatio = viewWidth / viewHeight;\n          const imgRatio = imgWidth / imgHeight;\n          const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n          const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n          const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n          const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n          // apply matrix to all layers\n          Paper.project.layers.forEach(layer => {\n            layer.matrix = matrix;\n          });\n          // reset image center\n          this.raster.position = new Paper.Point({\n            x: imgWidth / 2,\n            y: imgHeight / 2\n          });\n          this.paperZoom = this.rasterLayer ? Paper.view.zoom * this.rasterLayer.matrix.scaling.x : Paper.view.zoom;\n        }\n        this.resizeContent();\n      }\n    };\n    this.resizeContent = () => {\n      if (this.resizeDebounced) {\n        this.resizeDebounced();\n      } else {\n        this.resizeDebounced = debounce(() => {\n          this.resizeGrid();\n          this.resizeShapes();\n          this.drawWarnings();\n        }, 50);\n      }\n    };\n    this.zoom = (event, zoom) => {\n      if (this.canvasContainer.current) {\n        const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n        const viewPosition = Paper.view.viewToProject(mousePosition);\n        const oldZoom = Paper.view.zoom;\n        const oldCenter = Paper.view.center;\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        let newZoom = event && event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n        newZoom = zoom || newZoom;\n        if (newZoom <= 1) {\n          Paper.view.center = new Paper.Point({\n            x: viewWidth / 2,\n            y: viewHeight / 2\n          });\n        }\n        newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n        if (newZoom !== Paper.view.zoom) {\n          Paper.view.zoom = newZoom;\n          const zoomScale = oldZoom / newZoom;\n          const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n          Paper.view.center = Paper.view.center.add(offset);\n        }\n        this.catchZoom = {\n          zoom: newZoom,\n          center: Paper.view.center\n        };\n        this.paperZoom = newZoom * this.rasterLayer.matrix.scaling.x;\n        this.resizeContent();\n      }\n    };\n    this.drag = center => {\n      this.catchZoom = this.catchZoom ? {\n        ...this.catchZoom,\n        center\n      } : {\n        zoom: Paper.view.zoom,\n        center\n      };\n    };\n    this.fitSelected = (instanceId, groupName) => {\n      var _this$getInstanceCont;\n      const groupBox = groupName ? this.getGroupContainerByGroupName(instanceId, groupName) : (_this$getInstanceCont = this.getInstanceContainerByInstaceId(instanceId)) === null || _this$getInstanceCont === void 0 ? void 0 : _this$getInstanceCont.children.find(g => g.data.type === SHAPE_TYPE.GROUP);\n      if (groupBox && this.mainLayer && this.canvasContainer.current) {\n        const {\n          center,\n          width,\n          height\n        } = groupBox.bounds;\n        if (width === 0 || height === 0) return;\n        const point = this.mainLayer.localToGlobal(center);\n        const {\n          width: viewWidth,\n          height: viewHeight\n        } = this.mainLayer.bounds;\n        let zoom = width / height > viewWidth / viewHeight ? viewWidth / width : viewHeight / height;\n        zoom = Math.min(18, Math.max(zoom, 1));\n        Paper.view.zoom = zoom;\n        Paper.view.center = point;\n        this.catchZoom = {\n          zoom,\n          center: point\n        };\n        this.paperZoom = this.rasterLayer ? zoom * this.rasterLayer.matrix.scaling.x : zoom;\n        this.resizeContent();\n      } else {\n        this.resize();\n      }\n    };\n    this.fitPoint = point => {\n      if (this.mainLayer) {\n        const center = this.mainLayer.localToGlobal(new Paper.Point(point.x, point.y));\n        Paper.view.center = center;\n        this.catchZoom = {\n          zoom: Paper.view.zoom,\n          center\n        };\n        this.resizeContent();\n      }\n    };\n    this.hitTest = event => {\n      var _this$tool;\n      if (this.mainLayer && !((_this$tool = this.tool) === null || _this$tool === void 0 ? void 0 : _this$tool.mouseDown)) {\n        var _hit;\n        let cursor = Cursor.DEFAULT;\n        const isDrawPoint = this.props.selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT;\n        if (this.canAddShape()) {\n          cursor = isDrawPoint ? Cursor.POINTER : Cursor.CROSSHAIR;\n        }\n        if (this.selectedHit) {\n          this.selectedHit.selected = false;\n        }\n        const hits = this.mainLayer.hitTestAll(event.point, {\n          fill: true,\n          selected: false,\n          handles: true,\n          stroke: true,\n          tolerance: 10 / this.paperZoom,\n          match: ht => {\n            if (ht && ht.item && (ht.item.data.type === undefined || ht.item.data.type === SHAPE_TYPE.KEYPOINT_BOX)) {\n              return false;\n            }\n            return true;\n          }\n        });\n        let hit;\n        for (let i = 0; i < hits.length; i += 1) {\n          const h = hits[i];\n          const {\n            type\n          } = h.item.data;\n          if (!type || type !== SHAPE_TYPE.INSTANCE && type !== SHAPE_TYPE.GROUP && type !== SHAPE_TYPE.KEYPOINT_BOX && type !== SHAPE_TYPE.RECTANGLE_GROUP && (type !== SHAPE_TYPE.PATH || type === SHAPE_TYPE.PATH && ['handle-in', 'handle-out'].includes(h.type))) {\n            // select point | rectangle | rectangle control | path handle\n            if (type === SHAPE_TYPE.RECTANGLE || type === SHAPE_TYPE.RECTANGLE_POINT || type === SHAPE_TYPE.RECTANGLE_PATH) {\n              if (i === 0 && !this.canAddShape()) {\n                hit = h;\n              }\n            } else {\n              hit = h;\n              if (type === SHAPE_TYPE.KEYPOINT) {\n                break;\n              }\n            }\n          }\n        }\n        if (((_hit = hit) === null || _hit === void 0 ? void 0 : _hit.item) && !event.event.ctrlKey) {\n          var _hit$item$data, _hit$item$data2, _hit$item$data3, _hit$item$data4, _hit$item$data5;\n          if (!this.isShapeInSelectedShapes((_hit$item$data = hit.item.data) === null || _hit$item$data === void 0 ? void 0 : _hit$item$data.instanceId, (_hit$item$data2 = hit.item.data) === null || _hit$item$data2 === void 0 ? void 0 : _hit$item$data2.groupName, (_hit$item$data3 = hit.item.data) === null || _hit$item$data3 === void 0 ? void 0 : _hit$item$data3.index) && ((_hit$item$data4 = hit.item.data) === null || _hit$item$data4 === void 0 ? void 0 : _hit$item$data4.index) !== this.props.selectedShapeStatus.id && ((_hit$item$data5 = hit.item.data) === null || _hit$item$data5 === void 0 ? void 0 : _hit$item$data5.id) !== this.props.selectedShapeStatus.id) {\n            this.selectedHit = hit.item;\n            hit.item.selected = true;\n          }\n          if (hit.item.data.cursor) {\n            cursor = hit.item.data.cursor;\n          } else {\n            cursor = Cursor.MOVE;\n          }\n          this.showShapeLabel(hit, event.point);\n        } else if (this.shownLabel) {\n          const {\n            point\n          } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, {\n            x: point[0],\n            y: point[1]\n          }, false);\n        }\n        this.hits = hit;\n        if (this.currentWarnings.length > 0) {\n          var _this$warningLayer;\n          this.warningBtn = (_this$warningLayer = this.warningLayer) === null || _this$warningLayer === void 0 ? void 0 : _this$warningLayer.hitTest(event.point);\n        }\n        if (this.smoothPath) {\n          this.smoothPath.fullySelected = true;\n        }\n        this.setCursor(cursor);\n      }\n    };\n    this.clearHits = () => {\n      this.hits = undefined;\n    };\n    this.updateGroupBox = (instanceId, category, groupName) => {\n      let boundRect = this.getShapeByGroup();\n      const {\n        selectedShapeStatus\n      } = this.props;\n      let isRemovebound = false;\n      if (instanceId && instanceId === selectedShapeStatus.instanceId && groupName === selectedShapeStatus.groupName) {\n        const {\n          ontology,\n          setting: {\n            pointSize,\n            lineWidth,\n            labelItems\n          }\n        } = rootStore;\n        const groupConntainer = this.getGroupContainerByGroupName(instanceId, groupName);\n        const points = groupConntainer && groupConntainer.children.filter(v => v.type === CategoryPathShape.CIRCLE).map(v => [v.position.x, v.position.y]);\n        if (points && points.length > 0) {\n          const xList = points.map(v => v[0]);\n          const yList = points.map(v => v[1]);\n          const minX = Math.min(...xList);\n          const maxX = Math.max(...xList);\n          const minY = Math.min(...yList);\n          const maxY = Math.max(...yList);\n          if (this.mainLayer) {\n            var _instance$children$fi, _groupInfo$label_conf;\n            const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n            if (boundRect) {\n              boundRect.remove();\n            }\n            const range = pointSize * 3 / zoom;\n            const fontSize = FONT_SIZE / this.paperZoom;\n            const strokeWitdth = lineWidth / zoom;\n            boundRect = new Paper.Shape.Rectangle({\n              point: [minX - range, minY - range],\n              size: [maxX - minX + 2 * range, maxY - minY + 2 * range],\n              strokeColor: new Paper.Color('#FFE600'),\n              strokeWidth: strokeWitdth\n            });\n            boundRect.data.type = SHAPE_TYPE.KEYPOINT_BOX;\n            this.mainLayer.addChild(boundRect);\n            const groupInfo = ontology.getGroupData(category, groupName);\n            const instance = this.props.getInstance(instanceId);\n            const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[this.props.currentFrame];\n            const attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf = groupInfo.label_config) === null || _groupInfo$label_conf === void 0 ? void 0 : _groupInfo$label_conf.fields, group === null || group === void 0 ? void 0 : group.attributes, labelItems);\n            const content = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''} ${(instance === null || instance === void 0 ? void 0 : instance.number) || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n            const labelGroup = this.getLabelByKey('', '', 'group_label');\n            const groupAttribute = this.getLabelByKey('', '', 'group_attributes');\n            labelGroup === null || labelGroup === void 0 ? void 0 : labelGroup.remove();\n            groupAttribute === null || groupAttribute === void 0 ? void 0 : groupAttribute.remove();\n            const x = minX - range;\n            const y = minY - range - strokeWitdth * 2;\n            const w = maxX - minX + 2 * range;\n            const h = maxY - minY + 2 * range;\n            this.addLabel(content, {\n              x,\n              y,\n              width: w,\n              height: h\n            }, {\n              instanceId: '',\n              category: '',\n              groupName: ''\n            }, 'group_label', true, SHAPE_TYPE.KEYPOINT_BOX);\n            this.addLabel(attrsLabel, {\n              x,\n              y: y - fontSize * 1.5,\n              width: w,\n              height: h\n            }, {\n              instanceId: '',\n              category: '',\n              groupName: ''\n            }, 'group_attributes', true, SHAPE_TYPE.KEYPOINT_BOX);\n          }\n        } else {\n          isRemovebound = true;\n        }\n      } else {\n        isRemovebound = true;\n      }\n      if (isRemovebound && boundRect) {\n        boundRect.remove();\n        this.removeLabel('', '', 'group_label');\n        this.removeLabel('', '', 'group_attributes');\n      }\n    };\n    makeObservable(this, {\n      cursor: observable,\n      setCursor: action\n    });\n    reaction(() => rootStore.review.qaWarnings, () => {\n      this.drawWarnings();\n    });\n\n    // change frame & undo & redo to update points\n    reaction(() => rootStore.shape.updatedShapes, () => {\n      this.updateShapes();\n      this.drawWarnings();\n    });\n  }\n  get activeTool() {\n    var _this$props$ontologyG;\n    let tool = '';\n    switch ((_this$props$ontologyG = this.props.ontologyGroup) === null || _this$props$ontologyG === void 0 ? void 0 : _this$props$ontologyG.type) {\n      case LandmarkEditType.KEYPOINT:\n        tool = CategoryPathShape.CIRCLE;\n        break;\n      case LandmarkEditType.RECTANGLE:\n        tool = CategoryPathShape.RECTANGLE;\n        break;\n      default:\n        break;\n    }\n    return tool;\n  }\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', e => e.preventDefault(), false);\n    }\n    if (this.canvasContainer.current) {\n      this.resizeObserve = new ResizeObserver(() => {\n        this.resize(true);\n      });\n      this.resizeObserve.observe(this.canvasContainer.current);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.image !== this.props.image) {\n      this.loadImage();\n    }\n\n    // default instances\n    if (JSON.stringify(prevProps.defaultInstances) !== JSON.stringify(this.props.defaultInstances)) {\n      const defaultInstances = Object.values(this.props.defaultInstances).filter(instance => instance && !prevProps.defaultInstances[instance.id]);\n      if (defaultInstances.length > 0) {\n        defaultInstances.forEach(instance => {\n          var _this$mainLayer;\n          const instanceContainer = new Paper.Group();\n          (_this$mainLayer = this.mainLayer) === null || _this$mainLayer === void 0 ? void 0 : _this$mainLayer.addChild(instanceContainer);\n          instanceContainer.data = {\n            instanceId: instance.id,\n            category: instance.category,\n            type: SHAPE_TYPE.INSTANCE\n          };\n          instance.children.forEach(group => {\n            const groupContainer = new Paper.Group();\n            groupContainer.data = {\n              groupName: group.name,\n              type: SHAPE_TYPE.GROUP,\n              instanceId: instance.id,\n              category: instance.category,\n              displayColor: instance.displayColor || POINT_COLOR\n            };\n            instanceContainer.addChild(groupContainer);\n          });\n        });\n      }\n    }\n    if (JSON.stringify(prevProps.updatedCategories) !== JSON.stringify(this.props.updatedCategories) && this.props.updatedCategories.length > 0) {\n      this.props.updatedCategories.forEach(({\n        pointCategory,\n        frameIndex,\n        instanceId,\n        groupName,\n        category\n      }) => {\n        if (frameIndex === this.props.currentFrame) {\n          const container = {\n            instanceId,\n            groupName,\n            category\n          };\n          const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n        }\n      });\n      this.props.onCategoriesUpdated();\n    }\n\n    // selected changes\n    const isSelectedChange = JSON.stringify(prevProps.selectedShapeStatus) !== JSON.stringify(this.props.selectedShapeStatus);\n    if (isSelectedChange) {\n      if (this.selectedPoints.length <= 0 || this.selectedRectangles.length <= 0) {\n        if (prevProps.selectedShapeStatus && prevProps.selectedShapeStatus.id !== undefined) {\n          const {\n            instanceId,\n            groupName,\n            id,\n            shapeType\n          } = prevProps.selectedShapeStatus;\n          if (!this.isShapeInSelectedShapes(instanceId, groupName, id)) {\n            if (shapeType === LandmarkEditType.KEYPOINT) {\n              this.setPointSelected(instanceId, groupName, id, false);\n            } else {\n              this.selectShape(instanceId, groupName, id, false);\n            }\n          }\n        }\n      }\n      const {\n        instanceId,\n        groupName,\n        id,\n        shapeType\n      } = this.props.selectedShapeStatus;\n      if (id !== undefined) {\n        this.setMultiShapesUnselected();\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          this.setPointSelected(instanceId, groupName, id, true);\n        } else {\n          this.selectShape(instanceId, groupName, id);\n        }\n      }\n    }\n    if ((prevProps.selectedShapeInfo || {}).pointCategory !== (this.props.selectedShapeInfo || {}).pointCategory) {\n      this.setSmooth(null);\n      if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n        this.setSelectedCurves();\n      }\n    }\n    if (this.props.selectedInstance && (isSelectedChange || JSON.stringify(this.props.selectedInstance) !== JSON.stringify(prevProps.selectedInstance))) {\n      const {\n        instanceId,\n        category,\n        groupName\n      } = this.props.selectedShapeStatus;\n      this.updateGroupBox(instanceId, category, groupName);\n    }\n  }\n  componentWillUnmount() {\n    if (this.resizeObserve) {\n      this.resizeObserve.disconnect();\n      this.resizeObserve = null;\n    }\n  }\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = true;\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = rootStore.setting.isGridVisible;\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n    this.attrLayer = new Paper.Layer();\n    this.attrLayer.applyMatrix = false;\n    this.attrLayer.visible = false;\n    this.warningLayer = new Paper.Layer();\n    this.warningLayer.applyMatrix = false;\n    this.warningLayer.visible = false;\n    Paper.view.onMouseMove = this.hitTest;\n  }\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n  loadImage() {\n    if (this.rasterLayer && this.props.image) {\n      this.rasterLayer.activate();\n      this.props.changeLoading(true);\n      if (this.raster) {\n        this.prevRaster = this.raster;\n      }\n      imageLoader(this.props.image, c => {\n        var _canvas$getContext;\n        const canvas = c;\n        this.imageCanvas = canvas;\n        this.imageData = (_canvas$getContext = canvas.getContext('2d')) === null || _canvas$getContext === void 0 ? void 0 : _canvas$getContext.getImageData(0, 0, canvas.width, canvas.height);\n        this.raster = new Paper.Raster(canvas);\n        this.raster.visible = false;\n        this.raster.onLoad = () => {\n          var _this$gridLayer, _this$gridLayer$child;\n          if (!((_this$gridLayer = this.gridLayer) === null || _this$gridLayer === void 0 ? void 0 : (_this$gridLayer$child = _this$gridLayer.children) === null || _this$gridLayer$child === void 0 ? void 0 : _this$gridLayer$child.length)) {\n            this.labelLayer.visible = rootStore.setting.labelMode;\n            this.mainLayer.visible = true;\n            this.warningLayer.visible = true;\n            this.attrLayer.visible = true;\n          }\n          this.addGrid(); // add grid to image\n          this.resize(); // resize to fit the container\n          // when onload, show all layers\n          this.raster.visible = true;\n          if (this.prevRaster) {\n            this.prevRaster.remove();\n          }\n          this.props.changeLoading(false);\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous'\n      });\n    }\n  }\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const {\n        brightness,\n        contrast,\n        saturation,\n        lightness,\n        hue,\n        rescale\n      } = rootStore.setting.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      this.gridLayer.removeChildren();\n      const {\n        width,\n        height\n      } = this.imageCanvas;\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({\n        length: rows\n      }).forEach((_, index) => {\n        var _this$gridLayer2;\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer2 = this.gridLayer) === null || _this$gridLayer2 === void 0 ? void 0 : _this$gridLayer2.addChild(path);\n      });\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({\n        length: cols\n      }).forEach((_, index) => {\n        var _this$gridLayer3;\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer3 = this.gridLayer) === null || _this$gridLayer3 === void 0 ? void 0 : _this$gridLayer3.addChild(path);\n      });\n    }\n  }\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach(path => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n  isShapeInSelectedShapes(instanceId, groupName, index) {\n    return this.selectedPoints.findIndex(p => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0 || this.selectedRectangles.findIndex(p => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0;\n  }\n  isPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const {\n      bounds: {\n        x,\n        y,\n        width,\n        height\n      }\n    } = this.rasterLayer;\n    return localPoint.x >= 0 && localPoint.x <= x + width && localPoint.y >= 0 && localPoint.y <= y + height;\n  }\n  getPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n     if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n  getInstanceContainerByInstaceId(instaceId) {\n    var _this$mainLayer2;\n    return (_this$mainLayer2 = this.mainLayer) === null || _this$mainLayer2 === void 0 ? void 0 : _this$mainLayer2.children.find(i => i.data.type === SHAPE_TYPE.INSTANCE && i.data.instanceId === instaceId);\n  }\n  getGroupContainerByGroupName(instaceId, groupName) {\n    const instance = this.getInstanceContainerByInstaceId(instaceId);\n    return instance === null || instance === void 0 ? void 0 : instance.children.find(g => g.data.type === SHAPE_TYPE.GROUP && g.data.groupName === groupName);\n  }\n  getShapeByKey(instaceId, groupName, key) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.RECTANGLE_GROUP && p.data.id === key || p.data.type === SHAPE_TYPE.KEYPOINT && p.data.index === key);\n  }\n  getLabelByKey(instanceId, groupName, key) {\n    var _this$labelLayer;\n    return (_this$labelLayer = this.labelLayer) === null || _this$labelLayer === void 0 ? void 0 : _this$labelLayer.children.find(l => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === key);\n  }\n  getAttrLabelByKey(instanceId, groupName, key) {\n    var _this$attrLayer;\n    return (_this$attrLayer = this.attrLayer) === null || _this$attrLayer === void 0 ? void 0 : _this$attrLayer.children.find(l => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === `attr-${key}`);\n  }\n  getShapeByGroup() {\n    var _this$mainLayer3;\n    return (_this$mainLayer3 = this.mainLayer) === null || _this$mainLayer3 === void 0 ? void 0 : _this$mainLayer3.children.find(l => l.data.type === SHAPE_TYPE.KEYPOINT_BOX);\n  }\n  getPathByCategory(instaceId, groupName, pointCategory) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.PATH && p.data.pointCategory === pointCategory);\n  }\n  getPathById(instaceId, groupName, pathId) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.PATH && p.data.id === pathId);\n  }\n  getPointsByCategory(instaceId, groupName, pointCategory) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.filter(p => p.data.type === SHAPE_TYPE.KEYPOINT && p.data.pointCategory === pointCategory);\n  }\n  canAddShape() {\n    if (this.props.isReview || this.props.readonly || !rootStore.review.drawMode) return false;\n    if (this.mainLayer && this.props.selectedShapeInfo) {\n      if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.RECTANGLE) {\n        if (this.props.ontologyGroup && this.props.ontologyGroup.count > 0) {\n          return this.props.annotatedPointOrShapeCount < this.props.ontologyGroup.count;\n        }\n      } else if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.KEYPOINT) {\n        const {\n          instanceId,\n          groupName,\n          id\n        } = this.props.selectedShapeStatus;\n        if (id === undefined || id < 0) return false;\n        const point = this.getShapeByKey(instanceId, groupName, id);\n        return !point;\n      }\n    }\n    return false;\n  }\n  containerAddPoint(groupData, point, pointCategory, index, isKeyPoint, visible = true, attributes) {\n    const {\n      instanceId,\n      groupName\n    } = groupData;\n    const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n    this.addKeypointShape(point, pointCategory, index, isKeyPoint, groupContainer, visible, attributes);\n  }\n  addKeypoint(point) {\n    if (this.mainLayer && this.props.selectedShapeInfo && this.props.selectedShapeStatus && this.props.selectedInstance) {\n      const {\n        id,\n        shapeType,\n        frameIndex\n      } = this.props.selectedShapeStatus;\n      const index = shapeType === LandmarkEditType.KEYPOINT && id || 0;\n      const {\n        x,\n        y\n      } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory,\n        isKeyPoint\n      } = this.props.selectedShapeInfo;\n      const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n      const groupData = {\n        instanceId,\n        groupName,\n        type: LandmarkEditType.KEYPOINT,\n        category: this.props.selectedInstance.category\n      };\n      this.containerAddPoint(groupData, newPoint, pointCategory, index, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n        const container = {\n          instanceId,\n          category,\n          groupName\n        };\n        otherPoints = this.updateCirclePath(pointCategory, true, container);\n      }\n      this.props.handleShapesChange([{\n        frameIndex,\n        instanceId,\n        category,\n        groupName,\n        index,\n        shapeType: LandmarkEditType.KEYPOINT,\n        shape: {\n          pointCategory,\n          isKeyPoint,\n          position: {\n            x,\n            y\n          },\n          visible: true // default is visible when point added\n        }\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyShape(); // move next\n    }\n  }\n  addKeypointShape(point, pointCategory, pointIndex, isKeyPoint, groupContainer, visible, attributes) {\n    if (!groupContainer) return;\n    const {\n      frameIndex\n    } = this.props.selectedShapeStatus;\n    const {\n      instanceId,\n      groupName,\n      category,\n      displayColor\n    } = groupContainer.data;\n    if (this.mainLayer) {\n      var _groupInfo$point_labe;\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : displayColor || POINT_COLOR;\n      const fillColor = visible ? pointColor : '#3d424d';\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: (rootStore.setting.pointSize + 1) / zoom,\n        fillColor,\n        strokeColor: '#ffffff',\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white'\n      });\n      pointCircle.data = {\n        frameIndex,\n        type: SHAPE_TYPE.KEYPOINT,\n        cursor: Cursor.MOVE,\n        pointCategory,\n        index: pointIndex,\n        isKeyPoint,\n        visible,\n        instanceId,\n        groupName,\n        category,\n        fillColor\n      };\n      groupContainer.addChild(pointCircle);\n\n      // add point to path\n      const groupData = rootStore.ontology.getGroupData(category, groupName);\n      const categoryData = groupData && groupData.categories && groupData.categories.find(v => v.name === pointCategory) || undefined;\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      const lineColor = (categoryData === null || categoryData === void 0 ? void 0 : categoryData.isConnect) === false ? new Paper.Color('rgba(0,0,0,0)') : new Paper.Color(displayColor || POINT_COLOR);\n      let index = -1;\n      if (path) {\n        const {\n          points,\n          isCircle\n        } = path.data;\n        if (!isCircle) {\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            for (let i = 0; i < points.length; i += 1) {\n              const p = points[i];\n              const nextP = points[i + 1];\n              if (pointIndex > p && nextP > pointIndex) {\n                // 2 => 1,3\n                index = i + 1;\n                break;\n              } else if (pointIndex < p && (!nextP || nextP > p || nextP < p && i !== 0)) {\n                // 9 => 10 || 10,18 || 10,5(end point)[not (end point)10,5]\n                index = i;\n                break;\n              }\n            }\n          } else {\n            index = path.data.points.findIndex(p => pointIndex < p);\n          }\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: rootStore.setting.lineWidth / zoom,\n          strokeColor: lineColor,\n          selectedColor: lineColor\n        });\n        path.data = {\n          type: SHAPE_TYPE.PATH,\n          pointCategory,\n          points: [pointIndex],\n          instanceId,\n          groupName,\n          id: `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`\n        };\n        groupContainer.addChild(path);\n      }\n      this.toggleCurves(path);\n      if (path === this.smoothPath) {\n        this.setSmooth(path);\n      }\n      if (groupData && groupData.lines) {\n        const lines = groupData.lines.filter(v => v.points.indexOf(pointIndex) >= 0);\n        const linesData = [];\n        lines.forEach(connectPoints => {\n          if (connectPoints) {\n            const {\n              points,\n              color\n            } = connectPoints;\n            const isSource = pointIndex === points[0];\n            const otherEnd = this.getShapeByKey(instanceId, groupName, isSource ? points[1] : points[0]);\n            const fromTo = `${points[0]}-${points[1]}`;\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              if (otherEnd) {\n                const {\n                  pointCategory: otherCategory\n                } = otherEnd.data;\n                const [startPoint, endPoint] = isSource ? [pointCircle, otherEnd] : [otherEnd, pointCircle];\n                const endSegment = new Paper.Segment(new Paper.Point(endPoint.position.x, endPoint.position.y));\n                const line = isSource ? path : this.getPathByCategory(instanceId, groupName, otherCategory !== pointCategory ? otherCategory : '');\n                if (line) {\n                  const sourceIndex = line.data.points.findIndex(p => points[0] === p);\n                  if (sourceIndex === 0) {\n                    line.insert(0, endSegment);\n                    line.data.points.unshift(points[1]);\n                  } else if (sourceIndex === line.data.points.length - 1) {\n                    line.add(endSegment);\n                    line.data.points.push(points[1]);\n                  }\n                  this.toggleCurves(line);\n                  if (!endPoint.data.lines) {\n                    endPoint.data.lines = [];\n                  }\n                  endPoint.data.lines.push({\n                    isSource: false,\n                    fromTo,\n                    pathId: line.data.id\n                  });\n                  startPoint.data.lines = [...(startPoint.data.lines || []), {\n                    isSource: true,\n                    fromTo,\n                    pathId: line.data.id\n                  }];\n                }\n              }\n            } else {\n              linesData.push({\n                isSource,\n                fromTo,\n                pathId: fromTo\n              });\n              if (otherEnd) {\n                const segments = isSource ? [segment, otherEnd.position] : [otherEnd.position, segment];\n                const line = new Paper.Path({\n                  segments,\n                  strokeWidth: rootStore.setting.lineWidth / zoom,\n                  strokeColor: color,\n                  selectedColor: color\n                });\n                line.data = {\n                  type: SHAPE_TYPE.PATH,\n                  pointCategory: fromTo,\n                  points,\n                  instanceId,\n                  groupName,\n                  id: fromTo\n                };\n                groupContainer.addChild(line);\n              }\n            }\n          }\n        });\n        if (rootStore.setting.pathStyle !== PathStyles.CURVES) {\n          pointCircle.data.lines = linesData;\n        }\n      }\n      path.sendToBack();\n      const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n      const label = `${visible ? 1 : 0}-${pointIndex}`;\n      let attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$point_labe = groupInfo.point_label_config) === null || _groupInfo$point_labe === void 0 ? void 0 : _groupInfo$point_labe.fields, attributes, rootStore.setting.labelItems);\n      attrsLabel = `${rootStore.setting.displayPointIndex ? `${pointIndex}` : ''}${rootStore.setting.displayPointIndex && attrsLabel ? ';' : ''}${attrsLabel}`;\n      this.addLabel(label, {\n        x: point.x,\n        y: point.y,\n        width: rootStore.setting.pointSize / zoom,\n        height: rootStore.setting.pointSize / zoom\n      }, {\n        instanceId,\n        category,\n        groupName\n      }, pointIndex, visible, SHAPE_TYPE.KEYPOINT, attrsLabel);\n    }\n  }\n  removePointShape(containerData, pointIndex) {\n    const {\n      instanceId,\n      groupName\n    } = containerData;\n    if (this.mainLayer) {\n      const point = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (point) {\n        const {\n          lines,\n          pointCategory\n        } = point.data;\n        point.remove();\n        // remove pointCategory path\n        const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n        if (path && !path.data.isCircle) {\n          const index = path.data.points.findIndex(p => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n        // remove group connect path\n        if (lines) {\n          lines.forEach(({\n            pathId,\n            fromTo,\n            isSource\n          }) => {\n            const line = this.getPathById(instanceId, groupName, pathId);\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              let index = line === null || line === void 0 ? void 0 : line.data.points.findIndex(p => p === pointIndex);\n              if (isSource && index < 0) {\n                index = line.data.points.findIndex(p => p === Number(fromTo.split('-')[1] || -1));\n              }\n              if (index >= 0) {\n                line.removeSegment(index);\n                line.data.points.splice(index, 1);\n                this.toggleCurves(line);\n              }\n            } else {\n              line === null || line === void 0 ? void 0 : line.remove();\n            }\n          });\n        }\n      }\n    }\n    this.removeLabel(instanceId, groupName, pointIndex);\n  }\n  resizeShapes() {\n    var _this$labelLayer2, _this$attrLayer2;\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      this.mainLayer.children.forEach(instance => {\n        if (instance.children && instance.children.length > 0) {\n          instance.children.forEach(group => {\n            if (group.children) {\n              group.children.forEach(path => {\n                if (path.data.type === SHAPE_TYPE.KEYPOINT) {\n                  path.set({\n                    radius: rootStore.setting.pointSize / this.paperZoom\n                  });\n                  path.strokeWidth = 1 / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.PATH) {\n                  path.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.RECTANGLE_GROUP && path.children) {\n                  path.children.forEach(shape => {\n                    if (shape.data.type === SHAPE_TYPE.RECTANGLE_POINT) {\n                      shape.set({\n                        radius: rootStore.setting.pointSize / 2 / this.paperZoom\n                      });\n                    } else if (shape.data.type === SHAPE_TYPE.RECTANGLE_PATH) {\n                      shape.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                    }\n                  });\n                }\n              });\n            }\n          });\n        } else if (instance.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          instance.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n        }\n      });\n    }\n    if (((_this$labelLayer2 = this.labelLayer) === null || _this$labelLayer2 === void 0 ? void 0 : _this$labelLayer2.children) && this.labelLayer.children.length > 0) {\n      this.labelLayer.children.forEach(label => {\n        const {\n          zoom: oldZoom,\n          width,\n          height,\n          point\n        } = label.data;\n        resizeLabel({\n          width,\n          height,\n          zoom: this.paperZoom,\n          fontSize: FONT_SIZE\n        }, oldZoom, point, label, 'label');\n      });\n    }\n    if (((_this$attrLayer2 = this.attrLayer) === null || _this$attrLayer2 === void 0 ? void 0 : _this$attrLayer2.children) && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach(label => {\n        const {\n          zoom: oldZoom,\n          width,\n          height,\n          point\n        } = label.data;\n        resizeLabel({\n          width,\n          height,\n          zoom: this.paperZoom,\n          fontSize: FONT_SIZE\n        }, oldZoom, point, label, 'attr');\n      });\n    }\n    const {\n      instanceId,\n      groupName,\n      id\n    } = this.props.selectedShapeStatus;\n    this.setPointSelected(instanceId, groupName, id, true);\n  }\n  cleanLayer() {\n    if (this.mainLayer) {\n      var _this$mainLayer$child;\n      (_this$mainLayer$child = this.mainLayer.children) === null || _this$mainLayer$child === void 0 ? void 0 : _this$mainLayer$child.forEach(container => {\n        if (container.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          container.remove();\n        } else {\n          var _container$children;\n          (_container$children = container.children) === null || _container$children === void 0 ? void 0 : _container$children.forEach(group => {\n            group === null || group === void 0 ? void 0 : group.removeChildren();\n          });\n        }\n      });\n    }\n    if (this.labelLayer) {\n      this.labelLayer.removeChildren();\n    }\n    if (this.attrLayer) {\n      this.attrLayer.removeChildren();\n    }\n    if (this.warningLayer) {\n      this.warningLayer.removeChildren();\n    }\n  }\n  addLabel(content, shape, groupInfo, key, visible, shapeType, attrsLabel) {\n    if (this.labelLayer) {\n      const {\n        instanceId,\n        groupName\n      } = groupInfo;\n      const fontSize = FONT_SIZE / this.paperZoom;\n      const label = new Paper.PointText({\n        content,\n        fontSize,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#000000',\n        shadowBlur: 2 / this.paperZoom,\n        shadowOffset: 2 / this.paperZoom\n      });\n      const width = label.bounds.width + fontSize / 2;\n      const height = label.bounds.height + fontSize / 2;\n      const labelRect = new Paper.Shape.Rectangle({\n        size: [width, height],\n        fillColor: rootStore.setting.labelBgColor\n      });\n      label.position.x = labelRect.bounds.width / 2;\n      label.position.y = labelRect.bounds.height / 2;\n      const labelGroup = new Paper.Group();\n      labelGroup.data = {\n        point: [shape.x, shape.y],\n        instanceId,\n        groupName,\n        key,\n        type: shapeType === SHAPE_TYPE.KEYPOINT ? LabelType.KEYPOINT : LabelType.OBJECT,\n        zoom: this.paperZoom,\n        height,\n        width\n      };\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        labelGroup.addChild(labelRect);\n      }\n      labelGroup.addChild(label);\n      this.labelLayer.addChild(labelGroup);\n      labelGroup.position.x = shape.x + labelRect.bounds.width / 2;\n      labelGroup.position.y = shape.y - labelRect.bounds.height / 2 - rootStore.setting.lineWidth / this.paperZoom;\n      if (shapeType !== SHAPE_TYPE.KEYPOINT_BOX && this.attrLayer) {\n        let center = {\n          x: shape.x,\n          y: shape.y\n        };\n        if (SHAPE_TYPE.RECTANGLE) {\n          center = {\n            x: shape.x + shape.width / 2,\n            y: shape.y + shape.height / 2\n          };\n        }\n        const arrtLabelGroup = labelGroup.clone();\n        arrtLabelGroup.data.key = `attr-${arrtLabelGroup.data.key}`;\n        arrtLabelGroup.data.point = [center.x, center.y];\n        arrtLabelGroup.children.slice(-1)[0].fillColor = new Paper.Color('#ffffff');\n        arrtLabelGroup.children.slice(-1)[0].content = '';\n        this.attrLayer.addChild(arrtLabelGroup);\n        if (attrsLabel) {\n          this.updateLabelContent(arrtLabelGroup, attrsLabel, shapeType);\n        } else {\n          arrtLabelGroup.visible = false;\n        }\n      }\n    }\n  }\n  updateLabel(instanceId, groupName, key, position, center) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [position.x, position.y];\n        label.position.x = position.x + label.bounds.width / 2;\n        label.position.y = position.y - label.bounds.height / 2;\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [center.x, center.y];\n        label.position.x = center.x;\n        label.position.y = center.y;\n      }\n    }\n  }\n  updateAttributeLabel(instanceId, category, groupName, key, attributes, instanceNum) {\n    const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n    let label = '';\n    if (typeof key === 'number') {\n      var _groupInfo$point_labe2;\n      label = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$point_labe2 = groupInfo.point_label_config) === null || _groupInfo$point_labe2 === void 0 ? void 0 : _groupInfo$point_labe2.fields, attributes, rootStore.setting.pointLabelItems);\n      label = `${rootStore.setting.displayPointIndex ? `${key}` : ''}${rootStore.setting.displayPointIndex && label ? ';' : ''}${label}`;\n    } else {\n      var _groupInfo$label_conf2;\n      const categoryLabel = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''}  ${instanceNum || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n      label = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf2 = groupInfo.label_config) === null || _groupInfo$label_conf2 === void 0 ? void 0 : _groupInfo$label_conf2.fields, attributes, rootStore.setting.labelItems);\n      label = `${rootStore.setting.displayCategory ? `${categoryLabel}` : ''}${rootStore.setting.displayCategory && label ? ';' : ''}${label}`;\n    }\n    const attrLayer = this.getAttrLabelByKey(instanceId, groupName, key);\n    if (attrLayer) {\n      if (label) {\n        this.updateLabelContent(attrLayer, label, SHAPE_TYPE.KEYPOINT);\n      } else {\n        attrLayer.visible = false;\n      }\n    }\n  }\n  updateLabelContent(label, content, shapeType) {\n    if (this.attrLayer && label) {\n      const zoom = Paper.view.zoom * this.attrLayer.matrix.scaling.x;\n      const labelText = label.children.slice(-1)[0];\n      labelText.content = content;\n      const {\n        width,\n        height\n      } = labelText.bounds;\n      const fontSize = FONT_SIZE / zoom;\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        label.children[0].size.height = height + fontSize / 2;\n        label.children[0].size.width = width + fontSize / 2;\n      }\n      label.data.width = label.children[0].bounds.width;\n      label.data.height = label.children[0].bounds.height;\n      label.data.zoom = this.paperZoom;\n      let visible = false;\n      if (shapeType === SHAPE_TYPE.KEYPOINT) {\n        visible = rootStore.setting.activePointAttributesMode === AttributesMode.ALWAYS;\n      } else if (SHAPE_TYPE.RECTANGLE) {\n        visible = rootStore.setting.activeAttributesMode === AttributesMode.ALWAYS;\n      }\n      if (visible) {\n        const {\n          point\n        } = label.data;\n        resetAttrLabelPosition(label, {\n          x: point[0],\n          y: point[1]\n        }, visible);\n      } else {\n        label.visible = false;\n      }\n    }\n  }\n  updatelabelVisible(activeMode, type = 'object') {\n    var _this$attrLayer3;\n    if (this.shownLabel) {\n      this.shownLabel.visible = false;\n      this.shownLabel = null;\n    }\n    if (((_this$attrLayer3 = this.attrLayer) === null || _this$attrLayer3 === void 0 ? void 0 : _this$attrLayer3.children) && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach(label => {\n        const {\n          type: labelType\n        } = label.data;\n        if (type === labelType) {\n          label.visible = activeMode === AttributesMode.ALWAYS;\n        }\n      });\n    }\n  }\n  removeLabel(instanceId, groupName, key) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n  updateShapes() {\n    const {\n      currentFrame\n    } = this.props;\n    const {\n      shape: {\n        updatedShapes\n      }\n    } = rootStore;\n    updatedShapes.forEach(updatedShape => {\n      if (updatedShape.frameIndex !== currentFrame) return;\n      switch (updatedShape.shapeType) {\n        case LandmarkEditType.KEYPOINT:\n          this.updatePoint(updatedShape);\n          break;\n        case LandmarkEditType.RECTANGLE:\n          this.updateRectangle(updatedShape);\n          break;\n        default:\n          break;\n      }\n    });\n    rootStore.shape.setUpdatedShapes([]);\n    const {\n      instanceId,\n      category,\n      groupName\n    } = this.props.selectedShapeStatus;\n    this.updateGroupBox(instanceId, category, groupName);\n  }\n  updateRectangle(updateShape) {\n    const {\n      instanceId,\n      groupName,\n      category,\n      id,\n      shape\n    } = updateShape;\n    if (id !== undefined) {\n      const rectangle = shape;\n      const currRectangle = this.getShapeByKey(instanceId, groupName, id);\n      if (currRectangle) {\n        // alreay exist, should update\n        if (rectangle === undefined) {\n          // delete\n          this.removeRectangle(instanceId, groupName, id);\n        } else if (rectangle.x) {\n          const {\n            x,\n            y,\n            width,\n            height,\n            displayColor\n          } = rectangle;\n          // update position\n          this.drawRectangle({\n            x,\n            y,\n            width,\n            height,\n            displayColor\n          }, {\n            instanceId,\n            category,\n            groupName\n          }, id);\n        }\n      } else if (rectangle) {\n        //  has been removed, should add\n        const {\n          x,\n          y,\n          width,\n          height,\n          displayColor\n        } = rectangle;\n        const path = new Paper.Path();\n        path.data.id = id;\n        path.add(new Paper.Point(x, y));\n        path.add(new Paper.Point(x + width, y));\n        path.add(new Paper.Point(x + width, y + height));\n        path.add(new Paper.Point(x, y + height));\n        path.closed = true;\n        this.addRectangle(path, {\n          instanceId,\n          groupName,\n          category,\n          shapeType: LandmarkEditType.RECTANGLE,\n          displayColor\n        }, false);\n      }\n    }\n  }\n  updatePoint(updateShape) {\n    const {\n      frameIndex,\n      instanceId,\n      groupName,\n      category,\n      index,\n      shape\n    } = updateShape;\n    if (index !== undefined) {\n      let updatedCategorie;\n      const point = shape;\n      const currPoint = this.getShapeByKey(instanceId, groupName, index);\n      if (currPoint) {\n        const currCategory = currPoint.data.pointCategory;\n        updatedCategorie = {\n          pointCategory: currCategory,\n          frameIndex,\n          instanceId,\n          groupName,\n          category\n        };\n        const groupData = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(groupData, index);\n        } else if (point.position && point.pointCategory) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          this.updatePath(currPoint, point.position);\n          // update visible\n          if (point.visible !== undefined && currPoint.data.visible !== point.visible) {\n            this.changeVisibleStyle(currPoint, index, groupData, point.visible);\n          }\n          if (rootStore.setting.activePointAttributesMode !== AttributesMode.HIDE) {\n            this.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const {\n          position,\n          pointCategory,\n          isKeyPoint,\n          visible,\n          attributes\n        } = point;\n        if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          updatedCategorie = {\n            pointCategory,\n            frameIndex,\n            instanceId,\n            groupName,\n            category\n          };\n          const groupData = {\n            instanceId,\n            groupName,\n            type: LandmarkEditType.KEYPOINT,\n            category\n          };\n          this.containerAddPoint(groupData, new Paper.Point(position.x, position.y), pointCategory, index, isKeyPoint, visible, attributes);\n        }\n      }\n      if (updatedCategorie) {\n        const {\n          pointCategory,\n          ...newContainer\n        } = updatedCategorie;\n        const categoryKey = `${frameIndex}_${newContainer.instanceId}_${newContainer.groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, newContainer);\n        }\n      }\n    }\n  }\n  updatePath(point, position) {\n    const {\n      instanceId,\n      groupName,\n      pointCategory,\n      index,\n      lines\n    } = point.data;\n    const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n    if (path && !path.data.isCircle) {\n      const segmentIndex = path.data.points.findIndex(p => p === index);\n      path.segments[segmentIndex].point.x = position.x;\n      path.segments[segmentIndex].point.y = position.y;\n      this.toggleCurves(path);\n    }\n    // change connect line position\n    if (lines) {\n      lines.forEach(({\n        isSource,\n        pathId\n      }) => {\n        const line = this.getPathById(instanceId, groupName, pathId);\n        if (line) {\n          let n = -1;\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            n = !isSource ? line.data.points.findIndex(p => p === index) : -1;\n          } else {\n            n = isSource ? 0 : 1;\n            if (!line.segments[n]) {\n              n = 0;\n            }\n          }\n          if (n >= 0) {\n            line.segments[n].point.x = position.x;\n            line.segments[n].point.y = position.y;\n            this.toggleCurves(line);\n          }\n        }\n      });\n    }\n    this.updateLabel(instanceId, groupName, index, position, position);\n  }\n  setPointSelected(instanceId, groupName, index, selected) {\n    var _this$mainLayer4;\n    if (((_this$mainLayer4 = this.mainLayer) === null || _this$mainLayer4 === void 0 ? void 0 : _this$mainLayer4.children) && this.mainLayer.children.length > 0) {\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      if (point) {\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          point.strokeWidth = 3 / zoom;\n          point.radius = (rootStore.setting.pointSize + 1) / zoom;\n        } else {\n          point.radius = rootStore.setting.pointSize / zoom;\n          point.strokeWidth = 1 / zoom;\n        }\n      }\n    }\n  }\n  setMultiShapesSelected(selectedShapes, type) {\n    if (selectedShapes.length > 0) {\n      const {\n        instanceId,\n        groupName\n      } = selectedShapes[0].data;\n      this.props.selectGroup(instanceId, groupName, false);\n      this.props.setSelectedShape(undefined);\n    }\n    if (type === CategoryPathShape.CIRCLE) {\n      this.selectedPoints = selectedShapes.sort((a, b) => a.data.index - b.data.index);\n      rootStore.shape.setMultiSelectedShape(this.selectedPoints.map(point => point.data.index));\n      this.selectedPoints.forEach(point => {\n        const pData = point.data;\n        this.setPointSelected(pData.instanceId, pData.groupName, pData.index, true);\n      });\n    } else {\n      this.selectedRectangles = selectedShapes;\n      this.selectedRectangles.forEach(rectangle => {\n        const rData = rectangle.data;\n        this.selectShape(rData.instanceId, rData.groupName, rData.id);\n      });\n    }\n  }\n  setMultiShapesUnselected() {\n    this.selectedPoints.forEach(point => {\n      const {\n        instanceId,\n        groupName,\n        index\n      } = point.data;\n      this.setPointSelected(instanceId, groupName, index, false);\n    });\n    this.selectedRectangles.forEach(rectangle => {\n      const {\n        instanceId,\n        groupName,\n        id\n      } = rectangle.data;\n      this.selectShape(instanceId, groupName, id, false);\n    });\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    rootStore.shape.setMultiSelectedShape([]);\n  }\n  updatePointsPosition(shapes) {\n    this.props.handleShapesChange(shapes);\n  }\n\n  // resize and drag, change label position\n  updateRectanglePosition(shapes) {\n    this.props.handleShapesChange(shapes);\n    if (this.labelLayer) {\n      shapes.forEach(({\n        instanceId,\n        groupName,\n        id,\n        shape\n      }) => {\n        if (id && shape && shape.x) {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = shape;\n          this.updateLabel(instanceId, groupName, id, {\n            x,\n            y\n          }, {\n            x: x + width / 2,\n            y: y + height / 2\n          });\n        }\n      });\n    }\n  }\n  deleteSelectedPoints() {\n    const updatedCategories = [];\n    const points = [];\n    (this.selectedPoints.length > 0 ? this.selectedPoints.map(p => ({\n      frameIndex: this.props.currentFrame,\n      instanceId: p.data.instanceId,\n      category: p.data.category,\n      groupName: p.data.groupName,\n      index: p.data.index,\n      shapeType: LandmarkEditType.KEYPOINT\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.KEYPOINT\n    }]).forEach(selectedShapeStatus => {\n      let enable = true;\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        index\n      } = selectedShapeStatus;\n      const point = typeof index === 'number' && this.getShapeByKey(instanceId, groupName, index);\n      if (point && point.data) {\n        const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${point.data.pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          const path = this.getPathByCategory(instanceId, groupName, point.data.pointCategory);\n          const instance = this.getInstanceContainerByInstaceId(instanceId);\n          if (instance && path && path.data.isCircle) {\n            const group = rootStore.ontology.getGroupData(instance.data.category, groupName);\n            const pointCategory = group && group.categories && group.categories.length && group.categories.find(c => c.name === point.data.pointCategory);\n            if (pointCategory) {\n              const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n              const pIndex1 = sortedKeys[0];\n              const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n              if (index !== pIndex1 && index !== pIndex2) {\n                enable = true;\n              }\n            }\n          }\n        }\n        if (enable) {\n          points.push({\n            ...selectedShapeStatus,\n            ...point.data\n          });\n        }\n      }\n    });\n    this.props.handleShapesRemove(points);\n    rootStore.handle.removeHandles(points);\n    points.forEach(({\n      frameIndex,\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const instance = this.getInstanceContainerByInstaceId(instanceId);\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      if (instance && point && !updatedCategories.includes(point.data.pointCategory)) {\n        updatedCategories.push({\n          pointCategory: point.data.pointCategory,\n          frameIndex,\n          instanceId,\n          groupName,\n          category: instance.data.category\n        });\n      }\n      this.removePointShape({\n        instanceId,\n        category,\n        groupName\n      }, index);\n    });\n    updatedCategories.forEach(({\n      frameIndex,\n      pointCategory,\n      ...container\n    }) => {\n      const categoryKey = `${frameIndex}_${container.instanceId}_${container.groupName}_${pointCategory}`;\n      this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n    });\n    this.selectedPoints = [];\n  }\n  deleteSelectedRectangle() {\n    const rectangles = (this.selectedRectangles.length > 0 ? this.selectedRectangles.map(rect => ({\n      frameIndex: rect.data.frameIndex,\n      instanceId: rect.data.instanceId,\n      category: rect.data.category,\n      groupName: rect.data.groupName,\n      id: rect.data.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      id: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    }]).filter(v => typeof v.id === 'string');\n    this.props.handleShapesRemove(rectangles);\n    rectangles.forEach(({\n      instanceId,\n      groupName,\n      id\n    }) => {\n      this.removeRectangle(instanceId, groupName, id);\n    });\n    this.selectedRectangles = [];\n  }\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ? this.selectedPoints.map(p => p.data) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id\n    }].filter(v => v.shapeType === LandmarkEditType.KEYPOINT);\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      this.changeVisibleStyle(point, index, {\n        instanceId,\n        category,\n        groupName,\n        displayColor: point.data.fillColor\n      }, !point.data.visible);\n    });\n    this.props.togglePointsVisibility(points);\n  }\n  changeVisibleStyle(point, index, groupData, visible) {\n    const {\n      instanceId,\n      groupName\n    } = groupData;\n    const labelGroup = this.getLabelByKey(instanceId, groupName, index);\n    if (point) {\n      let fillColor = point.data.isKeyPoint ? KEY_POINT_COLOR : (groupData === null || groupData === void 0 ? void 0 : groupData.displayColor) || POINT_COLOR;\n      let strokeColor = '#ffffff';\n      if (!visible) {\n        strokeColor = fillColor;\n        fillColor = '#3d424d';\n      }\n      point.data.visible = visible;\n      point.fillColor = new Paper.Color(fillColor);\n      point.strokeColor = new Paper.Color(strokeColor);\n    }\n    if (this.labelLayer && labelGroup) {\n      const label = labelGroup.children.length === 2 ? labelGroup.children[1] : labelGroup.children[0];\n      label.content = `${visible ? '1' : '0'}-${index}`;\n      label.fillColor = new Paper.Color(visible ? 'white' : 'red');\n    }\n  }\n  setCursor(cursor) {\n    this.cursor = cursor;\n  }\n  showShapeLabel(hits, point) {\n    var _label$children;\n    const {\n      activePointAttributesMode,\n      activeAttributesMode\n    } = rootStore.setting;\n    if (!activePointAttributesMode && !activeAttributesMode) return;\n    const localPoint = this.getPointInImage(Paper.view.projectToView(point));\n    const {\n      data\n    } = hits.item;\n    let label;\n    if (data.type === SHAPE_TYPE.KEYPOINT && activePointAttributesMode === AttributesMode.HOVER) {\n      label = this.getAttrLabelByKey(data.instanceId, data.groupName, data.index);\n    } else if ((data.type === SHAPE_TYPE.RECTANGLE || data.type === SHAPE_TYPE.RECTANGLE_PATH || data.type === SHAPE_TYPE.RECTANGLE_POINT) && hits.item.parent && activeAttributesMode === AttributesMode.HOVER) {\n      const {\n        instanceId,\n        groupName,\n        id\n      } = hits.item.parent.data;\n      label = this.getAttrLabelByKey(instanceId, groupName, id);\n    }\n    if (label && ((_label$children = label.children) === null || _label$children === void 0 ? void 0 : _label$children.slice(-1)[0]).content) {\n      if (this.shownLabel) {\n        if (JSON.stringify(label) !== JSON.stringify(this.shownLabel)) {\n          const {\n            point: position\n          } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, {\n            x: position[0],\n            y: position[1]\n          }, false);\n          this.shownLabel = label;\n        }\n      } else {\n        this.shownLabel = label;\n      }\n      this.shownLabel.visible = true;\n      this.shownLabel.position.x = localPoint.x + 50 / Paper.view.zoom;\n      this.shownLabel.position.y = localPoint.y + 50 / Paper.view.zoom;\n    }\n  }\n  getNewPointsByKeyPointRange(path, startKey, endKey, instanceId, groupName) {\n    const startPosition = this.getShapeByKey(instanceId, groupName, startKey).position;\n    const endPosition = this.getShapeByKey(instanceId, groupName, endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    let newPoints = {}; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints = {\n        ...newPoints,\n        [base + 1]: nextPoint\n      };\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n  getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData) {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = parentData;\n    const updatedShapes = [];\n    const indexs = Object.keys(newPoints).map(v => Number(v));\n    for (let index = 0; index < indexs.length; index += 1) {\n      const pointIndex = indexs[index];\n      const existingPoint = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (newPoints[pointIndex]) {\n        const {\n          x,\n          y\n        } = newPoints[pointIndex];\n        const pointInfo = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index: pointIndex,\n          shapeType: LandmarkEditType.KEYPOINT\n        };\n        if (existingPoint) {\n          if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n            // update position\n            existingPoint.position.x = x;\n            existingPoint.position.y = y;\n            this.updatePath(existingPoint, {\n              x,\n              y\n            });\n            updatedShapes.push({\n              ...pointInfo,\n              shape: {\n                position: {\n                  x,\n                  y\n                }\n              }\n            });\n          }\n        } else {\n          // add new point\n          const isKeyPoint = pointCategory.keys.includes(pointIndex);\n          const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n          this.addKeypointShape(new Paper.Point(x, y), pointCategory.name, pointIndex, isKeyPoint, groupContainer, true);\n          updatedShapes.push({\n            ...pointInfo,\n            shape: {\n              pointCategory: pointCategory.name,\n              isKeyPoint,\n              position: {\n                x,\n                y\n              },\n              visible: true\n            }\n          });\n        }\n      }\n    }\n    return updatedShapes;\n  }\n  autoAdjust(point = this.props.selectedShapeStatus) {\n    if (this.props.selectedShapeInfo) {\n      const {\n        id\n      } = point;\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory: categoryName\n      } = this.props.selectedShapeInfo;\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName); // pointCategory path\n      const pointCategory = this.props.categories.find(c => c.name === categoryName); // pointCategory definition\n      if (path && pointCategory && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex;\n        let nextKeyPointIndex;\n        const {\n          points = []\n        } = path.data;\n        const {\n          keys = []\n        } = pointCategory;\n        const keysWithTwoSides = [...(keys.includes(points[0]) ? [] : [points[0]]), ...keys, ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]])].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex(key => key > Number(id));\n        if (keyIndex < 0) {\n          // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex, instanceId, groupName);\n          const parentData = {\n            instanceId,\n            category,\n            groupName\n          };\n          const updatedShapes = this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData);\n          if (updatedShapes.length > 0) {\n            this.props.handleShapesChange(updatedShapes);\n          }\n        }\n      }\n    }\n  }\n  switchSmoothMode() {\n    if (this.props.selectedShapeInfo && rootStore.setting.pathStyle !== PathStyles.CURVES) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory: categoryName\n      } = this.props.selectedShapeInfo;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName);\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      if (path && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const pointCategory = this.props.categories.find(c => c.name === categoryName);\n          if (pointCategory) {\n            const keyPoints = pointCategory.keys.filter(k => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedShapes = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i], instanceId, groupName);\n              const parentData = {\n                instanceId,\n                category,\n                groupName\n              };\n              updatedShapes = [...updatedShapes, ...this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData)];\n            }\n            if (updatedShapes.length > 0) {\n              this.props.handleShapesChange(updatedShapes);\n            }\n          }\n          this.setSmooth(null);\n        } else {\n          // start\n          this.setSmooth(path);\n        }\n      }\n    }\n  }\n  setSmooth(smooth) {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach(seg => {\n        seg.clearHandles();\n      });\n    }\n    this.smoothPath = smooth;\n    if (this.smoothPath) {\n      this.smoothPath.smooth({\n        type: 'continuous'\n      });\n      this.smoothPath.fullySelected = true;\n    }\n  }\n  setSelectedCurves() {\n    if (this.props.selectedShapeInfo) {\n      const {\n        selectedShapeInfo\n      } = this.props;\n      const {\n        instanceId,\n        groupName,\n        pointCategory\n      } = selectedShapeInfo;\n      const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      this.toggleCurves(path);\n    }\n    const {\n      instanceId,\n      groupName,\n      id\n    } = this.props.selectedShapeStatus;\n    if (typeof id === 'number') {\n      const point = this.getShapeByKey(instanceId, groupName, id);\n      if (point) {\n        const {\n          data: {\n            lines = []\n          }\n        } = point;\n        lines.forEach(({\n          pathId\n        }) => {\n          const path = this.getPathById(instanceId, groupName, pathId);\n          this.toggleCurves(path);\n        });\n      }\n    }\n  }\n  toggleCurves(path) {\n    if (rootStore.setting.pathStyle === PathStyles.CURVES && path) {\n      const {\n        data: {\n          instanceId,\n          groupName,\n          id: pathId,\n          points\n        },\n        segments\n      } = path;\n      const {\n        currentFrame\n      } = this.props;\n      path.smooth({\n        type: 'continuous'\n      });\n      const map = {};\n      // points\n      points.forEach((pointIndex, i) => {\n        const segment = segments[i];\n        if (segment) {\n          const {\n            handleIn,\n            handleOut,\n            point\n          } = segment;\n          map[pointIndex] = {\n            frameIndex: currentFrame,\n            pathId,\n            instanceId,\n            groupName,\n            pointIndex,\n            handleIn: {\n              x: handleIn.x,\n              y: handleIn.y\n            },\n            handleOut: {\n              x: handleOut.x,\n              y: handleOut.y\n            },\n            pointPosition: {\n              x: point.x,\n              y: point.y\n            }\n          };\n        }\n      });\n      rootStore.handle.setPathHandles(currentFrame, pathId, map);\n    }\n  }\n  setCategoryAsCircle() {\n    if (this.props.selectedShapeInfo) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory\n      } = this.props.selectedShapeInfo;\n      if (pointCategory) {\n        const container = {\n          instanceId,\n          category,\n          groupName\n        };\n        const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, false, container);\n          this.props.setCategoryPathShape(categoryKey);\n        } else {\n          const updatedShapes = this.updateCirclePath(pointCategory, true, container);\n          this.props.setCategoryPathShape(categoryKey, CategoryPathShape.CIRCLE, updatedShapes);\n        }\n      }\n    }\n  }\n  updateCirclePath(categoryName, isCirclePath = true, container) {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = container;\n    const updatedShapes = [];\n    const path = this.getPathByCategory(instanceId, groupName, categoryName);\n    const categoryData = rootStore.ontology.getCategoryData(category, groupName, categoryName);\n    const lineColor = (categoryData === null || categoryData === void 0 ? void 0 : categoryData.isConnect) === false ? new Paper.Color('rgba(0,0,0,0)') : new Paper.Color((categoryData === null || categoryData === void 0 ? void 0 : categoryData.displayColor) || POINT_COLOR);\n    if (path && categoryData) {\n      const categoryPoints = this.getPointsByCategory(instanceId, groupName, categoryName);\n      if (categoryPoints) {\n        const sortedKeys = [...categoryData.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find(p => p.data.index === pIndex1);\n        const point2 = categoryPoints.find(p => p.data.index === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (point1 && point2) {\n          if (isCirclePath) {\n            // is a circle & key points all exist\n            const centerX = (point1.position.x + point2.position.x) / 2;\n            const centerY = (point1.position.y + point2.position.y) / 2;\n            const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n            const newPath = new Paper.CompoundPath({\n              children: [new Paper.Path.Circle({\n                center: [centerX, centerY],\n                radius\n              }), new Paper.Path.Line({\n                from: [point1.position.x, point1.position.y],\n                to: [point2.position.x, point2.position.y]\n              }), new Paper.Path.Line({\n                from: new Paper.Point(computeRotatedPosition({\n                  x: centerX,\n                  y: centerY\n                }, point1.position, Math.PI / 2)),\n                to: new Paper.Point(computeRotatedPosition({\n                  x: centerX,\n                  y: centerY\n                }, point1.position, -Math.PI / 2))\n              })],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor\n            });\n            newPath.data = {\n              ...path.data,\n              isCircle: true,\n              instanceId,\n              groupName\n            };\n            path.replaceWith(newPath);\n\n            // update all points in this pointCategory\n            const update = (index, position) => {\n              const existingPoint = this.getShapeByKey(instanceId, groupName, index);\n              const pointInfo = {\n                frameIndex: this.props.selectedShapeStatus.frameIndex,\n                instanceId,\n                category,\n                groupName,\n                index,\n                shapeType: LandmarkEditType.KEYPOINT\n              };\n              if (existingPoint) {\n                // update position\n                existingPoint.position.x = position.x;\n                existingPoint.position.y = position.y;\n                this.updatePath(existingPoint, position);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    position: {\n                      x: position.x,\n                      y: position.y\n                    }\n                  }\n                });\n              } else {\n                const isKeyPoint = categoryData.keys.includes(index);\n                const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n                this.addKeypointShape(new Paper.Point(position.x, position.y), categoryData.name, index, isKeyPoint, groupContainer, true);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    pointCategory: categoryData.name,\n                    isKeyPoint,\n                    position: {\n                      x: position.x,\n                      y: position.y\n                    },\n                    visible: true\n                  }\n                });\n              }\n            };\n            const [start, end] = categoryData.range;\n            for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n              const radians = Math.PI / (pIndex2 - pIndex1) * (i - pIndex1);\n              const position = computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point1.position, radians);\n              update(i, position);\n            }\n            for (let i = pIndex2 + 1; i <= end; i += 1) {\n              const radians = Math.PI / (end + 1 - pIndex2) * (i - pIndex2);\n              const position = computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point2.position, radians);\n              update(i, position);\n            }\n            for (let i = start; i < pIndex1; i += 1) {\n              const radians = Math.PI / (end + 1 - pIndex2) * (start - pIndex1);\n              const position = computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point1.position, radians);\n              update(i, position);\n            }\n          } else {\n            const points = [...categoryPoints].sort((a, b) => a.data.index - b.data.index);\n            const newPath = new Paper.Path({\n              segments: points.map(p => p.position),\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor\n            });\n            newPath.data = {\n              ...path.data,\n              isCircle: false,\n              points: points.map(p => p.data.index)\n            };\n            path.replaceWith(newPath);\n            this.toggleCurves(newPath);\n          }\n        }\n      }\n    }\n    return updatedShapes;\n  }\n  addRectangle(path, groupInfo, add = true) {\n    if (this.mainLayer) {\n      const {\n        displayColor,\n        instanceId,\n        category,\n        groupName\n      } = groupInfo;\n      const {\n        data: {\n          id\n        },\n        segments\n      } = path;\n      const rectData = {\n        x: segments[0].point.x,\n        y: segments[0].point.y,\n        width: segments[2].point.x - segments[0].point.x,\n        height: segments[2].point.y - segments[0].point.y,\n        displayColor\n      };\n      this.drawRectangle(rectData, {\n        instanceId,\n        category,\n        groupName\n      }, id);\n      if (add) {\n        this.props.setNextEmptyShape();\n      }\n    }\n  }\n  getAlphaColor(color, opacity = this.fillOpacity) {\n    return hexToRgba(color, opacity);\n  }\n  drawRectangle(rectData, groupData, id, visible = true) {\n    if (this.props.selectedShapeInfo && this.mainLayer) {\n      const {\n        x,\n        y,\n        width,\n        height,\n        displayColor\n      } = rectData;\n      const {\n        instanceId,\n        category,\n        groupName\n      } = groupData;\n      let instanceContainer = this.getInstanceContainerByInstaceId(instanceId);\n      let groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (!instanceContainer) {\n        var _this$mainLayer5;\n        instanceContainer = new Paper.Group();\n        instanceContainer.data = {\n          instanceId,\n          name: category,\n          type: SHAPE_TYPE.INSTANCE\n        };\n        (_this$mainLayer5 = this.mainLayer) === null || _this$mainLayer5 === void 0 ? void 0 : _this$mainLayer5.addChild(instanceContainer);\n      }\n      if (!instanceContainer || !groupContainer) {\n        groupContainer = new Paper.Group();\n        groupContainer.data = {\n          groupName,\n          category,\n          type: SHAPE_TYPE.GROUP,\n          instanceId\n        };\n        instanceContainer.addChild(groupContainer);\n      }\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      let rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox) {\n        rectangleBox.removeChildren();\n      } else {\n        rectangleBox = new Paper.Group();\n        rectangleBox.data = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          id,\n          groupName,\n          category,\n          type: SHAPE_TYPE.RECTANGLE_GROUP,\n          instanceId,\n          displayColor,\n          visible\n        };\n        groupContainer.addChild(rectangleBox);\n      }\n      const rectangle = new Paper.Shape.Rectangle({\n        point: [x, y],\n        size: [width, height],\n        fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n        strokeWidth: rootStore.setting.lineWidth / zoom\n      });\n      rectangle.data = {\n        parentShape: id,\n        cursor: Cursor.MOVE,\n        type: SHAPE_TYPE.RECTANGLE\n      };\n      rectangleBox.addChild(rectangle);\n      this.selectShape(instanceId, groupName, id, id === this.props.selectedShapeStatus.id);\n      if (this.labelLayer) {\n        var _instance$children$fi2, _groupInfo$label_conf3;\n        const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n        const instance = this.props.getInstance(instanceId);\n        const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi2 = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi2 === void 0 ? void 0 : _instance$children$fi2.frames[this.props.currentFrame];\n        const label = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''} ${(instance === null || instance === void 0 ? void 0 : instance.number) || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n        let attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf3 = groupInfo.label_config) === null || _groupInfo$label_conf3 === void 0 ? void 0 : _groupInfo$label_conf3.fields, group === null || group === void 0 ? void 0 : group.attributes, rootStore.setting.labelItems);\n        attrsLabel = `${rootStore.setting.displayCategory ? `${label};` : ''}${rootStore.setting.displayCategory && attrsLabel ? ';' : ''}${attrsLabel}`;\n        const labelGroup = this.getLabelByKey(instanceId, groupName, id);\n        if (labelGroup) {\n          this.updateLabel(instanceId, groupName, id, {\n            x,\n            y\n          }, {\n            x: x + width / 2,\n            y: y + height / 2\n          });\n        } else {\n          this.addLabel(label, {\n            x,\n            y,\n            width,\n            height\n          }, {\n            instanceId,\n            category,\n            groupName\n          }, id, visible, SHAPE_TYPE.RECTANGLE, attrsLabel);\n        }\n      }\n    }\n  }\n  removeRectangle(instanceId, groupName, id) {\n    const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n    if (rectangleBox) {\n      rectangleBox.removeChildren();\n      rectangleBox.remove();\n      this.removeLabel(instanceId, groupName, id);\n    }\n  }\n  selectShape(instanceId, groupName, id, selected = true) {\n    if (this.mainLayer) {\n      const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox && rectangleBox.children) {\n        const {\n          bounds: {\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            x,\n            y,\n            height,\n            width\n          }\n        } = rectangleBox.children[0];\n        const points = [topLeft, topRight, bottomRight, bottomLeft];\n        const {\n          displayColor\n        } = rectangleBox.data;\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          const radius = rootStore.setting.pointSize / 2 / zoom;\n          const newColor = new Paper.Color(displayColor || POINT_COLOR);\n          points.forEach((point, index) => {\n            const sourceSeg = new Paper.Segment(point);\n            const targetSeg = index + 1 >= points.length ? new Paper.Segment(points[0]) : new Paper.Segment(points[index + 1]);\n            const lineBar = new Paper.Path({\n              segments: [sourceSeg, targetSeg],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              fillColor: newColor,\n              strokeColor: newColor,\n              selectedColor: newColor\n            });\n            lineBar.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_PATH,\n              controlIndex: index\n            };\n            rectangleBox.addChild(lineBar);\n          });\n          points.forEach((point, index) => {\n            const control = new Paper.Shape.Circle(point, radius);\n            control.strokeColor = newColor;\n            control.strokeWidth = rootStore.setting.lineWidth / zoom;\n            control.fillColor = newColor;\n            control.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_POINT,\n              controlIndex: index,\n              displayColor\n            };\n            rectangleBox.addChild(control);\n          });\n        } else {\n          rectangleBox.removeChildren();\n          const rectangle = new Paper.Shape.Rectangle({\n            point: [x, y],\n            size: [width, height],\n            fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n            strokeWidth: rootStore.setting.lineWidth / zoom\n          });\n          rectangle.data = {\n            parentShape: id,\n            cursor: Cursor.MOVE,\n            type: SHAPE_TYPE.RECTANGLE\n          };\n          rectangleBox.addChild(rectangle);\n        }\n      }\n    }\n  }\n  drawWarnings() {\n    var _this$warningLayer2;\n    (_this$warningLayer2 = this.warningLayer) === null || _this$warningLayer2 === void 0 ? void 0 : _this$warningLayer2.removeChildren();\n    const {\n      qaWarnings: warnings\n    } = rootStore.review;\n    if (warnings.length > 0) {\n      this.currentWarnings = warnings.filter(warning => warning.frames[0] === this.props.currentFrame);\n      if (this.warningLayer) {\n        const strokeWitdth = 2 / this.paperZoom;\n        const warningIconSize = 8 / this.paperZoom;\n        this.currentWarnings.forEach(warning => {\n          const {\n            id,\n            groupName,\n            shapeIds,\n            data\n          } = warning;\n          if (!groupName || !shapeIds) {\n            // missing\n            if (data === null || data === void 0 ? void 0 : data.position) {\n              const warningIcon = new Paper.Shape.Circle({\n                center: data.position,\n                radius: warningIconSize,\n                fillColor: '#DD4924'\n              });\n              const text = new Paper.PointText({\n                content: '!',\n                fontSize: FONT_SIZE / this.paperZoom,\n                fontWeight: '700',\n                fillColor: 'white'\n              });\n              warningIcon.data = {\n                id\n              };\n              text.data = {\n                id\n              };\n              text.position.set(data.position);\n              const group = new Paper.Group();\n              group.addChild(warningIcon);\n              group.addChild(text);\n              this.warningLayer.addChild(group);\n            }\n            return;\n          }\n          const shapes = [];\n          shapeIds.forEach(shapeId => {\n            const shape = this.getShapeByKey(id, groupName, shapeId);\n            if (shape) {\n              shapes.push(shape);\n              if (shape.data.type !== SHAPE_TYPE.RECTANGLE_GROUP) {\n                const {\n                  x,\n                  y,\n                  width,\n                  height\n                } = shape.bounds;\n                const boundRect = new Paper.Shape.Rectangle({\n                  point: [x - strokeWitdth, y - strokeWitdth],\n                  size: [width + 2 * strokeWitdth, height + 2 * strokeWitdth],\n                  strokeColor: new Paper.Color('#DC4624'),\n                  strokeWidth: strokeWitdth\n                });\n                this.warningLayer.addChild(boundRect);\n              }\n            }\n          });\n          let position = [];\n          if (shapes.length > 1) {\n            const minXList = [];\n            const maxXList = [];\n            const minYList = [];\n            const maxYList = [];\n            shapes.forEach(({\n              bounds: {\n                x,\n                y,\n                width,\n                height\n              }\n            }) => {\n              minXList.push(x - strokeWitdth);\n              maxXList.push(x + width + strokeWitdth);\n              minYList.push(y - strokeWitdth);\n              maxYList.push(y + height + strokeWitdth);\n            });\n            const minX = Math.min(...minXList);\n            const maxX = Math.max(...maxXList);\n            const minY = Math.min(...minYList);\n            const maxY = Math.max(...maxYList);\n            const boundRect = new Paper.Shape.Rectangle({\n              point: [minX - 2 * strokeWitdth, minY - 2 * strokeWitdth],\n              size: [maxX - minX + 4 * strokeWitdth, maxY - minY + 4 * strokeWitdth],\n              strokeColor: new Paper.Color('#DC4624'),\n              strokeWidth: strokeWitdth\n            });\n            this.warningLayer.addChild(boundRect);\n            position = [minX - warningIconSize, minY - warningIconSize];\n          } else if (shapes.length === 1) {\n            position = [shapes[0].bounds.x - warningIconSize, shapes[0].bounds.y - warningIconSize];\n          }\n          if (shapes.length > 0) {\n            const warningIcon = new Paper.Shape.Circle({\n              center: new Paper.Point(position[0], position[1]),\n              radius: warningIconSize,\n              fillColor: '#DC4624'\n            });\n            const text = new Paper.PointText({\n              content: '!',\n              fontSize: FONT_SIZE / this.paperZoom,\n              fontWeight: '700',\n              fillColor: 'white'\n            });\n            warningIcon.data = {\n              instanceId: id,\n              groupName,\n              shapeIds\n            };\n            text.data = {\n              instanceId: id,\n              groupName,\n              shapeIds\n            };\n            text.position.x = position[0];\n            text.position.y = position[1];\n            this.warningLayer.addChild(warningIcon);\n            this.warningLayer.addChild(text);\n          }\n        });\n      }\n    }\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.canvasContainer,\n      className: \"canvas\",\n      style: {\n        cursor: this.cursor\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2306,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: this.canvas,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2311,\n        columnNumber: 9\n      }\n    }), this.props.isReview && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"layer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2313,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tip\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2314,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2315,\n        columnNumber: 15\n      }\n    }, formatMessage('ORIGINAL_DATA')), /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2316,\n        columnNumber: 15\n      }\n    }, formatMessage('REVIEW_TIP')), /*#__PURE__*/React.createElement(Button, {\n      className: \"close\",\n      onClick: this.props.setReview,\n      size: \"small\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2317,\n        columnNumber: 15\n      }\n    }, formatMessage('REVIEW_CLOSE', {\n      values: {\n        shortcut: 'Ctrl+V'\n      }\n    })))), this.props.loading && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"loading\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2324,\n        columnNumber: 11\n      }\n    }, !this.raster && /*#__PURE__*/React.createElement(Spin, {\n      indicator: /*#__PURE__*/React.createElement(LoadingOutlined, {\n        style: {\n          fontSize: 100,\n          color: '#00bad3'\n        },\n        spin: true,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2325,\n          columnNumber: 47\n        }\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2325,\n        columnNumber: 30\n      }\n    })));\n  }\n}, (_applyDecoratedDescriptor(_class2.prototype, \"activeTool\", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, \"activeTool\"), _class2.prototype)), _class2)) || _class;\nexport default Canvas;","map":{"version":3,"names":["React","observable","action","makeObservable","computed","reaction","observer","Paper","debounce","hexToRgba","imageLoader","ImageFilters","ResizeObserver","Spin","Button","LoadingOutlined","Tool","AttributesMode","rootStore","formatMessage","CategoryPathShape","LandmarkEditType","LabelStyle","PathStyles","Cursor","resetAttrLabelPosition","getValuesLabel","resizeLabel","computeRotatedPosition","ZOOM_MIN","ZOOM_MAX","GRID_GAP","GRID_LINE_WIDTH","FONT_SIZE","POINT_COLOR","KEY_POINT_COLOR","SHAPE_TYPE","KEYPOINT","PATH","KEYPOINT_BOX","INSTANCE","GROUP","RECTANGLE_POINT","RECTANGLE_PATH","RECTANGLE_GROUP","RECTANGLE","WARNGIN","LabelType","Canvas","_class","_class2","Component","constructor","props","cursor","DEFAULT","canvas","createRef","canvasContainer","imageCanvas","imageData","raster","rasterLayer","gridLayer","labelLayer","attrLayer","mainLayer","warningLayer","tool","hits","selectedHit","warningBtn","selectedPoints","selectedRectangles","smoothPath","shownLabel","fillOpacity","resizeObserve","catchZoom","prevRaster","resizeDebounced","paperZoom","currentWarnings","resize","isWindow","current","offsetWidth","viewWidth","offsetHeight","viewHeight","view","viewSize","Size","viewCenter","Point","x","y","center","zoom","width","imgWidth","height","imgHeight","viewRatio","imgRatio","scaleFactor","offsetX","offsetY","matrix","Matrix","translate","scale","project","layers","forEach","layer","position","scaling","resizeContent","resizeGrid","resizeShapes","drawWarnings","event","mousePosition","viewPosition","viewToProject","oldZoom","oldCenter","newZoom","deltaY","Math","max","min","zoomScale","offset","subtract","multiply","add","drag","fitSelected","instanceId","groupName","_this$getInstanceCont","groupBox","getGroupContainerByGroupName","getInstanceContainerByInstaceId","children","find","g","data","type","bounds","point","localToGlobal","fitPoint","hitTest","_this$tool","mouseDown","_hit","isDrawPoint","selectedShapeStatus","shapeType","canAddShape","POINTER","CROSSHAIR","selected","hitTestAll","fill","handles","stroke","tolerance","match","ht","item","undefined","hit","i","length","h","includes","ctrlKey","_hit$item$data","_hit$item$data2","_hit$item$data3","_hit$item$data4","_hit$item$data5","isShapeInSelectedShapes","index","id","MOVE","showShapeLabel","_this$warningLayer","fullySelected","setCursor","clearHits","updateGroupBox","category","boundRect","getShapeByGroup","isRemovebound","ontology","setting","pointSize","lineWidth","labelItems","groupConntainer","points","filter","v","CIRCLE","map","xList","yList","minX","maxX","minY","maxY","_instance$children$fi","_groupInfo$label_conf","remove","range","fontSize","strokeWitdth","Shape","Rectangle","size","strokeColor","Color","strokeWidth","addChild","groupInfo","getGroupData","instance","getInstance","group","name","frames","currentFrame","attrsLabel","label_config","fields","attributes","content","class_display_name","number","display_name","labelGroup","getLabelByKey","groupAttribute","w","addLabel","removeLabel","review","qaWarnings","shape","updatedShapes","updateShapes","activeTool","_this$props$ontologyG","ontologyGroup","componentDidMount","setup","setupLayers","setupTools","addEventListener","e","preventDefault","observe","componentDidUpdate","prevProps","image","loadImage","JSON","stringify","defaultInstances","Object","values","_this$mainLayer","instanceContainer","Group","groupContainer","displayColor","updatedCategories","pointCategory","frameIndex","container","categoryKey","updateCirclePath","categoryPathShapes","onCategoriesUpdated","isSelectedChange","setPointSelected","selectShape","setMultiShapesUnselected","selectedShapeInfo","setSmooth","pathStyle","CURVES","setSelectedCurves","selectedInstance","componentWillUnmount","disconnect","Layer","applyMatrix","visible","isGridVisible","onMouseMove","activate","changeLoading","c","_canvas$getContext","getContext","getImageData","Raster","onLoad","_this$gridLayer","_this$gridLayer$child","labelMode","addGrid","orientation","crossOrigin","updateFilters","brightness","contrast","saturation","lightness","hue","rescale","filters","BrightnessContrastPhotoshop","Rescale","HSLAdjustment","setImageData","removeChildren","rows","ceil","Array","from","_","_this$gridLayer2","path","Path","Line","to","dashed","cols","_this$gridLayer3","baseWidth","dashArray","findIndex","p","isPointInImage","localPoint","globalToLocal","getPointInImage","instaceId","_this$mainLayer2","getShapeByKey","key","_this$labelLayer","l","getAttrLabelByKey","_this$attrLayer","_this$mainLayer3","getPathByCategory","getPathById","pathId","getPointsByCategory","isReview","readonly","drawMode","count","annotatedPointOrShapeCount","containerAddPoint","groupData","isKeyPoint","addKeypointShape","addKeypoint","newPoint","otherPoints","handleShapesChange","setNextEmptyShape","pointIndex","_groupInfo$point_labe","pointColor","fillColor","pointCircle","Circle","radius","selectedColor","categoryData","categories","segment","Segment","lineColor","isConnect","isCircle","nextP","push","insert","splice","segments","toggleCurves","lines","indexOf","linesData","connectPoints","color","isSource","otherEnd","fromTo","otherCategory","startPoint","endPoint","endSegment","line","sourceIndex","unshift","sendToBack","label","point_label_config","displayPointIndex","removePointShape","containerData","removeSegment","Number","split","_this$labelLayer2","_this$attrLayer2","set","cleanLayer","_this$mainLayer$child","_container$children","PointText","shadowColor","shadowBlur","shadowOffset","labelRect","labelBgColor","OBJECT","labelStyle","arrtLabelGroup","clone","slice","updateLabelContent","updateLabel","updateAttributeLabel","instanceNum","_groupInfo$point_labe2","pointLabelItems","_groupInfo$label_conf2","categoryLabel","displayCategory","labelText","activePointAttributesMode","ALWAYS","activeAttributesMode","updatelabelVisible","activeMode","_this$attrLayer3","labelType","updatedShape","updatePoint","updateRectangle","setUpdatedShapes","updateShape","rectangle","currRectangle","removeRectangle","drawRectangle","closed","addRectangle","updatedCategorie","currPoint","currCategory","updatePath","changeVisibleStyle","HIDE","newContainer","segmentIndex","n","_this$mainLayer4","setMultiShapesSelected","selectedShapes","selectGroup","setSelectedShape","sort","a","b","setMultiSelectedShape","pData","rData","updatePointsPosition","shapes","updateRectanglePosition","deleteSelectedPoints","enable","sortedKeys","keys","pIndex1","pIndex2","handleShapesRemove","handle","removeHandles","deleteSelectedRectangle","rectangles","rect","toggleSelectedPointVisibility","togglePointsVisibility","_label$children","projectToView","HOVER","parent","getNewPointsByKeyPointRange","startKey","endKey","startPosition","endPosition","segmentLength","getOffsetOf","newPoints","base","basePoint","baseOffset","nextPoint","getPointAt","getUpdatedPointsByNewPoints","parentData","indexs","existingPoint","pointInfo","autoAdjust","categoryName","prevKeyPointIndex","nextKeyPointIndex","keysWithTwoSides","keyIndex","switchSmoothMode","keyPoints","k","smooth","seg","clearHandles","handleIn","handleOut","pointPosition","setPathHandles","setCategoryAsCircle","setCategoryPathShape","isCirclePath","getCategoryData","categoryPoints","point1","point2","centerX","centerY","sqrt","newPath","CompoundPath","PI","replaceWith","update","start","end","radians","rectData","getAlphaColor","opacity","_this$mainLayer5","rectangleBox","parentShape","_instance$children$fi2","_groupInfo$label_conf3","topLeft","topRight","bottomRight","bottomLeft","newColor","sourceSeg","targetSeg","lineBar","NS_RESIZE","EW_RESIZE","controlIndex","control","NWSE_RESIZE","NESW_RESIZE","_this$warningLayer2","warnings","warning","warningIconSize","shapeIds","warningIcon","text","fontWeight","shapeId","minXList","maxXList","minYList","maxYList","render","createElement","ref","className","style","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","onClick","setReview","shortcut","loading","indicator","spin","_applyDecoratedDescriptor","prototype","getOwnPropertyDescriptor"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/components/Canvas.tsx"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable, computed, reaction } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport { debounce } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { Spin, Button } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool, { ToolEventExtend, ToolProps } from '../tools/Tool';\nimport { OntologyChild } from '../store/OntologyStore';\nimport { AttributesMode } from '../store/SettingsStore';\nimport rootStore from '../store/RootStore';\nimport formatMessage from '../locales';\nimport {\n  Point, PointStatus, CategoryItem, CategoryPathShape,\n  Group, LandmarkEditType, ShapeInfo, GroupInfo, InstanceAct,\n  PointInfo, UpdatedShape, Rectangle, KeypointCategoryProps,\n  LabelStyle, PathStyles, Handle,\n} from '../types';\nimport Cursor from '../../common/Cursor';\nimport { resetAttrLabelPosition, getValuesLabel, resizeLabel } from '../utils';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport { IWarning } from '../../common/tabs-menu/Validator';\nimport './Canvas.scss';\n\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 12;\nexport const POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  KEYPOINT: 'keypoint',\n  PATH: 'path',\n  KEYPOINT_BOX: 'keypoint_box',\n  INSTANCE: 'instance',\n  GROUP: 'group',\n  RECTANGLE_POINT: 'rectangle_point',\n  RECTANGLE_PATH: 'rectangle_path',\n  RECTANGLE_GROUP: 'rectangle_group',\n  RECTANGLE: 'rectangle',\n  WARNGIN: 'warning'\n};\n\nenum LabelType {\n  KEYPOINT='keypoint',\n  OBJECT='object'\n}\n\ninterface Props {\n  image: string;\n  readonly: boolean;\n  loading: boolean;\n  currentFrame: number;\n  isReview: boolean;\n  categories: CategoryItem[];\n  updatedCategories: KeypointCategoryProps[];\n  defaultInstances: {[id: string]: InstanceAct};\n  selectedInstance?: InstanceAct;\n  selectedGroupName?: string;\n  ontologyGroup?: OntologyChild;\n  annotatedPointOrShapeCount: number;\n  selectedShapeStatus: ShapeInfo;\n  selectedShapeInfo: PointInfo | GroupInfo | null;\n  categoryPathShapes: {[categoryName: string]: CategoryPathShape};\n  changeLoading: (loading: boolean) => void;\n  selectGroup: (groupId: string, name: string, isFit?: boolean) => void;\n  setSelectedShape: (selectedIndex?: number | string, data?: Group) => void;\n  handleShapesChange: (shape: UpdatedShape[]) => void;\n  handleShapesRemove: (shape: UpdatedShape[]) => void;\n  togglePointsVisibility: (points: PointStatus[]) => void;\n  setNextEmptyShape: () => void;\n  onCategoriesUpdated: () => void;\n  editShapeForm: () => void;\n  editGroupForm: () => void;\n  onSave: () => void;\n  setCategoryPathShape: (categoryName: string, type?: CategoryPathShape, updatedShapes?: UpdatedShape[]) => void;\n  getInstance: (id: string) => InstanceAct | undefined;\n  handleUndo: () => void;\n  handleRedo: () => void;\n  setReview: () => void;\n  handleChangeDrawMode: (mode: boolean) => void;\n}\n\n@observer\nclass Canvas extends React.Component<Props> {\n  cursor = Cursor.DEFAULT;\n\n  canvas: React.RefObject<HTMLCanvasElement> = React.createRef();\n\n  canvasContainer: React.RefObject<HTMLDivElement> = React.createRef();\n\n  imageCanvas: HTMLCanvasElement | undefined;\n\n  imageData: ImageData | undefined;\n\n  raster: paper.Raster | undefined;\n\n  rasterLayer: paper.Layer | undefined;\n\n  gridLayer: paper.Layer | undefined;\n\n  labelLayer: paper.Layer | undefined;\n\n  attrLayer: paper.Layer | undefined;\n\n  mainLayer: paper.Layer | undefined;\n\n  warningLayer: paper.Layer | undefined;\n\n  tool: ToolProps | undefined;\n\n  hits: paper.HitResult | undefined;\n\n  selectedHit: paper.Item | undefined;\n\n  warningBtn: paper.HitResult | undefined;\n\n  selectedPoints: paper.Shape[] = [];\n\n  selectedRectangles: paper.Group[] = [];\n\n  smoothPath: paper.Path | null = null;\n\n  shownLabel: paper.Group | null = null;\n\n  fillOpacity = 0.3;\n\n  resizeObserve: ResizeObserver | null = null;\n\n  catchZoom: { zoom: number, center: paper.Point } | undefined;\n\n  prevRaster: paper.Raster | null = null;\n\n  resizeDebounced: any;\n\n  paperZoom = 1;\n\n  currentWarnings: IWarning[] = [];\n\n  constructor(props: Props) {\n    super(props);\n    makeObservable(this, {\n      cursor: observable,\n      setCursor: action,\n    });\n\n    reaction(\n      () => rootStore.review.qaWarnings,\n      () => {\n        this.drawWarnings();\n      },\n    );\n\n    // change frame & undo & redo to update points\n    reaction(\n      () => rootStore.shape.updatedShapes,\n      () => {\n        this.updateShapes();\n        this.drawWarnings();\n      },\n    );\n  }\n\n  @computed get activeTool() {\n    let tool = '';\n    switch (this.props.ontologyGroup?.type) {\n      case LandmarkEditType.KEYPOINT:\n        tool = CategoryPathShape.CIRCLE;\n        break;\n      case LandmarkEditType.RECTANGLE:\n        tool = CategoryPathShape.RECTANGLE;\n        break;\n      default:\n        break;\n    }\n    return tool;\n  }\n\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', (e) => e.preventDefault(), false);\n    }\n    if (this.canvasContainer.current) {\n      this.resizeObserve = new ResizeObserver(() => { this.resize(true); });\n      this.resizeObserve.observe(this.canvasContainer.current);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.image !== this.props.image) {\n      this.loadImage();\n    }\n\n    // default instances\n    if (JSON.stringify(prevProps.defaultInstances) !== JSON.stringify(this.props.defaultInstances)) {\n      const defaultInstances = Object.values(this.props.defaultInstances).filter((instance) => instance && !prevProps.defaultInstances[instance.id]);\n      if (defaultInstances.length > 0) {\n        defaultInstances.forEach((instance) => {\n          const instanceContainer = new Paper.Group();\n          this.mainLayer?.addChild(instanceContainer);\n          instanceContainer.data = {\n            instanceId: instance.id,\n            category: instance.category,\n            type: SHAPE_TYPE.INSTANCE,\n          };\n          instance.children.forEach((group) => {\n            const groupContainer = new Paper.Group();\n            groupContainer.data = {\n              groupName: group.name,\n              type: SHAPE_TYPE.GROUP,\n              instanceId: instance.id,\n              category: instance.category,\n              displayColor: instance.displayColor || POINT_COLOR,\n            };\n            instanceContainer.addChild(groupContainer);\n          });\n        });\n      }\n    }\n\n    if (\n      JSON.stringify(prevProps.updatedCategories) !== JSON.stringify(this.props.updatedCategories) &&\n      this.props.updatedCategories.length > 0\n    ) {\n      this.props.updatedCategories.forEach(({ pointCategory, frameIndex, instanceId, groupName, category }) => {\n        if (frameIndex === this.props.currentFrame) {\n          const container = { instanceId, groupName, category };\n          const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n        }\n      });\n      this.props.onCategoriesUpdated();\n    }\n\n    // selected changes\n    const isSelectedChange = JSON.stringify(prevProps.selectedShapeStatus) !== JSON.stringify(this.props.selectedShapeStatus);\n    if (isSelectedChange) {\n      if (this.selectedPoints.length <= 0 || this.selectedRectangles.length <= 0) {\n        if (prevProps.selectedShapeStatus && prevProps.selectedShapeStatus.id !== undefined) {\n          const { instanceId, groupName, id, shapeType } = prevProps.selectedShapeStatus;\n          if (!this.isShapeInSelectedShapes(instanceId, groupName, id)) {\n            if (shapeType === LandmarkEditType.KEYPOINT) {\n              this.setPointSelected(instanceId, groupName, id as number, false);\n            } else {\n              this.selectShape(instanceId, groupName, id as string, false);\n            }\n          }\n        }\n      }\n      const { instanceId, groupName, id, shapeType } = this.props.selectedShapeStatus;\n      if (id !== undefined) {\n        this.setMultiShapesUnselected();\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          this.setPointSelected(instanceId, groupName, id as number, true);\n        } else {\n          this.selectShape(instanceId, groupName, id as string);\n        }\n      }\n    }\n    if ((prevProps.selectedShapeInfo as PointInfo || {}).pointCategory !== (this.props.selectedShapeInfo as PointInfo || {}).pointCategory) {\n      this.setSmooth(null);\n      if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n        this.setSelectedCurves();\n      }\n    }\n    if (\n      this.props.selectedInstance && (\n        isSelectedChange ||\n        JSON.stringify(this.props.selectedInstance) !== JSON.stringify(prevProps.selectedInstance)\n      )\n    ) {\n      const { instanceId, category, groupName } = this.props.selectedShapeStatus;\n      this.updateGroupBox(instanceId, category, groupName);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.resizeObserve) {\n      this.resizeObserve.disconnect();\n      this.resizeObserve = null;\n    }\n  }\n\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = true;\n\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = rootStore.setting.isGridVisible;\n\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n\n    this.attrLayer = new Paper.Layer();\n    this.attrLayer.applyMatrix = false;\n    this.attrLayer.visible = false;\n\n    this.warningLayer = new Paper.Layer();\n    this.warningLayer.applyMatrix = false;\n    this.warningLayer.visible = false;\n\n    Paper.view.onMouseMove = this.hitTest;\n  }\n\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n\n  loadImage() {\n    if (this.rasterLayer && this.props.image) {\n      this.rasterLayer.activate();\n      this.props.changeLoading(true);\n      if (this.raster) {\n        this.prevRaster = this.raster;\n      }\n      imageLoader(this.props.image, (c) => {\n        const canvas = c as HTMLCanvasElement;\n        this.imageCanvas = canvas;\n        this.imageData = canvas.getContext('2d')?.getImageData(0, 0, canvas.width, canvas.height);\n        this.raster = new Paper.Raster(canvas);\n        this.raster!.visible = false;\n        this.raster!.onLoad = () => {\n          if (!this.gridLayer?.children?.length) {\n            this.labelLayer!.visible = rootStore.setting.labelMode;\n            this.mainLayer!.visible = true;\n            this.warningLayer!.visible = true;\n            this.attrLayer!.visible = true;\n          }\n          this.addGrid(); // add grid to image\n          this.resize(); // resize to fit the container\n          // when onload, show all layers\n          this.raster!.visible = true;\n          if (this.prevRaster) {\n            this.prevRaster.remove();\n          }\n          this.props.changeLoading(false);\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous',\n      });\n    }\n  }\n\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const { brightness, contrast, saturation, lightness, hue, rescale } = rootStore.setting.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n\n  resize = (isWindow = false) => {\n    if (this.canvasContainer.current) {\n      // set view size\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n      const viewCenter = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      if (this.catchZoom) {\n        const { center, zoom } = this.catchZoom;\n        if (isWindow) {\n          Paper.view.center = viewCenter;\n          this.catchZoom.center = viewCenter;\n        } else {\n          Paper.view.center = center;\n        }\n        Paper.view.zoom = zoom;\n      } else {\n        Paper.view.center = viewCenter;\n        Paper.view.zoom = 1;\n      }\n\n      if (this.imageCanvas && this.raster) {\n        // resize image\n        const { width: imgWidth, height: imgHeight } = this.imageCanvas;\n        const viewRatio = viewWidth / viewHeight;\n        const imgRatio = imgWidth / imgHeight;\n        const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n        const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n        const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n        const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n        // apply matrix to all layers\n        Paper.project.layers.forEach((layer) => {\n          layer.matrix = matrix;\n        });\n        // reset image center\n        this.raster.position = new Paper.Point({ x: imgWidth / 2, y: imgHeight / 2 });\n        this.paperZoom = this.rasterLayer ? Paper.view.zoom * this.rasterLayer.matrix.scaling.x : Paper.view.zoom;\n      }\n      this.resizeContent();\n    }\n  };\n\n  resizeContent = () => {\n    if (this.resizeDebounced) {\n      this.resizeDebounced();\n    } else {\n      this.resizeDebounced = debounce(() => {\n        this.resizeGrid();\n        this.resizeShapes();\n        this.drawWarnings();\n      }, 50);\n    }\n  };\n\n  zoom = (event: WheelEvent, zoom?: number) => {\n    if (this.canvasContainer.current) {\n      const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n      const viewPosition = Paper.view.viewToProject(mousePosition);\n      const oldZoom = Paper.view.zoom;\n      const oldCenter = Paper.view.center;\n\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      let newZoom = event && event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n      newZoom = zoom || newZoom;\n      if (newZoom <= 1) {\n        Paper.view.center = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      }\n      newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n      if (newZoom !== Paper.view.zoom) {\n        Paper.view.zoom = newZoom;\n        const zoomScale = oldZoom / newZoom;\n        const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n        Paper.view.center = Paper.view.center.add(offset);\n      }\n      this.catchZoom = { zoom: newZoom, center: Paper.view.center };\n      this.paperZoom = newZoom * this.rasterLayer!.matrix.scaling.x;\n      this.resizeContent();\n    }\n  };\n\n  drag = (center: paper.Point) => {\n    this.catchZoom = this.catchZoom ? {\n      ...this.catchZoom,\n      center,\n    } : {\n      zoom: Paper.view.zoom,\n      center\n    };\n  };\n\n  fitSelected = (instanceId: string, groupName?: string) => {\n    const groupBox = groupName\n      ? this.getGroupContainerByGroupName(instanceId, groupName)\n      : this.getInstanceContainerByInstaceId(instanceId)?.children.find((g) => g.data.type === SHAPE_TYPE.GROUP);\n    if (groupBox && this.mainLayer && this.canvasContainer.current) {\n      const { center, width, height } = groupBox.bounds;\n      if (width === 0 || height === 0) return;\n      const point = this.mainLayer.localToGlobal(center);\n      const { width: viewWidth, height: viewHeight } = this.mainLayer.bounds;\n\n      let zoom = width / height > viewWidth / viewHeight ? viewWidth / width : viewHeight / height;\n      zoom = Math.min(18, Math.max(zoom, 1));\n      Paper.view.zoom = zoom;\n      Paper.view.center = point;\n      this.catchZoom = { zoom, center: point };\n      this.paperZoom = this.rasterLayer ? zoom * this.rasterLayer.matrix.scaling.x : zoom;\n      this.resizeContent();\n    } else {\n      this.resize();\n    }\n  };\n\n\n  fitPoint = (point: { x: number; y: number }) => {\n    if (this.mainLayer) {\n      const center = this.mainLayer.localToGlobal(new Paper.Point(point.x, point.y));\n      Paper.view.center = center;\n      this.catchZoom = { zoom: Paper.view.zoom, center };\n      this.resizeContent();\n    }\n  };\n\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      this.gridLayer.removeChildren();\n      const { width, height } = this.imageCanvas;\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({ length: rows }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({ length: cols }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n    }\n  }\n\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach((path) => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n\n  isShapeInSelectedShapes(instanceId: string, groupName: string, index: number | string | undefined) {\n    return this.selectedPoints.findIndex((p) => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0 ||\n    this.selectedRectangles.findIndex((p) => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0;\n  }\n\n  isPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const { bounds: { x, y, width, height } } = this.rasterLayer;\n    return localPoint.x >= 0 && localPoint.x <= (x + width) && localPoint.y >= 0 && localPoint.y <= (y + height);\n  }\n\n  getPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n\n    if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n\n  getInstanceContainerByInstaceId(instaceId: string) {\n    return this.mainLayer?.children.find((i) => i.data.type === SHAPE_TYPE.INSTANCE && i.data.instanceId === instaceId) as paper.Group;\n  }\n\n  getGroupContainerByGroupName(instaceId: string, groupName: string) {\n    const instance = this.getInstanceContainerByInstaceId(instaceId);\n    return instance?.children.find((g) => g.data.type === SHAPE_TYPE.GROUP && g.data.groupName === groupName) as paper.Group;\n  }\n\n  getShapeByKey(instaceId: string, groupName: string, key: string | number) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => (p.data.type === SHAPE_TYPE.RECTANGLE_GROUP && p.data.id === key) ||\n      (p.data.type === SHAPE_TYPE.KEYPOINT && p.data.index === key)) as paper.Group | paper.Shape;\n  }\n\n  getLabelByKey(instanceId: string, groupName: string, key: number | string) {\n    return this.labelLayer?.children.find((l) => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === key) as paper.Group;\n  }\n\n  getAttrLabelByKey(instanceId: string, groupName: string, key: number | string) {\n    return this.attrLayer?.children.find((l) => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === `attr-${key}`) as paper.Group;\n  }\n\n  getShapeByGroup() {\n    return this.mainLayer?.children.find((l) => l.data.type === SHAPE_TYPE.KEYPOINT_BOX);\n  }\n\n  getPathByCategory(instaceId: string, groupName: string, pointCategory: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => p.data.type === SHAPE_TYPE.PATH && p.data.pointCategory === pointCategory) as paper.Path;\n  }\n\n  getPathById(instaceId: string, groupName: string, pathId: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => p.data.type === SHAPE_TYPE.PATH && p.data.id === pathId) as paper.Path;\n  }\n\n  getPointsByCategory(instaceId: string, groupName: string, pointCategory: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.filter((p) => p.data.type === SHAPE_TYPE.KEYPOINT && p.data.pointCategory === pointCategory);\n  }\n\n  canAddShape() {\n    if (this.props.isReview || this.props.readonly || !rootStore.review.drawMode) return false;\n    if (this.mainLayer && this.props.selectedShapeInfo) {\n      if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.RECTANGLE) {\n        if (this.props.ontologyGroup && this.props.ontologyGroup.count > 0) {\n          return this.props.annotatedPointOrShapeCount < this.props.ontologyGroup.count;\n        }\n      } else if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.KEYPOINT) {\n        const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n        if (id === undefined || id < 0) return false;\n        const point = this.getShapeByKey(instanceId, groupName, id as number);\n        return !point;\n      }\n    }\n    return false;\n  }\n\n  containerAddPoint(groupData: GroupInfo, point: paper.Point, pointCategory: string, index: number, isKeyPoint: boolean, visible = true, attributes?: any) {\n    const { instanceId, groupName } = groupData;\n    const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n    this.addKeypointShape(point, pointCategory, index, isKeyPoint, groupContainer, visible, attributes);\n  };\n\n  addKeypoint(point: paper.Point) {\n    if (this.mainLayer && this.props.selectedShapeInfo && this.props.selectedShapeStatus && this.props.selectedInstance) {\n      const { id, shapeType, frameIndex } = this.props.selectedShapeStatus;\n      const index = (shapeType === LandmarkEditType.KEYPOINT && id as number) || 0;\n      const { x, y } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const { instanceId, category, groupName, pointCategory, isKeyPoint } = this.props.selectedShapeInfo as PointInfo;\n\n      const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n      const groupData = { instanceId, groupName, type: LandmarkEditType.KEYPOINT, category: this.props.selectedInstance.category };\n      this.containerAddPoint(groupData, newPoint, pointCategory, index, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n        const container: Group = { instanceId, category, groupName };\n        otherPoints = this.updateCirclePath(pointCategory, true, container);\n      }\n      this.props.handleShapesChange([{\n        frameIndex,\n        instanceId,\n        category,\n        groupName,\n        index,\n        shapeType: LandmarkEditType.KEYPOINT,\n        shape: {\n          pointCategory,\n          isKeyPoint,\n          position: { x, y },\n          visible: true, // default is visible when point added\n        },\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyShape(); // move next\n    }\n  }\n\n  addKeypointShape(point: paper.Point, pointCategory: string, pointIndex: number, isKeyPoint: boolean, groupContainer: paper.Group, visible: boolean, attributes?: any) {\n    if (!groupContainer) return;\n    const { frameIndex } = this.props.selectedShapeStatus;\n    const { instanceId, groupName, category, displayColor } = groupContainer.data;\n    if (this.mainLayer) {\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : displayColor || POINT_COLOR;\n      const fillColor = visible ? pointColor : '#3d424d';\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: (rootStore.setting.pointSize + 1) / zoom,\n        fillColor,\n        strokeColor: '#ffffff',\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white',\n      });\n      pointCircle.data = {\n        frameIndex,\n        type: SHAPE_TYPE.KEYPOINT,\n        cursor: Cursor.MOVE,\n        pointCategory,\n        index: pointIndex,\n        isKeyPoint,\n        visible,\n        instanceId,\n        groupName,\n        category,\n        fillColor,\n      };\n      groupContainer.addChild(pointCircle);\n\n      // add point to path\n      const groupData = rootStore.ontology.getGroupData(category, groupName);\n      const categoryData = (groupData && groupData.categories && groupData.categories.find((v) => v.name === pointCategory)) || undefined;\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      const lineColor = categoryData?.isConnect === false ?\n        new Paper.Color('rgba(0,0,0,0)') :\n        new Paper.Color(displayColor || POINT_COLOR);\n      let index = -1;\n      if (path) {\n        const { points, isCircle } = path.data;\n        if (!isCircle) {\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            for (let i = 0; i < points.length; i += 1) {\n              const p = points[i];\n              const nextP = points[i + 1];\n              if (pointIndex > p && nextP > pointIndex) {\n                // 2 => 1,3\n                index = i + 1;\n                break;\n              } else if (\n                pointIndex < p &&\n                (!nextP || nextP > p || (nextP < p && i !== 0))) {\n                // 9 => 10 || 10,18 || 10,5(end point)[not (end point)10,5]\n                index = i;\n                break;\n              }\n            }\n          } else {\n            index = path.data.points.findIndex((p: number) => pointIndex < p);\n          }\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: rootStore.setting.lineWidth / zoom,\n          strokeColor: lineColor,\n          selectedColor: lineColor,\n        });\n        path.data = {\n          type: SHAPE_TYPE.PATH,\n          pointCategory,\n          points: [pointIndex],\n          instanceId,\n          groupName,\n          id: `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`,\n        };\n        groupContainer.addChild(path);\n      }\n      this.toggleCurves(path);\n      if (path === this.smoothPath) {\n        this.setSmooth(path);\n      }\n      if (groupData && groupData.lines) {\n        const lines = groupData.lines.filter((v) => v.points.indexOf(pointIndex) >= 0);\n        const linesData: {isSource: boolean, fromTo: string, pathId: string}[] = [];\n        lines.forEach((connectPoints) => {\n          if (connectPoints) {\n            const { points, color } = connectPoints;\n            const isSource = pointIndex === points[0];\n            const otherEnd = this.getShapeByKey(instanceId, groupName, isSource ? points[1] : points[0]);\n            const fromTo = `${points[0]}-${points[1]}`;\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              if (otherEnd) {\n                const { pointCategory: otherCategory } = otherEnd.data;\n                const [startPoint, endPoint] = isSource ? [pointCircle, otherEnd] : [otherEnd, pointCircle];\n                const endSegment = new Paper.Segment(new Paper.Point(endPoint.position.x, endPoint.position.y));\n                const line = isSource ? path : this.getPathByCategory(instanceId, groupName, otherCategory !== pointCategory ? otherCategory : '');\n                if (line) {\n                  const sourceIndex = line.data.points.findIndex((p: number) => points[0] === p);\n                  if (sourceIndex === 0) {\n                    line.insert(0, endSegment);\n                    line.data.points.unshift(points[1]);\n                  } else if (sourceIndex === line.data.points.length - 1) {\n                    line.add(endSegment);\n                    line.data.points.push(points[1]);\n                  }\n                  this.toggleCurves(line);\n                  if (!endPoint.data.lines) {\n                    endPoint.data.lines = [];\n                  }\n                  endPoint.data.lines.push({ isSource: false, fromTo, pathId: line.data.id });\n                  startPoint.data.lines = [...startPoint.data.lines || [], { isSource: true, fromTo, pathId: line.data.id }];\n                }\n              }\n            } else {\n              linesData.push({ isSource, fromTo, pathId: fromTo });\n              if (otherEnd) {\n                const segments = isSource ? [segment, otherEnd.position] : [otherEnd.position, segment];\n                const line = new Paper.Path({\n                  segments,\n                  strokeWidth: rootStore.setting.lineWidth / zoom,\n                  strokeColor: color,\n                  selectedColor: color,\n                });\n                line.data = {\n                  type: SHAPE_TYPE.PATH,\n                  pointCategory: fromTo,\n                  points,\n                  instanceId,\n                  groupName,\n                  id: fromTo,\n                };\n                groupContainer.addChild(line);\n              }\n            }\n          }\n        });\n        if (rootStore.setting.pathStyle !== PathStyles.CURVES) {\n          pointCircle.data.lines = linesData;\n        }\n      }\n      path.sendToBack();\n      const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n      const label = `${visible ? 1 : 0}-${pointIndex}`;\n      let attrsLabel = getValuesLabel(groupInfo?.point_label_config?.fields, attributes, rootStore.setting.labelItems);\n      attrsLabel = `${rootStore.setting.displayPointIndex ? `${pointIndex}` : ''}${rootStore.setting.displayPointIndex && attrsLabel ? ';' : ''}${attrsLabel}`;\n\n      this.addLabel(\n        label,\n        { x: point.x, y: point.y, width: rootStore.setting.pointSize / zoom, height: rootStore.setting.pointSize / zoom },\n        { instanceId, category, groupName },\n        pointIndex,\n        visible,\n        SHAPE_TYPE.KEYPOINT,\n        attrsLabel\n      );\n    }\n  }\n\n  removePointShape(containerData: Group, pointIndex: number) {\n    const { instanceId, groupName } = containerData;\n    if (this.mainLayer) {\n      const point = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (point) {\n        const { lines, pointCategory } = point.data;\n        point.remove();\n        // remove pointCategory path\n        const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n        if (path && !path.data.isCircle) {\n          const index = path.data.points.findIndex((p: number) => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n        // remove group connect path\n        if (lines) {\n          (lines as { isSource: boolean, fromTo: string, pathId: string }[]).forEach(({ pathId, fromTo, isSource }) => {\n            const line = this.getPathById(instanceId, groupName, pathId);\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              let index = line?.data.points.findIndex((p: number) => p === pointIndex);\n              if (isSource && index < 0) {\n                index = line.data.points.findIndex((p: number) => p === Number(fromTo.split('-')[1] || -1));\n              }\n              if (index >= 0) {\n                line.removeSegment(index);\n                line.data.points.splice(index, 1);\n                this.toggleCurves(line);\n              }\n            } else {\n              line?.remove();\n            }\n          });\n        }\n      }\n    }\n    this.removeLabel(instanceId, groupName, pointIndex);\n  }\n\n  resizeShapes() {\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      this.mainLayer.children.forEach((instance) => {\n        if (instance.children && instance.children.length > 0) {\n          instance.children.forEach((group) => {\n            if (group.children) {\n              group.children.forEach((path) => {\n                if (path.data.type === SHAPE_TYPE.KEYPOINT) {\n                  path.set({ radius: rootStore.setting.pointSize / this.paperZoom });\n                  path.strokeWidth = 1 / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.PATH) {\n                  path.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.RECTANGLE_GROUP && path.children) {\n                  path.children.forEach((shape) => {\n                    if (shape.data.type === SHAPE_TYPE.RECTANGLE_POINT) {\n                      shape.set({ radius: (rootStore.setting.pointSize / 2) / this.paperZoom });\n                    } else if (shape.data.type === SHAPE_TYPE.RECTANGLE_PATH) {\n                      shape.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                    }\n                  });\n                }\n              });\n            }\n          });\n        } else if (instance.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          instance.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n        }\n      });\n    }\n    if (this.labelLayer?.children && this.labelLayer.children.length > 0) {\n      this.labelLayer.children.forEach((label) => {\n        const { zoom: oldZoom, width, height, point } = label.data;\n        resizeLabel({ width, height, zoom: this.paperZoom, fontSize: FONT_SIZE }, oldZoom, point, label, 'label');\n      });\n    }\n\n    if (this.attrLayer?.children && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach((label) => {\n        const { zoom: oldZoom, width, height, point } = label.data;\n        resizeLabel({ width, height, zoom: this.paperZoom, fontSize: FONT_SIZE }, oldZoom, point, label, 'attr');\n      });\n    }\n    const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n    this.setPointSelected(instanceId, groupName, id as number, true);\n  }\n\n  cleanLayer() {\n    if (this.mainLayer) {\n      this.mainLayer.children?.forEach((container) => {\n        if (container.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          container.remove();\n        } else {\n          container.children?.forEach((group) => {\n            group?.removeChildren();\n          });\n        }\n      });\n    }\n    if (this.labelLayer) {\n      this.labelLayer.removeChildren();\n    }\n\n    if (this.attrLayer) {\n      this.attrLayer.removeChildren();\n    }\n\n    if (this.warningLayer) {\n      this.warningLayer.removeChildren();\n    }\n  }\n\n  addLabel(content: string, shape: {x: number, y: number, width: number, height: number}, groupInfo: Group, key: number | string, visible: boolean, shapeType: string, attrsLabel?: string) {\n    if (this.labelLayer) {\n      const { instanceId, groupName } = groupInfo;\n      const fontSize = FONT_SIZE / this.paperZoom;\n      const label = new Paper.PointText({\n        content,\n        fontSize,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#000000',\n        shadowBlur: 2 / this.paperZoom,\n        shadowOffset: 2 / this.paperZoom,\n      });\n      const width = label.bounds.width + fontSize / 2;\n      const height = label.bounds.height + fontSize / 2;\n      const labelRect = new Paper.Shape.Rectangle({\n        size: [width, height],\n        fillColor: rootStore.setting.labelBgColor,\n      });\n      label.position.x = labelRect.bounds.width / 2;\n      label.position.y = labelRect.bounds.height / 2;\n\n      const labelGroup = new Paper.Group();\n      labelGroup.data = {\n        point: [shape.x, shape.y],\n        instanceId,\n        groupName,\n        key,\n        type: shapeType === SHAPE_TYPE.KEYPOINT ? LabelType.KEYPOINT : LabelType.OBJECT,\n        zoom: this.paperZoom,\n        height,\n        width\n      };\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        labelGroup.addChild(labelRect);\n      }\n      labelGroup.addChild(label);\n      this.labelLayer.addChild(labelGroup);\n      labelGroup.position.x = shape.x + labelRect.bounds.width / 2;\n      labelGroup.position.y = shape.y - labelRect.bounds.height / 2 - rootStore.setting.lineWidth / this.paperZoom;\n\n      if (shapeType !== SHAPE_TYPE.KEYPOINT_BOX && this.attrLayer) {\n        let center = { x: shape.x, y: shape.y };\n\n        if (SHAPE_TYPE.RECTANGLE) {\n          center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 };\n        }\n        const arrtLabelGroup = labelGroup.clone();\n        arrtLabelGroup.data.key = `attr-${arrtLabelGroup.data.key}`;\n        arrtLabelGroup.data.point = [center.x, center.y];\n        arrtLabelGroup.children.slice(-1)[0].fillColor = new Paper.Color('#ffffff');\n        (arrtLabelGroup.children.slice(-1)[0] as paper.PointText).content = '';\n        this.attrLayer.addChild(arrtLabelGroup);\n        if (attrsLabel) {\n          this.updateLabelContent(arrtLabelGroup, attrsLabel, shapeType);\n        } else {\n          arrtLabelGroup.visible = false;\n        }\n      }\n    }\n  }\n\n  updateLabel(instanceId: string, groupName: string, key: number | string, position: { x: number, y: number }, center: { x: number, y: number }) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [position.x, position.y];\n        label.position.x = position.x + label.bounds.width / 2;\n        label.position.y = position.y - label.bounds.height / 2;\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [center.x, center.y];\n        label.position.x = center.x;\n        label.position.y = center.y;\n      }\n    }\n  }\n\n  updateAttributeLabel(instanceId: string, category: string, groupName: string, key: number | string, attributes: any, instanceNum?: number) {\n    const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n    let label = '';\n    if (typeof key === 'number') {\n      label = getValuesLabel(groupInfo?.point_label_config?.fields, attributes, rootStore.setting.pointLabelItems);\n      label = `${rootStore.setting.displayPointIndex ? `${key}` : ''}${rootStore.setting.displayPointIndex && label ? ';' : ''}${label}`;\n    } else {\n      const categoryLabel = `${groupInfo?.class_display_name || ''}  ${instanceNum || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n      label = getValuesLabel(groupInfo?.label_config?.fields, attributes, rootStore.setting.labelItems);\n      label = `${rootStore.setting.displayCategory ? `${categoryLabel}` : ''}${rootStore.setting.displayCategory && label ? ';' : ''}${label}`;\n    }\n    const attrLayer = this.getAttrLabelByKey(instanceId, groupName, key);\n    if (attrLayer) {\n      if (label) {\n        this.updateLabelContent(attrLayer, label, SHAPE_TYPE.KEYPOINT);\n      } else {\n        attrLayer.visible = false;\n      }\n    }\n  }\n\n  updateLabelContent(label: paper.Group, content: string, shapeType: string) {\n    if (this.attrLayer && label) {\n      const zoom = Paper.view.zoom * this.attrLayer.matrix.scaling.x;\n      const labelText = label.children.slice(-1)[0];\n      (labelText as paper.PointText).content = content;\n      const { width, height } = labelText.bounds;\n      const fontSize = FONT_SIZE / zoom;\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        (label.children[0] as paper.Shape).size.height = height + fontSize / 2;\n        (label.children[0] as paper.Shape).size.width = width + fontSize / 2;\n      }\n      label.data.width = label.children[0].bounds.width;\n      label.data.height = label.children[0].bounds.height;\n      label.data.zoom = this.paperZoom;\n\n      let visible = false;\n      if (shapeType === SHAPE_TYPE.KEYPOINT) {\n        visible = rootStore.setting.activePointAttributesMode === AttributesMode.ALWAYS;\n      } else if (SHAPE_TYPE.RECTANGLE) {\n        visible = rootStore.setting.activeAttributesMode === AttributesMode.ALWAYS;\n      }\n      if (visible) {\n        const { point } = label.data;\n        resetAttrLabelPosition(label, { x: point[0], y: point[1] }, visible);\n      } else {\n        label.visible = false;\n      }\n    }\n  }\n\n  updatelabelVisible(activeMode: AttributesMode, type = 'object') {\n    if (this.shownLabel) {\n      this.shownLabel.visible = false;\n      this.shownLabel = null;\n    }\n    if (this.attrLayer?.children && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach((label) => {\n        const { type: labelType } = label.data;\n        if (type === labelType) {\n          label.visible = activeMode === AttributesMode.ALWAYS;\n        }\n      });\n    }\n  }\n\n  removeLabel(instanceId: string, groupName: string, key: string | number) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n\n  updateShapes() {\n    const { currentFrame } = this.props;\n    const { shape: { updatedShapes } } = rootStore;\n    updatedShapes.forEach((updatedShape) => {\n      if (updatedShape.frameIndex !== currentFrame) return;\n      switch (updatedShape.shapeType) {\n        case LandmarkEditType.KEYPOINT:\n          this.updatePoint(updatedShape);\n          break;\n        case LandmarkEditType.RECTANGLE:\n          this.updateRectangle(updatedShape);\n          break;\n        default:\n          break;\n      }\n    });\n    rootStore.shape.setUpdatedShapes([]);\n    const { instanceId, category, groupName } = this.props.selectedShapeStatus;\n    this.updateGroupBox(instanceId, category, groupName);\n  }\n\n  updateRectangle(updateShape: UpdatedShape) {\n    const { instanceId, groupName, category, id, shape } = updateShape;\n    if (id !== undefined) {\n      const rectangle = shape as Rectangle;\n      const currRectangle = this.getShapeByKey(instanceId, groupName, id);\n      if (currRectangle) {\n        // alreay exist, should update\n        if (rectangle === undefined) {\n          // delete\n          this.removeRectangle(instanceId, groupName, id);\n        } else if (rectangle.x) {\n          const { x, y, width, height, displayColor } = rectangle;\n          // update position\n          this.drawRectangle({ x, y, width, height, displayColor }, { instanceId, category, groupName }, id);\n        }\n      } else if (rectangle) {\n        //  has been removed, should add\n        const { x, y, width, height, displayColor } = rectangle;\n        const path = new Paper.Path();\n        path.data.id = id;\n        path.add(new Paper.Point(x, y));\n        path.add(new Paper.Point(x + width, y));\n        path.add(new Paper.Point(x + width, y + height));\n        path.add(new Paper.Point(x, y + height));\n        path.closed = true;\n        this.addRectangle(path, { instanceId, groupName, category, shapeType: LandmarkEditType.RECTANGLE, displayColor }, false);\n      }\n    }\n  }\n\n  updatePoint(updateShape: UpdatedShape) {\n    const { frameIndex, instanceId, groupName, category, index, shape } = updateShape;\n    if (index !== undefined) {\n      let updatedCategorie: KeypointCategoryProps | undefined;\n      const point = shape as Point;\n      const currPoint = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      if (currPoint) {\n        const currCategory = currPoint.data.pointCategory;\n        updatedCategorie = { pointCategory: currCategory, frameIndex, instanceId, groupName, category };\n        const groupData = { frameIndex, instanceId, category, groupName };\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(groupData, index);\n        } else if (point.position && point.pointCategory) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          this.updatePath(currPoint, point.position);\n          // update visible\n          if (point.visible !== undefined && currPoint.data.visible !== point.visible) {\n            this.changeVisibleStyle(currPoint, index, groupData, point.visible);\n          }\n          if (rootStore.setting.activePointAttributesMode !== AttributesMode.HIDE) {\n            this.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const { position, pointCategory, isKeyPoint, visible, attributes } = point;\n        if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          updatedCategorie = { pointCategory, frameIndex, instanceId, groupName, category };\n          const groupData = { instanceId, groupName, type: LandmarkEditType.KEYPOINT, category };\n          this.containerAddPoint(groupData, new Paper.Point(position.x, position.y), pointCategory, index, isKeyPoint, visible, attributes);\n        }\n      }\n      if (updatedCategorie) {\n        const { pointCategory, ...newContainer } = updatedCategorie;\n        const categoryKey = `${frameIndex}_${newContainer.instanceId}_${newContainer.groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, newContainer);\n        }\n      }\n    }\n  }\n\n  updatePath(\n    point: paper.Shape,\n    position: { x: number, y: number },\n  ) {\n    const { instanceId, groupName, pointCategory, index, lines } = point.data;\n    const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n    if (path && !path.data.isCircle) {\n      const segmentIndex = path.data.points.findIndex((p: number) => p === index);\n      path.segments[segmentIndex].point.x = position.x;\n      path.segments[segmentIndex].point.y = position.y;\n      this.toggleCurves(path);\n    }\n    // change connect line position\n    if (lines) {\n      (lines as {isSource: boolean, pathId: string}[]).forEach(({ isSource, pathId }) => {\n        const line = this.getPathById(instanceId, groupName, pathId);\n        if (line) {\n          let n = -1;\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            n = !isSource ? line.data.points.findIndex((p: number) => p === index) : -1;\n          } else {\n            n = isSource ? 0 : 1;\n            if (!line.segments[n]) {\n              n = 0;\n            }\n          }\n          if (n >= 0) {\n            line.segments[n].point.x = position.x;\n            line.segments[n].point.y = position.y;\n            this.toggleCurves(line);\n          }\n        }\n      });\n    }\n    this.updateLabel(\n      instanceId,\n      groupName,\n      index,\n      position,\n      position,\n    );\n  }\n\n  setPointSelected(instanceId: string, groupName: string, index: number, selected: boolean) {\n    if (this.mainLayer?.children && this.mainLayer.children.length > 0) {\n      const point = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      if (point) {\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          point.strokeWidth = 3 / zoom;\n          point.radius = (rootStore.setting.pointSize + 1) / zoom;\n        } else {\n          point.radius = rootStore.setting.pointSize / zoom;\n          point.strokeWidth = 1 / zoom;\n        }\n      }\n    }\n  }\n\n  setMultiShapesSelected(selectedShapes: (paper.Shape | paper.Group)[], type: CategoryPathShape) {\n    if (selectedShapes.length > 0) {\n      const { instanceId, groupName } = selectedShapes[0].data;\n      this.props.selectGroup(instanceId, groupName, false);\n      this.props.setSelectedShape(undefined);\n    }\n    if (type === CategoryPathShape.CIRCLE) {\n      this.selectedPoints = (selectedShapes as paper.Shape[]).sort((a, b) => a.data.index - b.data.index);\n      rootStore.shape.setMultiSelectedShape(this.selectedPoints.map((point) => (point as paper.Shape).data.index));\n      this.selectedPoints.forEach((point) => {\n        const pData = point.data;\n        this.setPointSelected(pData.instanceId, pData.groupName, pData.index, true);\n      });\n    } else {\n      this.selectedRectangles = selectedShapes as paper.Group[];\n      this.selectedRectangles.forEach((rectangle) => {\n        const rData = rectangle.data;\n        this.selectShape(rData.instanceId, rData.groupName, rData.id);\n      });\n    }\n  }\n\n  setMultiShapesUnselected() {\n    this.selectedPoints.forEach((point) => {\n      const { instanceId, groupName, index } = point.data;\n      this.setPointSelected(instanceId, groupName, index, false);\n    });\n    this.selectedRectangles.forEach((rectangle) => {\n      const { instanceId, groupName, id } = rectangle.data;\n      this.selectShape(instanceId, groupName, id, false);\n    });\n\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    rootStore.shape.setMultiSelectedShape([]);\n  }\n\n  updatePointsPosition(shapes: UpdatedShape[]) {\n    this.props.handleShapesChange(shapes);\n  }\n\n  // resize and drag, change label position\n  updateRectanglePosition(shapes: UpdatedShape[]) {\n    this.props.handleShapesChange(shapes);\n    if (this.labelLayer) {\n      shapes.forEach(({ instanceId, groupName, id, shape }) => {\n        if (id && shape && (shape as Rectangle).x) {\n          const { x, y, width, height } = shape as Rectangle;\n          this.updateLabel(\n            instanceId,\n            groupName,\n            id,\n            { x, y },\n            { x: x + width / 2, y: y + height / 2 },\n          );\n        }\n      });\n    }\n  }\n\n  deleteSelectedPoints() {\n    const updatedCategories: KeypointCategoryProps[] = [];\n    const points: UpdatedShape[] = [];\n    (this.selectedPoints.length > 0 ? this.selectedPoints.map((p) => ({\n      frameIndex: this.props.currentFrame,\n      instanceId: p.data.instanceId,\n      category: p.data.category,\n      groupName: p.data.groupName,\n      index: p.data.index,\n      shapeType: LandmarkEditType.KEYPOINT\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.KEYPOINT\n    }]).forEach((selectedShapeStatus) => {\n      let enable = true;\n      const { frameIndex, instanceId, groupName, index } = selectedShapeStatus;\n      const point = typeof index === 'number' && this.getShapeByKey(instanceId, groupName, index);\n      if (point && point.data) {\n        const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${point.data.pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          const path = this.getPathByCategory(instanceId, groupName, point.data.pointCategory);\n          const instance = this.getInstanceContainerByInstaceId(instanceId);\n          if (instance && path && path.data.isCircle) {\n            const group = rootStore.ontology.getGroupData(instance.data.category, groupName);\n            const pointCategory = group && group.categories && group.categories.length && group.categories.find((c) => c.name === point.data.pointCategory);\n            if (pointCategory) {\n              const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n              const pIndex1 = sortedKeys[0];\n              const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n              if (index !== pIndex1 && index !== pIndex2) {\n                enable = true;\n              }\n            }\n          }\n        }\n        if (enable) {\n          points.push({\n            ...selectedShapeStatus,\n            ...point.data\n          });\n        }\n      }\n    });\n    this.props.handleShapesRemove(points);\n    rootStore.handle.removeHandles(points);\n    points.forEach(({ frameIndex, instanceId, category, groupName, index }) => {\n      const instance = this.getInstanceContainerByInstaceId(instanceId);\n      const point = this.getShapeByKey(instanceId, groupName, index!);\n      if (instance && point && !updatedCategories.includes(point.data.pointCategory)) {\n        updatedCategories.push({ pointCategory: point.data.pointCategory, frameIndex, instanceId, groupName, category: instance.data.category });\n      }\n      this.removePointShape({ instanceId, category, groupName }, index!);\n    });\n    updatedCategories.forEach(({ frameIndex, pointCategory, ...container }) => {\n      const categoryKey = `${frameIndex}_${container.instanceId}_${container.groupName}_${pointCategory}`;\n      this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n    });\n    this.selectedPoints = [];\n  }\n\n  deleteSelectedRectangle() {\n    const rectangles = (this.selectedRectangles.length > 0 ? this.selectedRectangles.map((rect) => ({\n      frameIndex: rect.data.frameIndex,\n      instanceId: rect.data.instanceId,\n      category: rect.data.category,\n      groupName: rect.data.groupName,\n      id: rect.data.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      id: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    }]).filter((v) => typeof v.id === 'string');\n    this.props.handleShapesRemove(rectangles);\n    rectangles.forEach(({ instanceId, groupName, id }) => {\n      this.removeRectangle(instanceId, groupName, id);\n    });\n    this.selectedRectangles = [];\n  };\n\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ?\n      this.selectedPoints.map((p) => p.data) :\n      [{ ...this.props.selectedShapeStatus, index: this.props.selectedShapeStatus.id }]\n        .filter((v) => v.shapeType === LandmarkEditType.KEYPOINT);\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      this.changeVisibleStyle(point, index, { instanceId, category, groupName, displayColor: point.data.fillColor }, !point.data.visible);\n    });\n    this.props.togglePointsVisibility(points);\n  }\n\n  changeVisibleStyle(point: paper.Shape, index: number, groupData: Group, visible: boolean) {\n    const { instanceId, groupName } = groupData;\n    const labelGroup = this.getLabelByKey(instanceId, groupName, index);\n    if (point) {\n      let fillColor = point.data.isKeyPoint ?\n        KEY_POINT_COLOR :\n        groupData?.displayColor || POINT_COLOR;\n      let strokeColor = '#ffffff';\n      if (!visible) {\n        strokeColor = fillColor;\n        fillColor = '#3d424d';\n      }\n      point.data.visible = visible;\n      point.fillColor = new Paper.Color(fillColor);\n      point.strokeColor = new Paper.Color(strokeColor);\n    }\n    if (this.labelLayer && labelGroup) {\n      const label = labelGroup.children.length === 2 ? labelGroup.children[1] : labelGroup.children[0];\n      (label as paper.PointText).content = `${visible ? '1' : '0'}-${index}`;\n      label.fillColor = new Paper.Color(visible ? 'white' : 'red');\n    }\n  }\n\n  hitTest = (event: ToolEventExtend) => {\n    if (this.mainLayer && !this.tool?.mouseDown) {\n      let cursor: Cursor = Cursor.DEFAULT;\n      const isDrawPoint = this.props.selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT;\n      if (this.canAddShape()) {\n        cursor = isDrawPoint ? Cursor.POINTER : Cursor.CROSSHAIR;\n      }\n      if (this.selectedHit) {\n        this.selectedHit.selected = false;\n      }\n\n      const hits = this.mainLayer.hitTestAll(event.point, {\n        fill: true,\n        selected: false,\n        handles: true,\n        stroke: true,\n        tolerance: 10 / this.paperZoom,\n        match: (ht: any) => {\n          if (ht && ht.item && (ht.item.data.type === undefined || ht.item.data.type === SHAPE_TYPE.KEYPOINT_BOX)) {\n            return false;\n          }\n          return true;\n        }\n      });\n      let hit: paper.HitResult | undefined;\n      for (let i = 0; i < hits.length; i += 1) {\n        const h = hits[i];\n        const { type } = h.item.data;\n        if (\n          !type ||\n          (type !== SHAPE_TYPE.INSTANCE &&\n          type !== SHAPE_TYPE.GROUP &&\n          type !== SHAPE_TYPE.KEYPOINT_BOX &&\n          type !== SHAPE_TYPE.RECTANGLE_GROUP) &&\n          (\n            type !== SHAPE_TYPE.PATH ||\n            (type === SHAPE_TYPE.PATH && ['handle-in', 'handle-out'].includes(h.type)))\n        ) {\n          // select point | rectangle | rectangle control | path handle\n          if ((type === SHAPE_TYPE.RECTANGLE || type === SHAPE_TYPE.RECTANGLE_POINT || type === SHAPE_TYPE.RECTANGLE_PATH)) {\n            if ((i === 0) && !this.canAddShape()) {\n              hit = h;\n            }\n          } else {\n            hit = h;\n            if (type === SHAPE_TYPE.KEYPOINT) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (hit?.item && !event.event.ctrlKey) {\n        if (\n          !this.isShapeInSelectedShapes(hit.item.data?.instanceId, hit.item.data?.groupName, hit.item.data?.index) &&\n          hit.item.data?.index !== this.props.selectedShapeStatus.id &&\n          hit.item.data?.id !== this.props.selectedShapeStatus.id\n        ) {\n          this.selectedHit = hit.item;\n          hit.item.selected = true;\n        }\n        if (hit.item.data.cursor) {\n          cursor = hit.item.data.cursor;\n        } else {\n          cursor = Cursor.MOVE;\n        }\n        this.showShapeLabel(hit, event.point);\n      } else if (this.shownLabel) {\n        const { point } = this.shownLabel.data;\n        resetAttrLabelPosition(this.shownLabel, { x: point[0], y: point[1] }, false);\n      }\n      this.hits = hit;\n      if (this.currentWarnings.length > 0) {\n        this.warningBtn = this.warningLayer?.hitTest(event.point);\n      }\n      if (this.smoothPath) {\n        this.smoothPath.fullySelected = true;\n      }\n      this.setCursor(cursor);\n    }\n  };\n\n  setCursor(cursor: Cursor) {\n    this.cursor = cursor;\n  }\n\n  clearHits = () => {\n    this.hits = undefined;\n  };\n\n  showShapeLabel(hits: paper.HitResult, point: paper.Point) {\n    const { activePointAttributesMode, activeAttributesMode } = rootStore.setting;\n    if (!activePointAttributesMode && !activeAttributesMode) return;\n    const localPoint = this.getPointInImage(Paper.view.projectToView(point));\n    const { data } = hits.item;\n    let label;\n    if (data.type === SHAPE_TYPE.KEYPOINT && activePointAttributesMode === AttributesMode.HOVER) {\n      label = this.getAttrLabelByKey(data.instanceId, data.groupName, data.index);\n    } else if (\n      (data.type === SHAPE_TYPE.RECTANGLE || data.type === SHAPE_TYPE.RECTANGLE_PATH || data.type === SHAPE_TYPE.RECTANGLE_POINT) &&\n      hits.item.parent &&\n      activeAttributesMode === AttributesMode.HOVER\n    ) {\n      const { instanceId, groupName, id } = hits.item.parent.data;\n      label = this.getAttrLabelByKey(instanceId, groupName, id);\n    }\n    if (label && (label.children?.slice(-1)[0] as paper.PointText).content) {\n      if (this.shownLabel) {\n        if (JSON.stringify(label) !== JSON.stringify(this.shownLabel)) {\n          const { point: position } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, { x: position[0], y: position[1] }, false);\n          this.shownLabel = label;\n        }\n      } else {\n        this.shownLabel = label;\n      }\n      this.shownLabel.visible = true;\n      this.shownLabel.position.x = localPoint.x + 50 / Paper.view.zoom;\n      this.shownLabel.position.y = localPoint.y + 50 / Paper.view.zoom;\n    }\n  }\n\n  getNewPointsByKeyPointRange(path: paper.Path, startKey: number, endKey: number, instanceId: string, groupName: string) {\n    const startPosition = this.getShapeByKey(instanceId, groupName, startKey).position;\n    const endPosition = this.getShapeByKey(instanceId, groupName, endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    let newPoints = {}; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints = {\n        ...newPoints,\n        [base + 1]: nextPoint\n      };\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n\n  getUpdatedPointsByNewPoints(newPoints: {[index: number]: paper.Point}, pointCategory: CategoryItem, parentData: Group) {\n    const { instanceId, groupName, category } = parentData;\n    const updatedShapes: UpdatedShape[] = [];\n    const indexs = Object.keys(newPoints).map((v) => Number(v));\n    for (let index = 0; index < indexs.length; index += 1) {\n      const pointIndex = indexs[index];\n      const existingPoint = this.getShapeByKey(instanceId, groupName, pointIndex) as paper.Shape;\n      if (newPoints[pointIndex]) {\n        const { x, y } = newPoints[pointIndex];\n        const pointInfo = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index: pointIndex,\n          shapeType: LandmarkEditType.KEYPOINT,\n        };\n        if (existingPoint) {\n          if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n            // update position\n            existingPoint.position.x = x;\n            existingPoint.position.y = y;\n\n            this.updatePath(existingPoint, { x, y });\n            updatedShapes.push({\n              ...pointInfo,\n              shape: {\n                position: { x, y }\n              },\n            });\n          }\n        } else {\n          // add new point\n          const isKeyPoint = pointCategory.keys.includes(pointIndex);\n          const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n\n          this.addKeypointShape(new Paper.Point(x, y), pointCategory.name, pointIndex, isKeyPoint, groupContainer, true);\n          updatedShapes.push({\n            ...pointInfo,\n            shape: {\n              pointCategory: pointCategory.name,\n              isKeyPoint,\n              position: { x, y },\n              visible: true,\n            },\n          });\n        }\n      }\n    }\n    return updatedShapes;\n  }\n\n  autoAdjust(point = this.props.selectedShapeStatus) {\n    if (this.props.selectedShapeInfo) {\n      const { id } = point;\n      const { instanceId, category, groupName, pointCategory: categoryName } = this.props.selectedShapeInfo as PointInfo;\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName); // pointCategory path\n      const pointCategory = this.props.categories.find((c) => c.name === categoryName); // pointCategory definition\n      if (path && pointCategory && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex: number | undefined;\n        let nextKeyPointIndex: number | undefined;\n        const { points = [] } = path.data;\n        const { keys = [] } = pointCategory;\n        const keysWithTwoSides = [\n          ...(keys.includes(points[0]) ? [] : [points[0]]),\n          ...keys,\n          ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]]),\n        ].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex((key) => key > Number(id));\n        if (keyIndex < 0) { // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex, instanceId, groupName);\n          const parentData = { instanceId, category, groupName };\n          const updatedShapes = this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData);\n          if (updatedShapes.length > 0) {\n            this.props.handleShapesChange(updatedShapes);\n          }\n        }\n      }\n    }\n  }\n\n  switchSmoothMode() {\n    if (this.props.selectedShapeInfo && rootStore.setting.pathStyle !== PathStyles.CURVES) {\n      const { instanceId, category, groupName, pointCategory: categoryName } = this.props.selectedShapeInfo as PointInfo;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName);\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      if (path && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const pointCategory = this.props.categories.find((c) => c.name === categoryName);\n          if (pointCategory) {\n            const keyPoints = pointCategory.keys.filter((k) => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedShapes: UpdatedShape[] = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i], instanceId, groupName);\n              const parentData = { instanceId, category, groupName };\n              updatedShapes = [\n                ...updatedShapes,\n                ...this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData),\n              ];\n            }\n            if (updatedShapes.length > 0) {\n              this.props.handleShapesChange(updatedShapes);\n            }\n          }\n          this.setSmooth(null);\n        } else {\n          // start\n          this.setSmooth(path);\n        }\n      }\n    }\n  }\n\n  setSmooth(smooth: paper.Path | null) {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach((seg) => {\n        seg.clearHandles();\n      });\n    }\n    this.smoothPath = smooth;\n    if (this.smoothPath) {\n      this.smoothPath.smooth({ type: 'continuous' });\n      this.smoothPath.fullySelected = true;\n    }\n  }\n\n  setSelectedCurves() {\n    if (this.props.selectedShapeInfo) {\n      const { selectedShapeInfo } = this.props;\n      const { instanceId, groupName, pointCategory } = selectedShapeInfo as PointInfo;\n      const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      this.toggleCurves(path);\n    }\n    const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n    if (typeof id === 'number') {\n      const point = this.getShapeByKey(instanceId, groupName, id);\n      if (point) {\n        const { data: { lines = [] } } = point;\n        lines.forEach(({ pathId }: any) => {\n          const path = this.getPathById(instanceId, groupName, pathId);\n          this.toggleCurves(path);\n        });\n      }\n    }\n  }\n\n  toggleCurves(path?: paper.Path) {\n    if (rootStore.setting.pathStyle === PathStyles.CURVES && path) {\n      const { data: { instanceId, groupName, id: pathId, points }, segments } = path;\n      const { currentFrame } = this.props;\n      path.smooth({ type: 'continuous' });\n      const map: {[pointIndex: number]: Handle} = {};\n      // points\n      (points as number[]).forEach((pointIndex, i) => {\n        const segment = segments[i];\n        if (segment) {\n          const { handleIn, handleOut, point } = segment;\n          map[pointIndex] = {\n            frameIndex: currentFrame,\n            pathId,\n            instanceId,\n            groupName,\n            pointIndex,\n            handleIn: { x: handleIn.x, y: handleIn.y },\n            handleOut: { x: handleOut.x, y: handleOut.y },\n            pointPosition: { x: point.x, y: point.y },\n          };\n        }\n      });\n      rootStore.handle.setPathHandles(currentFrame, pathId, map);\n    }\n  }\n\n  setCategoryAsCircle() {\n    if (this.props.selectedShapeInfo) {\n      const { instanceId, category, groupName, pointCategory } = this.props.selectedShapeInfo as PointInfo;\n      if (pointCategory) {\n        const container: Group = { instanceId, category, groupName };\n        const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, false, container);\n          this.props.setCategoryPathShape(categoryKey);\n        } else {\n          const updatedShapes = this.updateCirclePath(pointCategory, true, container);\n          this.props.setCategoryPathShape(categoryKey, CategoryPathShape.CIRCLE, updatedShapes);\n        }\n      }\n    }\n  }\n\n  updateCirclePath(categoryName: string, isCirclePath = true, container: Group) {\n    const { instanceId, groupName, category } = container;\n    const updatedShapes: UpdatedShape[] = [];\n    const path = this.getPathByCategory(instanceId, groupName, categoryName);\n    const categoryData = rootStore.ontology.getCategoryData(category, groupName, categoryName);\n    const lineColor = categoryData?.isConnect === false ?\n      new Paper.Color('rgba(0,0,0,0)') :\n      new Paper.Color(categoryData?.displayColor || POINT_COLOR);\n    if (path && categoryData) {\n      const categoryPoints = this.getPointsByCategory(instanceId, groupName, categoryName);\n      if (categoryPoints) {\n        const sortedKeys = [...categoryData.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find((p) => p.data.index === pIndex1);\n        const point2 = categoryPoints.find((p) => p.data.index === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer!.matrix.scaling.x;\n        if (point1 && point2) {\n          if (isCirclePath) {\n            // is a circle & key points all exist\n            const centerX = (point1.position.x + point2.position.x) / 2;\n            const centerY = (point1.position.y + point2.position.y) / 2;\n            const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n            const newPath = new Paper.CompoundPath({\n              children: [\n                new Paper.Path.Circle({\n                  center: [centerX, centerY],\n                  radius,\n                }),\n                new Paper.Path.Line({\n                  from: [point1.position.x, point1.position.y],\n                  to: [point2.position.x, point2.position.y],\n                }),\n                new Paper.Path.Line({\n                  from: new Paper.Point(computeRotatedPosition({ x: centerX, y: centerY }, point1.position, Math.PI / 2)),\n                  to: new Paper.Point(computeRotatedPosition({ x: centerX, y: centerY }, point1.position, -Math.PI / 2)),\n                }),\n              ],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor,\n            });\n            newPath.data = { ...path.data, isCircle: true, instanceId, groupName };\n            path.replaceWith(newPath);\n\n            // update all points in this pointCategory\n            const update = (index: number, position: { x: number; y: number }) => {\n              const existingPoint = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n              const pointInfo = {\n                frameIndex: this.props.selectedShapeStatus.frameIndex,\n                instanceId,\n                category,\n                groupName,\n                index,\n                shapeType: LandmarkEditType.KEYPOINT,\n              };\n              if (existingPoint) {\n                // update position\n                existingPoint.position.x = position.x;\n                existingPoint.position.y = position.y;\n                this.updatePath(existingPoint, position);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    position: { x: position.x, y: position.y }\n                  },\n                });\n              } else {\n                const isKeyPoint = categoryData.keys.includes(index);\n                const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n\n                this.addKeypointShape(new Paper.Point(position.x, position.y), categoryData.name, index, isKeyPoint, groupContainer, true);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    pointCategory: categoryData.name,\n                    isKeyPoint,\n                    position: { x: position.x, y: position.y },\n                    visible: true,\n                  },\n                });\n              }\n            };\n            const [start, end] = categoryData.range;\n            for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n              const radians = (Math.PI / (pIndex2 - pIndex1)) * (i - pIndex1);\n              const position = computeRotatedPosition({ x: centerX, y: centerY }, point1.position, radians);\n              update(i, position);\n            }\n            for (let i = pIndex2 + 1; i <= end; i += 1) {\n              const radians = (Math.PI / (end + 1 - pIndex2)) * (i - pIndex2);\n              const position = computeRotatedPosition({ x: centerX, y: centerY }, point2.position, radians);\n              update(i, position);\n            }\n            for (let i = start; i < pIndex1; i += 1) {\n              const radians = (Math.PI / (end + 1 - pIndex2)) * (start - pIndex1);\n              const position = computeRotatedPosition({ x: centerX, y: centerY }, point1.position, radians);\n              update(i, position);\n            }\n          } else {\n            const points = [...categoryPoints].sort((a, b) => a.data.index - b.data.index);\n            const newPath = new Paper.Path({\n              segments: points.map((p) => p.position),\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor,\n            });\n            newPath.data = { ...path.data, isCircle: false, points: points.map((p) => p.data.index) };\n            path.replaceWith(newPath);\n            this.toggleCurves(newPath);\n          }\n        }\n      }\n    }\n    return updatedShapes;\n  }\n\n  updateGroupBox = (instanceId: string, category: string, groupName: string) => {\n    let boundRect = this.getShapeByGroup();\n    const { selectedShapeStatus } = this.props;\n    let isRemovebound = false;\n    if (\n      instanceId &&\n      instanceId === selectedShapeStatus.instanceId &&\n      groupName === selectedShapeStatus.groupName\n    ) {\n      const { ontology, setting: { pointSize, lineWidth, labelItems } } = rootStore;\n      const groupConntainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      const points = groupConntainer && groupConntainer.children\n        .filter((v: any) => v.type === CategoryPathShape.CIRCLE)\n        .map((v) => [v.position.x, v.position.y]);\n      if (points && points.length > 0) {\n        const xList = points.map((v) => v[0]);\n        const yList = points.map((v) => v[1]);\n        const minX = Math.min(...xList);\n        const maxX = Math.max(...xList);\n        const minY = Math.min(...yList);\n        const maxY = Math.max(...yList);\n        if (this.mainLayer) {\n          const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n          if (boundRect) {\n            boundRect.remove();\n          }\n          const range = (pointSize * 3) / zoom;\n          const fontSize = FONT_SIZE / this.paperZoom;\n          const strokeWitdth = lineWidth / zoom;\n          boundRect = new Paper.Shape.Rectangle({\n            point: [minX - range, minY - range],\n            size: [maxX - minX + 2 * range, maxY - minY + 2 * range],\n            strokeColor: new Paper.Color('#FFE600'),\n            strokeWidth: strokeWitdth\n          });\n          boundRect.data.type = SHAPE_TYPE.KEYPOINT_BOX;\n          this.mainLayer.addChild(boundRect);\n          const groupInfo = ontology.getGroupData(category, groupName);\n          const instance = this.props.getInstance(instanceId);\n          const group = instance?.children.find((g) => g.name === groupName)?.frames[this.props.currentFrame];\n          const attrsLabel = getValuesLabel(groupInfo?.label_config?.fields, group?.attributes, labelItems);\n          const content = `${groupInfo?.class_display_name || ''} ${instance?.number || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n          const labelGroup = this.getLabelByKey('', '', 'group_label');\n          const groupAttribute = this.getLabelByKey('', '', 'group_attributes');\n          labelGroup?.remove();\n          groupAttribute?.remove();\n          const x = minX - range; const y = minY - range - strokeWitdth * 2;\n          const w = maxX - minX + 2 * range; const h = maxY - minY + 2 * range;\n          this.addLabel(\n            content,\n            { x, y, width: w, height: h },\n            { instanceId: '', category: '', groupName: '' },\n            'group_label',\n            true,\n            SHAPE_TYPE.KEYPOINT_BOX\n          );\n          this.addLabel(\n            attrsLabel,\n            { x, y: y - fontSize * 1.5, width: w, height: h },\n            { instanceId: '', category: '', groupName: '' },\n            'group_attributes',\n            true,\n            SHAPE_TYPE.KEYPOINT_BOX\n          );\n        }\n      } else {\n        isRemovebound = true;\n      }\n    } else {\n      isRemovebound = true;\n    }\n    if (isRemovebound && boundRect) {\n      boundRect.remove();\n      this.removeLabel('', '', 'group_label');\n      this.removeLabel('', '', 'group_attributes');\n    }\n  };\n\n  addRectangle(path: paper.Path, groupInfo: GroupInfo, add = true) {\n    if (this.mainLayer) {\n      const { displayColor, instanceId, category, groupName } = groupInfo;\n      const { data: { id }, segments } = path;\n      const rectData = {\n        x: segments[0].point.x,\n        y: segments[0].point.y,\n        width: segments[2].point.x - segments[0].point.x,\n        height: segments[2].point.y - segments[0].point.y,\n        displayColor,\n      };\n      this.drawRectangle(rectData, { instanceId, category, groupName }, id);\n      if (add) {\n        this.props.setNextEmptyShape();\n      }\n    }\n  }\n\n  getAlphaColor(color: string, opacity = this.fillOpacity) {\n    return hexToRgba(color, opacity);\n  }\n\n  drawRectangle(\n    rectData: {x: number, y: number, width: number, height: number, displayColor?: string},\n    groupData: Group,\n    id: string,\n    visible = true\n  ) {\n    if (this.props.selectedShapeInfo && this.mainLayer) {\n      const { x, y, width, height, displayColor } = rectData;\n      const { instanceId, category, groupName } = groupData;\n      let instanceContainer = this.getInstanceContainerByInstaceId(instanceId);\n      let groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (!instanceContainer) {\n        instanceContainer = new Paper.Group();\n        instanceContainer.data = {\n          instanceId,\n          name: category,\n          type: SHAPE_TYPE.INSTANCE,\n        };\n        this.mainLayer?.addChild(instanceContainer);\n      }\n      if (!instanceContainer || !groupContainer) {\n        groupContainer = new Paper.Group();\n        groupContainer.data = {\n          groupName,\n          category,\n          type: SHAPE_TYPE.GROUP,\n          instanceId,\n        };\n        instanceContainer.addChild(groupContainer);\n      }\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      let rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox) {\n        rectangleBox.removeChildren();\n      } else {\n        rectangleBox = new Paper.Group();\n        rectangleBox.data = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          id,\n          groupName,\n          category,\n          type: SHAPE_TYPE.RECTANGLE_GROUP,\n          instanceId,\n          displayColor,\n          visible,\n        };\n        groupContainer.addChild(rectangleBox);\n      }\n      const rectangle = new Paper.Shape.Rectangle({\n        point: [x, y],\n        size: [width, height],\n        fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n        strokeWidth: rootStore.setting.lineWidth / zoom\n      });\n      rectangle.data = {\n        parentShape: id,\n        cursor: Cursor.MOVE,\n        type: SHAPE_TYPE.RECTANGLE\n      };\n      rectangleBox.addChild(rectangle);\n      this.selectShape(instanceId, groupName, id, id === this.props.selectedShapeStatus.id);\n      if (this.labelLayer) {\n        const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n        const instance = this.props.getInstance(instanceId);\n        const group = instance?.children.find((g) => g.name === groupName)?.frames[this.props.currentFrame];\n        const label = `${groupInfo?.class_display_name || ''} ${instance?.number || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n        let attrsLabel = getValuesLabel(groupInfo?.label_config?.fields, group?.attributes, rootStore.setting.labelItems);\n        attrsLabel = `${rootStore.setting.displayCategory ? `${label};` : ''}${rootStore.setting.displayCategory && attrsLabel ? ';' : ''}${attrsLabel}`;\n        const labelGroup = this.getLabelByKey(instanceId, groupName, id);\n        if (labelGroup) {\n          this.updateLabel(\n            instanceId,\n            groupName,\n            id,\n            { x, y },\n            { x: x + width / 2, y: y + height / 2 },\n          );\n        } else {\n          this.addLabel(\n            label,\n            { x, y, width, height },\n            { instanceId, category, groupName },\n            id,\n            visible,\n            SHAPE_TYPE.RECTANGLE,\n            attrsLabel\n          );\n        }\n      }\n    }\n  }\n\n  removeRectangle(instanceId: string, groupName: string, id: string) {\n    const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n    if (rectangleBox) {\n      rectangleBox.removeChildren();\n      rectangleBox.remove();\n      this.removeLabel(instanceId, groupName, id);\n    }\n  }\n\n  selectShape(instanceId: string, groupName: string, id: string, selected = true) {\n    if (this.mainLayer) {\n      const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox && rectangleBox.children) {\n        const { bounds: { topLeft, topRight, bottomRight, bottomLeft, x, y, height, width } } = rectangleBox.children[0];\n        const points = [topLeft, topRight, bottomRight, bottomLeft];\n        const { displayColor } = rectangleBox.data;\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          const radius = (rootStore.setting.pointSize / 2) / zoom;\n          const newColor = new Paper.Color(displayColor || POINT_COLOR);\n          points.forEach((point, index) => {\n            const sourceSeg = new Paper.Segment(point);\n            const targetSeg = index + 1 >= points.length ?\n              new Paper.Segment(points[0]) :\n              new Paper.Segment(points[index + 1]);\n\n            const lineBar = new Paper.Path({\n              segments: [sourceSeg, targetSeg],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              fillColor: newColor,\n              strokeColor: newColor,\n              selectedColor: newColor,\n            });\n            lineBar.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_PATH,\n              controlIndex: index,\n            };\n            rectangleBox.addChild(lineBar);\n          });\n          points.forEach((point, index) => {\n            const control = new Paper.Shape.Circle(point, radius);\n            control.strokeColor = newColor;\n            control.strokeWidth = rootStore.setting.lineWidth / zoom;\n            control.fillColor = newColor;\n            control.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_POINT,\n              controlIndex: index,\n              displayColor\n            };\n            rectangleBox.addChild(control);\n          });\n        } else {\n          rectangleBox.removeChildren();\n          const rectangle = new Paper.Shape.Rectangle({\n            point: [x, y],\n            size: [width, height],\n            fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n            strokeWidth: rootStore.setting.lineWidth / zoom\n          });\n          rectangle.data = {\n            parentShape: id,\n            cursor: Cursor.MOVE,\n            type: SHAPE_TYPE.RECTANGLE\n          };\n          rectangleBox.addChild(rectangle);\n        }\n      }\n    }\n  }\n\n  drawWarnings() {\n    this.warningLayer?.removeChildren();\n    const { qaWarnings: warnings } = rootStore.review;\n    if (warnings.length > 0) {\n      this.currentWarnings = warnings.filter((warning) => warning.frames[0] === this.props.currentFrame);\n      if (this.warningLayer) {\n        const strokeWitdth = 2 / this.paperZoom;\n        const warningIconSize = 8 / this.paperZoom;\n        this.currentWarnings.forEach((warning) => {\n          const { id, groupName, shapeIds, data } = warning;\n          if (!groupName || !shapeIds) {\n            // missing\n            if (data?.position) {\n              const warningIcon = new Paper.Shape.Circle({\n                center: data.position,\n                radius: warningIconSize,\n                fillColor: '#DD4924',\n              });\n              const text = new Paper.PointText({\n                content: '!',\n                fontSize: FONT_SIZE / this.paperZoom,\n                fontWeight: '700',\n                fillColor: 'white',\n              });\n              warningIcon.data = { id };\n              text.data = { id };\n              text.position.set(data.position);\n              const group = new Paper.Group();\n              group.addChild(warningIcon);\n              group.addChild(text);\n              this.warningLayer!.addChild(group);\n            }\n            return;\n          }\n          const shapes: paper.Item[] = [];\n          shapeIds!.forEach((shapeId) => {\n            const shape = this.getShapeByKey(id, groupName!, shapeId);\n            if (shape) {\n              shapes.push(shape);\n              if (shape.data.type !== SHAPE_TYPE.RECTANGLE_GROUP) {\n                const { x, y, width, height } = shape.bounds;\n                const boundRect = new Paper.Shape.Rectangle({\n                  point: [x - strokeWitdth, y - strokeWitdth],\n                  size: [width + 2 * strokeWitdth, height + 2 * strokeWitdth],\n                  strokeColor: new Paper.Color('#DC4624'),\n                  strokeWidth: strokeWitdth\n                });\n                this.warningLayer!.addChild(boundRect);\n              }\n            }\n          });\n          let position: number[] = [];\n          if (shapes.length > 1) {\n            const minXList: number[] = [];\n            const maxXList: number[] = [];\n            const minYList: number[] = [];\n            const maxYList: number[] = [];\n            shapes.forEach(({ bounds: { x, y, width, height } }) => {\n              minXList.push(x - strokeWitdth);\n              maxXList.push(x + width + strokeWitdth);\n              minYList.push(y - strokeWitdth);\n              maxYList.push(y + height + strokeWitdth);\n            });\n            const minX = Math.min(...minXList);\n            const maxX = Math.max(...maxXList);\n            const minY = Math.min(...minYList);\n            const maxY = Math.max(...maxYList);\n            const boundRect = new Paper.Shape.Rectangle({\n              point: [minX - 2 * strokeWitdth, minY - 2 * strokeWitdth],\n              size: [maxX - minX + 4 * strokeWitdth, maxY - minY + 4 * strokeWitdth],\n              strokeColor: new Paper.Color('#DC4624'),\n              strokeWidth: strokeWitdth\n            });\n            this.warningLayer!.addChild(boundRect);\n            position = [minX - warningIconSize, minY - warningIconSize];\n          } else if (shapes.length === 1) {\n            position = [shapes[0].bounds.x - warningIconSize, shapes[0].bounds.y - warningIconSize];\n          }\n          if (shapes.length > 0) {\n            const warningIcon = new Paper.Shape.Circle({\n              center: new Paper.Point(position[0], position[1]),\n              radius: warningIconSize,\n              fillColor: '#DC4624',\n            });\n            const text = new Paper.PointText({\n              content: '!',\n              fontSize: FONT_SIZE / this.paperZoom,\n              fontWeight: '700',\n              fillColor: 'white',\n            });\n            warningIcon.data = { instanceId: id, groupName, shapeIds };\n            text.data = { instanceId: id, groupName, shapeIds };\n            text.position.x = position[0];\n            text.position.y = position[1];\n            this.warningLayer!.addChild(warningIcon);\n            this.warningLayer!.addChild(text);\n          }\n        });\n      }\n    }\n  }\n\n  render() {\n    return (\n      <div\n        ref={this.canvasContainer}\n        className=\"canvas\"\n        style={{ cursor: this.cursor }}\n      >\n        <canvas ref={this.canvas} />\n        {this.props.isReview && (\n          <div className=\"layer\">\n            <div className=\"tip\">\n              <span>{formatMessage('ORIGINAL_DATA')}</span>\n              <span>{formatMessage('REVIEW_TIP')}</span>\n              <Button className=\"close\" onClick={this.props.setReview} size=\"small\">\n                {formatMessage('REVIEW_CLOSE', { values: { shortcut: 'Ctrl+V' } })}\n              </Button>\n            </div>\n          </div>\n        )}\n        {(this.props.loading) && (\n          <div className=\"loading\">\n            {!this.raster && <Spin indicator={<LoadingOutlined style={{ fontSize: 100, color: '#00bad3' }} spin />} />}\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default Canvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}