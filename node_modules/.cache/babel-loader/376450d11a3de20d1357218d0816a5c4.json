{"ast":null,"code":"import _applyDecoratedDescriptor from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nvar _class,\n  _class2,\n  _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/components/Canvas.tsx\";\n/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable, computed, reaction } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport { debounce } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { Spin, Button } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool from '../tools/Tool';\nimport { AttributesMode } from '../store/SettingsStore';\nimport rootStore from '../store/RootStore';\nimport formatMessage from '../locales';\nimport { CategoryPathShape, LandmarkEditType, LabelStyle, PathStyles } from '../types';\nimport Cursor from '../../common/Cursor';\nimport { resetAttrLabelPosition, getValuesLabel, resizeLabel } from '../utils';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport './Canvas.scss';\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 12;\nexport const POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  KEYPOINT: 'keypoint',\n  PATH: 'path',\n  KEYPOINT_BOX: 'keypoint_box',\n  INSTANCE: 'instance',\n  GROUP: 'group',\n  RECTANGLE_POINT: 'rectangle_point',\n  RECTANGLE_PATH: 'rectangle_path',\n  RECTANGLE_GROUP: 'rectangle_group',\n  RECTANGLE: 'rectangle',\n  WARNGIN: 'warning'\n};\nvar LabelType = /*#__PURE__*/function (LabelType) {\n  LabelType[\"KEYPOINT\"] = \"keypoint\";\n  LabelType[\"OBJECT\"] = \"object\";\n  return LabelType;\n}(LabelType || {});\nlet Canvas = observer(_class = (_class2 = class Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    this.cursor = Cursor.DEFAULT;\n    this.canvas = React.createRef();\n    this.canvasContainer = React.createRef();\n    this.imageCanvas = void 0;\n    this.imageData = void 0;\n    this.raster = void 0;\n    this.rasterLayer = void 0;\n    this.gridLayer = void 0;\n    this.labelLayer = void 0;\n    this.attrLayer = void 0;\n    this.mainLayer = void 0;\n    this.warningLayer = void 0;\n    this.tool = void 0;\n    this.hits = void 0;\n    this.selectedHit = void 0;\n    this.warningBtn = void 0;\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    this.smoothPath = null;\n    this.shownLabel = null;\n    this.fillOpacity = 0.3;\n    this.resizeObserve = null;\n    this.catchZoom = void 0;\n    this.prevRaster = null;\n    this.resizeDebounced = void 0;\n    this.paperZoom = 1;\n    this.currentWarnings = [];\n    this.resize = (isWindow = false) => {\n      if (this.canvasContainer.current) {\n        // set view size\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n        const viewCenter = new Paper.Point({\n          x: viewWidth / 2,\n          y: viewHeight / 2\n        });\n        if (this.catchZoom) {\n          const {\n            center,\n            zoom\n          } = this.catchZoom;\n          if (isWindow) {\n            Paper.view.center = viewCenter;\n            this.catchZoom.center = viewCenter;\n          } else {\n            Paper.view.center = center;\n          }\n          Paper.view.zoom = zoom;\n        } else {\n          Paper.view.center = viewCenter;\n          Paper.view.zoom = 1;\n        }\n        if (this.imageCanvas && this.raster) {\n          // resize image\n          const {\n            width: imgWidth,\n            height: imgHeight\n          } = this.imageCanvas;\n          const viewRatio = viewWidth / viewHeight;\n          const imgRatio = imgWidth / imgHeight;\n          const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n          const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n          const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n          const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n          // apply matrix to all layers\n          Paper.project.layers.forEach(layer => {\n            layer.matrix = matrix;\n          });\n          // reset image center\n          this.raster.position = new Paper.Point({\n            x: imgWidth / 2,\n            y: imgHeight / 2\n          });\n          this.paperZoom = this.rasterLayer ? Paper.view.zoom * this.rasterLayer.matrix.scaling.x : Paper.view.zoom;\n        }\n        this.resizeContent();\n      }\n    };\n    this.resizeContent = () => {\n      if (this.resizeDebounced) {\n        this.resizeDebounced();\n      } else {\n        this.resizeDebounced = debounce(() => {\n          this.resizeGrid();\n          this.resizeShapes();\n          this.drawWarnings();\n        }, 50);\n      }\n    };\n    this.zoom = (event, zoom) => {\n      if (this.canvasContainer.current) {\n        const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n        const viewPosition = Paper.view.viewToProject(mousePosition);\n        const oldZoom = Paper.view.zoom;\n        const oldCenter = Paper.view.center;\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        let newZoom = event && event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n        newZoom = zoom || newZoom;\n        if (newZoom <= 1) {\n          Paper.view.center = new Paper.Point({\n            x: viewWidth / 2,\n            y: viewHeight / 2\n          });\n        }\n        newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n        if (newZoom !== Paper.view.zoom) {\n          Paper.view.zoom = newZoom;\n          const zoomScale = oldZoom / newZoom;\n          const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n          Paper.view.center = Paper.view.center.add(offset);\n        }\n        this.catchZoom = {\n          zoom: newZoom,\n          center: Paper.view.center\n        };\n        this.paperZoom = newZoom * this.rasterLayer.matrix.scaling.x;\n        this.resizeContent();\n      }\n    };\n    this.drag = center => {\n      this.catchZoom = this.catchZoom ? {\n        ...this.catchZoom,\n        center\n      } : {\n        zoom: Paper.view.zoom,\n        center\n      };\n    };\n    this.fitSelected = (instanceId, groupName) => {\n      const groupBox = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (groupBox && this.mainLayer && this.canvasContainer.current) {\n        const {\n          center,\n          width,\n          height\n        } = groupBox.bounds;\n        if (width === 0 || height === 0) return;\n        const point = this.mainLayer.localToGlobal(center);\n        const {\n          width: viewWidth,\n          height: viewHeight\n        } = this.mainLayer.bounds;\n        let zoom = width / height > viewWidth / viewHeight ? viewWidth / width : viewHeight / height;\n        zoom = Math.min(18, Math.max(zoom, 1));\n        Paper.view.zoom = zoom;\n        Paper.view.center = point;\n        this.catchZoom = {\n          zoom,\n          center: point\n        };\n        this.paperZoom = this.rasterLayer ? zoom * this.rasterLayer.matrix.scaling.x : zoom;\n        this.resizeContent();\n      } else {\n        this.resize();\n      }\n    };\n    this.hitTest = event => {\n      var _this$tool;\n      if (this.mainLayer && !((_this$tool = this.tool) === null || _this$tool === void 0 ? void 0 : _this$tool.mouseDown)) {\n        var _hit;\n        let cursor = Cursor.DEFAULT;\n        const isDrawPoint = this.props.selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT;\n        if (this.canAddShape()) {\n          cursor = isDrawPoint ? Cursor.POINTER : Cursor.CROSSHAIR;\n        }\n        if (this.selectedHit) {\n          this.selectedHit.selected = false;\n        }\n        const hits = this.mainLayer.hitTestAll(event.point, {\n          fill: true,\n          selected: false,\n          handles: true,\n          stroke: true,\n          tolerance: 10 / this.paperZoom,\n          match: ht => {\n            if (ht && ht.item && (ht.item.data.type === undefined || ht.item.data.type === SHAPE_TYPE.KEYPOINT_BOX)) {\n              return false;\n            }\n            return true;\n          }\n        });\n        let hit;\n        for (let i = 0; i < hits.length; i += 1) {\n          const h = hits[i];\n          const {\n            type\n          } = h.item.data;\n          if (!type || type !== SHAPE_TYPE.INSTANCE && type !== SHAPE_TYPE.GROUP && type !== SHAPE_TYPE.KEYPOINT_BOX && type !== SHAPE_TYPE.RECTANGLE_GROUP && (type !== SHAPE_TYPE.PATH || type === SHAPE_TYPE.PATH && ['handle-in', 'handle-out'].includes(h.type))) {\n            // select point | rectangle | rectangle control | path handle\n            if (type === SHAPE_TYPE.RECTANGLE || type === SHAPE_TYPE.RECTANGLE_POINT || type === SHAPE_TYPE.RECTANGLE_PATH) {\n              if (i === 0 && !this.canAddShape()) {\n                hit = h;\n              }\n            } else {\n              hit = h;\n              if (type === SHAPE_TYPE.KEYPOINT) {\n                break;\n              }\n            }\n          }\n        }\n        if (((_hit = hit) === null || _hit === void 0 ? void 0 : _hit.item) && !event.event.ctrlKey) {\n          var _hit$item$data, _hit$item$data2, _hit$item$data3, _hit$item$data4, _hit$item$data5;\n          if (!this.isShapeInSelectedShapes((_hit$item$data = hit.item.data) === null || _hit$item$data === void 0 ? void 0 : _hit$item$data.instanceId, (_hit$item$data2 = hit.item.data) === null || _hit$item$data2 === void 0 ? void 0 : _hit$item$data2.groupName, (_hit$item$data3 = hit.item.data) === null || _hit$item$data3 === void 0 ? void 0 : _hit$item$data3.index) && ((_hit$item$data4 = hit.item.data) === null || _hit$item$data4 === void 0 ? void 0 : _hit$item$data4.index) !== this.props.selectedShapeStatus.id && ((_hit$item$data5 = hit.item.data) === null || _hit$item$data5 === void 0 ? void 0 : _hit$item$data5.id) !== this.props.selectedShapeStatus.id) {\n            this.selectedHit = hit.item;\n            hit.item.selected = true;\n          }\n          if (hit.item.data.cursor) {\n            cursor = hit.item.data.cursor;\n          } else {\n            cursor = Cursor.MOVE;\n          }\n          this.showShapeLabel(hit, event.point);\n        } else if (this.shownLabel) {\n          const {\n            point\n          } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, {\n            x: point[0],\n            y: point[1]\n          }, false);\n        }\n        this.hits = hit;\n        if (this.currentWarnings.length > 0) {\n          var _this$warningLayer;\n          this.warningBtn = (_this$warningLayer = this.warningLayer) === null || _this$warningLayer === void 0 ? void 0 : _this$warningLayer.hitTest(event.point);\n        }\n        if (this.smoothPath) {\n          this.smoothPath.fullySelected = true;\n        }\n        this.setCursor(cursor);\n      }\n    };\n    this.clearHits = () => {\n      this.hits = undefined;\n    };\n    this.updateGroupBox = (instanceId, category, groupName) => {\n      let boundRect = this.getShapeByGroup();\n      const {\n        selectedShapeStatus\n      } = this.props;\n      let isRemovebound = false;\n      if (instanceId && instanceId === selectedShapeStatus.instanceId && groupName === selectedShapeStatus.groupName) {\n        const {\n          ontology,\n          setting: {\n            pointSize,\n            lineWidth,\n            labelItems\n          }\n        } = rootStore;\n        const groupConntainer = this.getGroupContainerByGroupName(instanceId, groupName);\n        const points = groupConntainer && groupConntainer.children.filter(v => v.type === CategoryPathShape.CIRCLE).map(v => [v.position.x, v.position.y]);\n        if (points && points.length > 0) {\n          const xList = points.map(v => v[0]);\n          const yList = points.map(v => v[1]);\n          const minX = Math.min(...xList);\n          const maxX = Math.max(...xList);\n          const minY = Math.min(...yList);\n          const maxY = Math.max(...yList);\n          if (this.mainLayer) {\n            var _instance$children$fi, _groupInfo$label_conf;\n            const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n            if (boundRect) {\n              boundRect.remove();\n            }\n            const range = pointSize * 3 / zoom;\n            const fontSize = FONT_SIZE / this.paperZoom;\n            const strokeWitdth = lineWidth / zoom;\n            boundRect = new Paper.Shape.Rectangle({\n              point: [minX - range, minY - range],\n              size: [maxX - minX + 2 * range, maxY - minY + 2 * range],\n              strokeColor: new Paper.Color('#FFE600'),\n              strokeWidth: strokeWitdth\n            });\n            boundRect.data.type = SHAPE_TYPE.KEYPOINT_BOX;\n            this.mainLayer.addChild(boundRect);\n            const groupInfo = ontology.getGroupData(category, groupName);\n            const instance = this.props.getInstance(instanceId);\n            const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi === void 0 ? void 0 : _instance$children$fi.frames[this.props.currentFrame];\n            const attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf = groupInfo.label_config) === null || _groupInfo$label_conf === void 0 ? void 0 : _groupInfo$label_conf.fields, group === null || group === void 0 ? void 0 : group.attributes, labelItems);\n            const content = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''} ${(instance === null || instance === void 0 ? void 0 : instance.number) || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n            const labelGroup = this.getLabelByKey('', '', 'group_label');\n            const groupAttribute = this.getLabelByKey('', '', 'group_attributes');\n            labelGroup === null || labelGroup === void 0 ? void 0 : labelGroup.remove();\n            groupAttribute === null || groupAttribute === void 0 ? void 0 : groupAttribute.remove();\n            const x = minX - range;\n            const y = minY - range - strokeWitdth * 2;\n            const w = maxX - minX + 2 * range;\n            const h = maxY - minY + 2 * range;\n            this.addLabel(content, {\n              x,\n              y,\n              width: w,\n              height: h\n            }, {\n              instanceId: '',\n              category: '',\n              groupName: ''\n            }, 'group_label', true, SHAPE_TYPE.KEYPOINT_BOX);\n            this.addLabel(attrsLabel, {\n              x,\n              y: y - fontSize * 1.5,\n              width: w,\n              height: h\n            }, {\n              instanceId: '',\n              category: '',\n              groupName: ''\n            }, 'group_attributes', true, SHAPE_TYPE.KEYPOINT_BOX);\n          }\n        } else {\n          isRemovebound = true;\n        }\n      } else {\n        isRemovebound = true;\n      }\n      if (isRemovebound && boundRect) {\n        boundRect.remove();\n        this.removeLabel('', '', 'group_label');\n        this.removeLabel('', '', 'group_attributes');\n      }\n    };\n    makeObservable(this, {\n      cursor: observable,\n      setCursor: action\n    });\n    reaction(() => rootStore.review.qaWarnings, () => {\n      this.drawWarnings();\n    });\n\n    // change frame & undo & redo to update points\n    reaction(() => rootStore.shape.updatedShapes, () => {\n      this.updateShapes();\n      this.drawWarnings();\n    });\n  }\n  get activeTool() {\n    var _this$props$ontologyG;\n    let tool = '';\n    switch ((_this$props$ontologyG = this.props.ontologyGroup) === null || _this$props$ontologyG === void 0 ? void 0 : _this$props$ontologyG.type) {\n      case LandmarkEditType.KEYPOINT:\n        tool = CategoryPathShape.CIRCLE;\n        break;\n      case LandmarkEditType.RECTANGLE:\n        tool = CategoryPathShape.RECTANGLE;\n        break;\n      default:\n        break;\n    }\n    return tool;\n  }\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', e => e.preventDefault(), false);\n    }\n    if (this.canvasContainer.current) {\n      this.resizeObserve = new ResizeObserver(() => {\n        this.resize(true);\n      });\n      this.resizeObserve.observe(this.canvasContainer.current);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.image !== this.props.image) {\n      this.loadImage();\n    }\n\n    // default instances\n    if (JSON.stringify(prevProps.defaultInstances) !== JSON.stringify(this.props.defaultInstances)) {\n      const defaultInstances = Object.values(this.props.defaultInstances).filter(instance => instance && !prevProps.defaultInstances[instance.id]);\n      if (defaultInstances.length > 0) {\n        defaultInstances.forEach(instance => {\n          var _this$mainLayer;\n          const instanceContainer = new Paper.Group();\n          (_this$mainLayer = this.mainLayer) === null || _this$mainLayer === void 0 ? void 0 : _this$mainLayer.addChild(instanceContainer);\n          instanceContainer.data = {\n            instanceId: instance.id,\n            category: instance.category,\n            type: SHAPE_TYPE.INSTANCE\n          };\n          instance.children.forEach(group => {\n            const groupContainer = new Paper.Group();\n            groupContainer.data = {\n              groupName: group.name,\n              type: SHAPE_TYPE.GROUP,\n              instanceId: instance.id,\n              category: instance.category,\n              displayColor: instance.displayColor || POINT_COLOR\n            };\n            instanceContainer.addChild(groupContainer);\n          });\n        });\n      }\n    }\n    if (JSON.stringify(prevProps.updatedCategories) !== JSON.stringify(this.props.updatedCategories) && this.props.updatedCategories.length > 0) {\n      this.props.updatedCategories.forEach(({\n        pointCategory,\n        frameIndex,\n        instanceId,\n        groupName,\n        category\n      }) => {\n        if (frameIndex === this.props.currentFrame) {\n          const container = {\n            instanceId,\n            groupName,\n            category\n          };\n          const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n        }\n      });\n      this.props.onCategoriesUpdated();\n    }\n\n    // selected changes\n    const isSelectedChange = JSON.stringify(prevProps.selectedShapeStatus) !== JSON.stringify(this.props.selectedShapeStatus);\n    if (isSelectedChange) {\n      if (this.selectedPoints.length <= 0 || this.selectedRectangles.length <= 0) {\n        if (prevProps.selectedShapeStatus && prevProps.selectedShapeStatus.id !== undefined) {\n          const {\n            instanceId,\n            groupName,\n            id,\n            shapeType\n          } = prevProps.selectedShapeStatus;\n          if (!this.isShapeInSelectedShapes(instanceId, groupName, id)) {\n            if (shapeType === LandmarkEditType.KEYPOINT) {\n              this.setPointSelected(instanceId, groupName, id, false);\n            } else {\n              this.selectShape(instanceId, groupName, id, false);\n            }\n          }\n        }\n      }\n      const {\n        instanceId,\n        groupName,\n        id,\n        shapeType\n      } = this.props.selectedShapeStatus;\n      if (id !== undefined) {\n        this.setMultiShapesUnselected();\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          this.setPointSelected(instanceId, groupName, id, true);\n        } else {\n          this.selectShape(instanceId, groupName, id);\n        }\n      }\n    }\n    if ((prevProps.selectedShapeInfo || {}).pointCategory !== (this.props.selectedShapeInfo || {}).pointCategory) {\n      this.setSmooth(null);\n      if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n        this.setSelectedCurves();\n      }\n    }\n    if (this.props.selectedInstance && (isSelectedChange || JSON.stringify(this.props.selectedInstance) !== JSON.stringify(prevProps.selectedInstance))) {\n      const {\n        instanceId,\n        category,\n        groupName\n      } = this.props.selectedShapeStatus;\n      this.updateGroupBox(instanceId, category, groupName);\n    }\n  }\n  componentWillUnmount() {\n    if (this.resizeObserve) {\n      this.resizeObserve.disconnect();\n      this.resizeObserve = null;\n    }\n  }\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = true;\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = rootStore.setting.isGridVisible;\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n    this.attrLayer = new Paper.Layer();\n    this.attrLayer.applyMatrix = false;\n    this.attrLayer.visible = false;\n    this.warningLayer = new Paper.Layer();\n    this.warningLayer.applyMatrix = false;\n    this.warningLayer.visible = false;\n    Paper.view.onMouseMove = this.hitTest;\n  }\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n  loadImage() {\n    if (this.rasterLayer && this.props.image) {\n      this.rasterLayer.activate();\n      this.props.changeLoading(true);\n      if (this.raster) {\n        this.prevRaster = this.raster;\n      }\n      imageLoader(this.props.image, c => {\n        var _canvas$getContext;\n        const canvas = c;\n        this.imageCanvas = canvas;\n        this.imageData = (_canvas$getContext = canvas.getContext('2d')) === null || _canvas$getContext === void 0 ? void 0 : _canvas$getContext.getImageData(0, 0, canvas.width, canvas.height);\n        this.raster = new Paper.Raster(canvas);\n        this.raster.visible = false;\n        this.raster.onLoad = () => {\n          var _this$gridLayer, _this$gridLayer$child;\n          if (!((_this$gridLayer = this.gridLayer) === null || _this$gridLayer === void 0 ? void 0 : (_this$gridLayer$child = _this$gridLayer.children) === null || _this$gridLayer$child === void 0 ? void 0 : _this$gridLayer$child.length)) {\n            this.labelLayer.visible = rootStore.setting.labelMode;\n            this.mainLayer.visible = true;\n            this.warningLayer.visible = true;\n            this.attrLayer.visible = true;\n          }\n          this.addGrid(); // add grid to image\n          this.resize(); // resize to fit the container\n          // when onload, show all layers\n          this.raster.visible = true;\n          if (this.prevRaster) {\n            this.prevRaster.remove();\n          }\n          this.props.changeLoading(false);\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous'\n      });\n    }\n  }\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const {\n        brightness,\n        contrast,\n        saturation,\n        lightness,\n        hue,\n        rescale\n      } = rootStore.setting.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      this.gridLayer.removeChildren();\n      const {\n        width,\n        height\n      } = this.imageCanvas;\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({\n        length: rows\n      }).forEach((_, index) => {\n        var _this$gridLayer2;\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer2 = this.gridLayer) === null || _this$gridLayer2 === void 0 ? void 0 : _this$gridLayer2.addChild(path);\n      });\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({\n        length: cols\n      }).forEach((_, index) => {\n        var _this$gridLayer3;\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer3 = this.gridLayer) === null || _this$gridLayer3 === void 0 ? void 0 : _this$gridLayer3.addChild(path);\n      });\n    }\n  }\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach(path => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n  isShapeInSelectedShapes(instanceId, groupName, index) {\n    return this.selectedPoints.findIndex(p => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0 || this.selectedRectangles.findIndex(p => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0;\n  }\n  isPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const {\n      bounds: {\n        x,\n        y,\n        width,\n        height\n      }\n    } = this.rasterLayer;\n    return localPoint.x >= 0 && localPoint.x <= x + width && localPoint.y >= 0 && localPoint.y <= y + height;\n  }\n  getPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n     if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n  getInstanceContainerByInstaceId(instaceId) {\n    var _this$mainLayer2;\n    return (_this$mainLayer2 = this.mainLayer) === null || _this$mainLayer2 === void 0 ? void 0 : _this$mainLayer2.children.find(i => i.data.type === SHAPE_TYPE.INSTANCE && i.data.instanceId === instaceId);\n  }\n  getGroupContainerByGroupName(instaceId, groupName) {\n    const instance = this.getInstanceContainerByInstaceId(instaceId);\n    return instance === null || instance === void 0 ? void 0 : instance.children.find(g => g.data.type === SHAPE_TYPE.GROUP && g.data.groupName === groupName);\n  }\n  getShapeByKey(instaceId, groupName, key) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.RECTANGLE_GROUP && p.data.id === key || p.data.type === SHAPE_TYPE.KEYPOINT && p.data.index === key);\n  }\n  getLabelByKey(instanceId, groupName, key) {\n    var _this$labelLayer;\n    return (_this$labelLayer = this.labelLayer) === null || _this$labelLayer === void 0 ? void 0 : _this$labelLayer.children.find(l => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === key);\n  }\n  getAttrLabelByKey(instanceId, groupName, key) {\n    var _this$attrLayer;\n    return (_this$attrLayer = this.attrLayer) === null || _this$attrLayer === void 0 ? void 0 : _this$attrLayer.children.find(l => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === `attr-${key}`);\n  }\n  getShapeByGroup() {\n    var _this$mainLayer3;\n    return (_this$mainLayer3 = this.mainLayer) === null || _this$mainLayer3 === void 0 ? void 0 : _this$mainLayer3.children.find(l => l.data.type === SHAPE_TYPE.KEYPOINT_BOX);\n  }\n  getPathByCategory(instaceId, groupName, pointCategory) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.PATH && p.data.pointCategory === pointCategory);\n  }\n  getPathById(instaceId, groupName, pathId) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.find(p => p.data.type === SHAPE_TYPE.PATH && p.data.id === pathId);\n  }\n  getPointsByCategory(instaceId, groupName, pointCategory) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group === null || group === void 0 ? void 0 : group.children.filter(p => p.data.type === SHAPE_TYPE.KEYPOINT && p.data.pointCategory === pointCategory);\n  }\n  canAddShape() {\n    if (this.props.isReview || this.props.readonly || !rootStore.review.drawMode) return false;\n    if (this.mainLayer && this.props.selectedShapeInfo) {\n      if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.RECTANGLE) {\n        if (this.props.ontologyGroup && this.props.ontologyGroup.count > 0) {\n          return this.props.annotatedPointOrShapeCount < this.props.ontologyGroup.count;\n        }\n      } else if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.KEYPOINT) {\n        const {\n          instanceId,\n          groupName,\n          id\n        } = this.props.selectedShapeStatus;\n        if (id === undefined || id < 0) return false;\n        const point = this.getShapeByKey(instanceId, groupName, id);\n        return !point;\n      }\n    }\n    return false;\n  }\n  containerAddPoint(groupData, point, pointCategory, index, isKeyPoint, visible = true, attributes) {\n    const {\n      instanceId,\n      groupName\n    } = groupData;\n    const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n    this.addKeypointShape(point, pointCategory, index, isKeyPoint, groupContainer, visible, attributes);\n  }\n  addKeypoint(point) {\n    if (this.mainLayer && this.props.selectedShapeInfo && this.props.selectedShapeStatus && this.props.selectedInstance) {\n      const {\n        id,\n        shapeType,\n        frameIndex\n      } = this.props.selectedShapeStatus;\n      const index = shapeType === LandmarkEditType.KEYPOINT && id || 0;\n      const {\n        x,\n        y\n      } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory,\n        isKeyPoint\n      } = this.props.selectedShapeInfo;\n      const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n      const groupData = {\n        instanceId,\n        groupName,\n        type: LandmarkEditType.KEYPOINT,\n        category: this.props.selectedInstance.category\n      };\n      this.containerAddPoint(groupData, newPoint, pointCategory, index, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n        const container = {\n          instanceId,\n          category,\n          groupName\n        };\n        otherPoints = this.updateCirclePath(pointCategory, true, container);\n      }\n      this.props.handleShapesChange([{\n        frameIndex,\n        instanceId,\n        category,\n        groupName,\n        index,\n        shapeType: LandmarkEditType.KEYPOINT,\n        shape: {\n          pointCategory,\n          isKeyPoint,\n          position: {\n            x,\n            y\n          },\n          visible: true // default is visible when point added\n        }\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyShape(); // move next\n    }\n  }\n  addKeypointShape(point, pointCategory, pointIndex, isKeyPoint, groupContainer, visible, attributes) {\n    if (!groupContainer) return;\n    const {\n      frameIndex\n    } = this.props.selectedShapeStatus;\n    const {\n      instanceId,\n      groupName,\n      category,\n      displayColor\n    } = groupContainer.data;\n    if (this.mainLayer) {\n      var _groupInfo$point_labe;\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : displayColor || POINT_COLOR;\n      const fillColor = visible ? pointColor : '#3d424d';\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: (rootStore.setting.pointSize + 1) / zoom,\n        fillColor,\n        strokeColor: '#ffffff',\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white'\n      });\n      pointCircle.data = {\n        frameIndex,\n        type: SHAPE_TYPE.KEYPOINT,\n        cursor: Cursor.MOVE,\n        pointCategory,\n        index: pointIndex,\n        isKeyPoint,\n        visible,\n        instanceId,\n        groupName,\n        category,\n        fillColor\n      };\n      groupContainer.addChild(pointCircle);\n\n      // add point to path\n      const groupData = rootStore.ontology.getGroupData(category, groupName);\n      const categoryData = groupData && groupData.categories && groupData.categories.find(v => v.name === pointCategory) || undefined;\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      const lineColor = (categoryData === null || categoryData === void 0 ? void 0 : categoryData.isConnect) === false ? new Paper.Color('rgba(0,0,0,0)') : new Paper.Color(displayColor || POINT_COLOR);\n      let index = -1;\n      if (path) {\n        const {\n          points,\n          isCircle\n        } = path.data;\n        if (!isCircle) {\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            for (let i = 0; i < points.length; i += 1) {\n              const p = points[i];\n              const nextP = points[i + 1];\n              if (pointIndex > p && nextP > pointIndex) {\n                // 2 => 1,3\n                index = i + 1;\n                break;\n              } else if (pointIndex < p && (!nextP || nextP > p || nextP < p && i !== 0)) {\n                // 9 => 10 || 10,18 || 10,5(end point)[not (end point)10,5]\n                index = i;\n                break;\n              }\n            }\n          } else {\n            index = path.data.points.findIndex(p => pointIndex < p);\n          }\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: rootStore.setting.lineWidth / zoom,\n          strokeColor: lineColor,\n          selectedColor: lineColor\n        });\n        path.data = {\n          type: SHAPE_TYPE.PATH,\n          pointCategory,\n          points: [pointIndex],\n          instanceId,\n          groupName,\n          id: `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`\n        };\n        groupContainer.addChild(path);\n      }\n      this.toggleCurves(path);\n      if (path === this.smoothPath) {\n        this.setSmooth(path);\n      }\n      if (groupData && groupData.lines) {\n        const lines = groupData.lines.filter(v => v.points.indexOf(pointIndex) >= 0);\n        const linesData = [];\n        lines.forEach(connectPoints => {\n          if (connectPoints) {\n            const {\n              points,\n              color\n            } = connectPoints;\n            const isSource = pointIndex === points[0];\n            const otherEnd = this.getShapeByKey(instanceId, groupName, isSource ? points[1] : points[0]);\n            const fromTo = `${points[0]}-${points[1]}`;\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              if (otherEnd) {\n                const {\n                  pointCategory: otherCategory\n                } = otherEnd.data;\n                const [startPoint, endPoint] = isSource ? [pointCircle, otherEnd] : [otherEnd, pointCircle];\n                const endSegment = new Paper.Segment(new Paper.Point(endPoint.position.x, endPoint.position.y));\n                const line = isSource ? path : this.getPathByCategory(instanceId, groupName, otherCategory !== pointCategory ? otherCategory : '');\n                if (line) {\n                  const sourceIndex = line.data.points.findIndex(p => points[0] === p);\n                  if (sourceIndex === 0) {\n                    line.insert(0, endSegment);\n                    line.data.points.unshift(points[1]);\n                  } else if (sourceIndex === line.data.points.length - 1) {\n                    line.add(endSegment);\n                    line.data.points.push(points[1]);\n                  }\n                  this.toggleCurves(line);\n                  if (!endPoint.data.lines) {\n                    endPoint.data.lines = [];\n                  }\n                  endPoint.data.lines.push({\n                    isSource: false,\n                    fromTo,\n                    pathId: line.data.id\n                  });\n                  startPoint.data.lines = [...(startPoint.data.lines || []), {\n                    isSource: true,\n                    fromTo,\n                    pathId: line.data.id\n                  }];\n                }\n              }\n            } else {\n              linesData.push({\n                isSource,\n                fromTo,\n                pathId: fromTo\n              });\n              if (otherEnd) {\n                const segments = isSource ? [segment, otherEnd.position] : [otherEnd.position, segment];\n                const line = new Paper.Path({\n                  segments,\n                  strokeWidth: rootStore.setting.lineWidth / zoom,\n                  strokeColor: color,\n                  selectedColor: color\n                });\n                line.data = {\n                  type: SHAPE_TYPE.PATH,\n                  pointCategory: fromTo,\n                  points,\n                  instanceId,\n                  groupName,\n                  id: fromTo\n                };\n                groupContainer.addChild(line);\n              }\n            }\n          }\n        });\n        if (rootStore.setting.pathStyle !== PathStyles.CURVES) {\n          pointCircle.data.lines = linesData;\n        }\n      }\n      path.sendToBack();\n      const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n      const label = `${visible ? 1 : 0}-${pointIndex}`;\n      let attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$point_labe = groupInfo.point_label_config) === null || _groupInfo$point_labe === void 0 ? void 0 : _groupInfo$point_labe.fields, attributes, rootStore.setting.labelItems);\n      attrsLabel = `${rootStore.setting.displayPointIndex ? `${pointIndex}` : ''}${rootStore.setting.displayPointIndex && attrsLabel ? ';' : ''}${attrsLabel}`;\n      this.addLabel(label, {\n        x: point.x,\n        y: point.y,\n        width: rootStore.setting.pointSize / zoom,\n        height: rootStore.setting.pointSize / zoom\n      }, {\n        instanceId,\n        category,\n        groupName\n      }, pointIndex, visible, SHAPE_TYPE.KEYPOINT, attrsLabel);\n    }\n  }\n  removePointShape(containerData, pointIndex) {\n    const {\n      instanceId,\n      groupName\n    } = containerData;\n    if (this.mainLayer) {\n      const point = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (point) {\n        const {\n          lines,\n          pointCategory\n        } = point.data;\n        point.remove();\n        // remove pointCategory path\n        const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n        if (path && !path.data.isCircle) {\n          const index = path.data.points.findIndex(p => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n        // remove group connect path\n        if (lines) {\n          lines.forEach(({\n            pathId,\n            fromTo,\n            isSource\n          }) => {\n            const line = this.getPathById(instanceId, groupName, pathId);\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              let index = line === null || line === void 0 ? void 0 : line.data.points.findIndex(p => p === pointIndex);\n              if (isSource && index < 0) {\n                index = line.data.points.findIndex(p => p === Number(fromTo.split('-')[1] || -1));\n              }\n              if (index >= 0) {\n                line.removeSegment(index);\n                line.data.points.splice(index, 1);\n                this.toggleCurves(line);\n              }\n            } else {\n              line === null || line === void 0 ? void 0 : line.remove();\n            }\n          });\n        }\n      }\n    }\n    this.removeLabel(instanceId, groupName, pointIndex);\n  }\n  resizeShapes() {\n    var _this$labelLayer2, _this$attrLayer2;\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      this.mainLayer.children.forEach(instance => {\n        if (instance.children && instance.children.length > 0) {\n          instance.children.forEach(group => {\n            if (group.children) {\n              group.children.forEach(path => {\n                if (path.data.type === SHAPE_TYPE.KEYPOINT) {\n                  path.set({\n                    radius: rootStore.setting.pointSize / this.paperZoom\n                  });\n                  path.strokeWidth = 1 / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.PATH) {\n                  path.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.RECTANGLE_GROUP && path.children) {\n                  path.children.forEach(shape => {\n                    if (shape.data.type === SHAPE_TYPE.RECTANGLE_POINT) {\n                      shape.set({\n                        radius: rootStore.setting.pointSize / 2 / this.paperZoom\n                      });\n                    } else if (shape.data.type === SHAPE_TYPE.RECTANGLE_PATH) {\n                      shape.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                    }\n                  });\n                }\n              });\n            }\n          });\n        } else if (instance.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          instance.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n        }\n      });\n    }\n    if (((_this$labelLayer2 = this.labelLayer) === null || _this$labelLayer2 === void 0 ? void 0 : _this$labelLayer2.children) && this.labelLayer.children.length > 0) {\n      this.labelLayer.children.forEach(label => {\n        const {\n          zoom: oldZoom,\n          width,\n          height,\n          point\n        } = label.data;\n        resizeLabel({\n          width,\n          height,\n          zoom: this.paperZoom,\n          fontSize: FONT_SIZE\n        }, oldZoom, point, label, 'label');\n      });\n    }\n    if (((_this$attrLayer2 = this.attrLayer) === null || _this$attrLayer2 === void 0 ? void 0 : _this$attrLayer2.children) && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach(label => {\n        const {\n          zoom: oldZoom,\n          width,\n          height,\n          point\n        } = label.data;\n        resizeLabel({\n          width,\n          height,\n          zoom: this.paperZoom,\n          fontSize: FONT_SIZE\n        }, oldZoom, point, label, 'attr');\n      });\n    }\n    const {\n      instanceId,\n      groupName,\n      id\n    } = this.props.selectedShapeStatus;\n    this.setPointSelected(instanceId, groupName, id, true);\n  }\n  cleanLayer() {\n    if (this.mainLayer) {\n      var _this$mainLayer$child;\n      (_this$mainLayer$child = this.mainLayer.children) === null || _this$mainLayer$child === void 0 ? void 0 : _this$mainLayer$child.forEach(container => {\n        if (container.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          container.remove();\n        } else {\n          var _container$children;\n          (_container$children = container.children) === null || _container$children === void 0 ? void 0 : _container$children.forEach(group => {\n            group === null || group === void 0 ? void 0 : group.removeChildren();\n          });\n        }\n      });\n    }\n    if (this.labelLayer) {\n      this.labelLayer.removeChildren();\n    }\n    if (this.attrLayer) {\n      this.attrLayer.removeChildren();\n    }\n    if (this.warningLayer) {\n      this.warningLayer.removeChildren();\n    }\n  }\n  addLabel(content, shape, groupInfo, key, visible, shapeType, attrsLabel) {\n    if (this.labelLayer) {\n      const {\n        instanceId,\n        groupName\n      } = groupInfo;\n      const fontSize = FONT_SIZE / this.paperZoom;\n      const label = new Paper.PointText({\n        content,\n        fontSize,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#000000',\n        shadowBlur: 2 / this.paperZoom,\n        shadowOffset: 2 / this.paperZoom\n      });\n      const width = label.bounds.width + fontSize / 2;\n      const height = label.bounds.height + fontSize / 2;\n      const labelRect = new Paper.Shape.Rectangle({\n        size: [width, height],\n        fillColor: rootStore.setting.labelBgColor\n      });\n      label.position.x = labelRect.bounds.width / 2;\n      label.position.y = labelRect.bounds.height / 2;\n      const labelGroup = new Paper.Group();\n      labelGroup.data = {\n        point: [shape.x, shape.y],\n        instanceId,\n        groupName,\n        key,\n        type: shapeType === SHAPE_TYPE.KEYPOINT ? LabelType.KEYPOINT : LabelType.OBJECT,\n        zoom: this.paperZoom,\n        height,\n        width\n      };\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        labelGroup.addChild(labelRect);\n      }\n      labelGroup.addChild(label);\n      this.labelLayer.addChild(labelGroup);\n      labelGroup.position.x = shape.x + labelRect.bounds.width / 2;\n      labelGroup.position.y = shape.y - labelRect.bounds.height / 2 - rootStore.setting.lineWidth / this.paperZoom;\n      if (shapeType !== SHAPE_TYPE.KEYPOINT_BOX && this.attrLayer) {\n        let center = {\n          x: shape.x,\n          y: shape.y\n        };\n        if (SHAPE_TYPE.RECTANGLE) {\n          center = {\n            x: shape.x + shape.width / 2,\n            y: shape.y + shape.height / 2\n          };\n        }\n        const arrtLabelGroup = labelGroup.clone();\n        arrtLabelGroup.data.key = `attr-${arrtLabelGroup.data.key}`;\n        arrtLabelGroup.data.point = [center.x, center.y];\n        arrtLabelGroup.children.slice(-1)[0].fillColor = new Paper.Color('#ffffff');\n        arrtLabelGroup.children.slice(-1)[0].content = '';\n        this.attrLayer.addChild(arrtLabelGroup);\n        if (attrsLabel) {\n          this.updateLabelContent(arrtLabelGroup, attrsLabel, shapeType);\n        } else {\n          arrtLabelGroup.visible = false;\n        }\n      }\n    }\n  }\n  updateLabel(instanceId, groupName, key, position, center) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [position.x, position.y];\n        label.position.x = position.x + label.bounds.width / 2;\n        label.position.y = position.y - label.bounds.height / 2;\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [center.x, center.y];\n        label.position.x = center.x;\n        label.position.y = center.y;\n      }\n    }\n  }\n  updateAttributeLabel(instanceId, category, groupName, key, attributes, instanceNum) {\n    const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n    let label = '';\n    if (typeof key === 'number') {\n      var _groupInfo$point_labe2;\n      label = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$point_labe2 = groupInfo.point_label_config) === null || _groupInfo$point_labe2 === void 0 ? void 0 : _groupInfo$point_labe2.fields, attributes, rootStore.setting.pointLabelItems);\n      label = `${rootStore.setting.displayPointIndex ? `${key}` : ''}${rootStore.setting.displayPointIndex && label ? ';' : ''}${label}`;\n    } else {\n      var _groupInfo$label_conf2;\n      const categoryLabel = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''}  ${instanceNum || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n      label = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf2 = groupInfo.label_config) === null || _groupInfo$label_conf2 === void 0 ? void 0 : _groupInfo$label_conf2.fields, attributes, rootStore.setting.labelItems);\n      label = `${rootStore.setting.displayCategory ? `${categoryLabel}` : ''}${rootStore.setting.displayCategory && label ? ';' : ''}${label}`;\n    }\n    const attrLayer = this.getAttrLabelByKey(instanceId, groupName, key);\n    if (attrLayer) {\n      if (label) {\n        this.updateLabelContent(attrLayer, label, SHAPE_TYPE.KEYPOINT);\n      } else {\n        attrLayer.visible = false;\n      }\n    }\n  }\n  updateLabelContent(label, content, shapeType) {\n    if (this.attrLayer && label) {\n      const zoom = Paper.view.zoom * this.attrLayer.matrix.scaling.x;\n      const labelText = label.children.slice(-1)[0];\n      labelText.content = content;\n      const {\n        width,\n        height\n      } = labelText.bounds;\n      const fontSize = FONT_SIZE / zoom;\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        label.children[0].size.height = height + fontSize / 2;\n        label.children[0].size.width = width + fontSize / 2;\n      }\n      label.data.width = label.children[0].bounds.width;\n      label.data.height = label.children[0].bounds.height;\n      label.data.zoom = this.paperZoom;\n      let visible = false;\n      if (shapeType === SHAPE_TYPE.KEYPOINT) {\n        visible = rootStore.setting.activePointAttributesMode === AttributesMode.ALWAYS;\n      } else if (SHAPE_TYPE.RECTANGLE) {\n        visible = rootStore.setting.activeAttributesMode === AttributesMode.ALWAYS;\n      }\n      if (visible) {\n        const {\n          point\n        } = label.data;\n        resetAttrLabelPosition(label, {\n          x: point[0],\n          y: point[1]\n        }, visible);\n      } else {\n        label.visible = false;\n      }\n    }\n  }\n  updatelabelVisible(activeMode, type = 'object') {\n    var _this$attrLayer3;\n    if (this.shownLabel) {\n      this.shownLabel.visible = false;\n      this.shownLabel = null;\n    }\n    if (((_this$attrLayer3 = this.attrLayer) === null || _this$attrLayer3 === void 0 ? void 0 : _this$attrLayer3.children) && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach(label => {\n        const {\n          type: labelType\n        } = label.data;\n        if (type === labelType) {\n          label.visible = activeMode === AttributesMode.ALWAYS;\n        }\n      });\n    }\n  }\n  removeLabel(instanceId, groupName, key) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n  updateShapes() {\n    const {\n      currentFrame\n    } = this.props;\n    const {\n      shape: {\n        updatedShapes\n      }\n    } = rootStore;\n    updatedShapes.forEach(updatedShape => {\n      if (updatedShape.frameIndex !== currentFrame) return;\n      switch (updatedShape.shapeType) {\n        case LandmarkEditType.KEYPOINT:\n          this.updatePoint(updatedShape);\n          break;\n        case LandmarkEditType.RECTANGLE:\n          this.updateRectangle(updatedShape);\n          break;\n        default:\n          break;\n      }\n    });\n    rootStore.shape.setUpdatedShapes([]);\n    const {\n      instanceId,\n      category,\n      groupName\n    } = this.props.selectedShapeStatus;\n    this.updateGroupBox(instanceId, category, groupName);\n  }\n  updateRectangle(updateShape) {\n    const {\n      instanceId,\n      groupName,\n      category,\n      id,\n      shape\n    } = updateShape;\n    if (id !== undefined) {\n      const rectangle = shape;\n      const currRectangle = this.getShapeByKey(instanceId, groupName, id);\n      if (currRectangle) {\n        // alreay exist, should update\n        if (rectangle === undefined) {\n          // delete\n          this.removeRectangle(instanceId, groupName, id);\n        } else if (rectangle.x) {\n          const {\n            x,\n            y,\n            width,\n            height,\n            displayColor\n          } = rectangle;\n          // update position\n          this.drawRectangle({\n            x,\n            y,\n            width,\n            height,\n            displayColor\n          }, {\n            instanceId,\n            category,\n            groupName\n          }, id);\n        }\n      } else if (rectangle) {\n        //  has been removed, should add\n        const {\n          x,\n          y,\n          width,\n          height,\n          displayColor\n        } = rectangle;\n        const path = new Paper.Path();\n        path.data.id = id;\n        path.add(new Paper.Point(x, y));\n        path.add(new Paper.Point(x + width, y));\n        path.add(new Paper.Point(x + width, y + height));\n        path.add(new Paper.Point(x, y + height));\n        path.closed = true;\n        this.addRectangle(path, {\n          instanceId,\n          groupName,\n          category,\n          shapeType: LandmarkEditType.RECTANGLE,\n          displayColor\n        }, false);\n      }\n    }\n  }\n  updatePoint(updateShape) {\n    const {\n      frameIndex,\n      instanceId,\n      groupName,\n      category,\n      index,\n      shape\n    } = updateShape;\n    if (index !== undefined) {\n      let updatedCategorie;\n      const point = shape;\n      const currPoint = this.getShapeByKey(instanceId, groupName, index);\n      if (currPoint) {\n        const currCategory = currPoint.data.pointCategory;\n        updatedCategorie = {\n          pointCategory: currCategory,\n          frameIndex,\n          instanceId,\n          groupName,\n          category\n        };\n        const groupData = {\n          frameIndex,\n          instanceId,\n          category,\n          groupName\n        };\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(groupData, index);\n        } else if (point.position && point.pointCategory) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          this.updatePath(currPoint, point.position);\n          // update visible\n          if (point.visible !== undefined && currPoint.data.visible !== point.visible) {\n            this.changeVisibleStyle(currPoint, index, groupData, point.visible);\n          }\n          if (rootStore.setting.activePointAttributesMode !== AttributesMode.HIDE) {\n            this.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const {\n          position,\n          pointCategory,\n          isKeyPoint,\n          visible,\n          attributes\n        } = point;\n        if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          updatedCategorie = {\n            pointCategory,\n            frameIndex,\n            instanceId,\n            groupName,\n            category\n          };\n          const groupData = {\n            instanceId,\n            groupName,\n            type: LandmarkEditType.KEYPOINT,\n            category\n          };\n          this.containerAddPoint(groupData, new Paper.Point(position.x, position.y), pointCategory, index, isKeyPoint, visible, attributes);\n        }\n      }\n      if (updatedCategorie) {\n        const {\n          pointCategory,\n          ...newContainer\n        } = updatedCategorie;\n        const categoryKey = `${frameIndex}_${newContainer.instanceId}_${newContainer.groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, newContainer);\n        }\n      }\n    }\n  }\n  updatePath(point, position) {\n    const {\n      instanceId,\n      groupName,\n      pointCategory,\n      index,\n      lines\n    } = point.data;\n    const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n    if (path && !path.data.isCircle) {\n      const segmentIndex = path.data.points.findIndex(p => p === index);\n      path.segments[segmentIndex].point.x = position.x;\n      path.segments[segmentIndex].point.y = position.y;\n      this.toggleCurves(path);\n    }\n    // change connect line position\n    if (lines) {\n      lines.forEach(({\n        isSource,\n        pathId\n      }) => {\n        const line = this.getPathById(instanceId, groupName, pathId);\n        if (line) {\n          let n = -1;\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            n = !isSource ? line.data.points.findIndex(p => p === index) : -1;\n          } else {\n            n = isSource ? 0 : 1;\n            if (!line.segments[n]) {\n              n = 0;\n            }\n          }\n          if (n >= 0) {\n            line.segments[n].point.x = position.x;\n            line.segments[n].point.y = position.y;\n            this.toggleCurves(line);\n          }\n        }\n      });\n    }\n    this.updateLabel(instanceId, groupName, index, position, position);\n  }\n  setPointSelected(instanceId, groupName, index, selected) {\n    var _this$mainLayer4;\n    if (((_this$mainLayer4 = this.mainLayer) === null || _this$mainLayer4 === void 0 ? void 0 : _this$mainLayer4.children) && this.mainLayer.children.length > 0) {\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      if (point) {\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          point.strokeWidth = 3 / zoom;\n          point.radius = (rootStore.setting.pointSize + 1) / zoom;\n        } else {\n          point.radius = rootStore.setting.pointSize / zoom;\n          point.strokeWidth = 1 / zoom;\n        }\n      }\n    }\n  }\n  setMultiShapesSelected(selectedShapes, type) {\n    if (selectedShapes.length > 0) {\n      const {\n        instanceId,\n        groupName\n      } = selectedShapes[0].data;\n      this.props.selectGroup(instanceId, groupName, false);\n      this.props.setSelectedShape(undefined);\n    }\n    if (type === CategoryPathShape.CIRCLE) {\n      this.selectedPoints = selectedShapes.sort((a, b) => a.data.index - b.data.index);\n      rootStore.shape.setMultiSelectedShape(this.selectedPoints.map(point => point.data.index));\n      this.selectedPoints.forEach(point => {\n        const pData = point.data;\n        this.setPointSelected(pData.instanceId, pData.groupName, pData.index, true);\n      });\n    } else {\n      this.selectedRectangles = selectedShapes;\n      this.selectedRectangles.forEach(rectangle => {\n        const rData = rectangle.data;\n        this.selectShape(rData.instanceId, rData.groupName, rData.id);\n      });\n    }\n  }\n  setMultiShapesUnselected() {\n    this.selectedPoints.forEach(point => {\n      const {\n        instanceId,\n        groupName,\n        index\n      } = point.data;\n      this.setPointSelected(instanceId, groupName, index, false);\n    });\n    this.selectedRectangles.forEach(rectangle => {\n      const {\n        instanceId,\n        groupName,\n        id\n      } = rectangle.data;\n      this.selectShape(instanceId, groupName, id, false);\n    });\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    rootStore.shape.setMultiSelectedShape([]);\n  }\n  updatePointsPosition(shapes) {\n    this.props.handleShapesChange(shapes);\n  }\n\n  // resize and drag, change label position\n  updateRectanglePosition(shapes) {\n    this.props.handleShapesChange(shapes);\n    if (this.labelLayer) {\n      shapes.forEach(({\n        instanceId,\n        groupName,\n        id,\n        shape\n      }) => {\n        if (id && shape && shape.x) {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = shape;\n          this.updateLabel(instanceId, groupName, id, {\n            x,\n            y\n          }, {\n            x: x + width / 2,\n            y: y + height / 2\n          });\n        }\n      });\n    }\n  }\n  deleteSelectedPoints() {\n    const updatedCategories = [];\n    const points = [];\n    (this.selectedPoints.length > 0 ? this.selectedPoints.map(p => ({\n      frameIndex: this.props.currentFrame,\n      instanceId: p.data.instanceId,\n      category: p.data.category,\n      groupName: p.data.groupName,\n      index: p.data.index,\n      shapeType: LandmarkEditType.KEYPOINT\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.KEYPOINT\n    }]).forEach(selectedShapeStatus => {\n      let enable = true;\n      const {\n        frameIndex,\n        instanceId,\n        groupName,\n        index\n      } = selectedShapeStatus;\n      const point = typeof index === 'number' && this.getShapeByKey(instanceId, groupName, index);\n      if (point && point.data) {\n        const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${point.data.pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          const path = this.getPathByCategory(instanceId, groupName, point.data.pointCategory);\n          const instance = this.getInstanceContainerByInstaceId(instanceId);\n          if (instance && path && path.data.isCircle) {\n            const group = rootStore.ontology.getGroupData(instance.data.category, groupName);\n            const pointCategory = group && group.categories && group.categories.length && group.categories.find(c => c.name === point.data.pointCategory);\n            if (pointCategory) {\n              const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n              const pIndex1 = sortedKeys[0];\n              const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n              if (index !== pIndex1 && index !== pIndex2) {\n                enable = true;\n              }\n            }\n          }\n        }\n        if (enable) {\n          points.push({\n            ...selectedShapeStatus,\n            ...point.data\n          });\n        }\n      }\n    });\n    this.props.handleShapesRemove(points);\n    rootStore.handle.removeHandles(points);\n    points.forEach(({\n      frameIndex,\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const instance = this.getInstanceContainerByInstaceId(instanceId);\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      if (instance && point && !updatedCategories.includes(point.data.pointCategory)) {\n        updatedCategories.push({\n          pointCategory: point.data.pointCategory,\n          frameIndex,\n          instanceId,\n          groupName,\n          category: instance.data.category\n        });\n      }\n      this.removePointShape({\n        instanceId,\n        category,\n        groupName\n      }, index);\n    });\n    updatedCategories.forEach(({\n      frameIndex,\n      pointCategory,\n      ...container\n    }) => {\n      const categoryKey = `${frameIndex}_${container.instanceId}_${container.groupName}_${pointCategory}`;\n      this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n    });\n    this.selectedPoints = [];\n  }\n  deleteSelectedRectangle() {\n    const rectangles = (this.selectedRectangles.length > 0 ? this.selectedRectangles.map(rect => ({\n      frameIndex: rect.data.frameIndex,\n      instanceId: rect.data.instanceId,\n      category: rect.data.category,\n      groupName: rect.data.groupName,\n      id: rect.data.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      id: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    }]).filter(v => typeof v.id === 'string');\n    this.props.handleShapesRemove(rectangles);\n    rectangles.forEach(({\n      instanceId,\n      groupName,\n      id\n    }) => {\n      this.removeRectangle(instanceId, groupName, id);\n    });\n    this.selectedRectangles = [];\n  }\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ? this.selectedPoints.map(p => p.data) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id\n    }].filter(v => v.shapeType === LandmarkEditType.KEYPOINT);\n    points.forEach(({\n      instanceId,\n      category,\n      groupName,\n      index\n    }) => {\n      const point = this.getShapeByKey(instanceId, groupName, index);\n      this.changeVisibleStyle(point, index, {\n        instanceId,\n        category,\n        groupName,\n        displayColor: point.data.fillColor\n      }, !point.data.visible);\n    });\n    this.props.togglePointsVisibility(points);\n  }\n  changeVisibleStyle(point, index, groupData, visible) {\n    const {\n      instanceId,\n      groupName\n    } = groupData;\n    const labelGroup = this.getLabelByKey(instanceId, groupName, index);\n    if (point) {\n      let fillColor = point.data.isKeyPoint ? KEY_POINT_COLOR : (groupData === null || groupData === void 0 ? void 0 : groupData.displayColor) || POINT_COLOR;\n      let strokeColor = '#ffffff';\n      if (!visible) {\n        strokeColor = fillColor;\n        fillColor = '#3d424d';\n      }\n      point.data.visible = visible;\n      point.fillColor = new Paper.Color(fillColor);\n      point.strokeColor = new Paper.Color(strokeColor);\n    }\n    if (this.labelLayer && labelGroup) {\n      const label = labelGroup.children.length === 2 ? labelGroup.children[1] : labelGroup.children[0];\n      label.content = `${visible ? '1' : '0'}-${index}`;\n      label.fillColor = new Paper.Color(visible ? 'white' : 'red');\n    }\n  }\n  setCursor(cursor) {\n    this.cursor = cursor;\n  }\n  showShapeLabel(hits, point) {\n    var _label$children;\n    const {\n      activePointAttributesMode,\n      activeAttributesMode\n    } = rootStore.setting;\n    if (!activePointAttributesMode && !activeAttributesMode) return;\n    const localPoint = this.getPointInImage(Paper.view.projectToView(point));\n    const {\n      data\n    } = hits.item;\n    let label;\n    if (data.type === SHAPE_TYPE.KEYPOINT && activePointAttributesMode === AttributesMode.HOVER) {\n      label = this.getAttrLabelByKey(data.instanceId, data.groupName, data.index);\n    } else if ((data.type === SHAPE_TYPE.RECTANGLE || data.type === SHAPE_TYPE.RECTANGLE_PATH || data.type === SHAPE_TYPE.RECTANGLE_POINT) && hits.item.parent && activeAttributesMode === AttributesMode.HOVER) {\n      const {\n        instanceId,\n        groupName,\n        id\n      } = hits.item.parent.data;\n      label = this.getAttrLabelByKey(instanceId, groupName, id);\n    }\n    if (label && ((_label$children = label.children) === null || _label$children === void 0 ? void 0 : _label$children.slice(-1)[0]).content) {\n      if (this.shownLabel) {\n        if (JSON.stringify(label) !== JSON.stringify(this.shownLabel)) {\n          const {\n            point: position\n          } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, {\n            x: position[0],\n            y: position[1]\n          }, false);\n          this.shownLabel = label;\n        }\n      } else {\n        this.shownLabel = label;\n      }\n      this.shownLabel.visible = true;\n      this.shownLabel.position.x = localPoint.x + 50 / Paper.view.zoom;\n      this.shownLabel.position.y = localPoint.y + 50 / Paper.view.zoom;\n    }\n  }\n  getNewPointsByKeyPointRange(path, startKey, endKey, instanceId, groupName) {\n    const startPosition = this.getShapeByKey(instanceId, groupName, startKey).position;\n    const endPosition = this.getShapeByKey(instanceId, groupName, endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    let newPoints = {}; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints = {\n        ...newPoints,\n        [base + 1]: nextPoint\n      };\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n  getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData) {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = parentData;\n    const updatedShapes = [];\n    const indexs = Object.keys(newPoints).map(v => Number(v));\n    for (let index = 0; index < indexs.length; index += 1) {\n      const pointIndex = indexs[index];\n      const existingPoint = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (newPoints[pointIndex]) {\n        const {\n          x,\n          y\n        } = newPoints[pointIndex];\n        const pointInfo = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index: pointIndex,\n          shapeType: LandmarkEditType.KEYPOINT\n        };\n        if (existingPoint) {\n          if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n            // update position\n            existingPoint.position.x = x;\n            existingPoint.position.y = y;\n            this.updatePath(existingPoint, {\n              x,\n              y\n            });\n            updatedShapes.push({\n              ...pointInfo,\n              shape: {\n                position: {\n                  x,\n                  y\n                }\n              }\n            });\n          }\n        } else {\n          // add new point\n          const isKeyPoint = pointCategory.keys.includes(pointIndex);\n          const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n          this.addKeypointShape(new Paper.Point(x, y), pointCategory.name, pointIndex, isKeyPoint, groupContainer, true);\n          updatedShapes.push({\n            ...pointInfo,\n            shape: {\n              pointCategory: pointCategory.name,\n              isKeyPoint,\n              position: {\n                x,\n                y\n              },\n              visible: true\n            }\n          });\n        }\n      }\n    }\n    return updatedShapes;\n  }\n  autoAdjust(point = this.props.selectedShapeStatus) {\n    if (this.props.selectedShapeInfo) {\n      const {\n        id\n      } = point;\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory: categoryName\n      } = this.props.selectedShapeInfo;\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName); // pointCategory path\n      const pointCategory = this.props.categories.find(c => c.name === categoryName); // pointCategory definition\n      if (path && pointCategory && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex;\n        let nextKeyPointIndex;\n        const {\n          points = []\n        } = path.data;\n        const {\n          keys = []\n        } = pointCategory;\n        const keysWithTwoSides = [...(keys.includes(points[0]) ? [] : [points[0]]), ...keys, ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]])].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex(key => key > Number(id));\n        if (keyIndex < 0) {\n          // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex, instanceId, groupName);\n          const parentData = {\n            instanceId,\n            category,\n            groupName\n          };\n          const updatedShapes = this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData);\n          if (updatedShapes.length > 0) {\n            this.props.handleShapesChange(updatedShapes);\n          }\n        }\n      }\n    }\n  }\n  switchSmoothMode() {\n    if (this.props.selectedShapeInfo && rootStore.setting.pathStyle !== PathStyles.CURVES) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory: categoryName\n      } = this.props.selectedShapeInfo;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName);\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      if (path && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const pointCategory = this.props.categories.find(c => c.name === categoryName);\n          if (pointCategory) {\n            const keyPoints = pointCategory.keys.filter(k => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedShapes = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i], instanceId, groupName);\n              const parentData = {\n                instanceId,\n                category,\n                groupName\n              };\n              updatedShapes = [...updatedShapes, ...this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData)];\n            }\n            if (updatedShapes.length > 0) {\n              this.props.handleShapesChange(updatedShapes);\n            }\n          }\n          this.setSmooth(null);\n        } else {\n          // start\n          this.setSmooth(path);\n        }\n      }\n    }\n  }\n  setSmooth(smooth) {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach(seg => {\n        seg.clearHandles();\n      });\n    }\n    this.smoothPath = smooth;\n    if (this.smoothPath) {\n      this.smoothPath.smooth({\n        type: 'continuous'\n      });\n      this.smoothPath.fullySelected = true;\n    }\n  }\n  setSelectedCurves() {\n    if (this.props.selectedShapeInfo) {\n      const {\n        selectedShapeInfo\n      } = this.props;\n      const {\n        instanceId,\n        groupName,\n        pointCategory\n      } = selectedShapeInfo;\n      const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      this.toggleCurves(path);\n    }\n    const {\n      instanceId,\n      groupName,\n      id\n    } = this.props.selectedShapeStatus;\n    if (typeof id === 'number') {\n      const point = this.getShapeByKey(instanceId, groupName, id);\n      if (point) {\n        const {\n          data: {\n            lines = []\n          }\n        } = point;\n        lines.forEach(({\n          pathId\n        }) => {\n          const path = this.getPathById(instanceId, groupName, pathId);\n          this.toggleCurves(path);\n        });\n      }\n    }\n  }\n  toggleCurves(path) {\n    if (rootStore.setting.pathStyle === PathStyles.CURVES && path) {\n      const {\n        data: {\n          instanceId,\n          groupName,\n          id: pathId,\n          points\n        },\n        segments\n      } = path;\n      const {\n        currentFrame\n      } = this.props;\n      path.smooth({\n        type: 'continuous'\n      });\n      const map = {};\n      // points\n      points.forEach((pointIndex, i) => {\n        const segment = segments[i];\n        if (segment) {\n          const {\n            handleIn,\n            handleOut,\n            point\n          } = segment;\n          map[pointIndex] = {\n            frameIndex: currentFrame,\n            pathId,\n            instanceId,\n            groupName,\n            pointIndex,\n            handleIn: {\n              x: handleIn.x,\n              y: handleIn.y\n            },\n            handleOut: {\n              x: handleOut.x,\n              y: handleOut.y\n            },\n            pointPosition: {\n              x: point.x,\n              y: point.y\n            }\n          };\n        }\n      });\n      rootStore.handle.setPathHandles(currentFrame, pathId, map);\n    }\n  }\n  setCategoryAsCircle() {\n    if (this.props.selectedShapeInfo) {\n      const {\n        instanceId,\n        category,\n        groupName,\n        pointCategory\n      } = this.props.selectedShapeInfo;\n      if (pointCategory) {\n        const container = {\n          instanceId,\n          category,\n          groupName\n        };\n        const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, false, container);\n          this.props.setCategoryPathShape(categoryKey);\n        } else {\n          const updatedShapes = this.updateCirclePath(pointCategory, true, container);\n          this.props.setCategoryPathShape(categoryKey, CategoryPathShape.CIRCLE, updatedShapes);\n        }\n      }\n    }\n  }\n  updateCirclePath(categoryName, isCirclePath = true, container) {\n    const {\n      instanceId,\n      groupName,\n      category\n    } = container;\n    const updatedShapes = [];\n    const path = this.getPathByCategory(instanceId, groupName, categoryName);\n    const categoryData = rootStore.ontology.getCategoryData(category, groupName, categoryName);\n    const lineColor = (categoryData === null || categoryData === void 0 ? void 0 : categoryData.isConnect) === false ? new Paper.Color('rgba(0,0,0,0)') : new Paper.Color((categoryData === null || categoryData === void 0 ? void 0 : categoryData.displayColor) || POINT_COLOR);\n    if (path && categoryData) {\n      const categoryPoints = this.getPointsByCategory(instanceId, groupName, categoryName);\n      if (categoryPoints) {\n        const sortedKeys = [...categoryData.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find(p => p.data.index === pIndex1);\n        const point2 = categoryPoints.find(p => p.data.index === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (point1 && point2) {\n          if (isCirclePath) {\n            // is a circle & key points all exist\n            const centerX = (point1.position.x + point2.position.x) / 2;\n            const centerY = (point1.position.y + point2.position.y) / 2;\n            const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n            const newPath = new Paper.CompoundPath({\n              children: [new Paper.Path.Circle({\n                center: [centerX, centerY],\n                radius\n              }), new Paper.Path.Line({\n                from: [point1.position.x, point1.position.y],\n                to: [point2.position.x, point2.position.y]\n              }), new Paper.Path.Line({\n                from: new Paper.Point(computeRotatedPosition({\n                  x: centerX,\n                  y: centerY\n                }, point1.position, Math.PI / 2)),\n                to: new Paper.Point(computeRotatedPosition({\n                  x: centerX,\n                  y: centerY\n                }, point1.position, -Math.PI / 2))\n              })],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor\n            });\n            newPath.data = {\n              ...path.data,\n              isCircle: true,\n              instanceId,\n              groupName\n            };\n            path.replaceWith(newPath);\n\n            // update all points in this pointCategory\n            const update = (index, position) => {\n              const existingPoint = this.getShapeByKey(instanceId, groupName, index);\n              const pointInfo = {\n                frameIndex: this.props.selectedShapeStatus.frameIndex,\n                instanceId,\n                category,\n                groupName,\n                index,\n                shapeType: LandmarkEditType.KEYPOINT\n              };\n              if (existingPoint) {\n                // update position\n                existingPoint.position.x = position.x;\n                existingPoint.position.y = position.y;\n                this.updatePath(existingPoint, position);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    position: {\n                      x: position.x,\n                      y: position.y\n                    }\n                  }\n                });\n              } else {\n                const isKeyPoint = categoryData.keys.includes(index);\n                const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n                this.addKeypointShape(new Paper.Point(position.x, position.y), categoryData.name, index, isKeyPoint, groupContainer, true);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    pointCategory: categoryData.name,\n                    isKeyPoint,\n                    position: {\n                      x: position.x,\n                      y: position.y\n                    },\n                    visible: true\n                  }\n                });\n              }\n            };\n            const [start, end] = categoryData.range;\n            for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n              const radians = Math.PI / (pIndex2 - pIndex1) * (i - pIndex1);\n              const position = computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point1.position, radians);\n              update(i, position);\n            }\n            for (let i = pIndex2 + 1; i <= end; i += 1) {\n              const radians = Math.PI / (end + 1 - pIndex2) * (i - pIndex2);\n              const position = computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point2.position, radians);\n              update(i, position);\n            }\n            for (let i = start; i < pIndex1; i += 1) {\n              const radians = Math.PI / (end + 1 - pIndex2) * (start - pIndex1);\n              const position = computeRotatedPosition({\n                x: centerX,\n                y: centerY\n              }, point1.position, radians);\n              update(i, position);\n            }\n          } else {\n            const points = [...categoryPoints].sort((a, b) => a.data.index - b.data.index);\n            const newPath = new Paper.Path({\n              segments: points.map(p => p.position),\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor\n            });\n            newPath.data = {\n              ...path.data,\n              isCircle: false,\n              points: points.map(p => p.data.index)\n            };\n            path.replaceWith(newPath);\n            this.toggleCurves(newPath);\n          }\n        }\n      }\n    }\n    return updatedShapes;\n  }\n  addRectangle(path, groupInfo, add = true) {\n    if (this.mainLayer) {\n      const {\n        displayColor,\n        instanceId,\n        category,\n        groupName\n      } = groupInfo;\n      const {\n        data: {\n          id\n        },\n        segments\n      } = path;\n      const rectData = {\n        x: segments[0].point.x,\n        y: segments[0].point.y,\n        width: segments[2].point.x - segments[0].point.x,\n        height: segments[2].point.y - segments[0].point.y,\n        displayColor\n      };\n      this.drawRectangle(rectData, {\n        instanceId,\n        category,\n        groupName\n      }, id);\n      if (add) {\n        this.props.setNextEmptyShape();\n      }\n    }\n  }\n  getAlphaColor(color, opacity = this.fillOpacity) {\n    return hexToRgba(color, opacity);\n  }\n  drawRectangle(rectData, groupData, id, visible = true) {\n    if (this.props.selectedShapeInfo && this.mainLayer) {\n      const {\n        x,\n        y,\n        width,\n        height,\n        displayColor\n      } = rectData;\n      const {\n        instanceId,\n        category,\n        groupName\n      } = groupData;\n      let instanceContainer = this.getInstanceContainerByInstaceId(instanceId);\n      let groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (!instanceContainer) {\n        var _this$mainLayer5;\n        instanceContainer = new Paper.Group();\n        instanceContainer.data = {\n          instanceId,\n          name: category,\n          type: SHAPE_TYPE.INSTANCE\n        };\n        (_this$mainLayer5 = this.mainLayer) === null || _this$mainLayer5 === void 0 ? void 0 : _this$mainLayer5.addChild(instanceContainer);\n      }\n      if (!instanceContainer || !groupContainer) {\n        groupContainer = new Paper.Group();\n        groupContainer.data = {\n          groupName,\n          category,\n          type: SHAPE_TYPE.GROUP,\n          instanceId\n        };\n        instanceContainer.addChild(groupContainer);\n      }\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      let rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox) {\n        rectangleBox.removeChildren();\n      } else {\n        rectangleBox = new Paper.Group();\n        rectangleBox.data = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          id,\n          groupName,\n          category,\n          type: SHAPE_TYPE.RECTANGLE_GROUP,\n          instanceId,\n          displayColor,\n          visible\n        };\n        groupContainer.addChild(rectangleBox);\n      }\n      const rectangle = new Paper.Shape.Rectangle({\n        point: [x, y],\n        size: [width, height],\n        fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n        strokeWidth: rootStore.setting.lineWidth / zoom\n      });\n      rectangle.data = {\n        parentShape: id,\n        cursor: Cursor.MOVE,\n        type: SHAPE_TYPE.RECTANGLE\n      };\n      rectangleBox.addChild(rectangle);\n      this.selectShape(instanceId, groupName, id, id === this.props.selectedShapeStatus.id);\n      if (this.labelLayer) {\n        var _instance$children$fi2, _groupInfo$label_conf3;\n        const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n        const instance = this.props.getInstance(instanceId);\n        const group = instance === null || instance === void 0 ? void 0 : (_instance$children$fi2 = instance.children.find(g => g.name === groupName)) === null || _instance$children$fi2 === void 0 ? void 0 : _instance$children$fi2.frames[this.props.currentFrame];\n        const label = `${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.class_display_name) || ''} ${(instance === null || instance === void 0 ? void 0 : instance.number) || ''}-${(groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.display_name) || (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.name) || ''}`;\n        let attrsLabel = getValuesLabel(groupInfo === null || groupInfo === void 0 ? void 0 : (_groupInfo$label_conf3 = groupInfo.label_config) === null || _groupInfo$label_conf3 === void 0 ? void 0 : _groupInfo$label_conf3.fields, group === null || group === void 0 ? void 0 : group.attributes, rootStore.setting.labelItems);\n        attrsLabel = `${rootStore.setting.displayCategory ? `${label};` : ''}${rootStore.setting.displayCategory && attrsLabel ? ';' : ''}${attrsLabel}`;\n        const labelGroup = this.getLabelByKey(instanceId, groupName, id);\n        if (labelGroup) {\n          this.updateLabel(instanceId, groupName, id, {\n            x,\n            y\n          }, {\n            x: x + width / 2,\n            y: y + height / 2\n          });\n        } else {\n          this.addLabel(label, {\n            x,\n            y,\n            width,\n            height\n          }, {\n            instanceId,\n            category,\n            groupName\n          }, id, visible, SHAPE_TYPE.RECTANGLE, attrsLabel);\n        }\n      }\n    }\n  }\n  removeRectangle(instanceId, groupName, id) {\n    const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n    if (rectangleBox) {\n      rectangleBox.removeChildren();\n      rectangleBox.remove();\n      this.removeLabel(instanceId, groupName, id);\n    }\n  }\n  selectShape(instanceId, groupName, id, selected = true) {\n    if (this.mainLayer) {\n      const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox && rectangleBox.children) {\n        const {\n          bounds: {\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            x,\n            y,\n            height,\n            width\n          }\n        } = rectangleBox.children[0];\n        const points = [topLeft, topRight, bottomRight, bottomLeft];\n        const {\n          displayColor\n        } = rectangleBox.data;\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          const radius = rootStore.setting.pointSize / 2 / zoom;\n          const newColor = new Paper.Color(displayColor || POINT_COLOR);\n          points.forEach((point, index) => {\n            const sourceSeg = new Paper.Segment(point);\n            const targetSeg = index + 1 >= points.length ? new Paper.Segment(points[0]) : new Paper.Segment(points[index + 1]);\n            const lineBar = new Paper.Path({\n              segments: [sourceSeg, targetSeg],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              fillColor: newColor,\n              strokeColor: newColor,\n              selectedColor: newColor\n            });\n            lineBar.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_PATH,\n              controlIndex: index\n            };\n            rectangleBox.addChild(lineBar);\n          });\n          points.forEach((point, index) => {\n            const control = new Paper.Shape.Circle(point, radius);\n            control.strokeColor = newColor;\n            control.strokeWidth = rootStore.setting.lineWidth / zoom;\n            control.fillColor = newColor;\n            control.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_POINT,\n              controlIndex: index,\n              displayColor\n            };\n            rectangleBox.addChild(control);\n          });\n        } else {\n          rectangleBox.removeChildren();\n          const rectangle = new Paper.Shape.Rectangle({\n            point: [x, y],\n            size: [width, height],\n            fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n            strokeWidth: rootStore.setting.lineWidth / zoom\n          });\n          rectangle.data = {\n            parentShape: id,\n            cursor: Cursor.MOVE,\n            type: SHAPE_TYPE.RECTANGLE\n          };\n          rectangleBox.addChild(rectangle);\n        }\n      }\n    }\n  }\n  drawWarnings() {\n    var _this$warningLayer2;\n    (_this$warningLayer2 = this.warningLayer) === null || _this$warningLayer2 === void 0 ? void 0 : _this$warningLayer2.removeChildren();\n    const {\n      qaWarnings: warnings\n    } = rootStore.review;\n    if (warnings.length > 0) {\n      this.currentWarnings = warnings.filter(warning => warning.frames[0] === this.props.currentFrame);\n      if (this.warningLayer) {\n        const strokeWitdth = rootStore.setting.lineWidth * 2 / this.paperZoom;\n        const warningIconSize = rootStore.setting.pointSize * 6 / this.paperZoom;\n        this.currentWarnings.forEach(warning => {\n          const {\n            id,\n            groupName,\n            shapeIds\n          } = warning;\n          const shapes = [];\n          shapeIds.forEach(shapeId => {\n            const shape = this.getShapeByKey(id, groupName, shapeId);\n            if (shape) {\n              shapes.push(shape);\n              if (shape.data.type !== SHAPE_TYPE.RECTANGLE_GROUP) {\n                const {\n                  x,\n                  y,\n                  width,\n                  height\n                } = shape.bounds;\n                const boundRect = new Paper.Shape.Rectangle({\n                  point: [x - strokeWitdth, y - strokeWitdth],\n                  size: [width + 2 * strokeWitdth, height + 2 * strokeWitdth],\n                  strokeColor: new Paper.Color('#DC4624'),\n                  strokeWidth: strokeWitdth\n                });\n                this.warningLayer.addChild(boundRect);\n              }\n            }\n          });\n          let position = [];\n          if (shapes.length > 1) {\n            const minXList = [];\n            const maxXList = [];\n            const minYList = [];\n            const maxYList = [];\n            shapes.forEach(({\n              bounds: {\n                x,\n                y,\n                width,\n                height\n              }\n            }) => {\n              minXList.push(x - strokeWitdth);\n              maxXList.push(x + width + strokeWitdth);\n              minYList.push(y - strokeWitdth);\n              maxYList.push(y + height + strokeWitdth);\n            });\n            const minX = Math.min(...minXList);\n            const maxX = Math.max(...maxXList);\n            const minY = Math.min(...minYList);\n            const maxY = Math.max(...maxYList);\n            const boundRect = new Paper.Shape.Rectangle({\n              point: [minX - 2 * strokeWitdth, minY - 2 * strokeWitdth],\n              size: [maxX - minX + 4 * strokeWitdth, maxY - minY + 4 * strokeWitdth],\n              strokeColor: new Paper.Color('#DC4624'),\n              strokeWidth: strokeWitdth\n            });\n            this.warningLayer.addChild(boundRect);\n            position = [minX - warningIconSize / 2, minY - warningIconSize / 2];\n          } else if (shapes.length === 1) {\n            position = [shapes[0].bounds.x - warningIconSize / 2, shapes[0].bounds.y - warningIconSize / 2];\n          }\n          if (shapes.length > 0) {\n            const warningIcon = new Paper.Shape.Circle({\n              center: new Paper.Point(position[0], position[1]),\n              radius: warningIconSize / 3,\n              fillColor: '#DC4624'\n            });\n            const text = new Paper.PointText({\n              content: '!',\n              fontSize: FONT_SIZE / this.paperZoom,\n              fontWeight: '700',\n              fillColor: 'white'\n            });\n            warningIcon.data = {\n              instanceId: id,\n              groupName,\n              shapeIds\n            };\n            text.data = {\n              instanceId: id,\n              groupName,\n              shapeIds\n            };\n            text.position.x = position[0];\n            text.position.y = position[1];\n            this.warningLayer.addChild(warningIcon);\n            this.warningLayer.addChild(text);\n          }\n        });\n      }\n    }\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.canvasContainer,\n      className: \"canvas\",\n      style: {\n        cursor: this.cursor\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2270,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: this.canvas,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2275,\n        columnNumber: 9\n      }\n    }), this.props.isReview && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"layer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2277,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tip\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2278,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2279,\n        columnNumber: 15\n      }\n    }, formatMessage('ORIGINAL_DATA')), /*#__PURE__*/React.createElement(\"span\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2280,\n        columnNumber: 15\n      }\n    }, formatMessage('REVIEW_TIP')), /*#__PURE__*/React.createElement(Button, {\n      className: \"close\",\n      onClick: this.props.setReview,\n      size: \"small\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2281,\n        columnNumber: 15\n      }\n    }, formatMessage('REVIEW_CLOSE', {\n      values: {\n        shortcut: 'Ctrl+V'\n      }\n    })))), this.props.loading && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"loading\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2288,\n        columnNumber: 11\n      }\n    }, !this.raster && /*#__PURE__*/React.createElement(Spin, {\n      indicator: /*#__PURE__*/React.createElement(LoadingOutlined, {\n        style: {\n          fontSize: 100,\n          color: '#00bad3'\n        },\n        spin: true,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2289,\n          columnNumber: 47\n        }\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2289,\n        columnNumber: 30\n      }\n    })));\n  }\n}, (_applyDecoratedDescriptor(_class2.prototype, \"activeTool\", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, \"activeTool\"), _class2.prototype)), _class2)) || _class;\nexport default Canvas;","map":{"version":3,"names":["React","observable","action","makeObservable","computed","reaction","observer","Paper","debounce","hexToRgba","imageLoader","ImageFilters","ResizeObserver","Spin","Button","LoadingOutlined","Tool","AttributesMode","rootStore","formatMessage","CategoryPathShape","LandmarkEditType","LabelStyle","PathStyles","Cursor","resetAttrLabelPosition","getValuesLabel","resizeLabel","computeRotatedPosition","ZOOM_MIN","ZOOM_MAX","GRID_GAP","GRID_LINE_WIDTH","FONT_SIZE","POINT_COLOR","KEY_POINT_COLOR","SHAPE_TYPE","KEYPOINT","PATH","KEYPOINT_BOX","INSTANCE","GROUP","RECTANGLE_POINT","RECTANGLE_PATH","RECTANGLE_GROUP","RECTANGLE","WARNGIN","LabelType","Canvas","_class","_class2","Component","constructor","props","cursor","DEFAULT","canvas","createRef","canvasContainer","imageCanvas","imageData","raster","rasterLayer","gridLayer","labelLayer","attrLayer","mainLayer","warningLayer","tool","hits","selectedHit","warningBtn","selectedPoints","selectedRectangles","smoothPath","shownLabel","fillOpacity","resizeObserve","catchZoom","prevRaster","resizeDebounced","paperZoom","currentWarnings","resize","isWindow","current","offsetWidth","viewWidth","offsetHeight","viewHeight","view","viewSize","Size","viewCenter","Point","x","y","center","zoom","width","imgWidth","height","imgHeight","viewRatio","imgRatio","scaleFactor","offsetX","offsetY","matrix","Matrix","translate","scale","project","layers","forEach","layer","position","scaling","resizeContent","resizeGrid","resizeShapes","drawWarnings","event","mousePosition","viewPosition","viewToProject","oldZoom","oldCenter","newZoom","deltaY","Math","max","min","zoomScale","offset","subtract","multiply","add","drag","fitSelected","instanceId","groupName","groupBox","getGroupContainerByGroupName","bounds","point","localToGlobal","hitTest","_this$tool","mouseDown","_hit","isDrawPoint","selectedShapeStatus","shapeType","canAddShape","POINTER","CROSSHAIR","selected","hitTestAll","fill","handles","stroke","tolerance","match","ht","item","data","type","undefined","hit","i","length","h","includes","ctrlKey","_hit$item$data","_hit$item$data2","_hit$item$data3","_hit$item$data4","_hit$item$data5","isShapeInSelectedShapes","index","id","MOVE","showShapeLabel","_this$warningLayer","fullySelected","setCursor","clearHits","updateGroupBox","category","boundRect","getShapeByGroup","isRemovebound","ontology","setting","pointSize","lineWidth","labelItems","groupConntainer","points","children","filter","v","CIRCLE","map","xList","yList","minX","maxX","minY","maxY","_instance$children$fi","_groupInfo$label_conf","remove","range","fontSize","strokeWitdth","Shape","Rectangle","size","strokeColor","Color","strokeWidth","addChild","groupInfo","getGroupData","instance","getInstance","group","find","g","name","frames","currentFrame","attrsLabel","label_config","fields","attributes","content","class_display_name","number","display_name","labelGroup","getLabelByKey","groupAttribute","w","addLabel","removeLabel","review","qaWarnings","shape","updatedShapes","updateShapes","activeTool","_this$props$ontologyG","ontologyGroup","componentDidMount","setup","setupLayers","setupTools","addEventListener","e","preventDefault","observe","componentDidUpdate","prevProps","image","loadImage","JSON","stringify","defaultInstances","Object","values","_this$mainLayer","instanceContainer","Group","groupContainer","displayColor","updatedCategories","pointCategory","frameIndex","container","categoryKey","updateCirclePath","categoryPathShapes","onCategoriesUpdated","isSelectedChange","setPointSelected","selectShape","setMultiShapesUnselected","selectedShapeInfo","setSmooth","pathStyle","CURVES","setSelectedCurves","selectedInstance","componentWillUnmount","disconnect","Layer","applyMatrix","visible","isGridVisible","onMouseMove","activate","changeLoading","c","_canvas$getContext","getContext","getImageData","Raster","onLoad","_this$gridLayer","_this$gridLayer$child","labelMode","addGrid","orientation","crossOrigin","updateFilters","brightness","contrast","saturation","lightness","hue","rescale","filters","BrightnessContrastPhotoshop","Rescale","HSLAdjustment","setImageData","removeChildren","rows","ceil","Array","from","_","_this$gridLayer2","path","Path","Line","to","dashed","cols","_this$gridLayer3","baseWidth","dashArray","findIndex","p","isPointInImage","localPoint","globalToLocal","getPointInImage","getInstanceContainerByInstaceId","instaceId","_this$mainLayer2","getShapeByKey","key","_this$labelLayer","l","getAttrLabelByKey","_this$attrLayer","_this$mainLayer3","getPathByCategory","getPathById","pathId","getPointsByCategory","isReview","readonly","drawMode","count","annotatedPointOrShapeCount","containerAddPoint","groupData","isKeyPoint","addKeypointShape","addKeypoint","newPoint","otherPoints","handleShapesChange","setNextEmptyShape","pointIndex","_groupInfo$point_labe","pointColor","fillColor","pointCircle","Circle","radius","selectedColor","categoryData","categories","segment","Segment","lineColor","isConnect","isCircle","nextP","push","insert","splice","segments","toggleCurves","lines","indexOf","linesData","connectPoints","color","isSource","otherEnd","fromTo","otherCategory","startPoint","endPoint","endSegment","line","sourceIndex","unshift","sendToBack","label","point_label_config","displayPointIndex","removePointShape","containerData","removeSegment","Number","split","_this$labelLayer2","_this$attrLayer2","set","cleanLayer","_this$mainLayer$child","_container$children","PointText","shadowColor","shadowBlur","shadowOffset","labelRect","labelBgColor","OBJECT","labelStyle","arrtLabelGroup","clone","slice","updateLabelContent","updateLabel","updateAttributeLabel","instanceNum","_groupInfo$point_labe2","pointLabelItems","_groupInfo$label_conf2","categoryLabel","displayCategory","labelText","activePointAttributesMode","ALWAYS","activeAttributesMode","updatelabelVisible","activeMode","_this$attrLayer3","labelType","updatedShape","updatePoint","updateRectangle","setUpdatedShapes","updateShape","rectangle","currRectangle","removeRectangle","drawRectangle","closed","addRectangle","updatedCategorie","currPoint","currCategory","updatePath","changeVisibleStyle","HIDE","newContainer","segmentIndex","n","_this$mainLayer4","setMultiShapesSelected","selectedShapes","selectGroup","setSelectedShape","sort","a","b","setMultiSelectedShape","pData","rData","updatePointsPosition","shapes","updateRectanglePosition","deleteSelectedPoints","enable","sortedKeys","keys","pIndex1","pIndex2","handleShapesRemove","handle","removeHandles","deleteSelectedRectangle","rectangles","rect","toggleSelectedPointVisibility","togglePointsVisibility","_label$children","projectToView","HOVER","parent","getNewPointsByKeyPointRange","startKey","endKey","startPosition","endPosition","segmentLength","getOffsetOf","newPoints","base","basePoint","baseOffset","nextPoint","getPointAt","getUpdatedPointsByNewPoints","parentData","indexs","existingPoint","pointInfo","autoAdjust","categoryName","prevKeyPointIndex","nextKeyPointIndex","keysWithTwoSides","keyIndex","switchSmoothMode","keyPoints","k","smooth","seg","clearHandles","handleIn","handleOut","pointPosition","setPathHandles","setCategoryAsCircle","setCategoryPathShape","isCirclePath","getCategoryData","categoryPoints","point1","point2","centerX","centerY","sqrt","newPath","CompoundPath","PI","replaceWith","update","start","end","radians","rectData","getAlphaColor","opacity","_this$mainLayer5","rectangleBox","parentShape","_instance$children$fi2","_groupInfo$label_conf3","topLeft","topRight","bottomRight","bottomLeft","newColor","sourceSeg","targetSeg","lineBar","NS_RESIZE","EW_RESIZE","controlIndex","control","NWSE_RESIZE","NESW_RESIZE","_this$warningLayer2","warnings","warning","warningIconSize","shapeIds","shapeId","minXList","maxXList","minYList","maxYList","warningIcon","text","fontWeight","render","createElement","ref","className","style","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","onClick","setReview","shortcut","loading","indicator","spin","_applyDecoratedDescriptor","prototype","getOwnPropertyDescriptor"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/components/Canvas.tsx"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable, computed, reaction } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport { debounce } from 'lodash';\nimport hexToRgba from 'hex-to-rgba';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { Spin, Button } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool, { ToolEventExtend, ToolProps } from '../tools/Tool';\nimport { OntologyChild } from '../store/OntologyStore';\nimport { AttributesMode } from '../store/SettingsStore';\nimport rootStore from '../store/RootStore';\nimport formatMessage from '../locales';\nimport {\n  Point, PointStatus, CategoryItem, CategoryPathShape,\n  Group, LandmarkEditType, ShapeInfo, GroupInfo, InstanceAct,\n  PointInfo, UpdatedShape, Rectangle, KeypointCategoryProps,\n  LabelStyle, PathStyles, Handle,\n} from '../types';\nimport Cursor from '../../common/Cursor';\nimport { resetAttrLabelPosition, getValuesLabel, resizeLabel } from '../utils';\nimport { computeRotatedPosition } from '../../../utils/math';\nimport { IWarning } from '../../common/tabs-menu/Validator';\nimport './Canvas.scss';\n\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 12;\nexport const POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  KEYPOINT: 'keypoint',\n  PATH: 'path',\n  KEYPOINT_BOX: 'keypoint_box',\n  INSTANCE: 'instance',\n  GROUP: 'group',\n  RECTANGLE_POINT: 'rectangle_point',\n  RECTANGLE_PATH: 'rectangle_path',\n  RECTANGLE_GROUP: 'rectangle_group',\n  RECTANGLE: 'rectangle',\n  WARNGIN: 'warning'\n};\n\nenum LabelType {\n  KEYPOINT='keypoint',\n  OBJECT='object'\n}\n\ninterface Props {\n  image: string;\n  readonly: boolean;\n  loading: boolean;\n  currentFrame: number;\n  isReview: boolean;\n  categories: CategoryItem[];\n  updatedCategories: KeypointCategoryProps[];\n  defaultInstances: {[id: string]: InstanceAct};\n  selectedInstance?: InstanceAct;\n  selectedGroupName?: string;\n  ontologyGroup?: OntologyChild;\n  annotatedPointOrShapeCount: number;\n  selectedShapeStatus: ShapeInfo;\n  selectedShapeInfo: PointInfo | GroupInfo | null;\n  categoryPathShapes: {[categoryName: string]: CategoryPathShape};\n  changeLoading: (loading: boolean) => void;\n  selectGroup: (groupId: string, name: string, isFit?: boolean) => void;\n  setSelectedShape: (selectedIndex?: number | string, data?: Group) => void;\n  handleShapesChange: (shape: UpdatedShape[]) => void;\n  handleShapesRemove: (shape: UpdatedShape[]) => void;\n  togglePointsVisibility: (points: PointStatus[]) => void;\n  setNextEmptyShape: () => void;\n  onCategoriesUpdated: () => void;\n  editShapeForm: () => void;\n  editGroupForm: () => void;\n  onSave: () => void;\n  setCategoryPathShape: (categoryName: string, type?: CategoryPathShape, updatedShapes?: UpdatedShape[]) => void;\n  getInstance: (id: string) => InstanceAct | undefined;\n  handleUndo: () => void;\n  handleRedo: () => void;\n  setReview: () => void;\n  handleChangeDrawMode: (mode: boolean) => void;\n}\n\n@observer\nclass Canvas extends React.Component<Props> {\n  cursor = Cursor.DEFAULT;\n\n  canvas: React.RefObject<HTMLCanvasElement> = React.createRef();\n\n  canvasContainer: React.RefObject<HTMLDivElement> = React.createRef();\n\n  imageCanvas: HTMLCanvasElement | undefined;\n\n  imageData: ImageData | undefined;\n\n  raster: paper.Raster | undefined;\n\n  rasterLayer: paper.Layer | undefined;\n\n  gridLayer: paper.Layer | undefined;\n\n  labelLayer: paper.Layer | undefined;\n\n  attrLayer: paper.Layer | undefined;\n\n  mainLayer: paper.Layer | undefined;\n\n  warningLayer: paper.Layer | undefined;\n\n  tool: ToolProps | undefined;\n\n  hits: paper.HitResult | undefined;\n\n  selectedHit: paper.Item | undefined;\n\n  warningBtn: paper.HitResult | undefined;\n\n  selectedPoints: paper.Shape[] = [];\n\n  selectedRectangles: paper.Group[] = [];\n\n  smoothPath: paper.Path | null = null;\n\n  shownLabel: paper.Group | null = null;\n\n  fillOpacity = 0.3;\n\n  resizeObserve: ResizeObserver | null = null;\n\n  catchZoom: { zoom: number, center: paper.Point } | undefined;\n\n  prevRaster: paper.Raster | null = null;\n\n  resizeDebounced: any;\n\n  paperZoom = 1;\n\n  currentWarnings: IWarning[] = [];\n\n  constructor(props: Props) {\n    super(props);\n    makeObservable(this, {\n      cursor: observable,\n      setCursor: action,\n    });\n\n    reaction(\n      () => rootStore.review.qaWarnings,\n      () => {\n        this.drawWarnings();\n      },\n    );\n\n    // change frame & undo & redo to update points\n    reaction(\n      () => rootStore.shape.updatedShapes,\n      () => {\n        this.updateShapes();\n        this.drawWarnings();\n      },\n    );\n  }\n\n  @computed get activeTool() {\n    let tool = '';\n    switch (this.props.ontologyGroup?.type) {\n      case LandmarkEditType.KEYPOINT:\n        tool = CategoryPathShape.CIRCLE;\n        break;\n      case LandmarkEditType.RECTANGLE:\n        tool = CategoryPathShape.RECTANGLE;\n        break;\n      default:\n        break;\n    }\n    return tool;\n  }\n\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', (e) => e.preventDefault(), false);\n    }\n    if (this.canvasContainer.current) {\n      this.resizeObserve = new ResizeObserver(() => { this.resize(true); });\n      this.resizeObserve.observe(this.canvasContainer.current);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.image !== this.props.image) {\n      this.loadImage();\n    }\n\n    // default instances\n    if (JSON.stringify(prevProps.defaultInstances) !== JSON.stringify(this.props.defaultInstances)) {\n      const defaultInstances = Object.values(this.props.defaultInstances).filter((instance) => instance && !prevProps.defaultInstances[instance.id]);\n      if (defaultInstances.length > 0) {\n        defaultInstances.forEach((instance) => {\n          const instanceContainer = new Paper.Group();\n          this.mainLayer?.addChild(instanceContainer);\n          instanceContainer.data = {\n            instanceId: instance.id,\n            category: instance.category,\n            type: SHAPE_TYPE.INSTANCE,\n          };\n          instance.children.forEach((group) => {\n            const groupContainer = new Paper.Group();\n            groupContainer.data = {\n              groupName: group.name,\n              type: SHAPE_TYPE.GROUP,\n              instanceId: instance.id,\n              category: instance.category,\n              displayColor: instance.displayColor || POINT_COLOR,\n            };\n            instanceContainer.addChild(groupContainer);\n          });\n        });\n      }\n    }\n\n    if (\n      JSON.stringify(prevProps.updatedCategories) !== JSON.stringify(this.props.updatedCategories) &&\n      this.props.updatedCategories.length > 0\n    ) {\n      this.props.updatedCategories.forEach(({ pointCategory, frameIndex, instanceId, groupName, category }) => {\n        if (frameIndex === this.props.currentFrame) {\n          const container = { instanceId, groupName, category };\n          const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n        }\n      });\n      this.props.onCategoriesUpdated();\n    }\n\n    // selected changes\n    const isSelectedChange = JSON.stringify(prevProps.selectedShapeStatus) !== JSON.stringify(this.props.selectedShapeStatus);\n    if (isSelectedChange) {\n      if (this.selectedPoints.length <= 0 || this.selectedRectangles.length <= 0) {\n        if (prevProps.selectedShapeStatus && prevProps.selectedShapeStatus.id !== undefined) {\n          const { instanceId, groupName, id, shapeType } = prevProps.selectedShapeStatus;\n          if (!this.isShapeInSelectedShapes(instanceId, groupName, id)) {\n            if (shapeType === LandmarkEditType.KEYPOINT) {\n              this.setPointSelected(instanceId, groupName, id as number, false);\n            } else {\n              this.selectShape(instanceId, groupName, id as string, false);\n            }\n          }\n        }\n      }\n      const { instanceId, groupName, id, shapeType } = this.props.selectedShapeStatus;\n      if (id !== undefined) {\n        this.setMultiShapesUnselected();\n        if (shapeType === LandmarkEditType.KEYPOINT) {\n          this.setPointSelected(instanceId, groupName, id as number, true);\n        } else {\n          this.selectShape(instanceId, groupName, id as string);\n        }\n      }\n    }\n    if ((prevProps.selectedShapeInfo as PointInfo || {}).pointCategory !== (this.props.selectedShapeInfo as PointInfo || {}).pointCategory) {\n      this.setSmooth(null);\n      if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n        this.setSelectedCurves();\n      }\n    }\n    if (\n      this.props.selectedInstance && (\n        isSelectedChange ||\n        JSON.stringify(this.props.selectedInstance) !== JSON.stringify(prevProps.selectedInstance)\n      )\n    ) {\n      const { instanceId, category, groupName } = this.props.selectedShapeStatus;\n      this.updateGroupBox(instanceId, category, groupName);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.resizeObserve) {\n      this.resizeObserve.disconnect();\n      this.resizeObserve = null;\n    }\n  }\n\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = true;\n\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = rootStore.setting.isGridVisible;\n\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n\n    this.attrLayer = new Paper.Layer();\n    this.attrLayer.applyMatrix = false;\n    this.attrLayer.visible = false;\n\n    this.warningLayer = new Paper.Layer();\n    this.warningLayer.applyMatrix = false;\n    this.warningLayer.visible = false;\n\n    Paper.view.onMouseMove = this.hitTest;\n  }\n\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n\n  loadImage() {\n    if (this.rasterLayer && this.props.image) {\n      this.rasterLayer.activate();\n      this.props.changeLoading(true);\n      if (this.raster) {\n        this.prevRaster = this.raster;\n      }\n      imageLoader(this.props.image, (c) => {\n        const canvas = c as HTMLCanvasElement;\n        this.imageCanvas = canvas;\n        this.imageData = canvas.getContext('2d')?.getImageData(0, 0, canvas.width, canvas.height);\n        this.raster = new Paper.Raster(canvas);\n        this.raster!.visible = false;\n        this.raster!.onLoad = () => {\n          if (!this.gridLayer?.children?.length) {\n            this.labelLayer!.visible = rootStore.setting.labelMode;\n            this.mainLayer!.visible = true;\n            this.warningLayer!.visible = true;\n            this.attrLayer!.visible = true;\n          }\n          this.addGrid(); // add grid to image\n          this.resize(); // resize to fit the container\n          // when onload, show all layers\n          this.raster!.visible = true;\n          if (this.prevRaster) {\n            this.prevRaster.remove();\n          }\n          this.props.changeLoading(false);\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous',\n      });\n    }\n  }\n\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const { brightness, contrast, saturation, lightness, hue, rescale } = rootStore.setting.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n\n  resize = (isWindow = false) => {\n    if (this.canvasContainer.current) {\n      // set view size\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n      const viewCenter = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      if (this.catchZoom) {\n        const { center, zoom } = this.catchZoom;\n        if (isWindow) {\n          Paper.view.center = viewCenter;\n          this.catchZoom.center = viewCenter;\n        } else {\n          Paper.view.center = center;\n        }\n        Paper.view.zoom = zoom;\n      } else {\n        Paper.view.center = viewCenter;\n        Paper.view.zoom = 1;\n      }\n\n      if (this.imageCanvas && this.raster) {\n        // resize image\n        const { width: imgWidth, height: imgHeight } = this.imageCanvas;\n        const viewRatio = viewWidth / viewHeight;\n        const imgRatio = imgWidth / imgHeight;\n        const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n        const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n        const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n        const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n        // apply matrix to all layers\n        Paper.project.layers.forEach((layer) => {\n          layer.matrix = matrix;\n        });\n        // reset image center\n        this.raster.position = new Paper.Point({ x: imgWidth / 2, y: imgHeight / 2 });\n        this.paperZoom = this.rasterLayer ? Paper.view.zoom * this.rasterLayer.matrix.scaling.x : Paper.view.zoom;\n      }\n      this.resizeContent();\n    }\n  };\n\n  resizeContent = () => {\n    if (this.resizeDebounced) {\n      this.resizeDebounced();\n    } else {\n      this.resizeDebounced = debounce(() => {\n        this.resizeGrid();\n        this.resizeShapes();\n        this.drawWarnings();\n      }, 50);\n    }\n  };\n\n  zoom = (event: WheelEvent, zoom?: number) => {\n    if (this.canvasContainer.current) {\n      const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n      const viewPosition = Paper.view.viewToProject(mousePosition);\n      const oldZoom = Paper.view.zoom;\n      const oldCenter = Paper.view.center;\n\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      let newZoom = event && event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n      newZoom = zoom || newZoom;\n      if (newZoom <= 1) {\n        Paper.view.center = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      }\n      newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n      if (newZoom !== Paper.view.zoom) {\n        Paper.view.zoom = newZoom;\n        const zoomScale = oldZoom / newZoom;\n        const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n        Paper.view.center = Paper.view.center.add(offset);\n      }\n      this.catchZoom = { zoom: newZoom, center: Paper.view.center };\n      this.paperZoom = newZoom * this.rasterLayer!.matrix.scaling.x;\n      this.resizeContent();\n    }\n  };\n\n  drag = (center: paper.Point) => {\n    this.catchZoom = this.catchZoom ? {\n      ...this.catchZoom,\n      center,\n    } : {\n      zoom: Paper.view.zoom,\n      center\n    };\n  };\n\n  fitSelected = (instanceId: string, groupName: string) => {\n    const groupBox = this.getGroupContainerByGroupName(instanceId, groupName);\n    if (groupBox && this.mainLayer && this.canvasContainer.current) {\n      const { center, width, height } = groupBox.bounds;\n      if (width === 0 || height === 0) return;\n      const point = this.mainLayer.localToGlobal(center);\n      const { width: viewWidth, height: viewHeight } = this.mainLayer.bounds;\n\n      let zoom = width / height > viewWidth / viewHeight ? viewWidth / width : viewHeight / height;\n      zoom = Math.min(18, Math.max(zoom, 1));\n      Paper.view.zoom = zoom;\n      Paper.view.center = point;\n      this.catchZoom = { zoom, center: point };\n      this.paperZoom = this.rasterLayer ? zoom * this.rasterLayer.matrix.scaling.x : zoom;\n      this.resizeContent();\n    } else {\n      this.resize();\n    }\n  };\n\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      this.gridLayer.removeChildren();\n      const { width, height } = this.imageCanvas;\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({ length: rows }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({ length: cols }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n    }\n  }\n\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach((path) => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n\n  isShapeInSelectedShapes(instanceId: string, groupName: string, index: number | string | undefined) {\n    return this.selectedPoints.findIndex((p) => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0 ||\n    this.selectedRectangles.findIndex((p) => p.data.instanceId === instanceId && p.data.groupName === groupName && p.data.index === index) >= 0;\n  }\n\n  isPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const { bounds: { x, y, width, height } } = this.rasterLayer;\n    return localPoint.x >= 0 && localPoint.x <= (x + width) && localPoint.y >= 0 && localPoint.y <= (y + height);\n  }\n\n  getPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n\n    if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n\n  getInstanceContainerByInstaceId(instaceId: string) {\n    return this.mainLayer?.children.find((i) => i.data.type === SHAPE_TYPE.INSTANCE && i.data.instanceId === instaceId) as paper.Group;\n  }\n\n  getGroupContainerByGroupName(instaceId: string, groupName: string) {\n    const instance = this.getInstanceContainerByInstaceId(instaceId);\n    return instance?.children.find((g) => g.data.type === SHAPE_TYPE.GROUP && g.data.groupName === groupName) as paper.Group;\n  }\n\n  getShapeByKey(instaceId: string, groupName: string, key: string | number) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => (p.data.type === SHAPE_TYPE.RECTANGLE_GROUP && p.data.id === key) ||\n      (p.data.type === SHAPE_TYPE.KEYPOINT && p.data.index === key)) as paper.Group | paper.Shape;\n  }\n\n  getLabelByKey(instanceId: string, groupName: string, key: number | string) {\n    return this.labelLayer?.children.find((l) => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === key) as paper.Group;\n  }\n\n  getAttrLabelByKey(instanceId: string, groupName: string, key: number | string) {\n    return this.attrLayer?.children.find((l) => l.data.instanceId === instanceId && l.data.groupName === groupName && l.data.key === `attr-${key}`) as paper.Group;\n  }\n\n  getShapeByGroup() {\n    return this.mainLayer?.children.find((l) => l.data.type === SHAPE_TYPE.KEYPOINT_BOX);\n  }\n\n  getPathByCategory(instaceId: string, groupName: string, pointCategory: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => p.data.type === SHAPE_TYPE.PATH && p.data.pointCategory === pointCategory) as paper.Path;\n  }\n\n  getPathById(instaceId: string, groupName: string, pathId: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.find((p) => p.data.type === SHAPE_TYPE.PATH && p.data.id === pathId) as paper.Path;\n  }\n\n  getPointsByCategory(instaceId: string, groupName: string, pointCategory: string) {\n    const group = this.getGroupContainerByGroupName(instaceId, groupName);\n    return group?.children.filter((p) => p.data.type === SHAPE_TYPE.KEYPOINT && p.data.pointCategory === pointCategory);\n  }\n\n  canAddShape() {\n    if (this.props.isReview || this.props.readonly || !rootStore.review.drawMode) return false;\n    if (this.mainLayer && this.props.selectedShapeInfo) {\n      if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.RECTANGLE) {\n        if (this.props.ontologyGroup && this.props.ontologyGroup.count > 0) {\n          return this.props.annotatedPointOrShapeCount < this.props.ontologyGroup.count;\n        }\n      } else if (this.props.selectedShapeInfo.shapeType === LandmarkEditType.KEYPOINT) {\n        const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n        if (id === undefined || id < 0) return false;\n        const point = this.getShapeByKey(instanceId, groupName, id as number);\n        return !point;\n      }\n    }\n    return false;\n  }\n\n  containerAddPoint(groupData: GroupInfo, point: paper.Point, pointCategory: string, index: number, isKeyPoint: boolean, visible = true, attributes?: any) {\n    const { instanceId, groupName } = groupData;\n    const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n    this.addKeypointShape(point, pointCategory, index, isKeyPoint, groupContainer, visible, attributes);\n  };\n\n  addKeypoint(point: paper.Point) {\n    if (this.mainLayer && this.props.selectedShapeInfo && this.props.selectedShapeStatus && this.props.selectedInstance) {\n      const { id, shapeType, frameIndex } = this.props.selectedShapeStatus;\n      const index = (shapeType === LandmarkEditType.KEYPOINT && id as number) || 0;\n      const { x, y } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const { instanceId, category, groupName, pointCategory, isKeyPoint } = this.props.selectedShapeInfo as PointInfo;\n\n      const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`;\n      const groupData = { instanceId, groupName, type: LandmarkEditType.KEYPOINT, category: this.props.selectedInstance.category };\n      this.containerAddPoint(groupData, newPoint, pointCategory, index, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n        const container: Group = { instanceId, category, groupName };\n        otherPoints = this.updateCirclePath(pointCategory, true, container);\n      }\n      this.props.handleShapesChange([{\n        frameIndex,\n        instanceId,\n        category,\n        groupName,\n        index,\n        shapeType: LandmarkEditType.KEYPOINT,\n        shape: {\n          pointCategory,\n          isKeyPoint,\n          position: { x, y },\n          visible: true, // default is visible when point added\n        },\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyShape(); // move next\n    }\n  }\n\n  addKeypointShape(point: paper.Point, pointCategory: string, pointIndex: number, isKeyPoint: boolean, groupContainer: paper.Group, visible: boolean, attributes?: any) {\n    if (!groupContainer) return;\n    const { frameIndex } = this.props.selectedShapeStatus;\n    const { instanceId, groupName, category, displayColor } = groupContainer.data;\n    if (this.mainLayer) {\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : displayColor || POINT_COLOR;\n      const fillColor = visible ? pointColor : '#3d424d';\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: (rootStore.setting.pointSize + 1) / zoom,\n        fillColor,\n        strokeColor: '#ffffff',\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white',\n      });\n      pointCircle.data = {\n        frameIndex,\n        type: SHAPE_TYPE.KEYPOINT,\n        cursor: Cursor.MOVE,\n        pointCategory,\n        index: pointIndex,\n        isKeyPoint,\n        visible,\n        instanceId,\n        groupName,\n        category,\n        fillColor,\n      };\n      groupContainer.addChild(pointCircle);\n\n      // add point to path\n      const groupData = rootStore.ontology.getGroupData(category, groupName);\n      const categoryData = (groupData && groupData.categories && groupData.categories.find((v) => v.name === pointCategory)) || undefined;\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      const lineColor = categoryData?.isConnect === false ?\n        new Paper.Color('rgba(0,0,0,0)') :\n        new Paper.Color(displayColor || POINT_COLOR);\n      let index = -1;\n      if (path) {\n        const { points, isCircle } = path.data;\n        if (!isCircle) {\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            for (let i = 0; i < points.length; i += 1) {\n              const p = points[i];\n              const nextP = points[i + 1];\n              if (pointIndex > p && nextP > pointIndex) {\n                // 2 => 1,3\n                index = i + 1;\n                break;\n              } else if (\n                pointIndex < p &&\n                (!nextP || nextP > p || (nextP < p && i !== 0))) {\n                // 9 => 10 || 10,18 || 10,5(end point)[not (end point)10,5]\n                index = i;\n                break;\n              }\n            }\n          } else {\n            index = path.data.points.findIndex((p: number) => pointIndex < p);\n          }\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: rootStore.setting.lineWidth / zoom,\n          strokeColor: lineColor,\n          selectedColor: lineColor,\n        });\n        path.data = {\n          type: SHAPE_TYPE.PATH,\n          pointCategory,\n          points: [pointIndex],\n          instanceId,\n          groupName,\n          id: `${frameIndex}_${instanceId}_${groupName}_${pointCategory}`,\n        };\n        groupContainer.addChild(path);\n      }\n      this.toggleCurves(path);\n      if (path === this.smoothPath) {\n        this.setSmooth(path);\n      }\n      if (groupData && groupData.lines) {\n        const lines = groupData.lines.filter((v) => v.points.indexOf(pointIndex) >= 0);\n        const linesData: {isSource: boolean, fromTo: string, pathId: string}[] = [];\n        lines.forEach((connectPoints) => {\n          if (connectPoints) {\n            const { points, color } = connectPoints;\n            const isSource = pointIndex === points[0];\n            const otherEnd = this.getShapeByKey(instanceId, groupName, isSource ? points[1] : points[0]);\n            const fromTo = `${points[0]}-${points[1]}`;\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              if (otherEnd) {\n                const { pointCategory: otherCategory } = otherEnd.data;\n                const [startPoint, endPoint] = isSource ? [pointCircle, otherEnd] : [otherEnd, pointCircle];\n                const endSegment = new Paper.Segment(new Paper.Point(endPoint.position.x, endPoint.position.y));\n                const line = isSource ? path : this.getPathByCategory(instanceId, groupName, otherCategory !== pointCategory ? otherCategory : '');\n                if (line) {\n                  const sourceIndex = line.data.points.findIndex((p: number) => points[0] === p);\n                  if (sourceIndex === 0) {\n                    line.insert(0, endSegment);\n                    line.data.points.unshift(points[1]);\n                  } else if (sourceIndex === line.data.points.length - 1) {\n                    line.add(endSegment);\n                    line.data.points.push(points[1]);\n                  }\n                  this.toggleCurves(line);\n                  if (!endPoint.data.lines) {\n                    endPoint.data.lines = [];\n                  }\n                  endPoint.data.lines.push({ isSource: false, fromTo, pathId: line.data.id });\n                  startPoint.data.lines = [...startPoint.data.lines || [], { isSource: true, fromTo, pathId: line.data.id }];\n                }\n              }\n            } else {\n              linesData.push({ isSource, fromTo, pathId: fromTo });\n              if (otherEnd) {\n                const segments = isSource ? [segment, otherEnd.position] : [otherEnd.position, segment];\n                const line = new Paper.Path({\n                  segments,\n                  strokeWidth: rootStore.setting.lineWidth / zoom,\n                  strokeColor: color,\n                  selectedColor: color,\n                });\n                line.data = {\n                  type: SHAPE_TYPE.PATH,\n                  pointCategory: fromTo,\n                  points,\n                  instanceId,\n                  groupName,\n                  id: fromTo,\n                };\n                groupContainer.addChild(line);\n              }\n            }\n          }\n        });\n        if (rootStore.setting.pathStyle !== PathStyles.CURVES) {\n          pointCircle.data.lines = linesData;\n        }\n      }\n      path.sendToBack();\n      const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n      const label = `${visible ? 1 : 0}-${pointIndex}`;\n      let attrsLabel = getValuesLabel(groupInfo?.point_label_config?.fields, attributes, rootStore.setting.labelItems);\n      attrsLabel = `${rootStore.setting.displayPointIndex ? `${pointIndex}` : ''}${rootStore.setting.displayPointIndex && attrsLabel ? ';' : ''}${attrsLabel}`;\n\n      this.addLabel(\n        label,\n        { x: point.x, y: point.y, width: rootStore.setting.pointSize / zoom, height: rootStore.setting.pointSize / zoom },\n        { instanceId, category, groupName },\n        pointIndex,\n        visible,\n        SHAPE_TYPE.KEYPOINT,\n        attrsLabel\n      );\n    }\n  }\n\n  removePointShape(containerData: Group, pointIndex: number) {\n    const { instanceId, groupName } = containerData;\n    if (this.mainLayer) {\n      const point = this.getShapeByKey(instanceId, groupName, pointIndex);\n      if (point) {\n        const { lines, pointCategory } = point.data;\n        point.remove();\n        // remove pointCategory path\n        const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n        if (path && !path.data.isCircle) {\n          const index = path.data.points.findIndex((p: number) => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n        // remove group connect path\n        if (lines) {\n          (lines as { isSource: boolean, fromTo: string, pathId: string }[]).forEach(({ pathId, fromTo, isSource }) => {\n            const line = this.getPathById(instanceId, groupName, pathId);\n            if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n              let index = line?.data.points.findIndex((p: number) => p === pointIndex);\n              if (isSource && index < 0) {\n                index = line.data.points.findIndex((p: number) => p === Number(fromTo.split('-')[1] || -1));\n              }\n              if (index >= 0) {\n                line.removeSegment(index);\n                line.data.points.splice(index, 1);\n                this.toggleCurves(line);\n              }\n            } else {\n              line?.remove();\n            }\n          });\n        }\n      }\n    }\n    this.removeLabel(instanceId, groupName, pointIndex);\n  }\n\n  resizeShapes() {\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      this.mainLayer.children.forEach((instance) => {\n        if (instance.children && instance.children.length > 0) {\n          instance.children.forEach((group) => {\n            if (group.children) {\n              group.children.forEach((path) => {\n                if (path.data.type === SHAPE_TYPE.KEYPOINT) {\n                  path.set({ radius: rootStore.setting.pointSize / this.paperZoom });\n                  path.strokeWidth = 1 / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.PATH) {\n                  path.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                } else if (path.data.type === SHAPE_TYPE.RECTANGLE_GROUP && path.children) {\n                  path.children.forEach((shape) => {\n                    if (shape.data.type === SHAPE_TYPE.RECTANGLE_POINT) {\n                      shape.set({ radius: (rootStore.setting.pointSize / 2) / this.paperZoom });\n                    } else if (shape.data.type === SHAPE_TYPE.RECTANGLE_PATH) {\n                      shape.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n                    }\n                  });\n                }\n              });\n            }\n          });\n        } else if (instance.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          instance.strokeWidth = rootStore.setting.lineWidth / this.paperZoom;\n        }\n      });\n    }\n    if (this.labelLayer?.children && this.labelLayer.children.length > 0) {\n      this.labelLayer.children.forEach((label) => {\n        const { zoom: oldZoom, width, height, point } = label.data;\n        resizeLabel({ width, height, zoom: this.paperZoom, fontSize: FONT_SIZE }, oldZoom, point, label, 'label');\n      });\n    }\n\n    if (this.attrLayer?.children && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach((label) => {\n        const { zoom: oldZoom, width, height, point } = label.data;\n        resizeLabel({ width, height, zoom: this.paperZoom, fontSize: FONT_SIZE }, oldZoom, point, label, 'attr');\n      });\n    }\n    const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n    this.setPointSelected(instanceId, groupName, id as number, true);\n  }\n\n  cleanLayer() {\n    if (this.mainLayer) {\n      this.mainLayer.children?.forEach((container) => {\n        if (container.data.type === SHAPE_TYPE.KEYPOINT_BOX) {\n          container.remove();\n        } else {\n          container.children?.forEach((group) => {\n            group?.removeChildren();\n          });\n        }\n      });\n    }\n    if (this.labelLayer) {\n      this.labelLayer.removeChildren();\n    }\n\n    if (this.attrLayer) {\n      this.attrLayer.removeChildren();\n    }\n\n    if (this.warningLayer) {\n      this.warningLayer.removeChildren();\n    }\n  }\n\n  addLabel(content: string, shape: {x: number, y: number, width: number, height: number}, groupInfo: Group, key: number | string, visible: boolean, shapeType: string, attrsLabel?: string) {\n    if (this.labelLayer) {\n      const { instanceId, groupName } = groupInfo;\n      const fontSize = FONT_SIZE / this.paperZoom;\n      const label = new Paper.PointText({\n        content,\n        fontSize,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#000000',\n        shadowBlur: 2 / this.paperZoom,\n        shadowOffset: 2 / this.paperZoom,\n      });\n      const width = label.bounds.width + fontSize / 2;\n      const height = label.bounds.height + fontSize / 2;\n      const labelRect = new Paper.Shape.Rectangle({\n        size: [width, height],\n        fillColor: rootStore.setting.labelBgColor,\n      });\n      label.position.x = labelRect.bounds.width / 2;\n      label.position.y = labelRect.bounds.height / 2;\n\n      const labelGroup = new Paper.Group();\n      labelGroup.data = {\n        point: [shape.x, shape.y],\n        instanceId,\n        groupName,\n        key,\n        type: shapeType === SHAPE_TYPE.KEYPOINT ? LabelType.KEYPOINT : LabelType.OBJECT,\n        zoom: this.paperZoom,\n        height,\n        width\n      };\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        labelGroup.addChild(labelRect);\n      }\n      labelGroup.addChild(label);\n      this.labelLayer.addChild(labelGroup);\n      labelGroup.position.x = shape.x + labelRect.bounds.width / 2;\n      labelGroup.position.y = shape.y - labelRect.bounds.height / 2 - rootStore.setting.lineWidth / this.paperZoom;\n\n      if (shapeType !== SHAPE_TYPE.KEYPOINT_BOX && this.attrLayer) {\n        let center = { x: shape.x, y: shape.y };\n\n        if (SHAPE_TYPE.RECTANGLE) {\n          center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 };\n        }\n        const arrtLabelGroup = labelGroup.clone();\n        arrtLabelGroup.data.key = `attr-${arrtLabelGroup.data.key}`;\n        arrtLabelGroup.data.point = [center.x, center.y];\n        arrtLabelGroup.children.slice(-1)[0].fillColor = new Paper.Color('#ffffff');\n        (arrtLabelGroup.children.slice(-1)[0] as paper.PointText).content = '';\n        this.attrLayer.addChild(arrtLabelGroup);\n        if (attrsLabel) {\n          this.updateLabelContent(arrtLabelGroup, attrsLabel, shapeType);\n        } else {\n          arrtLabelGroup.visible = false;\n        }\n      }\n    }\n  }\n\n  updateLabel(instanceId: string, groupName: string, key: number | string, position: { x: number, y: number }, center: { x: number, y: number }) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [position.x, position.y];\n        label.position.x = position.x + label.bounds.width / 2;\n        label.position.y = position.y - label.bounds.height / 2;\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.data.point = [center.x, center.y];\n        label.position.x = center.x;\n        label.position.y = center.y;\n      }\n    }\n  }\n\n  updateAttributeLabel(instanceId: string, category: string, groupName: string, key: number | string, attributes: any, instanceNum?: number) {\n    const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n    let label = '';\n    if (typeof key === 'number') {\n      label = getValuesLabel(groupInfo?.point_label_config?.fields, attributes, rootStore.setting.pointLabelItems);\n      label = `${rootStore.setting.displayPointIndex ? `${key}` : ''}${rootStore.setting.displayPointIndex && label ? ';' : ''}${label}`;\n    } else {\n      const categoryLabel = `${groupInfo?.class_display_name || ''}  ${instanceNum || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n      label = getValuesLabel(groupInfo?.label_config?.fields, attributes, rootStore.setting.labelItems);\n      label = `${rootStore.setting.displayCategory ? `${categoryLabel}` : ''}${rootStore.setting.displayCategory && label ? ';' : ''}${label}`;\n    }\n    const attrLayer = this.getAttrLabelByKey(instanceId, groupName, key);\n    if (attrLayer) {\n      if (label) {\n        this.updateLabelContent(attrLayer, label, SHAPE_TYPE.KEYPOINT);\n      } else {\n        attrLayer.visible = false;\n      }\n    }\n  }\n\n  updateLabelContent(label: paper.Group, content: string, shapeType: string) {\n    if (this.attrLayer && label) {\n      const zoom = Paper.view.zoom * this.attrLayer.matrix.scaling.x;\n      const labelText = label.children.slice(-1)[0];\n      (labelText as paper.PointText).content = content;\n      const { width, height } = labelText.bounds;\n      const fontSize = FONT_SIZE / zoom;\n      if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n        (label.children[0] as paper.Shape).size.height = height + fontSize / 2;\n        (label.children[0] as paper.Shape).size.width = width + fontSize / 2;\n      }\n      label.data.width = label.children[0].bounds.width;\n      label.data.height = label.children[0].bounds.height;\n      label.data.zoom = this.paperZoom;\n\n      let visible = false;\n      if (shapeType === SHAPE_TYPE.KEYPOINT) {\n        visible = rootStore.setting.activePointAttributesMode === AttributesMode.ALWAYS;\n      } else if (SHAPE_TYPE.RECTANGLE) {\n        visible = rootStore.setting.activeAttributesMode === AttributesMode.ALWAYS;\n      }\n      if (visible) {\n        const { point } = label.data;\n        resetAttrLabelPosition(label, { x: point[0], y: point[1] }, visible);\n      } else {\n        label.visible = false;\n      }\n    }\n  }\n\n  updatelabelVisible(activeMode: AttributesMode, type = 'object') {\n    if (this.shownLabel) {\n      this.shownLabel.visible = false;\n      this.shownLabel = null;\n    }\n    if (this.attrLayer?.children && this.attrLayer.children.length > 0) {\n      this.attrLayer.children.forEach((label) => {\n        const { type: labelType } = label.data;\n        if (type === labelType) {\n          label.visible = activeMode === AttributesMode.ALWAYS;\n        }\n      });\n    }\n  }\n\n  removeLabel(instanceId: string, groupName: string, key: string | number) {\n    if (this.labelLayer) {\n      const label = this.getLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n    if (this.attrLayer) {\n      const label = this.getAttrLabelByKey(instanceId, groupName, key);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n\n  updateShapes() {\n    const { currentFrame } = this.props;\n    const { shape: { updatedShapes } } = rootStore;\n    updatedShapes.forEach((updatedShape) => {\n      if (updatedShape.frameIndex !== currentFrame) return;\n      switch (updatedShape.shapeType) {\n        case LandmarkEditType.KEYPOINT:\n          this.updatePoint(updatedShape);\n          break;\n        case LandmarkEditType.RECTANGLE:\n          this.updateRectangle(updatedShape);\n          break;\n        default:\n          break;\n      }\n    });\n    rootStore.shape.setUpdatedShapes([]);\n    const { instanceId, category, groupName } = this.props.selectedShapeStatus;\n    this.updateGroupBox(instanceId, category, groupName);\n  }\n\n  updateRectangle(updateShape: UpdatedShape) {\n    const { instanceId, groupName, category, id, shape } = updateShape;\n    if (id !== undefined) {\n      const rectangle = shape as Rectangle;\n      const currRectangle = this.getShapeByKey(instanceId, groupName, id);\n      if (currRectangle) {\n        // alreay exist, should update\n        if (rectangle === undefined) {\n          // delete\n          this.removeRectangle(instanceId, groupName, id);\n        } else if (rectangle.x) {\n          const { x, y, width, height, displayColor } = rectangle;\n          // update position\n          this.drawRectangle({ x, y, width, height, displayColor }, { instanceId, category, groupName }, id);\n        }\n      } else if (rectangle) {\n        //  has been removed, should add\n        const { x, y, width, height, displayColor } = rectangle;\n        const path = new Paper.Path();\n        path.data.id = id;\n        path.add(new Paper.Point(x, y));\n        path.add(new Paper.Point(x + width, y));\n        path.add(new Paper.Point(x + width, y + height));\n        path.add(new Paper.Point(x, y + height));\n        path.closed = true;\n        this.addRectangle(path, { instanceId, groupName, category, shapeType: LandmarkEditType.RECTANGLE, displayColor }, false);\n      }\n    }\n  }\n\n  updatePoint(updateShape: UpdatedShape) {\n    const { frameIndex, instanceId, groupName, category, index, shape } = updateShape;\n    if (index !== undefined) {\n      let updatedCategorie: KeypointCategoryProps | undefined;\n      const point = shape as Point;\n      const currPoint = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      if (currPoint) {\n        const currCategory = currPoint.data.pointCategory;\n        updatedCategorie = { pointCategory: currCategory, frameIndex, instanceId, groupName, category };\n        const groupData = { frameIndex, instanceId, category, groupName };\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(groupData, index);\n        } else if (point.position && point.pointCategory) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          this.updatePath(currPoint, point.position);\n          // update visible\n          if (point.visible !== undefined && currPoint.data.visible !== point.visible) {\n            this.changeVisibleStyle(currPoint, index, groupData, point.visible);\n          }\n          if (rootStore.setting.activePointAttributesMode !== AttributesMode.HIDE) {\n            this.updateAttributeLabel(instanceId, category, groupName, index, point.attributes);\n          }\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const { position, pointCategory, isKeyPoint, visible, attributes } = point;\n        if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          updatedCategorie = { pointCategory, frameIndex, instanceId, groupName, category };\n          const groupData = { instanceId, groupName, type: LandmarkEditType.KEYPOINT, category };\n          this.containerAddPoint(groupData, new Paper.Point(position.x, position.y), pointCategory, index, isKeyPoint, visible, attributes);\n        }\n      }\n      if (updatedCategorie) {\n        const { pointCategory, ...newContainer } = updatedCategorie;\n        const categoryKey = `${frameIndex}_${newContainer.instanceId}_${newContainer.groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, newContainer);\n        }\n      }\n    }\n  }\n\n  updatePath(\n    point: paper.Shape,\n    position: { x: number, y: number },\n  ) {\n    const { instanceId, groupName, pointCategory, index, lines } = point.data;\n    const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n    if (path && !path.data.isCircle) {\n      const segmentIndex = path.data.points.findIndex((p: number) => p === index);\n      path.segments[segmentIndex].point.x = position.x;\n      path.segments[segmentIndex].point.y = position.y;\n      this.toggleCurves(path);\n    }\n    // change connect line position\n    if (lines) {\n      (lines as {isSource: boolean, pathId: string}[]).forEach(({ isSource, pathId }) => {\n        const line = this.getPathById(instanceId, groupName, pathId);\n        if (line) {\n          let n = -1;\n          if (rootStore.setting.pathStyle === PathStyles.CURVES) {\n            n = !isSource ? line.data.points.findIndex((p: number) => p === index) : -1;\n          } else {\n            n = isSource ? 0 : 1;\n            if (!line.segments[n]) {\n              n = 0;\n            }\n          }\n          if (n >= 0) {\n            line.segments[n].point.x = position.x;\n            line.segments[n].point.y = position.y;\n            this.toggleCurves(line);\n          }\n        }\n      });\n    }\n    this.updateLabel(\n      instanceId,\n      groupName,\n      index,\n      position,\n      position,\n    );\n  }\n\n  setPointSelected(instanceId: string, groupName: string, index: number, selected: boolean) {\n    if (this.mainLayer?.children && this.mainLayer.children.length > 0) {\n      const point = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      if (point) {\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          point.strokeWidth = 3 / zoom;\n          point.radius = (rootStore.setting.pointSize + 1) / zoom;\n        } else {\n          point.radius = rootStore.setting.pointSize / zoom;\n          point.strokeWidth = 1 / zoom;\n        }\n      }\n    }\n  }\n\n  setMultiShapesSelected(selectedShapes: (paper.Shape | paper.Group)[], type: CategoryPathShape) {\n    if (selectedShapes.length > 0) {\n      const { instanceId, groupName } = selectedShapes[0].data;\n      this.props.selectGroup(instanceId, groupName, false);\n      this.props.setSelectedShape(undefined);\n    }\n    if (type === CategoryPathShape.CIRCLE) {\n      this.selectedPoints = (selectedShapes as paper.Shape[]).sort((a, b) => a.data.index - b.data.index);\n      rootStore.shape.setMultiSelectedShape(this.selectedPoints.map((point) => (point as paper.Shape).data.index));\n      this.selectedPoints.forEach((point) => {\n        const pData = point.data;\n        this.setPointSelected(pData.instanceId, pData.groupName, pData.index, true);\n      });\n    } else {\n      this.selectedRectangles = selectedShapes as paper.Group[];\n      this.selectedRectangles.forEach((rectangle) => {\n        const rData = rectangle.data;\n        this.selectShape(rData.instanceId, rData.groupName, rData.id);\n      });\n    }\n  }\n\n  setMultiShapesUnselected() {\n    this.selectedPoints.forEach((point) => {\n      const { instanceId, groupName, index } = point.data;\n      this.setPointSelected(instanceId, groupName, index, false);\n    });\n    this.selectedRectangles.forEach((rectangle) => {\n      const { instanceId, groupName, id } = rectangle.data;\n      this.selectShape(instanceId, groupName, id, false);\n    });\n\n    this.selectedPoints = [];\n    this.selectedRectangles = [];\n    rootStore.shape.setMultiSelectedShape([]);\n  }\n\n  updatePointsPosition(shapes: UpdatedShape[]) {\n    this.props.handleShapesChange(shapes);\n  }\n\n  // resize and drag, change label position\n  updateRectanglePosition(shapes: UpdatedShape[]) {\n    this.props.handleShapesChange(shapes);\n    if (this.labelLayer) {\n      shapes.forEach(({ instanceId, groupName, id, shape }) => {\n        if (id && shape && (shape as Rectangle).x) {\n          const { x, y, width, height } = shape as Rectangle;\n          this.updateLabel(\n            instanceId,\n            groupName,\n            id,\n            { x, y },\n            { x: x + width / 2, y: y + height / 2 },\n          );\n        }\n      });\n    }\n  }\n\n  deleteSelectedPoints() {\n    const updatedCategories: KeypointCategoryProps[] = [];\n    const points: UpdatedShape[] = [];\n    (this.selectedPoints.length > 0 ? this.selectedPoints.map((p) => ({\n      frameIndex: this.props.currentFrame,\n      instanceId: p.data.instanceId,\n      category: p.data.category,\n      groupName: p.data.groupName,\n      index: p.data.index,\n      shapeType: LandmarkEditType.KEYPOINT\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      index: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.KEYPOINT\n    }]).forEach((selectedShapeStatus) => {\n      let enable = true;\n      const { frameIndex, instanceId, groupName, index } = selectedShapeStatus;\n      const point = typeof index === 'number' && this.getShapeByKey(instanceId, groupName, index);\n      if (point && point.data) {\n        const categoryKey = `${frameIndex}_${instanceId}_${groupName}_${point.data.pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          const path = this.getPathByCategory(instanceId, groupName, point.data.pointCategory);\n          const instance = this.getInstanceContainerByInstaceId(instanceId);\n          if (instance && path && path.data.isCircle) {\n            const group = rootStore.ontology.getGroupData(instance.data.category, groupName);\n            const pointCategory = group && group.categories && group.categories.length && group.categories.find((c) => c.name === point.data.pointCategory);\n            if (pointCategory) {\n              const sortedKeys = [...pointCategory.keys].sort((a, b) => a - b);\n              const pIndex1 = sortedKeys[0];\n              const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n              if (index !== pIndex1 && index !== pIndex2) {\n                enable = true;\n              }\n            }\n          }\n        }\n        if (enable) {\n          points.push({\n            ...selectedShapeStatus,\n            ...point.data\n          });\n        }\n      }\n    });\n    this.props.handleShapesRemove(points);\n    rootStore.handle.removeHandles(points);\n    points.forEach(({ frameIndex, instanceId, category, groupName, index }) => {\n      const instance = this.getInstanceContainerByInstaceId(instanceId);\n      const point = this.getShapeByKey(instanceId, groupName, index!);\n      if (instance && point && !updatedCategories.includes(point.data.pointCategory)) {\n        updatedCategories.push({ pointCategory: point.data.pointCategory, frameIndex, instanceId, groupName, category: instance.data.category });\n      }\n      this.removePointShape({ instanceId, category, groupName }, index!);\n    });\n    updatedCategories.forEach(({ frameIndex, pointCategory, ...container }) => {\n      const categoryKey = `${frameIndex}_${container.instanceId}_${container.groupName}_${pointCategory}`;\n      this.updateCirclePath(pointCategory, this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE, container);\n    });\n    this.selectedPoints = [];\n  }\n\n  deleteSelectedRectangle() {\n    const rectangles = (this.selectedRectangles.length > 0 ? this.selectedRectangles.map((rect) => ({\n      frameIndex: rect.data.frameIndex,\n      instanceId: rect.data.instanceId,\n      category: rect.data.category,\n      groupName: rect.data.groupName,\n      id: rect.data.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    })) : [{\n      ...this.props.selectedShapeStatus,\n      id: this.props.selectedShapeStatus.id,\n      shapeType: LandmarkEditType.RECTANGLE\n    }]).filter((v) => typeof v.id === 'string');\n    this.props.handleShapesRemove(rectangles);\n    rectangles.forEach(({ instanceId, groupName, id }) => {\n      this.removeRectangle(instanceId, groupName, id);\n    });\n    this.selectedRectangles = [];\n  };\n\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ?\n      this.selectedPoints.map((p) => p.data) :\n      [{ ...this.props.selectedShapeStatus, index: this.props.selectedShapeStatus.id }]\n        .filter((v) => v.shapeType === LandmarkEditType.KEYPOINT);\n    points.forEach(({ instanceId, category, groupName, index }) => {\n      const point = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n      this.changeVisibleStyle(point, index, { instanceId, category, groupName, displayColor: point.data.fillColor }, !point.data.visible);\n    });\n    this.props.togglePointsVisibility(points);\n  }\n\n  changeVisibleStyle(point: paper.Shape, index: number, groupData: Group, visible: boolean) {\n    const { instanceId, groupName } = groupData;\n    const labelGroup = this.getLabelByKey(instanceId, groupName, index);\n    if (point) {\n      let fillColor = point.data.isKeyPoint ?\n        KEY_POINT_COLOR :\n        groupData?.displayColor || POINT_COLOR;\n      let strokeColor = '#ffffff';\n      if (!visible) {\n        strokeColor = fillColor;\n        fillColor = '#3d424d';\n      }\n      point.data.visible = visible;\n      point.fillColor = new Paper.Color(fillColor);\n      point.strokeColor = new Paper.Color(strokeColor);\n    }\n    if (this.labelLayer && labelGroup) {\n      const label = labelGroup.children.length === 2 ? labelGroup.children[1] : labelGroup.children[0];\n      (label as paper.PointText).content = `${visible ? '1' : '0'}-${index}`;\n      label.fillColor = new Paper.Color(visible ? 'white' : 'red');\n    }\n  }\n\n  hitTest = (event: ToolEventExtend) => {\n    if (this.mainLayer && !this.tool?.mouseDown) {\n      let cursor: Cursor = Cursor.DEFAULT;\n      const isDrawPoint = this.props.selectedShapeStatus.shapeType === LandmarkEditType.KEYPOINT;\n      if (this.canAddShape()) {\n        cursor = isDrawPoint ? Cursor.POINTER : Cursor.CROSSHAIR;\n      }\n      if (this.selectedHit) {\n        this.selectedHit.selected = false;\n      }\n\n      const hits = this.mainLayer.hitTestAll(event.point, {\n        fill: true,\n        selected: false,\n        handles: true,\n        stroke: true,\n        tolerance: 10 / this.paperZoom,\n        match: (ht: any) => {\n          if (ht && ht.item && (ht.item.data.type === undefined || ht.item.data.type === SHAPE_TYPE.KEYPOINT_BOX)) {\n            return false;\n          }\n          return true;\n        }\n      });\n      let hit: paper.HitResult | undefined;\n      for (let i = 0; i < hits.length; i += 1) {\n        const h = hits[i];\n        const { type } = h.item.data;\n        if (\n          !type ||\n          (type !== SHAPE_TYPE.INSTANCE &&\n          type !== SHAPE_TYPE.GROUP &&\n          type !== SHAPE_TYPE.KEYPOINT_BOX &&\n          type !== SHAPE_TYPE.RECTANGLE_GROUP) &&\n          (\n            type !== SHAPE_TYPE.PATH ||\n            (type === SHAPE_TYPE.PATH && ['handle-in', 'handle-out'].includes(h.type)))\n        ) {\n          // select point | rectangle | rectangle control | path handle\n          if ((type === SHAPE_TYPE.RECTANGLE || type === SHAPE_TYPE.RECTANGLE_POINT || type === SHAPE_TYPE.RECTANGLE_PATH)) {\n            if ((i === 0) && !this.canAddShape()) {\n              hit = h;\n            }\n          } else {\n            hit = h;\n            if (type === SHAPE_TYPE.KEYPOINT) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (hit?.item && !event.event.ctrlKey) {\n        if (\n          !this.isShapeInSelectedShapes(hit.item.data?.instanceId, hit.item.data?.groupName, hit.item.data?.index) &&\n          hit.item.data?.index !== this.props.selectedShapeStatus.id &&\n          hit.item.data?.id !== this.props.selectedShapeStatus.id\n        ) {\n          this.selectedHit = hit.item;\n          hit.item.selected = true;\n        }\n        if (hit.item.data.cursor) {\n          cursor = hit.item.data.cursor;\n        } else {\n          cursor = Cursor.MOVE;\n        }\n        this.showShapeLabel(hit, event.point);\n      } else if (this.shownLabel) {\n        const { point } = this.shownLabel.data;\n        resetAttrLabelPosition(this.shownLabel, { x: point[0], y: point[1] }, false);\n      }\n      this.hits = hit;\n      if (this.currentWarnings.length > 0) {\n        this.warningBtn = this.warningLayer?.hitTest(event.point);\n      }\n      if (this.smoothPath) {\n        this.smoothPath.fullySelected = true;\n      }\n      this.setCursor(cursor);\n    }\n  };\n\n  setCursor(cursor: Cursor) {\n    this.cursor = cursor;\n  }\n\n  clearHits = () => {\n    this.hits = undefined;\n  };\n\n  showShapeLabel(hits: paper.HitResult, point: paper.Point) {\n    const { activePointAttributesMode, activeAttributesMode } = rootStore.setting;\n    if (!activePointAttributesMode && !activeAttributesMode) return;\n    const localPoint = this.getPointInImage(Paper.view.projectToView(point));\n    const { data } = hits.item;\n    let label;\n    if (data.type === SHAPE_TYPE.KEYPOINT && activePointAttributesMode === AttributesMode.HOVER) {\n      label = this.getAttrLabelByKey(data.instanceId, data.groupName, data.index);\n    } else if (\n      (data.type === SHAPE_TYPE.RECTANGLE || data.type === SHAPE_TYPE.RECTANGLE_PATH || data.type === SHAPE_TYPE.RECTANGLE_POINT) &&\n      hits.item.parent &&\n      activeAttributesMode === AttributesMode.HOVER\n    ) {\n      const { instanceId, groupName, id } = hits.item.parent.data;\n      label = this.getAttrLabelByKey(instanceId, groupName, id);\n    }\n    if (label && (label.children?.slice(-1)[0] as paper.PointText).content) {\n      if (this.shownLabel) {\n        if (JSON.stringify(label) !== JSON.stringify(this.shownLabel)) {\n          const { point: position } = this.shownLabel.data;\n          resetAttrLabelPosition(this.shownLabel, { x: position[0], y: position[1] }, false);\n          this.shownLabel = label;\n        }\n      } else {\n        this.shownLabel = label;\n      }\n      this.shownLabel.visible = true;\n      this.shownLabel.position.x = localPoint.x + 50 / Paper.view.zoom;\n      this.shownLabel.position.y = localPoint.y + 50 / Paper.view.zoom;\n    }\n  }\n\n  getNewPointsByKeyPointRange(path: paper.Path, startKey: number, endKey: number, instanceId: string, groupName: string) {\n    const startPosition = this.getShapeByKey(instanceId, groupName, startKey).position;\n    const endPosition = this.getShapeByKey(instanceId, groupName, endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    let newPoints = {}; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints = {\n        ...newPoints,\n        [base + 1]: nextPoint\n      };\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n\n  getUpdatedPointsByNewPoints(newPoints: {[index: number]: paper.Point}, pointCategory: CategoryItem, parentData: Group) {\n    const { instanceId, groupName, category } = parentData;\n    const updatedShapes: UpdatedShape[] = [];\n    const indexs = Object.keys(newPoints).map((v) => Number(v));\n    for (let index = 0; index < indexs.length; index += 1) {\n      const pointIndex = indexs[index];\n      const existingPoint = this.getShapeByKey(instanceId, groupName, pointIndex) as paper.Shape;\n      if (newPoints[pointIndex]) {\n        const { x, y } = newPoints[pointIndex];\n        const pointInfo = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          instanceId,\n          category,\n          groupName,\n          index: pointIndex,\n          shapeType: LandmarkEditType.KEYPOINT,\n        };\n        if (existingPoint) {\n          if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n            // update position\n            existingPoint.position.x = x;\n            existingPoint.position.y = y;\n\n            this.updatePath(existingPoint, { x, y });\n            updatedShapes.push({\n              ...pointInfo,\n              shape: {\n                position: { x, y }\n              },\n            });\n          }\n        } else {\n          // add new point\n          const isKeyPoint = pointCategory.keys.includes(pointIndex);\n          const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n\n          this.addKeypointShape(new Paper.Point(x, y), pointCategory.name, pointIndex, isKeyPoint, groupContainer, true);\n          updatedShapes.push({\n            ...pointInfo,\n            shape: {\n              pointCategory: pointCategory.name,\n              isKeyPoint,\n              position: { x, y },\n              visible: true,\n            },\n          });\n        }\n      }\n    }\n    return updatedShapes;\n  }\n\n  autoAdjust(point = this.props.selectedShapeStatus) {\n    if (this.props.selectedShapeInfo) {\n      const { id } = point;\n      const { instanceId, category, groupName, pointCategory: categoryName } = this.props.selectedShapeInfo as PointInfo;\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName); // pointCategory path\n      const pointCategory = this.props.categories.find((c) => c.name === categoryName); // pointCategory definition\n      if (path && pointCategory && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex: number | undefined;\n        let nextKeyPointIndex: number | undefined;\n        const { points = [] } = path.data;\n        const { keys = [] } = pointCategory;\n        const keysWithTwoSides = [\n          ...(keys.includes(points[0]) ? [] : [points[0]]),\n          ...keys,\n          ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]]),\n        ].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex((key) => key > Number(id));\n        if (keyIndex < 0) { // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex, instanceId, groupName);\n          const parentData = { instanceId, category, groupName };\n          const updatedShapes = this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData);\n          if (updatedShapes.length > 0) {\n            this.props.handleShapesChange(updatedShapes);\n          }\n        }\n      }\n    }\n  }\n\n  switchSmoothMode() {\n    if (this.props.selectedShapeInfo && rootStore.setting.pathStyle !== PathStyles.CURVES) {\n      const { instanceId, category, groupName, pointCategory: categoryName } = this.props.selectedShapeInfo as PointInfo;\n      const path = this.getPathByCategory(instanceId, groupName, categoryName);\n      const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${categoryName}`;\n      if (path && this.props.categoryPathShapes[categoryKey] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const pointCategory = this.props.categories.find((c) => c.name === categoryName);\n          if (pointCategory) {\n            const keyPoints = pointCategory.keys.filter((k) => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedShapes: UpdatedShape[] = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i], instanceId, groupName);\n              const parentData = { instanceId, category, groupName };\n              updatedShapes = [\n                ...updatedShapes,\n                ...this.getUpdatedPointsByNewPoints(newPoints, pointCategory, parentData),\n              ];\n            }\n            if (updatedShapes.length > 0) {\n              this.props.handleShapesChange(updatedShapes);\n            }\n          }\n          this.setSmooth(null);\n        } else {\n          // start\n          this.setSmooth(path);\n        }\n      }\n    }\n  }\n\n  setSmooth(smooth: paper.Path | null) {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach((seg) => {\n        seg.clearHandles();\n      });\n    }\n    this.smoothPath = smooth;\n    if (this.smoothPath) {\n      this.smoothPath.smooth({ type: 'continuous' });\n      this.smoothPath.fullySelected = true;\n    }\n  }\n\n  setSelectedCurves() {\n    if (this.props.selectedShapeInfo) {\n      const { selectedShapeInfo } = this.props;\n      const { instanceId, groupName, pointCategory } = selectedShapeInfo as PointInfo;\n      const path = this.getPathByCategory(instanceId, groupName, pointCategory);\n      this.toggleCurves(path);\n    }\n    const { instanceId, groupName, id } = this.props.selectedShapeStatus;\n    if (typeof id === 'number') {\n      const point = this.getShapeByKey(instanceId, groupName, id);\n      if (point) {\n        const { data: { lines = [] } } = point;\n        lines.forEach(({ pathId }: any) => {\n          const path = this.getPathById(instanceId, groupName, pathId);\n          this.toggleCurves(path);\n        });\n      }\n    }\n  }\n\n  toggleCurves(path?: paper.Path) {\n    if (rootStore.setting.pathStyle === PathStyles.CURVES && path) {\n      const { data: { instanceId, groupName, id: pathId, points }, segments } = path;\n      const { currentFrame } = this.props;\n      path.smooth({ type: 'continuous' });\n      const map: {[pointIndex: number]: Handle} = {};\n      // points\n      (points as number[]).forEach((pointIndex, i) => {\n        const segment = segments[i];\n        if (segment) {\n          const { handleIn, handleOut, point } = segment;\n          map[pointIndex] = {\n            frameIndex: currentFrame,\n            pathId,\n            instanceId,\n            groupName,\n            pointIndex,\n            handleIn: { x: handleIn.x, y: handleIn.y },\n            handleOut: { x: handleOut.x, y: handleOut.y },\n            pointPosition: { x: point.x, y: point.y },\n          };\n        }\n      });\n      rootStore.handle.setPathHandles(currentFrame, pathId, map);\n    }\n  }\n\n  setCategoryAsCircle() {\n    if (this.props.selectedShapeInfo) {\n      const { instanceId, category, groupName, pointCategory } = this.props.selectedShapeInfo as PointInfo;\n      if (pointCategory) {\n        const container: Group = { instanceId, category, groupName };\n        const categoryKey = `${this.props.currentFrame}_${instanceId}_${groupName}_${pointCategory}`;\n        if (this.props.categoryPathShapes[categoryKey] === CategoryPathShape.CIRCLE) {\n          this.updateCirclePath(pointCategory, false, container);\n          this.props.setCategoryPathShape(categoryKey);\n        } else {\n          const updatedShapes = this.updateCirclePath(pointCategory, true, container);\n          this.props.setCategoryPathShape(categoryKey, CategoryPathShape.CIRCLE, updatedShapes);\n        }\n      }\n    }\n  }\n\n  updateCirclePath(categoryName: string, isCirclePath = true, container: Group) {\n    const { instanceId, groupName, category } = container;\n    const updatedShapes: UpdatedShape[] = [];\n    const path = this.getPathByCategory(instanceId, groupName, categoryName);\n    const categoryData = rootStore.ontology.getCategoryData(category, groupName, categoryName);\n    const lineColor = categoryData?.isConnect === false ?\n      new Paper.Color('rgba(0,0,0,0)') :\n      new Paper.Color(categoryData?.displayColor || POINT_COLOR);\n    if (path && categoryData) {\n      const categoryPoints = this.getPointsByCategory(instanceId, groupName, categoryName);\n      if (categoryPoints) {\n        const sortedKeys = [...categoryData.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find((p) => p.data.index === pIndex1);\n        const point2 = categoryPoints.find((p) => p.data.index === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer!.matrix.scaling.x;\n        if (point1 && point2) {\n          if (isCirclePath) {\n            // is a circle & key points all exist\n            const centerX = (point1.position.x + point2.position.x) / 2;\n            const centerY = (point1.position.y + point2.position.y) / 2;\n            const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n            const newPath = new Paper.CompoundPath({\n              children: [\n                new Paper.Path.Circle({\n                  center: [centerX, centerY],\n                  radius,\n                }),\n                new Paper.Path.Line({\n                  from: [point1.position.x, point1.position.y],\n                  to: [point2.position.x, point2.position.y],\n                }),\n                new Paper.Path.Line({\n                  from: new Paper.Point(computeRotatedPosition({ x: centerX, y: centerY }, point1.position, Math.PI / 2)),\n                  to: new Paper.Point(computeRotatedPosition({ x: centerX, y: centerY }, point1.position, -Math.PI / 2)),\n                }),\n              ],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor,\n            });\n            newPath.data = { ...path.data, isCircle: true, instanceId, groupName };\n            path.replaceWith(newPath);\n\n            // update all points in this pointCategory\n            const update = (index: number, position: { x: number; y: number }) => {\n              const existingPoint = this.getShapeByKey(instanceId, groupName, index) as paper.Shape;\n              const pointInfo = {\n                frameIndex: this.props.selectedShapeStatus.frameIndex,\n                instanceId,\n                category,\n                groupName,\n                index,\n                shapeType: LandmarkEditType.KEYPOINT,\n              };\n              if (existingPoint) {\n                // update position\n                existingPoint.position.x = position.x;\n                existingPoint.position.y = position.y;\n                this.updatePath(existingPoint, position);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    position: { x: position.x, y: position.y }\n                  },\n                });\n              } else {\n                const isKeyPoint = categoryData.keys.includes(index);\n                const groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n\n                this.addKeypointShape(new Paper.Point(position.x, position.y), categoryData.name, index, isKeyPoint, groupContainer, true);\n                updatedShapes.push({\n                  ...pointInfo,\n                  shape: {\n                    pointCategory: categoryData.name,\n                    isKeyPoint,\n                    position: { x: position.x, y: position.y },\n                    visible: true,\n                  },\n                });\n              }\n            };\n            const [start, end] = categoryData.range;\n            for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n              const radians = (Math.PI / (pIndex2 - pIndex1)) * (i - pIndex1);\n              const position = computeRotatedPosition({ x: centerX, y: centerY }, point1.position, radians);\n              update(i, position);\n            }\n            for (let i = pIndex2 + 1; i <= end; i += 1) {\n              const radians = (Math.PI / (end + 1 - pIndex2)) * (i - pIndex2);\n              const position = computeRotatedPosition({ x: centerX, y: centerY }, point2.position, radians);\n              update(i, position);\n            }\n            for (let i = start; i < pIndex1; i += 1) {\n              const radians = (Math.PI / (end + 1 - pIndex2)) * (start - pIndex1);\n              const position = computeRotatedPosition({ x: centerX, y: centerY }, point1.position, radians);\n              update(i, position);\n            }\n          } else {\n            const points = [...categoryPoints].sort((a, b) => a.data.index - b.data.index);\n            const newPath = new Paper.Path({\n              segments: points.map((p) => p.position),\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              strokeColor: lineColor,\n              selectedColor: lineColor,\n            });\n            newPath.data = { ...path.data, isCircle: false, points: points.map((p) => p.data.index) };\n            path.replaceWith(newPath);\n            this.toggleCurves(newPath);\n          }\n        }\n      }\n    }\n    return updatedShapes;\n  }\n\n  updateGroupBox = (instanceId: string, category: string, groupName: string) => {\n    let boundRect = this.getShapeByGroup();\n    const { selectedShapeStatus } = this.props;\n    let isRemovebound = false;\n    if (\n      instanceId &&\n      instanceId === selectedShapeStatus.instanceId &&\n      groupName === selectedShapeStatus.groupName\n    ) {\n      const { ontology, setting: { pointSize, lineWidth, labelItems } } = rootStore;\n      const groupConntainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      const points = groupConntainer && groupConntainer.children\n        .filter((v: any) => v.type === CategoryPathShape.CIRCLE)\n        .map((v) => [v.position.x, v.position.y]);\n      if (points && points.length > 0) {\n        const xList = points.map((v) => v[0]);\n        const yList = points.map((v) => v[1]);\n        const minX = Math.min(...xList);\n        const maxX = Math.max(...xList);\n        const minY = Math.min(...yList);\n        const maxY = Math.max(...yList);\n        if (this.mainLayer) {\n          const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n          if (boundRect) {\n            boundRect.remove();\n          }\n          const range = (pointSize * 3) / zoom;\n          const fontSize = FONT_SIZE / this.paperZoom;\n          const strokeWitdth = lineWidth / zoom;\n          boundRect = new Paper.Shape.Rectangle({\n            point: [minX - range, minY - range],\n            size: [maxX - minX + 2 * range, maxY - minY + 2 * range],\n            strokeColor: new Paper.Color('#FFE600'),\n            strokeWidth: strokeWitdth\n          });\n          boundRect.data.type = SHAPE_TYPE.KEYPOINT_BOX;\n          this.mainLayer.addChild(boundRect);\n          const groupInfo = ontology.getGroupData(category, groupName);\n          const instance = this.props.getInstance(instanceId);\n          const group = instance?.children.find((g) => g.name === groupName)?.frames[this.props.currentFrame];\n          const attrsLabel = getValuesLabel(groupInfo?.label_config?.fields, group?.attributes, labelItems);\n          const content = `${groupInfo?.class_display_name || ''} ${instance?.number || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n          const labelGroup = this.getLabelByKey('', '', 'group_label');\n          const groupAttribute = this.getLabelByKey('', '', 'group_attributes');\n          labelGroup?.remove();\n          groupAttribute?.remove();\n          const x = minX - range; const y = minY - range - strokeWitdth * 2;\n          const w = maxX - minX + 2 * range; const h = maxY - minY + 2 * range;\n          this.addLabel(\n            content,\n            { x, y, width: w, height: h },\n            { instanceId: '', category: '', groupName: '' },\n            'group_label',\n            true,\n            SHAPE_TYPE.KEYPOINT_BOX\n          );\n          this.addLabel(\n            attrsLabel,\n            { x, y: y - fontSize * 1.5, width: w, height: h },\n            { instanceId: '', category: '', groupName: '' },\n            'group_attributes',\n            true,\n            SHAPE_TYPE.KEYPOINT_BOX\n          );\n        }\n      } else {\n        isRemovebound = true;\n      }\n    } else {\n      isRemovebound = true;\n    }\n    if (isRemovebound && boundRect) {\n      boundRect.remove();\n      this.removeLabel('', '', 'group_label');\n      this.removeLabel('', '', 'group_attributes');\n    }\n  };\n\n  addRectangle(path: paper.Path, groupInfo: GroupInfo, add = true) {\n    if (this.mainLayer) {\n      const { displayColor, instanceId, category, groupName } = groupInfo;\n      const { data: { id }, segments } = path;\n      const rectData = {\n        x: segments[0].point.x,\n        y: segments[0].point.y,\n        width: segments[2].point.x - segments[0].point.x,\n        height: segments[2].point.y - segments[0].point.y,\n        displayColor,\n      };\n      this.drawRectangle(rectData, { instanceId, category, groupName }, id);\n      if (add) {\n        this.props.setNextEmptyShape();\n      }\n    }\n  }\n\n  getAlphaColor(color: string, opacity = this.fillOpacity) {\n    return hexToRgba(color, opacity);\n  }\n\n  drawRectangle(\n    rectData: {x: number, y: number, width: number, height: number, displayColor?: string},\n    groupData: Group,\n    id: string,\n    visible = true\n  ) {\n    if (this.props.selectedShapeInfo && this.mainLayer) {\n      const { x, y, width, height, displayColor } = rectData;\n      const { instanceId, category, groupName } = groupData;\n      let instanceContainer = this.getInstanceContainerByInstaceId(instanceId);\n      let groupContainer = this.getGroupContainerByGroupName(instanceId, groupName);\n      if (!instanceContainer) {\n        instanceContainer = new Paper.Group();\n        instanceContainer.data = {\n          instanceId,\n          name: category,\n          type: SHAPE_TYPE.INSTANCE,\n        };\n        this.mainLayer?.addChild(instanceContainer);\n      }\n      if (!instanceContainer || !groupContainer) {\n        groupContainer = new Paper.Group();\n        groupContainer.data = {\n          groupName,\n          category,\n          type: SHAPE_TYPE.GROUP,\n          instanceId,\n        };\n        instanceContainer.addChild(groupContainer);\n      }\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      let rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox) {\n        rectangleBox.removeChildren();\n      } else {\n        rectangleBox = new Paper.Group();\n        rectangleBox.data = {\n          frameIndex: this.props.selectedShapeStatus.frameIndex,\n          id,\n          groupName,\n          category,\n          type: SHAPE_TYPE.RECTANGLE_GROUP,\n          instanceId,\n          displayColor,\n          visible,\n        };\n        groupContainer.addChild(rectangleBox);\n      }\n      const rectangle = new Paper.Shape.Rectangle({\n        point: [x, y],\n        size: [width, height],\n        fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n        strokeWidth: rootStore.setting.lineWidth / zoom\n      });\n      rectangle.data = {\n        parentShape: id,\n        cursor: Cursor.MOVE,\n        type: SHAPE_TYPE.RECTANGLE\n      };\n      rectangleBox.addChild(rectangle);\n      this.selectShape(instanceId, groupName, id, id === this.props.selectedShapeStatus.id);\n      if (this.labelLayer) {\n        const groupInfo = rootStore.ontology.getGroupData(category, groupName);\n        const instance = this.props.getInstance(instanceId);\n        const group = instance?.children.find((g) => g.name === groupName)?.frames[this.props.currentFrame];\n        const label = `${groupInfo?.class_display_name || ''} ${instance?.number || ''}-${groupInfo?.display_name || groupInfo?.name || ''}`;\n        let attrsLabel = getValuesLabel(groupInfo?.label_config?.fields, group?.attributes, rootStore.setting.labelItems);\n        attrsLabel = `${rootStore.setting.displayCategory ? `${label};` : ''}${rootStore.setting.displayCategory && attrsLabel ? ';' : ''}${attrsLabel}`;\n        const labelGroup = this.getLabelByKey(instanceId, groupName, id);\n        if (labelGroup) {\n          this.updateLabel(\n            instanceId,\n            groupName,\n            id,\n            { x, y },\n            { x: x + width / 2, y: y + height / 2 },\n          );\n        } else {\n          this.addLabel(\n            label,\n            { x, y, width, height },\n            { instanceId, category, groupName },\n            id,\n            visible,\n            SHAPE_TYPE.RECTANGLE,\n            attrsLabel\n          );\n        }\n      }\n    }\n  }\n\n  removeRectangle(instanceId: string, groupName: string, id: string) {\n    const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n    if (rectangleBox) {\n      rectangleBox.removeChildren();\n      rectangleBox.remove();\n      this.removeLabel(instanceId, groupName, id);\n    }\n  }\n\n  selectShape(instanceId: string, groupName: string, id: string, selected = true) {\n    if (this.mainLayer) {\n      const rectangleBox = this.getShapeByKey(instanceId, groupName, id);\n      if (rectangleBox && rectangleBox.children) {\n        const { bounds: { topLeft, topRight, bottomRight, bottomLeft, x, y, height, width } } = rectangleBox.children[0];\n        const points = [topLeft, topRight, bottomRight, bottomLeft];\n        const { displayColor } = rectangleBox.data;\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (selected) {\n          const radius = (rootStore.setting.pointSize / 2) / zoom;\n          const newColor = new Paper.Color(displayColor || POINT_COLOR);\n          points.forEach((point, index) => {\n            const sourceSeg = new Paper.Segment(point);\n            const targetSeg = index + 1 >= points.length ?\n              new Paper.Segment(points[0]) :\n              new Paper.Segment(points[index + 1]);\n\n            const lineBar = new Paper.Path({\n              segments: [sourceSeg, targetSeg],\n              strokeWidth: rootStore.setting.lineWidth / zoom,\n              fillColor: newColor,\n              strokeColor: newColor,\n              selectedColor: newColor,\n            });\n            lineBar.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NS_RESIZE : Cursor.EW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_PATH,\n              controlIndex: index,\n            };\n            rectangleBox.addChild(lineBar);\n          });\n          points.forEach((point, index) => {\n            const control = new Paper.Shape.Circle(point, radius);\n            control.strokeColor = newColor;\n            control.strokeWidth = rootStore.setting.lineWidth / zoom;\n            control.fillColor = newColor;\n            control.data = {\n              parentShape: id,\n              cursor: index % 2 === 0 ? Cursor.NWSE_RESIZE : Cursor.NESW_RESIZE,\n              type: SHAPE_TYPE.RECTANGLE_POINT,\n              controlIndex: index,\n              displayColor\n            };\n            rectangleBox.addChild(control);\n          });\n        } else {\n          rectangleBox.removeChildren();\n          const rectangle = new Paper.Shape.Rectangle({\n            point: [x, y],\n            size: [width, height],\n            fillColor: this.getAlphaColor(displayColor || POINT_COLOR),\n            strokeWidth: rootStore.setting.lineWidth / zoom\n          });\n          rectangle.data = {\n            parentShape: id,\n            cursor: Cursor.MOVE,\n            type: SHAPE_TYPE.RECTANGLE\n          };\n          rectangleBox.addChild(rectangle);\n        }\n      }\n    }\n  }\n\n  drawWarnings() {\n    this.warningLayer?.removeChildren();\n    const { qaWarnings: warnings } = rootStore.review;\n    if (warnings.length > 0) {\n      this.currentWarnings = warnings.filter((warning) => warning.frames[0] === this.props.currentFrame);\n      if (this.warningLayer) {\n        const strokeWitdth = (rootStore.setting.lineWidth * 2) / this.paperZoom;\n        const warningIconSize = (rootStore.setting.pointSize * 6) / this.paperZoom;\n        this.currentWarnings.forEach((warning) => {\n          const { id, groupName, shapeIds } = warning;\n          const shapes: paper.Item[] = [];\n          shapeIds!.forEach((shapeId) => {\n            const shape = this.getShapeByKey(id, groupName!, shapeId);\n            if (shape) {\n              shapes.push(shape);\n              if (shape.data.type !== SHAPE_TYPE.RECTANGLE_GROUP) {\n                const { x, y, width, height } = shape.bounds;\n                const boundRect = new Paper.Shape.Rectangle({\n                  point: [x - strokeWitdth, y - strokeWitdth],\n                  size: [width + 2 * strokeWitdth, height + 2 * strokeWitdth],\n                  strokeColor: new Paper.Color('#DC4624'),\n                  strokeWidth: strokeWitdth\n                });\n                this.warningLayer!.addChild(boundRect);\n              }\n            }\n          });\n          let position: number[] = [];\n          if (shapes.length > 1) {\n            const minXList: number[] = [];\n            const maxXList: number[] = [];\n            const minYList: number[] = [];\n            const maxYList: number[] = [];\n            shapes.forEach(({ bounds: { x, y, width, height } }) => {\n              minXList.push(x - strokeWitdth);\n              maxXList.push(x + width + strokeWitdth);\n              minYList.push(y - strokeWitdth);\n              maxYList.push(y + height + strokeWitdth);\n            });\n            const minX = Math.min(...minXList);\n            const maxX = Math.max(...maxXList);\n            const minY = Math.min(...minYList);\n            const maxY = Math.max(...maxYList);\n            const boundRect = new Paper.Shape.Rectangle({\n              point: [minX - 2 * strokeWitdth, minY - 2 * strokeWitdth],\n              size: [maxX - minX + 4 * strokeWitdth, maxY - minY + 4 * strokeWitdth],\n              strokeColor: new Paper.Color('#DC4624'),\n              strokeWidth: strokeWitdth\n            });\n            this.warningLayer!.addChild(boundRect);\n            position = [minX - warningIconSize / 2, minY - warningIconSize / 2];\n          } else if (shapes.length === 1) {\n            position = [shapes[0].bounds.x - warningIconSize / 2, shapes[0].bounds.y - warningIconSize / 2];\n          }\n          if (shapes.length > 0) {\n            const warningIcon = new Paper.Shape.Circle({\n              center: new Paper.Point(position[0], position[1]),\n              radius: warningIconSize / 3,\n              fillColor: '#DC4624',\n            });\n            const text = new Paper.PointText({\n              content: '!',\n              fontSize: FONT_SIZE / this.paperZoom,\n              fontWeight: '700',\n              fillColor: 'white',\n            });\n            warningIcon.data = { instanceId: id, groupName, shapeIds };\n            text.data = { instanceId: id, groupName, shapeIds };\n            text.position.x = position[0];\n            text.position.y = position[1];\n            this.warningLayer!.addChild(warningIcon);\n            this.warningLayer!.addChild(text);\n          }\n        });\n      }\n    }\n  }\n\n  render() {\n    return (\n      <div\n        ref={this.canvasContainer}\n        className=\"canvas\"\n        style={{ cursor: this.cursor }}\n      >\n        <canvas ref={this.canvas} />\n        {this.props.isReview && (\n          <div className=\"layer\">\n            <div className=\"tip\">\n              <span>{formatMessage('ORIGINAL_DATA')}</span>\n              <span>{formatMessage('REVIEW_TIP')}</span>\n              <Button className=\"close\" onClick={this.props.setReview} size=\"small\">\n                {formatMessage('REVIEW_CLOSE', { values: { shortcut: 'Ctrl+V' } })}\n              </Button>\n            </div>\n          </div>\n        )}\n        {(this.props.loading) && (\n          <div className=\"loading\">\n            {!this.raster && <Spin indicator={<LoadingOutlined style={{ fontSize: 100, color: '#00bad3' }} spin />} />}\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default Canvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}