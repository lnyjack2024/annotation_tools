{"ast":null,"code":"import { makeAutoObservable, runInAction, toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport View, { EventAction } from '../shapes/View';\nimport { DEFAULT_CAMERA_NAME, SIDEBAR_WIDTH, TOOLBAR_HEIGHT } from '../constants';\nimport { parseFramesByPaylod, parseLabelConfig } from '../utils';\nimport { ReviewMode } from '../types';\nimport loader from '../../../utils/image-preloader';\nimport { triggerFormRules } from '../../../utils/form';\n\n/**\n * store for frames\n * @class\n */\nexport default class FrameStore {\n  /**\n   * is single camera\n   * @getter\n   */\n  get isSingleCamera() {\n    const cameraNames = Object.keys(this.cameras);\n    return cameraNames.length === 1;\n  }\n\n  /**\n   * camera names\n   * @getter\n   */\n  get cameraNames() {\n    return Object.keys(this.cameras);\n  }\n\n  /**\n   * camera count\n   * @getter\n   */\n  get cameraCount() {\n    return Object.keys(this.cameras).length;\n  }\n\n  /**\n   * current cameras frames\n   * @getter\n   */\n  get frames() {\n    return this.cameras[this.currentCamera] || [];\n  }\n\n  /**\n   * current camera frame count\n   * @getter\n   */\n  get frameCount() {\n    return this.frames.length;\n  }\n\n  /**\n   * image boundary\n   * @getter\n   */\n  get imageBounds() {\n    return this.getImageBoundsForCamera(this.currentCamera);\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  get currentFrameAttributes() {\n    var _this$attributes$this;\n    const {\n      attributes = {}\n    } = ((_this$attributes$this = this.attributes[this.currentCamera]) === null || _this$attributes$this === void 0 ? void 0 : _this$attributes$this[this.currentFrame]) || {};\n    return attributes;\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * camera frames\n     */\n    this.cameras = {};\n    /**\n     * camera views\n     */\n    this.cameraViews = {};\n    /**\n     * current active camera\n     */\n    this.currentCameraView = null;\n    /**\n     * frame attributes (for each camera)\n     */\n    this.attributes = {};\n    /**\n     * next shape orders for different cameras & frames\n     */\n    this.nextShapeOrders = {};\n    /**\n     * current camera name\n     */\n    this.currentCamera = DEFAULT_CAMERA_NAME;\n    /**\n     * current frame index\n     */\n    this.currentFrame = 0;\n    /**\n     * frame loading\n     */\n    this.loading = true;\n    /**\n     * is playing\n     */\n    this.isPlaying = false;\n    /**\n     * play timer\n     */\n    this.playTimer = null;\n    /**\n     * image preloader\n     */\n    this.imagePreloader = null;\n    /**\n     * frame config (for each camera)\n     */\n    this.frameConfig = void 0;\n    /**\n     * get next shape order & do increment\n     * @param frameIndex\n     * @param camera\n     */\n    this.getNextShapeOrder = (frameIndex = this.currentFrame, camera = this.currentCamera) => {\n      if (this.nextShapeOrders[camera] === undefined) {\n        this.nextShapeOrders[camera] = {};\n      }\n      if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n        this.nextShapeOrders[camera][frameIndex] = 0;\n      }\n      const order = this.nextShapeOrders[camera][frameIndex];\n      this.nextShapeOrders[camera][frameIndex] += 1;\n      return order;\n    };\n    makeAutoObservable(this, {\n      rootStore: false,\n      cameraViews: false,\n      nextShapeOrders: false,\n      playTimer: false,\n      imagePreloader: false,\n      imageBounds: false\n    }, {\n      autoBind: true\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  async init(payload) {\n    const cameras = await parseFramesByPaylod(payload);\n    // parse frame config\n    this.frameConfig = parseLabelConfig(payload.frame_config);\n\n    // update attributes by camera & frames\n    let frameCount = 0;\n    let defaultAttributes;\n    if (this.frameConfig) {\n      const {\n        updatedValues\n      } = triggerFormRules(this.frameConfig, {});\n      if (updatedValues && Object.keys(updatedValues).length > 0) {\n        defaultAttributes = updatedValues;\n      }\n    }\n    const attributes = {};\n    cameras.forEach(({\n      camera,\n      frames\n    }) => {\n      const count = frames.length;\n      if (count > frameCount) {\n        frameCount = count;\n      }\n      if (!attributes[camera]) {\n        attributes[camera] = {};\n      }\n      frames.forEach((_, frameIndex) => {\n        if (!attributes[camera][frameIndex]) {\n          attributes[camera][frameIndex] = {\n            frameIndex,\n            valid: true,\n            originValid: true,\n            rotation: 0\n          };\n        }\n        if (defaultAttributes) {\n          if (this.rootStore.annotatable) {\n            // save to attributes directly\n            attributes[camera][frameIndex].attributes = {\n              ...defaultAttributes\n            };\n          } else {\n            // just show attribute keys if no value\n            attributes[camera][frameIndex].attributes = {};\n            Object.keys(defaultAttributes).forEach(key => {\n              attributes[camera][frameIndex].attributes[key] = '';\n            });\n          }\n        }\n      });\n    });\n    this.attributes = attributes;\n    runInAction(() => {\n      if (cameras.length > 0) {\n        // set cameras\n        this.cameras = cameras.reduce((acc, curr) => {\n          acc[curr.camera] = curr.frames;\n          return acc;\n        }, {});\n        // setup camera containers\n        cameras.forEach(({\n          camera\n        }) => this.createCameraView(camera));\n        // set current camera\n        this.setCamera(cameras[0].camera);\n        // preload image\n        const allImages = Array.from({\n          length: this.frameCount\n        }).flatMap((_, i) => cameras.map(c => c.frames[i]));\n        this.imagePreloader = loader(allImages);\n      }\n    });\n  }\n\n  /**\n   * init attributes\n   * @param result\n   */\n  initAttributes(result) {\n    const {\n      frames: attrs\n    } = result;\n    if (Array.isArray(attrs)) {\n      const attributes = toJS(this.attributes);\n      attrs.forEach(cameraItem => {\n        const {\n          camera,\n          frames\n        } = cameraItem || {};\n        if (camera) {\n          if (!attributes[camera]) {\n            attributes[camera] = {};\n          }\n          if (Array.isArray(frames)) {\n            frames.forEach(frameItem => {\n              const {\n                frameIndex,\n                imageUrl,\n                imageWidth,\n                imageHeight,\n                valid,\n                attributes: frameAttributes,\n                ...legacyAttributes\n              } = frameItem;\n              attributes[camera][frameIndex] = {\n                ...attributes[camera][frameIndex],\n                frameIndex,\n                imageUrl,\n                imageWidth,\n                imageHeight,\n                valid: valid !== false && valid !== 'false',\n                rotation: 0,\n                attributes: frameAttributes || Object.keys(legacyAttributes).length > 0 ? cloneDeep({\n                  ...legacyAttributes,\n                  ...frameAttributes\n                }) : undefined\n              };\n            });\n          }\n        }\n      });\n      this.attributes = attributes;\n    }\n  }\n\n  /**\n   * create camera view\n   * @param camera\n   */\n  createCameraView(camera) {\n    const {\n      autoSnapPoint\n    } = this.rootStore.config;\n    const cameraView = new View({\n      id: camera,\n      enableReview: !this.rootStore.isLabeling,\n      enableSnap: autoSnapPoint\n    });\n\n    // bind listeners\n    cameraView.on(EventAction.SELECTED, event => {\n      if (event.button === 2) {\n        return;\n      }\n      this.rootStore.shape.unselectShape();\n      this.rootStore.review.unselectReview();\n    });\n    cameraView.on(EventAction.POINTERDOWN, (p, event) => {\n      if (event.button === 2) {\n        return;\n      }\n      if (this.rootStore.config.reviewMode === ReviewMode.LABELING) {\n        this.rootStore.shape.addShape(p);\n      } else {\n        this.rootStore.review.addReview(p);\n      }\n    });\n    cameraView.on(EventAction.SCALE_CHANGED, scale => {\n      if (this.currentCamera === camera) {\n        this.rootStore.config.setViewScale(scale);\n      }\n    });\n    cameraView.on(EventAction.POSITION_CHANGED, p => {\n      if (this.currentCamera === camera) {\n        this.rootStore.config.setViewPosition(p);\n      }\n    });\n    this.cameraViews[camera] = cameraView;\n    return cameraView;\n  }\n\n  /**\n   * get image bounds for camera\n   * @param camera\n   */\n  getImageBoundsForCamera(camera) {\n    const cameraView = this.cameraViews[camera];\n    const w = cameraView === null || cameraView === void 0 ? void 0 : cameraView.image.width;\n    const h = cameraView === null || cameraView === void 0 ? void 0 : cameraView.image.height;\n    return {\n      left: 0,\n      top: 0,\n      right: w || 0,\n      bottom: h || 0\n    };\n  }\n\n  /**\n   * set current camera\n   * @param camera\n   */\n  setCamera(camera) {\n    // set selected camera\n    this.currentCamera = camera;\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.selected = true;\n      this.currentCameraView = cameraView;\n      this.updateCameraLayers(cameraView);\n    }\n  }\n\n  /**\n   * update working layers by camera view\n   * @param cameraView\n   */\n  updateCameraLayers(cameraView) {\n    // update view scale\n    this.rootStore.config.setViewScale(cameraView.viewScale);\n    // update shapes layer\n    this.rootStore.shape.currentLayer = cameraView.shapesLayer;\n    // update review layer\n    if (cameraView.reviewLayer) {\n      this.rootStore.review.setReviewLayer(cameraView.reviewLayer);\n      this.rootStore.review.setReviewLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n  }\n\n  /**\n   * set current frame\n   * @param frameIndex\n   */\n  setFrame(frameIndex) {\n    if (frameIndex !== this.currentFrame) {\n      // frame changes\n      this.currentFrame = frameIndex;\n      this.loading = true;\n      this.rootStore.review.clearAnchors();\n    }\n  }\n\n  /**\n   * when frame loaded\n   * @param image\n   */\n  onFrameLoaded() {\n    var _this$imagePreloader;\n    // turn off add mode\n    this.rootStore.config.setAddMode(false);\n    // setup current shapes\n    this.rootStore.shape.setupShapes();\n    // setup reivew anchors\n    this.rootStore.review.setupReviewAnchors();\n\n    // select shape\n    const {\n      selectedInstanceItems,\n      selectedInstances\n    } = this.rootStore.instance;\n    if (selectedInstanceItems.length > 0) {\n      this.rootStore.shape.selectShapeByInstanceItem(selectedInstanceItems);\n    } else if (selectedInstances.length > 0) {\n      this.rootStore.shape.updateShapesInInstance(selectedInstances);\n    }\n    // predict\n    this.rootStore.shape.predict();\n    this.loading = false;\n\n    // preload image\n    (_this$imagePreloader = this.imagePreloader) === null || _this$imagePreloader === void 0 ? void 0 : _this$imagePreloader.preload((this.currentFrame + 1) * this.cameraCount);\n\n    // when loaded, if is auto playing, play next frame\n    if (this.isPlaying) {\n      this.playTimer = window.setTimeout(() => {\n        this.setFrameByAutoPlay();\n      }, 300);\n    }\n  }\n\n  /**\n   * go to previous frame by step\n   * @param step\n   */\n  prev(step) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.max(this.currentFrame - step, 0));\n    }\n  }\n\n  /**\n   * go to next frame by step\n   * @param step\n   */\n  next(step) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.min(this.currentFrame + step, this.frameCount - 1));\n    }\n  }\n\n  /**\n   * toggle playing\n   */\n  togglePlaying() {\n    this.isPlaying = !this.isPlaying;\n    if (this.isPlaying) {\n      this.setFrameByAutoPlay();\n    } else if (this.playTimer) {\n      window.clearTimeout(this.playTimer);\n      this.playTimer = null;\n    }\n  }\n\n  /**\n   * set frame by auto play\n   */\n  setFrameByAutoPlay() {\n    if (this.currentFrame < this.frameCount - 1) {\n      this.setFrame(this.currentFrame + 1);\n    } else {\n      this.isPlaying = false;\n      this.setFrame(0);\n    }\n  }\n\n  /**\n   * can update attributes by camera & frameIndex\n   * @param camera\n   * @param frameIndex\n   */\n  canUpdateFrameForCamera(camera, frameIndex) {\n    if (this.rootStore.readonly) {\n      return false;\n    }\n    if (!this.attributes[camera] || !this.attributes[camera][frameIndex]) {\n      // attributes not initialized as expected, may have wrong frames or base_url input\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * set frame attributes & frame valid\n   * @param camera\n   * @param frames\n   * @param attributes\n   */\n  setFrameAttributesForCamera(camera, frames, attributes) {\n    const currentFramesData = [];\n    const newFramesData = [];\n    frames.sort((a, b) => a - b).forEach(frameIndex => {\n      if (this.canUpdateFrameForCamera(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{\n          camera,\n          frames: currentFramesData\n        }]\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{\n          camera,\n          frames: newFramesData\n        }]\n      });\n    }\n  }\n  /**\n   * update next shape order\n   * @param currentOrder\n   * @param frameIndex\n   * @param camera\n   */\n  updateNextShapeOrder(currentOrder, frameIndex = this.currentFrame, camera = this.currentCamera) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined || this.nextShapeOrders[camera][frameIndex] <= currentOrder) {\n      this.nextShapeOrders[camera][frameIndex] = currentOrder + 1;\n    }\n  }\n\n  /**\n   * update image size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  updateImageSize(camera, frameIndex, width, height) {\n    if (this.attributes[camera] && this.attributes[camera][frameIndex]) {\n      const {\n        imageWidth,\n        imageHeight\n      } = this.attributes[camera][frameIndex];\n      if (width > 0 && height > 0 || imageWidth === undefined || imageHeight === undefined) {\n        // only update when size valid, or size not initialized\n        this.attributes[camera][frameIndex].imageWidth = width;\n        this.attributes[camera][frameIndex].imageHeight = height;\n      }\n    }\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  framesJSON() {\n    return Object.keys(this.cameras).map(camera => ({\n      camera,\n      frames: this.cameras[camera].map((imageUrl, frameIndex) => ({\n        frameIndex,\n        imageUrl,\n        imageWidth: this.attributes[camera][frameIndex].imageWidth,\n        imageHeight: this.attributes[camera][frameIndex].imageHeight,\n        valid: true,\n        originValid: true,\n        rotation: 0,\n        attributes: toJS(this.attributes[camera][frameIndex].attributes)\n      }))\n    }));\n  }\n}","map":{"version":3,"names":["makeAutoObservable","runInAction","toJS","cloneDeep","View","EventAction","DEFAULT_CAMERA_NAME","SIDEBAR_WIDTH","TOOLBAR_HEIGHT","parseFramesByPaylod","parseLabelConfig","ReviewMode","loader","triggerFormRules","FrameStore","isSingleCamera","cameraNames","Object","keys","cameras","length","cameraCount","frames","currentCamera","frameCount","imageBounds","getImageBoundsForCamera","currentFrameAttributes","_this$attributes$this","attributes","currentFrame","constructor","rootStore","cameraViews","currentCameraView","nextShapeOrders","loading","isPlaying","playTimer","imagePreloader","frameConfig","getNextShapeOrder","frameIndex","camera","undefined","order","autoBind","init","payload","frame_config","defaultAttributes","updatedValues","forEach","count","_","valid","originValid","rotation","annotatable","key","reduce","acc","curr","createCameraView","setCamera","allImages","Array","from","flatMap","i","map","c","initAttributes","result","attrs","isArray","cameraItem","frameItem","imageUrl","imageWidth","imageHeight","frameAttributes","legacyAttributes","autoSnapPoint","config","cameraView","id","enableReview","isLabeling","enableSnap","on","SELECTED","event","button","shape","unselectShape","review","unselectReview","POINTERDOWN","p","reviewMode","LABELING","addShape","addReview","SCALE_CHANGED","scale","setViewScale","POSITION_CHANGED","setViewPosition","w","image","width","h","height","left","top","right","bottom","selected","updateCameraLayers","viewScale","currentLayer","shapesLayer","reviewLayer","setReviewLayer","setReviewLayerOffset","setFrame","clearAnchors","onFrameLoaded","_this$imagePreloader","setAddMode","setupShapes","setupReviewAnchors","selectedInstanceItems","selectedInstances","instance","selectShapeByInstanceItem","updateShapesInInstance","predict","preload","window","setTimeout","setFrameByAutoPlay","prev","step","Math","max","next","min","togglePlaying","clearTimeout","canUpdateFrameForCamera","readonly","setFrameAttributesForCamera","currentFramesData","newFramesData","sort","a","b","push","storeId","undo","preserve","save","updateNextShapeOrder","currentOrder","updateImageSize","framesJSON"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/FrameStore.ts"],"sourcesContent":["import { makeAutoObservable, runInAction, toJS } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport { message } from 'antd';\nimport { MessageType } from 'antd/es/message';\nimport RootStore from './RootStore';\nimport View, { EventAction } from '../shapes/View';\nimport { DEFAULT_CAMERA_NAME, SIDEBAR_WIDTH, TOOLBAR_HEIGHT } from '../constants';\nimport { parseFramesByPaylod, parseLabelConfig } from '../utils';\nimport { Payload, FrameAttributes, CameraFrameAttributes, LabelConfig, ReviewMode } from '../types';\nimport i18n from '../locales';\nimport loader, { ImagePreloader } from '../../../utils/image-preloader';\nimport { triggerFormRules } from '../../../utils/form';\n\n/**\n * store for frames\n * @class\n */\nexport default class FrameStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * camera frames\n   */\n  cameras: { [camera: string]: string[] } = {};\n\n  /**\n   * camera views\n   */\n  cameraViews: { [camera: string]: View } = {};\n\n  /**\n   * current active camera\n   */\n  currentCameraView: View | null = null;\n\n  /**\n   * frame attributes (for each camera)\n   */\n  attributes: {\n    [camera: string]: {\n      [frameIndex: number]: FrameAttributes;\n    }\n  } = {};\n\n  /**\n   * next shape orders for different cameras & frames\n   */\n  nextShapeOrders: {\n    [camera: string]: {\n      [frameIndex: number]: number;\n    }\n  } = {};\n\n  /**\n   * current camera name\n   */\n  currentCamera = DEFAULT_CAMERA_NAME;\n\n  /**\n   * current frame index\n   */\n  currentFrame = 0;\n\n  /**\n   * frame loading\n   */\n  loading = true;\n\n  /**\n   * is playing\n   */\n  isPlaying = false;\n\n  /**\n   * play timer\n   */\n  playTimer: number | null = null;\n\n  /**\n   * image preloader\n   */\n  imagePreloader: ImagePreloader | null = null;\n\n  /**\n   * frame config (for each camera)\n   */\n  frameConfig?: LabelConfig;\n\n  /**\n   * is single camera\n   * @getter\n   */\n  get isSingleCamera() {\n    const cameraNames = Object.keys(this.cameras);\n    return cameraNames.length === 1;\n  }\n\n  /**\n   * camera names\n   * @getter\n   */\n  get cameraNames() {\n    return Object.keys(this.cameras);\n  }\n\n  /**\n   * camera count\n   * @getter\n   */\n  get cameraCount() {\n    return Object.keys(this.cameras).length;\n  }\n\n  /**\n   * current cameras frames\n   * @getter\n   */\n  get frames() {\n    return this.cameras[this.currentCamera] || [];\n  }\n\n  /**\n   * current camera frame count\n   * @getter\n   */\n  get frameCount() {\n    return this.frames.length;\n  }\n\n  /**\n   * image boundary\n   * @getter\n   */\n  get imageBounds() {\n    return this.getImageBoundsForCamera(this.currentCamera);\n  }\n\n  /**\n   * is current frame attributes\n   * @getter\n   */\n  get currentFrameAttributes() {\n    const { attributes = {} } = this.attributes[this.currentCamera]?.[this.currentFrame] || {};\n    return attributes;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeAutoObservable(this, {\n      rootStore: false,\n      cameraViews: false,\n      nextShapeOrders: false,\n      playTimer: false,\n      imagePreloader: false,\n      imageBounds: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  async init(payload: Payload) {\n    const cameras = await parseFramesByPaylod(payload);\n    // parse frame config\n    this.frameConfig = parseLabelConfig(payload.frame_config);\n\n    // update attributes by camera & frames\n    let frameCount = 0;\n    let defaultAttributes: any;\n    if (this.frameConfig) {\n      const { updatedValues } = triggerFormRules(this.frameConfig, {});\n      if (updatedValues && Object.keys(updatedValues).length > 0) {\n        defaultAttributes = updatedValues;\n      }\n    }\n    const attributes: {\n      [camera: string]: {\n        [frameIndex: number]: FrameAttributes;\n      }\n    } = {};\n    cameras.forEach(({ camera, frames }) => {\n      const count = frames.length;\n      if (count > frameCount) {\n        frameCount = count;\n      }\n      if (!attributes[camera]) {\n        attributes[camera] = {};\n      }\n      frames.forEach((_, frameIndex) => {\n        if (!attributes[camera][frameIndex]) {\n          attributes[camera][frameIndex] = {\n            frameIndex,\n            valid: true,\n            originValid: true,\n            rotation: 0,\n          };\n        }\n        if (defaultAttributes) {\n          if (this.rootStore.annotatable) {\n            // save to attributes directly\n            attributes[camera][frameIndex].attributes = { ...defaultAttributes };\n          } else {\n            // just show attribute keys if no value\n            attributes[camera][frameIndex].attributes = {};\n            Object.keys(defaultAttributes).forEach((key) => {\n              attributes[camera][frameIndex].attributes[key] = '';\n            });\n          }\n        }\n      });\n    });\n    this.attributes = attributes;\n    runInAction(() => {\n      if (cameras.length > 0) {\n        // set cameras\n        this.cameras = cameras.reduce((acc, curr) => {\n          acc[curr.camera] = curr.frames;\n          return acc;\n        }, {} as { [camera: string]: string[] });\n        // setup camera containers\n        cameras.forEach(({ camera }) => this.createCameraView(camera));\n        // set current camera\n        this.setCamera(cameras[0].camera);\n        // preload image\n        const allImages = Array.from({ length: this.frameCount }).flatMap((_, i) => cameras.map((c) => c.frames[i]));\n        this.imagePreloader = loader(allImages);\n      }\n    });\n  }\n\n  /**\n   * init attributes\n   * @param result\n   */\n  initAttributes(result: any) {\n    const { frames: attrs } = result;\n    if (Array.isArray(attrs)) {\n      const attributes = toJS(this.attributes);\n\n      attrs.forEach((cameraItem) => {\n        const { camera, frames } = cameraItem || {};\n        if (camera) {\n          if (!attributes[camera]) {\n            attributes[camera] = {};\n          }\n          if (Array.isArray(frames)) {\n            frames.forEach((frameItem) => {\n              const { frameIndex, imageUrl, imageWidth, imageHeight, valid, attributes: frameAttributes, ...legacyAttributes } = frameItem;\n              attributes[camera][frameIndex] = {\n                ...attributes[camera][frameIndex],\n                frameIndex,\n                imageUrl,\n                imageWidth,\n                imageHeight,\n                valid: valid !== false && valid !== 'false',\n                rotation: 0,\n                attributes: frameAttributes || Object.keys(legacyAttributes).length > 0 ? cloneDeep({ ...legacyAttributes, ...frameAttributes }) : undefined,\n              };\n            });\n          }\n        }\n      });\n\n      this.attributes = attributes;\n    }\n  }\n\n  /**\n   * create camera view\n   * @param camera\n   */\n  createCameraView(camera: string) {\n    const { autoSnapPoint } = this.rootStore.config;\n    const cameraView = new View({\n      id: camera,\n      enableReview: !this.rootStore.isLabeling,\n      enableSnap: autoSnapPoint,\n    });\n\n    // bind listeners\n    cameraView.on(EventAction.SELECTED, (event) => {\n      if (event.button === 2) {\n        return;\n      }\n      this.rootStore.shape.unselectShape();\n      this.rootStore.review.unselectReview();\n    });\n    cameraView.on(EventAction.POINTERDOWN, (p, event) => {\n      if (event.button === 2) {\n        return;\n      }\n      if (this.rootStore.config.reviewMode === ReviewMode.LABELING) {\n        this.rootStore.shape.addShape(p);\n      } else {\n        this.rootStore.review.addReview(p);\n      }\n    });\n    cameraView.on(EventAction.SCALE_CHANGED, (scale) => {\n      if (this.currentCamera === camera) {\n        this.rootStore.config.setViewScale(scale);\n      }\n    });\n    cameraView.on(EventAction.POSITION_CHANGED, (p) => {\n      if (this.currentCamera === camera) {\n        this.rootStore.config.setViewPosition(p);\n      }\n    });\n\n    this.cameraViews[camera] = cameraView;\n    return cameraView;\n  }\n\n  /**\n   * get image bounds for camera\n   * @param camera\n   */\n  getImageBoundsForCamera(camera: string) {\n    const cameraView = this.cameraViews[camera];\n    const w = cameraView?.image.width;\n    const h = cameraView?.image.height;\n    return { left: 0, top: 0, right: w || 0, bottom: h || 0 };\n  }\n\n  /**\n   * set current camera\n   * @param camera\n   */\n  setCamera(camera: string) {\n    // set selected camera\n    this.currentCamera = camera;\n    const cameraView = this.cameraViews[camera];\n    if (cameraView) {\n      cameraView.selected = true;\n      this.currentCameraView = cameraView;\n      this.updateCameraLayers(cameraView);\n    }\n  }\n\n  /**\n   * update working layers by camera view\n   * @param cameraView\n   */\n  updateCameraLayers(cameraView: View) {\n    // update view scale\n    this.rootStore.config.setViewScale(cameraView.viewScale);\n    // update shapes layer\n    this.rootStore.shape.currentLayer = cameraView.shapesLayer;\n    // update review layer\n    if (cameraView.reviewLayer) {\n      this.rootStore.review.setReviewLayer(cameraView.reviewLayer);\n      this.rootStore.review.setReviewLayerOffset(SIDEBAR_WIDTH, TOOLBAR_HEIGHT * 2);\n    }\n  }\n\n  /**\n   * set current frame\n   * @param frameIndex\n   */\n  setFrame(frameIndex: number) {\n    if (frameIndex !== this.currentFrame) {\n      // frame changes\n      this.currentFrame = frameIndex;\n      this.loading = true;\n      this.rootStore.review.clearAnchors();\n    }\n  }\n\n  /**\n   * when frame loaded\n   * @param image\n   */\n  onFrameLoaded() {\n    // turn off add mode\n    this.rootStore.config.setAddMode(false);\n    // setup current shapes\n    this.rootStore.shape.setupShapes();\n    // setup reivew anchors\n    this.rootStore.review.setupReviewAnchors();\n\n    // select shape\n    const { selectedInstanceItems, selectedInstances } = this.rootStore.instance;\n    if (selectedInstanceItems.length > 0) {\n      this.rootStore.shape.selectShapeByInstanceItem(selectedInstanceItems);\n    } else if (selectedInstances.length > 0) {\n      this.rootStore.shape.updateShapesInInstance(selectedInstances);\n    }\n    // predict\n    this.rootStore.shape.predict();\n\n    this.loading = false;\n\n    // preload image\n    this.imagePreloader?.preload((this.currentFrame + 1) * this.cameraCount);\n\n    // when loaded, if is auto playing, play next frame\n    if (this.isPlaying) {\n      this.playTimer = window.setTimeout(() => {\n        this.setFrameByAutoPlay();\n      }, 300);\n    }\n  }\n\n  /**\n   * go to previous frame by step\n   * @param step\n   */\n  prev(step: number) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.max(this.currentFrame - step, 0));\n    }\n  }\n\n  /**\n   * go to next frame by step\n   * @param step\n   */\n  next(step: number) {\n    if (!this.isPlaying) {\n      this.setFrame(Math.min(this.currentFrame + step, this.frameCount - 1));\n    }\n  }\n\n  /**\n   * toggle playing\n   */\n  togglePlaying() {\n    this.isPlaying = !this.isPlaying;\n    if (this.isPlaying) {\n      this.setFrameByAutoPlay();\n    } else if (this.playTimer) {\n      window.clearTimeout(this.playTimer);\n      this.playTimer = null;\n    }\n  }\n\n  /**\n   * set frame by auto play\n   */\n  setFrameByAutoPlay() {\n    if (this.currentFrame < this.frameCount - 1) {\n      this.setFrame(this.currentFrame + 1);\n    } else {\n      this.isPlaying = false;\n      this.setFrame(0);\n    }\n  }\n\n  /**\n   * can update attributes by camera & frameIndex\n   * @param camera\n   * @param frameIndex\n   */\n  canUpdateFrameForCamera(camera: string, frameIndex: number) {\n    if (this.rootStore.readonly) {\n      return false;\n    }\n    if (!this.attributes[camera] || !this.attributes[camera][frameIndex]) {\n      // attributes not initialized as expected, may have wrong frames or base_url input\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * set frame attributes & frame valid\n   * @param camera\n   * @param frames\n   * @param attributes\n   */\n  setFrameAttributesForCamera(\n    camera: string,\n    frames: number[],\n    attributes: any,\n  ) {\n    const currentFramesData: FrameAttributes[] = [];\n    const newFramesData: FrameAttributes[] = [];\n    frames.sort((a, b) => a - b).forEach((frameIndex) => {\n      if (this.canUpdateFrameForCamera(camera, frameIndex)) {\n        currentFramesData.push(toJS(this.attributes[camera][frameIndex]));\n        this.attributes[camera][frameIndex].attributes = cloneDeep(attributes);\n        newFramesData.push(toJS(this.attributes[camera][frameIndex]));\n      }\n    });\n    if (currentFramesData.length > 0) {\n      const storeId = this.rootStore.undo.preserve({\n        frames: [{ camera, frames: currentFramesData }],\n      });\n      this.rootStore.undo.save(storeId, {\n        frames: [{ camera, frames: newFramesData }],\n      });\n    }\n  }\n\n  /**\n   * get next shape order & do increment\n   * @param frameIndex\n   * @param camera\n   */\n  getNextShapeOrder = (frameIndex = this.currentFrame, camera = this.currentCamera) => {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined) {\n      this.nextShapeOrders[camera][frameIndex] = 0;\n    }\n\n    const order = this.nextShapeOrders[camera][frameIndex];\n    this.nextShapeOrders[camera][frameIndex] += 1;\n    return order;\n  };\n\n  /**\n   * update next shape order\n   * @param currentOrder\n   * @param frameIndex\n   * @param camera\n   */\n  updateNextShapeOrder(currentOrder: number, frameIndex = this.currentFrame, camera = this.currentCamera) {\n    if (this.nextShapeOrders[camera] === undefined) {\n      this.nextShapeOrders[camera] = {};\n    }\n    if (this.nextShapeOrders[camera][frameIndex] === undefined || this.nextShapeOrders[camera][frameIndex] <= currentOrder) {\n      this.nextShapeOrders[camera][frameIndex] = currentOrder + 1;\n    }\n  }\n\n  /**\n   * update image size\n   * @param camera\n   * @param frameIndex\n   * @param width\n   * @param height\n   */\n  updateImageSize(camera: string, frameIndex: number, width: number, height: number) {\n    if (this.attributes[camera] && this.attributes[camera][frameIndex]) {\n      const { imageWidth, imageHeight } = this.attributes[camera][frameIndex];\n      if ((width > 0 && height > 0) || imageWidth === undefined || imageHeight === undefined) {\n        // only update when size valid, or size not initialized\n        this.attributes[camera][frameIndex].imageWidth = width;\n        this.attributes[camera][frameIndex].imageHeight = height;\n      }\n    }\n  }\n\n  /**\n   * get frame attributes json data (for save)\n   */\n  framesJSON(): CameraFrameAttributes[] {\n    return Object.keys(this.cameras).map((camera) => ({\n      camera,\n      frames: this.cameras[camera].map((imageUrl, frameIndex) => ({\n        frameIndex,\n        imageUrl,\n        imageWidth: this.attributes[camera][frameIndex].imageWidth,\n        imageHeight: this.attributes[camera][frameIndex].imageHeight,\n        valid: true,\n        originValid: true,\n        rotation: 0,\n        attributes: toJS(this.attributes[camera][frameIndex].attributes),\n      })),\n    }));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}