{"ast":null,"code":"/**\n * vector based on canvas coordinates\n * @class\n */\nexport class Vector {\n  get norm() {\n    return Math.sqrt(this.x ** 2 + this.y ** 2);\n  }\n  get normalVector() {\n    return new Vector(this.y, -this.x);\n  }\n  constructor(...args) {\n    this.x = void 0;\n    this.y = void 0;\n    const [arg1, arg2] = args;\n    if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n      this.x = arg1;\n      this.y = arg2;\n    } else if (arg1 && arg1.x !== undefined && arg1.y !== undefined && arg2 && arg2.x !== undefined && arg2.y !== undefined) {\n      this.x = arg1.x - arg2.x;\n      this.y = arg1.y - arg2.y;\n    } else {\n      throw new Error('wrong arguments');\n    }\n  }\n\n  /**\n   * add vector\n   * @param vector\n   */\n  add(vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n    return this;\n  }\n\n  /**\n   * divide num\n   * @param num\n   */\n  divide(num) {\n    this.x /= num;\n    this.y /= num;\n    return this;\n  }\n\n  /**\n   * normalize norm to base\n   * @param base\n   */\n  normalize(base = 1) {\n    const a = base / this.norm;\n    this.x *= a;\n    this.y *= a;\n    return this;\n  }\n\n  /**\n   * dot of another vector\n   * @param vector\n   */\n  dot(vector) {\n    return this.x * vector.x + this.y * vector.y;\n  }\n\n  /**\n   * clone a new vector\n   * @returns\n   */\n  clone() {\n    return new Vector(this.x, this.y);\n  }\n}\nexport function calcOutlineForLine(points, width) {\n  const list1 = [];\n  const list2 = [];\n  let lastSegVector;\n  for (let i = 0; i < points.length - 1; i += 1) {\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const vector = new Vector(p1, p2).normalVector.normalize(width);\n\n    // first point\n    if (i === 0) {\n      list1.push({\n        x: p1.x + vector.x,\n        y: p1.y + vector.y\n      });\n      list2.unshift({\n        x: p1.x - vector.x,\n        y: p1.y - vector.y\n      });\n    }\n\n    // points between first & last\n    if (lastSegVector) {\n      const pointVector = vector.clone().add(lastSegVector);\n      const dot = vector.dot(pointVector) + 1; // add 1 to fix cos = 0 issue\n      const cos = dot / (vector.norm * pointVector.norm);\n      const dis = width / cos;\n      const actualVector = pointVector.normalize(dis);\n      list1.push({\n        x: p1.x + actualVector.x,\n        y: p1.y + actualVector.y\n      });\n      list2.unshift({\n        x: p1.x - actualVector.x,\n        y: p1.y - actualVector.y\n      });\n    }\n    lastSegVector = vector;\n\n    // last point\n    if (i === points.length - 2) {\n      list1.push({\n        x: p2.x + vector.x,\n        y: p2.y + vector.y\n      });\n      list2.unshift({\n        x: p2.x - vector.x,\n        y: p2.y - vector.y\n      });\n    }\n  }\n  return list1.concat(list2);\n}","map":{"version":3,"names":["Vector","norm","Math","sqrt","x","y","normalVector","constructor","args","arg1","arg2","undefined","Error","add","vector","divide","num","normalize","base","a","dot","clone","calcOutlineForLine","points","width","list1","list2","lastSegVector","i","length","p1","p2","push","unshift","pointVector","cos","dis","actualVector","concat"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/utils/vector.ts"],"sourcesContent":["interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * vector based on canvas coordinates\n * @class\n */\nexport class Vector {\n  x: number;\n\n  y: number;\n\n  get norm() {\n    return Math.sqrt(this.x ** 2 + this.y ** 2);\n  }\n\n  get normalVector() {\n    return new Vector(this.y, -this.x);\n  }\n\n  constructor(...args: [number, number] | [Point, Point]) {\n    const [arg1, arg2] = args;\n    if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n      this.x = arg1;\n      this.y = arg2;\n    } else if (\n      arg1 && (arg1 as Point).x !== undefined && (arg1 as Point).y !== undefined &&\n      arg2 && (arg2 as Point).x !== undefined && (arg2 as Point).y !== undefined\n    ) {\n      this.x = (arg1 as Point).x - (arg2 as Point).x;\n      this.y = (arg1 as Point).y - (arg2 as Point).y;\n    } else {\n      throw new Error('wrong arguments');\n    }\n  }\n\n  /**\n   * add vector\n   * @param vector\n   */\n  add(vector: Vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n    return this;\n  }\n\n  /**\n   * divide num\n   * @param num\n   */\n  divide(num: number) {\n    this.x /= num;\n    this.y /= num;\n    return this;\n  }\n\n  /**\n   * normalize norm to base\n   * @param base\n   */\n  normalize(base = 1) {\n    const a = base / this.norm;\n    this.x *= a;\n    this.y *= a;\n    return this;\n  }\n\n  /**\n   * dot of another vector\n   * @param vector\n   */\n  dot(vector: Vector) {\n    return this.x * vector.x + this.y * vector.y;\n  }\n\n  /**\n   * clone a new vector\n   * @returns\n   */\n  clone() {\n    return new Vector(this.x, this.y);\n  }\n}\n\nexport function calcOutlineForLine(points: Point[], width: number) {\n  const list1: Point[] = [];\n  const list2: Point[] = [];\n\n  let lastSegVector: Vector | undefined;\n  for (let i = 0; i < points.length - 1; i += 1) {\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const vector = new Vector(p1, p2).normalVector.normalize(width);\n\n    // first point\n    if (i === 0) {\n      list1.push({\n        x: p1.x + vector.x,\n        y: p1.y + vector.y,\n      });\n      list2.unshift({\n        x: p1.x - vector.x,\n        y: p1.y - vector.y,\n      });\n    }\n\n    // points between first & last\n    if (lastSegVector) {\n      const pointVector = vector.clone().add(lastSegVector);\n      const dot = vector.dot(pointVector) + 1; // add 1 to fix cos = 0 issue\n      const cos = dot / (vector.norm * pointVector.norm);\n      const dis = width / cos;\n      const actualVector = pointVector.normalize(dis);\n      list1.push({\n        x: p1.x + actualVector.x,\n        y: p1.y + actualVector.y,\n      });\n      list2.unshift({\n        x: p1.x - actualVector.x,\n        y: p1.y - actualVector.y,\n      });\n    }\n    lastSegVector = vector;\n\n    // last point\n    if (i === points.length - 2) {\n      list1.push({\n        x: p2.x + vector.x,\n        y: p2.y + vector.y,\n      });\n      list2.unshift({\n        x: p2.x - vector.x,\n        y: p2.y - vector.y,\n      });\n    }\n  }\n\n  return list1.concat(list2);\n}\n"],"mappings":"AAKA;AACA;AACA;AACA;AACA,OAAO,MAAMA,MAAM,CAAC;EAKlB,IAAIC,IAAIA,CAAA,EAAG;IACT,OAAOC,IAAI,CAACC,IAAI,CAAC,IAAI,CAACC,CAAC,IAAI,CAAC,GAAG,IAAI,CAACC,CAAC,IAAI,CAAC,CAAC;EAC7C;EAEA,IAAIC,YAAYA,CAAA,EAAG;IACjB,OAAO,IAAIN,MAAM,CAAC,IAAI,CAACK,CAAC,EAAE,CAAC,IAAI,CAACD,CAAC,CAAC;EACpC;EAEAG,WAAWA,CAAC,GAAGC,IAAuC,EAAE;IAAA,KAZxDJ,CAAC;IAAA,KAEDC,CAAC;IAWC,MAAM,CAACI,IAAI,EAAEC,IAAI,CAAC,GAAGF,IAAI;IACzB,IAAI,OAAOC,IAAI,KAAK,QAAQ,IAAI,OAAOC,IAAI,KAAK,QAAQ,EAAE;MACxD,IAAI,CAACN,CAAC,GAAGK,IAAI;MACb,IAAI,CAACJ,CAAC,GAAGK,IAAI;IACf,CAAC,MAAM,IACLD,IAAI,IAAKA,IAAI,CAAWL,CAAC,KAAKO,SAAS,IAAKF,IAAI,CAAWJ,CAAC,KAAKM,SAAS,IAC1ED,IAAI,IAAKA,IAAI,CAAWN,CAAC,KAAKO,SAAS,IAAKD,IAAI,CAAWL,CAAC,KAAKM,SAAS,EAC1E;MACA,IAAI,CAACP,CAAC,GAAIK,IAAI,CAAWL,CAAC,GAAIM,IAAI,CAAWN,CAAC;MAC9C,IAAI,CAACC,CAAC,GAAII,IAAI,CAAWJ,CAAC,GAAIK,IAAI,CAAWL,CAAC;IAChD,CAAC,MAAM;MACL,MAAM,IAAIO,KAAK,CAAC,iBAAiB,CAAC;IACpC;EACF;;EAEA;AACF;AACA;AACA;EACEC,GAAGA,CAACC,MAAc,EAAE;IAClB,IAAI,CAACV,CAAC,IAAIU,MAAM,CAACV,CAAC;IAClB,IAAI,CAACC,CAAC,IAAIS,MAAM,CAACT,CAAC;IAClB,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACEU,MAAMA,CAACC,GAAW,EAAE;IAClB,IAAI,CAACZ,CAAC,IAAIY,GAAG;IACb,IAAI,CAACX,CAAC,IAAIW,GAAG;IACb,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACEC,SAASA,CAACC,IAAI,GAAG,CAAC,EAAE;IAClB,MAAMC,CAAC,GAAGD,IAAI,GAAG,IAAI,CAACjB,IAAI;IAC1B,IAAI,CAACG,CAAC,IAAIe,CAAC;IACX,IAAI,CAACd,CAAC,IAAIc,CAAC;IACX,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACEC,GAAGA,CAACN,MAAc,EAAE;IAClB,OAAO,IAAI,CAACV,CAAC,GAAGU,MAAM,CAACV,CAAC,GAAG,IAAI,CAACC,CAAC,GAAGS,MAAM,CAACT,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;EACEgB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIrB,MAAM,CAAC,IAAI,CAACI,CAAC,EAAE,IAAI,CAACC,CAAC,CAAC;EACnC;AACF;AAEA,OAAO,SAASiB,kBAAkBA,CAACC,MAAe,EAAEC,KAAa,EAAE;EACjE,MAAMC,KAAc,GAAG,EAAE;EACzB,MAAMC,KAAc,GAAG,EAAE;EAEzB,IAAIC,aAAiC;EACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,CAACM,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;IAC7C,MAAME,EAAE,GAAGP,MAAM,CAACK,CAAC,CAAC;IACpB,MAAMG,EAAE,GAAGR,MAAM,CAACK,CAAC,GAAG,CAAC,CAAC;IACxB,MAAMd,MAAM,GAAG,IAAId,MAAM,CAAC8B,EAAE,EAAEC,EAAE,CAAC,CAACzB,YAAY,CAACW,SAAS,CAACO,KAAK,CAAC;;IAE/D;IACA,IAAII,CAAC,KAAK,CAAC,EAAE;MACXH,KAAK,CAACO,IAAI,CAAC;QACT5B,CAAC,EAAE0B,EAAE,CAAC1B,CAAC,GAAGU,MAAM,CAACV,CAAC;QAClBC,CAAC,EAAEyB,EAAE,CAACzB,CAAC,GAAGS,MAAM,CAACT;MACnB,CAAC,CAAC;MACFqB,KAAK,CAACO,OAAO,CAAC;QACZ7B,CAAC,EAAE0B,EAAE,CAAC1B,CAAC,GAAGU,MAAM,CAACV,CAAC;QAClBC,CAAC,EAAEyB,EAAE,CAACzB,CAAC,GAAGS,MAAM,CAACT;MACnB,CAAC,CAAC;IACJ;;IAEA;IACA,IAAIsB,aAAa,EAAE;MACjB,MAAMO,WAAW,GAAGpB,MAAM,CAACO,KAAK,CAAC,CAAC,CAACR,GAAG,CAACc,aAAa,CAAC;MACrD,MAAMP,GAAG,GAAGN,MAAM,CAACM,GAAG,CAACc,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;MACzC,MAAMC,GAAG,GAAGf,GAAG,IAAIN,MAAM,CAACb,IAAI,GAAGiC,WAAW,CAACjC,IAAI,CAAC;MAClD,MAAMmC,GAAG,GAAGZ,KAAK,GAAGW,GAAG;MACvB,MAAME,YAAY,GAAGH,WAAW,CAACjB,SAAS,CAACmB,GAAG,CAAC;MAC/CX,KAAK,CAACO,IAAI,CAAC;QACT5B,CAAC,EAAE0B,EAAE,CAAC1B,CAAC,GAAGiC,YAAY,CAACjC,CAAC;QACxBC,CAAC,EAAEyB,EAAE,CAACzB,CAAC,GAAGgC,YAAY,CAAChC;MACzB,CAAC,CAAC;MACFqB,KAAK,CAACO,OAAO,CAAC;QACZ7B,CAAC,EAAE0B,EAAE,CAAC1B,CAAC,GAAGiC,YAAY,CAACjC,CAAC;QACxBC,CAAC,EAAEyB,EAAE,CAACzB,CAAC,GAAGgC,YAAY,CAAChC;MACzB,CAAC,CAAC;IACJ;IACAsB,aAAa,GAAGb,MAAM;;IAEtB;IACA,IAAIc,CAAC,KAAKL,MAAM,CAACM,MAAM,GAAG,CAAC,EAAE;MAC3BJ,KAAK,CAACO,IAAI,CAAC;QACT5B,CAAC,EAAE2B,EAAE,CAAC3B,CAAC,GAAGU,MAAM,CAACV,CAAC;QAClBC,CAAC,EAAE0B,EAAE,CAAC1B,CAAC,GAAGS,MAAM,CAACT;MACnB,CAAC,CAAC;MACFqB,KAAK,CAACO,OAAO,CAAC;QACZ7B,CAAC,EAAE2B,EAAE,CAAC3B,CAAC,GAAGU,MAAM,CAACV,CAAC;QAClBC,CAAC,EAAE0B,EAAE,CAAC1B,CAAC,GAAGS,MAAM,CAACT;MACnB,CAAC,CAAC;IACJ;EACF;EAEA,OAAOoB,KAAK,CAACa,MAAM,CAACZ,KAAK,CAAC;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module"}