{"ast":null,"code":"/*!\n * @pixi/canvas-graphics - v6.2.2\n * Compiled Wed, 26 Jan 2022 16:23:27 UTC\n *\n * @pixi/canvas-graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, RenderTexture } from '@pixi/core';\nimport { Matrix, SHAPES } from '@pixi/math';\nimport { canvasUtils, CanvasRenderer } from '@pixi/canvas-renderer';\nimport { Graphics } from '@pixi/graphics';\n\n/**\n * Utilities for polygon\n * @class\n * @private\n */\nvar PolygonUtils = /** @class */function () {\n  function PolygonUtils() {}\n  /**\n  * Calculate points of an offset polygon\n  * @see {@link http://csharphelper.com/blog/2016/01/enlarge-a-polygon-in-c/}\n  *\n  * @private\n  * @param {number[]} points - polygon coordinates\n  * @param {number} offset\n  * @return {number[]} - offset points\n  */\n  PolygonUtils.offsetPolygon = function (points, offset) {\n    var offsetPoints = [];\n    var length = points.length;\n    offset = PolygonUtils.isPolygonClockwise(points) ? offset : -1 * offset;\n    for (var j = 0; j < length; j += 2) {\n      // Find location for the points before and after j\n      var i = j - 2;\n      if (i < 0) {\n        i += length;\n      }\n      var k = (j + 2) % length;\n      // Move the points by the offset\n      var v1x = points[j] - points[i];\n      var v1y = points[j + 1] - points[i + 1];\n      var len = Math.sqrt(v1x * v1x + v1y * v1y);\n      v1x /= len;\n      v1y /= len;\n      v1x *= offset;\n      v1y *= offset;\n      var norm1x = -v1y;\n      var norm1y = v1x;\n      var pij1 = [points[i] + norm1x, points[i + 1] + norm1y];\n      var pij2 = [points[j] + norm1x, points[j + 1] + norm1y];\n      var v2x = points[k] - points[j];\n      var v2y = points[k + 1] - points[j + 1];\n      len = Math.sqrt(v2x * v2x + v2y * v2y);\n      v2x /= len;\n      v2y /= len;\n      v2x *= offset;\n      v2y *= offset;\n      var norm2x = -v2y;\n      var norm2y = v2x;\n      var pjk1 = [points[j] + norm2x, points[j + 1] + norm2y];\n      var pjk2 = [points[k] + norm2x, points[k + 1] + norm2y];\n      // Find where the shifted lines ij and jk intersect.\n      var intersectPoint = PolygonUtils.findIntersection(pij1[0], pij1[1], pij2[0], pij2[1], pjk1[0], pjk1[1], pjk2[0], pjk2[1]);\n      if (intersectPoint) {\n        offsetPoints.push.apply(offsetPoints, intersectPoint);\n      }\n    }\n    return offsetPoints;\n  };\n  /**\n  * Determine the intersection point of two line segments\n  * @see {@link here http://paulbourke.net/geometry/pointlineplane/}\n  *\n  * @private\n  * @param {number} x1 - x-coordinate of start point at first line\n  * @param {number} y1 - y-coordinate of start point at first line\n  * @param {number} x2 - x-coordinate of end point at first line\n  * @param {number} y2 - y-coordinate of end point at first line\n  * @param {number} x3 - x-coordinate of start point at second line\n  * @param {number} y3 - y-coordinate of start point at second line\n  * @param {number} x4 - x-coordinate of end point at second line\n  * @param {number} y4 - y-coordinate of end point at second line\n  * @returns {[number, number] | null} - [x, y] coordinates of intersection\n  */\n  PolygonUtils.findIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    // lines are parallel\n    if (denominator === 0) {\n      // lines are coincident\n      if (numeratorA === 0 && numeratorB === 0) {\n        return [(x1 + x2) / 2, (y1 + y2) / 2];\n      }\n      return null;\n    }\n    var uA = numeratorA / denominator;\n    return [x1 + uA * (x2 - x1), y1 + uA * (y2 - y1)];\n  };\n  /**\n   * Determine polygon are clockwise or counterclockwise\n   * @see {@link https://stackoverflow.com/questions/1165647}\n   *\n   * @private\n   * @param {number[]} polygon - polygon coordinates\n   * @return {boolean}\n   */\n  PolygonUtils.isPolygonClockwise = function (polygon) {\n    var sum = 0;\n    for (var i = 0; i < polygon.length - 2; i += 2) {\n      sum += (polygon[i + 2] - polygon[i]) * (polygon[i + 3] + polygon[i + 1]);\n    }\n    return sum > 0;\n  };\n  return PolygonUtils;\n}();\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nvar CanvasGraphicsRenderer = /** @class */function () {\n  /**\n   * @param renderer - A reference to the current renderer.\n   */\n  function CanvasGraphicsRenderer(renderer) {\n    this._svgMatrix = null;\n    this._tempMatrix = new Matrix();\n    this.renderer = renderer;\n  }\n  /**\n   * calculates fill/stroke style for canvas\n   *\n   * @private\n   * @param style - A graphics {@link PIXI.FILL_STYLE} where if `texture` is specified then a tinted CanvasPattern\n   * will be used for the fill.stroke\n   * @param tint - color to set the fill/stroke too.\n   */\n  CanvasGraphicsRenderer.prototype._calcCanvasStyle = function (style, tint) {\n    var res;\n    if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture) {\n      if (style.texture.valid) {\n        res = canvasUtils.getTintedPattern(style.texture, tint);\n        this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);\n      } else {\n        res = '#808080';\n      }\n    } else {\n      res = \"#\" + (\"00000\" + (tint | 0).toString(16)).substr(-6);\n    }\n    return res;\n  };\n  /**\n   * Renders a Graphics object to a canvas.\n   *\n   * @param graphics - the actual graphics object to render\n   */\n  CanvasGraphicsRenderer.prototype.render = function (graphics) {\n    var renderer = this.renderer;\n    var context = renderer.context;\n    var worldAlpha = graphics.worldAlpha;\n    var transform = graphics.transform.worldTransform;\n    renderer.setContextTransform(transform);\n    renderer.setBlendMode(graphics.blendMode);\n    var graphicsData = graphics.geometry.graphicsData;\n    var contextFillStyle;\n    var contextStrokeStyle;\n    var tintR = (graphics.tint >> 16 & 0xFF) / 255;\n    var tintG = (graphics.tint >> 8 & 0xFF) / 255;\n    var tintB = (graphics.tint & 0xFF) / 255;\n    for (var i = 0; i < graphicsData.length; i++) {\n      var data = graphicsData[i];\n      var shape = data.shape;\n      var fillStyle = data.fillStyle;\n      var lineStyle = data.lineStyle;\n      var fillColor = data.fillStyle.color | 0;\n      var lineColor = data.lineStyle.color | 0;\n      if (data.matrix) {\n        renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));\n      }\n      if (fillStyle.visible) {\n        var fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;\n        contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);\n      }\n      if (lineStyle.visible) {\n        var lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255;\n        contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);\n      }\n      context.lineWidth = lineStyle.width;\n      context.lineCap = lineStyle.cap;\n      context.lineJoin = lineStyle.join;\n      context.miterLimit = lineStyle.miterLimit;\n      if (data.type === SHAPES.POLY) {\n        context.beginPath();\n        var tempShape = shape;\n        var points = tempShape.points;\n        var holes = data.holes;\n        var outerArea = void 0;\n        var innerArea = void 0;\n        var px = void 0;\n        var py = void 0;\n        var holesDirection = void 0;\n        context.moveTo(points[0], points[1]);\n        for (var j = 2; j < points.length; j += 2) {\n          context.lineTo(points[j], points[j + 1]);\n        }\n        if (tempShape.closeStroke) {\n          context.closePath();\n        }\n        if (holes.length > 0) {\n          holesDirection = [];\n          outerArea = 0;\n          px = points[0];\n          py = points[1];\n          for (var j = 2; j + 2 < points.length; j += 2) {\n            outerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);\n          }\n          for (var k = 0; k < holes.length; k++) {\n            points = holes[k].shape.points;\n            if (!points) {\n              continue;\n            }\n            innerArea = 0;\n            px = points[0];\n            py = points[1];\n            for (var j = 2; j + 2 < points.length; j += 2) {\n              innerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);\n            }\n            if (innerArea * outerArea < 0) {\n              context.moveTo(points[0], points[1]);\n              for (var j = 2; j < points.length; j += 2) {\n                context.lineTo(points[j], points[j + 1]);\n              }\n            } else {\n              context.moveTo(points[points.length - 2], points[points.length - 1]);\n              for (var j = points.length - 4; j >= 0; j -= 2) {\n                context.lineTo(points[j], points[j + 1]);\n              }\n            }\n            if (holes[k].shape.closeStroke) {\n              context.closePath();\n            }\n            holesDirection[k] = innerArea * outerArea < 0;\n          }\n        }\n        if (fillStyle.visible) {\n          context.globalAlpha = fillStyle.alpha * worldAlpha;\n          context.fillStyle = contextFillStyle;\n          context.fill();\n        }\n        if (lineStyle.visible) {\n          this.paintPolygonStroke(tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context);\n        }\n      } else if (data.type === SHAPES.RECT) {\n        var tempShape = shape;\n        if (fillStyle.visible) {\n          context.globalAlpha = fillStyle.alpha * worldAlpha;\n          context.fillStyle = contextFillStyle;\n          context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);\n        }\n        if (lineStyle.visible) {\n          var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n          var width = tempShape.width + 2 * alignmentOffset;\n          var height = tempShape.height + 2 * alignmentOffset;\n          context.globalAlpha = lineStyle.alpha * worldAlpha;\n          context.strokeStyle = contextStrokeStyle;\n          context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);\n        }\n      } else if (data.type === SHAPES.CIRC) {\n        var tempShape = shape;\n        // TODO - need to be Undefined!\n        context.beginPath();\n        context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);\n        context.closePath();\n        if (fillStyle.visible) {\n          context.globalAlpha = fillStyle.alpha * worldAlpha;\n          context.fillStyle = contextFillStyle;\n          context.fill();\n        }\n        if (lineStyle.visible) {\n          if (lineStyle.alignment !== 0.5) {\n            var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n            context.beginPath();\n            context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);\n            context.closePath();\n          }\n          context.globalAlpha = lineStyle.alpha * worldAlpha;\n          context.strokeStyle = contextStrokeStyle;\n          context.stroke();\n        }\n      } else if (data.type === SHAPES.ELIP) {\n        var tempShape = shape;\n        var drawShapeOverStroke = lineStyle.alignment === 1;\n        if (!drawShapeOverStroke) {\n          this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n        }\n        if (lineStyle.visible) {\n          if (lineStyle.alignment !== 0.5) {\n            var kappa = 0.5522848;\n            var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n            var sW = (tempShape.width + alignmentOffset) * 2;\n            var sH = (tempShape.height + alignmentOffset) * 2;\n            var sX = tempShape.x - sW / 2;\n            var sY = tempShape.y - sH / 2;\n            var sOx = sW / 2 * kappa;\n            var sOy = sH / 2 * kappa;\n            var sXe = sX + sW;\n            var sYe = sY + sH;\n            var sXm = sX + sW / 2;\n            var sYm = sY + sH / 2;\n            context.beginPath();\n            context.moveTo(sX, sYm);\n            context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);\n            context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);\n            context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);\n            context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);\n            context.closePath();\n          }\n          context.globalAlpha = lineStyle.alpha * worldAlpha;\n          context.strokeStyle = contextStrokeStyle;\n          context.stroke();\n        }\n        if (drawShapeOverStroke) {\n          this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n        }\n      } else if (data.type === SHAPES.RREC) {\n        var tempShape = shape;\n        var drawShapeOverStroke = lineStyle.alignment === 1;\n        if (!drawShapeOverStroke) {\n          this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n        }\n        if (lineStyle.visible) {\n          if (lineStyle.alignment !== 0.5) {\n            var width = tempShape.width;\n            var height = tempShape.height;\n            var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n            var sRx = tempShape.x - alignmentOffset;\n            var sRy = tempShape.y - alignmentOffset;\n            var sWidth = tempShape.width + 2 * alignmentOffset;\n            var sHeight = tempShape.height + 2 * alignmentOffset;\n            var radiusOffset = alignmentOffset * (lineStyle.alignment >= 1 ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));\n            var sRadius = tempShape.radius + radiusOffset;\n            var sMaxRadius = Math.min(sWidth, sHeight) / 2;\n            sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;\n            context.beginPath();\n            context.moveTo(sRx, sRy + sRadius);\n            context.lineTo(sRx, sRy + sHeight - sRadius);\n            context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);\n            context.lineTo(sRx + sWidth - sRadius, sRy + sHeight);\n            context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);\n            context.lineTo(sRx + sWidth, sRy + sRadius);\n            context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);\n            context.lineTo(sRx + sRadius, sRy);\n            context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);\n            context.closePath();\n          }\n          context.globalAlpha = lineStyle.alpha * worldAlpha;\n          context.strokeStyle = contextStrokeStyle;\n          context.stroke();\n        }\n        if (drawShapeOverStroke) {\n          this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n        }\n      }\n    }\n  };\n  /**\n   * Paint stroke for polygon and holes\n   *\n   * @private\n   * @param shape - Shape to be drawn\n   * @param lineStyle - Line style for the shape\n   * @param contextStrokeStyle - The strokeStyle for the canvas context\n   * @param holes - Holes to be added to the shape\n   * @param holesDirection -\n   * @param worldAlpha - The multiplied alpha of the displayObject\n   * @param context - The canvas context\n   */\n  CanvasGraphicsRenderer.prototype.paintPolygonStroke = function (shape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context) {\n    if (lineStyle.alignment !== 0.5) {\n      var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n      var offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);\n      var points = void 0;\n      context.beginPath();\n      context.moveTo(offsetPoints[0], offsetPoints[1]);\n      for (var j = 2; j < offsetPoints.length; j += 2) {\n        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n      }\n      if (shape.closeStroke) {\n        context.closePath();\n      }\n      for (var k = 0; k < holes.length; k++) {\n        points = holes[k].shape.points;\n        offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);\n        if (holesDirection[k]) {\n          context.moveTo(offsetPoints[0], offsetPoints[1]);\n          for (var j = 2; j < offsetPoints.length; j += 2) {\n            context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n          }\n        } else {\n          context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);\n          for (var j = offsetPoints.length - 4; j >= 0; j -= 2) {\n            context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n          }\n        }\n        if (holes[k].shape.closeStroke) {\n          context.closePath();\n        }\n      }\n    }\n    context.globalAlpha = lineStyle.alpha * worldAlpha;\n    context.strokeStyle = contextStrokeStyle;\n    context.stroke();\n  };\n  /**\n   * Paint Ellipse\n   *\n   * @private\n   * @param shape - Shape to be drawn\n   * @param fillStyle - Fill for the shape\n   * @param lineStyle - Line style for the shape\n   * @param contextFillStyle - The canvas context fill style\n   * @param worldAlpha - The multiplied alpha of the displayObject\n   * @param context - The canvas context\n   */\n  CanvasGraphicsRenderer.prototype.paintEllipse = function (shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {\n    // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n    var w = shape.width * 2;\n    var h = shape.height * 2;\n    var x = shape.x - w / 2;\n    var y = shape.y - h / 2;\n    var kappa = 0.5522848;\n    var ox = w / 2 * kappa; // control point offset horizontal\n    var oy = h / 2 * kappa; // control point offset vertical\n    var xe = x + w; // x-end\n    var ye = y + h; // y-end\n    var xm = x + w / 2; // x-middle\n    var ym = y + h / 2; // y-middle\n    if (lineStyle.alignment === 0) {\n      context.save();\n    }\n    context.beginPath();\n    context.moveTo(x, ym);\n    context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    context.closePath();\n    if (lineStyle.alignment === 0) {\n      context.clip();\n    }\n    if (fillStyle.visible) {\n      context.globalAlpha = fillStyle.alpha * worldAlpha;\n      context.fillStyle = contextFillStyle;\n      context.fill();\n    }\n    if (lineStyle.alignment === 0) {\n      context.restore();\n    }\n  };\n  /**\n   * Paint Rounded Rectangle\n   *\n   * @private\n   * @param shape - Shape to be drawn\n   * @param fillStyle - Fill for the shape\n   * @param lineStyle - Line style for the shape\n   * @param contextFillStyle - The canvas context fill style\n   * @param worldAlpha - The multiplied alpha of the displayObject\n   * @param context - The canvas context\n   */\n  CanvasGraphicsRenderer.prototype.paintRoundedRectangle = function (shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {\n    var rx = shape.x;\n    var ry = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n    var radius = shape.radius;\n    var maxRadius = Math.min(width, height) / 2;\n    radius = radius > maxRadius ? maxRadius : radius;\n    if (lineStyle.alignment === 0) {\n      context.save();\n    }\n    context.beginPath();\n    context.moveTo(rx, ry + radius);\n    context.lineTo(rx, ry + height - radius);\n    context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n    context.lineTo(rx + width - radius, ry + height);\n    context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n    context.lineTo(rx + width, ry + radius);\n    context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n    context.lineTo(rx + radius, ry);\n    context.quadraticCurveTo(rx, ry, rx, ry + radius);\n    context.closePath();\n    if (lineStyle.alignment === 0) {\n      context.clip();\n    }\n    if (fillStyle.visible) {\n      context.globalAlpha = fillStyle.alpha * worldAlpha;\n      context.fillStyle = contextFillStyle;\n      context.fill();\n    }\n    if (lineStyle.alignment === 0) {\n      context.restore();\n    }\n  };\n  CanvasGraphicsRenderer.prototype.setPatternTransform = function (pattern, matrix) {\n    if (this._svgMatrix === false) {\n      return;\n    }\n    if (!this._svgMatrix) {\n      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      if (svg && svg.createSVGMatrix) {\n        this._svgMatrix = svg.createSVGMatrix();\n      }\n      if (!this._svgMatrix || !pattern.setTransform) {\n        this._svgMatrix = false;\n        return;\n      }\n    }\n    this._svgMatrix.a = matrix.a;\n    this._svgMatrix.b = matrix.b;\n    this._svgMatrix.c = matrix.c;\n    this._svgMatrix.d = matrix.d;\n    this._svgMatrix.e = matrix.tx;\n    this._svgMatrix.f = matrix.ty;\n    pattern.setTransform(this._svgMatrix.inverse());\n  };\n  /** destroy graphics object */\n  CanvasGraphicsRenderer.prototype.destroy = function () {\n    this.renderer = null;\n    this._svgMatrix = null;\n    this._tempMatrix = null;\n  };\n  return CanvasGraphicsRenderer;\n}();\nvar canvasRenderer;\nvar tempMatrix = new Matrix();\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {PIXI.SCALE_MODES} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution) {\n  if (resolution === void 0) {\n    resolution = 1;\n  }\n  var bounds = this.getLocalBounds();\n  var canvasBuffer = RenderTexture.create({\n    width: bounds.width,\n    height: bounds.height,\n    scaleMode: scaleMode,\n    resolution: resolution\n  });\n  if (!canvasRenderer) {\n    canvasRenderer = new CanvasRenderer();\n  }\n  this.transform.updateLocalTransform();\n  this.transform.localTransform.copyTo(tempMatrix);\n  tempMatrix.invert();\n  tempMatrix.tx -= bounds.x;\n  tempMatrix.ty -= bounds.y;\n  canvasRenderer.render(this, {\n    renderTexture: canvasBuffer,\n    clear: true,\n    transform: tempMatrix\n  });\n  var texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {\n    scaleMode: scaleMode\n  });\n  texture.baseTexture.setResolution(resolution);\n  return texture;\n};\nGraphics.prototype.cachedGraphicsData = [];\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.isMask === true) {\n    return;\n  }\n  this.finishPoly();\n  renderer.plugins.graphics.render(this);\n};\nexport { CanvasGraphicsRenderer };","map":{"version":3,"sources":["../../src/utils/PolygonUtils.ts","../../src/CanvasGraphicsRenderer.ts","../../src/Graphics.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utilities for polygon\n * @class\n * @private\n */\nexport class PolygonUtils\n{\n    /**\n    * Calculate points of an offset polygon\n    * @see {@link http://csharphelper.com/blog/2016/01/enlarge-a-polygon-in-c/}\n    *\n    * @private\n    * @param {number[]} points - polygon coordinates\n    * @param {number} offset\n    * @return {number[]} - offset points\n    */\n    static offsetPolygon(points: number[], offset: number): number[]\n    {\n        const offsetPoints: number[] = [];\n        const length: number = points.length;\n\n        offset = PolygonUtils.isPolygonClockwise(points) ? offset : -1 * offset;\n\n        for (let j = 0; j < length; j += 2)\n        {\n            // Find location for the points before and after j\n            let i = (j - 2);\n\n            if (i < 0)\n            {\n                i += length;\n            }\n\n            const k = (j + 2) % length;\n\n            // Move the points by the offset\n            let v1x = points[j] - points[i];\n            let v1y = points[j + 1] - points[i + 1];\n            let len = Math.sqrt((v1x * v1x) + (v1y * v1y));\n\n            v1x /= len;\n            v1y /= len;\n            v1x *= offset;\n            v1y *= offset;\n\n            const norm1x = -v1y;\n            const norm1y = v1x;\n\n            const pij1 = [points[i] + norm1x, points[i + 1] + norm1y];\n            const pij2 = [points[j] + norm1x, points[j + 1] + norm1y];\n\n            let v2x = points[k] - points[j];\n            let v2y = points[k + 1] - points[j + 1];\n\n            len = Math.sqrt((v2x * v2x) + (v2y * v2y));\n\n            v2x /= len;\n            v2y /= len;\n            v2x *= offset;\n            v2y *= offset;\n\n            const norm2x = -v2y;\n            const norm2y = v2x;\n\n            const pjk1 = [points[j] + norm2x, points[j + 1] + norm2y];\n            const pjk2 = [points[k] + norm2x, points[k + 1] + norm2y];\n\n            // Find where the shifted lines ij and jk intersect.\n            const intersectPoint = PolygonUtils\n                .findIntersection(pij1[0], pij1[1], pij2[0], pij2[1], pjk1[0], pjk1[1], pjk2[0], pjk2[1]);\n\n            if (intersectPoint)\n            {\n                offsetPoints.push(...intersectPoint);\n            }\n        }\n\n        return offsetPoints;\n    }\n\n    /**\n    * Determine the intersection point of two line segments\n    * @see {@link here http://paulbourke.net/geometry/pointlineplane/}\n    *\n    * @private\n    * @param {number} x1 - x-coordinate of start point at first line\n    * @param {number} y1 - y-coordinate of start point at first line\n    * @param {number} x2 - x-coordinate of end point at first line\n    * @param {number} y2 - y-coordinate of end point at first line\n    * @param {number} x3 - x-coordinate of start point at second line\n    * @param {number} y3 - y-coordinate of start point at second line\n    * @param {number} x4 - x-coordinate of end point at second line\n    * @param {number} y4 - y-coordinate of end point at second line\n    * @returns {[number, number] | null} - [x, y] coordinates of intersection\n    */\n    static findIntersection(\n        x1: number, y1: number, x2: number, y2: number,\n        x3: number, y3: number, x4: number, y4: number\n    ): [number, number] | null\n    {\n        const denominator = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n        const numeratorA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n        const numeratorB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n        // lines are parallel\n        if (denominator === 0)\n        {\n            // lines are coincident\n            if (numeratorA === 0 && numeratorB === 0)\n            {\n                return [(x1 + x2) / 2, (y1 + y2) / 2];\n            }\n\n            return null;\n        }\n\n        const uA = numeratorA / denominator;\n\n        return [x1 + (uA * (x2 - x1)), y1 + (uA * (y2 - y1))];\n    }\n\n    /**\n     * Determine polygon are clockwise or counterclockwise\n     * @see {@link https://stackoverflow.com/questions/1165647}\n     *\n     * @private\n     * @param {number[]} polygon - polygon coordinates\n     * @return {boolean}\n     */\n    static isPolygonClockwise(polygon: number[]): boolean\n    {\n        let sum = 0;\n\n        for (let i = 0; i < polygon.length - 2; i += 2)\n        {\n            sum += (polygon[i + 2] - polygon[i]) * (polygon[i + 3] + polygon[i + 1]);\n        }\n\n        return sum > 0;\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { SHAPES, Matrix } from '@pixi/math';\nimport { canvasUtils, CrossPlatformCanvasRenderingContext2D } from '@pixi/canvas-renderer';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { FillStyle, Graphics, GraphicsData, LineStyle } from '@pixi/graphics';\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle } from '@pixi/math';\nimport { PolygonUtils } from './utils/PolygonUtils';\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    /** A reference to the current renderer */\n    public renderer: CanvasRenderer;\n    private _svgMatrix: DOMMatrix|boolean = null;\n    private _tempMatrix: Matrix = new Matrix();\n\n    /**\n     * @param renderer - A reference to the current renderer.\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * calculates fill/stroke style for canvas\n     *\n     * @private\n     * @param style - A graphics {@link PIXI.FILL_STYLE} where if `texture` is specified then a tinted CanvasPattern\n     * will be used for the fill.stroke\n     * @param tint - color to set the fill/stroke too.\n     */\n    private _calcCanvasStyle(style: FillStyle, tint: number): string|CanvasPattern\n    {\n        let res;\n\n        if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture)\n        {\n            if (style.texture.valid)\n            {\n                res = canvasUtils.getTintedPattern(style.texture, tint);\n                this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);\n            }\n            else\n            {\n                res = '#808080';\n            }\n        }\n        else\n        {\n            res = `#${(`00000${(tint | 0).toString(16)}`).substr(-6)}`;\n        }\n\n        return res;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     *\n     * @param graphics - the actual graphics object to render\n     */\n    public render(graphics: Graphics): void\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n\n        renderer.setContextTransform(transform);\n        renderer.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        let contextFillStyle;\n        let contextStrokeStyle;\n\n        const tintR = ((graphics.tint >> 16) & 0xFF) / 255;\n        const tintG = ((graphics.tint >> 8) & 0xFF) / 255;\n        const tintB = (graphics.tint & 0xFF) / 255;\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            if (data.matrix)\n            {\n                renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));\n            }\n\n            if (fillStyle.visible)\n            {\n                const fillTint = (\n                    (((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((fillColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);\n            }\n            if (lineStyle.visible)\n            {\n                const lineTint = (\n                    (((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((lineColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);\n            }\n\n            context.lineWidth = lineStyle.width;\n            context.lineCap = lineStyle.cap;\n            context.lineJoin = lineStyle.join;\n            context.miterLimit = lineStyle.miterLimit;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                const tempShape = shape as Polygon;\n                let points = tempShape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n                let holesDirection: boolean[];\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (tempShape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    holesDirection = [];\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = (holes[k].shape as Polygon).points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if ((holes[k].shape as Polygon).closeStroke)\n                        {\n                            context.closePath();\n                        }\n\n                        holesDirection[k] = innerArea * outerArea < 0;\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    this.paintPolygonStroke(\n                        tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context\n                    );\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                const tempShape = shape as Rectangle;\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);\n                }\n\n                if (lineStyle.visible)\n                {\n                    const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                    const width = tempShape.width + (2 * alignmentOffset);\n                    const height = tempShape.height + (2 * alignmentOffset);\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                const tempShape = shape as Circle;\n\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n\n                        context.beginPath();\n                        context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                const tempShape = shape as Ellipse;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const kappa = 0.5522848;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sW = (tempShape.width + alignmentOffset) * 2;\n                        const sH = (tempShape.height + alignmentOffset) * 2;\n                        const sX = tempShape.x - (sW / 2);\n                        const sY = tempShape.y - (sH / 2);\n                        const sOx = (sW / 2) * kappa;\n                        const sOy = (sH / 2) * kappa;\n                        const sXe = sX + sW;\n                        const sYe = sY + sH;\n                        const sXm = sX + (sW / 2);\n                        const sYm = sY + (sH / 2);\n\n                        context.beginPath();\n                        context.moveTo(sX, sYm);\n                        context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);\n                        context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);\n                        context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);\n                        context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const tempShape = shape as RoundedRectangle;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const width = tempShape.width;\n                        const height = tempShape.height;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sRx = tempShape.x - alignmentOffset;\n                        const sRy = tempShape.y - alignmentOffset;\n                        const sWidth = tempShape.width + (2 * alignmentOffset);\n                        const sHeight = tempShape.height + (2 * alignmentOffset);\n                        const radiusOffset = alignmentOffset * (lineStyle.alignment >= 1\n                            ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));\n                        let sRadius = tempShape.radius + radiusOffset;\n                        const sMaxRadius = Math.min(sWidth, sHeight) / 2;\n\n                        sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;\n\n                        context.beginPath();\n                        context.moveTo(sRx, sRy + sRadius);\n                        context.lineTo(sRx, sRy + sHeight - sRadius);\n                        context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);\n                        context.lineTo(sRx + sWidth - sRadius, sRy + sHeight);\n                        context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);\n                        context.lineTo(sRx + sWidth, sRy + sRadius);\n                        context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);\n                        context.lineTo(sRx + sRadius, sRy);\n                        context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n        }\n    }\n\n    /**\n     * Paint stroke for polygon and holes\n     *\n     * @private\n     * @param shape - Shape to be drawn\n     * @param lineStyle - Line style for the shape\n     * @param contextStrokeStyle - The strokeStyle for the canvas context\n     * @param holes - Holes to be added to the shape\n     * @param holesDirection -\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintPolygonStroke(\n        shape: Polygon, lineStyle: LineStyle, contextStrokeStyle: string|CanvasPattern,\n        holes: GraphicsData[], holesDirection: boolean[],\n        worldAlpha: number, context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        if (lineStyle.alignment !== 0.5)\n        {\n            const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n            let offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);\n            let points;\n\n            context.beginPath();\n            context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n            for (let j = 2; j < offsetPoints.length; j += 2)\n            {\n                context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n            }\n\n            if (shape.closeStroke)\n            {\n                context.closePath();\n            }\n\n            for (let k = 0; k < holes.length; k++)\n            {\n                points = (holes[k].shape as Polygon).points;\n                offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);\n\n                if (holesDirection[k])\n                {\n                    context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n                    for (let j = 2; j < offsetPoints.length; j += 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n                else\n                {\n                    context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);\n\n                    for (let j = offsetPoints.length - 4; j >= 0; j -= 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n\n                if ((holes[k].shape as Polygon).closeStroke)\n                {\n                    context.closePath();\n                }\n            }\n        }\n\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = contextStrokeStyle;\n        context.stroke();\n    }\n\n    /**\n     * Paint Ellipse\n     *\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintEllipse(\n        shape: Ellipse, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string|CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D): void\n    {\n        // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n        const w = shape.width * 2;\n        const h = shape.height * 2;\n\n        const x = shape.x - (w / 2);\n        const y = shape.y - (h / 2);\n\n        const kappa = 0.5522848;\n        const ox = (w / 2) * kappa; // control point offset horizontal\n        const oy = (h / 2) * kappa; // control point offset vertical\n        const xe = x + w; // x-end\n        const ye = y + h; // y-end\n        const xm = x + (w / 2); // x-middle\n        const ym = y + (h / 2); // y-middle\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    /**\n     * Paint Rounded Rectangle\n     *\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintRoundedRectangle(\n        shape: RoundedRectangle, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string|CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        const rx = shape.x;\n        const ry = shape.y;\n        const width = shape.width;\n        const height = shape.height;\n        let radius = shape.radius;\n\n        const maxRadius = Math.min(width, height) / 2;\n\n        radius = radius > maxRadius ? maxRadius : radius;\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(rx, ry + radius);\n        context.lineTo(rx, ry + height - radius);\n        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n        context.lineTo(rx + width - radius, ry + height);\n        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n        context.lineTo(rx + width, ry + radius);\n        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n        context.lineTo(rx + radius, ry);\n        context.quadraticCurveTo(rx, ry, rx, ry + radius);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    public setPatternTransform(pattern: CanvasPattern, matrix: Matrix): void\n    {\n        if (this._svgMatrix === false)\n        {\n            return;\n        }\n        if (!this._svgMatrix)\n        {\n            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n            if (svg && svg.createSVGMatrix)\n            {\n                this._svgMatrix = svg.createSVGMatrix();\n            }\n            if (!this._svgMatrix || !pattern.setTransform)\n            {\n                this._svgMatrix = false;\n\n                return;\n            }\n        }\n\n        (this._svgMatrix as DOMMatrix).a = matrix.a;\n        (this._svgMatrix as DOMMatrix).b = matrix.b;\n        (this._svgMatrix as DOMMatrix).c = matrix.c;\n        (this._svgMatrix as DOMMatrix).d = matrix.d;\n        (this._svgMatrix as DOMMatrix).e = matrix.tx;\n        (this._svgMatrix as DOMMatrix).f = matrix.ty;\n        pattern.setTransform((this._svgMatrix as DOMMatrix).inverse());\n    }\n\n    /** destroy graphics object */\n    public destroy(): void\n    {\n        this.renderer = null;\n        this._svgMatrix = null;\n        this._tempMatrix = null;\n    }\n}\n","import { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nimport type { SCALE_MODES } from '@pixi/constants';\nimport type { BaseRenderTexture } from '@pixi/core';\n\nlet canvasRenderer: CanvasRenderer;\nconst tempMatrix = new Matrix();\n\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {PIXI.SCALE_MODES} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode: SCALE_MODES, resolution = 1): Texture\n{\n    const bounds = this.getLocalBounds();\n\n    const canvasBuffer = RenderTexture.create({\n        width: bounds.width,\n        height: bounds.height,\n        scaleMode,\n        resolution,\n    });\n\n    if (!canvasRenderer)\n    {\n        canvasRenderer = new CanvasRenderer();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copyTo(tempMatrix);\n\n    tempMatrix.invert();\n\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n\n    canvasRenderer.render(this, { renderTexture: canvasBuffer, clear: true, transform: tempMatrix });\n\n    const texture = Texture.from((canvasBuffer.baseTexture as BaseRenderTexture)._canvasRenderTarget.canvas, {\n        scaleMode,\n    });\n\n    texture.baseTexture.setResolution(resolution);\n\n    return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    this.finishPoly();\n    renderer.plugins.graphics.render(this);\n};\n"]},"metadata":{},"sourceType":"module"}