{"ast":null,"code":"import { makeObservable, observable, action } from 'mobx';\nimport { message } from 'antd';\nimport { inv } from 'mathjs';\nimport { cloneDeep } from 'lodash';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape, getSnapshot, parseFields, calcShapeArea, isAttributesPassCondition, getMatrixByRotation, calcPositionByMatrix } from '../utils';\nimport { imageSegmentation } from '../request';\nimport { Tool, ViewMode, LabelItem, ReviewMode, ProjectMode } from '../types';\nimport { CAMERA_VIEW_LABELS } from '../constants';\nimport ShapeFactory from '../../common/shapes/ShapeFactory';\nimport { ShapeType } from '../../common/shapes/types';\nimport { EventAction, BorderStyle } from '../../common/shapes/Shape';\nimport Rectangle, { RectType } from '../../common/shapes/Rectangle';\nimport Polygon, { PolygonType } from '../../common/shapes/Polygon';\nimport Line from '../../common/shapes/Line';\nimport Dot from '../../common/shapes/Dot';\nimport Label from '../../common/shapes/label/Label';\nimport { precise } from '../../common/shapes/utils';\nimport Cursor from '../../common/Cursor';\nimport { computeRotatedPosition } from '../../../utils/math';\nconst shapeTypesSupportProject = [ShapeType.LINE, ShapeType.POLYGON];\n/**\n * store for shapes in current camera & current frame\n * @class\n */\nexport default class ShapeStore {\n  /**\n   * is drawing shape\n   * @getter\n   */\n  get isDrawing() {\n    return this.drawingShape !== null;\n  }\n  constructor(rootStore) {\n    /**\n     * root store\n     */\n    this.rootStore = void 0;\n    /**\n     * canvas reference\n     */\n    this.canvasRef = null;\n    /**\n     * app\n     */\n    this.app = void 0;\n    /**\n     * current layer\n     */\n    this.currentLayer = void 0;\n    /**\n     * shapes in current frame\n     */\n    this.shapes = {};\n    /**\n     * currently drawing shape\n     */\n    this.drawingShape = null;\n    /**\n     * if recognition prepared, start to do recognition\n     */\n    this.recognitionStart = false;\n    /**\n     * data used for recognition\n     */\n    this.recognitionData = {\n      image: '',\n      clicks: '',\n      threshold: 0.5\n    };\n    /**\n     * currently selected shapes\n     */\n    this.selectedShapes = [];\n    /**\n     * currently selected shape vertex index for polygon & line\n     */\n    this.selectedPointIndex = -1;\n    /**\n     * predicted shapes\n     */\n    this.predictedShapes = {};\n    /**\n     * projected shapes\n     */\n    this.projectedShapes = {};\n    /**\n     * hovered shape id\n     */\n    this.hoveredShapeId = '';\n    /**\n     * waiting merge polygon\n     */\n    this.pendingMergePolygon = '';\n    /**\n     * polygon id in cut mode\n     */\n    this.cuttingPolygon = '';\n    /**\n     * polygon id in split mode\n     */\n    this.splittingPolygn = '';\n    /**\n     * is deleting\n     */\n    this.deleting = false;\n    /**\n     * is points moving\n     */\n    this.pointsMoving = false;\n    /**\n     * is shapes moving\n     */\n    this.shapesMoving = false;\n    /**\n     * is shape projecting\n     */\n    this.projecting = false;\n    /**\n     * shape display config\n     */\n    this.config = {\n      fill: true,\n      alpha: 20,\n      toleranceFill: false,\n      toleranceAlpha: 20,\n      borderAlpha: 100,\n      borderWidth: 1,\n      dotRadius: 5,\n      showVertex: false,\n      showVertexOrder: false,\n      vertexSize: 4,\n      vertexStart: 1\n    };\n    /**\n     * default config from payload\n     */\n    this.defaultConfig = this.config;\n    /**\n     * clear shapes\n     */\n    this.clearShapes = () => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.destroy();\n      });\n      this.shapes = {};\n      this.drawingShape = null;\n      this.selectedShapes = [];\n      this.clearPredictedShapes();\n      this.clearProjectedShapes();\n      this.selectedPointIndex = -1;\n    };\n    /**\n     * clear predicted shapes\n     */\n    this.clearPredictedShapes = () => {\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.destroy();\n      });\n      this.predictedShapes = {};\n    };\n    /**\n     * clear projected shapes\n     */\n    this.clearProjectedShapes = () => {\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.destroy();\n        });\n      });\n      this.projectedShapes = {};\n    };\n    /**\n     * is predicted shape\n     * @param s\n     */\n    this.isPredictedShape = s => Object.values(this.predictedShapes).findIndex(({\n      shape\n    }) => shape === s) >= 0;\n    /**\n     * get shape by instance item\n     * @param instanceItem\n     */\n    this.getShapeByInstanceItem = (instanceItem, camera = this.rootStore.frame.currentCamera) => {\n      const shapeItem = Object.values(this.shapes).find(i => i.camera === camera && i.instanceItem === instanceItem);\n      if (shapeItem) {\n        return shapeItem.shape;\n      }\n      return undefined;\n    };\n    /**\n     * get shapes by instance items\n     * @param instanceItems\n     * @param camera\n     */\n    this.getShapesByInstanceItems = (instanceItems, camera = this.rootStore.frame.currentCamera) => {\n      const shapeItems = Object.values(this.shapes).filter(i => i.camera === camera && instanceItems.indexOf(i.instanceItem) >= 0);\n      return shapeItems.map(i => i.shape);\n    };\n    /**\n     * get shapes for one camera\n     * @param camera\n     */\n    this.getShapesForCamera = camera => Object.values(this.shapes).filter(s => s.camera === camera);\n    /**\n     * update shapes interactive\n     * @param interactive\n     * @param ignoreIds\n     */\n    this.updateShapesInteractive = (interactive, ignoreIds) => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (ignoreIds && ignoreIds.includes(shape.uid)) {\n          return;\n        }\n        shape.interactive = interactive;\n        if (interactive && this.selectedShapes.indexOf(shape) >= 0) {\n          shape.selected = true;\n        }\n      });\n    };\n    /**\n     * update shapes user data mode\n     * @param userDataMode\n     */\n    this.updateShapesUserDataMode = userDataMode => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.userDataMode = userDataMode;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.userDataMode = userDataMode;\n      });\n    };\n    /**\n     * redraw shapes label\n     */\n    this.redrawShapesLabel = () => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.drawShapeLabel();\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.drawShapeLabel();\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.drawShapeLabel();\n        });\n      });\n    };\n    /**\n     * setup shapes for current frame\n     */\n    this.setupShapes = () => {\n      this.clearShapes();\n      const {\n        cameraViews,\n        currentFrame,\n        cameraNames,\n        getImageBoundsForCamera\n      } = this.rootStore.frame;\n      const allShapeOrders = {};\n      const noOrderShapes = {};\n      cameraNames.forEach(cameraName => {\n        allShapeOrders[cameraName] = new Set();\n        noOrderShapes[cameraName] = [];\n      });\n      Object.values(this.rootStore.instance.instances).forEach(instance => {\n        Object.values(instance.items).forEach(item => {\n          Object.values(item.cameras).forEach(({\n            camera\n          }) => {\n            const {\n              frames\n            } = item.cameras[camera];\n            const cameraView = cameraViews[camera];\n            if (frames[currentFrame] && cameraView && !cameraView.imageLoadError) {\n              const shape = this.createShape(cameraView.shapesLayer, getImageBoundsForCamera(camera), item.categoryItemRef.displayColor, instance.category, item.name, frames[currentFrame].shapeType, frames[currentFrame].shape, frames[currentFrame].order, item.label, camera);\n              if (shape.destroyed || shape.area < this.rootStore.config.minArea) {\n                // delete instance item\n                this.rootStore.instance.deleteInstanceItemByFrame(item, currentFrame, camera);\n                return;\n              }\n              if (this.rootStore.readonly) {\n                shape.editable = false;\n              }\n              this.setShapeStyles(shape, item);\n              this.addShapeListeners(shape);\n              this.shapes[shape.uid] = {\n                shape,\n                camera,\n                instanceItem: item\n              };\n              const {\n                order\n              } = frames[currentFrame];\n              if (order !== undefined && !allShapeOrders[camera].has(order)) {\n                // update next shape order\n                shape.order = order;\n                allShapeOrders[camera].add(order);\n              } else {\n                // add to temp array\n                noOrderShapes[camera].push({\n                  frameData: frames[currentFrame],\n                  shape\n                });\n              }\n            }\n          });\n        });\n      });\n      Object.keys(noOrderShapes).forEach(cameraName => {\n        noOrderShapes[cameraName].forEach(({\n          frameData,\n          shape\n        }) => {\n          // new order\n          shape.order = this.rootStore.frame.getNextShapeOrder(currentFrame, cameraName);\n          frameData.order = shape.order;\n        });\n      });\n      this.projectShapes();\n    };\n    /**\n     * format point label\n     * @param data\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.formatPointLabel = (data, categoryName, categoryItemName) => {\n      const pointLabelConfig = this.rootStore.ontology.getPointLabelConfigFromCategoryItem(categoryName, categoryItemName);\n      const fieldsMap = parseFields(pointLabelConfig);\n      const labels = [];\n      const {\n        pointLabelItems\n      } = this.rootStore.config;\n      Object.keys(data).forEach(key => {\n        const label = [];\n        const field = fieldsMap[key];\n        const fieldValue = data[key];\n        if (pointLabelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n          label.push((field === null || field === void 0 ? void 0 : field.label) || (field === null || field === void 0 ? void 0 : field.name) || `${key}`);\n        }\n        if (pointLabelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n          let displayValue = '';\n          if (fieldValue !== undefined) {\n            if (field === null || field === void 0 ? void 0 : field.options) {\n              const getOptionLabel = value => {\n                const option = field.options.find(o => o.value === value);\n                return option && option.label ? option.label : value.toString();\n              };\n              displayValue = Array.isArray(fieldValue) ? fieldValue.map(getOptionLabel).toString() : getOptionLabel(fieldValue);\n            } else {\n              displayValue = fieldValue.toString();\n            }\n          }\n          label.push(displayValue);\n        }\n        if (label.length > 0) {\n          labels.push(label);\n        }\n      });\n      return labels.map(l => l.join(': ')).join('; ');\n    };\n    /**\n     * get point style\n     * @param pointIndex\n     * @param data\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.getPointStyle = (pointIndex, data, shape, categoryName, categoryItemName) => {\n      let pointColor;\n      let pointType;\n      // by point attributes\n      if (data) {\n        const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n        const {\n          pointLabelConfig,\n          pointLabelConfigGroups\n        } = categoryItem || {};\n        if (pointLabelConfig && pointLabelConfigGroups) {\n          // from point label config settings\n          pointLabelConfigGroups.some(g => {\n            const {\n              attributes,\n              ...styles\n            } = g;\n            if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n              // match group attributes\n              if (pointColor === undefined) {\n                const color = styles.pointColor;\n                if (color) {\n                  pointColor = parseInt(color.substr(1), 16);\n                }\n              }\n              if (pointType === undefined) {\n                const type = styles.pointType;\n                if (type) {\n                  pointType = type;\n                }\n              }\n            }\n            return pointColor !== undefined && pointType !== undefined;\n          });\n        } else if (pointColor === undefined) {\n          // from hotkeys config\n          const dataKeyLen = Object.keys(data).length;\n          Object.values(this.rootStore.config.hotkeyMap).some(items => items.some(({\n            affected,\n            type,\n            color,\n            attributes\n          }) => {\n            if (affected === 'point' && color !== undefined) {\n              const attrKeys = Object.keys(attributes);\n              if (isAttributesPassCondition(data, attributes) && (type !== 'overwrite' || attrKeys.length === dataKeyLen)) {\n                pointColor = parseInt(color.substr(1), 16);\n                return true;\n              }\n            }\n            return false;\n          }));\n        }\n      }\n\n      // by point index\n      const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n      if (styles) {\n        // has style config\n        if (pointColor === undefined) {\n          // color not affected by attributes, use point index settings\n          const color = (styles.pointsColor || [])[pointIndex];\n          if (color) {\n            pointColor = parseInt(color.substr(1), 16);\n          }\n        }\n        if (pointType === undefined) {\n          // type not affected by attributes, use point index settings\n          const type = (styles.pointsType || [])[pointIndex];\n          if (type) {\n            pointType = type;\n          }\n        }\n      }\n      return {\n        color: pointColor,\n        type: pointType\n      };\n    };\n    /**\n     * get edge style\n     * @param startPointIndex\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.getEdgeStyle = (startPointIndex, data, shape, categoryName, categoryItemName) => {\n      let edgeColor;\n      let edgeType;\n      let edgeBold;\n\n      // by point labelConfig\n      if (data) {\n        const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n        const {\n          pointLabelConfig,\n          pointLabelConfigGroups\n        } = categoryItem || {};\n        if (pointLabelConfig && pointLabelConfigGroups) {\n          // from point label config settings\n          pointLabelConfigGroups.some(g => {\n            const {\n              attributes,\n              ...styles\n            } = g;\n            if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n              // match group attributes\n              if (edgeColor === undefined) {\n                const color = styles.edgeColor;\n                if (color) {\n                  edgeColor = parseInt(color.substr(1), 16);\n                }\n              }\n              if (edgeType === undefined) {\n                const type = styles.edgeType;\n                if (type) {\n                  edgeType = type;\n                }\n              }\n              if (edgeBold === undefined) {\n                const bold = styles.edgeBold;\n                if (bold !== undefined) {\n                  edgeBold = bold;\n                }\n              }\n            }\n            return edgeColor !== undefined && edgeType !== undefined && edgeBold !== undefined;\n          });\n        }\n      }\n      if (edgeColor === undefined || edgeType === undefined || edgeBold === undefined) {\n        // by point index\n        const styles = this.rootStore.ontology.getToolEdgesStylesByCategoryItem(categoryName, categoryItemName);\n        if (styles) {\n          // has style config\n          if (edgeColor === undefined) {\n            // color not affected by attributes, use point index settings\n            const color = (styles.edgesColor || [])[startPointIndex];\n            if (color) {\n              edgeColor = parseInt(color.substr(1), 16);\n            }\n          }\n          if (edgeType === undefined) {\n            // type not affected by attributes, use point index settings\n            const type = (styles.edgesType || [])[startPointIndex];\n            if (type) {\n              edgeType = type;\n            }\n          }\n          if (edgeBold === undefined) {\n            // bold not affected by attributes, use point index settings\n            const bold = (styles.edgesBold || [])[startPointIndex];\n            if (bold !== undefined) {\n              edgeBold = bold;\n            }\n          }\n        }\n      }\n      return {\n        color: edgeColor,\n        type: edgeType,\n        bold: edgeBold\n      };\n    };\n    /**\n     * get shape style (for fill color & dot style & color)\n     * @param data\n     * @param categoryName\n     * @param categoryItemName\n     */\n    this.getShapeStyle = (data, categoryName, categoryItemName) => {\n      let dotColor;\n      let dotType;\n      let fillColor;\n      let borderColor;\n      let borderType;\n      let borderBold;\n      let vertexColor;\n      let vertexType;\n      const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n      if (data) {\n        const {\n          labelConfig,\n          labelConfigGroups\n        } = categoryItem || {};\n        if (labelConfig && labelConfigGroups) {\n          // has label config settings\n          labelConfigGroups.some(g => {\n            const {\n              attributes,\n              ...styles\n            } = g;\n            if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n              // match group attributes\n              if (dotColor === undefined) {\n                const color = styles.pointColor;\n                if (color) {\n                  dotColor = parseInt(color.substr(1), 16);\n                }\n              }\n              if (dotType === undefined) {\n                const type = styles.pointType;\n                if (type) {\n                  dotType = type;\n                }\n              }\n              if (fillColor === undefined && styles.fillColor) {\n                fillColor = parseInt(styles.fillColor.substr(1), 16);\n              }\n              if (borderColor === undefined && styles.edgeColor) {\n                borderColor = parseInt(styles.edgeColor.substr(1), 16);\n              }\n              if (borderType === undefined && styles.edgeType) {\n                borderType = styles.edgeType;\n              }\n              if (borderBold === undefined && styles.edgeBold !== undefined) {\n                borderBold = styles.edgeBold;\n              }\n              if (vertexColor === undefined && styles.pointColor) {\n                vertexColor = parseInt(styles.pointColor.substr(1), 16);\n              }\n              if (vertexType === undefined && styles.pointType) {\n                vertexType = styles.pointType;\n              }\n            }\n            return dotColor !== undefined && dotType !== undefined && fillColor !== undefined && borderColor !== undefined && borderType !== undefined && borderBold !== undefined && vertexColor !== undefined && vertexType !== undefined;\n          });\n        }\n      }\n      const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n      if (styles) {\n        if (dotColor === undefined) {\n          // color not affected by attributes, use shape settings\n          const color = styles.pointColor;\n          if (color) {\n            dotColor = parseInt(color.substr(1), 16);\n          }\n        }\n        if (dotType === undefined) {\n          // type not affected by attributes, use shape settings\n          const type = styles.pointType;\n          if (type) {\n            dotType = type;\n          }\n        }\n      }\n      if (fillColor === undefined) {\n        // fill color not affected by attributes, use shape settings\n        const fill = this.rootStore.ontology.getToolFillByCategoryItem(categoryName, categoryItemName);\n        if (fill) {\n          fillColor = parseInt(fill.substr(1), 16);\n        }\n      }\n      if (borderColor === undefined || borderType === undefined || borderBold === undefined || vertexColor === undefined || vertexType === undefined) {\n        const {\n          pointsStyles,\n          edgesStyles\n        } = this.rootStore.ontology.getToolStylesByCategoryItem(categoryName, categoryItemName);\n        if (borderColor === undefined && (edgesStyles === null || edgesStyles === void 0 ? void 0 : edgesStyles.edgeColor)) {\n          borderColor = parseInt(edgesStyles.edgeColor.substr(1), 16);\n        }\n        if (borderType === undefined && (edgesStyles === null || edgesStyles === void 0 ? void 0 : edgesStyles.edgeType)) {\n          borderType = edgesStyles.edgeType;\n        }\n        if (borderBold === undefined && (edgesStyles === null || edgesStyles === void 0 ? void 0 : edgesStyles.edgeBold) !== undefined) {\n          borderBold = edgesStyles.edgeBold;\n        }\n        if (vertexColor === undefined && (pointsStyles === null || pointsStyles === void 0 ? void 0 : pointsStyles.pointColor)) {\n          vertexColor = parseInt(pointsStyles.pointColor.substr(1), 16);\n        }\n        if (vertexType === undefined && (pointsStyles === null || pointsStyles === void 0 ? void 0 : pointsStyles.pointType)) {\n          vertexType = pointsStyles.pointType;\n        }\n      }\n      const displayColor = (categoryItem === null || categoryItem === void 0 ? void 0 : categoryItem.displayColor) ? parseInt(categoryItem.displayColor.substr(1), 16) : undefined;\n      return {\n        dotColor,\n        dotType,\n        fillColor: fillColor || displayColor,\n        borderColor: borderColor || displayColor,\n        borderType,\n        borderBold,\n        vertexColor: vertexColor || displayColor,\n        vertexType\n      };\n    };\n    /**\n     * set shape styles\n     * @param shape\n     * @param instanceItem\n     * @param camera\n     * @param frameIndex\n     */\n    this.setShapeStyles = (shape, instanceItem, camera = this.rootStore.frame.currentCamera, frameIndex = this.rootStore.frame.currentFrame) => {\n      var _instanceItem$cameras;\n      const {\n        attributes\n      } = ((_instanceItem$cameras = instanceItem.cameras[camera]) === null || _instanceItem$cameras === void 0 ? void 0 : _instanceItem$cameras.frames[frameIndex]) || {};\n      const {\n        dotColor,\n        dotType,\n        fillColor,\n        borderColor,\n        borderType,\n        borderBold,\n        vertexColor,\n        vertexType\n      } = this.getShapeStyle(attributes, instanceItem.instance.category, instanceItem.name);\n      if (shape.shapeType === ShapeType.DOT) {\n        if (dotColor !== undefined) {\n          shape.color = dotColor;\n          shape.originColors.color = dotColor;\n        }\n        if (dotType) {\n          shape.dotType = dotType;\n        }\n      }\n      if ((shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.RECTANGLE) && fillColor !== undefined) {\n        shape.fillColor = fillColor;\n      }\n      if (shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.LINE || shape.shapeType === ShapeType.ARROW || shape.shapeType === ShapeType.RECTANGLE) {\n        if (borderColor !== undefined) {\n          shape.borderColor = borderColor;\n          shape.originColors.borderColor = borderColor;\n        }\n        if (borderType !== undefined) {\n          shape.borderType = borderType;\n        }\n        if (borderBold !== undefined) {\n          shape.borderBold = borderBold;\n        }\n      }\n      if (shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.LINE || shape.shapeType === ShapeType.ARROW) {\n        if (vertexColor !== undefined) {\n          shape.vertexColor = vertexColor;\n        }\n        if (vertexType !== undefined) {\n          shape.vertexType = vertexType;\n        }\n      }\n    };\n    /**\n     * validate shape\n     * @param shape\n     */\n    this.validateShape = shape => {\n      if (shape.area < this.rootStore.config.minArea) {\n        if (shape.uid === this.cuttingPolygon) {\n          this.endPolygonCutting();\n        }\n        const {\n          instanceItem\n        } = this.shapes[shape.uid] || {};\n        if (instanceItem) {\n          // related to instance, also update data\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n        } else {\n          // has not been related to any instance, just delete the shape\n          this.deleteShape(shape);\n        }\n        message.warning(i18n.translate('MIN_AREA_ALERT'));\n        return false;\n      }\n      return true;\n    };\n    /**\n     * select shapes\n     * @param shapes\n     */\n    this.selectShapes = shapes => {\n      if (this.selectedPointIndex >= 0) {\n        // has point selected\n        if (this.selectedShapes.length === 1 && shapes.length === 1 && this.selectedShapes[0] === shapes[0]) {\n          // same shape, do not unselect\n          return;\n        }\n        this.selectedPointIndex = -1;\n      }\n      this.selectedShapes.forEach(shape => {\n        if (shapes.indexOf(shape) < 0) {\n          // not selected any more\n          shape.selected = false;\n          if (this.projectedShapes[shape.uid]) {\n            Object.values(this.projectedShapes[shape.uid]).forEach(projectedShape => {\n              projectedShape.selected = false;\n            });\n          }\n        }\n      });\n      this.selectedShapes = [...shapes];\n      this.selectedShapes.forEach(shape => {\n        shape.selected = true;\n        const projectedShapes = this.projectedShapes[shape.uid];\n        if (projectedShapes) {\n          Object.keys(projectedShapes).forEach(projectCamera => {\n            const projectedShape = projectedShapes[projectCamera];\n            projectedShape.selected = true;\n            // this.fitProjectShape(projectedShape, projectCamera);\n          });\n        }\n      });\n    };\n    /**\n     * select shape by instance item\n     * @param instanceItem\n     * @param autoFocus\n     */\n    this.selectShapeByInstanceItem = (instanceItem, autoFocus = false) => {\n      const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...(instanceItem ? [instanceItem] : [])];\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        const shapes = this.getShapesByInstanceItems(instanceItems);\n        this.selectShapes(shapes);\n        const {\n          currentCameraView\n        } = this.rootStore.frame;\n        if (autoFocus && shapes.length > 0 && currentCameraView) {\n          let {\n            left,\n            top,\n            right,\n            bottom\n          } = shapes[0].instance.getLocalBounds();\n          for (let i = 1; i < shapes.length; i += 1) {\n            const bbox = shapes[i].instance.getLocalBounds();\n            left = Math.min(bbox.left, left);\n            top = Math.min(bbox.top, top);\n            right = Math.max(bbox.right, right);\n            bottom = Math.max(bbox.bottom, bottom);\n          }\n          currentCameraView.fitShapeToView({\n            left,\n            top,\n            right,\n            bottom\n          }, 0.5);\n        }\n      }\n      const instancesSet = new Set(instanceItems.map(i => i.instance));\n      this.updateShapesInInstance(Array.from(instancesSet));\n      this.predict();\n      this.hideOrShowOthers();\n    };\n    /**\n     * click to unselect shape\n     */\n    this.unselectShape = () => {\n      if (this.rootStore.config.addMode || this.cuttingPolygon || this.splittingPolygn) {\n        return;\n      }\n      this.rootStore.cancelShapeWorking();\n      this.selectedShapes.forEach(shape => {\n        shape.selected = false;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.selected = false;\n        });\n      });\n      this.selectedShapes = [];\n      this.rootStore.instance.selectInstance(null);\n    };\n    /**\n     * set selected shape points\n     * @param shapePointsMap\n     */\n    this.setSelectedPoints = shapePointsMap => {\n      let count = 0;\n      Object.keys(shapePointsMap).forEach(shapeId => {\n        const {\n          shape\n        } = this.shapes[shapeId];\n        shape.setSelectedPoints(shapePointsMap[shapeId]);\n        count += shapePointsMap[shapeId].length;\n      });\n      if (count === 1) {\n        // point can be selected\n        this.selectedPointIndex = Object.values(shapePointsMap)[0][0];\n      }\n    };\n    /**\n     * set selected shapes\n     * @param shapeIds\n     */\n    this.setSelectedShapes = shapeIds => {\n      const shapeItems = Object.values(this.shapes).filter(({\n        shape\n      }) => shapeIds.indexOf(shape.uid) >= 0);\n      const instanceItems = shapeItems.map(({\n        instanceItem\n      }) => instanceItem);\n      this.rootStore.instance.selectInstanceItem(instanceItems);\n    };\n    /**\n     * update shape border color\n     * @param instance\n     */\n    this.updateShapesInInstance = instance => {\n      const instances = Array.isArray(instance) ? instance : [...(instance ? [instance] : [])];\n      Object.values(this.shapes).forEach(({\n        shape,\n        instanceItem\n      }) => {\n        if (instances.indexOf(instanceItem.instance) >= 0) {\n          shape.borderColor = 0xFFFF00;\n          if (shape.shapeType === ShapeType.DOT) {\n            shape.color = 0xFFFF00;\n          }\n        } else {\n          shape.borderColor = shape.originColors.borderColor;\n          if (shape.shapeType === ShapeType.DOT) {\n            shape.color = shape.originColors.color;\n          }\n        }\n      });\n    };\n    /**\n     * click to draw a shape\n     * @param point\n     * @param shapeContainer\n     * @param imageBounds\n     * @param finishCallback\n     */\n    this.addShape = (point, shapeContainer, imageBounds, finishCallback) => {\n      if (this.rootStore.initialized && this.rootStore.config.addMode && !this.drawingShape) {\n        this.drawingShape = this.createShape(shapeContainer || this.currentLayer, imageBounds || this.rootStore.frame.imageBounds, this.rootStore.ontology.selectedCategoryItem.displayColor, this.rootStore.ontology.selectedCategory.className, this.rootStore.ontology.selectedCategoryItem.name);\n\n        // add listeners\n        this.drawingShape.on(EventAction.FINISHED, shape => {\n          // remove listeners after creating\n          shape.off(EventAction.FINISHED);\n          shape.off(EventAction.REMOVED);\n          shape.off(EventAction.RECOGNITION);\n          this.drawingShape = null;\n          if (!this.rootStore.config.continuousMode) {\n            this.rootStore.config.setAddMode(false);\n          }\n          if (this.validateShape(shape)) {\n            // add shape to instance item\n            this.addShapeToCurrentInstanceItem(shape);\n          }\n          if (this.rootStore.config.continuousMode) {\n            shape.interactive = false;\n          }\n          // finish creating\n          if (finishCallback) {\n            finishCallback();\n          }\n        });\n        this.drawingShape.on(EventAction.REMOVED, () => {\n          this.drawingShape = null;\n          if (this.recognitionStart && !this.rootStore.config.continuousMode) {\n            // if recognition shape removed, should set add mode to false\n            this.rootStore.config.setAddMode(false);\n          }\n        });\n        this.drawingShape.on(EventAction.RECOGNITION, async (_, data) => {\n          // do recognition\n          this.recognitionStart = true;\n          this.rootStore.config.cursor = Cursor.DEFAULT; // use default cursor, not crosshair\n          // request\n          const {\n            frames,\n            currentFrame\n          } = this.rootStore.frame;\n          const {\n            bounds,\n            controls\n          } = data;\n          this.recognitionData.image = await getSnapshot(frames[currentFrame], bounds);\n          this.recognitionData.clicks = JSON.stringify(controls);\n          this.requestRecognition();\n        });\n        // start create\n        this.drawingShape.create(point, this.rootStore.ontology.currentOptions);\n        return this.drawingShape;\n      }\n      return null;\n    };\n    /**\n     * add shape to current instance item\n     * @param shape\n     */\n    this.addShapeToCurrentInstanceItem = shape => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem();\n      const {\n        prevState,\n        currState\n      } = instanceItem.addShape(currentCamera, currentFrame, this.rootStore.config.autoInterpolation, shape.shapeType, shape.getData(), shape.order, this.rootStore.ontology.isOCRTool, this.rootStore.ontology.isFormulaTool);\n      const basicInfo = instanceItem.instance.getBasicInfo();\n      this.rootStore.undo.push({\n        instances: prevState ? [{\n          ...basicInfo,\n          children: [prevState]\n        }] : []\n      }, {\n        instances: currState ? [{\n          ...basicInfo,\n          children: [currState]\n        }] : []\n      });\n\n      // update shape instance\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        shape.label = instanceItem.label;\n        this.setShapeStyles(shape, instanceItem);\n        this.addShapeListeners(shape);\n        this.shapes[shape.uid] = {\n          shape,\n          camera: currentCamera,\n          instanceItem\n        };\n      }\n\n      // select\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n      // project\n      this.projectShape(shape);\n    };\n    /**\n     * add predicted shape to instance item\n     * @param instanceItem\n     * @param camera\n     */\n    this.addShapeToInstanceItem = (instanceItem, camera = this.rootStore.frame.currentCamera) => {\n      const {\n        currentCamera,\n        currentFrame,\n        cameraViews,\n        getImageBoundsForCamera\n      } = this.rootStore.frame;\n      const currentCameraView = cameraViews[camera];\n      const imageBounds = getImageBoundsForCamera(camera);\n      if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n        return;\n      }\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame]) {\n        return;\n      }\n      let shapeInfo;\n      const predictedItem = Object.values(this.predictedShapes).find(i => i.instanceItem === instanceItem);\n      if (camera === currentCamera && predictedItem) {\n        // predicted shape in current camera exists, use it\n        const {\n          shape\n        } = predictedItem;\n        shapeInfo = {\n          shapeType: shape.shapeType,\n          shape: shape.getData()\n        };\n        // remove predicted shape\n        shape.destroy();\n        delete this.predictedShapes[shape.uid];\n      } else {\n        shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n      }\n      if (shapeInfo) {\n        const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n        if (area < this.rootStore.config.minArea) {\n          message.warning(i18n.translate('MIN_AREA_ALERT'));\n          return;\n        }\n        // add to model\n        this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, shapeInfo.shapeType, shapeInfo.shape, this.rootStore.frame.getNextShapeOrder(currentFrame, camera), camera);\n        // create shape\n        this.setupShape(instanceItem, camera, currentCameraView.shapesLayer, imageBounds);\n        // set camera\n        if (currentCamera !== camera) {\n          this.rootStore.frame.setCamera(camera);\n        }\n        // select\n        this.rootStore.instance.selectInstanceItem(instanceItem);\n        this.rootStore.instance.autoOpenAttributesModal();\n      }\n    };\n    /**\n     * add predicted shapes to instance\n     * @param instance\n     * @param camera\n     */\n    this.addShapesToInstance = (instance, camera = this.rootStore.frame.currentCamera) => {\n      const currentCameraView = this.rootStore.frame.cameraViews[camera];\n      if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n        return;\n      }\n      const {\n        currentCamera,\n        currentFrame,\n        getImageBoundsForCamera,\n        getNextShapeOrder\n      } = this.rootStore.frame;\n      const imageBounds = getImageBoundsForCamera(camera);\n      const instanceItems = [];\n      Object.values(instance.items).forEach(instanceItem => {\n        const cameraData = instanceItem.cameras[camera];\n        if (!cameraData || !cameraData.frames[currentFrame]) {\n          // not exist in current frame\n          let shapeInfo;\n          const predictedItem = Object.values(this.predictedShapes).find(i => i.instanceItem === instanceItem);\n          if (camera === currentCamera && predictedItem) {\n            // predicted shape in current camera exists, use it\n            const {\n              shape\n            } = predictedItem;\n            shapeInfo = {\n              shapeType: shape.shapeType,\n              shape: shape.getData()\n            };\n            // remove predicted shape\n            shape.destroy();\n            delete this.predictedShapes[shape.uid];\n          } else {\n            shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n          }\n          if (shapeInfo) {\n            const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n            if (area < this.rootStore.config.minArea) {\n              return;\n            }\n            instanceItems.push({\n              instanceItem,\n              frameIndex: currentFrame,\n              order: getNextShapeOrder(currentFrame, camera),\n              camera,\n              ...shapeInfo\n            });\n          }\n        }\n      });\n      if (instanceItems.length > 0) {\n        // update model\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n        // setup shapes\n        instanceItems.forEach(({\n          instanceItem\n        }) => {\n          this.setupShape(instanceItem, camera, currentCameraView.shapesLayer, imageBounds);\n        });\n        // select\n        this.rootStore.instance.selectInstanceItem(null);\n        this.rootStore.instance.selectInstance(instance);\n        this.rootStore.instance.autoOpenAttributesModal();\n      }\n    };\n    /**\n     * setup shape in current camera & current frame\n     * @param instanceItem\n     * @param shapeContainer\n     * @param imageBounds\n     */\n    this.setupShape = (instanceItem, camera = this.rootStore.frame.currentCamera, shapeContainer, imageBounds) => {\n      const {\n        cameraViews,\n        currentFrame\n      } = this.rootStore.frame;\n      const cameraData = instanceItem.cameras[camera];\n      if (cameraData) {\n        const frameData = cameraData.frames[currentFrame];\n        if (frameData) {\n          var _cameraViews$camera;\n          // remove shape if already exists\n          const existingShape = this.getShapeByInstanceItem(instanceItem, camera);\n          const existingShapeId = existingShape === null || existingShape === void 0 ? void 0 : existingShape.uid;\n          if (existingShape) {\n            this.deleteShape(existingShape);\n          }\n          // add shape\n          if (!((_cameraViews$camera = cameraViews[camera]) === null || _cameraViews$camera === void 0 ? void 0 : _cameraViews$camera.imageLoadError)) {\n            const shape = this.createShape(shapeContainer || cameraViews[camera].shapesLayer, imageBounds || this.rootStore.frame.getImageBoundsForCamera(camera), instanceItem.categoryItemRef.displayColor, instanceItem.instance.category, instanceItem.name, frameData.shapeType, frameData.shape, frameData.order !== undefined ? frameData.order : this.rootStore.frame.getNextShapeOrder(), instanceItem.label, camera);\n            if (shape.destroyed) {\n              // delete instance item\n              this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame, camera);\n              return;\n            }\n            this.setShapeStyles(shape, instanceItem, camera);\n            this.addShapeListeners(shape);\n            this.shapes[shape.uid] = {\n              shape,\n              camera,\n              instanceItem\n            };\n            this.rootStore.relationship.setupConnectionsForInstanceItem(instanceItem);\n            if (this.pendingMergePolygon === existingShapeId) {\n              this.pendingMergePolygon = shape.uid;\n            }\n            if (this.cuttingPolygon === existingShapeId) {\n              this.cuttingPolygon = shape.uid;\n            }\n            if (this.splittingPolygn === existingShapeId) {\n              this.splittingPolygn = shape.uid;\n            }\n            this.projectShape(shape, false, camera);\n          }\n        }\n      }\n    };\n    /**\n     * predict in current camera & current frame\n     * @param instance\n     */\n    this.predict = () => {\n      this.clearPredictedShapes();\n      if (!this.rootStore.config.autoTracking || this.rootStore.readonly && this.rootStore.config.reviewMode !== ReviewMode.REVIEW || this.rootStore.config.viewMode === ViewMode.GRID) {\n        return;\n      }\n      const {\n        isMultiSelected,\n        selectedInstances,\n        selectedInstanceItems\n      } = this.rootStore.instance;\n      if (isMultiSelected) {\n        return;\n      }\n      if (selectedInstances.length === 1) {\n        const {\n          currentCamera,\n          currentFrame,\n          currentCameraView,\n          imageBounds\n        } = this.rootStore.frame;\n        if (currentCameraView === null || currentCameraView === void 0 ? void 0 : currentCameraView.imageLoadError) {\n          return;\n        }\n        const selectedInstance = selectedInstances[0];\n        Object.values(selectedInstance.items).forEach(item => {\n          const shapeInfo = item.predictShape(currentCamera, currentFrame, imageBounds);\n          if (shapeInfo) {\n            // create predict shape\n            const predictedShape = this.createShape(this.currentLayer, imageBounds, item.categoryItemRef.displayColor, selectedInstance.category, item.name, shapeInfo.shapeType, shapeInfo.shape, 9999,\n            // predicted shape always on the top\n            item.label);\n            predictedShape.borderStyle = BorderStyle.DASHED;\n            predictedShape.borderColor = 0xFFFF00;\n            if (predictedShape.shapeType === ShapeType.DOT) {\n              predictedShape.color = 0xFFFF00;\n            }\n            predictedShape.editable = this.rootStore.config.reviewMode === ReviewMode.LABELING;\n            if (selectedInstanceItems.indexOf(item) >= 0) {\n              predictedShape.selected = true;\n            }\n            // add listeners\n            this.addShapeListeners(predictedShape);\n            this.predictedShapes[predictedShape.uid] = {\n              shape: predictedShape,\n              instanceItem: item\n            };\n          }\n        });\n      }\n    };\n    /**\n     * delete selected shape point or instance\n     */\n    this.delete = () => {\n      if (this.selectedShapes.length > 0) {\n        this.deleting = true;\n        this.selectedPointIndex = -1;\n        const pointsDeletedShapes = [];\n        this.selectedShapes.forEach(shape => {\n          const deleted = shape.deleteSelectedPoints();\n          if (deleted) {\n            pointsDeletedShapes.push(shape);\n          }\n        });\n        const {\n          currentFrame\n        } = this.rootStore.frame;\n        if (pointsDeletedShapes.length > 0) {\n          // has points deleted shapes\n          const instanceItems = [];\n          pointsDeletedShapes.forEach(shape => {\n            const shapeItem = this.shapes[shape.uid];\n            if (shapeItem) {\n              instanceItems.push({\n                instanceItem: shapeItem.instanceItem,\n                frameIndex: currentFrame,\n                shapeType: shape.shapeType,\n                shape: shape.destroyed ? undefined : shape.getData()\n              });\n              if (shape.destroyed) {\n                this.deleteShape(shape);\n              } else {\n                this.projectShape(shape);\n              }\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n        } else {\n          // should delete shapes\n          const instanceItems = [];\n          this.selectedShapes.forEach(shape => {\n            const shapeItem = this.shapes[shape.uid];\n            if (shapeItem) {\n              const {\n                instanceItem\n              } = shapeItem;\n              instanceItems.push({\n                instanceItem,\n                frames: [currentFrame]\n              });\n            }\n          });\n          this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);\n          this.predict();\n        }\n      }\n      this.deleting = false;\n    };\n    /**\n     * delete shape instance\n     * @param shape\n     */\n    this.deleteShape = shape => {\n      const index = this.selectedShapes.indexOf(shape);\n      if (index >= 0) {\n        this.selectedShapes.splice(index, 1);\n      }\n      shape.destroy();\n      delete this.shapes[shape.uid];\n      if (this.projectedShapes[shape.uid]) {\n        Object.values(this.projectedShapes[shape.uid]).forEach(s => {\n          s.destroy();\n        });\n        delete this.projectedShapes[shape.uid];\n      }\n    };\n    /**\n     * delete shape by instance item\n     * @param instanceItem\n     */\n    this.deleteShapeByInstanceItem = instanceItem => {\n      const shape = this.getShapeByInstanceItem(instanceItem);\n      if (shape) {\n        this.deleteShape(shape);\n      }\n    };\n    /**\n     * set threshold for recognition\n     * @param threshold\n     */\n    this.setRecognitionThreshold = threshold => {\n      this.recognitionData.threshold = threshold;\n    };\n    /**\n     * request recognition\n     */\n    this.requestRecognition = async () => {\n      if (!this.recognitionStart) {\n        return;\n      }\n      const {\n        image,\n        clicks,\n        threshold\n      } = this.recognitionData;\n      if (image && clicks) {\n        this.rootStore.frame.loading = true;\n        try {\n          const polygon = await imageSegmentation(image, clicks, threshold);\n          // set to drawing shape\n          this.drawingShape.setRecognizedPolygon(polygon);\n        } catch (e) {\n          message.error(i18n.translate('RECOGNITION_FAIL'));\n        }\n        this.rootStore.frame.loading = false;\n      }\n    };\n    /**\n     * finish recognition\n     */\n    this.finishRecognition = () => {\n      if (this.recognitionStart) {\n        this.drawingShape.finishCreate();\n      }\n    };\n    /**\n     * set points user data for shape by hotkey\n     * @param shape\n     * @param hotkey\n     */\n    this.setPointsUserDataByHotkey = (shape, hotkey) => {\n      if (shape instanceof Polygon || shape instanceof Line) {\n        const hotkeyItems = this.rootStore.config.pointHotkeyMap[hotkey] || [];\n        const selectedPoints = shape.getSelectedPoints();\n        if (hotkeyItems.length > 0 && selectedPoints.length > 0) {\n          const pointsData = [];\n          selectedPoints.forEach(({\n            index,\n            point\n          }) => {\n            let userData = {\n              ...point.userData\n            };\n            hotkeyItems.forEach(({\n              type,\n              attributes\n            }) => {\n              userData = type === 'overwrite' ? {\n                ...attributes\n              } : {\n                ...userData,\n                ...attributes\n              };\n            });\n            pointsData.push({\n              index,\n              userData\n            });\n          });\n          shape.setPointsUserData(pointsData);\n        }\n      }\n    };\n    /**\n     * set points user data for shape\n     * @param shape\n     * @param pointIndex\n     * @param userData\n     */\n    this.setPointUserData = (shape, pointIndex, userData) => {\n      if (shape instanceof Polygon || shape instanceof Line) {\n        const pointsData = [{\n          index: pointIndex,\n          userData\n        }];\n        shape.setPointsUserData(pointsData);\n      }\n    };\n    /**\n     * move selected shape to front\n     * @param toTop\n     */\n    this.moveFront = (toTop = false) => {\n      if (this.selectedShapes.length === 1) {\n        const selectedShape = this.selectedShapes[0];\n        if (toTop) {\n          this.moveToTop(this.shapes[selectedShape.uid].instanceItem);\n          return;\n        }\n        const intersections = this.getIntersectionsForShape(selectedShape);\n        if (intersections.length > 0) {\n          const upperShape = getUpperShape(selectedShape, intersections);\n          if (upperShape) {\n            this.exchangeShapeOrder(selectedShape, upperShape);\n            message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_FRONT_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    };\n    /**\n     * move selected shape to back\n     * @param toBottom\n     */\n    this.moveBack = (toBottom = false) => {\n      if (this.selectedShapes.length === 1) {\n        const selectedShape = this.selectedShapes[0];\n        if (toBottom) {\n          this.moveToBottom(this.shapes[selectedShape.uid].instanceItem);\n          return;\n        }\n        const intersections = this.getIntersectionsForShape(selectedShape);\n        if (intersections.length > 0) {\n          const underShape = getUnderShape(selectedShape, intersections);\n          if (underShape) {\n            this.exchangeShapeOrder(selectedShape, underShape);\n            message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n          } else {\n            message.warning(i18n.translate('ORDER_BACK_MOST'));\n          }\n        } else {\n          message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n        }\n      }\n    };\n    this.clearPending = () => {\n      this.pendingMergePolygon = '';\n    };\n    this.mergePolygon = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || this.selectedShapes.length !== 1 || this.selectedShapes[0].shapeType !== ShapeType.POLYGON) {\n        return;\n      }\n      this.endPolygonCutting(); // cancel cutting\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      const selectedPolygon = this.selectedShapes[0];\n      const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i => i.shape);\n      const intersectPolygonIds = selectedPolygon.findIntersectPolygons(shapes);\n      if (intersectPolygonIds.length === 1) {\n        this.mergePolygons(selectedPolygon.uid, intersectPolygonIds[0]);\n      } else if (intersectPolygonIds.length === 0) {\n        message.warn(i18n.translate('MERGE_NO_INTERSECT'));\n      } else {\n        this.pendingMergePolygon = selectedPolygon.uid;\n        message.info(i18n.translate('MERGE_SELECT_NEXT'));\n      }\n    };\n    this.subtractPolygon = () => {\n      if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || this.selectedShapes.length !== 1 || this.selectedShapes[0].shapeType !== ShapeType.POLYGON) {\n        return;\n      }\n      this.rootStore.cancelShapeWorking();\n      const selectedPolygon = this.selectedShapes[0];\n      const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i => i.shape);\n      const intersectPolygons = selectedPolygon.findIntersectPolygons(shapes).map(i => this.shapes[i].shape);\n      const subtractedData = selectedPolygon.subtract(intersectPolygons);\n      if (subtractedData && subtractedData.length > 0) {\n        this.updatePolygons(subtractedData[0][0], subtractedData.slice(1).map(d => d[0]));\n        message.success(i18n.translate('SUBTRACT_SUCCESS'));\n      } else {\n        message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));\n      }\n    };\n    this.updateConfig = ({\n      fill,\n      alpha,\n      toleranceFill,\n      toleranceAlpha,\n      borderAlpha,\n      borderWidth,\n      dotRadius,\n      showVertex,\n      showVertexOrder,\n      vertexSize\n    }) => {\n      const {\n        viewMode\n      } = this.rootStore.config;\n      if (fill !== undefined) {\n        this.config.fill = fill;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesFill(fill);\n        } else {\n          this.rootStore.grid.updateShapesFill(fill);\n        }\n      }\n      if (alpha !== undefined) {\n        this.config.alpha = alpha;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesAlpha(alpha / 100);\n        } else {\n          this.rootStore.grid.updateShapesAlpha(alpha / 100);\n        }\n      }\n      if (toleranceFill !== undefined) {\n        this.config.toleranceFill = toleranceFill;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesToleranceFill(toleranceFill);\n        } else {\n          this.rootStore.grid.updateShapesToleranceFill(toleranceFill);\n        }\n      }\n      if (toleranceAlpha !== undefined) {\n        this.config.toleranceAlpha = toleranceAlpha;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesToleranceAlpha(toleranceAlpha / 100);\n        } else {\n          this.rootStore.grid.updateShapesToleranceAlpha(toleranceAlpha / 100);\n        }\n      }\n      if (borderAlpha !== undefined) {\n        this.config.borderAlpha = borderAlpha;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesBorderAlpha(borderAlpha / 100);\n        } else {\n          this.rootStore.grid.updateShapesBorderAlpha(borderAlpha / 100);\n        }\n      }\n      if (borderWidth !== undefined) {\n        this.config.borderWidth = borderWidth;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShapesBorderWidth(borderWidth);\n        } else {\n          this.rootStore.grid.updateShapesBorderWidth(borderWidth);\n        }\n      }\n      if (dotRadius !== undefined) {\n        this.config.dotRadius = dotRadius;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateDotsRadius(dotRadius);\n        } else {\n          this.rootStore.grid.updateDotsRadius(dotRadius);\n        }\n      }\n      if (showVertex !== undefined) {\n        this.config.showVertex = showVertex;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShowVertex(showVertex);\n        } else {\n          this.rootStore.grid.updateShowVertex(showVertex);\n        }\n      }\n      if (showVertexOrder !== undefined) {\n        this.config.showVertexOrder = showVertexOrder;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateShowVertexOrder(showVertexOrder);\n        } else {\n          this.rootStore.grid.updateShowVertexOrder(showVertexOrder);\n        }\n      }\n      if (vertexSize !== undefined) {\n        this.config.vertexSize = vertexSize;\n        if (viewMode === ViewMode.DEFAULT) {\n          this.updateVertexSize(vertexSize);\n        } else {\n          this.rootStore.grid.updateVertexSize(vertexSize);\n        }\n      }\n    };\n    this.updateShapesFill = fill => {\n      const fillAlpha = fill ? this.config.alpha / 100 : 0;\n      if (this.drawingShape) {\n        this.drawingShape.alpha = fillAlpha;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.alpha = fillAlpha;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.alpha = fillAlpha;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.alpha = fillAlpha;\n        });\n      });\n    };\n    this.updateShapesAlpha = alpha => {\n      if (this.config.fill) {\n        if (this.drawingShape) {\n          this.drawingShape.alpha = alpha;\n        }\n        Object.values(this.shapes).forEach(({\n          shape\n        }) => {\n          shape.alpha = alpha;\n        });\n        Object.values(this.predictedShapes).forEach(({\n          shape\n        }) => {\n          shape.alpha = alpha;\n        });\n        Object.values(this.projectedShapes).forEach(cameraShapes => {\n          Object.values(cameraShapes).forEach(shape => {\n            shape.alpha = alpha;\n          });\n        });\n      }\n    };\n    this.updateShapesToleranceFill = fill => {\n      const fillAlpha = fill ? this.config.toleranceAlpha / 100 : 0;\n      if (this.drawingShape instanceof Rectangle) {\n        this.drawingShape.toleranceAlpha = fillAlpha;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Rectangle) {\n          shape.toleranceAlpha = fillAlpha;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Rectangle) {\n          shape.toleranceAlpha = fillAlpha;\n        }\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          if (shape instanceof Rectangle) {\n            shape.toleranceAlpha = fillAlpha;\n          }\n        });\n      });\n    };\n    this.updateShapesToleranceAlpha = alpha => {\n      if (this.config.toleranceFill) {\n        if (this.drawingShape instanceof Rectangle) {\n          this.drawingShape.toleranceAlpha = alpha;\n        }\n        Object.values(this.shapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Rectangle) {\n            shape.toleranceAlpha = alpha;\n          }\n        });\n        Object.values(this.predictedShapes).forEach(({\n          shape\n        }) => {\n          if (shape instanceof Rectangle) {\n            shape.toleranceAlpha = alpha;\n          }\n        });\n        Object.values(this.projectedShapes).forEach(cameraShapes => {\n          Object.values(cameraShapes).forEach(shape => {\n            if (shape instanceof Rectangle) {\n              shape.toleranceAlpha = alpha;\n            }\n          });\n        });\n      }\n    };\n    this.updateShapesBorderAlpha = borderAlpha => {\n      if (this.drawingShape) {\n        this.drawingShape.borderAlpha = borderAlpha;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.borderAlpha = borderAlpha;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.borderAlpha = borderAlpha;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.borderAlpha = borderAlpha;\n        });\n      });\n    };\n    this.updateShapesBorderWidth = borderWidth => {\n      if (this.drawingShape) {\n        this.drawingShape.borderWidth = borderWidth;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.borderWidth = borderWidth;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.borderWidth = borderWidth;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.borderWidth = borderWidth;\n        });\n      });\n    };\n    this.updateDotsRadius = dotRadius => {\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Dot) {\n          shape.dotRadius = dotRadius;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        if (shape instanceof Dot) {\n          shape.dotRadius = dotRadius;\n        }\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          if (shape instanceof Dot) {\n            shape.dotRadius = dotRadius;\n          }\n        });\n      });\n    };\n    this.updateShowVertex = showVertex => {\n      if (this.drawingShape) {\n        this.drawingShape.showVertex = showVertex;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showVertex = showVertex;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showVertex = showVertex;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.showVertex = showVertex;\n        });\n      });\n    };\n    this.updateShowVertexOrder = showVertexOrder => {\n      if (this.drawingShape) {\n        this.drawingShape.showVertexOrder = showVertexOrder;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.showVertexOrder = showVertexOrder;\n        });\n      });\n    };\n    this.updateVertexSize = vertexSize => {\n      if (this.drawingShape) {\n        this.drawingShape.vertexSize = vertexSize;\n      }\n      Object.values(this.shapes).forEach(({\n        shape\n      }) => {\n        shape.vertexSize = vertexSize;\n      });\n      Object.values(this.predictedShapes).forEach(({\n        shape\n      }) => {\n        shape.vertexSize = vertexSize;\n      });\n      Object.values(this.projectedShapes).forEach(cameraShapes => {\n        Object.values(cameraShapes).forEach(shape => {\n          shape.vertexSize = vertexSize;\n        });\n      });\n    };\n    this.resetConfig = () => {\n      this.updateConfig({\n        ...this.defaultConfig\n      });\n    };\n    this.togglePolygonCut = () => {\n      if (this.cuttingPolygon) {\n        this.endPolygonCutting();\n      } else {\n        this.startPolygonCutting('cut');\n      }\n    };\n    /**\n     * rotate all shapes (excluding predicted shapes)\n     * @param rotation\n     * @param center\n     * @param offsetX\n     * @param offsetY\n     */\n    this.rotateShapesByCanvas = (rotation, center, offsetX, offsetY) => {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const {\n        autoInterpolation\n      } = this.rootStore.config;\n      const prevInstanceMap = {};\n      const currInstanceMap = {};\n      this.getShapesForCamera(currentCamera).forEach(({\n        shape,\n        instanceItem\n      }) => {\n        // update shape\n        switch (shape.shapeType) {\n          case ShapeType.POLYGON:\n          case ShapeType.LINE:\n          case ShapeType.ARROW:\n            {\n              const s = shape;\n              const {\n                points\n              } = s;\n              s.points = points.map(p => {\n                const rp = computeRotatedPosition(center, p, rotation);\n                return {\n                  x: precise(rp.x - offsetX),\n                  y: precise(rp.y - offsetY),\n                  userData: p.userData\n                };\n              });\n              break;\n            }\n          case ShapeType.RECTANGLE:\n            {\n              const rect = shape;\n              const {\n                x,\n                y,\n                width,\n                height,\n                centerLineEnabled,\n                center: c,\n                rotation: r\n              } = rect;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x: x + width / 2,\n                y: y + height / 2\n              }, rotation);\n              if (rotation % Math.PI !== 0) {\n                rect.width = height;\n                rect.height = width;\n              }\n              rect.x = precise(rotatedCenter.x - offsetX - rect.width / 2);\n              rect.y = precise(rotatedCenter.y - offsetY - rect.height / 2);\n              // update center\n              if (centerLineEnabled) {\n                rect.center = precise(rect.x + (c - x) / width * rect.width);\n              }\n              // reset rotation to update pivot\n              rect.rotation = r;\n              break;\n            }\n          case ShapeType.ELLIPSE:\n            {\n              const ellipse = shape;\n              const {\n                x,\n                y,\n                halfWidth,\n                halfHeight\n              } = ellipse;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x,\n                y\n              }, rotation);\n              ellipse.x = precise(rotatedCenter.x - offsetX);\n              ellipse.y = precise(rotatedCenter.y - offsetY);\n              if (rotation % Math.PI !== 0) {\n                ellipse.halfWidth = halfHeight;\n                ellipse.halfHeight = halfWidth;\n              }\n              break;\n            }\n          case ShapeType.CIRCLE:\n            {\n              const circle = shape;\n              const {\n                x,\n                y\n              } = circle;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x,\n                y\n              }, rotation);\n              circle.x = precise(rotatedCenter.x - offsetX);\n              circle.y = precise(rotatedCenter.y - offsetY);\n              break;\n            }\n          case ShapeType.DOT:\n            {\n              const dot = shape;\n              const {\n                x,\n                y\n              } = dot;\n              const rotatedPoint = computeRotatedPosition(center, {\n                x,\n                y\n              }, rotation);\n              dot.x = precise(rotatedPoint.x - offsetX);\n              dot.y = precise(rotatedPoint.y - offsetY);\n              break;\n            }\n          case ShapeType.CUBOID:\n          case ShapeType.TWO_SIDES_CUBOID:\n            {\n              const cuboid = shape;\n              const {\n                x1,\n                y1,\n                w1,\n                h1,\n                x2,\n                y2,\n                w2,\n                h2\n              } = cuboid;\n              const rotatedCenter1 = computeRotatedPosition(center, {\n                x: x1 + w1 / 2,\n                y: y1 + h1 / 2\n              }, rotation);\n              const rotatedCenter2 = computeRotatedPosition(center, {\n                x: x2 + w2 / 2,\n                y: y2 + h2 / 2\n              }, rotation);\n              let fw = w1;\n              let fh = h1;\n              let bw = w2;\n              let bh = h2;\n              if (rotation % Math.PI !== 0) {\n                fw = h1;\n                fh = w1;\n                bw = h2;\n                bh = w2;\n              }\n              cuboid.setData({\n                front: {\n                  x: precise(rotatedCenter1.x - offsetX - fw / 2),\n                  y: precise(rotatedCenter1.y - offsetY - fh / 2),\n                  width: fw,\n                  height: fh\n                },\n                back: {\n                  x: precise(rotatedCenter2.x - offsetX - bw / 2),\n                  y: precise(rotatedCenter2.y - offsetY - bh / 2),\n                  width: bw,\n                  height: bh\n                }\n              });\n              break;\n            }\n          case ShapeType.LSHAPE:\n            {\n              const lshape = shape;\n              const {\n                x,\n                y,\n                w,\n                h,\n                sx1,\n                sy1,\n                sx2,\n                sy2,\n                center: c\n              } = lshape;\n              const rotatedCenter = computeRotatedPosition(center, {\n                x: x + w / 2,\n                y: y + h / 2\n              }, rotation);\n              if (rotation % Math.PI !== 0) {\n                lshape.w = h;\n                lshape.h = w;\n              }\n              lshape.x = rotatedCenter.x - offsetX - lshape.w / 2;\n              lshape.y = rotatedCenter.y - offsetY - lshape.h / 2;\n              // update side points (side points cannot be rotated, keep the offset from origin)\n              if (Math.abs(sx1 - x) < Math.abs(sx1 - x - w)) {\n                lshape.sx1 = lshape.x + sx1 - x;\n                lshape.sx2 = lshape.x + sx2 - x;\n              } else {\n                lshape.sx1 = lshape.x + lshape.w + sx1 - (x + w);\n                lshape.sx2 = lshape.x + lshape.w + sx2 - (x + w);\n              }\n              lshape.sy1 = lshape.y + sy1 - y;\n              lshape.sy2 = lshape.y + sy2 - y;\n              // update center\n              lshape.center = precise(lshape.x + (c - x) / w * lshape.w);\n              lshape.x = precise(lshape.x);\n              lshape.y = precise(lshape.y);\n              lshape.sx1 = precise(lshape.sx1);\n              lshape.sx2 = precise(lshape.sx2);\n              lshape.sy1 = precise(lshape.sy1);\n              lshape.sy2 = precise(lshape.sy2);\n              break;\n            }\n          case ShapeType.GRID:\n            {\n              const grid = shape;\n              const {\n                cols,\n                rows,\n                x,\n                y,\n                width,\n                height\n              } = grid;\n              const gridCenter = {\n                x: x + width / 2,\n                y: y + height / 2\n              };\n              const rotatedCenter = computeRotatedPosition(center, gridCenter, rotation);\n              if (rotation % Math.PI !== 0) {\n                const c0 = rotatedCenter.x - offsetX - height / 2;\n                const r0 = rotatedCenter.y - offsetY - width / 2;\n                grid.cols = rows.map(r => ({\n                  x: precise(c0 + r.y - y)\n                }));\n                grid.rows = cols.map(c => ({\n                  y: precise(r0 + c.x - x)\n                }));\n              } else {\n                const c0 = rotatedCenter.x - offsetX - width / 2;\n                const r0 = rotatedCenter.y - offsetY - height / 2;\n                grid.cols = cols.map(c => ({\n                  x: precise(c0 + c.x - x)\n                }));\n                grid.rows = rows.map(r => ({\n                  y: precise(r0 + r.y - y)\n                }));\n              }\n              break;\n            }\n          default:\n        }\n\n        // save shape data\n        const {\n          prevState,\n          currState\n        } = instanceItem.updateShape(currentCamera, currentFrame, autoInterpolation, shape.shapeType, shape.getData());\n        const {\n          instance\n        } = instanceItem;\n        if (prevState) {\n          if (!prevInstanceMap[instance.id]) {\n            prevInstanceMap[instance.id] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          prevInstanceMap[instance.id].children.push(prevState);\n        }\n        if (currState) {\n          if (!currInstanceMap[instance.id]) {\n            currInstanceMap[instance.id] = {\n              ...instance.getBasicInfo(),\n              children: []\n            };\n          }\n          currInstanceMap[instance.id].children.push(currState);\n        }\n      });\n\n      // reproject shapes\n      this.reprojectShapesByCamera();\n      return {\n        prevState: {\n          instances: Object.values(prevInstanceMap)\n        },\n        currState: {\n          instances: Object.values(currInstanceMap)\n        }\n      };\n    };\n    /**\n     * hide or show shapes based on hideOthers\n     */\n    this.hideOrShowOthers = () => {\n      const {\n        hideOthers,\n        hideAll\n      } = this.rootStore.config;\n      const selectedInstanceIds = this.rootStore.instance.selectedInstances.map(i => i.id);\n      const shouldHide = hideOthers && selectedInstanceIds.length > 0;\n      Object.values(this.shapes).forEach(({\n        shape,\n        instanceItem\n      }) => {\n        const {\n          id\n        } = instanceItem.instance;\n        const labelDom = document.getElementById(`label-item-${instanceItem.id}`);\n        if (hideAll || shouldHide && !selectedInstanceIds.includes(id)) {\n          shape.visible = false;\n          if (labelDom) {\n            labelDom.style.visibility = 'hidden';\n          }\n          if (this.projectedShapes[shape.uid]) {\n            Object.values(this.projectedShapes[shape.uid]).forEach(projectedShape => {\n              projectedShape.visible = false;\n            });\n          }\n        } else {\n          shape.visible = true;\n          if (labelDom) {\n            labelDom.style.visibility = 'visible';\n          }\n          if (this.projectedShapes[shape.uid]) {\n            Object.values(this.projectedShapes[shape.uid]).forEach(projectedShape => {\n              projectedShape.visible = true;\n            });\n          }\n        }\n      });\n      this.rootStore.relationship.hideOrShowRelationships();\n      this.rootStore.review.hideOrShowReviews();\n    };\n    this.fitProjectShapesForSelectedShapes = () => {\n      this.selectedShapes.forEach(shape => {\n        const projectedShapes = this.projectedShapes[shape.uid];\n        if (projectedShapes) {\n          Object.keys(projectedShapes).forEach(projectCamera => {\n            const projectedShape = projectedShapes[projectCamera];\n            this.fitProjectShape(projectedShape, projectCamera);\n          });\n        }\n      });\n    };\n    makeObservable(this, {\n      shapes: observable,\n      recognitionStart: observable,\n      recognitionData: observable,\n      selectedShapes: observable,\n      selectedPointIndex: observable,\n      cuttingPolygon: observable,\n      splittingPolygn: observable,\n      projecting: observable,\n      config: observable,\n      clearShapes: action,\n      setupShapes: action,\n      selectShapes: action,\n      unselectShape: action,\n      addShape: action,\n      setupShape: action,\n      deleteShape: action,\n      setRecognitionThreshold: action,\n      updateConfig: action,\n      startPolygonCutting: action,\n      endPolygonCutting: action\n    });\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload) {\n    this.config.fill = payload.is_fill !== 'false' && payload.is_fill !== false;\n    if (payload.fill_opacity !== undefined && payload.fill_opacity !== '') {\n      const alpha = Number(payload.fill_opacity);\n      if (!Number.isNaN(alpha) && alpha >= 0 && alpha <= 1) {\n        this.config.alpha = alpha * 100;\n      }\n    }\n    if (payload.border_opacity !== undefined && payload.border_opacity !== '') {\n      const borderAlpha = Number(payload.border_opacity);\n      if (!Number.isNaN(borderAlpha) && borderAlpha >= 0 && borderAlpha <= 1) {\n        this.config.borderAlpha = borderAlpha * 100;\n      }\n    }\n    if (payload.border_width !== undefined && payload.border_width !== '') {\n      const borderWidth = Number(payload.border_width);\n      if (!Number.isNaN(borderWidth) && borderWidth >= 1 && borderWidth <= 10) {\n        this.config.borderWidth = borderWidth;\n      }\n    }\n    if (payload.dot_size !== undefined && payload.dot_size !== '') {\n      const dotRadius = Number(payload.dot_size);\n      if (!Number.isNaN(dotRadius) && dotRadius >= 1 && dotRadius <= 10) {\n        this.config.dotRadius = dotRadius;\n      }\n    }\n    this.config.showVertex = payload.show_vertex === 'true' || payload.show_vertex === true;\n    this.config.showVertexOrder = payload.show_vertex_order === 'true' || payload.show_vertex_order === true;\n    if (payload.vertex_size !== undefined && payload.vertex_size !== '') {\n      const vertexSize = Number(payload.vertex_size);\n      if (!Number.isNaN(vertexSize) && vertexSize >= 0) {\n        this.config.vertexSize = vertexSize;\n      }\n    }\n    if (payload.vertex_start !== undefined && payload.vertex_start !== '') {\n      const vertexStart = Number(payload.vertex_start);\n      if (!Number.isNaN(vertexStart)) {\n        this.config.vertexStart = vertexStart;\n      }\n    }\n    this.defaultConfig = {\n      ...this.config\n    }; // save default settings\n\n    this.app = payload.app;\n  }\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable) {\n    Object.values(this.shapes).forEach(({\n      shape\n    }) => {\n      shape.editable = editable;\n    });\n    Object.values(this.predictedShapes).forEach(({\n      shape\n    }) => {\n      shape.editable = editable;\n    });\n  }\n  /**\n   * create shape label dom\n   */\n  createShapeLabel(camera = this.rootStore.frame.currentCamera) {\n    const shapeLabelsContainer = document.getElementById(`${CAMERA_VIEW_LABELS}-${camera}`);\n    if (shapeLabelsContainer) {\n      const shapeLabel = new Label({\n        className: 'shape-label',\n        transPosition: p => {\n          const cameraView = this.rootStore.frame.cameraViews[camera];\n          if (cameraView) {\n            return cameraView.toLocal(p);\n          }\n          return p;\n        }\n      });\n      shapeLabel.addToContainer(shapeLabelsContainer);\n      return shapeLabel;\n    }\n    return undefined;\n  }\n\n  /**\n   * create shape instance\n   * @param shapeContainer\n   * @param imageBounds\n   * @param hexColor\n   * @param categoryName\n   * @param categoryItemName\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param label\n   */\n  createShape(shapeContainer, imageBounds, hexColor, categoryName, categoryItemName, shapeType, shapeData, order, label, camera) {\n    var _this$rootStore$frame;\n    const {\n      boundaryCheck,\n      draggable,\n      rotatable,\n      autoSnap,\n      activePointAttributesMode\n    } = this.rootStore.config;\n    const {\n      currentToolItem,\n      currentTool,\n      currentShapeType,\n      getToolConfigByCategoryItem\n    } = this.rootStore.ontology;\n    const useCurrent = shapeType === undefined;\n    const color = parseInt(hexColor.substr(1), 16);\n    const type = shapeType || currentShapeType;\n    const toolConfig = getToolConfigByCategoryItem(categoryName, categoryItemName);\n    const {\n      dotColor = color,\n      dotType,\n      fillColor,\n      borderColor,\n      borderType,\n      borderBold,\n      vertexColor,\n      vertexType\n    } = this.getShapeStyle(null, categoryName, categoryItemName);\n    const shape = ShapeFactory.getShape(type, {\n      app: this.app,\n      container: shapeContainer,\n      color,\n      fillColor,\n      borderColor,\n      borderType,\n      borderBold,\n      vertexColor,\n      vertexType,\n      alpha: this.config.fill ? this.config.alpha / 100 : 0,\n      draggable,\n      rotatable,\n      borderWidth: this.config.borderWidth,\n      borderAlpha: this.config.borderAlpha / 100,\n      showVertex: this.config.showVertex,\n      showVertexOrder: this.config.showVertexOrder,\n      vertexSize: this.config.vertexSize,\n      vertexStart: this.config.vertexStart,\n      ...(boundaryCheck && {\n        bounds: imageBounds\n      }),\n      label,\n      ...shapeData,\n      ...toolConfig,\n      ...(type === ShapeType.DOT && {\n        dotRadius: this.config.dotRadius,\n        dotType,\n        color: dotColor\n      }),\n      ...(type === ShapeType.RECTANGLE && {\n        autoSnapEnabled: autoSnap,\n        toleranceAlpha: this.config.toleranceFill ? this.config.toleranceAlpha / 100 : 0\n      }),\n      ...(useCurrent && currentTool === Tool.CENTERLINE_RECTANGLE && {\n        centerLineEnabled: true\n      }),\n      ...(useCurrent && currentTool === Tool.FOUR_DOTS_RECTANGLE && {\n        rectType: RectType.FOUR_DOTS_RECT\n      }),\n      ...(useCurrent && currentTool === Tool.RECOGNITION && {\n        polygonType: PolygonType.RECOGNITION\n      }),\n      ...(useCurrent && (currentToolItem === null || currentToolItem === void 0 ? void 0 : currentToolItem.edges) !== undefined && [Tool.POLYGON, Tool.LINE, Tool.ARROW].includes(currentTool) && {\n        defaultEdges: currentToolItem.edges\n      }),\n      ...(this.rootStore.config.viewMode === ViewMode.DEFAULT ? {\n        labelDom: this.createShapeLabel(camera),\n        scale: (_this$rootStore$frame = this.rootStore.frame.cameraViews[camera || this.rootStore.frame.currentCamera]) === null || _this$rootStore$frame === void 0 ? void 0 : _this$rootStore$frame.viewScale\n      } : {\n        scale: shapeContainer.scale.x // use shape container\n      }),\n      userDataFormatter: data => this.formatPointLabel(data, categoryName, categoryItemName),\n      ...([ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW].includes(type) && {\n        pointStyler: (pIndex, data, s) => this.getPointStyle(pIndex, data, s, categoryName, categoryItemName),\n        edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName)\n      }),\n      ...(type === ShapeType.RECTANGLE && {\n        edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName)\n      })\n    });\n    if (shape === null || shape === void 0 ? void 0 : shape.destroyed) {\n      return shape;\n    }\n    if (order !== undefined) {\n      shape.order = order;\n    } else if (useCurrent) {\n      shape.order = this.rootStore.frame.getNextShapeOrder();\n    }\n    if (shapeData && type === ShapeType.RECTANGLE) {\n      shape.rotation = shapeData.rotation || 0;\n    }\n    shape.userDataMode = activePointAttributesMode;\n    return shape;\n  }\n  /**\n   * add shape listeners\n   * @param shape\n   */\n  addShapeListeners(shape) {\n    shape.on(EventAction.SELECTED, (s, p) => {\n      if (this.cuttingPolygon || this.splittingPolygn) {\n        return; // do not select other shape when cutting or splitting\n      }\n      if (!this.isPredictedShape(s)) {\n        if (this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n          if (this.pendingMergePolygon) {\n            this.mergePolygons(this.pendingMergePolygon, shape.uid);\n            this.pendingMergePolygon = '';\n            return;\n          }\n          if (this.rootStore.relationship.settingRelationship) {\n            const {\n              instanceItem\n            } = this.shapes[s.uid];\n            if (instanceItem === this.rootStore.relationship.fromInstanceItem) {\n              return;\n            }\n            this.rootStore.relationship.add(instanceItem);\n          }\n        }\n        if (this.selectedShapes.indexOf(s) < 0) {\n          this.selectShapes([s]);\n          this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n        }\n      } else {\n        // clear selected shape status\n        this.selectedShapes.forEach(ss => {\n          ss.selected = false;\n        });\n        this.selectedShapes = [];\n        // clear predicted shape selected status\n        Object.values(this.predictedShapes).forEach(predictedShape => {\n          if (predictedShape.shape !== s) {\n            predictedShape.shape.selected = false;\n          }\n        });\n        this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      }\n      if (this.rootStore.review.addMode) {\n        this.rootStore.review.addReview(p);\n      }\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      this.clearPending();\n      if (this.isPredictedShape(s)) {\n        if (this.validateShape(s)) {\n          // predicted shape area meets the requirement\n          this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);\n        } else {\n          // repredict\n          this.predict();\n        }\n      } else if (this.validateShape(s)) {\n        const {\n          instanceItem\n        } = this.shapes[s.uid];\n        const {\n          currentFrame\n        } = this.rootStore.frame;\n        if (this.splittingPolygn === s.uid && s.cuttingOtherPolygon) {\n          this.updatePolygons(data, [s.cuttingOtherPolygon]);\n          this.endPolygonCutting();\n          this.projectShape(s);\n        } else if (this.pointsMoving) {\n          // finish points moving\n          const instanceItems = [];\n          this.selectedShapes.forEach(i => {\n            if (i === s || i.shapeType === ShapeType.POLYGON || i.shapeType === ShapeType.LINE || i.shapeType === ShapeType.ARROW) {\n              const shapeItem = this.shapes[i.uid];\n              if (shapeItem) {\n                if (s !== i) {\n                  i.normalize();\n                }\n                instanceItems.push({\n                  instanceItem: shapeItem.instanceItem,\n                  frameIndex: currentFrame,\n                  shapeType: i.shapeType,\n                  shape: s === i ? data : i.getData()\n                });\n              }\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.pointsMoving = false;\n        } else if (this.shapesMoving) {\n          // finish shapes moving\n          const instanceItems = [];\n          this.selectedShapes.forEach(i => {\n            const shapeItem = this.shapes[i.uid];\n            if (shapeItem) {\n              instanceItems.push({\n                instanceItem: shapeItem.instanceItem,\n                frameIndex: currentFrame,\n                shapeType: i.shapeType,\n                shape: s === i ? data : i.getData()\n              });\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.shapesMoving = false;\n        } else if (!this.deleting) {\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, s.shapeType, data);\n          this.projectShape(s);\n        }\n      }\n    });\n    shape.on(EventAction.REMOVED, s => {\n      if (!this.deleting) {\n        const {\n          instanceItem\n        } = this.shapes[s.uid];\n        if (instanceItem) {\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n        }\n      }\n    });\n    shape.on(EventAction.POINTER_OVER, s => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = s.uid;\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.POINTER_OUT, s => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = '';\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.VERTEX_SELECTED, (s, index) => {\n      if (this.isPredictedShape(s)) {\n        return;\n      }\n      this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n      if (this.selectedShapes.length === 1 && this.selectedShapes[0] === s) {\n        this.selectedPointIndex = index;\n      } else {\n        this.selectedPointIndex = -1;\n      }\n    });\n    shape.on(EventAction.RESIZING, (s, {\n      deltaX,\n      deltaY\n    }) => {\n      if (s.shapeType === ShapeType.POLYGON || s.shapeType === ShapeType.LINE || s.shapeType === ShapeType.ARROW) {\n        const otherSelectedPolygonsAndLines = this.selectedShapes.filter(i => i !== s && (i.shapeType === ShapeType.POLYGON || i.shapeType === ShapeType.LINE || i.shapeType === ShapeType.ARROW));\n        if (otherSelectedPolygonsAndLines.length > 0) {\n          // move points together\n          this.pointsMoving = true;\n          otherSelectedPolygonsAndLines.forEach(i => {\n            i.updateSelectedPointsPosistion(deltaX, deltaY);\n            this.projectShape(i);\n          });\n        }\n      }\n      this.projectShape(s);\n    });\n    shape.on(EventAction.DRAGGING, (s, {\n      deltaX,\n      deltaY\n    }) => {\n      const otherSelectedShapes = this.selectedShapes.filter(i => i !== s);\n      if (otherSelectedShapes.length > 0) {\n        // move shapes together\n        this.shapesMoving = true;\n        otherSelectedShapes.forEach(i => {\n          i.updatePosition(i.position.x + deltaX, i.position.y + deltaY);\n          this.projectShape(i);\n        });\n      }\n      this.projectShape(s);\n    });\n  }\n  /**\n   * reset recognition data\n   */\n  resetRecognition() {\n    this.recognitionStart = false;\n    this.recognitionData = {\n      image: '',\n      clicks: '',\n      threshold: 0.5\n    };\n  }\n  /**\n   * get intersections for shape\n   * @param shape\n   */\n  getIntersectionsForShape(shape) {\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map(i => i.shape).filter(s => s.visible && s.finished);\n    const intersections = shape.findIntersections(shapes);\n    return intersections;\n  }\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA, shapeB) {\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const {\n      instanceItem: instanceItemA\n    } = this.shapes[shapeA.uid];\n    const {\n      instanceItem: instanceItemB\n    } = this.shapes[shapeB.uid];\n    const instanceInfoA = instanceItemA.instance.getBasicInfo();\n    const instanceInfoB = instanceItemB.instance.getBasicInfo();\n\n    // save state\n    const prevInstances = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      });\n    } else {\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()]\n      });\n      prevInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()]\n      });\n    }\n    const storeId = this.rootStore.undo.preserve({\n      instances: prevInstances\n    });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    shapeA.order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    shapeB.order = orderA;\n    const currInstances = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()]\n      });\n    } else {\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()]\n      });\n      currInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()]\n      });\n    }\n    this.rootStore.undo.save(storeId, {\n      instances: currInstances\n    });\n  }\n\n  /**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */\n  moveToTop(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame,\n      getNextShapeOrder\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const maxOrder = Math.max(...cameraShapes.map(s => s.shape.order));\n    if (maxOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_FRONT_MOST'));\n      return;\n    }\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n    // preserve state\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }]\n    });\n    // update order\n    const order = getNextShapeOrder();\n    frameData.order = order;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = order;\n    }\n    // save state\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }]\n    });\n    message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));\n  }\n\n  /**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */\n  moveToBottom(instanceItem) {\n    const {\n      currentCamera,\n      currentFrame,\n      updateNextShapeOrder\n    } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData === null || cameraData === void 0 ? void 0 : cameraData.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const minOrder = Math.min(...cameraShapes.map(s => s.shape.order));\n    if (minOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_BACK_MOST'));\n      return;\n    }\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n\n    // prev instance state map\n    const prevInstanceMap = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }\n    };\n    // update selected shape order\n    frameData.order = 0;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = 0;\n    }\n    // current instance state map\n    const currInstanceMap = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()]\n        }]\n      }\n    };\n    if (minOrder <= 0) {\n      // show move all camera shapes upper\n      for (let i = 0; i < cameraShapes.length; i += 1) {\n        const {\n          shape: s,\n          instanceItem: sInstanceItem\n        } = cameraShapes[i];\n        if (sInstanceItem.id !== instanceItem.id) {\n          // not selected shape\n          const sInstanceInfo = sInstanceItem.instance.getBasicInfo();\n          const sInstanceItemInfo = sInstanceItem.getBasicInfo();\n          const sCameraData = sInstanceItem.cameras[currentCamera];\n          if (!prevInstanceMap[sInstanceInfo.id]) {\n            prevInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: []\n            };\n          }\n          prevInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()]\n          });\n          // update not selected shape's order\n          const order = s.order + 1;\n          sCameraData.frames[currentFrame].order = order;\n          s.order = order;\n          updateNextShapeOrder(order, currentFrame, currentCamera);\n          if (!currInstanceMap[sInstanceInfo.id]) {\n            currInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: []\n            };\n          }\n          currInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()]\n          });\n        }\n      }\n    }\n\n    // save state\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap)\n    }, {\n      instances: Object.values(currInstanceMap)\n    });\n    message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));\n  }\n  mergePolygons(polygonId1, polygonId2) {\n    const {\n      shape: polygon1,\n      instanceItem: instance1\n    } = this.shapes[polygonId1];\n    const {\n      shape: polygon2,\n      instanceItem: instance2\n    } = this.shapes[polygonId2];\n    const mergedData = polygon1.merge(polygon2);\n    if (mergedData.length === 1) {\n      const {\n        currentCamera,\n        currentFrame\n      } = this.rootStore.frame;\n      const {\n        prevState,\n        currState\n      } = this.rootStore.instance.deleteInstanceItemByFrame(instance2, currentFrame);\n      const {\n        prevState: prevStateItem,\n        currState: currStateItem\n      } = instance1.updateShape(currentCamera, currentFrame, this.rootStore.config.autoInterpolation, ShapeType.POLYGON, mergedData[0], this.rootStore.frame.getNextShapeOrder());\n      this.setupShape(instance1);\n      this.selectShapeByInstanceItem(instance1);\n      const basicInfo = instance1.instance.getBasicInfo();\n      this.rootStore.undo.push({\n        instances: [...prevState.instances, ...(prevStateItem ? [{\n          ...basicInfo,\n          children: [prevStateItem]\n        }] : [])],\n        relationships: prevState.relationships\n      }, {\n        instances: [...currState.instances, ...(currStateItem ? [{\n          ...basicInfo,\n          children: [currStateItem]\n        }] : [])],\n        relationships: currState.relationships\n      });\n      message.success(i18n.translate('MERGE_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('MERGE_WITH_HOLE'));\n    }\n  }\n  updatePolygons(currPolygonData, otherPolygonData) {\n    const selectedPolygon = this.selectedShapes[0];\n    const {\n      instanceItem: selectedInstanceItem\n    } = this.shapes[selectedPolygon.uid];\n    const {\n      currentCamera,\n      currentFrame\n    } = this.rootStore.frame;\n    const attributes = selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n    const area = calcShapeArea(ShapeType.POLYGON, currPolygonData);\n    if (area < this.rootStore.config.minArea) {\n      message.warning(i18n.translate('MIN_AREA_ALERT'));\n      this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItem, [currentFrame]);\n      return;\n    }\n    const {\n      prevState: prevStateItem,\n      currState: currStateItem\n    } = selectedInstanceItem.updateShape(currentCamera, currentFrame, this.rootStore.config.autoInterpolation, ShapeType.POLYGON, currPolygonData, this.rootStore.frame.getNextShapeOrder(), attributes);\n    const basicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const instanceState = {\n      [basicInfo.id]: {\n        prev: {\n          ...basicInfo,\n          children: prevStateItem ? [prevStateItem] : []\n        },\n        curr: {\n          ...basicInfo,\n          children: currStateItem ? [currStateItem] : []\n        }\n      }\n    };\n    this.setupShape(selectedInstanceItem);\n    for (let i = 0; i < otherPolygonData.length; i += 1) {\n      if (calcShapeArea(ShapeType.POLYGON, otherPolygonData[i]) < this.rootStore.config.minArea) {\n        return;\n      }\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category, selectedInstanceItem.name);\n      const prevInfo = instanceItem.instance.getBasicInfo();\n      if (instanceItem.instance !== selectedInstanceItem.instance) {\n        instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);\n      }\n      const currInfo = instanceItem.instance.getBasicInfo();\n      if (!instanceState[currInfo.id]) {\n        instanceState[currInfo.id] = {\n          prev: {\n            ...prevInfo,\n            children: []\n          },\n          curr: {\n            ...currInfo,\n            children: []\n          }\n        };\n      }\n      const state = instanceState[currInfo.id];\n      const {\n        prevState,\n        currState\n      } = instanceItem.updateShape(currentCamera, currentFrame, this.rootStore.config.autoInterpolation, ShapeType.POLYGON, otherPolygonData[i], this.rootStore.frame.getNextShapeOrder(), attributes);\n      this.setupShape(instanceItem);\n      if (prevState) {\n        state.prev.children.push(prevState);\n      }\n      if (currState) {\n        state.curr.children.push(currState);\n      }\n    }\n    this.selectShapeByInstanceItem(selectedInstanceItem);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map(i => i.prev).filter(i => i.children.length > 0)\n    }, {\n      instances: Object.values(instanceState).map(i => i.curr)\n    });\n  }\n  startPolygonCutting(cuttingMode) {\n    if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || !this.rootStore.instance.isSingleSelected) {\n      return;\n    }\n    const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n    const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n    if (selectedShape && selectedShape.shapeType === ShapeType.POLYGON) {\n      this.clearPending(); // cancel merge\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      const polygon = selectedShape;\n      polygon.isCutting = true;\n      polygon.cuttingMode = cuttingMode;\n      if (cuttingMode === 'cut') {\n        this.cuttingPolygon = polygon.uid;\n        this.splittingPolygn = '';\n      } else {\n        this.splittingPolygn = polygon.uid;\n        this.cuttingPolygon = '';\n      }\n      this.selectedPointIndex = -1;\n      // update interactive\n      if (!isGridView) {\n        this.updateShapesInteractive(false, [polygon.uid]);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(false, [polygon.uid]);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(false);\n    }\n  }\n  endPolygonCutting() {\n    const polygonId = this.cuttingPolygon || this.splittingPolygn;\n    if (polygonId) {\n      const polygon = this.shapes[polygonId].shape;\n      polygon.isCutting = false;\n      this.cuttingPolygon = '';\n      this.splittingPolygn = '';\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        this.updateShapesInteractive(true);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(true);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(true);\n    }\n  }\n  /**\n   * update bounds for all shapes\n   */\n  updateShapesBounds() {\n    const {\n      boundaryCheck\n    } = this.rootStore.config;\n    const {\n      currentCamera,\n      imageBounds\n    } = this.rootStore.frame;\n    if (boundaryCheck) {\n      this.getShapesForCamera(currentCamera).forEach(({\n        shape\n      }) => {\n        shape.bounds = imageBounds;\n      });\n    }\n  }\n  /**\n    * project all shapes in current frame\n    */\n  async projectShapes() {\n    if (!this.rootStore.frame.camerasMapping.projectEnabled) {\n      return;\n    }\n    const allShapes = Object.values(this.shapes);\n    if (allShapes.length <= 0) {\n      return;\n    }\n    return Promise.all(allShapes.map(({\n      shape,\n      camera\n    }) => this.projectShape(shape, false, camera)));\n  }\n\n  /**\n   * project shape in current frame from base camera to camera\n   * @param shape\n   * @param forceUpdate\n   * @param baseCamera\n   * @param toCameras\n   */\n  async projectShape(shape, forceUpdate = false, baseCamera = this.rootStore.frame.currentCamera, toCameras = this.rootStore.frame.cameraNames) {\n    var _instanceItem$cameras2;\n    const {\n      projectMode\n    } = this.rootStore.config;\n    const shouldUpdate = projectMode === ProjectMode.REAL_TIME || forceUpdate;\n    const {\n      camerasMapping,\n      currentFrame,\n      cameraViews,\n      getImageBoundsForCamera,\n      getFrameRotation\n    } = this.rootStore.frame;\n    if (!shouldUpdate || !camerasMapping.projectEnabled || !this.shapes[shape.uid] || shapeTypesSupportProject.indexOf(shape.shapeType) < 0) {\n      return;\n    }\n    const {\n      instanceItem\n    } = this.shapes[shape.uid];\n    const frameData = (_instanceItem$cameras2 = instanceItem.cameras[baseCamera]) === null || _instanceItem$cameras2 === void 0 ? void 0 : _instanceItem$cameras2.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const {\n      points\n    } = shape;\n    const {\n      width: baseCameraWidth,\n      height: baseCameraHeight\n    } = cameraViews[baseCamera].image;\n    const baseCameraRotation = getFrameRotation(baseCamera, currentFrame);\n    const baseCameraMatrix = getMatrixByRotation(baseCameraRotation, baseCameraWidth, baseCameraHeight);\n    const originPoints = points.map(p => {\n      if (baseCameraRotation !== 0) {\n        const op = calcPositionByMatrix(p, inv(baseCameraMatrix));\n        return [op.x, op.y];\n      }\n      return [p.x, p.y];\n    });\n    const projectedCameras = [];\n    await Promise.all(toCameras.map(async toCamera => {\n      if (toCamera === baseCamera) {\n        // do not project to self camera\n        return;\n      }\n      if (!camerasMapping.isProjectAvailable(currentFrame)) {\n        // show loading if current not available\n        this.projecting = true;\n      }\n      const projectedPoints = await camerasMapping.projectPoints(originPoints, currentFrame, baseCamera, toCamera);\n      const {\n        width: toCameraWidth,\n        height: toCameraHeight\n      } = cameraViews[toCamera].image;\n      const toCameraRotation = getFrameRotation(toCamera, currentFrame);\n      const toCameraMatrix = getMatrixByRotation(toCameraRotation, toCameraWidth, toCameraHeight);\n      const projectedShapePoints = projectedPoints.map(p => {\n        const point = {\n          x: p[0],\n          y: p[1]\n        };\n        if (toCameraRotation !== 0) {\n          const rp = calcPositionByMatrix(point, toCameraMatrix);\n          point.x = rp.x;\n          point.y = rp.y;\n        }\n        return point;\n      });\n      const projectedShapeData = {\n        points: projectedShapePoints\n      };\n      if (projectMode === ProjectMode.REAL_TIME) {\n        var _this$projectedShapes;\n        const existingProjectedShape = (_this$projectedShapes = this.projectedShapes[shape.uid]) === null || _this$projectedShapes === void 0 ? void 0 : _this$projectedShapes[toCamera];\n        if (existingProjectedShape) {\n          // update\n          existingProjectedShape.points = projectedShapePoints;\n          existingProjectedShape.selected = shape.selected;\n        } else {\n          // create\n          const projectedShape = this.createShape(cameraViews[toCamera].shapesLayer, getImageBoundsForCamera(toCamera), instanceItem.categoryItemRef.displayColor, instanceItem.instance.category, instanceItem.name, frameData.shapeType, projectedShapeData, frameData.order, i18n.translate('PROJECTED_SHAPE_LABEL', {\n            values: {\n              label: instanceItem.label\n            }\n          }), toCamera);\n          if (projectedShape.destroyed) {\n            return;\n          }\n          projectedShape.on(EventAction.SELECTED, () => {\n            // when projected shape selected\n            this.rootStore.instance.selectInstanceItem(instanceItem);\n            // fit source shape\n            this.fitProjectShape(shape, baseCamera);\n            // fit projected shapes in other cameras\n            Object.keys(this.projectedShapes[shape.uid]).forEach(c => {\n              if (c !== toCamera) {\n                this.fitProjectShape(this.projectedShapes[shape.uid][c], c);\n              }\n            });\n          });\n          projectedShape.on(EventAction.REMOVED, () => {\n            // when projected removed (not valid anymore)\n            if (this.projectedShapes[shape.uid]) {\n              // delete the projected shape\n              delete this.projectedShapes[shape.uid][toCamera];\n            }\n          });\n\n          // TODO: should set editable by cameras config, current is always not editable\n          projectedShape.editable = false;\n          projectedShape.selected = shape.selected;\n\n          // add to projected shapes map\n          if (!this.projectedShapes[shape.uid]) {\n            this.projectedShapes[shape.uid] = {};\n          }\n          this.projectedShapes[shape.uid][toCamera] = projectedShape;\n          if (shape.selected) {\n            // auto focus when shape selected & first created\n            // this.fitProjectShape(projectedShape, toCamera);\n          }\n        }\n      } else if (projectMode === ProjectMode.MANUAL) {\n        var _instanceItem$cameras3;\n        const toFrameData = (_instanceItem$cameras3 = instanceItem.cameras[toCamera]) === null || _instanceItem$cameras3 === void 0 ? void 0 : _instanceItem$cameras3.frames[currentFrame];\n        projectedShapeData.points.forEach((p, i) => {\n          var _points, _points$i, _points$i2;\n          p.userData = cloneDeep(toFrameData ? (_points = toFrameData.shape.points) === null || _points === void 0 ? void 0 : (_points$i = _points[i]) === null || _points$i === void 0 ? void 0 : _points$i.userData : (_points$i2 = points[i]) === null || _points$i2 === void 0 ? void 0 : _points$i2.userData);\n        });\n        const {\n          prevState,\n          currState\n        } = instanceItem.updateShape(toCamera, currentFrame, this.rootStore.config.autoInterpolation, frameData.shapeType, projectedShapeData, this.rootStore.frame.getNextShapeOrder(currentFrame, toCamera), (toFrameData === null || toFrameData === void 0 ? void 0 : toFrameData.attributes) || frameData.attributes);\n        const basicInfo = instanceItem.instance.getBasicInfo();\n        this.rootStore.undo.push({\n          instances: prevState ? [{\n            ...basicInfo,\n            children: [prevState]\n          }] : []\n        }, {\n          instances: currState ? [{\n            ...basicInfo,\n            children: [currState]\n          }] : []\n        });\n        this.setupShape(instanceItem, toCamera);\n        this.rootStore.instance.selectInstanceItem(instanceItem);\n        projectedCameras.push(toCamera);\n      }\n      this.projecting = false;\n    }));\n    if (projectedCameras.length > 0) {\n      const projectedCamerasLabel = projectedCameras.map(c => `C${this.rootStore.frame.cameraNames.indexOf(c) + 1}`).join(',');\n      message.success(i18n.translate('PROJECT_SUCCESS', {\n        values: {\n          label: instanceItem.label,\n          cameras: projectedCamerasLabel\n        }\n      }));\n    }\n  }\n\n  /**\n   * project selected shapes\n   */\n  projectSelectedShape() {\n    if (this.rootStore.readonly) {\n      return;\n    }\n    this.selectedShapes.forEach(shape => this.projectShape(shape, true));\n  }\n\n  /**\n   * fit projected shape to camera view\n   * @param shape\n   * @param camera\n   */\n  fitProjectShape(shape, camera) {\n    const cameraView = this.rootStore.frame.cameraViews[camera];\n    if (cameraView) {\n      const {\n        left,\n        top,\n        right,\n        bottom\n      } = shape.shapeBounds;\n      cameraView.fitShapeToView({\n        left,\n        top,\n        right,\n        bottom\n      }, 0.5);\n    }\n  }\n  /**\n   * reproject shapes\n   * @param camera\n   */\n  reprojectShapesByCamera(camera = this.rootStore.frame.currentCamera) {\n    Object.keys(this.projectedShapes).forEach(sourceShapeId => {\n      const projectedShape = this.projectedShapes[sourceShapeId][camera];\n      if (projectedShape) {\n        const sourceShape = this.shapes[sourceShapeId];\n        if (sourceShape) {\n          this.projectShape(sourceShape.shape, false, sourceShape.camera, [camera]);\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["makeObservable","observable","action","message","inv","cloneDeep","i18n","getUnderShape","getUpperShape","getSnapshot","parseFields","calcShapeArea","isAttributesPassCondition","getMatrixByRotation","calcPositionByMatrix","imageSegmentation","Tool","ViewMode","LabelItem","ReviewMode","ProjectMode","CAMERA_VIEW_LABELS","ShapeFactory","ShapeType","EventAction","BorderStyle","Rectangle","RectType","Polygon","PolygonType","Line","Dot","Label","precise","Cursor","computeRotatedPosition","shapeTypesSupportProject","LINE","POLYGON","ShapeStore","isDrawing","drawingShape","constructor","rootStore","canvasRef","app","currentLayer","shapes","recognitionStart","recognitionData","image","clicks","threshold","selectedShapes","selectedPointIndex","predictedShapes","projectedShapes","hoveredShapeId","pendingMergePolygon","cuttingPolygon","splittingPolygn","deleting","pointsMoving","shapesMoving","projecting","config","fill","alpha","toleranceFill","toleranceAlpha","borderAlpha","borderWidth","dotRadius","showVertex","showVertexOrder","vertexSize","vertexStart","defaultConfig","clearShapes","Object","values","forEach","shape","destroy","clearPredictedShapes","clearProjectedShapes","cameraShapes","isPredictedShape","s","findIndex","getShapeByInstanceItem","instanceItem","camera","frame","currentCamera","shapeItem","find","i","undefined","getShapesByInstanceItems","instanceItems","shapeItems","filter","indexOf","map","getShapesForCamera","updateShapesInteractive","interactive","ignoreIds","includes","uid","selected","updateShapesUserDataMode","userDataMode","redrawShapesLabel","drawShapeLabel","setupShapes","cameraViews","currentFrame","cameraNames","getImageBoundsForCamera","allShapeOrders","noOrderShapes","cameraName","Set","instance","instances","items","item","cameras","frames","cameraView","imageLoadError","createShape","shapesLayer","categoryItemRef","displayColor","category","name","shapeType","order","label","destroyed","area","minArea","deleteInstanceItemByFrame","readonly","editable","setShapeStyles","addShapeListeners","has","add","push","frameData","keys","getNextShapeOrder","projectShapes","formatPointLabel","data","categoryName","categoryItemName","pointLabelConfig","ontology","getPointLabelConfigFromCategoryItem","fieldsMap","labels","pointLabelItems","key","field","fieldValue","ATTRIBUTE_KEYS","ATTRIBUTE_VALUES","displayValue","options","getOptionLabel","value","option","o","toString","Array","isArray","length","l","join","getPointStyle","pointIndex","pointColor","pointType","categoryItem","getCategoryItem","pointLabelConfigGroups","some","g","attributes","styles","color","parseInt","substr","type","dataKeyLen","hotkeyMap","affected","attrKeys","getToolPointsStylesByCategoryItem","pointsColor","pointsType","getEdgeStyle","startPointIndex","edgeColor","edgeType","edgeBold","bold","getToolEdgesStylesByCategoryItem","edgesColor","edgesType","edgesBold","getShapeStyle","dotColor","dotType","fillColor","borderColor","borderType","borderBold","vertexColor","vertexType","labelConfig","labelConfigGroups","getToolFillByCategoryItem","pointsStyles","edgesStyles","getToolStylesByCategoryItem","frameIndex","_instanceItem$cameras","DOT","originColors","RECTANGLE","ARROW","validateShape","endPolygonCutting","deleteFramesFromInstanceItem","deleteShape","warning","translate","selectShapes","projectedShape","projectCamera","selectShapeByInstanceItem","autoFocus","viewMode","DEFAULT","currentCameraView","left","top","right","bottom","getLocalBounds","bbox","Math","min","max","fitShapeToView","instancesSet","updateShapesInInstance","from","predict","hideOrShowOthers","unselectShape","addMode","cancelShapeWorking","selectInstance","setSelectedPoints","shapePointsMap","count","shapeId","setSelectedShapes","shapeIds","selectInstanceItem","addShape","point","shapeContainer","imageBounds","finishCallback","initialized","selectedCategoryItem","selectedCategory","className","on","FINISHED","off","REMOVED","RECOGNITION","continuousMode","setAddMode","addShapeToCurrentInstanceItem","_","cursor","bounds","controls","JSON","stringify","requestRecognition","create","currentOptions","getCurrentInstanceItem","prevState","currState","autoInterpolation","getData","isOCRTool","isFormulaTool","basicInfo","getBasicInfo","undo","children","autoOpenAttributesModal","projectShape","addShapeToInstanceItem","cameraData","shapeInfo","predictedItem","predictShape","updateFrameShapeForInstanceItem","setupShape","setCamera","addShapesToInstance","updateFrameShapeForInstanceItems","_cameraViews$camera","existingShape","existingShapeId","relationship","setupConnectionsForInstanceItem","autoTracking","reviewMode","REVIEW","GRID","isMultiSelected","selectedInstances","selectedInstanceItems","selectedInstance","predictedShape","borderStyle","DASHED","LABELING","delete","pointsDeletedShapes","deleted","deleteSelectedPoints","deleteFramesFromInstanceItems","index","splice","deleteShapeByInstanceItem","setRecognitionThreshold","loading","polygon","setRecognizedPolygon","e","error","finishRecognition","finishCreate","setPointsUserDataByHotkey","hotkey","hotkeyItems","pointHotkeyMap","selectedPoints","getSelectedPoints","pointsData","userData","setPointsUserData","setPointUserData","moveFront","toTop","selectedShape","moveToTop","intersections","getIntersectionsForShape","upperShape","exchangeShapeOrder","success","moveBack","toBottom","moveToBottom","underShape","clearPending","mergePolygon","isAnyModalOpened","cancel","selectedPolygon","intersectPolygonIds","findIntersectPolygons","mergePolygons","warn","info","subtractPolygon","intersectPolygons","subtractedData","subtract","updatePolygons","slice","d","updateConfig","updateShapesFill","grid","updateShapesAlpha","updateShapesToleranceFill","updateShapesToleranceAlpha","updateShapesBorderAlpha","updateShapesBorderWidth","updateDotsRadius","updateShowVertex","updateShowVertexOrder","updateVertexSize","fillAlpha","resetConfig","togglePolygonCut","startPolygonCutting","rotateShapesByCanvas","rotation","center","offsetX","offsetY","prevInstanceMap","currInstanceMap","points","p","rp","x","y","rect","width","height","centerLineEnabled","c","r","rotatedCenter","PI","ELLIPSE","ellipse","halfWidth","halfHeight","CIRCLE","circle","dot","rotatedPoint","CUBOID","TWO_SIDES_CUBOID","cuboid","x1","y1","w1","h1","x2","y2","w2","h2","rotatedCenter1","rotatedCenter2","fw","fh","bw","bh","setData","front","back","LSHAPE","lshape","w","h","sx1","sy1","sx2","sy2","abs","cols","rows","gridCenter","c0","r0","updateShape","id","reprojectShapesByCamera","hideOthers","hideAll","selectedInstanceIds","shouldHide","labelDom","document","getElementById","visible","style","visibility","hideOrShowRelationships","review","hideOrShowReviews","fitProjectShapesForSelectedShapes","fitProjectShape","init","payload","is_fill","fill_opacity","Number","isNaN","border_opacity","border_width","dot_size","show_vertex","show_vertex_order","vertex_size","vertex_start","updateShapesEditable","createShapeLabel","shapeLabelsContainer","shapeLabel","transPosition","toLocal","addToContainer","hexColor","shapeData","_this$rootStore$frame","boundaryCheck","draggable","rotatable","autoSnap","activePointAttributesMode","currentToolItem","currentTool","currentShapeType","getToolConfigByCategoryItem","useCurrent","toolConfig","getShape","container","autoSnapEnabled","CENTERLINE_RECTANGLE","FOUR_DOTS_RECTANGLE","rectType","FOUR_DOTS_RECT","polygonType","edges","defaultEdges","scale","viewScale","userDataFormatter","pointStyler","pIndex","edgeStyler","SELECTED","settingRelationship","fromInstanceItem","ss","updateSelectedInstanceItem","addReview","CHANGED","cuttingOtherPolygon","normalize","POINTER_OVER","onShapeHovered","POINTER_OUT","VERTEX_SELECTED","RESIZING","deltaX","deltaY","otherSelectedPolygonsAndLines","updateSelectedPointsPosistion","DRAGGING","otherSelectedShapes","updatePosition","position","resetRecognition","finished","findIntersections","shapeA","shapeB","orderA","orderB","instanceItemA","instanceItemB","instanceInfoA","instanceInfoB","prevInstances","toJSON","storeId","preserve","currInstances","save","maxOrder","instanceInfo","instanceItemInfo","updateNextShapeOrder","minOrder","sInstanceItem","sInstanceInfo","sInstanceItemInfo","sCameraData","polygonId1","polygonId2","polygon1","instance1","polygon2","instance2","mergedData","merge","prevStateItem","currStateItem","relationships","currPolygonData","otherPolygonData","selectedInstanceItem","instanceState","prev","curr","prevInfo","setAttributes","currInfo","state","cuttingMode","isSingleSelected","isGridView","getCurrentSelectedShape","isCutting","updateConnectionsInteractive","polygonId","updateShapesBounds","camerasMapping","projectEnabled","allShapes","Promise","all","forceUpdate","baseCamera","toCameras","_instanceItem$cameras2","projectMode","shouldUpdate","REAL_TIME","getFrameRotation","baseCameraWidth","baseCameraHeight","baseCameraRotation","baseCameraMatrix","originPoints","op","projectedCameras","toCamera","isProjectAvailable","projectedPoints","projectPoints","toCameraWidth","toCameraHeight","toCameraRotation","toCameraMatrix","projectedShapePoints","projectedShapeData","_this$projectedShapes","existingProjectedShape","MANUAL","_instanceItem$cameras3","toFrameData","_points","_points$i","_points$i2","projectedCamerasLabel","projectSelectedShape","shapeBounds","sourceShapeId","sourceShape"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/store/ShapeStore.ts"],"sourcesContent":["import { Application, Container, Point } from 'pixi.js';\nimport { makeObservable, observable, action } from 'mobx';\nimport { message } from 'antd';\nimport { inv } from 'mathjs';\nimport { cloneDeep } from 'lodash';\nimport { FieldValue } from '@appen/easy-form/es/types';\nimport RootStore from './RootStore';\nimport Instance from '../model/Instance';\nimport InstanceItem from '../model/InstanceItem';\nimport FrameData from '../model/FrameData';\nimport i18n from '../locales';\nimport { getUnderShape, getUpperShape, getSnapshot, parseFields, calcShapeArea, isAttributesPassCondition, getMatrixByRotation, calcPositionByMatrix } from '../utils';\nimport { imageSegmentation } from '../request';\nimport { Payload, Tool, ViewMode, LabelItem, Instance as IInstance, ReviewMode, ProjectMode } from '../types';\nimport { CAMERA_VIEW_LABELS } from '../constants';\nimport ShapeFactory from '../../common/shapes/ShapeFactory';\nimport { ShapeType, ShapeData, ShapeVertexType, ShapeLineType } from '../../common/shapes/types';\nimport Shape, { EventAction, UserDataMode, BorderStyle } from '../../common/shapes/Shape';\nimport Rectangle, { RectType, RectangleData } from '../../common/shapes/Rectangle';\nimport Polygon, { PolygonData, PolygonType } from '../../common/shapes/Polygon';\nimport Line, { LineData } from '../../common/shapes/Line';\nimport Dot from '../../common/shapes/Dot';\nimport Ellipse from '../../common/shapes/Ellipse';\nimport Circle from '../../common/shapes/Circle';\nimport Cuboid from '../../common/shapes/Cuboid';\nimport LShape from '../../common/shapes/LShape';\nimport Grid from '../../common/shapes/Grid';\nimport Arrow from '../../common/shapes/Arrow';\nimport Canvas from '../../common/shapes/canvas/Canvas';\nimport Label from '../../common/shapes/label/Label';\nimport { precise } from '../../common/shapes/utils';\nimport Cursor from '../../common/Cursor';\nimport { computeRotatedPosition } from '../../../utils/math';\n\nconst shapeTypesSupportProject = [\n  ShapeType.LINE,\n  ShapeType.POLYGON,\n];\ntype ShapeSupportProject = Line | Polygon;\ntype ShapeDataSupportProject = LineData | PolygonData;\n\n/**\n * store for shapes in current camera & current frame\n * @class\n */\nexport default class ShapeStore {\n  /**\n   * root store\n   */\n  rootStore: typeof RootStore;\n\n  /**\n   * canvas reference\n   */\n  canvasRef: Canvas | null = null;\n\n  /**\n   * app\n   */\n  app?: Application;\n\n  /**\n   * current layer\n   */\n  currentLayer?: Container;\n\n  /**\n   * shapes in current frame\n   */\n  shapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      camera: string;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * currently drawing shape\n   */\n  drawingShape: Shape<ShapeData> | null = null;\n\n  /**\n   * if recognition prepared, start to do recognition\n   */\n  recognitionStart = false;\n\n  /**\n   * data used for recognition\n   */\n  recognitionData = { image: '', clicks: '', threshold: 0.5 };\n\n  /**\n   * currently selected shapes\n   */\n  selectedShapes: Shape<ShapeData>[] = [];\n\n  /**\n   * currently selected shape vertex index for polygon & line\n   */\n  selectedPointIndex = -1;\n\n  /**\n   * predicted shapes\n   */\n  predictedShapes: {\n    [shapeId: string]: {\n      shape: Shape<ShapeData>;\n      instanceItem: InstanceItem;\n    }\n  } = {};\n\n  /**\n   * projected shapes\n   */\n  projectedShapes: {\n    [baseShapeId: string]: {\n      [projectToCamera: string]: Shape<ShapeData>;\n    }\n  } = {};\n\n  /**\n   * hovered shape id\n   */\n  hoveredShapeId = '';\n\n  /**\n   * waiting merge polygon\n   */\n  pendingMergePolygon = '';\n\n  /**\n   * polygon id in cut mode\n   */\n  cuttingPolygon = '';\n\n  /**\n   * polygon id in split mode\n   */\n  splittingPolygn = '';\n\n  /**\n   * is deleting\n   */\n  deleting = false;\n\n  /**\n   * is points moving\n   */\n  pointsMoving = false;\n\n  /**\n   * is shapes moving\n   */\n  shapesMoving = false;\n\n  /**\n   * is shape projecting\n   */\n  projecting = false;\n\n  /**\n   * shape display config\n   */\n  config = {\n    fill: true,\n    alpha: 20,\n    toleranceFill: false,\n    toleranceAlpha: 20,\n    borderAlpha: 100,\n    borderWidth: 1,\n    dotRadius: 5,\n    showVertex: false,\n    showVertexOrder: false,\n    vertexSize: 4,\n    vertexStart: 1,\n  };\n\n  /**\n   * default config from payload\n   */\n  defaultConfig = this.config;\n\n  /**\n   * is drawing shape\n   * @getter\n   */\n  get isDrawing() {\n    return this.drawingShape !== null;\n  }\n\n  constructor(rootStore: typeof RootStore) {\n    makeObservable(this, {\n      shapes: observable,\n      recognitionStart: observable,\n      recognitionData: observable,\n      selectedShapes: observable,\n      selectedPointIndex: observable,\n      cuttingPolygon: observable,\n      splittingPolygn: observable,\n      projecting: observable,\n      config: observable,\n      clearShapes: action,\n      setupShapes: action,\n      selectShapes: action,\n      unselectShape: action,\n      addShape: action,\n      setupShape: action,\n      deleteShape: action,\n      setRecognitionThreshold: action,\n      updateConfig: action,\n      startPolygonCutting: action,\n      endPolygonCutting: action,\n    });\n\n    this.rootStore = rootStore;\n  }\n\n  /**\n   * init from paylod\n   * @param payload\n   */\n  init(payload: Payload) {\n    this.config.fill = payload.is_fill !== 'false' && payload.is_fill !== false;\n    if (payload.fill_opacity !== undefined && payload.fill_opacity !== '') {\n      const alpha = Number(payload.fill_opacity);\n      if (!Number.isNaN(alpha) && alpha >= 0 && alpha <= 1) {\n        this.config.alpha = alpha * 100;\n      }\n    }\n    if (payload.border_opacity !== undefined && payload.border_opacity !== '') {\n      const borderAlpha = Number(payload.border_opacity);\n      if (!Number.isNaN(borderAlpha) && borderAlpha >= 0 && borderAlpha <= 1) {\n        this.config.borderAlpha = borderAlpha * 100;\n      }\n    }\n    if (payload.border_width !== undefined && payload.border_width !== '') {\n      const borderWidth = Number(payload.border_width);\n      if (!Number.isNaN(borderWidth) && borderWidth >= 1 && borderWidth <= 10) {\n        this.config.borderWidth = borderWidth;\n      }\n    }\n    if (payload.dot_size !== undefined && payload.dot_size !== '') {\n      const dotRadius = Number(payload.dot_size);\n      if (!Number.isNaN(dotRadius) && dotRadius >= 1 && dotRadius <= 10) {\n        this.config.dotRadius = dotRadius;\n      }\n    }\n    this.config.showVertex = payload.show_vertex === 'true' || payload.show_vertex === true;\n    this.config.showVertexOrder = payload.show_vertex_order === 'true' || payload.show_vertex_order === true;\n    if (payload.vertex_size !== undefined && payload.vertex_size !== '') {\n      const vertexSize = Number(payload.vertex_size);\n      if (!Number.isNaN(vertexSize) && vertexSize >= 0) {\n        this.config.vertexSize = vertexSize;\n      }\n    }\n    if (payload.vertex_start !== undefined && payload.vertex_start !== '') {\n      const vertexStart = Number(payload.vertex_start);\n      if (!Number.isNaN(vertexStart)) {\n        this.config.vertexStart = vertexStart;\n      }\n    }\n    this.defaultConfig = { ...this.config }; // save default settings\n\n    this.app = payload.app;\n  }\n\n  /**\n   * clear shapes\n   */\n  clearShapes = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.shapes = {};\n    this.drawingShape = null;\n    this.selectedShapes = [];\n    this.clearPredictedShapes();\n    this.clearProjectedShapes();\n    this.selectedPointIndex = -1;\n  };\n\n  /**\n   * clear predicted shapes\n   */\n  clearPredictedShapes = () => {\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.destroy();\n    });\n    this.predictedShapes = {};\n  };\n\n  /**\n   * clear projected shapes\n   */\n  clearProjectedShapes = () => {\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.destroy();\n      });\n    });\n    this.projectedShapes = {};\n  };\n\n  /**\n   * is predicted shape\n   * @param s\n   */\n  isPredictedShape = (s: Shape<ShapeData>) => Object.values(this.predictedShapes).findIndex(({ shape }) => shape === s) >= 0;\n\n  /**\n   * get shape by instance item\n   * @param instanceItem\n   */\n  getShapeByInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const shapeItem = Object.values(this.shapes).find((i) => i.camera === camera && i.instanceItem === instanceItem);\n    if (shapeItem) {\n      return shapeItem.shape;\n    }\n    return undefined;\n  };\n\n  /**\n   * get shapes by instance items\n   * @param instanceItems\n   * @param camera\n   */\n  getShapesByInstanceItems = (instanceItems: InstanceItem[], camera = this.rootStore.frame.currentCamera) => {\n    const shapeItems = Object.values(this.shapes).filter((i) => i.camera === camera && instanceItems.indexOf(i.instanceItem) >= 0);\n    return shapeItems.map((i) => i.shape);\n  };\n\n  /**\n   * get shapes for one camera\n   * @param camera\n   */\n  getShapesForCamera = (camera: string) => Object.values(this.shapes).filter((s) => s.camera === camera);\n\n  /**\n   * update shapes interactive\n   * @param interactive\n   * @param ignoreIds\n   */\n  updateShapesInteractive = (interactive: boolean, ignoreIds?: string[]) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (ignoreIds && ignoreIds.includes(shape.uid)) {\n        return;\n      }\n      shape.interactive = interactive;\n      if (interactive && this.selectedShapes.indexOf(shape) >= 0) {\n        shape.selected = true;\n      }\n    });\n  };\n\n  /**\n   * update shapes editable\n   * @param editable\n   */\n  updateShapesEditable(editable: boolean) {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.editable = editable;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.editable = editable;\n    });\n  }\n\n  /**\n   * update shapes user data mode\n   * @param userDataMode\n   */\n  updateShapesUserDataMode = (userDataMode: UserDataMode) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.userDataMode = userDataMode;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.userDataMode = userDataMode;\n    });\n  };\n\n  /**\n   * redraw shapes label\n   */\n  redrawShapesLabel = () => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.drawShapeLabel();\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.drawShapeLabel();\n      });\n    });\n  };\n\n  /**\n   * setup shapes for current frame\n   */\n  setupShapes = () => {\n    this.clearShapes();\n    const { cameraViews, currentFrame, cameraNames, getImageBoundsForCamera } = this.rootStore.frame;\n    const allShapeOrders: {\n      [camera: string]: Set<number>;\n    } = {};\n    const noOrderShapes: {\n      [camera: string]: { frameData: FrameData, shape: Shape<ShapeData> }[];\n    } = {};\n    cameraNames.forEach((cameraName) => {\n      allShapeOrders[cameraName] = new Set();\n      noOrderShapes[cameraName] = [];\n    });\n    Object.values(this.rootStore.instance.instances).forEach((instance) => {\n      Object.values(instance.items).forEach((item) => {\n        Object.values(item.cameras).forEach(({ camera }) => {\n          const { frames } = item.cameras[camera];\n          const cameraView = cameraViews[camera];\n          if (frames[currentFrame] && cameraView && !cameraView.imageLoadError) {\n            const shape = this.createShape(\n              cameraView.shapesLayer,\n              getImageBoundsForCamera(camera),\n              item.categoryItemRef.displayColor,\n              instance.category,\n              item.name,\n              frames[currentFrame].shapeType,\n              frames[currentFrame].shape,\n              frames[currentFrame].order,\n              item.label,\n              camera,\n            );\n            if (shape.destroyed || shape.area < this.rootStore.config.minArea) {\n              // delete instance item\n              this.rootStore.instance.deleteInstanceItemByFrame(item, currentFrame, camera);\n              return;\n            }\n            if (this.rootStore.readonly) {\n              shape.editable = false;\n            }\n            this.setShapeStyles(shape, item);\n            this.addShapeListeners(shape);\n            this.shapes[shape.uid] = {\n              shape,\n              camera,\n              instanceItem: item,\n            };\n\n            const { order } = frames[currentFrame];\n            if (order !== undefined && !allShapeOrders[camera].has(order)) {\n              // update next shape order\n              shape.order = order;\n              allShapeOrders[camera].add(order);\n            } else {\n              // add to temp array\n              noOrderShapes[camera].push({ frameData: frames[currentFrame], shape });\n            }\n          }\n        });\n      });\n    });\n    Object.keys(noOrderShapes).forEach((cameraName) => {\n      noOrderShapes[cameraName].forEach(({ frameData, shape }) => {\n        // new order\n        shape.order = this.rootStore.frame.getNextShapeOrder(currentFrame, cameraName);\n        frameData.order = shape.order;\n      });\n    });\n\n    this.projectShapes();\n  };\n\n  /**\n   * format point label\n   * @param data\n   * @param categoryName\n   * @param categoryItemName\n   */\n  formatPointLabel = (data: any, categoryName: string, categoryItemName: string) => {\n    const pointLabelConfig = this.rootStore.ontology.getPointLabelConfigFromCategoryItem(categoryName, categoryItemName);\n    const fieldsMap = parseFields(pointLabelConfig);\n    const labels: string[][] = [];\n    const { pointLabelItems } = this.rootStore.config;\n    Object.keys(data).forEach((key) => {\n      const label = [];\n      const field = fieldsMap[key];\n      const fieldValue = data[key];\n      if (pointLabelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n        label.push(field?.label || field?.name || `${key}`);\n      }\n      if (pointLabelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n        let displayValue = '';\n        if (fieldValue !== undefined) {\n          if (field?.options) {\n            const getOptionLabel = (value: FieldValue) => {\n              const option = field.options!.find((o) => o.value === value);\n              return (option && option.label) ? option.label : value.toString();\n            };\n            displayValue = Array.isArray(fieldValue) ? fieldValue.map(getOptionLabel).toString() : getOptionLabel(fieldValue);\n          } else {\n            displayValue = fieldValue.toString();\n          }\n        }\n        label.push(displayValue);\n      }\n      if (label.length > 0) {\n        labels.push(label);\n      }\n    });\n    return labels.map((l) => l.join(': ')).join('; ');\n  };\n\n  /**\n   * get point style\n   * @param pointIndex\n   * @param data\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getPointStyle = (pointIndex: number, data: any, shape: Shape<ShapeData>, categoryName: string, categoryItemName: string) => {\n    let pointColor: number | undefined;\n    let pointType: ShapeVertexType | undefined;\n    // by point attributes\n    if (data) {\n      const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n      const { pointLabelConfig, pointLabelConfigGroups } = categoryItem || {};\n      if (pointLabelConfig && pointLabelConfigGroups) {\n        // from point label config settings\n        pointLabelConfigGroups.some((g) => {\n          const { attributes, ...styles } = g;\n          if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n            // match group attributes\n            if (pointColor === undefined) {\n              const color = styles.pointColor;\n              if (color) {\n                pointColor = parseInt(color.substr(1), 16);\n              }\n            }\n            if (pointType === undefined) {\n              const type = styles.pointType;\n              if (type) {\n                pointType = type as ShapeVertexType;\n              }\n            }\n          }\n          return pointColor !== undefined && pointType !== undefined;\n        });\n      } else if (pointColor === undefined) {\n        // from hotkeys config\n        const dataKeyLen = Object.keys(data).length;\n        Object.values(this.rootStore.config.hotkeyMap).some((items) => items.some(({ affected, type, color, attributes }) => {\n          if (affected === 'point' && color !== undefined) {\n            const attrKeys = Object.keys(attributes);\n            if (isAttributesPassCondition(data, attributes) && (type !== 'overwrite' || attrKeys.length === dataKeyLen)) {\n              pointColor = parseInt(color.substr(1), 16);\n              return true;\n            }\n          }\n          return false;\n        }));\n      }\n    }\n\n    // by point index\n    const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n    if (styles) {\n      // has style config\n      if (pointColor === undefined) {\n        // color not affected by attributes, use point index settings\n        const color = (styles.pointsColor || [])[pointIndex];\n        if (color) {\n          pointColor = parseInt(color.substr(1), 16);\n        }\n      }\n      if (pointType === undefined) {\n        // type not affected by attributes, use point index settings\n        const type = (styles.pointsType || [])[pointIndex];\n        if (type) {\n          pointType = type as ShapeVertexType;\n        }\n      }\n    }\n\n    return {\n      color: pointColor,\n      type: pointType,\n    };\n  };\n\n  /**\n   * get edge style\n   * @param startPointIndex\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getEdgeStyle = (startPointIndex: number, data: any, shape: Shape<ShapeData>, categoryName: string, categoryItemName: string) => {\n    let edgeColor: number | undefined;\n    let edgeType: ShapeLineType | undefined;\n    let edgeBold: boolean | undefined;\n\n    // by point labelConfig\n    if (data) {\n      const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n      const { pointLabelConfig, pointLabelConfigGroups } = categoryItem || {};\n      if (pointLabelConfig && pointLabelConfigGroups) {\n        // from point label config settings\n        pointLabelConfigGroups.some((g) => {\n          const { attributes, ...styles } = g;\n\n          if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n            // match group attributes\n            if (edgeColor === undefined) {\n              const color = styles.edgeColor;\n              if (color) {\n                edgeColor = parseInt(color.substr(1), 16);\n              }\n            }\n            if (edgeType === undefined) {\n              const type = styles.edgeType;\n              if (type) {\n                edgeType = type as ShapeLineType;\n              }\n            }\n\n            if (edgeBold === undefined) {\n              const bold = styles.edgeBold;\n              if (bold !== undefined) {\n                edgeBold = bold;\n              }\n            }\n          }\n          return edgeColor !== undefined && edgeType !== undefined && edgeBold !== undefined;\n        });\n      }\n    }\n\n    if (edgeColor === undefined || edgeType === undefined || edgeBold === undefined) {\n      // by point index\n      const styles = this.rootStore.ontology.getToolEdgesStylesByCategoryItem(categoryName, categoryItemName);\n      if (styles) {\n        // has style config\n        if (edgeColor === undefined) {\n          // color not affected by attributes, use point index settings\n          const color = (styles.edgesColor || [])[startPointIndex];\n          if (color) {\n            edgeColor = parseInt(color.substr(1), 16);\n          }\n        }\n        if (edgeType === undefined) {\n          // type not affected by attributes, use point index settings\n          const type = (styles.edgesType || [])[startPointIndex];\n          if (type) {\n            edgeType = type as ShapeLineType;\n          }\n        }\n        if (edgeBold === undefined) {\n          // bold not affected by attributes, use point index settings\n          const bold = (styles.edgesBold || [])[startPointIndex];\n          if (bold !== undefined) {\n            edgeBold = bold;\n          }\n        }\n      }\n    }\n\n    return {\n      color: edgeColor,\n      type: edgeType,\n      bold: edgeBold,\n    };\n  };\n\n  /**\n   * get shape style (for fill color & dot style & color)\n   * @param data\n   * @param categoryName\n   * @param categoryItemName\n   */\n  getShapeStyle = (data: any, categoryName: string, categoryItemName: string) => {\n    let dotColor: number | undefined;\n    let dotType: ShapeVertexType | undefined;\n    let fillColor: number | undefined;\n    let borderColor: number | undefined;\n    let borderType: ShapeLineType | undefined;\n    let borderBold: boolean | undefined;\n    let vertexColor: number | undefined;\n    let vertexType: ShapeVertexType | undefined;\n\n    const categoryItem = this.rootStore.ontology.getCategoryItem(categoryName, categoryItemName);\n    if (data) {\n      const { labelConfig, labelConfigGroups } = categoryItem || {};\n      if (labelConfig && labelConfigGroups) {\n        // has label config settings\n        labelConfigGroups.some((g) => {\n          const { attributes, ...styles } = g;\n          if (attributes && styles && isAttributesPassCondition(data, attributes)) {\n            // match group attributes\n            if (dotColor === undefined) {\n              const color = styles.pointColor;\n              if (color) {\n                dotColor = parseInt(color.substr(1), 16);\n              }\n            }\n            if (dotType === undefined) {\n              const type = styles.pointType;\n              if (type) {\n                dotType = type as ShapeVertexType;\n              }\n            }\n            if (fillColor === undefined && styles.fillColor) {\n              fillColor = parseInt(styles.fillColor.substr(1), 16);\n            }\n            if (borderColor === undefined && styles.edgeColor) {\n              borderColor = parseInt(styles.edgeColor.substr(1), 16);\n            }\n            if (borderType === undefined && styles.edgeType) {\n              borderType = styles.edgeType as ShapeLineType;\n            }\n            if (borderBold === undefined && styles.edgeBold !== undefined) {\n              borderBold = styles.edgeBold;\n            }\n            if (vertexColor === undefined && styles.pointColor) {\n              vertexColor = parseInt(styles.pointColor.substr(1), 16);\n            }\n            if (vertexType === undefined && styles.pointType) {\n              vertexType = styles.pointType as ShapeVertexType;\n            }\n          }\n\n          return (\n            dotColor !== undefined &&\n            dotType !== undefined &&\n            fillColor !== undefined &&\n            borderColor !== undefined &&\n            borderType !== undefined &&\n            borderBold !== undefined &&\n            vertexColor !== undefined &&\n            vertexType !== undefined\n          );\n        });\n      }\n    }\n\n    const styles = this.rootStore.ontology.getToolPointsStylesByCategoryItem(categoryName, categoryItemName);\n    if (styles) {\n      if (dotColor === undefined) {\n        // color not affected by attributes, use shape settings\n        const color = styles.pointColor;\n        if (color) {\n          dotColor = parseInt(color.substr(1), 16);\n        }\n      }\n      if (dotType === undefined) {\n        // type not affected by attributes, use shape settings\n        const type = styles.pointType;\n        if (type) {\n          dotType = type as ShapeVertexType;\n        }\n      }\n    }\n\n    if (fillColor === undefined) {\n      // fill color not affected by attributes, use shape settings\n      const fill = this.rootStore.ontology.getToolFillByCategoryItem(categoryName, categoryItemName);\n      if (fill) {\n        fillColor = parseInt(fill.substr(1), 16);\n      }\n    }\n\n    if (\n      borderColor === undefined || borderType === undefined || borderBold === undefined ||\n      vertexColor === undefined || vertexType === undefined\n    ) {\n      const { pointsStyles, edgesStyles } = this.rootStore.ontology.getToolStylesByCategoryItem(categoryName, categoryItemName);\n      if (borderColor === undefined && edgesStyles?.edgeColor) {\n        borderColor = parseInt(edgesStyles.edgeColor.substr(1), 16);\n      }\n\n      if (borderType === undefined && edgesStyles?.edgeType) {\n        borderType = edgesStyles.edgeType as ShapeLineType;\n      }\n\n      if (borderBold === undefined && edgesStyles?.edgeBold !== undefined) {\n        borderBold = edgesStyles.edgeBold;\n      }\n\n      if (vertexColor === undefined && pointsStyles?.pointColor) {\n        vertexColor = parseInt(pointsStyles.pointColor.substr(1), 16);\n      }\n\n      if (vertexType === undefined && pointsStyles?.pointType) {\n        vertexType = pointsStyles.pointType as ShapeVertexType;\n      }\n    }\n    const displayColor = categoryItem?.displayColor ? parseInt(categoryItem.displayColor.substr(1), 16) : undefined;\n    return {\n      dotColor,\n      dotType,\n      fillColor: fillColor || displayColor,\n      borderColor: borderColor || displayColor,\n      borderType,\n      borderBold,\n      vertexColor: vertexColor || displayColor,\n      vertexType,\n    };\n  };\n\n  /**\n   * set shape styles\n   * @param shape\n   * @param instanceItem\n   * @param camera\n   * @param frameIndex\n   */\n  setShapeStyles = (\n    shape: Shape<ShapeData>,\n    instanceItem: InstanceItem,\n    camera = this.rootStore.frame.currentCamera,\n    frameIndex = this.rootStore.frame.currentFrame,\n  ) => {\n    const { attributes } = instanceItem.cameras[camera]?.frames[frameIndex] || {};\n    const { dotColor, dotType, fillColor, borderColor, borderType, borderBold, vertexColor, vertexType } = this.getShapeStyle(attributes, instanceItem.instance.category, instanceItem.name);\n    if (shape.shapeType === ShapeType.DOT) {\n      if (dotColor !== undefined) {\n        shape.color = dotColor;\n        shape.originColors.color = dotColor;\n      }\n      if (dotType) {\n        (shape as Dot).dotType = dotType;\n      }\n    }\n    if ((shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.RECTANGLE) && fillColor !== undefined) {\n      shape.fillColor = fillColor;\n    }\n\n    if (\n      shape.shapeType === ShapeType.POLYGON ||\n      shape.shapeType === ShapeType.LINE ||\n      shape.shapeType === ShapeType.ARROW ||\n      shape.shapeType === ShapeType.RECTANGLE\n    ) {\n      if (borderColor !== undefined) {\n        shape.borderColor = borderColor;\n        shape.originColors.borderColor = borderColor;\n      }\n\n      if (borderType !== undefined) {\n        shape.borderType = borderType;\n      }\n\n      if (borderBold !== undefined) {\n        shape.borderBold = borderBold;\n      }\n    }\n    if (shape.shapeType === ShapeType.POLYGON || shape.shapeType === ShapeType.LINE || shape.shapeType === ShapeType.ARROW) {\n      if (vertexColor !== undefined) {\n        shape.vertexColor = vertexColor;\n      }\n\n      if (vertexType !== undefined) {\n        shape.vertexType = vertexType;\n      }\n    }\n  };\n\n  /**\n   * create shape label dom\n   */\n  createShapeLabel(camera = this.rootStore.frame.currentCamera) {\n    const shapeLabelsContainer = document.getElementById(`${CAMERA_VIEW_LABELS}-${camera}`);\n    if (shapeLabelsContainer) {\n      const shapeLabel = new Label({\n        className: 'shape-label',\n        transPosition: (p) => {\n          const cameraView = this.rootStore.frame.cameraViews[camera];\n          if (cameraView) {\n            return cameraView.toLocal(p);\n          }\n          return p;\n        },\n      });\n      shapeLabel.addToContainer(shapeLabelsContainer);\n      return shapeLabel;\n    }\n    return undefined;\n  }\n\n  /**\n   * create shape instance\n   * @param shapeContainer\n   * @param imageBounds\n   * @param hexColor\n   * @param categoryName\n   * @param categoryItemName\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param label\n   */\n  createShape(\n    shapeContainer: Container,\n    imageBounds: { left: number; top: number; right: number; bottom: number; },\n    hexColor: string,\n    categoryName: string,\n    categoryItemName: string,\n    shapeType?: ShapeType,\n    shapeData?: ShapeData,\n    order?: number,\n    label?: string,\n    camera?: string,\n  ) {\n    const { boundaryCheck, draggable, rotatable, autoSnap, activePointAttributesMode } = this.rootStore.config;\n    const { currentToolItem, currentTool, currentShapeType, getToolConfigByCategoryItem } = this.rootStore.ontology;\n    const useCurrent = shapeType === undefined;\n    const color = parseInt(hexColor.substr(1), 16);\n    const type = shapeType || currentShapeType;\n    const toolConfig = getToolConfigByCategoryItem(categoryName, categoryItemName);\n    const { dotColor = color, dotType, fillColor, borderColor, borderType, borderBold, vertexColor, vertexType } = this.getShapeStyle(null, categoryName, categoryItemName);\n    const shape = ShapeFactory.getShape(type, {\n      app: this.app!,\n      container: shapeContainer,\n      color,\n      fillColor,\n      borderColor,\n      borderType,\n      borderBold,\n      vertexColor,\n      vertexType,\n      alpha: this.config.fill ? this.config.alpha / 100 : 0,\n      draggable,\n      rotatable,\n      borderWidth: this.config.borderWidth,\n      borderAlpha: this.config.borderAlpha / 100,\n      showVertex: this.config.showVertex,\n      showVertexOrder: this.config.showVertexOrder,\n      vertexSize: this.config.vertexSize,\n      vertexStart: this.config.vertexStart,\n      ...boundaryCheck && { bounds: imageBounds },\n      label,\n      ...shapeData,\n      ...toolConfig,\n      ...type === ShapeType.DOT && {\n        dotRadius: this.config.dotRadius,\n        dotType,\n        color: dotColor,\n      },\n      ...type === ShapeType.RECTANGLE && {\n        autoSnapEnabled: autoSnap,\n        toleranceAlpha: this.config.toleranceFill ? this.config.toleranceAlpha / 100 : 0,\n      },\n      ...(useCurrent && currentTool === Tool.CENTERLINE_RECTANGLE && {\n        centerLineEnabled: true,\n      }),\n      ...(useCurrent && currentTool === Tool.FOUR_DOTS_RECTANGLE && {\n        rectType: RectType.FOUR_DOTS_RECT,\n      }),\n      ...(useCurrent && currentTool === Tool.RECOGNITION && {\n        polygonType: PolygonType.RECOGNITION,\n      }),\n      ...(useCurrent && currentToolItem?.edges !== undefined && [Tool.POLYGON, Tool.LINE, Tool.ARROW].includes(currentTool) && {\n        defaultEdges: currentToolItem.edges,\n      }),\n      ...this.rootStore.config.viewMode === ViewMode.DEFAULT ? {\n        labelDom: this.createShapeLabel(camera),\n        scale: this.rootStore.frame.cameraViews[camera || this.rootStore.frame.currentCamera]?.viewScale,\n      } : {\n        scale: shapeContainer.scale.x, // use shape container\n      },\n      userDataFormatter: (data) => this.formatPointLabel(data, categoryName, categoryItemName),\n      ...[ShapeType.POLYGON, ShapeType.LINE, ShapeType.ARROW].includes(type) && {\n        pointStyler: (pIndex, data, s) => this.getPointStyle(pIndex, data, s, categoryName, categoryItemName),\n        edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName),\n      },\n      ...type === ShapeType.RECTANGLE && {\n        edgeStyler: (pIndex, data, s) => this.getEdgeStyle(pIndex, data, s, categoryName, categoryItemName),\n      },\n    });\n    if (shape?.destroyed) {\n      return shape;\n    }\n    if (order !== undefined) {\n      shape!.order = order;\n    } else if (useCurrent) {\n      shape!.order = this.rootStore.frame.getNextShapeOrder();\n    }\n    if (shapeData && type === ShapeType.RECTANGLE) {\n      shape!.rotation = (shapeData as RectangleData).rotation || 0;\n    }\n    shape!.userDataMode = activePointAttributesMode as unknown as UserDataMode;\n    return shape!;\n  }\n\n  /**\n   * validate shape\n   * @param shape\n   */\n  validateShape = (shape: Shape<ShapeData>) => {\n    if (shape.area < this.rootStore.config.minArea) {\n      if (shape.uid === this.cuttingPolygon) {\n        this.endPolygonCutting();\n      }\n      const { instanceItem } = this.shapes[shape.uid] || {};\n      if (instanceItem) {\n        // related to instance, also update data\n        this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n      } else {\n        // has not been related to any instance, just delete the shape\n        this.deleteShape(shape);\n      }\n      message.warning(i18n.translate('MIN_AREA_ALERT'));\n      return false;\n    }\n    return true;\n  };\n\n  /**\n   * add shape listeners\n   * @param shape\n   */\n  addShapeListeners(shape: Shape<ShapeData>) {\n    shape.on(EventAction.SELECTED, (s, p) => {\n      if (this.cuttingPolygon || this.splittingPolygn) {\n        return; // do not select other shape when cutting or splitting\n      }\n      if (!this.isPredictedShape(s)) {\n        if (this.selectedShapes.length === 1 && s.uid !== this.selectedShapes[0].uid) {\n          if (this.pendingMergePolygon) {\n            this.mergePolygons(this.pendingMergePolygon, shape.uid);\n            this.pendingMergePolygon = '';\n            return;\n          }\n          if (this.rootStore.relationship.settingRelationship) {\n            const { instanceItem } = this.shapes[s.uid];\n            if (instanceItem === this.rootStore.relationship.fromInstanceItem) {\n              return;\n            }\n            this.rootStore.relationship.add(instanceItem);\n          }\n        }\n        if (this.selectedShapes.indexOf(s) < 0) {\n          this.selectShapes([s]);\n          this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n        }\n      } else {\n        // clear selected shape status\n        this.selectedShapes.forEach((ss) => {\n          ss.selected = false;\n        });\n        this.selectedShapes = [];\n        // clear predicted shape selected status\n        Object.values(this.predictedShapes).forEach((predictedShape) => {\n          if (predictedShape.shape !== s) {\n            predictedShape.shape.selected = false;\n          }\n        });\n        this.rootStore.instance.updateSelectedInstanceItem(this.predictedShapes[s.uid].instanceItem);\n      }\n      if (this.rootStore.review.addMode) {\n        this.rootStore.review.addReview(p);\n      }\n    });\n    shape.on(EventAction.CHANGED, (s, data) => {\n      this.clearPending();\n      if (this.isPredictedShape(s)) {\n        if (this.validateShape(s)) { // predicted shape area meets the requirement\n          this.addShapeToInstanceItem(this.predictedShapes[s.uid].instanceItem);\n        } else { // repredict\n          this.predict();\n        }\n      } else if (this.validateShape(s)) {\n        const { instanceItem } = this.shapes[s.uid];\n        const { currentFrame } = this.rootStore.frame;\n        if (this.splittingPolygn === s.uid && (s as Polygon).cuttingOtherPolygon) {\n          this.updatePolygons(data, [(s as Polygon).cuttingOtherPolygon!]);\n          this.endPolygonCutting();\n          this.projectShape(s);\n        } else if (this.pointsMoving) {\n          // finish points moving\n          const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData }[] = [];\n          this.selectedShapes.forEach((i) => {\n            if (i === s || i.shapeType === ShapeType.POLYGON || i.shapeType === ShapeType.LINE || i.shapeType === ShapeType.ARROW) {\n              const shapeItem = this.shapes[i.uid];\n              if (shapeItem) {\n                if (s !== i) {\n                  (i as Polygon | Line).normalize();\n                }\n                instanceItems.push({\n                  instanceItem: shapeItem.instanceItem,\n                  frameIndex: currentFrame,\n                  shapeType: i.shapeType,\n                  shape: s === i ? data : i.getData(),\n                });\n              }\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.pointsMoving = false;\n        } else if (this.shapesMoving) {\n          // finish shapes moving\n          const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape: ShapeData }[] = [];\n          this.selectedShapes.forEach((i) => {\n            const shapeItem = this.shapes[i.uid];\n            if (shapeItem) {\n              instanceItems.push({\n                instanceItem: shapeItem.instanceItem,\n                frameIndex: currentFrame,\n                shapeType: i.shapeType,\n                shape: s === i ? data : i.getData(),\n              });\n            }\n          });\n          this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n          this.shapesMoving = false;\n        } else if (!this.deleting) {\n          this.rootStore.instance.updateFrameShapeForInstanceItem(instanceItem, currentFrame, s.shapeType, data);\n          this.projectShape(s);\n        }\n      }\n    });\n    shape.on(EventAction.REMOVED, (s) => {\n      if (!this.deleting) {\n        const { instanceItem } = this.shapes[s.uid];\n        if (instanceItem) {\n          this.rootStore.instance.deleteFramesFromInstanceItem(instanceItem, [this.rootStore.frame.currentFrame]);\n        }\n      }\n    });\n    shape.on(EventAction.POINTER_OVER, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = s.uid;\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.POINTER_OUT, (s) => {\n      if (!this.isPredictedShape(s)) {\n        this.hoveredShapeId = '';\n        this.rootStore.relationship.onShapeHovered(this.hoveredShapeId);\n      }\n    });\n    shape.on(EventAction.VERTEX_SELECTED, (s, index) => {\n      if (this.isPredictedShape(s)) {\n        return;\n      }\n      this.rootStore.instance.selectInstanceItem(this.shapes[s.uid].instanceItem);\n      if (this.selectedShapes.length === 1 && this.selectedShapes[0] === s) {\n        this.selectedPointIndex = index;\n      } else {\n        this.selectedPointIndex = -1;\n      }\n    });\n    shape.on(EventAction.RESIZING, (s, { deltaX, deltaY }) => {\n      if (s.shapeType === ShapeType.POLYGON || s.shapeType === ShapeType.LINE || s.shapeType === ShapeType.ARROW) {\n        const otherSelectedPolygonsAndLines = this.selectedShapes.filter((i) => i !== s && (i.shapeType === ShapeType.POLYGON || i.shapeType === ShapeType.LINE || i.shapeType === ShapeType.ARROW));\n        if (otherSelectedPolygonsAndLines.length > 0) {\n          // move points together\n          this.pointsMoving = true;\n          otherSelectedPolygonsAndLines.forEach((i) => {\n            (i as Polygon | Line).updateSelectedPointsPosistion(deltaX, deltaY);\n            this.projectShape(i);\n          });\n        }\n      }\n      this.projectShape(s);\n    });\n    shape.on(EventAction.DRAGGING, (s, { deltaX, deltaY }) => {\n      const otherSelectedShapes = this.selectedShapes.filter((i) => i !== s);\n      if (otherSelectedShapes.length > 0) {\n        // move shapes together\n        this.shapesMoving = true;\n        otherSelectedShapes.forEach((i) => {\n          i.updatePosition(i.position.x + deltaX, i.position.y + deltaY);\n          this.projectShape(i);\n        });\n      }\n      this.projectShape(s);\n    });\n  }\n\n  /**\n   * select shapes\n   * @param shapes\n   */\n  selectShapes = (shapes: Shape<ShapeData>[]) => {\n    if (this.selectedPointIndex >= 0) {\n      // has point selected\n      if (this.selectedShapes.length === 1 && shapes.length === 1 && this.selectedShapes[0] === shapes[0]) {\n        // same shape, do not unselect\n        return;\n      }\n      this.selectedPointIndex = -1;\n    }\n    this.selectedShapes.forEach((shape) => {\n      if (shapes.indexOf(shape) < 0) { // not selected any more\n        shape.selected = false;\n        if (this.projectedShapes[shape.uid]) {\n          Object.values(this.projectedShapes[shape.uid]).forEach((projectedShape) => {\n            projectedShape.selected = false;\n          });\n        }\n      }\n    });\n    this.selectedShapes = [...shapes];\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = true;\n      const projectedShapes = this.projectedShapes[shape.uid];\n      if (projectedShapes) {\n        Object.keys(projectedShapes).forEach((projectCamera) => {\n          const projectedShape = projectedShapes[projectCamera];\n          projectedShape.selected = true;\n          // this.fitProjectShape(projectedShape, projectCamera);\n        });\n      }\n    });\n  };\n\n  /**\n   * select shape by instance item\n   * @param instanceItem\n   * @param autoFocus\n   */\n  selectShapeByInstanceItem = (instanceItem: InstanceItem | InstanceItem[] | null, autoFocus = false) => {\n    const instanceItems = Array.isArray(instanceItem) ? instanceItem : [...instanceItem ? [instanceItem] : []];\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      const shapes = this.getShapesByInstanceItems(instanceItems);\n      this.selectShapes(shapes);\n      const { currentCameraView } = this.rootStore.frame;\n      if (autoFocus && shapes.length > 0 && currentCameraView) {\n        let { left, top, right, bottom } = shapes[0].instance.getLocalBounds();\n        for (let i = 1; i < shapes.length; i += 1) {\n          const bbox = shapes[i].instance.getLocalBounds();\n          left = Math.min(bbox.left, left);\n          top = Math.min(bbox.top, top);\n          right = Math.max(bbox.right, right);\n          bottom = Math.max(bbox.bottom, bottom);\n        }\n        currentCameraView.fitShapeToView({ left, top, right, bottom }, 0.5);\n      }\n    }\n    const instancesSet = new Set(instanceItems.map((i) => i.instance));\n    this.updateShapesInInstance(Array.from(instancesSet));\n    this.predict();\n    this.hideOrShowOthers();\n  };\n\n  /**\n   * click to unselect shape\n   */\n  unselectShape = () => {\n    if (this.rootStore.config.addMode || this.cuttingPolygon || this.splittingPolygn) {\n      return;\n    }\n    this.rootStore.cancelShapeWorking();\n    this.selectedShapes.forEach((shape) => {\n      shape.selected = false;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.selected = false;\n      });\n    });\n    this.selectedShapes = [];\n    this.rootStore.instance.selectInstance(null);\n  };\n\n  /**\n   * set selected shape points\n   * @param shapePointsMap\n   */\n  setSelectedPoints = (shapePointsMap: { [shapeId: string]: number[] }) => {\n    let count = 0;\n    Object.keys(shapePointsMap).forEach((shapeId) => {\n      const { shape } = this.shapes[shapeId];\n      (shape as Polygon | Line).setSelectedPoints(shapePointsMap[shapeId]);\n      count += shapePointsMap[shapeId].length;\n    });\n    if (count === 1) {\n      // point can be selected\n      this.selectedPointIndex = Object.values(shapePointsMap)[0][0];\n    }\n  };\n\n  /**\n   * set selected shapes\n   * @param shapeIds\n   */\n  setSelectedShapes = (shapeIds: string[]) => {\n    const shapeItems = Object.values(this.shapes).filter(({ shape }) => shapeIds.indexOf(shape.uid) >= 0);\n    const instanceItems = shapeItems.map(({ instanceItem }) => instanceItem);\n    this.rootStore.instance.selectInstanceItem(instanceItems);\n  };\n\n  /**\n   * update shape border color\n   * @param instance\n   */\n  updateShapesInInstance = (instance?: Instance | Instance[] | null) => {\n    const instances = Array.isArray(instance) ? instance : [...instance ? [instance] : []];\n    Object.values(this.shapes).forEach(({ shape, instanceItem }) => {\n      if (instances.indexOf(instanceItem.instance) >= 0) {\n        shape.borderColor = 0xFFFF00;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = 0xFFFF00;\n        }\n      } else {\n        shape.borderColor = shape.originColors.borderColor;\n        if (shape.shapeType === ShapeType.DOT) {\n          shape.color = shape.originColors.color;\n        }\n      }\n    });\n  };\n\n  /**\n   * click to draw a shape\n   * @param point\n   * @param shapeContainer\n   * @param imageBounds\n   * @param finishCallback\n   */\n  addShape = (\n    point: Point,\n    shapeContainer?: Container,\n    imageBounds?: { left: number; top: number; right: number; bottom: number },\n    finishCallback?: () => void,\n  ) => {\n    if (this.rootStore.initialized && this.rootStore.config.addMode && !this.drawingShape) {\n      this.drawingShape = this.createShape(\n        shapeContainer || this.currentLayer!,\n        imageBounds || this.rootStore.frame.imageBounds,\n        this.rootStore.ontology.selectedCategoryItem.displayColor,\n        this.rootStore.ontology.selectedCategory.className,\n        this.rootStore.ontology.selectedCategoryItem.name,\n      );\n\n      // add listeners\n      this.drawingShape.on(EventAction.FINISHED, (shape) => {\n        // remove listeners after creating\n        shape.off(EventAction.FINISHED);\n        shape.off(EventAction.REMOVED);\n        shape.off(EventAction.RECOGNITION);\n\n        this.drawingShape = null;\n        if (!this.rootStore.config.continuousMode) {\n          this.rootStore.config.setAddMode(false);\n        }\n        if (this.validateShape(shape)) {\n          // add shape to instance item\n          this.addShapeToCurrentInstanceItem(shape);\n        }\n        if (this.rootStore.config.continuousMode) {\n          shape.interactive = false;\n        }\n        // finish creating\n        if (finishCallback) {\n          finishCallback();\n        }\n      });\n      this.drawingShape.on(EventAction.REMOVED, () => {\n        this.drawingShape = null;\n        if (this.recognitionStart && !this.rootStore.config.continuousMode) {\n          // if recognition shape removed, should set add mode to false\n          this.rootStore.config.setAddMode(false);\n        }\n      });\n      this.drawingShape.on(EventAction.RECOGNITION, async (_, data) => {\n        // do recognition\n        this.recognitionStart = true;\n        this.rootStore.config.cursor = Cursor.DEFAULT; // use default cursor, not crosshair\n        // request\n        const { frames, currentFrame } = this.rootStore.frame;\n        const { bounds, controls } = data;\n        this.recognitionData.image = await getSnapshot(frames[currentFrame], bounds);\n        this.recognitionData.clicks = JSON.stringify(controls);\n        this.requestRecognition();\n      });\n      // start create\n      this.drawingShape.create(point, this.rootStore.ontology.currentOptions);\n      return this.drawingShape;\n    }\n    return null;\n  };\n\n  /**\n   * add shape to current instance item\n   * @param shape\n   */\n  addShapeToCurrentInstanceItem = (shape: Shape<ShapeData>) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const instanceItem = this.rootStore.instance.getCurrentInstanceItem();\n    const { prevState, currState } = instanceItem.addShape(\n      currentCamera,\n      currentFrame,\n      this.rootStore.config.autoInterpolation,\n      shape.shapeType,\n      shape.getData(),\n      shape.order,\n      this.rootStore.ontology.isOCRTool,\n      this.rootStore.ontology.isFormulaTool,\n    );\n    const basicInfo = instanceItem.instance.getBasicInfo();\n    this.rootStore.undo.push({\n      instances: prevState ? [{ ...basicInfo, children: [prevState] }] : [],\n    }, {\n      instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n    });\n\n    // update shape instance\n    if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n      shape.label = instanceItem.label;\n      this.setShapeStyles(shape, instanceItem);\n      this.addShapeListeners(shape);\n      this.shapes[shape.uid] = { shape, camera: currentCamera, instanceItem };\n    }\n\n    // select\n    this.rootStore.instance.selectInstanceItem(instanceItem);\n    this.rootStore.instance.autoOpenAttributesModal();\n    // project\n    this.projectShape(shape);\n  };\n\n  /**\n   * add predicted shape to instance item\n   * @param instanceItem\n   * @param camera\n   */\n  addShapeToInstanceItem = (instanceItem: InstanceItem, camera = this.rootStore.frame.currentCamera) => {\n    const { currentCamera, currentFrame, cameraViews, getImageBoundsForCamera } = this.rootStore.frame;\n    const currentCameraView = cameraViews[camera];\n    const imageBounds = getImageBoundsForCamera(camera);\n    if (currentCameraView?.imageLoadError) {\n      return;\n    }\n\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData?.frames[currentFrame]) {\n      return;\n    }\n\n    let shapeInfo;\n    const predictedItem = Object.values(this.predictedShapes).find((i) => i.instanceItem === instanceItem);\n    if (camera === currentCamera && predictedItem) {\n      // predicted shape in current camera exists, use it\n      const { shape } = predictedItem;\n      shapeInfo = {\n        shapeType: shape.shapeType,\n        shape: shape.getData(),\n      };\n      // remove predicted shape\n      shape.destroy();\n      delete this.predictedShapes[shape.uid];\n    } else {\n      shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n    }\n\n    if (shapeInfo) {\n      const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n      if (area < this.rootStore.config.minArea) {\n        message.warning(i18n.translate('MIN_AREA_ALERT'));\n        return;\n      }\n      // add to model\n      this.rootStore.instance.updateFrameShapeForInstanceItem(\n        instanceItem,\n        currentFrame,\n        shapeInfo.shapeType,\n        shapeInfo.shape,\n        this.rootStore.frame.getNextShapeOrder(currentFrame, camera),\n        camera,\n      );\n      // create shape\n      this.setupShape(instanceItem, camera, currentCameraView.shapesLayer, imageBounds);\n      // set camera\n      if (currentCamera !== camera) {\n        this.rootStore.frame.setCamera(camera);\n      }\n      // select\n      this.rootStore.instance.selectInstanceItem(instanceItem);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  };\n\n  /**\n   * add predicted shapes to instance\n   * @param instance\n   * @param camera\n   */\n  addShapesToInstance = (instance: Instance, camera = this.rootStore.frame.currentCamera) => {\n    const currentCameraView = this.rootStore.frame.cameraViews[camera];\n    if (currentCameraView?.imageLoadError) {\n      return;\n    }\n\n    const { currentCamera, currentFrame, getImageBoundsForCamera, getNextShapeOrder } = this.rootStore.frame;\n    const imageBounds = getImageBoundsForCamera(camera);\n    const instanceItems: {\n      instanceItem: InstanceItem,\n      frameIndex: number,\n      shapeType: ShapeType,\n      shape: ShapeData,\n      order: number,\n      camera: string,\n    }[] = [];\n    Object.values(instance.items).forEach((instanceItem) => {\n      const cameraData = instanceItem.cameras[camera];\n      if (!cameraData || !cameraData.frames[currentFrame]) {\n        // not exist in current frame\n        let shapeInfo;\n        const predictedItem = Object.values(this.predictedShapes).find((i) => i.instanceItem === instanceItem);\n        if (camera === currentCamera && predictedItem) {\n          // predicted shape in current camera exists, use it\n          const { shape } = predictedItem;\n          shapeInfo = {\n            shapeType: shape.shapeType,\n            shape: shape.getData(),\n          };\n          // remove predicted shape\n          shape.destroy();\n          delete this.predictedShapes[shape.uid];\n        } else {\n          shapeInfo = instanceItem.predictShape(camera, currentFrame, imageBounds, true);\n        }\n\n        if (shapeInfo) {\n          const area = calcShapeArea(shapeInfo.shapeType, shapeInfo.shape);\n          if (area < this.rootStore.config.minArea) {\n            return;\n          }\n          instanceItems.push({\n            instanceItem,\n            frameIndex: currentFrame,\n            order: getNextShapeOrder(currentFrame, camera),\n            camera,\n            ...shapeInfo,\n          });\n        }\n      }\n    });\n\n    if (instanceItems.length > 0) {\n      // update model\n      this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      // setup shapes\n      instanceItems.forEach(({ instanceItem }) => {\n        this.setupShape(instanceItem, camera, currentCameraView.shapesLayer, imageBounds);\n      });\n      // select\n      this.rootStore.instance.selectInstanceItem(null);\n      this.rootStore.instance.selectInstance(instance);\n      this.rootStore.instance.autoOpenAttributesModal();\n    }\n  };\n\n  /**\n   * setup shape in current camera & current frame\n   * @param instanceItem\n   * @param shapeContainer\n   * @param imageBounds\n   */\n  setupShape = (\n    instanceItem: InstanceItem,\n    camera = this.rootStore.frame.currentCamera,\n    shapeContainer?: Container,\n    imageBounds?: { left: number; top: number; right: number; bottom: number; },\n  ) => {\n    const { cameraViews, currentFrame } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[camera];\n    if (cameraData) {\n      const frameData = cameraData.frames[currentFrame];\n      if (frameData) {\n        // remove shape if already exists\n        const existingShape = this.getShapeByInstanceItem(instanceItem, camera);\n        const existingShapeId = existingShape?.uid;\n        if (existingShape) {\n          this.deleteShape(existingShape);\n        }\n        // add shape\n        if (!cameraViews[camera]?.imageLoadError) {\n          const shape = this.createShape(\n            shapeContainer || cameraViews[camera].shapesLayer,\n            imageBounds || this.rootStore.frame.getImageBoundsForCamera(camera),\n            instanceItem.categoryItemRef.displayColor,\n            instanceItem.instance.category,\n            instanceItem.name,\n            frameData.shapeType,\n            frameData.shape,\n            frameData.order !== undefined ? frameData.order : this.rootStore.frame.getNextShapeOrder(),\n            instanceItem.label,\n            camera,\n          );\n          if (shape.destroyed) {\n            // delete instance item\n            this.rootStore.instance.deleteInstanceItemByFrame(instanceItem, currentFrame, camera);\n            return;\n          }\n          this.setShapeStyles(shape, instanceItem, camera);\n          this.addShapeListeners(shape);\n          this.shapes[shape.uid] = { shape, camera, instanceItem };\n          this.rootStore.relationship.setupConnectionsForInstanceItem(instanceItem);\n          if (this.pendingMergePolygon === existingShapeId) {\n            this.pendingMergePolygon = shape.uid;\n          }\n          if (this.cuttingPolygon === existingShapeId) {\n            this.cuttingPolygon = shape.uid;\n          }\n          if (this.splittingPolygn === existingShapeId) {\n            this.splittingPolygn = shape.uid;\n          }\n          this.projectShape(shape, false, camera);\n        }\n      }\n    }\n  };\n\n  /**\n   * predict in current camera & current frame\n   * @param instance\n   */\n  predict = () => {\n    this.clearPredictedShapes();\n\n    if (\n      !this.rootStore.config.autoTracking ||\n      (this.rootStore.readonly && this.rootStore.config.reviewMode !== ReviewMode.REVIEW) ||\n      this.rootStore.config.viewMode === ViewMode.GRID\n    ) {\n      return;\n    }\n\n    const { isMultiSelected, selectedInstances, selectedInstanceItems } = this.rootStore.instance;\n    if (isMultiSelected) {\n      return;\n    }\n\n    if (selectedInstances.length === 1) {\n      const { currentCamera, currentFrame, currentCameraView, imageBounds } = this.rootStore.frame;\n      if (currentCameraView?.imageLoadError) {\n        return;\n      }\n\n      const selectedInstance = selectedInstances[0];\n      Object.values(selectedInstance.items).forEach((item) => {\n        const shapeInfo = item.predictShape(currentCamera, currentFrame, imageBounds);\n        if (shapeInfo) {\n          // create predict shape\n          const predictedShape = this.createShape(\n            this.currentLayer!,\n            imageBounds,\n            item.categoryItemRef.displayColor,\n            selectedInstance.category,\n            item.name,\n            shapeInfo.shapeType,\n            shapeInfo.shape,\n            9999, // predicted shape always on the top\n            item.label,\n          );\n          predictedShape.borderStyle = BorderStyle.DASHED;\n          predictedShape.borderColor = 0xFFFF00;\n          if (predictedShape.shapeType === ShapeType.DOT) {\n            predictedShape.color = 0xFFFF00;\n          }\n          predictedShape.editable = this.rootStore.config.reviewMode === ReviewMode.LABELING;\n          if (selectedInstanceItems.indexOf(item) >= 0) {\n            predictedShape.selected = true;\n          }\n          // add listeners\n          this.addShapeListeners(predictedShape);\n\n          this.predictedShapes[predictedShape.uid] = {\n            shape: predictedShape,\n            instanceItem: item,\n          };\n        }\n      });\n    }\n  };\n\n  /**\n   * delete selected shape point or instance\n   */\n  delete = () => {\n    if (this.selectedShapes.length > 0) {\n      this.deleting = true;\n      this.selectedPointIndex = -1;\n\n      const pointsDeletedShapes: Shape<ShapeData>[] = [];\n      this.selectedShapes.forEach((shape) => {\n        const deleted = shape.deleteSelectedPoints();\n        if (deleted) {\n          pointsDeletedShapes.push(shape);\n        }\n      });\n\n      const { currentFrame } = this.rootStore.frame;\n      if (pointsDeletedShapes.length > 0) {\n        // has points deleted shapes\n        const instanceItems: { instanceItem: InstanceItem, frameIndex: number, shapeType: ShapeType, shape?: ShapeData }[] = [];\n        pointsDeletedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            instanceItems.push({\n              instanceItem: shapeItem.instanceItem,\n              frameIndex: currentFrame,\n              shapeType: shape.shapeType,\n              shape: shape.destroyed ? undefined : shape.getData(),\n            });\n            if (shape.destroyed) {\n              this.deleteShape(shape);\n            } else {\n              this.projectShape(shape);\n            }\n          }\n        });\n        this.rootStore.instance.updateFrameShapeForInstanceItems(instanceItems);\n      } else {\n        // should delete shapes\n        const instanceItems: { instanceItem: InstanceItem, frames: number[] }[] = [];\n        this.selectedShapes.forEach((shape) => {\n          const shapeItem = this.shapes[shape.uid];\n          if (shapeItem) {\n            const { instanceItem } = shapeItem;\n            instanceItems.push({ instanceItem, frames: [currentFrame] });\n          }\n        });\n        this.rootStore.instance.deleteFramesFromInstanceItems(instanceItems);\n        this.predict();\n      }\n    }\n    this.deleting = false;\n  };\n\n  /**\n   * delete shape instance\n   * @param shape\n   */\n  deleteShape = (shape: Shape<ShapeData>) => {\n    const index = this.selectedShapes.indexOf(shape);\n    if (index >= 0) {\n      this.selectedShapes.splice(index, 1);\n    }\n    shape.destroy();\n    delete this.shapes[shape.uid];\n\n    if (this.projectedShapes[shape.uid]) {\n      Object.values(this.projectedShapes[shape.uid]).forEach((s) => {\n        s.destroy();\n      });\n      delete this.projectedShapes[shape.uid];\n    }\n  };\n\n  /**\n   * delete shape by instance item\n   * @param instanceItem\n   */\n  deleteShapeByInstanceItem = (instanceItem: InstanceItem) => {\n    const shape = this.getShapeByInstanceItem(instanceItem);\n    if (shape) {\n      this.deleteShape(shape);\n    }\n  };\n\n  /**\n   * reset recognition data\n   */\n  resetRecognition() {\n    this.recognitionStart = false;\n    this.recognitionData = { image: '', clicks: '', threshold: 0.5 };\n  }\n\n  /**\n   * set threshold for recognition\n   * @param threshold\n   */\n  setRecognitionThreshold = (threshold: number) => {\n    this.recognitionData.threshold = threshold;\n  };\n\n  /**\n   * request recognition\n   */\n  requestRecognition = async () => {\n    if (!this.recognitionStart) {\n      return;\n    }\n    const { image, clicks, threshold } = this.recognitionData;\n    if (image && clicks) {\n      this.rootStore.frame.loading = true;\n      try {\n        const polygon = await imageSegmentation(image, clicks, threshold);\n        // set to drawing shape\n        (this.drawingShape as Polygon).setRecognizedPolygon(polygon);\n      } catch (e) {\n        message.error(i18n.translate('RECOGNITION_FAIL'));\n      }\n      this.rootStore.frame.loading = false;\n    }\n  };\n\n  /**\n   * finish recognition\n   */\n  finishRecognition = () => {\n    if (this.recognitionStart) {\n      (this.drawingShape as Polygon).finishCreate();\n    }\n  };\n\n  /**\n   * set points user data for shape by hotkey\n   * @param shape\n   * @param hotkey\n   */\n  setPointsUserDataByHotkey = (shape: Shape<ShapeData>, hotkey: string) => {\n    if (shape instanceof Polygon || shape instanceof Line) {\n      const hotkeyItems = this.rootStore.config.pointHotkeyMap[hotkey] || [];\n      const selectedPoints = shape.getSelectedPoints();\n      if (hotkeyItems.length > 0 && selectedPoints.length > 0) {\n        const pointsData: { index: number; userData: any }[] = [];\n        selectedPoints.forEach(({ index, point }) => {\n          let userData = { ...point.userData };\n          hotkeyItems.forEach(({ type, attributes }) => {\n            userData = type === 'overwrite' ? { ...attributes } : { ...userData, ...attributes };\n          });\n          pointsData.push({ index, userData });\n        });\n        shape.setPointsUserData(pointsData);\n      }\n    }\n  };\n\n  /**\n   * set points user data for shape\n   * @param shape\n   * @param pointIndex\n   * @param userData\n   */\n  setPointUserData = (shape: Shape<ShapeData>, pointIndex: number, userData: any) => {\n    if (shape instanceof Polygon || shape instanceof Line) {\n      const pointsData = [{ index: pointIndex, userData }];\n      shape.setPointsUserData(pointsData);\n    }\n  };\n\n  /**\n   * get intersections for shape\n   * @param shape\n   */\n  getIntersectionsForShape(shape: Shape<ShapeData>) {\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape).filter((s) => s.visible && s.finished);\n    const intersections = shape.findIntersections(shapes);\n    return intersections;\n  }\n\n  /**\n   * exchange two shapes order\n   * @param shapeA\n   * @param shapeB\n   */\n  exchangeShapeOrder(shapeA: Shape<ShapeData>, shapeB: Shape<ShapeData>) {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n\n    const orderA = shapeA.order;\n    const orderB = shapeB.order;\n    const { instanceItem: instanceItemA } = this.shapes[shapeA.uid];\n    const { instanceItem: instanceItemB } = this.shapes[shapeB.uid];\n    const instanceInfoA = instanceItemA.instance.getBasicInfo();\n    const instanceInfoB = instanceItemB.instance.getBasicInfo();\n\n    // save state\n    const prevInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      prevInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      prevInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    const storeId = this.rootStore.undo.preserve({ instances: prevInstances });\n\n    // update a\n    instanceItemA.cameras[currentCamera].frames[currentFrame].order = orderB;\n    shapeA.order = orderB;\n    // update b\n    instanceItemB.cameras[currentCamera].frames[currentFrame].order = orderA;\n    shapeB.order = orderA;\n\n    const currInstances: IInstance[] = [];\n    if (instanceItemA.instance.id === instanceItemB.instance.id) {\n      // same instance\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON(), instanceItemB.toJSON()],\n      });\n    } else {\n      currInstances.push({\n        ...instanceInfoA,\n        children: [instanceItemA.toJSON()],\n      });\n      currInstances.push({\n        ...instanceInfoB,\n        children: [instanceItemB.toJSON()],\n      });\n    }\n    this.rootStore.undo.save(storeId, { instances: currInstances });\n  }\n\n  /**\n   * move shape to the top of all shapes\n   * @param instanceItem\n   */\n  moveToTop(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, getNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const maxOrder = Math.max(...cameraShapes.map((s) => s.shape.order));\n    if (maxOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_FRONT_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n    // preserve state\n    const storeId = this.rootStore.undo.preserve({\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n    // update order\n    const order = getNextShapeOrder();\n    frameData.order = order;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = order;\n    }\n    // save state\n    this.rootStore.undo.save(storeId, {\n      instances: [{\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      }],\n    });\n\n    message.success(i18n.translate('ORDER_TO_TOP_SUCCESS'));\n  }\n\n  /**\n   * move shape to the bottom of all shapes\n   * @param instanceItem\n   */\n  moveToBottom(instanceItem: InstanceItem) {\n    const { currentCamera, currentFrame, updateNextShapeOrder } = this.rootStore.frame;\n    const cameraData = instanceItem.cameras[currentCamera];\n    const frameData = cameraData?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n    const cameraShapes = this.getShapesForCamera(currentCamera);\n    const minOrder = Math.min(...cameraShapes.map((s) => s.shape.order));\n    if (minOrder === frameData.order) {\n      message.warning(i18n.translate('ORDER_BACK_MOST'));\n      return;\n    }\n\n    const instanceInfo = instanceItem.instance.getBasicInfo();\n    const instanceItemInfo = instanceItem.getBasicInfo();\n\n    // prev instance state map\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n    // update selected shape order\n    frameData.order = 0;\n    const shape = this.getShapeByInstanceItem(instanceItem, currentCamera);\n    if (shape) {\n      shape.order = 0;\n    }\n    // current instance state map\n    const currInstanceMap: { [instanceId: string]: IInstance } = {\n      [instanceInfo.id]: {\n        ...instanceInfo,\n        children: [{\n          ...instanceItemInfo,\n          cameras: [cameraData.toJSON()],\n        }],\n      },\n    };\n\n    if (minOrder <= 0) {\n      // show move all camera shapes upper\n      for (let i = 0; i < cameraShapes.length; i += 1) {\n        const { shape: s, instanceItem: sInstanceItem } = cameraShapes[i];\n        if (sInstanceItem.id !== instanceItem.id) {\n          // not selected shape\n          const sInstanceInfo = sInstanceItem.instance.getBasicInfo();\n          const sInstanceItemInfo = sInstanceItem.getBasicInfo();\n          const sCameraData = sInstanceItem.cameras[currentCamera];\n          if (!prevInstanceMap[sInstanceInfo.id]) {\n            prevInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          prevInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n          // update not selected shape's order\n          const order = s.order + 1;\n          sCameraData.frames[currentFrame].order = order;\n          s.order = order;\n          updateNextShapeOrder(order, currentFrame, currentCamera);\n          if (!currInstanceMap[sInstanceInfo.id]) {\n            currInstanceMap[sInstanceInfo.id] = {\n              ...sInstanceInfo,\n              children: [],\n            };\n          }\n          currInstanceMap[sInstanceInfo.id].children.push({\n            ...sInstanceItemInfo,\n            cameras: [sCameraData.toJSON()],\n          });\n        }\n      }\n    }\n\n    // save state\n    this.rootStore.undo.push({\n      instances: Object.values(prevInstanceMap),\n    }, {\n      instances: Object.values(currInstanceMap),\n    });\n\n    message.success(i18n.translate('ORDER_TO_BOTTOM_SUCCESS'));\n  }\n\n  /**\n   * move selected shape to front\n   * @param toTop\n   */\n  moveFront = (toTop = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (toTop) {\n        this.moveToTop(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const upperShape = getUpperShape(selectedShape, intersections);\n        if (upperShape) {\n          this.exchangeShapeOrder(selectedShape, upperShape);\n          message.success(i18n.translate('ORDER_FRONT_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_FRONT_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  /**\n   * move selected shape to back\n   * @param toBottom\n   */\n  moveBack = (toBottom = false) => {\n    if (this.selectedShapes.length === 1) {\n      const selectedShape = this.selectedShapes[0];\n      if (toBottom) {\n        this.moveToBottom(this.shapes[selectedShape.uid].instanceItem);\n        return;\n      }\n      const intersections = this.getIntersectionsForShape(selectedShape);\n      if (intersections.length > 0) {\n        const underShape = getUnderShape(selectedShape, intersections);\n        if (underShape) {\n          this.exchangeShapeOrder(selectedShape, underShape);\n          message.success(i18n.translate('ORDER_BACK_SUCCESS'));\n        } else {\n          message.warning(i18n.translate('ORDER_BACK_MOST'));\n        }\n      } else {\n        message.warning(i18n.translate('ORDER_NO_INTERSECT'));\n      }\n    }\n  };\n\n  clearPending = () => {\n    this.pendingMergePolygon = '';\n  };\n\n  mergePolygon = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1 ||\n      this.selectedShapes[0].shapeType !== ShapeType.POLYGON\n    ) {\n      return;\n    }\n\n    this.endPolygonCutting(); // cancel cutting\n    this.rootStore.relationship.cancel(); // cancel relationship\n\n    const selectedPolygon = this.selectedShapes[0] as Polygon;\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape);\n    const intersectPolygonIds = selectedPolygon.findIntersectPolygons(shapes);\n    if (intersectPolygonIds.length === 1) {\n      this.mergePolygons(selectedPolygon.uid, intersectPolygonIds[0]);\n    } else if (intersectPolygonIds.length === 0) {\n      message.warn(i18n.translate('MERGE_NO_INTERSECT'));\n    } else {\n      this.pendingMergePolygon = selectedPolygon.uid;\n      message.info(i18n.translate('MERGE_SELECT_NEXT'));\n    }\n  };\n\n  mergePolygons(polygonId1: string, polygonId2: string) {\n    const { shape: polygon1, instanceItem: instance1 } = this.shapes[polygonId1];\n    const { shape: polygon2, instanceItem: instance2 } = this.shapes[polygonId2];\n    const mergedData = (polygon1 as Polygon).merge(polygon2 as Polygon);\n    if (mergedData.length === 1) {\n      const { currentCamera, currentFrame } = this.rootStore.frame;\n      const { prevState, currState } = this.rootStore.instance.deleteInstanceItemByFrame(instance2, currentFrame);\n\n      const { prevState: prevStateItem, currState: currStateItem } = instance1.updateShape(\n        currentCamera,\n        currentFrame,\n        this.rootStore.config.autoInterpolation,\n        ShapeType.POLYGON,\n        mergedData[0],\n        this.rootStore.frame.getNextShapeOrder(),\n      );\n\n      this.setupShape(instance1);\n      this.selectShapeByInstanceItem(instance1);\n      const basicInfo = instance1.instance.getBasicInfo();\n\n      this.rootStore.undo.push({\n        instances: [\n          ...prevState.instances,\n          ...prevStateItem ? [{ ...basicInfo, children: [prevStateItem] }] : [],\n        ],\n        relationships: prevState.relationships,\n      }, {\n        instances: [\n          ...currState.instances,\n          ...currStateItem ? [{ ...basicInfo, children: [currStateItem] }] : [],\n        ],\n        relationships: currState.relationships,\n      });\n\n      message.success(i18n.translate('MERGE_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('MERGE_WITH_HOLE'));\n    }\n  }\n\n  subtractPolygon = () => {\n    if (\n      this.rootStore.readonly ||\n      this.rootStore.config.isAnyModalOpened ||\n      this.isDrawing ||\n      this.selectedShapes.length !== 1 ||\n      this.selectedShapes[0].shapeType !== ShapeType.POLYGON\n    ) {\n      return;\n    }\n\n    this.rootStore.cancelShapeWorking();\n\n    const selectedPolygon = this.selectedShapes[0] as Polygon;\n    const shapes = this.getShapesForCamera(this.rootStore.frame.currentCamera).map((i) => i.shape);\n    const intersectPolygons = selectedPolygon.findIntersectPolygons(shapes).map((i) => this.shapes[i].shape);\n    const subtractedData = selectedPolygon.subtract(intersectPolygons);\n\n    if (subtractedData && subtractedData.length > 0) {\n      this.updatePolygons(subtractedData[0][0], subtractedData.slice(1).map((d) => d[0]));\n      message.success(i18n.translate('SUBTRACT_SUCCESS'));\n    } else {\n      message.warn(i18n.translate('SUBTRACT_NO_INTERSECT'));\n    }\n  };\n\n  updatePolygons(currPolygonData: PolygonData, otherPolygonData: PolygonData[]) {\n    const selectedPolygon = this.selectedShapes[0] as Polygon;\n    const { instanceItem: selectedInstanceItem } = this.shapes[selectedPolygon.uid];\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const attributes = selectedInstanceItem.cameras[currentCamera].frames[currentFrame].attributes;\n\n    const area = calcShapeArea(ShapeType.POLYGON, currPolygonData);\n    if (area < this.rootStore.config.minArea) {\n      message.warning(i18n.translate('MIN_AREA_ALERT'));\n      this.rootStore.instance.deleteFramesFromInstanceItem(selectedInstanceItem, [currentFrame]);\n      return;\n    }\n\n    const { prevState: prevStateItem, currState: currStateItem } = selectedInstanceItem.updateShape(\n      currentCamera,\n      currentFrame,\n      this.rootStore.config.autoInterpolation,\n      ShapeType.POLYGON,\n      currPolygonData,\n      this.rootStore.frame.getNextShapeOrder(),\n      attributes,\n    );\n\n    const basicInfo = selectedInstanceItem.instance.getBasicInfo();\n    const instanceState: Record<string, { prev: IInstance, curr: IInstance }> = {\n      [basicInfo.id]: {\n        prev: { ...basicInfo, children: prevStateItem ? [prevStateItem] : [] },\n        curr: { ...basicInfo, children: currStateItem ? [currStateItem] : [] }\n      }\n    };\n\n    this.setupShape(selectedInstanceItem);\n\n    for (let i = 0; i < otherPolygonData.length; i += 1) {\n      if (calcShapeArea(ShapeType.POLYGON, otherPolygonData[i]) < this.rootStore.config.minArea) {\n        return;\n      }\n\n      const instanceItem = this.rootStore.instance.getCurrentInstanceItem(selectedInstanceItem.instance.category, selectedInstanceItem.name);\n\n      const prevInfo = instanceItem.instance.getBasicInfo();\n      if (instanceItem.instance !== selectedInstanceItem.instance) {\n        instanceItem.instance.setAttributes(selectedInstanceItem.instance.attributes);\n      }\n      const currInfo = instanceItem.instance.getBasicInfo();\n      if (!instanceState[currInfo.id]) {\n        instanceState[currInfo.id] = {\n          prev: { ...prevInfo, children: [] },\n          curr: { ...currInfo, children: [] }\n        };\n      }\n      const state = instanceState[currInfo.id];\n      const { prevState, currState } = instanceItem.updateShape(\n        currentCamera,\n        currentFrame,\n        this.rootStore.config.autoInterpolation,\n        ShapeType.POLYGON,\n        otherPolygonData[i],\n        this.rootStore.frame.getNextShapeOrder(),\n        attributes,\n      );\n      this.setupShape(instanceItem);\n      if (prevState) {\n        state.prev.children.push(prevState);\n      }\n      if (currState) {\n        state.curr.children.push(currState);\n      }\n    }\n    this.selectShapeByInstanceItem(selectedInstanceItem);\n    this.rootStore.undo.push({\n      instances: Object.values(instanceState).map((i) => i.prev).filter((i) => i.children.length > 0)\n    }, {\n      instances: Object.values(instanceState).map((i) => i.curr)\n    });\n  }\n\n  updateConfig = ({ fill, alpha, toleranceFill, toleranceAlpha, borderAlpha, borderWidth, dotRadius, showVertex, showVertexOrder, vertexSize }: {\n    fill?: boolean,\n    alpha?: number,\n    toleranceFill?: boolean,\n    toleranceAlpha?: number,\n    borderAlpha?: number,\n    borderWidth?: number,\n    dotRadius?: number,\n    showVertex?: boolean,\n    showVertexOrder?: boolean,\n    vertexSize?: number,\n  }) => {\n    const { viewMode } = this.rootStore.config;\n    if (fill !== undefined) {\n      this.config.fill = fill;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesFill(fill);\n      } else {\n        this.rootStore.grid.updateShapesFill(fill);\n      }\n    }\n    if (alpha !== undefined) {\n      this.config.alpha = alpha;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesAlpha(alpha / 100);\n      } else {\n        this.rootStore.grid.updateShapesAlpha(alpha / 100);\n      }\n    }\n    if (toleranceFill !== undefined) {\n      this.config.toleranceFill = toleranceFill;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesToleranceFill(toleranceFill);\n      } else {\n        this.rootStore.grid.updateShapesToleranceFill(toleranceFill);\n      }\n    }\n    if (toleranceAlpha !== undefined) {\n      this.config.toleranceAlpha = toleranceAlpha;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesToleranceAlpha(toleranceAlpha / 100);\n      } else {\n        this.rootStore.grid.updateShapesToleranceAlpha(toleranceAlpha / 100);\n      }\n    }\n    if (borderAlpha !== undefined) {\n      this.config.borderAlpha = borderAlpha;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesBorderAlpha(borderAlpha / 100);\n      } else {\n        this.rootStore.grid.updateShapesBorderAlpha(borderAlpha / 100);\n      }\n    }\n    if (borderWidth !== undefined) {\n      this.config.borderWidth = borderWidth;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShapesBorderWidth(borderWidth);\n      } else {\n        this.rootStore.grid.updateShapesBorderWidth(borderWidth);\n      }\n    }\n    if (dotRadius !== undefined) {\n      this.config.dotRadius = dotRadius;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateDotsRadius(dotRadius);\n      } else {\n        this.rootStore.grid.updateDotsRadius(dotRadius);\n      }\n    }\n    if (showVertex !== undefined) {\n      this.config.showVertex = showVertex;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShowVertex(showVertex);\n      } else {\n        this.rootStore.grid.updateShowVertex(showVertex);\n      }\n    }\n    if (showVertexOrder !== undefined) {\n      this.config.showVertexOrder = showVertexOrder;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateShowVertexOrder(showVertexOrder);\n      } else {\n        this.rootStore.grid.updateShowVertexOrder(showVertexOrder);\n      }\n    }\n    if (vertexSize !== undefined) {\n      this.config.vertexSize = vertexSize;\n      if (viewMode === ViewMode.DEFAULT) {\n        this.updateVertexSize(vertexSize);\n      } else {\n        this.rootStore.grid.updateVertexSize(vertexSize);\n      }\n    }\n  };\n\n  updateShapesFill = (fill: boolean) => {\n    const fillAlpha = fill ? this.config.alpha / 100 : 0;\n    if (this.drawingShape) {\n      this.drawingShape.alpha = fillAlpha;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.alpha = fillAlpha;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.alpha = fillAlpha;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.alpha = fillAlpha;\n      });\n    });\n  };\n\n  updateShapesAlpha = (alpha: number) => {\n    if (this.config.fill) {\n      if (this.drawingShape) {\n        this.drawingShape.alpha = alpha;\n      }\n      Object.values(this.shapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n      Object.values(this.predictedShapes).forEach(({ shape }) => {\n        shape.alpha = alpha;\n      });\n      Object.values(this.projectedShapes).forEach((cameraShapes) => {\n        Object.values(cameraShapes).forEach((shape) => {\n          shape.alpha = alpha;\n        });\n      });\n    }\n  };\n\n  updateShapesToleranceFill = (fill: boolean) => {\n    const fillAlpha = fill ? this.config.toleranceAlpha / 100 : 0;\n    if (this.drawingShape instanceof Rectangle) {\n      this.drawingShape.toleranceAlpha = fillAlpha;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape instanceof Rectangle) {\n        shape.toleranceAlpha = fillAlpha;\n      }\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      if (shape instanceof Rectangle) {\n        shape.toleranceAlpha = fillAlpha;\n      }\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        if (shape instanceof Rectangle) {\n          shape.toleranceAlpha = fillAlpha;\n        }\n      });\n    });\n  };\n\n  updateShapesToleranceAlpha = (alpha: number) => {\n    if (this.config.toleranceFill) {\n      if (this.drawingShape instanceof Rectangle) {\n        this.drawingShape.toleranceAlpha = alpha;\n      }\n      Object.values(this.shapes).forEach(({ shape }) => {\n        if (shape instanceof Rectangle) {\n          shape.toleranceAlpha = alpha;\n        }\n      });\n      Object.values(this.predictedShapes).forEach(({ shape }) => {\n        if (shape instanceof Rectangle) {\n          shape.toleranceAlpha = alpha;\n        }\n      });\n      Object.values(this.projectedShapes).forEach((cameraShapes) => {\n        Object.values(cameraShapes).forEach((shape) => {\n          if (shape instanceof Rectangle) {\n            shape.toleranceAlpha = alpha;\n          }\n        });\n      });\n    }\n  };\n\n  updateShapesBorderAlpha = (borderAlpha: number) => {\n    if (this.drawingShape) {\n      this.drawingShape.borderAlpha = borderAlpha;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.borderAlpha = borderAlpha;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.borderAlpha = borderAlpha;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.borderAlpha = borderAlpha;\n      });\n    });\n  };\n\n  updateShapesBorderWidth = (borderWidth: number) => {\n    if (this.drawingShape) {\n      this.drawingShape.borderWidth = borderWidth;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.borderWidth = borderWidth;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.borderWidth = borderWidth;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.borderWidth = borderWidth;\n      });\n    });\n  };\n\n  updateDotsRadius = (dotRadius: number) => {\n    Object.values(this.shapes).forEach(({ shape }) => {\n      if (shape instanceof Dot) {\n        shape.dotRadius = dotRadius;\n      }\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      if (shape instanceof Dot) {\n        shape.dotRadius = dotRadius;\n      }\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        if (shape instanceof Dot) {\n          shape.dotRadius = dotRadius;\n        }\n      });\n    });\n  };\n\n  updateShowVertex = (showVertex: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertex = showVertex;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertex = showVertex;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.showVertex = showVertex;\n      });\n    });\n  };\n\n  updateShowVertexOrder = (showVertexOrder: boolean) => {\n    if (this.drawingShape) {\n      this.drawingShape.showVertexOrder = showVertexOrder;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.showVertexOrder = showVertexOrder;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.showVertexOrder = showVertexOrder;\n      });\n    });\n  };\n\n  updateVertexSize = (vertexSize: number) => {\n    if (this.drawingShape) {\n      this.drawingShape.vertexSize = vertexSize;\n    }\n    Object.values(this.shapes).forEach(({ shape }) => {\n      shape.vertexSize = vertexSize;\n    });\n    Object.values(this.predictedShapes).forEach(({ shape }) => {\n      shape.vertexSize = vertexSize;\n    });\n    Object.values(this.projectedShapes).forEach((cameraShapes) => {\n      Object.values(cameraShapes).forEach((shape) => {\n        shape.vertexSize = vertexSize;\n      });\n    });\n  };\n\n  resetConfig = () => {\n    this.updateConfig({ ...this.defaultConfig });\n  };\n\n  togglePolygonCut = () => {\n    if (this.cuttingPolygon) {\n      this.endPolygonCutting();\n    } else {\n      this.startPolygonCutting('cut');\n    }\n  };\n\n  startPolygonCutting(cuttingMode: 'cut' | 'split') {\n    if (this.rootStore.readonly || this.rootStore.config.isAnyModalOpened || this.isDrawing || !this.rootStore.instance.isSingleSelected) {\n      return;\n    }\n\n    const isGridView = this.rootStore.config.viewMode === ViewMode.GRID;\n    const selectedShape = !isGridView ? this.selectedShapes[0] : this.rootStore.grid.getCurrentSelectedShape();\n    if (selectedShape && selectedShape.shapeType === ShapeType.POLYGON) {\n      this.clearPending(); // cancel merge\n      this.rootStore.relationship.cancel(); // cancel relationship\n\n      const polygon = selectedShape as Polygon;\n      polygon.isCutting = true;\n      polygon.cuttingMode = cuttingMode;\n      if (cuttingMode === 'cut') {\n        this.cuttingPolygon = polygon.uid;\n        this.splittingPolygn = '';\n      } else {\n        this.splittingPolygn = polygon.uid;\n        this.cuttingPolygon = '';\n      }\n      this.selectedPointIndex = -1;\n      // update interactive\n      if (!isGridView) {\n        this.updateShapesInteractive(false, [polygon.uid]);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(false, [polygon.uid]);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(false);\n    }\n  }\n\n  endPolygonCutting() {\n    const polygonId = this.cuttingPolygon || this.splittingPolygn;\n    if (polygonId) {\n      const polygon = this.shapes[polygonId].shape as Polygon;\n      polygon.isCutting = false;\n      this.cuttingPolygon = '';\n      this.splittingPolygn = '';\n      if (this.rootStore.config.viewMode === ViewMode.DEFAULT) {\n        this.updateShapesInteractive(true);\n      } else {\n        this.rootStore.grid.updateShapesInteractive(true);\n      }\n      this.rootStore.relationship.updateConnectionsInteractive(true);\n    }\n  }\n\n  /**\n   * rotate all shapes (excluding predicted shapes)\n   * @param rotation\n   * @param center\n   * @param offsetX\n   * @param offsetY\n   */\n  rotateShapesByCanvas = (rotation: number, center: { x: number; y: number }, offsetX: number, offsetY: number) => {\n    const { currentCamera, currentFrame } = this.rootStore.frame;\n    const { autoInterpolation } = this.rootStore.config;\n    const prevInstanceMap: { [instanceId: string]: IInstance } = {};\n    const currInstanceMap: { [instanceId: string]: IInstance } = {};\n\n    this.getShapesForCamera(currentCamera).forEach(({ shape, instanceItem }) => {\n      // update shape\n      switch (shape.shapeType) {\n        case ShapeType.POLYGON:\n        case ShapeType.LINE:\n        case ShapeType.ARROW: {\n          const s = shape as Polygon | Line | Arrow;\n          const { points } = s;\n          s.points = points.map((p) => {\n            const rp = computeRotatedPosition(center, p, rotation);\n            return { x: precise(rp.x - offsetX), y: precise(rp.y - offsetY), userData: p.userData };\n          });\n          break;\n        }\n        case ShapeType.RECTANGLE: {\n          const rect = shape as Rectangle;\n          const { x, y, width, height, centerLineEnabled, center: c, rotation: r } = rect;\n          const rotatedCenter = computeRotatedPosition(center, { x: x + width / 2, y: y + height / 2 }, rotation);\n          if (rotation % Math.PI !== 0) {\n            rect.width = height;\n            rect.height = width;\n          }\n          rect.x = precise(rotatedCenter.x - offsetX - rect.width / 2);\n          rect.y = precise(rotatedCenter.y - offsetY - rect.height / 2);\n          // update center\n          if (centerLineEnabled) {\n            rect.center = precise(rect.x + ((c - x) / width) * rect.width);\n          }\n          // reset rotation to update pivot\n          rect.rotation = r;\n          break;\n        }\n        case ShapeType.ELLIPSE: {\n          const ellipse = shape as Ellipse;\n          const { x, y, halfWidth, halfHeight } = ellipse;\n          const rotatedCenter = computeRotatedPosition(center, { x, y }, rotation);\n          ellipse.x = precise(rotatedCenter.x - offsetX);\n          ellipse.y = precise(rotatedCenter.y - offsetY);\n          if (rotation % Math.PI !== 0) {\n            ellipse.halfWidth = halfHeight;\n            ellipse.halfHeight = halfWidth;\n          }\n          break;\n        }\n        case ShapeType.CIRCLE: {\n          const circle = shape as Circle;\n          const { x, y } = circle;\n          const rotatedCenter = computeRotatedPosition(center, { x, y }, rotation);\n          circle.x = precise(rotatedCenter.x - offsetX);\n          circle.y = precise(rotatedCenter.y - offsetY);\n          break;\n        }\n        case ShapeType.DOT: {\n          const dot = shape as Dot;\n          const { x, y } = dot;\n          const rotatedPoint = computeRotatedPosition(center, { x, y }, rotation);\n          dot.x = precise(rotatedPoint.x - offsetX);\n          dot.y = precise(rotatedPoint.y - offsetY);\n          break;\n        }\n        case ShapeType.CUBOID:\n        case ShapeType.TWO_SIDES_CUBOID: {\n          const cuboid = shape as Cuboid;\n          const { x1, y1, w1, h1, x2, y2, w2, h2 } = cuboid;\n          const rotatedCenter1 = computeRotatedPosition(center, { x: x1 + w1 / 2, y: y1 + h1 / 2 }, rotation);\n          const rotatedCenter2 = computeRotatedPosition(center, { x: x2 + w2 / 2, y: y2 + h2 / 2 }, rotation);\n          let fw = w1;\n          let fh = h1;\n          let bw = w2;\n          let bh = h2;\n          if (rotation % Math.PI !== 0) {\n            fw = h1;\n            fh = w1;\n            bw = h2;\n            bh = w2;\n          }\n          cuboid.setData({\n            front: {\n              x: precise(rotatedCenter1.x - offsetX - fw / 2),\n              y: precise(rotatedCenter1.y - offsetY - fh / 2),\n              width: fw,\n              height: fh,\n            },\n            back: {\n              x: precise(rotatedCenter2.x - offsetX - bw / 2),\n              y: precise(rotatedCenter2.y - offsetY - bh / 2),\n              width: bw,\n              height: bh,\n            },\n          });\n          break;\n        }\n        case ShapeType.LSHAPE: {\n          const lshape = shape as LShape;\n          const { x, y, w, h, sx1, sy1, sx2, sy2, center: c } = lshape;\n          const rotatedCenter = computeRotatedPosition(center, { x: x + w / 2, y: y + h / 2 }, rotation);\n          if (rotation % Math.PI !== 0) {\n            lshape.w = h;\n            lshape.h = w;\n          }\n          lshape.x = rotatedCenter.x - offsetX - lshape.w / 2;\n          lshape.y = rotatedCenter.y - offsetY - lshape.h / 2;\n          // update side points (side points cannot be rotated, keep the offset from origin)\n          if (Math.abs(sx1 - x) < Math.abs(sx1 - x - w)) {\n            lshape.sx1 = lshape.x + sx1 - x;\n            lshape.sx2 = lshape.x + sx2 - x;\n          } else {\n            lshape.sx1 = lshape.x + lshape.w + sx1 - (x + w);\n            lshape.sx2 = lshape.x + lshape.w + sx2 - (x + w);\n          }\n          lshape.sy1 = lshape.y + sy1 - y;\n          lshape.sy2 = lshape.y + sy2 - y;\n          // update center\n          lshape.center = precise(lshape.x + ((c - x) / w) * lshape.w);\n          lshape.x = precise(lshape.x);\n          lshape.y = precise(lshape.y);\n          lshape.sx1 = precise(lshape.sx1);\n          lshape.sx2 = precise(lshape.sx2);\n          lshape.sy1 = precise(lshape.sy1);\n          lshape.sy2 = precise(lshape.sy2);\n          break;\n        }\n        case ShapeType.GRID: {\n          const grid = shape as Grid;\n          const { cols, rows, x, y, width, height } = grid;\n          const gridCenter = { x: x + width / 2, y: y + height / 2 };\n          const rotatedCenter = computeRotatedPosition(center, gridCenter, rotation);\n          if (rotation % Math.PI !== 0) {\n            const c0 = rotatedCenter.x - offsetX - height / 2;\n            const r0 = rotatedCenter.y - offsetY - width / 2;\n            grid.cols = rows.map((r) => ({ x: precise(c0 + r.y - y) }));\n            grid.rows = cols.map((c) => ({ y: precise(r0 + c.x - x) }));\n          } else {\n            const c0 = rotatedCenter.x - offsetX - width / 2;\n            const r0 = rotatedCenter.y - offsetY - height / 2;\n            grid.cols = cols.map((c) => ({ x: precise(c0 + c.x - x) }));\n            grid.rows = rows.map((r) => ({ y: precise(r0 + r.y - y) }));\n          }\n          break;\n        }\n        default:\n      }\n\n      // save shape data\n      const { prevState, currState } = instanceItem.updateShape(currentCamera, currentFrame, autoInterpolation, shape.shapeType, shape.getData());\n      const { instance } = instanceItem;\n      if (prevState) {\n        if (!prevInstanceMap[instance.id]) {\n          prevInstanceMap[instance.id] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        prevInstanceMap[instance.id].children.push(prevState);\n      }\n      if (currState) {\n        if (!currInstanceMap[instance.id]) {\n          currInstanceMap[instance.id] = {\n            ...instance.getBasicInfo(),\n            children: [],\n          };\n        }\n        currInstanceMap[instance.id].children.push(currState);\n      }\n    });\n\n    // reproject shapes\n    this.reprojectShapesByCamera();\n\n    return {\n      prevState: { instances: Object.values(prevInstanceMap) },\n      currState: { instances: Object.values(currInstanceMap) },\n    };\n  };\n\n  /**\n   * update bounds for all shapes\n   */\n  updateShapesBounds() {\n    const { boundaryCheck } = this.rootStore.config;\n    const { currentCamera, imageBounds } = this.rootStore.frame;\n    if (boundaryCheck) {\n      this.getShapesForCamera(currentCamera).forEach(({ shape }) => {\n        shape.bounds = imageBounds;\n      });\n    }\n  }\n\n  /**\n   * hide or show shapes based on hideOthers\n   */\n  hideOrShowOthers = () => {\n    const { hideOthers, hideAll } = this.rootStore.config;\n    const selectedInstanceIds = this.rootStore.instance.selectedInstances.map((i) => i.id);\n    const shouldHide = hideOthers && selectedInstanceIds.length > 0;\n    Object.values(this.shapes).forEach(({ shape, instanceItem }) => {\n      const { id } = instanceItem.instance;\n      const labelDom = document.getElementById(`label-item-${instanceItem.id}`);\n      if (hideAll || (shouldHide && !selectedInstanceIds.includes(id))) {\n        shape.visible = false;\n        if (labelDom) {\n          labelDom.style.visibility = 'hidden';\n        }\n        if (this.projectedShapes[shape.uid]) {\n          Object.values(this.projectedShapes[shape.uid]).forEach((projectedShape) => {\n            projectedShape.visible = false;\n          });\n        }\n      } else {\n        shape.visible = true;\n        if (labelDom) {\n          labelDom.style.visibility = 'visible';\n        }\n        if (this.projectedShapes[shape.uid]) {\n          Object.values(this.projectedShapes[shape.uid]).forEach((projectedShape) => {\n            projectedShape.visible = true;\n          });\n        }\n      }\n    });\n    this.rootStore.relationship.hideOrShowRelationships();\n    this.rootStore.review.hideOrShowReviews();\n  };\n\n  /**\n    * project all shapes in current frame\n    */\n  async projectShapes() {\n    if (!this.rootStore.frame.camerasMapping.projectEnabled) {\n      return;\n    }\n    const allShapes = Object.values(this.shapes);\n    if (allShapes.length <= 0) {\n      return;\n    }\n    return Promise.all(\n      allShapes.map(({ shape, camera }) => this.projectShape(shape, false, camera))\n    );\n  }\n\n  /**\n   * project shape in current frame from base camera to camera\n   * @param shape\n   * @param forceUpdate\n   * @param baseCamera\n   * @param toCameras\n   */\n  async projectShape(\n    shape: Shape<ShapeData>,\n    forceUpdate = false,\n    baseCamera = this.rootStore.frame.currentCamera,\n    toCameras = this.rootStore.frame.cameraNames,\n  ) {\n    const { projectMode } = this.rootStore.config;\n    const shouldUpdate = projectMode === ProjectMode.REAL_TIME || forceUpdate;\n    const {\n      camerasMapping,\n      currentFrame,\n      cameraViews,\n      getImageBoundsForCamera,\n      getFrameRotation,\n    } = this.rootStore.frame;\n\n    if (\n      !shouldUpdate ||\n      !camerasMapping.projectEnabled ||\n      !this.shapes[shape.uid] ||\n      shapeTypesSupportProject.indexOf(shape.shapeType) < 0\n    ) {\n      return;\n    }\n\n    const { instanceItem } = this.shapes[shape.uid];\n    const frameData = instanceItem.cameras[baseCamera]?.frames[currentFrame];\n    if (!frameData) {\n      return;\n    }\n\n    const { points } = shape as ShapeSupportProject;\n    const { width: baseCameraWidth, height: baseCameraHeight } = cameraViews[baseCamera].image;\n    const baseCameraRotation = getFrameRotation(baseCamera, currentFrame);\n    const baseCameraMatrix = getMatrixByRotation(baseCameraRotation, baseCameraWidth, baseCameraHeight);\n    const originPoints: [number, number][] = points.map((p) => {\n      if (baseCameraRotation !== 0) {\n        const op = calcPositionByMatrix(p, inv(baseCameraMatrix));\n        return [op.x, op.y];\n      }\n      return [p.x, p.y];\n    });\n\n    const projectedCameras: string[] = [];\n    await Promise.all(\n      toCameras\n        .map(async (toCamera) => {\n          if (toCamera === baseCamera) {\n            // do not project to self camera\n            return;\n          }\n\n          if (!camerasMapping.isProjectAvailable(currentFrame)) {\n            // show loading if current not available\n            this.projecting = true;\n          }\n\n          const projectedPoints = await camerasMapping.projectPoints(\n            originPoints,\n            currentFrame,\n            baseCamera,\n            toCamera,\n          );\n\n          const { width: toCameraWidth, height: toCameraHeight } = cameraViews[toCamera].image;\n          const toCameraRotation = getFrameRotation(toCamera, currentFrame);\n          const toCameraMatrix = getMatrixByRotation(toCameraRotation, toCameraWidth, toCameraHeight);\n          const projectedShapePoints = projectedPoints.map((p) => {\n            const point = { x: p[0], y: p[1] };\n            if (toCameraRotation !== 0) {\n              const rp = calcPositionByMatrix(point, toCameraMatrix);\n              point.x = rp.x;\n              point.y = rp.y;\n            }\n            return point;\n          });\n          const projectedShapeData = {\n            points: projectedShapePoints,\n          } as ShapeDataSupportProject;\n\n          if (projectMode === ProjectMode.REAL_TIME) {\n            const existingProjectedShape = this.projectedShapes[shape.uid]?.[toCamera];\n            if (existingProjectedShape) {\n              // update\n              (existingProjectedShape as ShapeSupportProject).points = projectedShapePoints;\n              existingProjectedShape.selected = shape.selected;\n            } else {\n              // create\n              const projectedShape = this.createShape(\n                cameraViews[toCamera].shapesLayer,\n                getImageBoundsForCamera(toCamera),\n                instanceItem.categoryItemRef.displayColor,\n                instanceItem.instance.category,\n                instanceItem.name,\n                frameData.shapeType,\n                projectedShapeData,\n                frameData.order,\n                i18n.translate('PROJECTED_SHAPE_LABEL', { values: { label: instanceItem.label } }),\n                toCamera,\n              );\n              if (projectedShape.destroyed) {\n                return;\n              }\n\n              projectedShape.on(EventAction.SELECTED, () => {\n                // when projected shape selected\n                this.rootStore.instance.selectInstanceItem(instanceItem);\n                // fit source shape\n                this.fitProjectShape(shape, baseCamera);\n                // fit projected shapes in other cameras\n                Object.keys(this.projectedShapes[shape.uid]).forEach((c) => {\n                  if (c !== toCamera) {\n                    this.fitProjectShape(this.projectedShapes[shape.uid][c], c);\n                  }\n                });\n              });\n              projectedShape.on(EventAction.REMOVED, () => {\n                // when projected removed (not valid anymore)\n                if (this.projectedShapes[shape.uid]) {\n                  // delete the projected shape\n                  delete this.projectedShapes[shape.uid][toCamera];\n                }\n              });\n\n              // TODO: should set editable by cameras config, current is always not editable\n              projectedShape.editable = false;\n              projectedShape.selected = shape.selected;\n\n              // add to projected shapes map\n              if (!this.projectedShapes[shape.uid]) {\n                this.projectedShapes[shape.uid] = {};\n              }\n              this.projectedShapes[shape.uid][toCamera] = projectedShape;\n\n              if (shape.selected) {\n                // auto focus when shape selected & first created\n                // this.fitProjectShape(projectedShape, toCamera);\n              }\n            }\n          } else if (projectMode === ProjectMode.MANUAL) {\n            const toFrameData = instanceItem.cameras[toCamera]?.frames[currentFrame];\n            projectedShapeData.points.forEach((p, i) => {\n              p.userData = cloneDeep(toFrameData\n                ? (toFrameData.shape as ShapeDataSupportProject).points?.[i]?.userData\n                : points[i]?.userData);\n            });\n            const { prevState, currState } = instanceItem.updateShape(\n              toCamera,\n              currentFrame,\n              this.rootStore.config.autoInterpolation,\n              frameData.shapeType,\n              projectedShapeData,\n              this.rootStore.frame.getNextShapeOrder(currentFrame, toCamera),\n              toFrameData?.attributes || frameData.attributes,\n            );\n            const basicInfo = instanceItem.instance.getBasicInfo();\n            this.rootStore.undo.push({\n              instances: prevState ? [{ ...basicInfo, children: [prevState] }] : [],\n            }, {\n              instances: currState ? [{ ...basicInfo, children: [currState] }] : [],\n            });\n            this.setupShape(instanceItem, toCamera);\n            this.rootStore.instance.selectInstanceItem(instanceItem);\n            projectedCameras.push(toCamera);\n          }\n\n          this.projecting = false;\n        })\n    );\n\n    if (projectedCameras.length > 0) {\n      const projectedCamerasLabel = projectedCameras.map((c) => `C${this.rootStore.frame.cameraNames.indexOf(c) + 1}`).join(',');\n      message.success(i18n.translate('PROJECT_SUCCESS', {\n        values: {\n          label: instanceItem.label,\n          cameras: projectedCamerasLabel,\n        },\n      }));\n    }\n  }\n\n  /**\n   * project selected shapes\n   */\n  projectSelectedShape() {\n    if (this.rootStore.readonly) {\n      return;\n    }\n    this.selectedShapes.forEach((shape) => this.projectShape(shape, true));\n  }\n\n  /**\n   * fit projected shape to camera view\n   * @param shape\n   * @param camera\n   */\n  fitProjectShape(shape: Shape<ShapeData>, camera: string) {\n    const cameraView = this.rootStore.frame.cameraViews[camera];\n    if (cameraView) {\n      const { left, top, right, bottom } = shape.shapeBounds;\n      cameraView.fitShapeToView({ left, top, right, bottom }, 0.5);\n    }\n  }\n\n  fitProjectShapesForSelectedShapes = () => {\n    this.selectedShapes.forEach((shape) => {\n      const projectedShapes = this.projectedShapes[shape.uid];\n      if (projectedShapes) {\n        Object.keys(projectedShapes).forEach((projectCamera) => {\n          const projectedShape = projectedShapes[projectCamera];\n          this.fitProjectShape(projectedShape, projectCamera);\n        });\n      }\n    });\n  };\n\n  /**\n   * reproject shapes\n   * @param camera\n   */\n  reprojectShapesByCamera(camera = this.rootStore.frame.currentCamera) {\n    Object.keys(this.projectedShapes).forEach((sourceShapeId) => {\n      const projectedShape = this.projectedShapes[sourceShapeId][camera];\n      if (projectedShape) {\n        const sourceShape = this.shapes[sourceShapeId];\n        if (sourceShape) {\n          this.projectShape(sourceShape.shape, false, sourceShape.camera, [camera]);\n        }\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}