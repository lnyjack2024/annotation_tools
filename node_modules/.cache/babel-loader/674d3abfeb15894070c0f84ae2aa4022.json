{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\n\n/**\n * Higher-order component that manages lazy-loading for \"infinite\" data.\n * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.\n * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.\n */\nvar InfiniteLoader = /*#__PURE__*/function (_React$PureComponent) {\n  function InfiniteLoader(props, context) {\n    var _this;\n    _classCallCheck(this, InfiniteLoader);\n    _this = _callSuper(this, InfiniteLoader, [props, context]);\n    _this._loadMoreRowsMemoizer = createCallbackMemoizer();\n    _this._onRowsRendered = _this._onRowsRendered.bind(_this);\n    _this._registerChild = _this._registerChild.bind(_this);\n    return _this;\n  }\n  _inherits(InfiniteLoader, _React$PureComponent);\n  return _createClass(InfiniteLoader, [{\n    key: \"resetLoadMoreRowsCache\",\n    value: function resetLoadMoreRowsCache(autoReload) {\n      this._loadMoreRowsMemoizer = createCallbackMemoizer();\n      if (autoReload) {\n        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children({\n        onRowsRendered: this._onRowsRendered,\n        registerChild: this._registerChild\n      });\n    }\n  }, {\n    key: \"_loadUnloadedRanges\",\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this;\n      var loadMoreRows = this.props.loadMoreRows;\n      unloadedRanges.forEach(function (unloadedRange) {\n        var promise = loadMoreRows(unloadedRange);\n        if (promise) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: unloadedRange.startIndex,\n              stopIndex: unloadedRange.stopIndex\n            })) {\n              if (_this2._registeredChild) {\n                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);\n              }\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_onRowsRendered\",\n    value: function _onRowsRendered(_ref) {\n      var startIndex = _ref.startIndex,\n        stopIndex = _ref.stopIndex;\n      this._lastRenderedStartIndex = startIndex;\n      this._lastRenderedStopIndex = stopIndex;\n      this._doStuff(startIndex, stopIndex);\n    }\n  }, {\n    key: \"_doStuff\",\n    value: function _doStuff(startIndex, stopIndex) {\n      var _ref2,\n        _this3 = this;\n      var _this$props = this.props,\n        isRowLoaded = _this$props.isRowLoaded,\n        minimumBatchSize = _this$props.minimumBatchSize,\n        rowCount = _this$props.rowCount,\n        threshold = _this$props.threshold;\n      var unloadedRanges = scanForUnloadedRanges({\n        isRowLoaded: isRowLoaded,\n        minimumBatchSize: minimumBatchSize,\n        rowCount: rowCount,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\n      });\n\n      // For memoize comparison\n      var squashedUnloadedRanges = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(unloadedRanges.map(function (_ref3) {\n        var startIndex = _ref3.startIndex,\n          stopIndex = _ref3.stopIndex;\n        return [startIndex, stopIndex];\n      })));\n      this._loadMoreRowsMemoizer({\n        callback: function callback() {\n          _this3._loadUnloadedRanges(unloadedRanges);\n        },\n        indices: {\n          squashedUnloadedRanges: squashedUnloadedRanges\n        }\n      });\n    }\n  }, {\n    key: \"_registerChild\",\n    value: function _registerChild(registeredChild) {\n      this._registeredChild = registeredChild;\n    }\n  }]);\n}(React.PureComponent);\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\n_defineProperty(InfiniteLoader, \"defaultProps\", {\n  minimumBatchSize: 10,\n  rowCount: 0,\n  threshold: 15\n});\nexport { InfiniteLoader as default };\nInfiniteLoader.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * Function responsible for rendering a virtualized component.\n   * This function should implement the following signature:\n   * ({ onRowsRendered, registerChild }) => PropTypes.element\n   *\n   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.\n   * The :registerChild callback should be set as the virtualized component's :ref.\n   */\n  children: PropTypes.func.isRequired,\n  /**\n   * Function responsible for tracking the loaded state of each row.\n   * It should implement the following signature: ({ index: number }): boolean\n   */\n  isRowLoaded: PropTypes.func.isRequired,\n  /**\n   * Callback to be invoked when more rows must be loaded.\n   * It should implement the following signature: ({ startIndex, stopIndex }): Promise\n   * The returned Promise should be resolved once row data has finished loading.\n   * It will be used to determine when to refresh the list with the newly-loaded data.\n   * This callback may be called multiple times in reaction to a single scroll event.\n   */\n  loadMoreRows: PropTypes.func.isRequired,\n  /**\n   * Minimum number of rows to be loaded at a time.\n   * This property can be used to batch requests to reduce HTTP requests.\n   */\n  minimumBatchSize: PropTypes.number.isRequired,\n  /**\n   * Number of rows in list; can be arbitrary high number if actual number is unknown.\n   */\n  rowCount: PropTypes.number.isRequired,\n  /**\n   * Threshold at which to pre-fetch data.\n   * A threshold X means that data will start loading when a user scrolls within X rows.\n   * This value defaults to 15.\n   */\n  threshold: PropTypes.number.isRequired\n} : {};\nexport function isRangeVisible(_ref4) {\n  var lastRenderedStartIndex = _ref4.lastRenderedStartIndex,\n    lastRenderedStopIndex = _ref4.lastRenderedStopIndex,\n    startIndex = _ref4.startIndex,\n    stopIndex = _ref4.stopIndex;\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nexport function scanForUnloadedRanges(_ref5) {\n  var isRowLoaded = _ref5.isRowLoaded,\n    minimumBatchSize = _ref5.minimumBatchSize,\n    rowCount = _ref5.rowCount,\n    startIndex = _ref5.startIndex,\n    stopIndex = _ref5.stopIndex;\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n  for (var index = startIndex; index <= stopIndex; index++) {\n    var loaded = isRowLoaded({\n      index: index\n    });\n    if (!loaded) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex\n      });\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\n      if (!isRowLoaded({\n        index: _index\n      })) {\n        rangeStopIndex = _index;\n      } else {\n        break;\n      }\n    }\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    var firstUnloadedRange = unloadedRanges[0];\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\n      var _index2 = firstUnloadedRange.startIndex - 1;\n      if (!isRowLoaded({\n        index: _index2\n      })) {\n        firstUnloadedRange.startIndex = _index2;\n      } else {\n        break;\n      }\n    }\n  }\n  return unloadedRanges;\n}\n\n/**\n * Since RV components use shallowCompare we need to force a render (even though props haven't changed).\n * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.\n * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,\n * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.\n * Else the inner Grid will not be re-rendered and visuals may be stale.\n *\n * Additionally, while a Grid is scrolling the cells can be cached,\n * So it's important to invalidate that cache by recalculating sizes\n * before forcing a rerender.\n */\nexport function forceUpdateReactVirtualizedComponent(component) {\n  var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;\n  if (recomputeSize) {\n    recomputeSize.call(component, currentIndex);\n  } else {\n    component.forceUpdate();\n  }\n}","map":{"version":3,"names":["_toConsumableArray","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_inherits","_defineProperty","_callSuper","t","o","e","_isNativeReflectConstruct","Reflect","construct","constructor","apply","Boolean","prototype","valueOf","call","React","PropTypes","createCallbackMemoizer","InfiniteLoader","_React$PureComponent","props","context","_this","_loadMoreRowsMemoizer","_onRowsRendered","bind","_registerChild","key","value","resetLoadMoreRowsCache","autoReload","_doStuff","_lastRenderedStartIndex","_lastRenderedStopIndex","render","children","onRowsRendered","registerChild","_loadUnloadedRanges","unloadedRanges","_this2","loadMoreRows","forEach","unloadedRange","promise","then","isRangeVisible","lastRenderedStartIndex","lastRenderedStopIndex","startIndex","stopIndex","_registeredChild","forceUpdateReactVirtualizedComponent","_ref","_ref2","_this3","_this$props","isRowLoaded","minimumBatchSize","rowCount","threshold","scanForUnloadedRanges","Math","max","min","squashedUnloadedRanges","concat","map","_ref3","callback","indices","registeredChild","PureComponent","default","propTypes","process","env","NODE_ENV","func","isRequired","number","_ref4","_ref5","rangeStartIndex","rangeStopIndex","index","loaded","push","potentialStopIndex","_index","length","firstUnloadedRange","_index2","component","currentIndex","arguments","undefined","recomputeSize","recomputeGridSize","recomputeRowHeights","forceUpdate"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/react-virtualized/dist/es/InfiniteLoader/InfiniteLoader.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\n\n/**\n * Higher-order component that manages lazy-loading for \"infinite\" data.\n * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.\n * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.\n */\nvar InfiniteLoader = /*#__PURE__*/function (_React$PureComponent) {\n  function InfiniteLoader(props, context) {\n    var _this;\n    _classCallCheck(this, InfiniteLoader);\n    _this = _callSuper(this, InfiniteLoader, [props, context]);\n    _this._loadMoreRowsMemoizer = createCallbackMemoizer();\n    _this._onRowsRendered = _this._onRowsRendered.bind(_this);\n    _this._registerChild = _this._registerChild.bind(_this);\n    return _this;\n  }\n  _inherits(InfiniteLoader, _React$PureComponent);\n  return _createClass(InfiniteLoader, [{\n    key: \"resetLoadMoreRowsCache\",\n    value: function resetLoadMoreRowsCache(autoReload) {\n      this._loadMoreRowsMemoizer = createCallbackMemoizer();\n      if (autoReload) {\n        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children({\n        onRowsRendered: this._onRowsRendered,\n        registerChild: this._registerChild\n      });\n    }\n  }, {\n    key: \"_loadUnloadedRanges\",\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this;\n      var loadMoreRows = this.props.loadMoreRows;\n      unloadedRanges.forEach(function (unloadedRange) {\n        var promise = loadMoreRows(unloadedRange);\n        if (promise) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: unloadedRange.startIndex,\n              stopIndex: unloadedRange.stopIndex\n            })) {\n              if (_this2._registeredChild) {\n                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);\n              }\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_onRowsRendered\",\n    value: function _onRowsRendered(_ref) {\n      var startIndex = _ref.startIndex,\n        stopIndex = _ref.stopIndex;\n      this._lastRenderedStartIndex = startIndex;\n      this._lastRenderedStopIndex = stopIndex;\n      this._doStuff(startIndex, stopIndex);\n    }\n  }, {\n    key: \"_doStuff\",\n    value: function _doStuff(startIndex, stopIndex) {\n      var _ref2,\n        _this3 = this;\n      var _this$props = this.props,\n        isRowLoaded = _this$props.isRowLoaded,\n        minimumBatchSize = _this$props.minimumBatchSize,\n        rowCount = _this$props.rowCount,\n        threshold = _this$props.threshold;\n      var unloadedRanges = scanForUnloadedRanges({\n        isRowLoaded: isRowLoaded,\n        minimumBatchSize: minimumBatchSize,\n        rowCount: rowCount,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\n      });\n\n      // For memoize comparison\n      var squashedUnloadedRanges = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(unloadedRanges.map(function (_ref3) {\n        var startIndex = _ref3.startIndex,\n          stopIndex = _ref3.stopIndex;\n        return [startIndex, stopIndex];\n      })));\n      this._loadMoreRowsMemoizer({\n        callback: function callback() {\n          _this3._loadUnloadedRanges(unloadedRanges);\n        },\n        indices: {\n          squashedUnloadedRanges: squashedUnloadedRanges\n        }\n      });\n    }\n  }, {\n    key: \"_registerChild\",\n    value: function _registerChild(registeredChild) {\n      this._registeredChild = registeredChild;\n    }\n  }]);\n}(React.PureComponent);\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\n_defineProperty(InfiniteLoader, \"defaultProps\", {\n  minimumBatchSize: 10,\n  rowCount: 0,\n  threshold: 15\n});\nexport { InfiniteLoader as default };\nInfiniteLoader.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * Function responsible for rendering a virtualized component.\n   * This function should implement the following signature:\n   * ({ onRowsRendered, registerChild }) => PropTypes.element\n   *\n   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.\n   * The :registerChild callback should be set as the virtualized component's :ref.\n   */\n  children: PropTypes.func.isRequired,\n  /**\n   * Function responsible for tracking the loaded state of each row.\n   * It should implement the following signature: ({ index: number }): boolean\n   */\n  isRowLoaded: PropTypes.func.isRequired,\n  /**\n   * Callback to be invoked when more rows must be loaded.\n   * It should implement the following signature: ({ startIndex, stopIndex }): Promise\n   * The returned Promise should be resolved once row data has finished loading.\n   * It will be used to determine when to refresh the list with the newly-loaded data.\n   * This callback may be called multiple times in reaction to a single scroll event.\n   */\n  loadMoreRows: PropTypes.func.isRequired,\n  /**\n   * Minimum number of rows to be loaded at a time.\n   * This property can be used to batch requests to reduce HTTP requests.\n   */\n  minimumBatchSize: PropTypes.number.isRequired,\n  /**\n   * Number of rows in list; can be arbitrary high number if actual number is unknown.\n   */\n  rowCount: PropTypes.number.isRequired,\n  /**\n   * Threshold at which to pre-fetch data.\n   * A threshold X means that data will start loading when a user scrolls within X rows.\n   * This value defaults to 15.\n   */\n  threshold: PropTypes.number.isRequired\n} : {};\nexport function isRangeVisible(_ref4) {\n  var lastRenderedStartIndex = _ref4.lastRenderedStartIndex,\n    lastRenderedStopIndex = _ref4.lastRenderedStopIndex,\n    startIndex = _ref4.startIndex,\n    stopIndex = _ref4.stopIndex;\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nexport function scanForUnloadedRanges(_ref5) {\n  var isRowLoaded = _ref5.isRowLoaded,\n    minimumBatchSize = _ref5.minimumBatchSize,\n    rowCount = _ref5.rowCount,\n    startIndex = _ref5.startIndex,\n    stopIndex = _ref5.stopIndex;\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n  for (var index = startIndex; index <= stopIndex; index++) {\n    var loaded = isRowLoaded({\n      index: index\n    });\n    if (!loaded) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex\n      });\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\n      if (!isRowLoaded({\n        index: _index\n      })) {\n        rangeStopIndex = _index;\n      } else {\n        break;\n      }\n    }\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    var firstUnloadedRange = unloadedRanges[0];\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\n      var _index2 = firstUnloadedRange.startIndex - 1;\n      if (!isRowLoaded({\n        index: _index2\n      })) {\n        firstUnloadedRange.startIndex = _index2;\n      } else {\n        break;\n      }\n    }\n  }\n  return unloadedRanges;\n}\n\n/**\n * Since RV components use shallowCompare we need to force a render (even though props haven't changed).\n * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.\n * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,\n * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.\n * Else the inner Grid will not be re-rendered and visuals may be stale.\n *\n * Additionally, while a Grid is scrolling the cells can be cached,\n * So it's important to invalidate that cache by recalculating sizes\n * before forcing a rerender.\n */\nexport function forceUpdateReactVirtualizedComponent(component) {\n  var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;\n  if (recomputeSize) {\n    recomputeSize.call(component, currentIndex);\n  } else {\n    component.forceUpdate();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}