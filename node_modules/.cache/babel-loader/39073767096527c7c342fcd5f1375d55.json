{"ast":null,"code":"import { Base64 } from 'js-base64';\nimport { v4 as uuid } from 'uuid';\nimport hexToRgba from 'hex-to-rgba';\nimport rootStore from './store/RootStore';\nimport { runCustomValidation } from '../../utils';\nimport { LandmarkEditType, LabelItem, LabelFormat, LabelStyle, ValidationType } from './types';\n/* eslint-disable no-param-reassign */\n\nexport function parseFrames(frames) {\n  return (typeof frames === 'string' ? frames.split(',') : frames).map((f, i) => ({\n    url: f.trim(),\n    valid: true,\n    index: i\n  }));\n}\nexport async function parseFramesByPaylod({\n  frames,\n  imageData\n}) {\n  let parsedFrames = [];\n  if (frames) {\n    parsedFrames = parseFrames(frames);\n  }\n  if (imageData) {\n    parsedFrames = imageData.map((v, index) => typeof v === 'string' ? {\n      url: v,\n      valid: true,\n      index\n    } : {\n      url: v.url,\n      valid: v.valid !== undefined ? v.valid : true,\n      index\n    });\n  }\n  return parsedFrames;\n}\nexport function getValuesLabel(fields, values, labelItems) {\n  let content = '';\n  if (fields && values) {\n    for (let i = 0; i < fields.length; i += 1) {\n      const {\n        name,\n        label,\n        visible\n      } = fields[i];\n      if (rootStore.setting.labelFormat === LabelFormat.DEFAULT) {\n        content = `\\n${content}`;\n      }\n      if (visible || !visible && values[name]) {\n        if (labelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n          content += `${label || name}: `;\n        }\n        if (labelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n          content += `${values[name] || ''}`;\n        }\n      }\n      if (i < fields.length - 1 && content) {\n        content += ';';\n      }\n    }\n  }\n  return content;\n}\n;\nexport function resetAttrLabelPosition(label, position, visible) {\n  if (visible !== undefined) {\n    label.visible = visible;\n  }\n  label.position.x = position.x;\n  label.position.y = position.y;\n  if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n    label.children[0].position.x = position.x;\n    label.children[0].position.y = position.y;\n  }\n  label.children.slice(-1)[0].position.x = position.x;\n  label.children.slice(-1)[0].position.y = position.y;\n}\n\n// load result\nexport function loadInstancesFromResult(instances) {\n  const newInstances = {};\n  const categoryInstancesMap = {};\n  instances.forEach(instanceData => {\n    const {\n      category,\n      children: defaultChildren,\n      number\n    } = instanceData;\n    const id = instanceData.id || uuid();\n    let notEmpty = 0;\n    const ontologyItem = rootStore.ontology.ontology.find(onto => onto.class_name === category);\n    if (ontologyItem) {\n      const children = ontologyItem.children.map(group => {\n        var _defaultChildren$find;\n        const groupFrames = (_defaultChildren$find = defaultChildren.find(c => c.name === group.name)) === null || _defaultChildren$find === void 0 ? void 0 : _defaultChildren$find.frames;\n        const frames = {};\n        if (Array.isArray(groupFrames)) {\n          groupFrames.forEach(frame => {\n            if (frame) {\n              notEmpty += frame.shapes.length;\n              const shapes = {};\n              frame.shapes.forEach(shape => {\n                if (shape) {\n                  if (group.type === LandmarkEditType.KEYPOINT) {\n                    const point = shape;\n                    const {\n                      index,\n                      ...rest\n                    } = point;\n                    if (index || index === 0) {\n                      const realCategory = group && Array.isArray(group.categories) && group.categories.find(c => c.range && c.range.length === 2 && index >= c.range[0] && index <= c.range[1]);\n                      if (realCategory) {\n                        // fix pointCategory and key point info for saved data\n                        rest.pointCategory = realCategory.name;\n                        rest.isKeyPoint = realCategory.keys.includes(index);\n                        rest.visible = rest.visible !== false;\n                        shapes[index] = rest;\n                      }\n                    }\n                  } else if (group.type === LandmarkEditType.RECTANGLE) {\n                    const rectangle = shape;\n                    shapes[rectangle.id] = rectangle;\n                  }\n                }\n              });\n              frames[frame.frameIndex] = {\n                frameIndex: frame.frameIndex,\n                count: frame.shapes.length,\n                shapes,\n                attributes: frame.attributes\n              };\n            }\n          });\n        }\n        return {\n          name: group.name,\n          shapeType: group.type,\n          count: (groupFrames === null || groupFrames === void 0 ? void 0 : groupFrames.reduce((n, f) => n + (f ? f.shapes.length : 0), 0)) || 0,\n          frames\n        };\n      }) || [];\n      newInstances[id] = {\n        ...instanceData,\n        id,\n        notEmpty,\n        children\n      };\n    }\n    // add to categoryInstancesMap\n    if (!categoryInstancesMap[category]) {\n      categoryInstancesMap[category] = {};\n    }\n    categoryInstancesMap[category][id] = number;\n  });\n  return {\n    newInstances,\n    categoryInstancesMap\n  };\n}\nexport function getFrameShapes(instances, currentFrame, isRemove = false) {\n  const updateShapes = [];\n  const updatedCategories = [];\n  instances.filter(v => !!v).forEach(({\n    id,\n    category,\n    children\n  }) => {\n    if (Array.isArray(children)) {\n      children.forEach(group => {\n        const currentFrameGroup = group.frames[currentFrame];\n        if (currentFrameGroup) {\n          Object.keys(currentFrameGroup.shapes).forEach(key => {\n            const shape = group.shapeType === LandmarkEditType.KEYPOINT ? currentFrameGroup.shapes[Number(key)] : currentFrameGroup.shapes[key];\n            if (shape) {\n              const updateShape = {\n                frameIndex: currentFrame,\n                instanceId: id,\n                category,\n                groupName: group.name,\n                shape: isRemove ? undefined : shape,\n                shapeType: group.shapeType\n              };\n              if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                updateShapes.push({\n                  ...updateShape,\n                  index: Number(key)\n                });\n                const {\n                  position,\n                  pointCategory,\n                  index,\n                  isKeyPoint\n                } = shape;\n                if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n                  if (updatedCategories.findIndex(v => v.pointCategory === pointCategory) < 0) {\n                    updatedCategories.push({\n                      frameIndex: currentFrame,\n                      pointCategory,\n                      instanceId: id,\n                      groupName: group.name,\n                      category\n                    });\n                  }\n                }\n              } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                updateShapes.push({\n                  ...updateShape,\n                  id: key\n                });\n              }\n            }\n          });\n        }\n      });\n    }\n  });\n  return {\n    updateShapes,\n    updatedCategories\n  };\n}\nexport function initInstances(points, frameCount) {\n  const newPoints = points.map(point => ({\n    ...point,\n    index: point.index\n  }));\n  const ontologyItem = rootStore.ontology.ontology.find(onto => onto.class_name === 'Ontology');\n  const children = (ontologyItem === null || ontologyItem === void 0 ? void 0 : ontologyItem.children.filter(group => group.name !== 'default').map(group => ({\n    ...group,\n    name: group.name,\n    shape_type: group.type,\n    frames: Array.from({\n      length: frameCount\n    }).map((v, i) => i === 0 ? {\n      frameIndex: i,\n      count: points.length,\n      shapes: newPoints\n    } : undefined)\n  }))) || [];\n  return [{\n    id: uuid(),\n    index: 1,\n    color: '#5cdef0',\n    ontology: 'Ontology',\n    children\n  }];\n}\n\n// init ontology\nexport function initOntology(loadOntology) {\n  let list = [];\n  if (loadOntology.find(v => v.class_name)) {\n    list = loadOntology.map(o => ({\n      ...o,\n      children: o.children && o.children.map(child => {\n        let groupConfig = null;\n        let pointConfig = null;\n        if (typeof child.label_config === 'string') {\n          try {\n            groupConfig = JSON.parse(Base64.decode(child.label_config));\n          } catch (e) {\n            // parse error\n          }\n        }\n        if (typeof child.point_label_config === 'string') {\n          try {\n            pointConfig = JSON.parse(Base64.decode(child.point_label_config));\n          } catch (e) {\n            // parse error\n          }\n        }\n        return {\n          ...child,\n          display_color: o.display_color || '#5cdef0',\n          lines: child.lines ? child.lines.map(v => ({\n            ...v,\n            points: v.points.sort((a, b) => a - b)\n          })) : [],\n          label_config: groupConfig,\n          point_label_config: pointConfig\n        };\n      })\n    }));\n  } else {\n    // for older version\n    list = [{\n      class_name: 'Ontology',\n      display_color: '#5cdef0',\n      children: [{\n        name: 'default',\n        type: LandmarkEditType.KEYPOINT,\n        categories: loadOntology.map(v => ({\n          ...v,\n          isConnect: true\n        })),\n        lines: [],\n        count: loadOntology.reduce((total, pointCategory) => total + (pointCategory.range[1] - pointCategory.range[0] + 1), 0),\n        reference: '',\n        label_config: null,\n        point_label_config: null\n      }]\n    }];\n  }\n  ;\n  return list;\n}\nexport function resizeLabel(size, oldZoom, point, label, type = 'attr') {\n  if (!label || !label.children) {\n    return;\n  }\n  label.children.slice(-1)[0].set({\n    fontSize: size.fontSize / size.zoom,\n    shadowBlur: 2 / size.zoom,\n    shadowOffset: 2 / size.zoom\n  });\n  const scale = size.zoom / oldZoom;\n  const [x, y] = point;\n  const newWidth = size.width / scale;\n  const newHeight = size.height / scale;\n  if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n    label.children[0].size.width = newWidth;\n    label.children[0].size.height = newHeight;\n  }\n  let position = {\n    x,\n    y\n  };\n  if (type === 'label') {\n    position = {\n      x: x + newWidth / 2,\n      y: y - newHeight / 2\n    };\n  }\n  resetAttrLabelPosition(label, position);\n}\nexport function getRGBAColor(displayColor, alpha = 0.2) {\n  if (displayColor) {\n    return hexToRgba(displayColor, alpha);\n  }\n  return '#FFFFFF';\n}\n;\nexport function getInstanceFrames(instance) {\n  const frameStatus = {};\n  if (instance) {\n    instance.children.forEach(group => {\n      Object.values(group.frames).forEach(frame => {\n        if (frame && frame.count > 0) {\n          frameStatus[frame.frameIndex] = false;\n        }\n      });\n    });\n  }\n  return frameStatus;\n}\n;\nexport function validate(customCheck, params) {\n  return new Promise(async resolve => {\n    const {\n      resultLink\n    } = params;\n    const results = [];\n    let hasCustomError = false;\n    if (customCheck) {\n      // custom check\n      const customResult = await runCustomValidation(customCheck, resultLink);\n      customResult.results.forEach(result => {\n        results.push({\n          ...result,\n          ...(result.info && result.info),\n          warningType: ValidationType.CUSTOM\n        });\n      });\n      hasCustomError = customResult.hasCustomError;\n    }\n    resolve({\n      results,\n      hasCustomError\n    });\n  });\n}\nexport const getNextState = setState => new Promise(resolve => {\n  setState(preState => {\n    resolve(preState);\n    return preState;\n  });\n});","map":{"version":3,"names":["Base64","v4","uuid","hexToRgba","rootStore","runCustomValidation","LandmarkEditType","LabelItem","LabelFormat","LabelStyle","ValidationType","parseFrames","frames","split","map","f","i","url","trim","valid","index","parseFramesByPaylod","imageData","parsedFrames","v","undefined","getValuesLabel","fields","values","labelItems","content","length","name","label","visible","setting","labelFormat","DEFAULT","includes","ATTRIBUTE_KEYS","ATTRIBUTE_VALUES","resetAttrLabelPosition","position","x","y","labelStyle","children","slice","loadInstancesFromResult","instances","newInstances","categoryInstancesMap","forEach","instanceData","category","defaultChildren","number","id","notEmpty","ontologyItem","ontology","find","onto","class_name","group","_defaultChildren$find","groupFrames","c","Array","isArray","frame","shapes","shape","type","KEYPOINT","point","rest","realCategory","categories","range","pointCategory","isKeyPoint","keys","RECTANGLE","rectangle","frameIndex","count","attributes","shapeType","reduce","n","getFrameShapes","currentFrame","isRemove","updateShapes","updatedCategories","filter","currentFrameGroup","Object","key","Number","updateShape","instanceId","groupName","push","findIndex","initInstances","points","frameCount","newPoints","shape_type","from","color","initOntology","loadOntology","list","o","child","groupConfig","pointConfig","label_config","JSON","parse","decode","e","point_label_config","display_color","lines","sort","a","b","isConnect","total","reference","resizeLabel","size","oldZoom","set","fontSize","zoom","shadowBlur","shadowOffset","scale","newWidth","width","newHeight","height","getRGBAColor","displayColor","alpha","getInstanceFrames","instance","frameStatus","validate","customCheck","params","Promise","resolve","resultLink","results","hasCustomError","customResult","result","info","warningType","CUSTOM","getNextState","setState","preState"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/keypoint/utils.ts"],"sourcesContent":["import { Dispatch, SetStateAction } from 'react';\nimport { Field } from '@appen/easy-form/es/types';\nimport { Base64 } from 'js-base64';\nimport { v4 as uuid } from 'uuid';\nimport hexToRgba from 'hex-to-rgba';\nimport rootStore from './store/RootStore';\nimport { OntologyItem } from './store/OntologyStore';\nimport { runCustomValidation } from '../../utils';\nimport {\n  InstanceListItem, LandmarkEditType, Rectangle, UpdatedShape,\n  CategoryItem, PointListItem, InstanceAct, Shapes, CurrentShapes,\n  Points, CategoryInstancesMap, KeypointCategoryProps, Frame,\n  LabelItem, LabelFormat, LabelStyle, ValidationType, Image,\n} from './types';\nimport { IWarning } from '../common/tabs-menu/Validator';\n\n/* eslint-disable no-param-reassign */\n\nexport function parseFrames(frames: string | string[]) {\n  return (\n    typeof frames === 'string' ?\n      (frames as string).split(',') :\n      frames\n  ).map((f, i) => ({ url: f.trim(), valid: true, index: i }));\n}\n\nexport async function parseFramesByPaylod({ frames, imageData }: { frames?: string | string[]; imageData?: Image[] }) {\n  let parsedFrames: Image[] = [];\n  if (frames) {\n    parsedFrames = parseFrames(frames);\n  }\n  if (imageData) {\n    parsedFrames = imageData.map((v, index) => (typeof v === 'string' ? {\n      url: v,\n      valid: true,\n      index,\n    } : {\n      url: v.url,\n      valid: v.valid !== undefined ? v.valid : true,\n      index,\n    }));\n  }\n  return parsedFrames;\n}\n\nexport function getValuesLabel(fields: Field[] | undefined, values: any, labelItems: LabelItem[]) {\n  let content = '';\n  if (fields && values) {\n    for (let i = 0; i < fields.length; i += 1) {\n      const { name, label, visible } = fields[i];\n      if (rootStore.setting.labelFormat === LabelFormat.DEFAULT) {\n        content = `\\n${content}`;\n      }\n      if (visible || (!visible && values[name])) {\n        if (labelItems.includes(LabelItem.ATTRIBUTE_KEYS)) {\n          content += `${label || name}: `;\n        }\n\n        if (labelItems.includes(LabelItem.ATTRIBUTE_VALUES)) {\n          content += `${values[name] || ''}`;\n        }\n      }\n      if (i < fields.length - 1 && content) {\n        content += ';';\n      }\n    }\n  }\n  return content;\n};\n\nexport function resetAttrLabelPosition(label: paper.Group, position: { x: number, y: number }, visible?: boolean) {\n  if (visible !== undefined) {\n    label.visible = visible;\n  }\n\n  label.position.x = position.x;\n  label.position.y = position.y;\n  if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n    label.children[0].position.x = position.x;\n    label.children[0].position.y = position.y;\n  }\n  label.children.slice(-1)[0].position.x = position.x;\n  label.children.slice(-1)[0].position.y = position.y;\n}\n\n// load result\nexport function loadInstancesFromResult(instances: InstanceListItem[]) {\n  const newInstances: {[id: string]: InstanceAct} = {};\n  const categoryInstancesMap: CategoryInstancesMap = {};\n  instances.forEach((instanceData) => {\n    const { category, children: defaultChildren, number } = instanceData;\n    const id = instanceData.id || uuid();\n    let notEmpty = 0;\n\n    const ontologyItem = rootStore.ontology.ontology.find((onto) => onto.class_name === category);\n    if (ontologyItem) {\n      const children = ontologyItem.children.map((group) => {\n        const groupFrames = defaultChildren.find((c) => c.name === group.name)?.frames;\n        const frames: {[frameIndex: number]: Frame} = {};\n        if (Array.isArray(groupFrames)) {\n          groupFrames.forEach((frame) => {\n            if (frame) {\n              notEmpty += frame.shapes.length;\n              const shapes: Shapes = {};\n              frame.shapes.forEach((shape: any) => {\n                if (shape) {\n                  if (group.type === LandmarkEditType.KEYPOINT) {\n                    const point = shape as PointListItem;\n                    const { index, ...rest } = point;\n                    if (index || index === 0) {\n                      const realCategory = group && Array.isArray(group.categories) && group.categories.find((c) => c.range && c.range.length === 2 && index >= c.range[0] && index <= c.range[1]);\n                      if (realCategory) {\n                        // fix pointCategory and key point info for saved data\n                        rest.pointCategory = realCategory.name;\n                        rest.isKeyPoint = realCategory.keys.includes(index);\n                        rest.visible = rest.visible !== false;\n                        (shapes as Points)[index] = rest;\n                      }\n                    }\n                  } else if (group.type === LandmarkEditType.RECTANGLE) {\n                    const rectangle = shape as Rectangle;\n                    (shapes as CurrentShapes)[rectangle.id] = rectangle;\n                  }\n                }\n              });\n              frames[frame.frameIndex] = {\n                frameIndex: frame.frameIndex,\n                count: frame.shapes.length,\n                shapes,\n                attributes: frame.attributes\n              };\n            }\n          });\n        }\n        return {\n          name: group.name,\n          shapeType: group.type,\n          count: groupFrames?.reduce((n, f) => n + (f ? f.shapes.length : 0), 0) || 0,\n          frames,\n        };\n      }) || [];\n      newInstances[id] = {\n        ...instanceData,\n        id,\n        notEmpty,\n        children\n      };\n    }\n    // add to categoryInstancesMap\n    if (!categoryInstancesMap[category]) {\n      categoryInstancesMap[category] = {};\n    }\n    categoryInstancesMap[category][id] = number;\n  });\n  return {\n    newInstances,\n    categoryInstancesMap\n  };\n}\n\nexport function getFrameShapes(instances: InstanceAct[], currentFrame: number, isRemove = false) {\n  const updateShapes: UpdatedShape[] = [];\n  const updatedCategories: KeypointCategoryProps[] = [];\n  instances.filter((v) => !!v).forEach(({ id, category, children }) => {\n    if (Array.isArray(children)) {\n      children.forEach((group) => {\n        const currentFrameGroup = group.frames[currentFrame];\n        if (currentFrameGroup) {\n          Object.keys(currentFrameGroup.shapes).forEach((key) => {\n            const shape = group.shapeType === LandmarkEditType.KEYPOINT ?\n              (currentFrameGroup.shapes as Points)[Number(key)] :\n              (currentFrameGroup.shapes as CurrentShapes)[key];\n            if (shape) {\n              const updateShape = {\n                frameIndex: currentFrame,\n                instanceId: id,\n                category,\n                groupName: group.name,\n                shape: isRemove ? undefined : shape,\n                shapeType: group.shapeType\n              };\n              if (group.shapeType === LandmarkEditType.KEYPOINT) {\n                updateShapes.push({\n                  ...updateShape,\n                  index: Number(key),\n                });\n                const { position, pointCategory, index, isKeyPoint } = shape as PointListItem;\n                if (position !== undefined && pointCategory !== undefined && index !== undefined && isKeyPoint !== undefined) {\n                  if (updatedCategories.findIndex((v) => v.pointCategory === pointCategory) < 0) {\n                    updatedCategories.push({\n                      frameIndex: currentFrame,\n                      pointCategory,\n                      instanceId: id,\n                      groupName: group.name,\n                      category\n                    });\n                  }\n                }\n              } else if (group.shapeType === LandmarkEditType.RECTANGLE) {\n                updateShapes.push({\n                  ...updateShape,\n                  id: key,\n                });\n              }\n            }\n          });\n        }\n      });\n    }\n  });\n  return {\n    updateShapes,\n    updatedCategories\n  };\n}\n\nexport function initInstances(points: PointListItem[], frameCount: number) {\n  const newPoints = points.map((point) => ({ ...point, index: point.index }));\n  const ontologyItem = rootStore.ontology.ontology.find((onto) => onto.class_name === 'Ontology');\n  const children = ontologyItem?.children.filter((group) => group.name !== 'default').map((group) => (({\n    ...group,\n    name: group.name,\n    shape_type: group.type,\n    frames: Array.from({ length: frameCount }).map((v, i) => (i === 0 ? {\n      frameIndex: i,\n      count: points.length,\n      shapes: newPoints\n    } : undefined))\n  }))) || [];\n  return [{\n    id: uuid(),\n    index: 1,\n    color: '#5cdef0',\n    ontology: 'Ontology',\n    children\n  }];\n}\n\n// init ontology\nexport function initOntology(loadOntology: OntologyItem[] | CategoryItem[]) {\n  let list:OntologyItem[] = [];\n  if ((loadOntology as OntologyItem[]).find((v) => v.class_name)) {\n    list = (loadOntology as OntologyItem[]).map((o) => ({\n      ...o,\n      children: o.children && o.children.map((child) => {\n        let groupConfig = null;\n        let pointConfig = null;\n        if (typeof child.label_config === 'string') {\n          try {\n            groupConfig = JSON.parse(Base64.decode(child.label_config));\n          } catch (e) {\n            // parse error\n          }\n        }\n        if (typeof child.point_label_config === 'string') {\n          try {\n            pointConfig = JSON.parse(Base64.decode(child.point_label_config));\n          } catch (e) {\n            // parse error\n          }\n        }\n        return {\n          ...child,\n          display_color: o.display_color || '#5cdef0',\n          lines: child.lines ? child.lines.map((v) => ({\n            ...v,\n            points: v.points.sort((a, b) => a - b)\n          })) : [],\n          label_config: groupConfig,\n          point_label_config: pointConfig\n        };\n      })\n    }));\n  } else {\n    // for older version\n    list = [\n      {\n        class_name: 'Ontology',\n        display_color: '#5cdef0',\n        children: [\n          {\n            name: 'default',\n            type: LandmarkEditType.KEYPOINT,\n            categories: ((loadOntology as CategoryItem[]).map((v) => ({ ...v, isConnect: true })) as CategoryItem[]),\n            lines: [],\n            count: (loadOntology as CategoryItem[]).reduce((total: number, pointCategory: CategoryItem) => total + (pointCategory.range[1] - pointCategory.range[0] + 1), 0),\n            reference: '',\n            label_config: null,\n            point_label_config: null,\n          }\n        ]\n      },\n    ];\n  };\n  return list;\n}\n\nexport function resizeLabel(\n  size: {width: number, height: number, zoom: number, fontSize: number},\n  oldZoom: number,\n  point: number[],\n  label: paper.Item,\n  type = 'attr'\n) {\n  if (!label || !label.children) {\n    return;\n  }\n  (label.children.slice(-1)[0] as paper.PointText).set({\n    fontSize: size.fontSize / size.zoom,\n    shadowBlur: 2 / size.zoom,\n    shadowOffset: 2 / size.zoom,\n  });\n  const scale = size.zoom / oldZoom;\n  const [x, y] = point;\n  const newWidth = size.width / scale;\n  const newHeight = size.height / scale;\n  if (rootStore.setting.labelStyle === LabelStyle.DEFAULT) {\n    (label.children[0] as paper.Shape).size.width = newWidth;\n    (label.children[0] as paper.Shape).size.height = newHeight;\n  }\n  let position = { x, y };\n  if (type === 'label') {\n    position = {\n      x: x + newWidth / 2,\n      y: y - newHeight / 2\n    };\n  }\n  resetAttrLabelPosition(label as paper.Group, position);\n}\n\nexport function getRGBAColor(displayColor?: string, alpha = 0.2) {\n  if (displayColor) {\n    return hexToRgba(displayColor, alpha);\n  }\n  return '#FFFFFF';\n};\n\nexport function getInstanceFrames(instance?: InstanceAct) {\n  const frameStatus: { [frameIndex: number]: boolean } = {};\n  if (instance) {\n    instance.children.forEach((group) => {\n      Object.values(group.frames).forEach((frame) => {\n        if (frame && frame.count > 0) {\n          frameStatus[frame.frameIndex] = false;\n        }\n      });\n    });\n  }\n  return frameStatus;\n};\n\nexport function validate(\n  customCheck: string[],\n  params: {\n    resultLink?: string;\n  },\n) {\n  return new Promise<{\n    results: IWarning[];\n    hasCustomError: boolean;\n  }>(async (resolve) => {\n    const { resultLink } = params;\n    const results: IWarning[] = [];\n    let hasCustomError = false;\n\n    if (customCheck) {\n      // custom check\n      const customResult = await runCustomValidation(customCheck, resultLink!);\n      customResult.results.forEach((result) => {\n        results.push({ ...result, ...result.info && result.info, warningType: ValidationType.CUSTOM });\n      });\n      hasCustomError = customResult.hasCustomError;\n    }\n\n    resolve({ results, hasCustomError });\n  });\n}\n\nexport const getNextState = <S>(setState: Dispatch<SetStateAction<S>>) => new Promise<S>((resolve) => {\n  setState((preState) => {\n    resolve(preState);\n    return preState;\n  });\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}