{"ast":null,"code":"import { cloneDeep } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { notification } from 'antd';\nimport { makeAutoObservable, observable, toJS } from 'mobx';\nimport { parseTextgrid } from 'praatio';\nimport audioBufferToWav from 'audiobuffer-to-wav';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport AnalyseStore from './AnalyseStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport { loadInstancesFromResult } from '../utils';\nimport i18n from '../locales';\nimport { ReviewResult, PraatAnnotationType, AnnotationType } from '../types';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, isTemplatePreview } from '../../../utils/tool-mode';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in template preview mode\n   */\n  get isTemplatePreview() {\n    return isTemplatePreview(this.jobProxy.toolMode);\n  }\n  constructor() {\n    this.ontology = void 0;\n    this.undo = void 0;\n    this.analyse = void 0;\n    this.setting = void 0;\n    this.review = void 0;\n    this.instance = void 0;\n    this.url = void 0;\n    /**\n     * job proxy\n     */\n    this.jobProxy = void 0;\n    /**\n     * initial data copy\n     */\n    this.initialData = null;\n    /**\n     * is tool initialized\n     */\n    this.initialized = false;\n    /**\n     * check missing character\n     */\n    this.checkMissingCharacter = false;\n    /**\n     * get instance statistics\n     */\n    this.getInstanceStatistics = () => {\n      const {\n        categories\n      } = this.ontology;\n      const {\n        placement: {\n          duration\n        }\n      } = this.analyse;\n      const data = {\n        elements: [],\n        categories: categories.map(({\n          className\n        }) => className),\n        shapes: new Set(),\n        summary: {},\n        duration: duration * 1000,\n        // file duration\n        approvedWordCount: 0,\n        rejectedWordCount: 0,\n        approvedCharCount: 0,\n        rejectedCharCount: 0,\n        wordCount: 0,\n        charCount: 0\n      };\n      const instancesList = Object.values(this.instance.instances).filter(v => !!v);\n      for (let i = 0; i < instancesList.length; i += 1) {\n        const {\n          id,\n          category,\n          shapeType,\n          start,\n          end,\n          text\n        } = instancesList[i];\n        const charCount = text ? text.length : 0;\n        const wordCount = text && text.indexOf(' ') >= 0 ? text.split(' ').length : charCount;\n        const key = `${shapeType}_${category}`;\n        if (!data.summary[key]) {\n          data.summary[key] = {\n            ids: [id],\n            category,\n            shape: shapeType,\n            wordCount,\n            charCount\n          };\n        } else {\n          data.summary[key].wordCount += wordCount;\n          data.summary[key].charCount += charCount;\n          data.summary[key].ids.push(id);\n        }\n        data.elements.push({\n          id,\n          category,\n          start: start * 1000,\n          ...(end && {\n            end: end * 1000\n          }),\n          text\n        });\n        data.shapes.add(shapeType);\n        data.wordCount += wordCount;\n        data.charCount += charCount;\n        const review = this.review.getReview(id);\n        if (review && review.result === ReviewResult.REJECT) {\n          data.rejectedCharCount += charCount;\n          data.rejectedWordCount += wordCount;\n        } else {\n          data.approvedCharCount += charCount;\n          data.approvedWordCount += wordCount;\n        }\n      }\n      return {\n        ...data,\n        shapes: Array.from(data.shapes)\n      };\n    };\n    /**\n     * save file\n     * @param file\n     */\n    this.saveFile = file => this.jobProxy.saveFile(file);\n    makeAutoObservable(this, {\n      url: observable,\n      initialized: observable\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.analyse = new AnalyseStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n  }\n  async init(payload) {\n    // init urls\n    try {\n      if (!payload.audio) {\n        throw new Error();\n      }\n      const urls = payload.audio.split(',');\n      this.url = urls[0];\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('AUDIO_LOAD_ERROR')\n      });\n      this.setting.setLoading(false);\n    }\n    // init job proxy\n    this.jobProxy = payload.jobProxy;\n\n    // init common stores\n    try {\n      this.ontology.init(payload);\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR')\n      });\n    }\n    this.setting.init(payload);\n\n    // init analyse\n    await this.analyse.init(payload, this.url);\n\n    // load result & init instances\n    try {\n      await this.loadResult(payload.ontology, payload.review_from);\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR')\n      });\n    }\n    // load & init reviews\n    try {\n      await this.loadReviews(payload);\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR')\n      });\n    }\n    this.initialized = true;\n    this.checkMissingCharacter = payload.check_missing_character === 'true' || payload.check_missing_character === true;\n  }\n\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology, reviewFrom) {\n    const savedResult = await this.jobProxy.loadSavedResult();\n    let reviewFromResult;\n    if (reviewFrom) {\n      const foramt = reviewFrom.split('.').pop();\n      if ((foramt === null || foramt === void 0 ? void 0 : foramt.toLocaleLowerCase()) === 'textgrid') {\n        reviewFromResult = await this.loadTextGrid(reviewFrom, ontology);\n      } else {\n        reviewFromResult = await this.jobProxy.loadReviewFrom();\n      }\n    }\n    // copy initial data\n    if (reviewFromResult) {\n      this.initialData = cloneDeep({\n        instances: reviewFromResult.instances\n      });\n    }\n    const result = savedResult || reviewFromResult;\n    // load instance\n    this.instance.init((result === null || result === void 0 ? void 0 : result.instances) ? loadInstancesFromResult(result === null || result === void 0 ? void 0 : result.instances, ontology) : []);\n    if (!result) {\n      return;\n    }\n    if (result.auditId) {\n      this.jobProxy.setAuditId(result.auditId);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  loadTextGrid(url, ontology) {\n    return new Promise((resolve, reject) => {\n      fetch(url).then(res => res.arrayBuffer()).then(async arrayBuffer => {\n        var _tg;\n        let tg;\n        try {\n          tg = parseTextgrid(Buffer.from(arrayBuffer));\n        } catch (error) {\n          notification.error({\n            message: i18n.translate('TEXTGRID_LOAD_ERROR')\n          });\n        }\n        const instances = [];\n        if (((_tg = tg) === null || _tg === void 0 ? void 0 : _tg.tierDict) && ontology) {\n          ontology.forEach((o, n) => {\n            var _tierData$entryList;\n            const tierData = tg.tierDict[o.class_name];\n            if ((tierData === null || tierData === void 0 ? void 0 : tierData.tierType) && PraatAnnotationType[o.type.toLocaleLowerCase()] === (tierData === null || tierData === void 0 ? void 0 : tierData.tierType) && ((_tierData$entryList = tierData.entryList) === null || _tierData$entryList === void 0 ? void 0 : _tierData$entryList.length) > 0) {\n              const entryList = [];\n              tierData.entryList.sort((a, b) => a[0] - b[0]).forEach((item, m) => {\n                entryList.push(item);\n                const next = tierData.entryList[m + 1];\n                if (next && item[1] !== next[0]) {\n                  entryList.push([item[1], next[0], '']);\n                }\n              });\n              const isSegment = o.type === AnnotationType.SEGMENT;\n              const tierInstances = entryList.map(entry => ({\n                id: uuidv4(),\n                start: entry[0],\n                ...(isSegment && {\n                  end: entry[1]\n                }),\n                shapeType: o.type,\n                category: o.class_name,\n                categoryIndex: n,\n                text: isSegment ? entry[2] : entry[1]\n              })).sort((a, b) => a.start - b.start);\n              if (isSegment) {\n                if (tierInstances[0].start > 0) {\n                  tierInstances.unshift({\n                    id: uuidv4(),\n                    start: 0,\n                    end: tierInstances[0].start,\n                    shapeType: o.type,\n                    category: o.class_name,\n                    categoryIndex: n,\n                    text: ''\n                  });\n                }\n                if (tierInstances[tierInstances.length - 1].end < tierData.maxTimestamp) {\n                  tierInstances.push({\n                    id: uuidv4(),\n                    start: tierInstances[tierInstances.length - 1].end,\n                    end: tierData.maxTimestamp,\n                    shapeType: o.type,\n                    category: o.class_name,\n                    categoryIndex: n,\n                    text: ''\n                  });\n                }\n              }\n              instances.push(...tierInstances);\n            } else if (o.type === AnnotationType.SEGMENT) {\n              const {\n                placement: {\n                  duration\n                }\n              } = this.analyse;\n              instances.push({\n                id: uuidv4(),\n                start: 0,\n                end: duration,\n                shapeType: o.type,\n                category: o.class_name,\n                categoryIndex: n,\n                text: ''\n              });\n            }\n          });\n        }\n        resolve({\n          instances\n        });\n      }).catch(error => {\n        console.log('load textgrid error: ', error);\n        resolve(false);\n      });\n    });\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const newInstances = Object.values(toJS(this.instance.instances)).map(({\n      id,\n      start,\n      end,\n      shapeType,\n      category,\n      text\n    }) => ({\n      id,\n      start,\n      end,\n      shapeType,\n      category,\n      text\n    }));\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy.saveResultStat(statData);\n    return this.jobProxy.saveResult({\n      auditId: this.jobProxy.auditFileId,\n      instances: newInstances,\n      statistics\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload) {\n    this.review.init(payload.jobProxy.toolMode, payload.issue_types);\n    const reviews = await this.jobProxy.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews(submit = false) {\n    const {\n      reviewsResult\n    } = this.review;\n    return this.jobProxy.saveReviews(reviewsResult, submit);\n  }\n  setlocalUrl(buffer) {\n    const wav = audioBufferToWav(buffer);\n    const blob = new Blob([wav], {\n      type: 'audio/wav'\n    });\n    this.url = window.URL.createObjectURL(blob);\n  }\n}\nconst rootStore = new RootStore();\nexport default rootStore;","map":{"version":3,"names":["cloneDeep","v4","uuidv4","notification","makeAutoObservable","observable","toJS","parseTextgrid","audioBufferToWav","OntologyStore","UndoStore","AnalyseStore","SettingsStore","ReviewsStore","InstanceStore","loadInstancesFromResult","i18n","ReviewResult","PraatAnnotationType","AnnotationType","isAnnotationReadonly","isReviewEditable","isRework","isPreview","isTemplatePreview","RootStore","readonly","jobProxy","toolMode","reviewable","constructor","ontology","undo","analyse","setting","review","instance","url","initialData","initialized","checkMissingCharacter","getInstanceStatistics","categories","placement","duration","data","elements","map","className","shapes","Set","summary","approvedWordCount","rejectedWordCount","approvedCharCount","rejectedCharCount","wordCount","charCount","instancesList","Object","values","instances","filter","v","i","length","id","category","shapeType","start","end","text","indexOf","split","key","ids","shape","push","add","getReview","result","REJECT","Array","from","saveFile","file","init","payload","audio","Error","urls","error","message","translate","setLoading","loadResult","review_from","loadReviews","check_missing_character","reviewFrom","savedResult","loadSavedResult","reviewFromResult","foramt","pop","toLocaleLowerCase","loadTextGrid","loadReviewFrom","auditId","setAuditId","Promise","resolve","reject","fetch","then","res","arrayBuffer","_tg","tg","Buffer","tierDict","forEach","o","n","_tierData$entryList","tierData","class_name","tierType","type","entryList","sort","a","b","item","m","next","isSegment","SEGMENT","tierInstances","entry","categoryIndex","unshift","maxTimestamp","catch","console","log","saveResult","submit","newInstances","statData","statistics","saveResultStat","auditFileId","issue_types","reviews","setInitialData","saveReviews","reviewsResult","setlocalUrl","buffer","wav","blob","Blob","window","URL","createObjectURL","rootStore"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/store/RootStore.ts"],"sourcesContent":["import { cloneDeep } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { notification } from 'antd';\nimport { makeAutoObservable, observable, toJS } from 'mobx';\nimport { parseTextgrid } from 'praatio';\nimport audioBufferToWav from 'audiobuffer-to-wav';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport AnalyseStore from './AnalyseStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport { loadInstancesFromResult } from '../utils';\nimport i18n from '../locales';\nimport { Payload, Statistic, InstanceItem, Ontology, ReviewResult, Instance, PraatAnnotationType, AnnotationType } from '../types';\nimport JobProxy from '../../../libs/JobProxy';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, isTemplatePreview } from '../../../utils/tool-mode';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  ontology: OntologyStore;\n\n  undo: UndoStore;\n\n  analyse: AnalyseStore;\n\n  setting: SettingsStore;\n\n  review: ReviewsStore;\n\n  instance: InstanceStore;\n\n  url?: string;\n\n  /**\n   * job proxy\n   */\n  jobProxy?: JobProxy;\n\n  /**\n   * initial data copy\n   */\n  initialData: any = null;\n\n  /**\n   * is tool initialized\n   */\n  initialized = false;\n\n  /**\n   * check missing character\n   */\n  checkMissingCharacter = false;\n\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in template preview mode\n   */\n  get isTemplatePreview() {\n    return isTemplatePreview(this.jobProxy!.toolMode);\n  }\n\n  constructor() {\n    makeAutoObservable(this, {\n      url: observable,\n      initialized: observable,\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.analyse = new AnalyseStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n  }\n\n  async init(payload: Payload) {\n    // init urls\n    try {\n      if (!payload.audio) {\n        throw new Error();\n      }\n      const urls = payload.audio.split(',');\n      this.url = urls[0];\n    } catch (error) {\n      notification.error({ message: i18n.translate('AUDIO_LOAD_ERROR') });\n      this.setting.setLoading(false);\n    }\n    // init job proxy\n    this.jobProxy = payload.jobProxy;\n\n    // init common stores\n    try {\n      this.ontology.init(payload);\n    } catch (error) {\n      notification.error({ message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR') });\n    }\n    this.setting.init(payload);\n\n    // init analyse\n    await this.analyse.init(payload, this.url!);\n\n    // load result & init instances\n    try {\n      await this.loadResult(payload.ontology, payload.review_from);\n    } catch (error) {\n      notification.error({ message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR') });\n    }\n    // load & init reviews\n    try {\n      await this.loadReviews(payload);\n    } catch (error) {\n      notification.error({ message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR') });\n    }\n    this.initialized = true;\n    this.checkMissingCharacter = payload.check_missing_character === 'true' || payload.check_missing_character === true;\n  }\n\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology: Ontology[], reviewFrom?: string) {\n    const savedResult = await this.jobProxy!.loadSavedResult();\n    let reviewFromResult;\n    if (reviewFrom) {\n      const foramt = reviewFrom.split('.').pop();\n      if (foramt?.toLocaleLowerCase() === 'textgrid') {\n        reviewFromResult = await this.loadTextGrid(reviewFrom, ontology);\n      } else {\n        reviewFromResult = await this.jobProxy!.loadReviewFrom();\n      }\n    }\n    // copy initial data\n    if (reviewFromResult) {\n      this.initialData = cloneDeep({\n        instances: reviewFromResult.instances,\n      });\n    }\n    const result = savedResult || reviewFromResult;\n    // load instance\n    this.instance.init(result?.instances ? loadInstancesFromResult(result?.instances, ontology) : []);\n    if (!result) {\n      return;\n    }\n    if (result.auditId) {\n      this.jobProxy!.setAuditId(result.auditId);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  loadTextGrid(url: string, ontology: Ontology[]) {\n    return new Promise((resolve, reject) => {\n      fetch(url)\n        .then((res) => res.arrayBuffer())\n        .then(async (arrayBuffer) => {\n          let tg: any;\n          try {\n            tg = parseTextgrid(Buffer.from(arrayBuffer));\n          } catch (error) {\n            notification.error({ message: i18n.translate('TEXTGRID_LOAD_ERROR') });\n          }\n          const instances: Instance[] = [];\n          if (tg?.tierDict && ontology) {\n            ontology.forEach((o, n) => {\n              const tierData = tg.tierDict[o.class_name];\n              if (\n                tierData?.tierType &&\n                PraatAnnotationType[o.type.toLocaleLowerCase()] === tierData?.tierType &&\n                tierData.entryList?.length > 0\n              ) {\n                const entryList:(number|string)[][] = [];\n                (tierData.entryList as (number|string)[][])\n                  .sort((a: (number|string)[], b: (number|string)[]) => (a[0] as number) - (b[0] as number))\n                  .forEach((item, m) => {\n                    entryList.push(item);\n                    const next = tierData.entryList[m + 1];\n                    if (next && item[1] !== next[0]) {\n                      entryList.push([item[1], next[0], '']);\n                    }\n                  });\n                const isSegment = o.type === AnnotationType.SEGMENT;\n                const tierInstances = entryList.map((entry: (string | number)[]) => ({\n                  id: uuidv4(),\n                  start: entry[0] as number,\n                  ...(isSegment && {\n                    end: entry[1] as number,\n                  }),\n                  shapeType: o.type,\n                  category: o.class_name,\n                  categoryIndex: n,\n                  text: (isSegment ? entry[2] : entry[1]) as string\n                })).sort((a : Instance, b: Instance) => a.start - b.start);\n                if (isSegment) {\n                  if (tierInstances[0].start > 0) {\n                    tierInstances.unshift({\n                      id: uuidv4(),\n                      start: 0,\n                      end: tierInstances[0].start,\n                      shapeType: o.type,\n                      category: o.class_name,\n                      categoryIndex: n,\n                      text: '',\n                    });\n                  }\n                  if (tierInstances[tierInstances.length - 1].end! < tierData.maxTimestamp) {\n                    tierInstances.push({\n                      id: uuidv4(),\n                      start: tierInstances[tierInstances.length - 1].end!,\n                      end: tierData.maxTimestamp,\n                      shapeType: o.type,\n                      category: o.class_name,\n                      categoryIndex: n,\n                      text: '',\n                    });\n                  }\n                }\n                instances.push(...tierInstances);\n              } else if (o.type === AnnotationType.SEGMENT) {\n                const { placement: { duration } } = this.analyse;\n                instances.push({\n                  id: uuidv4(),\n                  start: 0,\n                  end: duration,\n                  shapeType: o.type,\n                  category: o.class_name,\n                  categoryIndex: n,\n                  text: '',\n                });\n              }\n            });\n          }\n          resolve({ instances });\n        }).catch((error) => {\n          console.log('load textgrid error: ', error);\n          resolve(false);\n        });\n    });\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const newInstances: InstanceItem[] = Object.values(toJS(this.instance.instances))\n      .map(({ id, start, end, shapeType, category, text }) => ({ id, start, end, shapeType, category, text }));\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy!.saveResultStat(statData);\n    return this.jobProxy!.saveResult({\n      auditId: this.jobProxy!.auditFileId,\n      instances: newInstances,\n      statistics,\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload: Payload) {\n    this.review.init(payload.jobProxy.toolMode, payload.issue_types);\n    const reviews = await this.jobProxy!.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews(submit = false) {\n    const { reviewsResult } = this.review;\n    return this.jobProxy!.saveReviews(reviewsResult, submit);\n  }\n\n  /**\n   * get instance statistics\n   */\n  getInstanceStatistics = () => {\n    const { categories } = this.ontology;\n    const { placement: { duration } } = this.analyse;\n    const data: Statistic = {\n      elements: [],\n      categories: categories.map(({ className }) => className),\n      shapes: new Set(),\n      summary: {},\n      duration: duration * 1000, // file duration\n      approvedWordCount: 0,\n      rejectedWordCount: 0,\n      approvedCharCount: 0,\n      rejectedCharCount: 0,\n      wordCount: 0,\n      charCount: 0,\n    };\n\n    const instancesList = Object.values(this.instance.instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, category, shapeType, start, end, text } = instancesList[i];\n      const charCount = text ? text.length : 0;\n      const wordCount = text && text.indexOf(' ') >= 0 ? text.split(' ').length : charCount;\n      const key = `${shapeType}_${category}`;\n      if (!data.summary[key]) {\n        data.summary[key] = {\n          ids: [id],\n          category,\n          shape: shapeType,\n          wordCount,\n          charCount,\n        };\n      } else {\n        data.summary[key].wordCount += wordCount;\n        data.summary[key].charCount += charCount;\n        data.summary[key].ids.push(id);\n      }\n      data.elements.push({\n        id,\n        category,\n        start: start * 1000,\n        ...end && {\n          end: end * 1000\n        },\n        text\n      });\n      data.shapes.add(shapeType);\n      data.wordCount += wordCount;\n      data.charCount += charCount;\n      const review = this.review.getReview(id);\n      if (review && review.result === ReviewResult.REJECT) {\n        data.rejectedCharCount += charCount;\n        data.rejectedWordCount += wordCount;\n      } else {\n        data.approvedCharCount += charCount;\n        data.approvedWordCount += wordCount;\n      }\n    }\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n    };\n  };\n\n  /**\n   * save file\n   * @param file\n   */\n  saveFile = (file: File) => this.jobProxy!.saveFile(file);\n\n  setlocalUrl(buffer: AudioBuffer) {\n    const wav = audioBufferToWav(buffer);\n    const blob = new Blob([wav], { type: 'audio/wav' });\n    this.url = window.URL.createObjectURL(blob);\n  }\n}\n\nconst rootStore = new RootStore();\nexport type RootStoreType = typeof rootStore;\nexport default rootStore;\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,QAAQ;AAClC,SAASC,EAAE,IAAIC,MAAM,QAAQ,MAAM;AACnC,SAASC,YAAY,QAAQ,MAAM;AACnC,SAASC,kBAAkB,EAAEC,UAAU,EAAEC,IAAI,QAAQ,MAAM;AAC3D,SAASC,aAAa,QAAQ,SAAS;AACvC,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,YAAY,MAAM,gBAAgB;AACzC,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,YAAY,MAAM,gBAAgB;AACzC,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,SAASC,uBAAuB,QAAQ,UAAU;AAClD,OAAOC,IAAI,MAAM,YAAY;AAC7B,SAAqDC,YAAY,EAAYC,mBAAmB,EAAEC,cAAc,QAAQ,UAAU;AAElI,SAASC,oBAAoB,EAAEC,gBAAgB,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,iBAAiB,QAAQ,0BAA0B;;AAEzH;AACA;AACA;AACA;AACA,MAAMC,SAAS,CAAC;EAmCd;AACF;AACA;EACE,IAAIC,QAAQA,CAAA,EAAG;IACb,OAAON,oBAAoB,CAAC,IAAI,CAACO,QAAQ,CAAEC,QAAQ,CAAC;EACtD;;EAEA;AACF;AACA;EACE,IAAIC,UAAUA,CAAA,EAAG;IACf,OAAOR,gBAAgB,CAAC,IAAI,CAACM,QAAQ,CAAEC,QAAQ,CAAC;EAClD;;EAEA;AACF;AACA;EACE,IAAIN,QAAQA,CAAA,EAAG;IACb,OAAOA,QAAQ,CAAC,IAAI,CAACK,QAAQ,CAAEC,QAAQ,CAAC;EAC1C;;EAEA;AACF;AACA;EACE,IAAIL,SAASA,CAAA,EAAG;IACd,OAAOA,SAAS,CAAC,IAAI,CAACI,QAAQ,CAAEC,QAAQ,CAAC;EAC3C;;EAEA;AACF;AACA;EACE,IAAIJ,iBAAiBA,CAAA,EAAG;IACtB,OAAOA,iBAAiB,CAAC,IAAI,CAACG,QAAQ,CAAEC,QAAQ,CAAC;EACnD;EAEAE,WAAWA,CAAA,EAAG;IAAA,KArEdC,QAAQ;IAAA,KAERC,IAAI;IAAA,KAEJC,OAAO;IAAA,KAEPC,OAAO;IAAA,KAEPC,MAAM;IAAA,KAENC,QAAQ;IAAA,KAERC,GAAG;IAEH;AACF;AACA;IAFE,KAGAV,QAAQ;IAER;AACF;AACA;IAFE,KAGAW,WAAW,GAAQ,IAAI;IAEvB;AACF;AACA;IAFE,KAGAC,WAAW,GAAG,KAAK;IAEnB;AACF;AACA;IAFE,KAGAC,qBAAqB,GAAG,KAAK;IAsP7B;AACF;AACA;IAFE,KAGAC,qBAAqB,GAAG,MAAM;MAC5B,MAAM;QAAEC;MAAW,CAAC,GAAG,IAAI,CAACX,QAAQ;MACpC,MAAM;QAAEY,SAAS,EAAE;UAAEC;QAAS;MAAE,CAAC,GAAG,IAAI,CAACX,OAAO;MAChD,MAAMY,IAAe,GAAG;QACtBC,QAAQ,EAAE,EAAE;QACZJ,UAAU,EAAEA,UAAU,CAACK,GAAG,CAAC,CAAC;UAAEC;QAAU,CAAC,KAAKA,SAAS,CAAC;QACxDC,MAAM,EAAE,IAAIC,GAAG,CAAC,CAAC;QACjBC,OAAO,EAAE,CAAC,CAAC;QACXP,QAAQ,EAAEA,QAAQ,GAAG,IAAI;QAAE;QAC3BQ,iBAAiB,EAAE,CAAC;QACpBC,iBAAiB,EAAE,CAAC;QACpBC,iBAAiB,EAAE,CAAC;QACpBC,iBAAiB,EAAE,CAAC;QACpBC,SAAS,EAAE,CAAC;QACZC,SAAS,EAAE;MACb,CAAC;MAED,MAAMC,aAAa,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACxB,QAAQ,CAACyB,SAAS,CAAC,CAACC,MAAM,CAAEC,CAAC,IAAK,CAAC,CAACA,CAAC,CAAC;MAC/E,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,aAAa,CAACO,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;QAChD,MAAM;UAAEE,EAAE;UAAEC,QAAQ;UAAEC,SAAS;UAAEC,KAAK;UAAEC,GAAG;UAAEC;QAAK,CAAC,GAAGb,aAAa,CAACM,CAAC,CAAC;QACtE,MAAMP,SAAS,GAAGc,IAAI,GAAGA,IAAI,CAACN,MAAM,GAAG,CAAC;QACxC,MAAMT,SAAS,GAAGe,IAAI,IAAIA,IAAI,CAACC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC,CAACR,MAAM,GAAGR,SAAS;QACrF,MAAMiB,GAAG,GAAG,GAAGN,SAAS,IAAID,QAAQ,EAAE;QACtC,IAAI,CAACtB,IAAI,CAACM,OAAO,CAACuB,GAAG,CAAC,EAAE;UACtB7B,IAAI,CAACM,OAAO,CAACuB,GAAG,CAAC,GAAG;YAClBC,GAAG,EAAE,CAACT,EAAE,CAAC;YACTC,QAAQ;YACRS,KAAK,EAAER,SAAS;YAChBZ,SAAS;YACTC;UACF,CAAC;QACH,CAAC,MAAM;UACLZ,IAAI,CAACM,OAAO,CAACuB,GAAG,CAAC,CAAClB,SAAS,IAAIA,SAAS;UACxCX,IAAI,CAACM,OAAO,CAACuB,GAAG,CAAC,CAACjB,SAAS,IAAIA,SAAS;UACxCZ,IAAI,CAACM,OAAO,CAACuB,GAAG,CAAC,CAACC,GAAG,CAACE,IAAI,CAACX,EAAE,CAAC;QAChC;QACArB,IAAI,CAACC,QAAQ,CAAC+B,IAAI,CAAC;UACjBX,EAAE;UACFC,QAAQ;UACRE,KAAK,EAAEA,KAAK,GAAG,IAAI;UACnB,IAAGC,GAAG,IAAI;YACRA,GAAG,EAAEA,GAAG,GAAG;UACb,CAAC;UACDC;QACF,CAAC,CAAC;QACF1B,IAAI,CAACI,MAAM,CAAC6B,GAAG,CAACV,SAAS,CAAC;QAC1BvB,IAAI,CAACW,SAAS,IAAIA,SAAS;QAC3BX,IAAI,CAACY,SAAS,IAAIA,SAAS;QAC3B,MAAMtB,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC4C,SAAS,CAACb,EAAE,CAAC;QACxC,IAAI/B,MAAM,IAAIA,MAAM,CAAC6C,MAAM,KAAK/D,YAAY,CAACgE,MAAM,EAAE;UACnDpC,IAAI,CAACU,iBAAiB,IAAIE,SAAS;UACnCZ,IAAI,CAACQ,iBAAiB,IAAIG,SAAS;QACrC,CAAC,MAAM;UACLX,IAAI,CAACS,iBAAiB,IAAIG,SAAS;UACnCZ,IAAI,CAACO,iBAAiB,IAAII,SAAS;QACrC;MACF;MAEA,OAAO;QACL,GAAGX,IAAI;QACPI,MAAM,EAAEiC,KAAK,CAACC,IAAI,CAACtC,IAAI,CAACI,MAAM;MAChC,CAAC;IACH,CAAC;IAED;AACF;AACA;AACA;IAHE,KAIAmC,QAAQ,GAAIC,IAAU,IAAK,IAAI,CAAC1D,QAAQ,CAAEyD,QAAQ,CAACC,IAAI,CAAC;IAvRtDjF,kBAAkB,CAAC,IAAI,EAAE;MACvBiC,GAAG,EAAEhC,UAAU;MACfkC,WAAW,EAAElC;IACf,CAAC,CAAC;IACF,IAAI,CAAC0B,QAAQ,GAAG,IAAItB,aAAa,CAAC,IAAI,CAAC;IACvC,IAAI,CAACuB,IAAI,GAAG,IAAItB,SAAS,CAAC,IAAI,CAAC;IAC/B,IAAI,CAACuB,OAAO,GAAG,IAAItB,YAAY,CAAC,IAAI,CAAC;IACrC,IAAI,CAACuB,OAAO,GAAG,IAAItB,aAAa,CAAC,IAAI,CAAC;IACtC,IAAI,CAACuB,MAAM,GAAG,IAAItB,YAAY,CAAC,IAAI,CAAC;IACpC,IAAI,CAACuB,QAAQ,GAAG,IAAItB,aAAa,CAAC,IAAI,CAAC;EACzC;EAEA,MAAMwE,IAAIA,CAACC,OAAgB,EAAE;IAC3B;IACA,IAAI;MACF,IAAI,CAACA,OAAO,CAACC,KAAK,EAAE;QAClB,MAAM,IAAIC,KAAK,CAAC,CAAC;MACnB;MACA,MAAMC,IAAI,GAAGH,OAAO,CAACC,KAAK,CAACf,KAAK,CAAC,GAAG,CAAC;MACrC,IAAI,CAACpC,GAAG,GAAGqD,IAAI,CAAC,CAAC,CAAC;IACpB,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdxF,YAAY,CAACwF,KAAK,CAAC;QAAEC,OAAO,EAAE5E,IAAI,CAAC6E,SAAS,CAAC,kBAAkB;MAAE,CAAC,CAAC;MACnE,IAAI,CAAC3D,OAAO,CAAC4D,UAAU,CAAC,KAAK,CAAC;IAChC;IACA;IACA,IAAI,CAACnE,QAAQ,GAAG4D,OAAO,CAAC5D,QAAQ;;IAEhC;IACA,IAAI;MACF,IAAI,CAACI,QAAQ,CAACuD,IAAI,CAACC,OAAO,CAAC;IAC7B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdxF,YAAY,CAACwF,KAAK,CAAC;QAAEC,OAAO,EAAE5E,IAAI,CAAC6E,SAAS,CAAC,kCAAkC;MAAE,CAAC,CAAC;IACrF;IACA,IAAI,CAAC3D,OAAO,CAACoD,IAAI,CAACC,OAAO,CAAC;;IAE1B;IACA,MAAM,IAAI,CAACtD,OAAO,CAACqD,IAAI,CAACC,OAAO,EAAE,IAAI,CAAClD,GAAI,CAAC;;IAE3C;IACA,IAAI;MACF,MAAM,IAAI,CAAC0D,UAAU,CAACR,OAAO,CAACxD,QAAQ,EAAEwD,OAAO,CAACS,WAAW,CAAC;IAC9D,CAAC,CAAC,OAAOL,KAAK,EAAE;MACdxF,YAAY,CAACwF,KAAK,CAAC;QAAEC,OAAO,EAAE5E,IAAI,CAAC6E,SAAS,CAAC,8BAA8B;MAAE,CAAC,CAAC;IACjF;IACA;IACA,IAAI;MACF,MAAM,IAAI,CAACI,WAAW,CAACV,OAAO,CAAC;IACjC,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdxF,YAAY,CAACwF,KAAK,CAAC;QAAEC,OAAO,EAAE5E,IAAI,CAAC6E,SAAS,CAAC,8BAA8B;MAAE,CAAC,CAAC;IACjF;IACA,IAAI,CAACtD,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,qBAAqB,GAAG+C,OAAO,CAACW,uBAAuB,KAAK,MAAM,IAAIX,OAAO,CAACW,uBAAuB,KAAK,IAAI;EACrH;;EAEA;AACF;AACA;EACE,MAAMH,UAAUA,CAAChE,QAAoB,EAAEoE,UAAmB,EAAE;IAC1D,MAAMC,WAAW,GAAG,MAAM,IAAI,CAACzE,QAAQ,CAAE0E,eAAe,CAAC,CAAC;IAC1D,IAAIC,gBAAgB;IACpB,IAAIH,UAAU,EAAE;MACd,MAAMI,MAAM,GAAGJ,UAAU,CAAC1B,KAAK,CAAC,GAAG,CAAC,CAAC+B,GAAG,CAAC,CAAC;MAC1C,IAAI,CAAAD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE,iBAAiB,CAAC,CAAC,MAAK,UAAU,EAAE;QAC9CH,gBAAgB,GAAG,MAAM,IAAI,CAACI,YAAY,CAACP,UAAU,EAAEpE,QAAQ,CAAC;MAClE,CAAC,MAAM;QACLuE,gBAAgB,GAAG,MAAM,IAAI,CAAC3E,QAAQ,CAAEgF,cAAc,CAAC,CAAC;MAC1D;IACF;IACA;IACA,IAAIL,gBAAgB,EAAE;MACpB,IAAI,CAAChE,WAAW,GAAGtC,SAAS,CAAC;QAC3B6D,SAAS,EAAEyC,gBAAgB,CAACzC;MAC9B,CAAC,CAAC;IACJ;IACA,MAAMmB,MAAM,GAAGoB,WAAW,IAAIE,gBAAgB;IAC9C;IACA,IAAI,CAAClE,QAAQ,CAACkD,IAAI,CAAC,CAAAN,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEnB,SAAS,IAAG9C,uBAAuB,CAACiE,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEnB,SAAS,EAAE9B,QAAQ,CAAC,GAAG,EAAE,CAAC;IACjG,IAAI,CAACiD,MAAM,EAAE;MACX;IACF;IACA,IAAIA,MAAM,CAAC4B,OAAO,EAAE;MAClB,IAAI,CAACjF,QAAQ,CAAEkF,UAAU,CAAC7B,MAAM,CAAC4B,OAAO,CAAC;IAC3C;EACF;;EAEA;EACAF,YAAYA,CAACrE,GAAW,EAAEN,QAAoB,EAAE;IAC9C,OAAO,IAAI+E,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtCC,KAAK,CAAC5E,GAAG,CAAC,CACP6E,IAAI,CAAEC,GAAG,IAAKA,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC,CAChCF,IAAI,CAAC,MAAOE,WAAW,IAAK;QAAA,IAAAC,GAAA;QAC3B,IAAIC,EAAO;QACX,IAAI;UACFA,EAAE,GAAG/G,aAAa,CAACgH,MAAM,CAACpC,IAAI,CAACiC,WAAW,CAAC,CAAC;QAC9C,CAAC,CAAC,OAAOzB,KAAK,EAAE;UACdxF,YAAY,CAACwF,KAAK,CAAC;YAAEC,OAAO,EAAE5E,IAAI,CAAC6E,SAAS,CAAC,qBAAqB;UAAE,CAAC,CAAC;QACxE;QACA,MAAMhC,SAAqB,GAAG,EAAE;QAChC,IAAI,EAAAwD,GAAA,GAAAC,EAAE,cAAAD,GAAA,uBAAFA,GAAA,CAAIG,QAAQ,KAAIzF,QAAQ,EAAE;UAC5BA,QAAQ,CAAC0F,OAAO,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;YAAA,IAAAC,mBAAA;YACzB,MAAMC,QAAQ,GAAGP,EAAE,CAACE,QAAQ,CAACE,CAAC,CAACI,UAAU,CAAC;YAC1C,IACE,CAAAD,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,QAAQ,KAClB7G,mBAAmB,CAACwG,CAAC,CAACM,IAAI,CAACvB,iBAAiB,CAAC,CAAC,CAAC,MAAKoB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,QAAQ,KACtE,EAAAH,mBAAA,GAAAC,QAAQ,CAACI,SAAS,cAAAL,mBAAA,uBAAlBA,mBAAA,CAAoB3D,MAAM,IAAG,CAAC,EAC9B;cACA,MAAMgE,SAA6B,GAAG,EAAE;cACvCJ,QAAQ,CAACI,SAAS,CAChBC,IAAI,CAAC,CAACC,CAAoB,EAAEC,CAAoB,KAAMD,CAAC,CAAC,CAAC,CAAC,GAAeC,CAAC,CAAC,CAAC,CAAY,CAAC,CACzFX,OAAO,CAAC,CAACY,IAAI,EAAEC,CAAC,KAAK;gBACpBL,SAAS,CAACpD,IAAI,CAACwD,IAAI,CAAC;gBACpB,MAAME,IAAI,GAAGV,QAAQ,CAACI,SAAS,CAACK,CAAC,GAAG,CAAC,CAAC;gBACtC,IAAIC,IAAI,IAAIF,IAAI,CAAC,CAAC,CAAC,KAAKE,IAAI,CAAC,CAAC,CAAC,EAAE;kBAC/BN,SAAS,CAACpD,IAAI,CAAC,CAACwD,IAAI,CAAC,CAAC,CAAC,EAAEE,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;gBACxC;cACF,CAAC,CAAC;cACJ,MAAMC,SAAS,GAAGd,CAAC,CAACM,IAAI,KAAK7G,cAAc,CAACsH,OAAO;cACnD,MAAMC,aAAa,GAAGT,SAAS,CAAClF,GAAG,CAAE4F,KAA0B,KAAM;gBACnEzE,EAAE,EAAEhE,MAAM,CAAC,CAAC;gBACZmE,KAAK,EAAEsE,KAAK,CAAC,CAAC,CAAW;gBACzB,IAAIH,SAAS,IAAI;kBACflE,GAAG,EAAEqE,KAAK,CAAC,CAAC;gBACd,CAAC,CAAC;gBACFvE,SAAS,EAAEsD,CAAC,CAACM,IAAI;gBACjB7D,QAAQ,EAAEuD,CAAC,CAACI,UAAU;gBACtBc,aAAa,EAAEjB,CAAC;gBAChBpD,IAAI,EAAGiE,SAAS,GAAGG,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC;cACvC,CAAC,CAAC,CAAC,CAACT,IAAI,CAAC,CAACC,CAAY,EAAEC,CAAW,KAAKD,CAAC,CAAC9D,KAAK,GAAG+D,CAAC,CAAC/D,KAAK,CAAC;cAC1D,IAAImE,SAAS,EAAE;gBACb,IAAIE,aAAa,CAAC,CAAC,CAAC,CAACrE,KAAK,GAAG,CAAC,EAAE;kBAC9BqE,aAAa,CAACG,OAAO,CAAC;oBACpB3E,EAAE,EAAEhE,MAAM,CAAC,CAAC;oBACZmE,KAAK,EAAE,CAAC;oBACRC,GAAG,EAAEoE,aAAa,CAAC,CAAC,CAAC,CAACrE,KAAK;oBAC3BD,SAAS,EAAEsD,CAAC,CAACM,IAAI;oBACjB7D,QAAQ,EAAEuD,CAAC,CAACI,UAAU;oBACtBc,aAAa,EAAEjB,CAAC;oBAChBpD,IAAI,EAAE;kBACR,CAAC,CAAC;gBACJ;gBACA,IAAImE,aAAa,CAACA,aAAa,CAACzE,MAAM,GAAG,CAAC,CAAC,CAACK,GAAG,GAAIuD,QAAQ,CAACiB,YAAY,EAAE;kBACxEJ,aAAa,CAAC7D,IAAI,CAAC;oBACjBX,EAAE,EAAEhE,MAAM,CAAC,CAAC;oBACZmE,KAAK,EAAEqE,aAAa,CAACA,aAAa,CAACzE,MAAM,GAAG,CAAC,CAAC,CAACK,GAAI;oBACnDA,GAAG,EAAEuD,QAAQ,CAACiB,YAAY;oBAC1B1E,SAAS,EAAEsD,CAAC,CAACM,IAAI;oBACjB7D,QAAQ,EAAEuD,CAAC,CAACI,UAAU;oBACtBc,aAAa,EAAEjB,CAAC;oBAChBpD,IAAI,EAAE;kBACR,CAAC,CAAC;gBACJ;cACF;cACAV,SAAS,CAACgB,IAAI,CAAC,GAAG6D,aAAa,CAAC;YAClC,CAAC,MAAM,IAAIhB,CAAC,CAACM,IAAI,KAAK7G,cAAc,CAACsH,OAAO,EAAE;cAC5C,MAAM;gBAAE9F,SAAS,EAAE;kBAAEC;gBAAS;cAAE,CAAC,GAAG,IAAI,CAACX,OAAO;cAChD4B,SAAS,CAACgB,IAAI,CAAC;gBACbX,EAAE,EAAEhE,MAAM,CAAC,CAAC;gBACZmE,KAAK,EAAE,CAAC;gBACRC,GAAG,EAAE1B,QAAQ;gBACbwB,SAAS,EAAEsD,CAAC,CAACM,IAAI;gBACjB7D,QAAQ,EAAEuD,CAAC,CAACI,UAAU;gBACtBc,aAAa,EAAEjB,CAAC;gBAChBpD,IAAI,EAAE;cACR,CAAC,CAAC;YACJ;UACF,CAAC,CAAC;QACJ;QACAwC,OAAO,CAAC;UAAElD;QAAU,CAAC,CAAC;MACxB,CAAC,CAAC,CAACkF,KAAK,CAAEpD,KAAK,IAAK;QAClBqD,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEtD,KAAK,CAAC;QAC3CoB,OAAO,CAAC,KAAK,CAAC;MAChB,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;EACE,MAAMmC,UAAUA,CAACC,MAAM,GAAG,KAAK,EAAE;IAC/B,MAAMC,YAA4B,GAAGzF,MAAM,CAACC,MAAM,CAACtD,IAAI,CAAC,IAAI,CAAC8B,QAAQ,CAACyB,SAAS,CAAC,CAAC,CAC9Ed,GAAG,CAAC,CAAC;MAAEmB,EAAE;MAAEG,KAAK;MAAEC,GAAG;MAAEF,SAAS;MAAED,QAAQ;MAAEI;IAAK,CAAC,MAAM;MAAEL,EAAE;MAAEG,KAAK;MAAEC,GAAG;MAAEF,SAAS;MAAED,QAAQ;MAAEI;IAAK,CAAC,CAAC,CAAC;IAC1G,MAAM8E,QAAQ,GAAG,IAAI,CAAC5G,qBAAqB,CAAC,CAAC;IAC7C,MAAM6G,UAAU,GAAG,MAAM,IAAI,CAAC3H,QAAQ,CAAE4H,cAAc,CAACF,QAAQ,CAAC;IAChE,OAAO,IAAI,CAAC1H,QAAQ,CAAEuH,UAAU,CAAC;MAC/BtC,OAAO,EAAE,IAAI,CAACjF,QAAQ,CAAE6H,WAAW;MACnC3F,SAAS,EAAEuF,YAAY;MACvBE;IACF,CAAC,EAAEH,MAAM,CAAC;EACZ;;EAEA;AACF;AACA;AACA;EACE,MAAMlD,WAAWA,CAACV,OAAgB,EAAE;IAClC,IAAI,CAACpD,MAAM,CAACmD,IAAI,CAACC,OAAO,CAAC5D,QAAQ,CAACC,QAAQ,EAAE2D,OAAO,CAACkE,WAAW,CAAC;IAChE,MAAMC,OAAO,GAAG,MAAM,IAAI,CAAC/H,QAAQ,CAAEsE,WAAW,CAAC,CAAC;IAClD,IAAI,CAAC9D,MAAM,CAACwH,cAAc,CAACD,OAAO,CAAC;EACrC;;EAEA;AACF;AACA;EACE,MAAME,WAAWA,CAACT,MAAM,GAAG,KAAK,EAAE;IAChC,MAAM;MAAEU;IAAc,CAAC,GAAG,IAAI,CAAC1H,MAAM;IACrC,OAAO,IAAI,CAACR,QAAQ,CAAEiI,WAAW,CAACC,aAAa,EAAEV,MAAM,CAAC;EAC1D;EA2EAW,WAAWA,CAACC,MAAmB,EAAE;IAC/B,MAAMC,GAAG,GAAGxJ,gBAAgB,CAACuJ,MAAM,CAAC;IACpC,MAAME,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACF,GAAG,CAAC,EAAE;MAAEhC,IAAI,EAAE;IAAY,CAAC,CAAC;IACnD,IAAI,CAAC3F,GAAG,GAAG8H,MAAM,CAACC,GAAG,CAACC,eAAe,CAACJ,IAAI,CAAC;EAC7C;AACF;AAEA,MAAMK,SAAS,GAAG,IAAI7I,SAAS,CAAC,CAAC;AAEjC,eAAe6I,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module"}