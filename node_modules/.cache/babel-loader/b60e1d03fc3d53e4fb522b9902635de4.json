{"ast":null,"code":"/*!\n * wavesurfer.js timeline plugin 5.2.0 (2021-08-16)\n * https://wavesurfer-js.org\n * @license BSD-3-Clause\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(\"WaveSurfer\", [], t) : \"object\" == typeof exports ? exports.WaveSurfer = t() : (e.WaveSurfer = e.WaveSurfer || {}, e.WaveSurfer.timeline = t());\n}(self, function () {\n  return (() => {\n    \"use strict\";\n\n    var e = {\n        171: (e, t) => {\n          function a(e, t) {\n            for (var a = 0; a < t.length; a++) {\n              var r = t[a];\n              r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n            }\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.default = void 0;\n          var r = function () {\n            function e(t, a) {\n              var r = this;\n              if (function (e, t) {\n                if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n              }(this, e), i.call(this), this.container = \"string\" == typeof t.container ? document.querySelector(t.container) : t.container, !this.container) throw new Error(\"No container for wavesurfer timeline\");\n              this.wavesurfer = a, this.util = a.util, this.params = Object.assign({}, {\n                height: 20,\n                notchPercentHeight: 90,\n                labelPadding: 5,\n                unlabeledNotchColor: \"#c0c0c0\",\n                primaryColor: \"#000\",\n                secondaryColor: \"#c0c0c0\",\n                primaryFontColor: \"#000\",\n                secondaryFontColor: \"#000\",\n                fontFamily: \"Arial\",\n                fontSize: 10,\n                duration: null,\n                zoomDebounce: !1,\n                formatTimeCallback: this.defaultFormatTimeCallback,\n                timeInterval: this.defaultTimeInterval,\n                primaryLabelInterval: this.defaultPrimaryLabelInterval,\n                secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n                offset: 0\n              }, t), this.canvases = [], this.wrapper = null, this.drawer = null, this.pixelRatio = null, this.maxCanvasWidth = null, this.maxCanvasElementWidth = null, this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {\n                return r.render();\n              }, this.params.zoomDebounce) : function () {\n                return r.render();\n              };\n            }\n            var t, r, n;\n            return t = e, n = [{\n              key: \"create\",\n              value: function (t) {\n                return {\n                  name: \"timeline\",\n                  deferInit: !(!t || !t.deferInit) && t.deferInit,\n                  params: t,\n                  instance: e\n                };\n              }\n            }], (r = [{\n              key: \"init\",\n              value: function () {\n                this.wavesurfer.isReady ? this._onReady() : this.wavesurfer.once(\"ready\", this._onReady);\n              }\n            }, {\n              key: \"destroy\",\n              value: function () {\n                this.unAll(), this.wavesurfer.un(\"redraw\", this._onRedraw), this.wavesurfer.un(\"zoom\", this._onZoom), this.wavesurfer.un(\"ready\", this._onReady), this.wavesurfer.drawer.wrapper.removeEventListener(\"scroll\", this._onScroll), this.wrapper && this.wrapper.parentNode && (this.wrapper.removeEventListener(\"click\", this._onWrapperClick), this.wrapper.parentNode.removeChild(this.wrapper), this.wrapper = null);\n              }\n            }, {\n              key: \"createWrapper\",\n              value: function () {\n                var e = this.wavesurfer.params;\n                this.container.innerHTML = \"\", this.wrapper = this.container.appendChild(document.createElement(\"timeline\")), this.util.style(this.wrapper, {\n                  display: \"block\",\n                  position: \"relative\",\n                  userSelect: \"none\",\n                  webkitUserSelect: \"none\",\n                  height: \"\".concat(this.params.height, \"px\")\n                }), (e.fillParent || e.scrollParent) && this.util.style(this.wrapper, {\n                  width: \"100%\",\n                  overflowX: \"hidden\",\n                  overflowY: \"hidden\"\n                }), this.wrapper.addEventListener(\"click\", this._onWrapperClick);\n              }\n            }, {\n              key: \"render\",\n              value: function () {\n                this.wrapper || this.createWrapper(), this.updateCanvases(), this.updateCanvasesPositioning(), this.renderCanvases();\n              }\n            }, {\n              key: \"addCanvas\",\n              value: function () {\n                var e = this.wrapper.appendChild(document.createElement(\"canvas\"));\n                this.canvases.push(e), this.util.style(e, {\n                  position: \"absolute\",\n                  zIndex: 4\n                });\n              }\n            }, {\n              key: \"removeCanvas\",\n              value: function () {\n                var e = this.canvases.pop();\n                e.parentElement.removeChild(e);\n              }\n            }, {\n              key: \"updateCanvases\",\n              value: function () {\n                for (var e = Math.round(this.drawer.wrapper.scrollWidth), t = Math.ceil(e / this.maxCanvasElementWidth); this.canvases.length < t;) this.addCanvas();\n                for (; this.canvases.length > t;) this.removeCanvas();\n              }\n            }, {\n              key: \"updateCanvasesPositioning\",\n              value: function () {\n                var e = this,\n                  t = this.canvases.length;\n                this.canvases.forEach(function (a, r) {\n                  var i = r === t - 1 ? e.drawer.wrapper.scrollWidth - e.maxCanvasElementWidth * (t - 1) : e.maxCanvasElementWidth;\n                  a.width = i * e.pixelRatio, a.height = (e.params.height + 1) * e.pixelRatio, e.util.style(a, {\n                    width: \"\".concat(i, \"px\"),\n                    height: \"\".concat(e.params.height, \"px\"),\n                    left: \"\".concat(r * e.maxCanvasElementWidth, \"px\")\n                  });\n                });\n              }\n            }, {\n              key: \"renderCanvases\",\n              value: function () {\n                var e = this,\n                  t = this.params.duration || this.wavesurfer.backend.getDuration();\n                if (!(t <= 0)) {\n                  var a,\n                    r = this.wavesurfer.params,\n                    i = this.params.fontSize * r.pixelRatio,\n                    n = parseInt(t, 10) + 1,\n                    s = r.fillParent && !r.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * r.pixelRatio,\n                    o = this.params.height * this.pixelRatio,\n                    l = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio,\n                    h = s / t,\n                    c = this.params.formatTimeCallback,\n                    u = function (e) {\n                      return \"function\" == typeof e ? e(h) : e;\n                    },\n                    p = u(this.params.timeInterval),\n                    f = u(this.params.primaryLabelInterval),\n                    d = u(this.params.secondaryLabelInterval),\n                    v = h * this.params.offset,\n                    m = 0,\n                    y = [];\n                  for (a = 0; a < n / p; a++) y.push([a, m, v]), m += p, v += h * p;\n                  var w = function (e) {\n                    y.forEach(function (t) {\n                      e(t[0], t[1], t[2]);\n                    });\n                  };\n                  this.setFillStyles(this.params.primaryColor), this.setFonts(\"\".concat(i, \"px \").concat(this.params.fontFamily)), this.setFillStyles(this.params.primaryFontColor), w(function (t, a, r) {\n                    t % f == 0 && (e.fillRect(r, 0, 1, o), e.fillText(c(a, h), r + e.params.labelPadding * e.pixelRatio, o));\n                  }), this.setFillStyles(this.params.secondaryColor), this.setFonts(\"\".concat(i, \"px \").concat(this.params.fontFamily)), this.setFillStyles(this.params.secondaryFontColor), w(function (t, a, r) {\n                    t % d == 0 && (e.fillRect(r, 0, 1, o), e.fillText(c(a, h), r + e.params.labelPadding * e.pixelRatio, o));\n                  }), this.setFillStyles(this.params.unlabeledNotchColor), w(function (t, a, r) {\n                    t % d != 0 && t % f != 0 && e.fillRect(r, 0, 1, l);\n                  });\n                }\n              }\n            }, {\n              key: \"setFillStyles\",\n              value: function (e) {\n                this.canvases.forEach(function (t) {\n                  var a = t.getContext(\"2d\");\n                  a && (a.fillStyle = e);\n                });\n              }\n            }, {\n              key: \"setFonts\",\n              value: function (e) {\n                this.canvases.forEach(function (t) {\n                  var a = t.getContext(\"2d\");\n                  a && (a.font = e);\n                });\n              }\n            }, {\n              key: \"fillRect\",\n              value: function (e, t, a, r) {\n                var i = this;\n                this.canvases.forEach(function (n, s) {\n                  var o = s * i.maxCanvasWidth,\n                    l = {\n                      x1: Math.max(e, s * i.maxCanvasWidth),\n                      y1: t,\n                      x2: Math.min(e + a, s * i.maxCanvasWidth + n.width),\n                      y2: t + r\n                    };\n                  if (l.x1 < l.x2) {\n                    var h = n.getContext(\"2d\");\n                    h && h.fillRect(l.x1 - o, l.y1, l.x2 - l.x1, l.y2 - l.y1);\n                  }\n                });\n              }\n            }, {\n              key: \"fillText\",\n              value: function (e, t, a) {\n                var r,\n                  i = 0;\n                this.canvases.forEach(function (n) {\n                  var s = n.getContext(\"2d\");\n                  if (s) {\n                    var o = s.canvas.width;\n                    if (i > t + r) return;\n                    i + o > t && s && (r = s.measureText(e).width, s.fillText(e, t - i, a)), i += o;\n                  }\n                });\n              }\n            }, {\n              key: \"defaultFormatTimeCallback\",\n              value: function (e, t) {\n                if (e / 60 > 1) {\n                  var a = parseInt(e / 60, 10);\n                  return e = (e = parseInt(e % 60, 10)) < 10 ? \"0\" + e : e, \"\".concat(a, \":\").concat(e);\n                }\n                return Math.round(1e3 * e) / 1e3;\n              }\n            }, {\n              key: \"defaultTimeInterval\",\n              value: function (e) {\n                return e >= 25 ? 1 : 5 * e >= 25 ? 5 : 15 * e >= 25 ? 15 : 60 * Math.ceil(.5 / e);\n              }\n            }, {\n              key: \"defaultPrimaryLabelInterval\",\n              value: function (e) {\n                return e >= 25 ? 10 : 5 * e >= 25 ? 6 : 4;\n              }\n            }, {\n              key: \"defaultSecondaryLabelInterval\",\n              value: function (e) {\n                return e >= 25 ? 5 : 2;\n              }\n            }]) && a(t.prototype, r), n && a(t, n), e;\n          }();\n          t.default = r;\n          var i = function () {\n            var e = this;\n            this._onScroll = function () {\n              e.wrapper && e.drawer.wrapper && (e.wrapper.scrollLeft = e.drawer.wrapper.scrollLeft);\n            }, this._onRedraw = function () {\n              return e.render();\n            }, this._onReady = function () {\n              var t = e.wavesurfer;\n              e.drawer = t.drawer, e.pixelRatio = t.drawer.params.pixelRatio, e.maxCanvasWidth = t.drawer.maxCanvasWidth || t.drawer.width, e.maxCanvasElementWidth = t.drawer.maxCanvasElementWidth || Math.round(e.maxCanvasWidth / e.pixelRatio), t.drawer.wrapper.addEventListener(\"scroll\", e._onScroll), t.on(\"redraw\", e._onRedraw), t.on(\"zoom\", e._onZoom), e.render();\n            }, this._onWrapperClick = function (t) {\n              t.preventDefault();\n              var a = \"offsetX\" in t ? t.offsetX : t.layerX;\n              e.fireEvent(\"click\", a / e.wrapper.scrollWidth || 0);\n            };\n          };\n          e.exports = t.default;\n        }\n      },\n      t = {};\n    return function a(r) {\n      var i = t[r];\n      if (void 0 !== i) return i.exports;\n      var n = t[r] = {\n        exports: {}\n      };\n      return e[r](n, n.exports, a), n.exports;\n    }(171);\n  })();\n});","map":{"version":3,"sources":["webpack://WaveSurfer.[name]/webpack/universalModuleDefinition","webpack://WaveSurfer.[name]/src/plugin/timeline/index.js","webpack://WaveSurfer.[name]/webpack/bootstrap","webpack://WaveSurfer.[name]/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","TimelinePlugin","params","name","deferInit","instance","_onScroll","wrapper","drawer","scrollLeft","_onRedraw","render","_onReady","ws","wavesurfer","pixelRatio","maxCanvasWidth","width","maxCanvasElementWidth","Math","round","addEventListener","on","_onZoom","_onWrapperClick","e","preventDefault","relX","offsetX","layerX","fireEvent","scrollWidth","this","container","document","querySelector","Error","util","Object","assign","height","notchPercentHeight","labelPadding","unlabeledNotchColor","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","duration","zoomDebounce","formatTimeCallback","defaultFormatTimeCallback","timeInterval","defaultTimeInterval","primaryLabelInterval","defaultPrimaryLabelInterval","secondaryLabelInterval","defaultSecondaryLabelInterval","offset","canvases","debounce","isReady","once","unAll","un","removeEventListener","parentNode","removeChild","wsParams","innerHTML","appendChild","createElement","style","display","position","userSelect","webkitUserSelect","fillParent","scrollParent","overflowX","overflowY","createWrapper","updateCanvases","updateCanvasesPositioning","renderCanvases","canvas","push","zIndex","pop","parentElement","totalWidth","requiredCanvases","ceil","length","addCanvas","removeCanvas","canvasesLength","forEach","i","canvasWidth","left","backend","getDuration","totalSeconds","parseInt","getWidth","height1","height2","pixelsPerSecond","formatTime","intervalFnOrVal","option","curPixel","curSeconds","positioning","renderPositions","cb","pos","setFillStyles","setFonts","fillRect","fillText","fillStyle","context","getContext","font","x","y","leftOffset","intersection","x1","max","y1","x2","min","y2","text","textWidth","xOffset","measureText","seconds","pxPerSec","minutes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WaveSurfer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WaveSurfer\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(self, function() {\nreturn ","/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} unlabeledNotchColor='#c0c0c0' The colour of the notches\n * that do not have labels\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {number} labelPadding=5 The padding between the label and the notch\n * @property {?number} zoomDebounce A debounce timeout to increase rendering\n * performance for large files\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {?number} duration Length of the track in seconds. Overrides\n * getDuration() for setting length of timeline\n * @property {function} formatTimeCallback (sec, pxPerSec) -> label\n * @property {function} timeInterval (pxPerSec) -> seconds between notches\n * @property {function} primaryLabelInterval (pxPerSec) -> cadence between\n * labels in primary color\n * @property {function} secondaryLabelInterval (pxPerSec) -> cadence between\n * labels in secondary color\n * @property {?number} offset Offset for the timeline start in seconds. May also be\n * negative.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n    /**\n     * Timeline plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'timeline',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            instance: TimelinePlugin\n        };\n    }\n\n    // event handlers\n    _onScroll = () => {\n        if (this.wrapper && this.drawer.wrapper) {\n            this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;\n        }\n    };\n\n    /**\n     * @returns {void}\n     */\n    _onRedraw = () => this.render();\n\n    _onReady = () => {\n        const ws = this.wavesurfer;\n        this.drawer = ws.drawer;\n        this.pixelRatio = ws.drawer.params.pixelRatio;\n        this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n        this.maxCanvasElementWidth =\n            ws.drawer.maxCanvasElementWidth ||\n            Math.round(this.maxCanvasWidth / this.pixelRatio);\n\n        // add listeners\n        ws.drawer.wrapper.addEventListener('scroll', this._onScroll);\n        ws.on('redraw', this._onRedraw);\n        ws.on('zoom', this._onZoom);\n\n        this.render();\n    };\n\n    /**\n     * @param {object} e Click event\n     */\n    _onWrapperClick = e => {\n        e.preventDefault();\n        const relX = 'offsetX' in e ? e.offsetX : e.layerX;\n        this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);\n    };\n\n    /**\n     * Creates an instance of TimelinePlugin.\n     *\n     * You probably want to use TimelinePlugin.create()\n     *\n     * @param {TimelinePluginParams} params Plugin parameters\n     * @param {object} ws Wavesurfer instance\n     */\n    constructor(params, ws) {\n        this.container =\n            'string' == typeof params.container\n                ? document.querySelector(params.container)\n                : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n\n        this.wavesurfer = ws;\n        this.util = ws.util;\n        this.params = Object.assign(\n            {},\n            {\n                height: 20,\n                notchPercentHeight: 90,\n                labelPadding: 5,\n                unlabeledNotchColor: '#c0c0c0',\n                primaryColor: '#000',\n                secondaryColor: '#c0c0c0',\n                primaryFontColor: '#000',\n                secondaryFontColor: '#000',\n                fontFamily: 'Arial',\n                fontSize: 10,\n                duration: null,\n                zoomDebounce: false,\n                formatTimeCallback: this.defaultFormatTimeCallback,\n                timeInterval: this.defaultTimeInterval,\n                primaryLabelInterval: this.defaultPrimaryLabelInterval,\n                secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n                offset: 0\n            },\n            params\n        );\n\n        this.canvases = [];\n        this.wrapper = null;\n        this.drawer = null;\n        this.pixelRatio = null;\n        this.maxCanvasWidth = null;\n        this.maxCanvasElementWidth = null;\n        /**\n         * This event handler has to be in the constructor function because it\n         * relies on the debounce function which is only available after\n         * instantiation\n         *\n         * Use a debounced function if `params.zoomDebounce` is defined\n         *\n         * @returns {void}\n         */\n        this._onZoom = this.params.zoomDebounce\n            ? this.wavesurfer.util.debounce(\n                () => this.render(),\n                this.params.zoomDebounce\n            )\n            : () => this.render();\n    }\n\n    /**\n     * Initialisation function used by the plugin API\n     */\n    init() {\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        } else {\n            this.wavesurfer.once('ready', this._onReady);\n        }\n    }\n\n    /**\n     * Destroy function used by the plugin API\n     */\n    destroy() {\n        this.unAll();\n        this.wavesurfer.un('redraw', this._onRedraw);\n        this.wavesurfer.un('zoom', this._onZoom);\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.drawer.wrapper.removeEventListener(\n            'scroll',\n            this._onScroll\n        );\n        if (this.wrapper && this.wrapper.parentNode) {\n            this.wrapper.removeEventListener('click', this._onWrapperClick);\n            this.wrapper.parentNode.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    /**\n     * Create a timeline element to wrap the canvases drawn by this plugin\n     *\n     */\n    createWrapper() {\n        const wsParams = this.wavesurfer.params;\n        this.container.innerHTML = '';\n        this.wrapper = this.container.appendChild(\n            document.createElement('timeline')\n        );\n        this.util.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: `${this.params.height}px`\n        });\n\n        if (wsParams.fillParent || wsParams.scrollParent) {\n            this.util.style(this.wrapper, {\n                width: '100%',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            });\n        }\n\n        this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n\n    /**\n     * Render the timeline (also updates the already rendered timeline)\n     *\n     */\n    render() {\n        if (!this.wrapper) {\n            this.createWrapper();\n        }\n        this.updateCanvases();\n        this.updateCanvasesPositioning();\n        this.renderCanvases();\n    }\n\n    /**\n     * Add new timeline canvas\n     *\n     */\n    addCanvas() {\n        const canvas = this.wrapper.appendChild(\n            document.createElement('canvas')\n        );\n        this.canvases.push(canvas);\n        this.util.style(canvas, {\n            position: 'absolute',\n            zIndex: 4\n        });\n    }\n\n    /**\n     * Remove timeline canvas\n     *\n     */\n    removeCanvas() {\n        const canvas = this.canvases.pop();\n        canvas.parentElement.removeChild(canvas);\n    }\n\n    /**\n     * Make sure the correct of timeline canvas elements exist and are cached in\n     * this.canvases\n     *\n     */\n    updateCanvases() {\n        const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n        const requiredCanvases = Math.ceil(\n            totalWidth / this.maxCanvasElementWidth\n        );\n\n        while (this.canvases.length < requiredCanvases) {\n            this.addCanvas();\n        }\n\n        while (this.canvases.length > requiredCanvases) {\n            this.removeCanvas();\n        }\n    }\n\n    /**\n     * Update the dimensions and positioning style for all the timeline canvases\n     *\n     */\n    updateCanvasesPositioning() {\n        // cache length for performance\n        const canvasesLength = this.canvases.length;\n        this.canvases.forEach((canvas, i) => {\n            // canvas width is the max element width, or if it is the last the\n            // required width\n            const canvasWidth =\n                i === canvasesLength - 1\n                    ? this.drawer.wrapper.scrollWidth -\n                      this.maxCanvasElementWidth * (canvasesLength - 1)\n                    : this.maxCanvasElementWidth;\n            // set dimensions and style\n            canvas.width = canvasWidth * this.pixelRatio;\n            // on certain pixel ratios the canvas appears cut off at the bottom,\n            // therefore leave 1px extra\n            canvas.height = (this.params.height + 1) * this.pixelRatio;\n            this.util.style(canvas, {\n                width: `${canvasWidth}px`,\n                height: `${this.params.height}px`,\n                left: `${i * this.maxCanvasElementWidth}px`\n            });\n        });\n    }\n\n    /**\n     * Render the timeline labels and notches\n     *\n     */\n    renderCanvases() {\n        const duration =\n            this.params.duration ||\n            this.wavesurfer.backend.getDuration();\n\n        if (duration <= 0) {\n            return;\n        }\n        const wsParams = this.wavesurfer.params;\n        const fontSize = this.params.fontSize * wsParams.pixelRatio;\n        const totalSeconds = parseInt(duration, 10) + 1;\n        const width =\n            wsParams.fillParent && !wsParams.scrollParent\n                ? this.drawer.getWidth()\n                : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n        const height1 = this.params.height * this.pixelRatio;\n        const height2 =\n            this.params.height *\n            (this.params.notchPercentHeight / 100) *\n            this.pixelRatio;\n        const pixelsPerSecond = width / duration;\n\n        const formatTime = this.params.formatTimeCallback;\n        // if parameter is function, call the function with\n        // pixelsPerSecond, otherwise simply take the value as-is\n        const intervalFnOrVal = option =>\n            typeof option === 'function' ? option(pixelsPerSecond) : option;\n        const timeInterval = intervalFnOrVal(this.params.timeInterval);\n        const primaryLabelInterval = intervalFnOrVal(\n            this.params.primaryLabelInterval\n        );\n        const secondaryLabelInterval = intervalFnOrVal(\n            this.params.secondaryLabelInterval\n        );\n\n        let curPixel = pixelsPerSecond * this.params.offset;\n        let curSeconds = 0;\n        let i;\n        // build an array of position data with index, second and pixel data,\n        // this is then used multiple times below\n        const positioning = [];\n        for (i = 0; i < totalSeconds / timeInterval; i++) {\n            positioning.push([i, curSeconds, curPixel]);\n            curSeconds += timeInterval;\n            curPixel += pixelsPerSecond * timeInterval;\n        }\n\n        // iterate over each position\n        const renderPositions = cb => {\n            positioning.forEach(pos => {\n                cb(pos[0], pos[1], pos[2]);\n            });\n        };\n\n        // render primary labels\n        this.setFillStyles(this.params.primaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.primaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % primaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds, pixelsPerSecond),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render secondary labels\n        this.setFillStyles(this.params.secondaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.secondaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % secondaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds, pixelsPerSecond),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render the actual notches (when no labels are used)\n        this.setFillStyles(this.params.unlabeledNotchColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (\n                i % secondaryLabelInterval !== 0 &&\n                i % primaryLabelInterval !== 0\n            ) {\n                this.fillRect(curPixel, 0, 1, height2);\n            }\n        });\n    }\n\n    /**\n     * Set the canvas fill style\n     *\n     * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle Fill style to\n     * use\n     */\n    setFillStyles(fillStyle) {\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                context.fillStyle = fillStyle;\n            }\n        });\n    }\n\n    /**\n     * Set the canvas font\n     *\n     * @param {DOMString} font Font to use\n     */\n    setFonts(font) {\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                context.font = font;\n            }\n        });\n    }\n\n    /**\n     * Draw a rectangle on the canvases\n     *\n     * (it figures out the offset for each canvas)\n     *\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     * @param {number} width Width\n     * @param {number} height Height\n     */\n    fillRect(x, y, width, height) {\n        this.canvases.forEach((canvas, i) => {\n            const leftOffset = i * this.maxCanvasWidth;\n\n            const intersection = {\n                x1: Math.max(x, i * this.maxCanvasWidth),\n                y1: y,\n                x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),\n                y2: y + height\n            };\n\n            if (intersection.x1 < intersection.x2) {\n                const context = canvas\n                    .getContext('2d');\n                if (context) {\n                    context\n                        .fillRect(\n                            intersection.x1 - leftOffset,\n                            intersection.y1,\n                            intersection.x2 - intersection.x1,\n                            intersection.y2 - intersection.y1\n                        );\n                }\n            }\n        });\n    }\n\n    /**\n     * Fill a given text on the canvases\n     *\n     * @param {string} text Text to render\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     */\n    fillText(text, x, y) {\n        let textWidth;\n        let xOffset = 0;\n\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                const canvasWidth = context.canvas.width;\n\n                if (xOffset > x + textWidth) {\n                    return;\n                }\n\n                if (xOffset + canvasWidth > x && context) {\n                    textWidth = context.measureText(text).width;\n                    context.fillText(text, x - xOffset, y);\n                }\n\n                xOffset += canvasWidth;\n            }\n        });\n    }\n\n    /**\n     * Turn the time into a suitable label for the time.\n     *\n     * @param {number} seconds Seconds to format\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n    defaultFormatTimeCallback(seconds, pxPerSec) {\n        if (seconds / 60 > 1) {\n            // calculate minutes and seconds from seconds count\n            const minutes = parseInt(seconds / 60, 10);\n            seconds = parseInt(seconds % 60, 10);\n            // fill up seconds with zeroes\n            seconds = seconds < 10 ? '0' + seconds : seconds;\n            return `${minutes}:${seconds}`;\n        }\n        return Math.round(seconds * 1000) / 1000;\n    }\n\n    /**\n     * Return how many seconds should be between each notch\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n    defaultTimeInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 1;\n        } else if (pxPerSec * 5 >= 25) {\n            return 5;\n        } else if (pxPerSec * 15 >= 25) {\n            return 15;\n        }\n        return Math.ceil(0.5 / pxPerSec) * 60;\n    }\n\n    /**\n     * Return the cadence of notches that get labels in the primary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n    defaultPrimaryLabelInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 10;\n        } else if (pxPerSec * 5 >= 25) {\n            return 6;\n        } else if (pxPerSec * 15 >= 25) {\n            return 4;\n        }\n        return 4;\n    }\n\n    /**\n     * Return the cadence of notches that get labels in the secondary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n    defaultSecondaryLabelInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 5;\n        } else if (pxPerSec * 5 >= 25) {\n            return 2;\n        } else if (pxPerSec * 15 >= 25) {\n            return 2;\n        }\n        return 2;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(171);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}