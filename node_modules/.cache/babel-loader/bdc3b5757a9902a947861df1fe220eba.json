{"ast":null,"code":"import _initializerDefineProperty from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/qzheng/Documents/webroot/annotation_tools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\nvar _dec,\n  _class,\n  _class2,\n  _descriptor,\n  _descriptor2,\n  _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/landmark-annotation/components/Canvas.tsx\";\n/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport { Spin } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool from '../tools/Tool';\nimport { CategoryPathShape } from '../types';\nimport './Canvas.scss';\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 18;\nconst POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  POINT: 'point',\n  PATH: 'path'\n};\nfunction rotatePoint(originX, originY, x, y, radians) {\n  const cos = Math.cos(-radians);\n  const sin = Math.sin(-radians);\n  const nx = cos * (x - originX) + sin * (y - originY) + originX;\n  const ny = cos * (y - originY) - sin * (x - originX) + originY;\n  return {\n    x: nx,\n    y: ny\n  };\n}\nlet Canvas = (_dec = action.bound, observer(_class = (_class2 = class Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    _initializerDefineProperty(this, \"cursor\", _descriptor, this);\n    _initializerDefineProperty(this, \"loading\", _descriptor2, this);\n    this.canvas = React.createRef();\n    this.canvasContainer = React.createRef();\n    this.imageCanvas = void 0;\n    this.imageData = void 0;\n    this.raster = void 0;\n    this.rasterLayer = void 0;\n    this.gridLayer = void 0;\n    this.labelLayer = void 0;\n    this.mainLayer = void 0;\n    this.tool = void 0;\n    this.hits = null;\n    this.selectedPoints = [];\n    this.smoothPath = null;\n    this.resize = () => {\n      if (this.canvasContainer.current) {\n        // set view size\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n        Paper.view.center = new Paper.Point({\n          x: viewWidth / 2,\n          y: viewHeight / 2\n        });\n        Paper.view.zoom = 1;\n        if (this.imageCanvas && this.raster) {\n          // resize image\n          const {\n            width: imgWidth,\n            height: imgHeight\n          } = this.imageCanvas;\n          const viewRatio = viewWidth / viewHeight;\n          const imgRatio = imgWidth / imgHeight;\n          const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n          const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n          const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n          const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n          // apply matrix to all layers\n          Paper.project.layers.forEach(layer => {\n            layer.matrix = matrix;\n          });\n          // reset image center\n          this.raster.position = new Paper.Point({\n            x: imgWidth / 2,\n            y: imgHeight / 2\n          });\n        }\n        this.resizeGrid();\n        this.resizeShapes();\n      }\n    };\n    this.zoom = event => {\n      if (this.canvasContainer.current) {\n        const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n        const viewPosition = Paper.view.viewToProject(mousePosition);\n        const oldZoom = Paper.view.zoom;\n        const oldCenter = Paper.view.center;\n        const {\n          offsetWidth: viewWidth,\n          offsetHeight: viewHeight\n        } = this.canvasContainer.current;\n        let newZoom = event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n        if (newZoom <= 1) {\n          Paper.view.center = new Paper.Point({\n            x: viewWidth / 2,\n            y: viewHeight / 2\n          });\n        }\n        newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n        if (newZoom !== Paper.view.zoom) {\n          Paper.view.zoom = newZoom;\n          const zoomScale = oldZoom / newZoom;\n          const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n          Paper.view.center = Paper.view.center.add(offset);\n        }\n        this.resizeGrid();\n        this.resizeShapes();\n      }\n    };\n    makeObservable(this);\n  }\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n\n      // load image\n      this.loadImage();\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', e => e.preventDefault(), false);\n    }\n    window.addEventListener('resize', this.resize, false);\n  }\n  componentDidUpdate(prevProps) {\n    // default points\n    if (JSON.stringify(prevProps.defaultPoints) !== JSON.stringify(this.props.defaultPoints) && this.props.defaultPoints.length > 0) {\n      this.cleanPoints();\n      const updatedCategories = [];\n      this.props.defaultPoints.forEach(point => {\n        const {\n          position,\n          category,\n          index,\n          isKeyPoint,\n          visible\n        } = point;\n        if (position !== undefined && category !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          if (!updatedCategories.includes(category)) {\n            updatedCategories.push(category);\n          }\n          this.addPointShape(new Paper.Point(position.x, position.y), category, index, isKeyPoint, visible);\n        }\n      });\n      updatedCategories.forEach(category => {\n        this.updateCirclePath(category, this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE);\n      });\n    }\n\n    // undo & redo to update points\n    if (JSON.stringify(prevProps.updatedPoints) !== JSON.stringify(this.props.updatedPoints) && this.props.updatedPoints.length > 0) {\n      this.updatePoints();\n    }\n\n    // visibility changes\n    if (prevProps.isGridVisible !== this.props.isGridVisible) {\n      if (this.gridLayer) {\n        this.gridLayer.visible = this.props.isGridVisible;\n      }\n    }\n    if (prevProps.isLabelVisible !== this.props.isLabelVisible) {\n      if (this.labelLayer) {\n        this.labelLayer.visible = this.props.isLabelVisible;\n      }\n    }\n    // size changes\n    if (prevProps.pointSize !== this.props.pointSize || prevProps.lineWidth !== this.props.lineWidth) {\n      this.resizeShapes();\n    }\n\n    // selected changes\n    if (prevProps.selectedPoint !== this.props.selectedPoint) {\n      if (this.selectedPoints.length <= 0) {\n        this.setPointSelected(prevProps.selectedPoint, false);\n      } else if (!this.isPointInSelectedPoints(this.props.selectedPoint)) {\n        this.setMultiPointsUnselected();\n      }\n      this.setPointSelected(this.props.selectedPoint, true);\n    }\n    if ((prevProps.selectedPointInfo || {}).category !== (this.props.selectedPointInfo || {}).category) {\n      this.clearSmooth();\n    }\n    if (JSON.stringify(prevProps.filters) !== JSON.stringify(this.props.filters)) {\n      this.updateFilters();\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.resize, false);\n  }\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = false;\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = false;\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n    Paper.view.onMouseMove = this.hitTest;\n\n    // this.rasterLayer.on('mousemove', this.hitTest);\n    // this.mainLayer.on('mousemove', this.hitTest);\n  }\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n  loadImage() {\n    if (this.rasterLayer) {\n      this.rasterLayer.activate();\n      imageLoader(this.props.image, c => {\n        var _this$imageCanvas$get;\n        const canvas = c;\n        this.imageCanvas = canvas;\n        this.imageData = (_this$imageCanvas$get = this.imageCanvas.getContext('2d')) === null || _this$imageCanvas$get === void 0 ? void 0 : _this$imageCanvas$get.getImageData(0, 0, this.imageCanvas.width, this.imageCanvas.height);\n        this.raster = new Paper.Raster(this.imageCanvas);\n        this.raster.onLoad = () => {\n          this.resize(); // resize to fit the container\n          this.addGrid(); // add grid to image\n\n          this.loading = false;\n          // when onload, show all layers\n          if (this.rasterLayer) {\n            this.rasterLayer.visible = true;\n          }\n          if (this.mainLayer) {\n            this.mainLayer.visible = true;\n          }\n          if (this.gridLayer) {\n            this.gridLayer.visible = this.props.isGridVisible;\n          }\n          if (this.labelLayer) {\n            this.labelLayer.visible = this.props.isLabelVisible;\n          }\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous'\n      });\n    }\n  }\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const {\n        brightness,\n        contrast,\n        saturation,\n        lightness,\n        hue,\n        rescale\n      } = this.props.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      const {\n        width,\n        height\n      } = this.imageCanvas;\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({\n        length: rows\n      }).forEach((_, index) => {\n        var _this$gridLayer;\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer = this.gridLayer) === null || _this$gridLayer === void 0 ? void 0 : _this$gridLayer.addChild(path);\n      });\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({\n        length: cols\n      }).forEach((_, index) => {\n        var _this$gridLayer2;\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333'\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        (_this$gridLayer2 = this.gridLayer) === null || _this$gridLayer2 === void 0 ? void 0 : _this$gridLayer2.addChild(path);\n      });\n      this.resizeGrid();\n    }\n  }\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach(path => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n  isPointInSelectedPoints(pointIndex) {\n    return this.selectedPoints.findIndex(p => p.data.pointIndex === pointIndex) >= 0;\n  }\n  isPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const {\n      width,\n      height\n    } = this.imageCanvas;\n    return localPoint.x >= 0 && localPoint.x <= width && localPoint.y >= 0 && localPoint.y <= height;\n  }\n  getPointInImage(point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n     if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n  getPointByPointIndex(pointIndex) {\n    var _this$mainLayer;\n    return (_this$mainLayer = this.mainLayer) === null || _this$mainLayer === void 0 ? void 0 : _this$mainLayer.children.find(p => p.data.type === SHAPE_TYPE.POINT && p.data.pointIndex === pointIndex);\n  }\n  getLabelByPointIndex(pointIndex) {\n    var _this$labelLayer;\n    return (_this$labelLayer = this.labelLayer) === null || _this$labelLayer === void 0 ? void 0 : _this$labelLayer.children.find(l => l.data.pointIndex === pointIndex);\n  }\n  getPathByCategory(category) {\n    var _this$mainLayer2;\n    return (_this$mainLayer2 = this.mainLayer) === null || _this$mainLayer2 === void 0 ? void 0 : _this$mainLayer2.children.find(p => p.data.type === SHAPE_TYPE.PATH && p.data.category === category);\n  }\n  getPointsByCategory(category) {\n    var _this$mainLayer3;\n    return (_this$mainLayer3 = this.mainLayer) === null || _this$mainLayer3 === void 0 ? void 0 : _this$mainLayer3.children.filter(p => p.data.type === SHAPE_TYPE.POINT && p.data.category === category);\n  }\n  canAddPoint() {\n    if (this.mainLayer && this.props.selectedPointInfo) {\n      const {\n        category\n      } = this.props.selectedPointInfo;\n      return this.mainLayer.children.findIndex(p => p.data.type === SHAPE_TYPE.POINT && p.data.category === category && p.data.pointIndex === this.props.selectedPoint) < 0;\n    }\n    return false;\n  }\n  addPoint(point) {\n    if (this.mainLayer && this.props.selectedPointInfo) {\n      const {\n        x,\n        y\n      } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const {\n        category,\n        isKeyPoint\n      } = this.props.selectedPointInfo;\n      this.addPointShape(newPoint, category, this.props.selectedPoint, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE) {\n        otherPoints = this.updateCirclePath(category);\n      }\n      this.props.handlePointsChange([{\n        pointIndex: this.props.selectedPoint,\n        point: {\n          category,\n          isKeyPoint,\n          position: {\n            x,\n            y\n          },\n          visible: true // default is visible when point added\n        }\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyPoint(); // move next\n    }\n  }\n  addPointShape(point, category, pointIndex, isKeyPoint, visible = true) {\n    if (this.mainLayer) {\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: this.props.pointSize / zoom,\n        fillColor: visible ? pointColor : '#3d424d',\n        strokeColor: pointColor,\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white'\n      });\n      pointCircle.data.type = SHAPE_TYPE.POINT;\n      pointCircle.data.category = category;\n      pointCircle.data.pointIndex = pointIndex;\n      pointCircle.data.visible = visible;\n      this.mainLayer.addChild(pointCircle);\n\n      // add point to path\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(category);\n      let index = 0;\n      if (path) {\n        if (!path.data.isCircle) {\n          index = path.data.points.findIndex(p => pointIndex < p);\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: this.props.lineWidth / zoom,\n          strokeColor: POINT_COLOR,\n          selectedColor: POINT_COLOR\n        });\n        path.data.type = SHAPE_TYPE.PATH;\n        path.data.category = category;\n        path.data.points = [pointIndex];\n        this.mainLayer.addChild(path);\n      }\n      path.sendToBack();\n      if (path === this.smoothPath) {\n        path.smooth({\n          from: index - 1,\n          to: index + 1,\n          type: 'continuous'\n        });\n        path.fullySelected = true;\n      }\n    }\n    if (this.labelLayer) {\n      const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n      const label = new Paper.PointText({\n        content: `${visible ? '1' : '0'}-${pointIndex}`,\n        fontSize: FONT_SIZE / zoom,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#333333',\n        shadowBlur: 1 / zoom\n      });\n      label.data.point = [point.x, point.y];\n      label.data.pointIndex = pointIndex;\n      label.position.x = point.x + (this.props.pointSize + 6) / zoom;\n      label.position.y = point.y - (this.props.pointSize + 6) / zoom;\n      this.labelLayer.addChild(label);\n    }\n  }\n  removePointShape(pointIndex) {\n    if (this.mainLayer) {\n      const point = this.getPointByPointIndex(pointIndex);\n      if (point) {\n        point.remove();\n        const path = this.getPathByCategory(point.data.category);\n        if (!path.data.isCircle) {\n          const index = path.data.points.findIndex(p => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n      }\n    }\n    if (this.labelLayer) {\n      const label = this.getLabelByPointIndex(pointIndex);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n  resizeShapes() {\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      this.mainLayer.children.forEach(path => {\n        if (path.data.type === SHAPE_TYPE.POINT) {\n          path.set({\n            radius: this.props.pointSize / zoom\n          });\n          path.strokeWidth = 1 / zoom;\n        } else if (path.data.type === SHAPE_TYPE.PATH) {\n          path.strokeWidth = this.props.lineWidth / zoom;\n        }\n      });\n    }\n    if (this.labelLayer && this.labelLayer.children && this.labelLayer.children.length > 0) {\n      const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n      this.labelLayer.children.forEach(label => {\n        label.set({\n          fontSize: FONT_SIZE / zoom,\n          shadowBlur: 1 / zoom\n        });\n        label.position.x = label.data.point[0] + (this.props.pointSize + 6) / zoom;\n        label.position.y = label.data.point[1] - (this.props.pointSize + 6) / zoom;\n      });\n    }\n  }\n  cleanPoints() {\n    if (this.mainLayer) {\n      this.mainLayer.removeChildren();\n    }\n  }\n  updatePoints() {\n    const updatedCategories = [];\n    this.props.updatedPoints.forEach(({\n      index,\n      point\n    }) => {\n      const currPoint = this.getPointByPointIndex(index);\n      if (currPoint) {\n        if (!updatedCategories.includes(currPoint.data.category)) {\n          updatedCategories.push(currPoint.data.category);\n        }\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(index);\n        } else if (point.position && point.category) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          const path = this.getPathByCategory(point.category);\n          if (path && !path.data.isCircle) {\n            const segmentIndex = path.data.points.findIndex(p => p === index);\n            path.segments[segmentIndex].point.x = point.position.x;\n            path.segments[segmentIndex].point.y = point.position.y;\n          }\n          const label = this.getLabelByPointIndex(index);\n          if (label && this.labelLayer) {\n            const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n            label.data.point = [point.position.x, point.position.y];\n            label.position.x = point.position.x + (this.props.pointSize + 6) / zoom;\n            label.position.y = point.position.y - (this.props.pointSize + 6) / zoom;\n          }\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const {\n          position,\n          category,\n          isKeyPoint,\n          visible\n        } = point;\n        if (position !== undefined && category !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          if (!updatedCategories.includes(category)) {\n            updatedCategories.push(category);\n          }\n          this.addPointShape(new Paper.Point(position.x, position.y), category, index, isKeyPoint, visible);\n        }\n      }\n    });\n    updatedCategories.forEach(category => {\n      this.updateCirclePath(category, this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE);\n    });\n    this.props.onPointsUpdated();\n  }\n  setPointSelected(pointIndex, selected) {\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      const point = this.getPointByPointIndex(pointIndex);\n      if (point) {\n        point.selected = selected;\n        if (selected) {\n          point.selectedColor = 'red';\n        } else {\n          point.selectedColor = 'white';\n        }\n      }\n    }\n  }\n  setMultiPointsSelected(selectedPoints) {\n    this.selectedPoints = selectedPoints.sort((a, b) => a.data.pointIndex - b.data.pointIndex);\n    let found = false;\n    this.selectedPoints.forEach(point => {\n      this.setPointSelected(point.data.pointIndex, true);\n      if (point.data.pointIndex === this.props.selectedPoint) {\n        found = true;\n      }\n    });\n    if (!found && this.selectedPoints.length > 0) {\n      this.props.setSelectedPoint(this.selectedPoints[0].data.pointIndex);\n    }\n  }\n  setMultiPointsUnselected() {\n    this.selectedPoints.forEach(point => {\n      this.setPointSelected(point.data.pointIndex, false);\n    });\n    this.selectedPoints = [];\n  }\n  updatePointsPosition(points) {\n    this.props.handlePointsChange(points.map(({\n      pointIndex,\n      position\n    }) => ({\n      pointIndex,\n      point: {\n        position\n      }\n    })));\n    if (this.labelLayer) {\n      const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n      points.forEach(({\n        pointIndex,\n        position\n      }) => {\n        const label = this.getLabelByPointIndex(pointIndex);\n        if (label) {\n          label.data.point = [position.x, position.y];\n          label.position.x = position.x + (this.props.pointSize + 6) / zoom;\n          label.position.y = position.y - (this.props.pointSize + 6) / zoom;\n        }\n      });\n    }\n  }\n  deleteSelectedPoints() {\n    const updatedCategories = [];\n    const points = (this.selectedPoints.length > 0 ? this.selectedPoints.map(p => p.data.pointIndex) : [this.props.selectedPoint]).filter(pIndex => {\n      const point = this.getPointByPointIndex(pIndex);\n      if (point && point.data && this.props.categoryPathShapes[point.data.category] === CategoryPathShape.CIRCLE) {\n        const path = this.getPathByCategory(point.data.category);\n        if (path && path.data.isCircle) {\n          const category = this.props.categories.find(c => c.name === point.data.category);\n          if (category) {\n            const sortedKeys = [...category.keys].sort((a, b) => a - b);\n            const pIndex1 = sortedKeys[0];\n            const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n            if (point.data.pointIndex !== pIndex1 && point.data.pointIndex !== pIndex2) {\n              return false;\n            }\n          }\n        }\n      }\n      return !!point;\n    });\n    this.props.handlePointsRemove(points);\n    points.forEach(p => {\n      const point = this.getPointByPointIndex(p);\n      if (point && !updatedCategories.includes(point.data.category)) {\n        updatedCategories.push(point.data.category);\n      }\n      this.removePointShape(p);\n    });\n    updatedCategories.forEach(category => {\n      this.updateCirclePath(category, this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE);\n    });\n    this.selectedPoints = [];\n  }\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ? this.selectedPoints.map(p => p.data.pointIndex) : [this.props.selectedPoint];\n    this.props.togglePointsVisibility(points);\n    if (this.labelLayer) {\n      points.forEach(pIndex => {\n        const point = this.getPointByPointIndex(pIndex);\n        const label = this.getLabelByPointIndex(pIndex);\n        if (point) {\n          point.data.visible = !point.data.visible;\n          point.fillColor = point.data.visible ? point.strokeColor : new Paper.Color('#3d424d');\n        }\n        if (label) {\n          label.content = `${point.data.visible ? '1' : '0'}-${pIndex}`;\n          label.fillColor = new Paper.Color(point.data.visible ? 'white' : 'red');\n        }\n      });\n    }\n  }\n  hitTest(event) {\n    if (this.mainLayer) {\n      this.cursor = 'default';\n      this.mainLayer.children.forEach(path => {\n        if (path.data.pointIndex !== this.props.selectedPoint && !this.isPointInSelectedPoints(path.data.pointIndex) && path !== this.smoothPath) {\n          // eslint-disable-next-line no-param-reassign\n          path.selected = false;\n        }\n      });\n      this.hits = this.mainLayer.hitTest(event.point, {\n        fill: true,\n        selected: false,\n        handles: true,\n        tolerance: 10 / (Paper.view.zoom * this.mainLayer.matrix.scaling.x),\n        match: ht => {\n          if (ht && ht.item && ht.item.data.type === undefined) {\n            return false;\n          }\n          return true;\n        }\n      });\n      if (this.hits && this.hits.item && !event.event.ctrlKey) {\n        this.hits.item.selected = true;\n        this.cursor = 'move';\n      }\n    }\n  }\n  getNewPointsByKeyPointRange(path, startKey, endKey) {\n    const startPosition = this.getPointByPointIndex(startKey).position;\n    const endPosition = this.getPointByPointIndex(endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    const newPoints = []; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints.push(nextPoint);\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n  getUpdatedPointsByNewPoints(path, newPoints, startKey, category) {\n    const updatedPoints = [];\n    for (let index = 0; index < newPoints.length; index += 1) {\n      const pointIndex = startKey + index + 1;\n      const existingPoint = this.getPointByPointIndex(pointIndex);\n      const {\n        x,\n        y\n      } = newPoints[index];\n      if (existingPoint) {\n        if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n          // update position\n          existingPoint.position.x = x;\n          existingPoint.position.y = y;\n          const segmentIndex = path.data.points.findIndex(p => p === pointIndex);\n          if (segmentIndex >= 0) {\n            path.segments[segmentIndex].point.x = x;\n            path.segments[segmentIndex].point.y = y;\n          }\n          if (this.labelLayer) {\n            const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n            const label = this.getLabelByPointIndex(pointIndex);\n            if (label) {\n              label.data.point = [x, y];\n              label.position.x = x + (this.props.pointSize + 6) / zoom;\n              label.position.y = y - (this.props.pointSize + 6) / zoom;\n            }\n          }\n          updatedPoints.push({\n            pointIndex,\n            point: {\n              position: {\n                x,\n                y\n              }\n            }\n          });\n        }\n      } else {\n        // add new point\n        const isKeyPoint = category.keys.includes(pointIndex);\n        this.addPointShape(new Paper.Point(x, y), category.name, pointIndex, isKeyPoint);\n        updatedPoints.push({\n          pointIndex,\n          point: {\n            category: category.name,\n            isKeyPoint,\n            position: {\n              x,\n              y\n            },\n            visible: true\n          }\n        });\n      }\n    }\n    return updatedPoints;\n  }\n  autoAdjust(point = this.props.selectedPoint) {\n    if (this.props.selectedPointInfo) {\n      const {\n        category: categoryName\n      } = this.props.selectedPointInfo;\n      const path = this.getPathByCategory(categoryName); // category path\n      const category = this.props.categories.find(c => c.name === categoryName); // category definition\n\n      if (path && category && this.props.categoryPathShapes[categoryName] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex;\n        let nextKeyPointIndex;\n        const {\n          points = []\n        } = path.data;\n        const {\n          keys = []\n        } = category;\n        const keysWithTwoSides = [...(keys.includes(points[0]) ? [] : [points[0]]), ...keys, ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]])].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex(key => key > point);\n        if (keyIndex < 0) {\n          // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex);\n          const updatedPoints = this.getUpdatedPointsByNewPoints(path, newPoints, prevKeyPointIndex, category);\n          if (updatedPoints.length > 0) {\n            this.props.handlePointsChange(updatedPoints);\n          }\n        }\n      }\n    }\n  }\n  switchSmoothMode() {\n    if (this.props.selectedPointInfo) {\n      const path = this.getPathByCategory(this.props.selectedPointInfo.category);\n      if (path && this.props.categoryPathShapes[this.props.selectedPointInfo.category] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const category = this.props.categories.find(c => c.name === this.props.selectedPointInfo.category);\n          if (category) {\n            const keyPoints = category.keys.filter(k => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedPoints = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i]);\n              updatedPoints = [...updatedPoints, ...this.getUpdatedPointsByNewPoints(path, newPoints, keyPoints[i - 1], category)];\n            }\n            if (updatedPoints.length > 0) {\n              this.props.handlePointsChange(updatedPoints);\n            }\n          }\n          this.clearSmooth();\n        } else {\n          // start\n          path.fullySelected = true;\n          path.smooth({\n            type: 'continuous'\n          });\n          this.smoothPath = path;\n        }\n      }\n    }\n  }\n  clearSmooth() {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach(seg => {\n        seg.clearHandles();\n      });\n      this.smoothPath = null;\n    }\n  }\n  setCategoryAsCircle() {\n    if (this.props.selectedPointInfo) {\n      const {\n        category\n      } = this.props.selectedPointInfo;\n      if (this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE) {\n        this.updateCirclePath(category, false);\n        this.props.setCategoryPathShape(category);\n      } else {\n        const updatedPoints = this.updateCirclePath(category);\n        this.props.setCategoryPathShape(category, CategoryPathShape.CIRCLE, updatedPoints);\n      }\n    }\n  }\n  updateCirclePath(categoryName, isCirclePath = true) {\n    const updatedPoints = [];\n    const path = this.getPathByCategory(categoryName);\n    if (path) {\n      const category = this.props.categories.find(c => c.name === categoryName);\n      const categoryPoints = this.getPointsByCategory(categoryName);\n      if (category && categoryPoints) {\n        const sortedKeys = [...category.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find(p => p.data.pointIndex === pIndex1);\n        const point2 = categoryPoints.find(p => p.data.pointIndex === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n        if (point1 && point2 && isCirclePath) {\n          // is a circle & key points all exist\n          const centerX = (point1.position.x + point2.position.x) / 2;\n          const centerY = (point1.position.y + point2.position.y) / 2;\n          const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n          const newPath = new Paper.CompoundPath({\n            children: [new Paper.Path.Circle({\n              center: [centerX, centerY],\n              radius\n            }), new Paper.Path.Line({\n              from: [point1.position.x, point1.position.y],\n              to: [point2.position.x, point2.position.y]\n            }), new Paper.Path.Line({\n              from: new Paper.Point(rotatePoint(centerX, centerY, point1.position.x, point1.position.y, Math.PI / 2)),\n              to: new Paper.Point(rotatePoint(centerX, centerY, point1.position.x, point1.position.y, -Math.PI / 2))\n            })],\n            strokeWidth: this.props.lineWidth / zoom,\n            strokeColor: POINT_COLOR,\n            selectedColor: POINT_COLOR\n          });\n          newPath.data = {\n            ...path.data,\n            isCircle: true\n          };\n          path.replaceWith(newPath);\n\n          // update all points in this category\n          const update = (index, position) => {\n            const existingPoint = this.getPointByPointIndex(index);\n            if (existingPoint) {\n              // update position\n              existingPoint.position.x = position.x;\n              existingPoint.position.y = position.y;\n              if (this.labelLayer) {\n                const labelZoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n                const label = this.getLabelByPointIndex(index);\n                if (label) {\n                  label.data.point = [position.x, position.y];\n                  label.position.x = position.x + (this.props.pointSize + 6) / labelZoom;\n                  label.position.y = position.y - (this.props.pointSize + 6) / labelZoom;\n                }\n              }\n              updatedPoints.push({\n                pointIndex: index,\n                point: {\n                  position: {\n                    x: position.x,\n                    y: position.y\n                  }\n                }\n              });\n            } else {\n              const isKeyPoint = category.keys.includes(index);\n              this.addPointShape(new Paper.Point(position.x, position.y), category.name, index, isKeyPoint);\n              updatedPoints.push({\n                pointIndex: index,\n                point: {\n                  category: category.name,\n                  isKeyPoint,\n                  position: {\n                    x: position.x,\n                    y: position.y\n                  },\n                  visible: true\n                }\n              });\n            }\n          };\n          const [start, end] = category.range;\n          for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n            const radians = Math.PI / (pIndex2 - pIndex1) * (i - pIndex1);\n            const position = rotatePoint(centerX, centerY, point1.position.x, point1.position.y, radians);\n            update(i, position);\n          }\n          for (let i = pIndex2 + 1; i <= end; i += 1) {\n            const radians = Math.PI / (end + 1 - pIndex2) * (i - pIndex2);\n            const position = rotatePoint(centerX, centerY, point2.position.x, point2.position.y, radians);\n            update(i, position);\n          }\n          for (let i = start; i < pIndex1; i += 1) {\n            const radians = Math.PI / (end + 1 - pIndex2) * (start - pIndex1);\n            const position = rotatePoint(centerX, centerY, point1.position.x, point1.position.y, radians);\n            update(i, position);\n          }\n        } else {\n          const points = [...categoryPoints].sort((a, b) => a.data.pointIndex - b.data.pointIndex);\n          const newPath = new Paper.Path({\n            segments: points.map(p => p.position),\n            strokeWidth: this.props.lineWidth / zoom,\n            strokeColor: POINT_COLOR,\n            selectedColor: POINT_COLOR\n          });\n          newPath.data = {\n            ...path.data,\n            isCircle: false,\n            points: points.map(p => p.data.pointIndex)\n          };\n          path.replaceWith(newPath);\n        }\n      }\n    }\n    return updatedPoints;\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: this.canvasContainer,\n      className: \"canvas\",\n      style: {\n        cursor: this.cursor\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1045,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: this.canvas,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1046,\n        columnNumber: 9\n      }\n    }), (this.loading || this.props.dataLoading) && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"loading\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1048,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Spin, {\n      indicator: /*#__PURE__*/React.createElement(LoadingOutlined, {\n        style: {\n          fontSize: 100,\n          color: '#00bad3'\n        },\n        spin: true,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1049,\n          columnNumber: 30\n        }\n      }),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1049,\n        columnNumber: 13\n      }\n    })));\n  }\n}, _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"cursor\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 'default';\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"loading\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return true;\n  }\n}), _applyDecoratedDescriptor(_class2.prototype, \"hitTest\", [_dec], Object.getOwnPropertyDescriptor(_class2.prototype, \"hitTest\"), _class2.prototype), _class2)) || _class);\nexport default Canvas;","map":{"version":3,"names":["React","observable","action","makeObservable","observer","Paper","imageLoader","ImageFilters","Spin","LoadingOutlined","Tool","CategoryPathShape","ZOOM_MIN","ZOOM_MAX","GRID_GAP","GRID_LINE_WIDTH","FONT_SIZE","POINT_COLOR","KEY_POINT_COLOR","SHAPE_TYPE","POINT","PATH","rotatePoint","originX","originY","x","y","radians","cos","Math","sin","nx","ny","Canvas","_dec","bound","_class","_class2","Component","constructor","props","_initializerDefineProperty","_descriptor","_descriptor2","canvas","createRef","canvasContainer","imageCanvas","imageData","raster","rasterLayer","gridLayer","labelLayer","mainLayer","tool","hits","selectedPoints","smoothPath","resize","current","offsetWidth","viewWidth","offsetHeight","viewHeight","view","viewSize","Size","center","Point","zoom","width","imgWidth","height","imgHeight","viewRatio","imgRatio","scaleFactor","offsetX","offsetY","matrix","Matrix","translate","scale","project","layers","forEach","layer","position","resizeGrid","resizeShapes","event","mousePosition","viewPosition","viewToProject","oldZoom","oldCenter","newZoom","deltaY","max","min","zoomScale","offset","subtract","multiply","add","componentDidMount","setup","setupLayers","setupTools","loadImage","addEventListener","e","preventDefault","window","componentDidUpdate","prevProps","JSON","stringify","defaultPoints","length","cleanPoints","updatedCategories","point","category","index","isKeyPoint","visible","undefined","includes","push","addPointShape","updateCirclePath","categoryPathShapes","CIRCLE","updatedPoints","updatePoints","isGridVisible","isLabelVisible","pointSize","lineWidth","selectedPoint","setPointSelected","isPointInSelectedPoints","setMultiPointsUnselected","selectedPointInfo","clearSmooth","filters","updateFilters","componentWillUnmount","removeEventListener","Layer","applyMatrix","onMouseMove","hitTest","activate","image","c","_this$imageCanvas$get","getContext","getImageData","Raster","onLoad","addGrid","loading","orientation","crossOrigin","data","brightness","contrast","saturation","lightness","hue","rescale","BrightnessContrastPhotoshop","Rescale","HSLAdjustment","setImageData","rows","ceil","Array","from","_","_this$gridLayer","path","Path","Line","to","strokeColor","dashed","addChild","cols","_this$gridLayer2","children","scaling","baseWidth","strokeWidth","dashArray","pointIndex","findIndex","p","isPointInImage","localPoint","globalToLocal","getPointInImage","getPointByPointIndex","_this$mainLayer","find","type","getLabelByPointIndex","_this$labelLayer","l","getPathByCategory","_this$mainLayer2","getPointsByCategory","_this$mainLayer3","filter","canAddPoint","addPoint","newPoint","otherPoints","handlePointsChange","setNextEmptyPoint","pointColor","pointCircle","Shape","Circle","radius","fillColor","selectedColor","segment","Segment","isCircle","points","insert","splice","segments","sendToBack","smooth","fullySelected","label","PointText","content","fontSize","shadowColor","shadowBlur","removePointShape","remove","removeSegment","set","removeChildren","currPoint","segmentIndex","onPointsUpdated","selected","setMultiPointsSelected","sort","a","b","found","setSelectedPoint","updatePointsPosition","map","deleteSelectedPoints","pIndex","categories","name","sortedKeys","keys","pIndex1","pIndex2","handlePointsRemove","toggleSelectedPointVisibility","togglePointsVisibility","Color","cursor","fill","handles","tolerance","match","ht","item","ctrlKey","getNewPointsByKeyPointRange","startKey","endKey","startPosition","endPosition","segmentLength","getOffsetOf","newPoints","base","basePoint","baseOffset","nextPoint","getPointAt","getUpdatedPointsByNewPoints","existingPoint","autoAdjust","categoryName","prevKeyPointIndex","nextKeyPointIndex","keysWithTwoSides","keyIndex","key","i","switchSmoothMode","keyPoints","k","seg","clearHandles","setCategoryAsCircle","setCategoryPathShape","isCirclePath","categoryPoints","point1","point2","centerX","centerY","sqrt","newPath","CompoundPath","PI","replaceWith","update","labelZoom","start","end","range","render","createElement","ref","className","style","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","dataLoading","indicator","color","spin","_applyDecoratedDescriptor","prototype","configurable","enumerable","writable","initializer","Object","getOwnPropertyDescriptor"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/landmark-annotation/components/Canvas.tsx"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport React from 'react';\nimport { observable, action, makeObservable } from 'mobx';\nimport { observer } from 'mobx-react';\nimport Paper from 'paper';\nimport imageLoader from 'blueimp-load-image';\nimport ImageFilters from 'canvas-filters';\nimport { Spin } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nimport Tool, { ToolEventExtend } from '../tools/Tool';\nimport { Point, PointListItem, PointStatus, CategoryItem, CategoryPathShape } from '../types';\nimport './Canvas.scss';\n\nconst ZOOM_MIN = 0.5;\nconst ZOOM_MAX = 100;\nconst GRID_GAP = 10;\nconst GRID_LINE_WIDTH = 1;\nconst FONT_SIZE = 18;\nconst POINT_COLOR = '#5cdef0';\nconst KEY_POINT_COLOR = '#ffb86d';\nexport const SHAPE_TYPE = {\n  POINT: 'point',\n  PATH: 'path',\n};\n\nfunction rotatePoint(originX: number, originY: number, x: number, y: number, radians: number) {\n  const cos = Math.cos(-radians);\n  const sin = Math.sin(-radians);\n  const nx = cos * (x - originX) + sin * (y - originY) + originX;\n  const ny = cos * (y - originY) - sin * (x - originX) + originY;\n  return { x: nx, y: ny };\n}\n\ninterface Props {\n  image: string;\n  categories: CategoryItem[];\n  defaultPoints: PointListItem[];\n  updatedPoints: PointStatus[];\n  isGridVisible: boolean;\n  setGridVisible: (visible: boolean) => void;\n  isLabelVisible: boolean;\n  setLabelVisible: (visible: boolean) => void;\n  pointSize: number;\n  lineWidth: number;\n  selectedPoint: number;\n  selectedPointInfo: {\n    category: string;\n    isKeyPoint: boolean;\n  } | null;\n  setSelectedPoint: (point: number) => void;\n  handlePointsChange: (points: { pointIndex: number; point: Point }[]) => void;\n  handlePointsRemove: (points: number[]) => void;\n  togglePointsVisibility: (points: number[]) => void;\n  setNextEmptyPoint: () => void;\n  onPointsUpdated: () => void;\n  undo: () => void;\n  redo: () => void;\n  onSave: () => void;\n  isFullScreen: boolean;\n  setFullScreen: (full: boolean) => void;\n  filters: {[key: string]: number};\n  dataLoading: boolean;\n  categoryPathShapes: {[categoryName: string]: CategoryPathShape};\n  setCategoryPathShape: (categoryName: string, type?: CategoryPathShape, updatedPoints?: { pointIndex: number; point: Point }[]) => void;\n}\n\n@observer\nclass Canvas extends React.Component<Props> {\n  @observable cursor = 'default';\n\n  @observable loading = true;\n\n  canvas: React.RefObject<HTMLCanvasElement> = React.createRef();\n\n  canvasContainer: React.RefObject<HTMLDivElement> = React.createRef();\n\n  imageCanvas: HTMLCanvasElement | undefined;\n\n  imageData: ImageData | undefined;\n\n  raster: paper.Raster | undefined;\n\n  rasterLayer: paper.Layer | undefined;\n\n  gridLayer: paper.Layer | undefined;\n\n  labelLayer: paper.Layer | undefined;\n\n  mainLayer: paper.Layer | undefined;\n\n  tool: paper.Tool | undefined;\n\n  hits: paper.HitResult | null = null;\n\n  selectedPoints: paper.Shape[] = [];\n\n  smoothPath: paper.Path | null = null;\n\n  constructor(props: Props) {\n    super(props);\n    makeObservable(this);\n  }\n\n  componentDidMount() {\n    if (this.canvas.current) {\n      // init canvas\n      Paper.setup(this.canvas.current);\n      // setup layers\n      this.setupLayers();\n      // setuo tools\n      this.setupTools();\n\n      // load image\n      this.loadImage();\n      this.canvas.current.addEventListener('wheel', this.zoom, false);\n      this.canvas.current.addEventListener('contextmenu', (e) => e.preventDefault(), false);\n    }\n\n    window.addEventListener('resize', this.resize, false);\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    // default points\n    if (JSON.stringify(prevProps.defaultPoints) !== JSON.stringify(this.props.defaultPoints) && this.props.defaultPoints.length > 0) {\n      this.cleanPoints();\n      const updatedCategories: string[] = [];\n      this.props.defaultPoints.forEach((point) => {\n        const { position, category, index, isKeyPoint, visible } = point;\n        if (position !== undefined && category !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          if (!updatedCategories.includes(category)) {\n            updatedCategories.push(category);\n          }\n          this.addPointShape(new Paper.Point(position.x, position.y), category, index, isKeyPoint, visible);\n        }\n      });\n      updatedCategories.forEach((category) => {\n        this.updateCirclePath(category, this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE);\n      });\n    }\n\n    // undo & redo to update points\n    if (JSON.stringify(prevProps.updatedPoints) !== JSON.stringify(this.props.updatedPoints) && this.props.updatedPoints.length > 0) {\n      this.updatePoints();\n    }\n\n    // visibility changes\n    if (prevProps.isGridVisible !== this.props.isGridVisible) {\n      if (this.gridLayer) {\n        this.gridLayer.visible = this.props.isGridVisible;\n      }\n    }\n    if (prevProps.isLabelVisible !== this.props.isLabelVisible) {\n      if (this.labelLayer) {\n        this.labelLayer.visible = this.props.isLabelVisible;\n      }\n    }\n    // size changes\n    if (prevProps.pointSize !== this.props.pointSize || prevProps.lineWidth !== this.props.lineWidth) {\n      this.resizeShapes();\n    }\n\n    // selected changes\n    if (prevProps.selectedPoint !== this.props.selectedPoint) {\n      if (this.selectedPoints.length <= 0) {\n        this.setPointSelected(prevProps.selectedPoint, false);\n      } else if (!this.isPointInSelectedPoints(this.props.selectedPoint)) {\n        this.setMultiPointsUnselected();\n      }\n      this.setPointSelected(this.props.selectedPoint, true);\n    }\n    if ((prevProps.selectedPointInfo || {}).category !== (this.props.selectedPointInfo || {}).category) {\n      this.clearSmooth();\n    }\n\n    if (JSON.stringify(prevProps.filters) !== JSON.stringify(this.props.filters)) {\n      this.updateFilters();\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.resize, false);\n  }\n\n  setupLayers() {\n    this.rasterLayer = new Paper.Layer();\n    this.rasterLayer.applyMatrix = false;\n    this.rasterLayer.visible = false;\n\n    this.gridLayer = new Paper.Layer();\n    this.gridLayer.applyMatrix = false;\n    this.gridLayer.visible = false;\n\n    this.mainLayer = new Paper.Layer();\n    this.mainLayer.applyMatrix = false;\n    this.mainLayer.visible = false;\n\n    this.labelLayer = new Paper.Layer();\n    this.labelLayer.applyMatrix = false;\n    this.labelLayer.visible = false;\n\n    Paper.view.onMouseMove = this.hitTest;\n\n    // this.rasterLayer.on('mousemove', this.hitTest);\n    // this.mainLayer.on('mousemove', this.hitTest);\n  }\n\n  setupTools() {\n    this.tool = new Tool(this);\n    this.tool.activate();\n  }\n\n  loadImage() {\n    if (this.rasterLayer) {\n      this.rasterLayer.activate();\n      imageLoader(this.props.image, (c) => {\n        const canvas = c as HTMLCanvasElement;\n        this.imageCanvas = canvas;\n        this.imageData = this.imageCanvas.getContext('2d')?.getImageData(0, 0, this.imageCanvas.width, this.imageCanvas.height);\n        this.raster = new Paper.Raster(this.imageCanvas);\n        this.raster.onLoad = () => {\n          this.resize(); // resize to fit the container\n          this.addGrid(); // add grid to image\n\n          this.loading = false;\n          // when onload, show all layers\n          if (this.rasterLayer) {\n            this.rasterLayer.visible = true;\n          }\n          if (this.mainLayer) {\n            this.mainLayer.visible = true;\n          }\n          if (this.gridLayer) {\n            this.gridLayer.visible = this.props.isGridVisible;\n          }\n          if (this.labelLayer) {\n            this.labelLayer.visible = this.props.isLabelVisible;\n          }\n        };\n      }, {\n        canvas: true,\n        orientation: true,\n        crossOrigin: 'anonymous',\n      });\n    }\n  }\n\n  updateFilters() {\n    if (this.imageData && this.raster) {\n      let data = this.imageData;\n      const { brightness, contrast, saturation, lightness, hue, rescale } = this.props.filters;\n      if (brightness || contrast) {\n        data = ImageFilters.BrightnessContrastPhotoshop(data, brightness, contrast);\n      }\n      if (rescale !== 1) {\n        data = ImageFilters.Rescale(data, rescale);\n      }\n      if (hue || saturation || lightness) {\n        data = ImageFilters.HSLAdjustment(data, hue, saturation, lightness);\n      }\n      this.raster.setImageData(data, new Paper.Point(0, 0));\n    }\n  }\n\n  resize = () => {\n    if (this.canvasContainer.current) {\n      // set view size\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      Paper.view.viewSize = new Paper.Size(viewWidth, viewHeight);\n      Paper.view.center = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      Paper.view.zoom = 1;\n\n      if (this.imageCanvas && this.raster) {\n        // resize image\n        const { width: imgWidth, height: imgHeight } = this.imageCanvas;\n        const viewRatio = viewWidth / viewHeight;\n        const imgRatio = imgWidth / imgHeight;\n        const scaleFactor = (viewRatio < imgRatio ? viewWidth / imgWidth : viewHeight / imgHeight) * 0.98;\n        const offsetX = (viewWidth - scaleFactor * imgWidth) / 2;\n        const offsetY = (viewHeight - scaleFactor * imgHeight) / 2;\n        const matrix = new Paper.Matrix().translate(offsetX, offsetY).scale(scaleFactor);\n        // apply matrix to all layers\n        Paper.project.layers.forEach((layer) => {\n          layer.matrix = matrix;\n        });\n        // reset image center\n        this.raster.position = new Paper.Point({ x: imgWidth / 2, y: imgHeight / 2 });\n      }\n\n      this.resizeGrid();\n      this.resizeShapes();\n    }\n  };\n\n  zoom = (event: WheelEvent) => {\n    if (this.canvasContainer.current) {\n      const mousePosition = new Paper.Point(event.offsetX, event.offsetY);\n      const viewPosition = Paper.view.viewToProject(mousePosition);\n\n      const oldZoom = Paper.view.zoom;\n      const oldCenter = Paper.view.center;\n\n      const { offsetWidth: viewWidth, offsetHeight: viewHeight } = this.canvasContainer.current;\n      let newZoom = event.deltaY > 0 ? Paper.view.zoom * 1.1 : Paper.view.zoom / 1.1;\n      if (newZoom <= 1) {\n        Paper.view.center = new Paper.Point({ x: viewWidth / 2, y: viewHeight / 2 });\n      }\n      newZoom = Math.max(Math.min(newZoom, ZOOM_MAX), ZOOM_MIN);\n      if (newZoom !== Paper.view.zoom) {\n        Paper.view.zoom = newZoom;\n        const zoomScale = oldZoom / newZoom;\n        const offset = viewPosition.subtract(viewPosition.subtract(oldCenter).multiply(zoomScale)).subtract(oldCenter);\n        Paper.view.center = Paper.view.center.add(offset);\n      }\n\n      this.resizeGrid();\n      this.resizeShapes();\n    }\n  };\n\n  addGrid() {\n    if (this.gridLayer && this.imageCanvas) {\n      const { width, height } = this.imageCanvas;\n\n      const rows = Math.ceil(height / GRID_GAP);\n      Array.from({ length: rows }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [0, index * GRID_GAP],\n          to: [width, index * GRID_GAP],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n\n      const cols = Math.ceil(width / GRID_GAP);\n      Array.from({ length: cols }).forEach((_, index) => {\n        const path = new Paper.Path.Line({\n          from: [index * GRID_GAP, 0],\n          to: [index * GRID_GAP, height],\n          strokeColor: '#333333',\n        });\n        if (index % 4 === 0) {\n          path.data.dashed = false;\n        } else {\n          path.data.dashed = true;\n        }\n        this.gridLayer?.addChild(path);\n      });\n\n      this.resizeGrid();\n    }\n  }\n\n  resizeGrid() {\n    if (this.gridLayer && this.gridLayer.children && this.gridLayer.children.length > 0) {\n      // keep grid line width looks the same\n      const zoom = Paper.view.zoom * this.gridLayer.matrix.scaling.x;\n      this.gridLayer.children.forEach((path) => {\n        const baseWidth = GRID_LINE_WIDTH / zoom;\n        if (path.data.dashed) {\n          path.strokeWidth = baseWidth / 2;\n          path.dashArray = [baseWidth * 4, baseWidth];\n        } else {\n          path.strokeWidth = baseWidth;\n          path.dashArray = [];\n        }\n      });\n    }\n  }\n\n  isPointInSelectedPoints(pointIndex: number) {\n    return this.selectedPoints.findIndex((p) => p.data.pointIndex === pointIndex) >= 0;\n  }\n\n  isPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return false;\n\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    const { width, height } = this.imageCanvas;\n\n    return localPoint.x >= 0 && localPoint.x <= width && localPoint.y >= 0 && localPoint.y <= height;\n  }\n\n  getPointInImage(point: paper.Point) {\n    if (!this.imageCanvas || !this.rasterLayer) return point;\n\n    const localPoint = this.rasterLayer.globalToLocal(Paper.view.viewToProject(point));\n    /* const { width, height } = this.imageCanvas;\n\n    if (localPoint.x < 0) {\n      localPoint.x = 0;\n    } else if (localPoint.x > width) {\n      localPoint.x = width;\n    }\n    if (localPoint.y < 0) {\n      localPoint.y = 0;\n    } else if (localPoint.y > height) {\n      localPoint.y = height;\n    } */\n\n    return localPoint;\n  }\n\n  getPointByPointIndex(pointIndex: number) {\n    return this.mainLayer?.children.find((p) => p.data.type === SHAPE_TYPE.POINT && p.data.pointIndex === pointIndex) as paper.Shape;\n  }\n\n  getLabelByPointIndex(pointIndex: number) {\n    return this.labelLayer?.children.find((l) => l.data.pointIndex === pointIndex) as paper.PointText;\n  }\n\n  getPathByCategory(category: string) {\n    return this.mainLayer?.children.find((p) => p.data.type === SHAPE_TYPE.PATH && p.data.category === category) as paper.Path;\n  }\n\n  getPointsByCategory(category: string) {\n    return this.mainLayer?.children.filter((p) => p.data.type === SHAPE_TYPE.POINT && p.data.category === category);\n  }\n\n  canAddPoint() {\n    if (this.mainLayer && this.props.selectedPointInfo) {\n      const { category } = this.props.selectedPointInfo;\n      return this.mainLayer.children.findIndex((p) => (\n        p.data.type === SHAPE_TYPE.POINT && p.data.category === category && p.data.pointIndex === this.props.selectedPoint\n      )) < 0;\n    }\n    return false;\n  }\n\n  addPoint(point: paper.Point) {\n    if (this.mainLayer && this.props.selectedPointInfo) {\n      const { x, y } = this.mainLayer.globalToLocal(Paper.view.viewToProject(point));\n      const newPoint = new Paper.Point(x, y);\n      const { category, isKeyPoint } = this.props.selectedPointInfo;\n\n      this.addPointShape(newPoint, category, this.props.selectedPoint, isKeyPoint);\n      let otherPoints;\n      if (this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE) {\n        otherPoints = this.updateCirclePath(category);\n      }\n\n      this.props.handlePointsChange([{\n        pointIndex: this.props.selectedPoint,\n        point: {\n          category,\n          isKeyPoint,\n          position: { x, y },\n          visible: true, // default is visible when point added\n        },\n      }, ...(otherPoints || [])]);\n      this.props.setNextEmptyPoint(); // move next\n    }\n  }\n\n  addPointShape(point: paper.Point, category: string, pointIndex: number, isKeyPoint: boolean, visible = true) {\n    if (this.mainLayer) {\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n\n      // add point\n      const pointColor = isKeyPoint ? KEY_POINT_COLOR : POINT_COLOR;\n      const pointCircle = new Paper.Shape.Circle({\n        center: point,\n        radius: this.props.pointSize / zoom,\n        fillColor: visible ? pointColor : '#3d424d',\n        strokeColor: pointColor,\n        strokeWidth: 1 / zoom,\n        selectedColor: 'white',\n      });\n      pointCircle.data.type = SHAPE_TYPE.POINT;\n      pointCircle.data.category = category;\n      pointCircle.data.pointIndex = pointIndex;\n      pointCircle.data.visible = visible;\n      this.mainLayer.addChild(pointCircle);\n\n      // add point to path\n      const segment = new Paper.Segment(point);\n      let path = this.getPathByCategory(category);\n      let index = 0;\n      if (path) {\n        if (!path.data.isCircle) {\n          index = path.data.points.findIndex((p: number) => pointIndex < p);\n          if (index < 0) {\n            path.add(segment);\n            index = path.data.points.push(pointIndex) - 1;\n          } else {\n            path.insert(index, segment);\n            path.data.points.splice(index, 0, pointIndex);\n          }\n        }\n      } else {\n        path = new Paper.Path({\n          segments: [segment],\n          strokeWidth: this.props.lineWidth / zoom,\n          strokeColor: POINT_COLOR,\n          selectedColor: POINT_COLOR,\n        });\n        path.data.type = SHAPE_TYPE.PATH;\n        path.data.category = category;\n        path.data.points = [pointIndex];\n        this.mainLayer.addChild(path);\n      }\n      path.sendToBack();\n\n      if (path === this.smoothPath) {\n        path.smooth({ from: index - 1, to: index + 1, type: 'continuous' });\n        path.fullySelected = true;\n      }\n    }\n\n    if (this.labelLayer) {\n      const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n      const label = new Paper.PointText({\n        content: `${visible ? '1' : '0'}-${pointIndex}`,\n        fontSize: FONT_SIZE / zoom,\n        fillColor: visible ? 'white' : 'red',\n        shadowColor: '#333333',\n        shadowBlur: 1 / zoom,\n      });\n      label.data.point = [point.x, point.y];\n      label.data.pointIndex = pointIndex;\n      label.position.x = point.x + (this.props.pointSize + 6) / zoom;\n      label.position.y = point.y - (this.props.pointSize + 6) / zoom;\n      this.labelLayer.addChild(label);\n    }\n  }\n\n  removePointShape(pointIndex: number) {\n    if (this.mainLayer) {\n      const point = this.getPointByPointIndex(pointIndex);\n      if (point) {\n        point.remove();\n        const path = this.getPathByCategory(point.data.category);\n        if (!path.data.isCircle) {\n          const index = path.data.points.findIndex((p: number) => p === pointIndex);\n          if (index >= 0) {\n            path.removeSegment(index);\n            path.data.points.splice(index, 1);\n          }\n        }\n      }\n    }\n\n    if (this.labelLayer) {\n      const label = this.getLabelByPointIndex(pointIndex);\n      if (label) {\n        label.remove();\n      }\n    }\n  }\n\n  resizeShapes() {\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      const zoom = Paper.view.zoom * this.mainLayer.matrix.scaling.x;\n      this.mainLayer.children.forEach((path) => {\n        if (path.data.type === SHAPE_TYPE.POINT) {\n          path.set({ radius: this.props.pointSize / zoom });\n          path.strokeWidth = 1 / zoom;\n        } else if (path.data.type === SHAPE_TYPE.PATH) {\n          path.strokeWidth = this.props.lineWidth / zoom;\n        }\n      });\n    }\n    if (this.labelLayer && this.labelLayer.children && this.labelLayer.children.length > 0) {\n      const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n      this.labelLayer.children.forEach((label) => {\n        label.set({\n          fontSize: FONT_SIZE / zoom,\n          shadowBlur: 1 / zoom,\n        });\n        label.position.x = label.data.point[0] + (this.props.pointSize + 6) / zoom;\n        label.position.y = label.data.point[1] - (this.props.pointSize + 6) / zoom;\n      });\n    }\n  }\n\n  cleanPoints() {\n    if (this.mainLayer) {\n      this.mainLayer.removeChildren();\n    }\n  }\n\n  updatePoints() {\n    const updatedCategories: string[] = [];\n    this.props.updatedPoints.forEach(({ index, point }) => {\n      const currPoint = this.getPointByPointIndex(index);\n      if (currPoint) {\n        if (!updatedCategories.includes(currPoint.data.category)) {\n          updatedCategories.push(currPoint.data.category);\n        }\n        // alreay exist, should update\n        if (point === undefined) {\n          // delete\n          this.removePointShape(index);\n        } else if (point.position && point.category) {\n          // update position\n          currPoint.position.x = point.position.x;\n          currPoint.position.y = point.position.y;\n          const path = this.getPathByCategory(point.category);\n          if (path && !path.data.isCircle) {\n            const segmentIndex = path.data.points.findIndex((p: number) => p === index);\n            path.segments[segmentIndex].point.x = point.position.x;\n            path.segments[segmentIndex].point.y = point.position.y;\n          }\n          const label = this.getLabelByPointIndex(index);\n          if (label && this.labelLayer) {\n            const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n            label.data.point = [point.position.x, point.position.y];\n            label.position.x = point.position.x + (this.props.pointSize + 6) / zoom;\n            label.position.y = point.position.y - (this.props.pointSize + 6) / zoom;\n          }\n        }\n      } else if (point) {\n        //  has been removed, should add\n        const { position, category, isKeyPoint, visible } = point;\n        if (position !== undefined && category !== undefined && index !== undefined && isKeyPoint !== undefined) {\n          if (!updatedCategories.includes(category)) {\n            updatedCategories.push(category);\n          }\n          this.addPointShape(new Paper.Point(position.x, position.y), category, index, isKeyPoint, visible);\n        }\n      }\n    });\n    updatedCategories.forEach((category) => {\n      this.updateCirclePath(category, this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE);\n    });\n    this.props.onPointsUpdated();\n  }\n\n  setPointSelected(pointIndex: number, selected: boolean) {\n    if (this.mainLayer && this.mainLayer.children && this.mainLayer.children.length > 0) {\n      const point = this.getPointByPointIndex(pointIndex);\n      if (point) {\n        point.selected = selected;\n        if (selected) {\n          point.selectedColor = 'red' as unknown as paper.Color;\n        } else {\n          point.selectedColor = 'white' as unknown as paper.Color;\n        }\n      }\n    }\n  }\n\n  setMultiPointsSelected(selectedPoints: paper.Shape[]) {\n    this.selectedPoints = selectedPoints.sort((a, b) => a.data.pointIndex - b.data.pointIndex);\n    let found = false;\n    this.selectedPoints.forEach((point) => {\n      this.setPointSelected(point.data.pointIndex, true);\n      if (point.data.pointIndex === this.props.selectedPoint) {\n        found = true;\n      }\n    });\n    if (!found && this.selectedPoints.length > 0) {\n      this.props.setSelectedPoint(this.selectedPoints[0].data.pointIndex);\n    }\n  }\n\n  setMultiPointsUnselected() {\n    this.selectedPoints.forEach((point) => {\n      this.setPointSelected(point.data.pointIndex, false);\n    });\n    this.selectedPoints = [];\n  }\n\n  updatePointsPosition(points: { pointIndex: number, position: { x: number; y: number } }[]) {\n    this.props.handlePointsChange(points.map(({ pointIndex, position }) => ({ pointIndex, point: { position } })));\n\n    if (this.labelLayer) {\n      const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n      points.forEach(({ pointIndex, position }) => {\n        const label = this.getLabelByPointIndex(pointIndex);\n        if (label) {\n          label.data.point = [position.x, position.y];\n          label.position.x = position.x + (this.props.pointSize + 6) / zoom;\n          label.position.y = position.y - (this.props.pointSize + 6) / zoom;\n        }\n      });\n    }\n  }\n\n  deleteSelectedPoints() {\n    const updatedCategories: string[] = [];\n    const points = (this.selectedPoints.length > 0 ? this.selectedPoints.map((p) => p.data.pointIndex) : [this.props.selectedPoint]).filter((pIndex) => {\n      const point = this.getPointByPointIndex(pIndex);\n      if (point && point.data && this.props.categoryPathShapes[point.data.category] === CategoryPathShape.CIRCLE) {\n        const path = this.getPathByCategory(point.data.category);\n        if (path && path.data.isCircle) {\n          const category = this.props.categories.find((c) => c.name === point.data.category);\n          if (category) {\n            const sortedKeys = [...category.keys].sort((a, b) => a - b);\n            const pIndex1 = sortedKeys[0];\n            const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n            if (point.data.pointIndex !== pIndex1 && point.data.pointIndex !== pIndex2) {\n              return false;\n            }\n          }\n        }\n      }\n      return !!point;\n    });\n    this.props.handlePointsRemove(points);\n    points.forEach((p) => {\n      const point = this.getPointByPointIndex(p);\n      if (point && !updatedCategories.includes(point.data.category)) {\n        updatedCategories.push(point.data.category);\n      }\n      this.removePointShape(p);\n    });\n    updatedCategories.forEach((category) => {\n      this.updateCirclePath(category, this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE);\n    });\n    this.selectedPoints = [];\n  }\n\n  toggleSelectedPointVisibility() {\n    const points = this.selectedPoints.length > 0 ? this.selectedPoints.map((p) => p.data.pointIndex) : [this.props.selectedPoint];\n    this.props.togglePointsVisibility(points);\n    if (this.labelLayer) {\n      points.forEach((pIndex) => {\n        const point = this.getPointByPointIndex(pIndex);\n        const label = this.getLabelByPointIndex(pIndex);\n        if (point) {\n          point.data.visible = !point.data.visible;\n          point.fillColor = point.data.visible ? point.strokeColor : new Paper.Color('#3d424d');\n        }\n        if (label) {\n          label.content = `${point.data.visible ? '1' : '0'}-${pIndex}`;\n          label.fillColor = new Paper.Color(point.data.visible ? 'white' : 'red');\n        }\n      });\n    }\n  }\n\n  @action.bound\n  hitTest(event: ToolEventExtend) {\n    if (this.mainLayer) {\n      this.cursor = 'default';\n      this.mainLayer.children.forEach((path) => {\n        if (path.data.pointIndex !== this.props.selectedPoint && !this.isPointInSelectedPoints(path.data.pointIndex) && path !== this.smoothPath) {\n          // eslint-disable-next-line no-param-reassign\n          path.selected = false;\n        }\n      });\n\n      this.hits = this.mainLayer.hitTest(event.point, {\n        fill: true,\n        selected: false,\n        handles: true,\n        tolerance: 10 / (Paper.view.zoom * this.mainLayer.matrix.scaling.x),\n        match: (ht: any) => {\n          if (ht && ht.item && ht.item.data.type === undefined) {\n            return false;\n          }\n          return true;\n        }\n      });\n      if (this.hits && this.hits.item && !event.event.ctrlKey) {\n        this.hits.item.selected = true;\n        this.cursor = 'move';\n      }\n    }\n  }\n\n  getNewPointsByKeyPointRange(path: paper.Path, startKey: number, endKey: number) {\n    const startPosition = this.getPointByPointIndex(startKey).position;\n    const endPosition = this.getPointByPointIndex(endKey).position;\n    const segmentLength = (path.getOffsetOf(endPosition) - path.getOffsetOf(startPosition)) / (endKey - startKey);\n    const newPoints = []; // new points position between start & end\n    let base = startKey;\n    let basePoint = startPosition;\n    while (base < endKey - 1) {\n      const baseOffset = path.getOffsetOf(basePoint);\n      const nextPoint = path.getPointAt(baseOffset + segmentLength);\n      newPoints.push(nextPoint);\n      base += 1;\n      basePoint = nextPoint;\n    }\n    return newPoints;\n  }\n\n  getUpdatedPointsByNewPoints(path: paper.Path, newPoints: paper.Point[], startKey: number, category: CategoryItem) {\n    const updatedPoints: { pointIndex: number; point: Point }[] = [];\n    for (let index = 0; index < newPoints.length; index += 1) {\n      const pointIndex = startKey + index + 1;\n      const existingPoint = this.getPointByPointIndex(pointIndex);\n      const { x, y } = newPoints[index];\n      if (existingPoint) {\n        if (existingPoint.position.x !== x || existingPoint.position.y !== y) {\n          // update position\n          existingPoint.position.x = x;\n          existingPoint.position.y = y;\n          const segmentIndex = path.data.points.findIndex((p: number) => p === pointIndex);\n          if (segmentIndex >= 0) {\n            path.segments[segmentIndex].point.x = x;\n            path.segments[segmentIndex].point.y = y;\n          }\n          if (this.labelLayer) {\n            const zoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n            const label = this.getLabelByPointIndex(pointIndex);\n            if (label) {\n              label.data.point = [x, y];\n              label.position.x = x + (this.props.pointSize + 6) / zoom;\n              label.position.y = y - (this.props.pointSize + 6) / zoom;\n            }\n          }\n          updatedPoints.push({\n            pointIndex,\n            point: { position: { x, y } },\n          });\n        }\n      } else {\n        // add new point\n        const isKeyPoint = category.keys.includes(pointIndex);\n        this.addPointShape(new Paper.Point(x, y), category.name, pointIndex, isKeyPoint);\n        updatedPoints.push({\n          pointIndex,\n          point: {\n            category: category.name,\n            isKeyPoint,\n            position: { x, y },\n            visible: true,\n          },\n        });\n      }\n    }\n    return updatedPoints;\n  }\n\n  autoAdjust(point = this.props.selectedPoint) {\n    if (this.props.selectedPointInfo) {\n      const { category: categoryName } = this.props.selectedPointInfo;\n      const path = this.getPathByCategory(categoryName); // category path\n      const category = this.props.categories.find((c) => c.name === categoryName); // category definition\n\n      if (path && category && this.props.categoryPathShapes[categoryName] !== CategoryPathShape.CIRCLE) {\n        // calc the prev & next key point index\n        let prevKeyPointIndex: number | undefined;\n        let nextKeyPointIndex: number | undefined;\n        const { points = [] } = path.data;\n        const { keys = [] } = category;\n        const keysWithTwoSides = [\n          ...(keys.includes(points[0]) ? [] : [points[0]]),\n          ...keys,\n          ...(keys.includes(points[points.length - 1]) ? [] : [points[points.length - 1]]),\n        ].sort((a, b) => a - b);\n        let keyIndex = keysWithTwoSides.findIndex((key) => key > point);\n        if (keyIndex < 0) { // not found, use the last point\n          keyIndex = keysWithTwoSides.length - 1;\n        }\n        let i = keyIndex;\n        while (i < keysWithTwoSides.length) {\n          if (points.includes(keysWithTwoSides[i])) {\n            nextKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i += 1;\n        }\n        i = keyIndex - 1;\n        while (i >= 0) {\n          if (points.includes(keysWithTwoSides[i])) {\n            prevKeyPointIndex = keysWithTwoSides[i];\n            break;\n          }\n          i -= 1;\n        }\n\n        // range found, continue\n        if (prevKeyPointIndex !== undefined && nextKeyPointIndex !== undefined) {\n          const newPoints = this.getNewPointsByKeyPointRange(path, prevKeyPointIndex, nextKeyPointIndex);\n          const updatedPoints = this.getUpdatedPointsByNewPoints(path, newPoints, prevKeyPointIndex, category);\n          if (updatedPoints.length > 0) {\n            this.props.handlePointsChange(updatedPoints);\n          }\n        }\n      }\n    }\n  }\n\n  switchSmoothMode() {\n    if (this.props.selectedPointInfo) {\n      const path = this.getPathByCategory(this.props.selectedPointInfo.category);\n      if (path && this.props.categoryPathShapes[this.props.selectedPointInfo.category] !== CategoryPathShape.CIRCLE) {\n        if (path === this.smoothPath) {\n          // ends\n          const category = this.props.categories.find((c) => c.name === this.props.selectedPointInfo!.category);\n          if (category) {\n            const keyPoints = category.keys.filter((k) => path.data.points.includes(k)).sort((a, b) => a - b);\n            let updatedPoints: { pointIndex: number; point: Point }[] = [];\n            for (let i = 1; i < keyPoints.length; i += 1) {\n              const newPoints = this.getNewPointsByKeyPointRange(path, keyPoints[i - 1], keyPoints[i]);\n              updatedPoints = [\n                ...updatedPoints,\n                ...this.getUpdatedPointsByNewPoints(path, newPoints, keyPoints[i - 1], category),\n              ];\n            }\n            if (updatedPoints.length > 0) {\n              this.props.handlePointsChange(updatedPoints);\n            }\n          }\n          this.clearSmooth();\n        } else {\n          // start\n          path.fullySelected = true;\n          path.smooth({ type: 'continuous' });\n          this.smoothPath = path;\n        }\n      }\n    }\n  }\n\n  clearSmooth() {\n    if (this.smoothPath) {\n      this.smoothPath.fullySelected = false;\n      this.smoothPath.segments.forEach((seg) => {\n        seg.clearHandles();\n      });\n      this.smoothPath = null;\n    }\n  }\n\n  setCategoryAsCircle() {\n    if (this.props.selectedPointInfo) {\n      const { category } = this.props.selectedPointInfo;\n      if (this.props.categoryPathShapes[category] === CategoryPathShape.CIRCLE) {\n        this.updateCirclePath(category, false);\n        this.props.setCategoryPathShape(category);\n      } else {\n        const updatedPoints = this.updateCirclePath(category);\n        this.props.setCategoryPathShape(category, CategoryPathShape.CIRCLE, updatedPoints);\n      }\n    }\n  }\n\n  updateCirclePath(categoryName: string, isCirclePath = true) {\n    const updatedPoints: { pointIndex: number; point: Point }[] = [];\n    const path = this.getPathByCategory(categoryName);\n    if (path) {\n      const category = this.props.categories.find((c) => c.name === categoryName);\n      const categoryPoints = this.getPointsByCategory(categoryName);\n      if (category && categoryPoints) {\n        const sortedKeys = [...category.keys].sort((a, b) => a - b);\n        const pIndex1 = sortedKeys[0];\n        const pIndex2 = sortedKeys[Math.ceil(sortedKeys.length / 2)];\n        const point1 = categoryPoints.find((p) => p.data.pointIndex === pIndex1);\n        const point2 = categoryPoints.find((p) => p.data.pointIndex === pIndex2);\n        const zoom = Paper.view.zoom * this.mainLayer!.matrix.scaling.x;\n        if (point1 && point2 && isCirclePath) {\n          // is a circle & key points all exist\n          const centerX = (point1.position.x + point2.position.x) / 2;\n          const centerY = (point1.position.y + point2.position.y) / 2;\n          const radius = Math.sqrt((point2.position.x - point1.position.x) ** 2 + (point2.position.y - point1.position.y) ** 2) / 2;\n          const newPath = new Paper.CompoundPath({\n            children: [\n              new Paper.Path.Circle({\n                center: [centerX, centerY],\n                radius,\n              }),\n              new Paper.Path.Line({\n                from: [point1.position.x, point1.position.y],\n                to: [point2.position.x, point2.position.y],\n              }),\n              new Paper.Path.Line({\n                from: new Paper.Point(rotatePoint(centerX, centerY, point1.position.x, point1.position.y, Math.PI / 2)),\n                to: new Paper.Point(rotatePoint(centerX, centerY, point1.position.x, point1.position.y, -Math.PI / 2)),\n              }),\n            ],\n            strokeWidth: this.props.lineWidth / zoom,\n            strokeColor: POINT_COLOR,\n            selectedColor: POINT_COLOR,\n          });\n          newPath.data = { ...path.data, isCircle: true };\n          path.replaceWith(newPath);\n\n          // update all points in this category\n          const update = (index: number, position: { x: number; y: number }) => {\n            const existingPoint = this.getPointByPointIndex(index);\n            if (existingPoint) {\n              // update position\n              existingPoint.position.x = position.x;\n              existingPoint.position.y = position.y;\n              if (this.labelLayer) {\n                const labelZoom = Paper.view.zoom * this.labelLayer.matrix.scaling.x;\n                const label = this.getLabelByPointIndex(index);\n                if (label) {\n                  label.data.point = [position.x, position.y];\n                  label.position.x = position.x + (this.props.pointSize + 6) / labelZoom;\n                  label.position.y = position.y - (this.props.pointSize + 6) / labelZoom;\n                }\n              }\n              updatedPoints.push({\n                pointIndex: index,\n                point: { position: { x: position.x, y: position.y } },\n              });\n            } else {\n              const isKeyPoint = category.keys.includes(index);\n              this.addPointShape(new Paper.Point(position.x, position.y), category.name, index, isKeyPoint);\n              updatedPoints.push({\n                pointIndex: index,\n                point: {\n                  category: category.name,\n                  isKeyPoint,\n                  position: { x: position.x, y: position.y },\n                  visible: true,\n                },\n              });\n            }\n          };\n          const [start, end] = category.range;\n          for (let i = pIndex1 + 1; i < pIndex2; i += 1) {\n            const radians = (Math.PI / (pIndex2 - pIndex1)) * (i - pIndex1);\n            const position = rotatePoint(centerX, centerY, point1.position.x, point1.position.y, radians);\n            update(i, position);\n          }\n          for (let i = pIndex2 + 1; i <= end; i += 1) {\n            const radians = (Math.PI / (end + 1 - pIndex2)) * (i - pIndex2);\n            const position = rotatePoint(centerX, centerY, point2.position.x, point2.position.y, radians);\n            update(i, position);\n          }\n          for (let i = start; i < pIndex1; i += 1) {\n            const radians = (Math.PI / (end + 1 - pIndex2)) * (start - pIndex1);\n            const position = rotatePoint(centerX, centerY, point1.position.x, point1.position.y, radians);\n            update(i, position);\n          }\n        } else {\n          const points = [...categoryPoints].sort((a, b) => a.data.pointIndex - b.data.pointIndex);\n          const newPath = new Paper.Path({\n            segments: points.map((p) => p.position),\n            strokeWidth: this.props.lineWidth / zoom,\n            strokeColor: POINT_COLOR,\n            selectedColor: POINT_COLOR,\n          });\n          newPath.data = { ...path.data, isCircle: false, points: points.map((p) => p.data.pointIndex) };\n          path.replaceWith(newPath);\n        }\n      }\n    }\n    return updatedPoints;\n  }\n\n  render() {\n    return (\n      <div ref={this.canvasContainer} className=\"canvas\" style={{ cursor: this.cursor }}>\n        <canvas ref={this.canvas} />\n        {(this.loading || this.props.dataLoading) && (\n          <div className=\"loading\">\n            <Spin indicator={<LoadingOutlined style={{ fontSize: 100, color: '#00bad3' }} spin />} />\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default Canvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}