{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/image-annotation/index.tsx\";\nimport React, { useImperativeHandle, useRef, useState, useMemo, useEffect } from 'react';\n// import ImageMarkupTool from '@appen/image-markup-tool';\nimport { AnnotationType } from '../../types';\nimport { store } from '../../utils';\nimport './index.css';\nvar Mode = /*#__PURE__*/function (Mode) {\n  Mode[\"SINGLE\"] = \"single\";\n  Mode[\"SEQUENTIAL\"] = \"sequential\";\n  return Mode;\n}(Mode || {});\n;\nconst splitImages = imageStr => imageStr.split(',').map(i => i.trim());\nconst checkMode = props => {\n  if (props.image && typeof props.image === 'string') {\n    const images = splitImages(props.image);\n    if (images.length > 1) {\n      return Mode.SEQUENTIAL;\n    }\n  }\n  return Mode.SINGLE;\n};\nexport default React.forwardRef((props, ref) => {\n  const tool = useRef();\n  const mode = checkMode(props);\n  const {\n    saveContent,\n    unitId,\n    exportImage = false,\n    image,\n    sequenceData,\n    ...payload\n  } = props;\n  const [jobId, taskId, recordId, workerId] = unitId.split('_');\n  const [currentImageIndex, setCurrentImageIndex] = useState(-1);\n  const copyObjects = useRef();\n  useImperativeHandle(ref, () => ({\n    getData: () => new Promise(async (resolve, reject) => {\n      let data;\n      try {\n        data = tool.current.retrieveData();\n      } catch (e) {\n        // retrieve data error\n      }\n\n      // check retrieved data\n      if (!data || data.code) {\n        reject(data ? `[${data.code}] ${data.message}` : 'Retrieve Data Error');\n      }\n      if (mode === Mode.SINGLE) {\n        let annotatedImage;\n        if (exportImage) {\n          const snapshot = tool.current.takeSnapshot();\n          annotatedImage = await saveContent(snapshot);\n        }\n        return resolve({\n          ...data,\n          annotatedImage\n        });\n      }\n\n      // get storage\n      const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n      const storage = records[recordId];\n      const imageIndexs = Array.from({\n        length: splitImages(image).length\n      }, (_, index) => index);\n      if (imageIndexs.every(index => index === currentImageIndex || Object.keys(storage).find(i => i.toString() === index.toString()))) {\n        storage[currentImageIndex] = data;\n        resolve({\n          sequenceData: Object.values(storage)\n        });\n      } else {\n        reject('Not all images annotated. Please check and submit again.');\n      }\n    })\n  }));\n  const initStorage = () => {\n    // when tool mode is view, skip init store\n    if (payload.mode !== 'view') {\n      const baseInfo = store.getStorage(AnnotationType.IMAGE, 'baseInfo');\n      if (!baseInfo || (baseInfo === null || baseInfo === void 0 ? void 0 : baseInfo.jobId) !== jobId || (baseInfo === null || baseInfo === void 0 ? void 0 : baseInfo.taskId) !== taskId || (baseInfo === null || baseInfo === void 0 ? void 0 : baseInfo.workerId) !== workerId) {\n        // task has been changed, all things need update\n        // update base info\n        store.setStorage(AnnotationType.IMAGE, 'baseInfo', {\n          jobId,\n          taskId,\n          workerId\n        });\n        // clear records\n        store.setStorage(AnnotationType.IMAGE, 'records', {});\n      }\n      const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n      if (!records[recordId] && sequenceData) {\n        records[recordId] = sequenceData;\n        store.setStorage(AnnotationType.IMAGE, 'records', records);\n      }\n    }\n  };\n  const getInitialEntities = () => {\n    // when tool mode is view, get entities from sequenceData\n    if (payload.mode === 'view') {\n      return sequenceData[currentImageIndex].entities;\n    }\n    const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n    const storage = records[recordId] || {};\n\n    // if current image has been saved, get saved data\n    if (storage[currentImageIndex]) {\n      return storage[currentImageIndex].entities;\n    }\n    let i = currentImageIndex;\n    let entities;\n    while (i >= 0) {\n      // go back to find last image's entities\n      i -= 1;\n      if (storage[i] && storage[i].entities && storage[i].entities.length > 0) {\n        entities = storage[i].entities;\n        break;\n      }\n    }\n    return entities;\n  };\n  const handleImageChange = index => {\n    // when tool mode is view, skip save data\n    if (payload.mode !== 'view') {\n      // retrieve data\n      let data;\n      try {\n        data = tool.current.retrieveData();\n      } catch (e) {\n        // retrieve data error\n      }\n      if (!data || data.code) {\n        return;\n      }\n\n      // save data to store\n      const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n      if (!records[recordId]) {\n        records[recordId] = {};\n      }\n      records[recordId][currentImageIndex] = data;\n      store.setStorage(AnnotationType.IMAGE, 'records', records);\n    }\n\n    // goto next image\n    setCurrentImageIndex(index);\n  };\n  const handleKeyDown = event => {\n    switch (event.key) {\n      case 'c':\n        if (event.ctrlKey) {\n          const selectedEntities = tool.current.getSelectedEntities();\n          if (selectedEntities.length > 0) {\n            event.preventDefault();\n            copyObjects.current = selectedEntities;\n          }\n        }\n        break;\n      case 'v':\n        if (event.ctrlKey && copyObjects.current) {\n          event.preventDefault();\n          copyObjects.current.forEach(entity => {\n            try {\n              tool.current.copyEntity(entity);\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.log('Copy Failed: ', e.message);\n            }\n          });\n        }\n        break;\n      default:\n    }\n  };\n\n  // single\n\n  // sequential\n  useEffect(() => {\n    if (mode === Mode.SEQUENTIAL) {\n      if (store.isEnabled()) {\n        initStorage();\n      }\n      if (payload.mode !== 'view') {\n        window.addEventListener('keydown', handleKeyDown, true);\n      }\n    }\n    setCurrentImageIndex(0);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, true);\n    };\n  }, []);\n  const images = useMemo(() => splitImages(image), [image]);\n  const entities = useMemo(() => getInitialEntities(), [currentImageIndex]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"image-annotation-seq-container\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 202,\n      columnNumber: 7\n    }\n  }, images.map((img, index) => /*#__PURE__*/React.createElement(\"div\", {\n    key: img,\n    className: \"image-annotation-seq-item\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 204,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    style: {\n      backgroundImage: `url(${img})`\n    }\n  }, index === currentImageIndex && {\n    className: 'active'\n  }, {\n    onClick: () => handleImageChange(index),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 205,\n      columnNumber: 13\n    }\n  }))))));\n});","map":{"version":3,"names":["React","useImperativeHandle","useRef","useState","useMemo","useEffect","AnnotationType","store","Mode","splitImages","imageStr","split","map","i","trim","checkMode","props","image","images","length","SEQUENTIAL","SINGLE","forwardRef","ref","tool","mode","saveContent","unitId","exportImage","sequenceData","payload","jobId","taskId","recordId","workerId","currentImageIndex","setCurrentImageIndex","copyObjects","getData","Promise","resolve","reject","data","current","retrieveData","e","code","message","annotatedImage","snapshot","takeSnapshot","records","getStorage","IMAGE","storage","imageIndexs","Array","from","_","index","every","Object","keys","find","toString","values","initStorage","baseInfo","setStorage","getInitialEntities","entities","handleImageChange","handleKeyDown","event","key","ctrlKey","selectedEntities","getSelectedEntities","preventDefault","forEach","entity","copyEntity","console","log","isEnabled","window","addEventListener","removeEventListener","createElement","Fragment","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","img","assign","style","backgroundImage","onClick"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/image-annotation/index.tsx"],"sourcesContent":["import React, { useImperativeHandle, useRef, useState, useMemo, useEffect } from 'react';\n// import ImageMarkupTool from '@appen/image-markup-tool';\nimport { AnnotationType } from '../../types';\nimport { store } from '../../utils';\nimport './index.css';\n\nenum Mode {\n  SINGLE = 'single',\n  SEQUENTIAL = 'sequential',\n};\n\ninterface ImageProps {\n  saveContent: (content: string) => Promise<string>;\n  unitId: string;\n  exportImage: boolean;\n  mode: string;\n  image: string;\n  sequenceData?: any; // only used for sequential mode\n}\n\nconst splitImages = (imageStr: string) => imageStr.split(',').map((i: string) => i.trim());\nconst checkMode = (props: ImageProps) => {\n  if (props.image && typeof props.image === 'string') {\n    const images = splitImages(props.image);\n    if (images.length > 1) {\n      return Mode.SEQUENTIAL;\n    }\n  }\n  return Mode.SINGLE;\n};\n\nexport default React.forwardRef((props: ImageProps, ref: any) => {\n  const tool = useRef<any>();\n  const mode = checkMode(props);\n  const { saveContent, unitId, exportImage = false, image, sequenceData, ...payload } = props;\n  const [jobId, taskId, recordId, workerId] = unitId.split('_');\n  const [currentImageIndex, setCurrentImageIndex] = useState(-1);\n  const copyObjects = useRef<any>();\n\n  useImperativeHandle(ref, () => ({\n    getData: () => new Promise(async (resolve, reject) => {\n      let data;\n      try {\n        data = tool.current.retrieveData();\n      } catch (e) {\n        // retrieve data error\n      }\n\n      // check retrieved data\n      if (!data || data.code) {\n        reject(data ? `[${data.code}] ${data.message}` : 'Retrieve Data Error');\n      }\n\n      if (mode === Mode.SINGLE) {\n        let annotatedImage;\n        if (exportImage) {\n          const snapshot = tool.current.takeSnapshot();\n          annotatedImage = await saveContent(snapshot);\n        }\n        return resolve({ ...data, annotatedImage });\n      }\n\n      // get storage\n      const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n      const storage = records[recordId];\n      const imageIndexs = Array.from({ length: splitImages(image).length }, (_, index) => index);\n      if (imageIndexs.every((index) => index === currentImageIndex || Object.keys(storage).find((i) => i.toString() === index.toString()))) {\n        storage[currentImageIndex] = data;\n        resolve({ sequenceData: Object.values(storage) });\n      } else {\n        reject('Not all images annotated. Please check and submit again.');\n      }\n    }),\n  }));\n\n  const initStorage = () => {\n    // when tool mode is view, skip init store\n    if (payload.mode !== 'view') {\n      const baseInfo = store.getStorage(AnnotationType.IMAGE, 'baseInfo');\n      if (!baseInfo || baseInfo?.jobId !== jobId || baseInfo?.taskId !== taskId || baseInfo?.workerId !== workerId) {\n        // task has been changed, all things need update\n        // update base info\n        store.setStorage(AnnotationType.IMAGE, 'baseInfo', { jobId, taskId, workerId });\n        // clear records\n        store.setStorage(AnnotationType.IMAGE, 'records', {});\n      }\n\n      const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n      if (!records[recordId] && sequenceData) {\n        records[recordId] = sequenceData;\n        store.setStorage(AnnotationType.IMAGE, 'records', records);\n      }\n    }\n  };\n\n  const getInitialEntities = () => {\n    // when tool mode is view, get entities from sequenceData\n    if (payload.mode === 'view') {\n      return sequenceData[currentImageIndex].entities;\n    }\n\n    const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n    const storage = records[recordId] || {};\n\n    // if current image has been saved, get saved data\n    if (storage[currentImageIndex]) {\n      return storage[currentImageIndex].entities;\n    }\n\n    let i = currentImageIndex;\n    let entities;\n    while (i >= 0) {\n      // go back to find last image's entities\n      i -= 1;\n      if (storage[i] && storage[i].entities && storage[i].entities.length > 0) {\n        entities = storage[i].entities;\n        break;\n      }\n    }\n    return entities;\n  };\n\n  const handleImageChange = (index: number) => {\n    // when tool mode is view, skip save data\n    if (payload.mode !== 'view') {\n      // retrieve data\n      let data;\n      try {\n        data = tool.current.retrieveData();\n      } catch (e) {\n        // retrieve data error\n      }\n\n      if (!data || data.code) {\n        return;\n      }\n\n      // save data to store\n      const records = store.getStorage(AnnotationType.IMAGE, 'records') || {};\n      if (!records[recordId]) {\n        records[recordId] = {};\n      }\n      records[recordId][currentImageIndex] = data;\n      store.setStorage(AnnotationType.IMAGE, 'records', records);\n    }\n\n    // goto next image\n    setCurrentImageIndex(index);\n  };\n\n  const handleKeyDown = (event: KeyboardEvent) => {\n    switch (event.key) {\n      case 'c':\n        if (event.ctrlKey) {\n          const selectedEntities = tool.current.getSelectedEntities();\n          if (selectedEntities.length > 0) {\n            event.preventDefault();\n            copyObjects.current = selectedEntities;\n          }\n        }\n        break;\n      case 'v':\n        if (event.ctrlKey && copyObjects.current) {\n          event.preventDefault();\n          copyObjects.current.forEach((entity: any) => {\n            try {\n              tool.current.copyEntity(entity);\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.log('Copy Failed: ', e.message);\n            }\n          });\n        }\n        break;\n      default:\n    }\n  };\n\n  // single\n\n\n  // sequential\n  useEffect(() => {\n    if (mode === Mode.SEQUENTIAL) {\n      if (store.isEnabled()) {\n        initStorage();\n      }\n      if (payload.mode !== 'view') {\n        window.addEventListener('keydown', handleKeyDown, true);\n      }\n    }\n    setCurrentImageIndex(0);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, true);\n    };\n  }, []);\n\n  const images = useMemo(() => splitImages(image), [image]);\n  const entities = useMemo(() => getInitialEntities(), [currentImageIndex]);\n  return (\n    <>\n      <div className=\"image-annotation-seq-container\">\n        {images.map((img, index) => (\n          <div key={img} className=\"image-annotation-seq-item\">\n            <div\n              style={{ backgroundImage: `url(${img})` }}\n              {...index === currentImageIndex && { className: 'active' }}\n              onClick={() => handleImageChange(index)}\n            />\n          </div>\n        ))}\n      </div>\n\n    </>\n  );\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}