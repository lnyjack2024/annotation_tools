{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { Base64 } from 'js-base64';\nimport { utils as formUtils } from '@appen-china/easy-form';\nimport { FieldControlType } from '@appen-china/easy-form/es/types';\nimport { Tool } from './types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_CATEGORY_ITEM } from './constants';\nimport { fetchResultByUrl } from '../../utils';\nimport { computeRotatedPosition } from '../../utils/math';\nimport { ShapeType } from '../common/shapes/types';\nimport { precise } from '../common/shapes/utils';\n\n/**\n * parse frames\n * @param frames\n */\nexport function parseFrames(frames) {\n  if (typeof frames === 'string') {\n    return frames.split(',').map(f => f.trim());\n  }\n  return [...frames];\n}\n\n/**\n * parse frames config from frames\n * @param frames\n */\nfunction parseFramesFromFrames(frames) {\n  if (typeof frames === 'string' && frames || Array.isArray(frames)) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      frames: parseFrames(frames)\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames from payload\n * @param payload\n */\nexport async function parseFramesByPaylod({\n  frames,\n  base_url\n}) {\n  const parseFromFrames = parseFramesFromFrames(frames);\n  if (parseFromFrames !== null) {\n    return parseFromFrames;\n  }\n  if (base_url) {\n    try {\n      const res = await fetchResultByUrl(base_url);\n      if (res) {\n        const parseFromFramesResult = parseFramesFromFrames(res.frames);\n        if (parseFromFramesResult !== null) {\n          return parseFromFramesResult;\n        }\n      }\n    } catch (e) {\n      // fetch error\n    }\n  }\n  return [{\n    camera: DEFAULT_CAMERA_NAME,\n    frames: []\n  }];\n}\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result) {\n  const instances = [];\n  if (result && result.instances && Array.isArray(result.instances)) {\n    result.instances.forEach(instance => {\n      if (instance.frames) {\n        // legacy data\n        const defaultCamera = {\n          camera: DEFAULT_CAMERA_NAME,\n          frames: instance.frames\n        };\n        const defaultItem = {\n          id: uuidv4(),\n          name: DEFAULT_CATEGORY_ITEM,\n          number: 1,\n          cameras: [defaultCamera]\n        };\n        const newInstance = {\n          id: instance.id,\n          category: instance.category,\n          number: instance.number,\n          children: [defaultItem]\n        };\n        instances.push(newInstance);\n        // TODO: fix string points attribute for rectangle\n      } else {\n        instances.push(instance);\n      }\n    });\n  }\n  return instances;\n}\n\n/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */\nexport function predictShapeData(currentFrame, frames, bounds) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame);\n    }\n  }\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const {\n        shapeType,\n        shape\n      } = frames[prevKeyFrameIndexes[0]];\n      return {\n        shapeType,\n        shape\n      };\n    }\n  }\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const {\n      shapeType,\n      shape\n    } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return {\n        shapeType,\n        shape\n      };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const {\n      shapeType,\n      shape\n    } = frames[prevKeyFrameIndexes[0]];\n    return {\n      shapeType,\n      shape\n    };\n  }\n  return null;\n}\n\n/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getLastKeyFrames(count, currentFrame, frames) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map(f => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getNextKeyFrames(count, currentFrame, frames) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map(f => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */\nexport function getShapeFromFrames(frames, startFrame, endFrame, baseFrame, currentFrame) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape\n  };\n  if (Object.values(frames).filter(f => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some(f => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE:\n      {\n        const shape = calculate(startShape, endShape, baseShape, frameScale);\n        const right = precise(shape.x + shape.width);\n        const bottom = precise(shape.y + shape.height);\n        const points = [{\n          x: shape.x,\n          y: shape.y\n        }, {\n          x: right,\n          y: shape.y\n        }, {\n          x: right,\n          y: bottom\n        }, {\n          x: shape.x,\n          y: bottom\n        }];\n        if (shape.rotation) {\n          points.forEach(p => {\n            const point = computeRotatedPosition({\n              x: shape.x + shape.width / 2,\n              y: shape.y + shape.height / 2\n            }, p, shape.rotation);\n            p.x = precise(point.x);\n            p.y = precise(point.y);\n          });\n        }\n        shape.points = points;\n        shapeInfo.shape = {\n          ...shape\n        };\n        break;\n      }\n    case ShapeType.DOT:\n      {\n        shapeInfo.shape = calculate(startShape, endShape, baseShape, frameScale);\n        break;\n      }\n    default:\n  }\n  return shapeInfo;\n}\n\n/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */\nfunction calculate(start, end, base, scale) {\n  const calculatedObject = {};\n  Object.keys(base).forEach(key => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = precise(base[key] + (end[key] - start[key]) * scale);\n    }\n  });\n  return calculatedObject;\n}\n\n/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */\nexport function checkShapeInBounds(shape, shapeType, bounds) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n      {\n        const points = shape.points;\n        const allX = points.map(p => p.x);\n        const allY = points.map(p => p.y);\n        const left = Math.min(...allX);\n        const right = Math.max(...allX);\n        const top = Math.min(...allY);\n        const bottom = Math.max(...allY);\n        return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n      }\n    case ShapeType.DOT:\n      {\n        const {\n          x,\n          y\n        } = shape;\n        return x <= bounds.right && y <= bounds.bottom && x >= bounds.left && y >= bounds.top;\n      }\n    default:\n  }\n  return true;\n}\n\n/**\n * get shape type by tool name\n * @param tool\n */\nexport function getShapeTypeByTool(tool) {\n  switch (tool) {\n    case Tool.RECTANGLE:\n      return ShapeType.RECTANGLE;\n    case Tool.POLYGON:\n      return ShapeType.POLYGON;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * get tool type from frame data\n * @param shape\n */\nexport function getToolTypeFromFrameData(shape) {\n  switch (shape.shapeType) {\n    case ShapeType.POLYGON:\n      return Tool.POLYGON;\n    case ShapeType.RECTANGLE:\n      return Tool.RECTANGLE;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * parse label config\n * @param labelConfigStr\n */\nexport function parseLabelConfig(labelConfigStr) {\n  if (labelConfigStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(labelConfigStr));\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields, values) {\n  return fields.map(field => ({\n    ...field,\n    ...(values && values[field.name] !== undefined && {\n      defaultValue: values[field.name]\n    })\n  }));\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config) {\n  const map = {};\n  ((config === null || config === void 0 ? void 0 : config.fields) || []).forEach(field => {\n    const {\n      name,\n      label,\n      type,\n      valueType,\n      options = []\n    } = field;\n    const newField = {\n      name,\n      type,\n      label\n    };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUpperShape(targetShape, shapes) {\n  let upperShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order > targetShape.order) {\n      // upper\n      if (!upperShape) {\n        upperShape = shape;\n      } else if (upperShape.order > shape.order) {\n        upperShape = shape;\n      }\n    }\n  }\n  return upperShape;\n}\n\n/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUnderShape(targetShape, shapes) {\n  let underShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order < targetShape.order) {\n      // under\n      if (!underShape) {\n        underShape = shape;\n      } else if (underShape.order < shape.order) {\n        underShape = shape;\n      }\n    }\n  }\n  return underShape;\n}\n\n/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */\nexport function preciseShapeByType(shapeType, shapeData) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n      {\n        const {\n          rotation\n        } = shapeData;\n        preciseData(shapeData);\n        if (rotation !== undefined) {\n          shapeData.rotation = rotation;\n        }\n        break;\n      }\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n    case ShapeType.DOT:\n      preciseData(shapeData);\n      break;\n    default:\n  }\n}\n\n/**\n * precise data\n * @param data\n */\nexport function preciseData(data) {\n  if (Array.isArray(data)) {\n    // array\n    data.forEach((item, i) => {\n      if (typeof item === 'number') {\n        data[i] = precise(item);\n      } else {\n        preciseData(item);\n      }\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    // object\n    const allKeys = Object.keys(data);\n    allKeys.forEach(key => {\n      const keyData = data[key];\n      if (typeof keyData === 'number') {\n        data[key] = precise(keyData);\n      } else {\n        preciseData(keyData);\n      }\n    });\n  }\n}\n\n/**\n * get field option label\n * @param value\n * @param options\n */\nexport function getFieldOptionLabel(value, options) {\n  const option = options.find(o => o.value === value);\n  return (option === null || option === void 0 ? void 0 : option.label) || `${value}`;\n}\n\n/**\n * get field display label\n * @param value\n * @param field\n */\nexport function getFieldDisplayLabel(fieldValue, field) {\n  let displayValue = '';\n  if (fieldValue !== undefined && fieldValue !== null) {\n    if (field === null || field === void 0 ? void 0 : field.options) {\n      displayValue = Array.isArray(fieldValue) ? `${fieldValue.map(v => getFieldOptionLabel(v, field.options))}` : getFieldOptionLabel(fieldValue, field.options);\n    } else {\n      displayValue = `${fieldValue}`;\n    }\n  }\n  return displayValue;\n}","map":{"version":3,"names":["v4","uuidv4","Base64","utils","formUtils","FieldControlType","Tool","DEFAULT_CAMERA_NAME","DEFAULT_CATEGORY_ITEM","fetchResultByUrl","computeRotatedPosition","ShapeType","precise","parseFrames","frames","split","map","f","trim","parseFramesFromFrames","Array","isArray","defaultCamera","camera","parseFramesByPaylod","base_url","parseFromFrames","res","parseFromFramesResult","e","loadInstancesFromResult","result","instances","forEach","instance","defaultItem","id","name","number","cameras","newInstance","category","children","push","predictShapeData","currentFrame","bounds","prevKeyFrameIndexes","getLastKeyFrames","nextKeyFrameIndexes","getNextKeyFrames","length","startFrame","endFrame","shapeType","getShapeFromFrames","shape","checkShapeInBounds","count","i","keyFrameIndexes","minFrame","Math","min","Object","values","frameIndex","isKeyFrame","maxFrame","max","baseFrame","frameShapeType","shapeInfo","filter","some","startShape","endShape","baseShape","frameScale","RECTANGLE","calculate","right","x","width","bottom","y","height","points","rotation","p","point","DOT","start","end","base","scale","calculatedObject","keys","key","undefined","POLYGON","LINE","allX","allY","left","top","getShapeTypeByTool","tool","getToolTypeFromFrameData","parseLabelConfig","labelConfigStr","labelConfig","JSON","parse","decode","setInitialValues","fields","field","defaultValue","parseFields","config","label","type","valueType","options","newField","RADIO","SELECT","CHECKBOX","parseOptions","getUpperShape","targetShape","shapes","upperShape","order","getUnderShape","underShape","preciseShapeByType","shapeData","preciseData","data","item","allKeys","keyData","getFieldOptionLabel","value","option","find","o","getFieldDisplayLabel","fieldValue","displayValue","v"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/utils.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { Base64 } from 'js-base64';\nimport { utils as formUtils } from '@appen-china/easy-form';\nimport { Field, FieldControlType, FieldOption, FieldValue } from '@appen-china/easy-form/es/types';\nimport { Instance, InstanceItem, CameraData, FrameData, Tool, LabelConfig, FieldConfig } from './types';\nimport { DEFAULT_CAMERA_NAME, DEFAULT_CATEGORY_ITEM } from './constants';\nimport { fetchResultByUrl } from '../../utils';\nimport { computeRotatedPosition } from '../../utils/math';\nimport { ShapeData, ShapeType } from '../common/shapes/types';\nimport type Shape from '../common/shapes/Shape';\nimport { RectangleData } from '../common/shapes/Rectangle';\nimport { DotData } from '../common/shapes/Dot';\nimport { PolygonData } from '../common/shapes/Polygon';\nimport { LineData } from '../common/shapes/Line';\nimport { precise } from '../common/shapes/utils';\n\n/**\n * parse frames\n * @param frames\n */\nexport function parseFrames(frames: string | string[]) {\n  if (typeof frames === 'string') {\n    return frames.split(',').map((f) => f.trim());\n  }\n  return [...frames];\n}\n\n/**\n * parse frames config from frames\n * @param frames\n */\nfunction parseFramesFromFrames(frames: unknown) {\n  if ((typeof frames === 'string' && frames) || Array.isArray(frames)) {\n    const defaultCamera = {\n      camera: DEFAULT_CAMERA_NAME,\n      frames: parseFrames(frames),\n    };\n    return [defaultCamera];\n  }\n  return null;\n}\n\n/**\n * parse frames from payload\n * @param payload\n */\nexport async function parseFramesByPaylod({ frames, base_url }: {\n  frames?: string | string[];\n  base_url?: string;\n}) {\n  const parseFromFrames = parseFramesFromFrames(frames);\n  if (parseFromFrames !== null) {\n    return parseFromFrames;\n  }\n\n  if (base_url) {\n    try {\n      const res: any = await fetchResultByUrl(base_url);\n      if (res) {\n        const parseFromFramesResult = parseFramesFromFrames(res.frames);\n        if (parseFromFramesResult !== null) {\n          return parseFromFramesResult;\n        }\n      }\n    } catch (e) {\n      // fetch error\n    }\n  }\n  return [{\n    camera: DEFAULT_CAMERA_NAME,\n    frames: [],\n  }];\n}\n\n/**\n * load instance from result\n * @param result\n */\nexport function loadInstancesFromResult(result: any) {\n  const instances: Instance[] = [];\n\n  if (result && result.instances && Array.isArray(result.instances)) {\n    result.instances.forEach((instance: any) => {\n      if (instance.frames) {\n        // legacy data\n        const defaultCamera: CameraData = {\n          camera: DEFAULT_CAMERA_NAME,\n          frames: instance.frames,\n        };\n        const defaultItem: InstanceItem = {\n          id: uuidv4(),\n          name: DEFAULT_CATEGORY_ITEM,\n          number: 1,\n          cameras: [defaultCamera],\n        };\n        const newInstance: Instance = {\n          id: instance.id,\n          category: instance.category,\n          number: instance.number,\n          children: [defaultItem],\n        };\n        instances.push(newInstance);\n        // TODO: fix string points attribute for rectangle\n      } else {\n        instances.push(instance);\n      }\n    });\n  }\n\n  return instances;\n}\n\n/**\n * get predicted shape data\n * @param currentFrame\n * @param frames\n * @param bounds\n */\nexport function predictShapeData(\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n  bounds?: { top: number; right: number; bottom: number; left: number },\n) {\n  // when shape already exists\n  if (frames[currentFrame]) {\n    return null;\n  }\n\n  const prevKeyFrameIndexes = getLastKeyFrames(2, currentFrame, frames);\n  const nextKeyFrameIndexes = getNextKeyFrames(1, currentFrame, frames);\n\n  if (nextKeyFrameIndexes.length === 1 && prevKeyFrameIndexes.length >= 1) {\n    // prev & next has key frames\n    const [startFrame] = prevKeyFrameIndexes;\n    const [endFrame] = nextKeyFrameIndexes;\n    if (frames[startFrame].shapeType === frames[endFrame].shapeType) {\n      // same shape, use the range, else continue\n      return getShapeFromFrames(frames, startFrame, endFrame, startFrame, currentFrame);\n    }\n  }\n\n  if (nextKeyFrameIndexes.length <= 0 && prevKeyFrameIndexes.length >= 1) {\n    // no next key frame\n    if (prevKeyFrameIndexes.length === 1 || frames[prevKeyFrameIndexes[0]].shapeType !== frames[prevKeyFrameIndexes[1]].shapeType) {\n      // just 1 prev key frame, or two prev key frame shapes are not same\n      const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n      return { shapeType, shape };\n    }\n  }\n\n  if (prevKeyFrameIndexes.length === 2) {\n    // has 2 prev key frames\n    const [endFrame, startFrame] = prevKeyFrameIndexes;\n    const { shapeType, shape } = getShapeFromFrames(frames, startFrame, endFrame, endFrame, currentFrame);\n    if (!bounds || checkShapeInBounds(shape, shapeType, bounds)) {\n      return { shapeType, shape };\n    }\n  } else if (prevKeyFrameIndexes.length === 1) {\n    // has 1 prev key frame\n    const { shapeType, shape } = frames[prevKeyFrameIndexes[0]];\n    return { shapeType, shape };\n  }\n\n  return null;\n}\n\n/**\n * get last {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getLastKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find last n key frames\n  let i = currentFrame - 1;\n  const keyFrameIndexes = [];\n  const minFrame = Math.min(...Object.values(frames).map((f) => f.frameIndex));\n  while (i >= minFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i -= 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * get next {count} key frames\n * @param count\n * @param currentFrame\n * @param frames\n */\nexport function getNextKeyFrames(\n  count: number,\n  currentFrame: number,\n  frames: {[frameIndex: number]: FrameData},\n) {\n  // find next n key frames\n  let i = currentFrame + 1;\n  const keyFrameIndexes = [];\n  const maxFrame = Math.max(...Object.values(frames).map((f) => f.frameIndex));\n  while (i <= maxFrame && keyFrameIndexes.length < count) {\n    if (frames[i] && frames[i].isKeyFrame) {\n      // find a key frame\n      keyFrameIndexes.push(i);\n    }\n    i += 1;\n  }\n  return keyFrameIndexes;\n}\n\n/**\n * interpolate shape\n * @param frames\n * @param startFrame\n * @param endFrame\n * @param baseFrame\n * @param currentFrame\n */\nexport function getShapeFromFrames(\n  frames: {[frameIndex: number]: FrameData},\n  startFrame: number,\n  endFrame: number,\n  baseFrame: number,\n  currentFrame: number,\n) {\n  const frameShapeType = frames[baseFrame].shapeType;\n  const shapeInfo = {\n    shapeType: frameShapeType,\n    shape: frames[baseFrame].shape,\n  };\n\n  if (Object.values(frames).filter((f) => f.frameIndex >= startFrame && f.frameIndex <= endFrame).some((f) => f.shapeType !== frameShapeType)) {\n    // shape type changes between start & end, can't calculate offsets\n    return shapeInfo;\n  }\n\n  const startShape = frames[startFrame].shape;\n  const endShape = frames[endFrame].shape;\n  const baseShape = frames[baseFrame].shape;\n  const frameScale = (currentFrame - baseFrame) / (endFrame - startFrame);\n\n  switch (frameShapeType) {\n    case ShapeType.RECTANGLE: {\n      const shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as RectangleData;\n      const right = precise(shape.x + shape.width);\n      const bottom = precise(shape.y + shape.height);\n      const points = [\n        { x: shape.x, y: shape.y },\n        { x: right, y: shape.y },\n        { x: right, y: bottom },\n        { x: shape.x, y: bottom },\n      ];\n      if (shape.rotation) {\n        points.forEach((p) => {\n          const point = computeRotatedPosition({ x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }, p, shape.rotation as number);\n          p.x = precise(point.x);\n          p.y = precise(point.y);\n        });\n      }\n\n      shape.points = points;\n      shapeInfo.shape = { ...shape };\n      break;\n    }\n    case ShapeType.DOT: {\n      shapeInfo.shape = calculate(\n        startShape as unknown as { [key: string]: number; },\n        endShape as unknown as { [key: string]: number; },\n        baseShape as unknown as { [key: string]: number; },\n        frameScale,\n      ) as unknown as DotData;\n      break;\n    }\n    default:\n  }\n\n  return shapeInfo;\n}\n\n/**\n * calculate interpolation data\n * @param start\n * @param end\n * @param base\n * @param scale\n */\nfunction calculate(\n  start: {[key: string]: number},\n  end: {[key: string]: number},\n  base: {[key: string]: number},\n  scale: number,\n) {\n  const calculatedObject: {[key: string]: number} = {};\n  Object.keys(base).forEach((key) => {\n    if (start[key] !== undefined && end[key] !== undefined) {\n      calculatedObject[key] = precise(base[key] + (end[key] - start[key]) * scale);\n    }\n  });\n  return calculatedObject;\n}\n\n/**\n * check if ths shape is in image bounds\n * @param shape\n * @param shapeType\n * @param bounds\n */\nexport function checkShapeInBounds(\n  shape: ShapeData,\n  shapeType: ShapeType,\n  bounds: { top: number; right: number; bottom: number; left: number },\n) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE:\n    case ShapeType.POLYGON:\n    case ShapeType.LINE: {\n      const points = (shape as RectangleData | PolygonData | LineData).points as { x: number; y: number }[];\n      const allX = points.map((p) => p.x);\n      const allY = points.map((p) => p.y);\n      const left = Math.min(...allX);\n      const right = Math.max(...allX);\n      const top = Math.min(...allY);\n      const bottom = Math.max(...allY);\n      return left >= bounds.left && top >= bounds.top && right <= bounds.right && bottom <= bounds.bottom;\n    }\n    case ShapeType.DOT: {\n      const { x, y } = shape as DotData;\n      return x <= bounds.right && y <= bounds.bottom && x >= bounds.left && y >= bounds.top;\n    }\n    default:\n  }\n  return true;\n}\n\n/**\n * get shape type by tool name\n * @param tool\n */\nexport function getShapeTypeByTool(tool: Tool): ShapeType | undefined {\n  switch (tool) {\n    case Tool.RECTANGLE:\n      return ShapeType.RECTANGLE;\n    case Tool.POLYGON:\n      return ShapeType.POLYGON;\n    case Tool.LINE:\n      return ShapeType.LINE;\n    case Tool.DOT:\n      return ShapeType.DOT;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * get tool type from frame data\n * @param shape\n */\nexport function getToolTypeFromFrameData(shape: FrameData) {\n  switch (shape.shapeType) {\n    case ShapeType.POLYGON:\n      return Tool.POLYGON;\n    case ShapeType.RECTANGLE:\n      return Tool.RECTANGLE;\n    case ShapeType.LINE:\n      return Tool.LINE;\n    case ShapeType.DOT:\n      return Tool.DOT;\n    default:\n  }\n  return undefined;\n}\n\n/**\n * parse label config\n * @param labelConfigStr\n */\nexport function parseLabelConfig(labelConfigStr?: string) {\n  if (labelConfigStr) {\n    try {\n      const labelConfig = JSON.parse(Base64.decode(labelConfigStr));\n      return labelConfig;\n    } catch (e) {\n      // parse error\n    }\n  }\n  return undefined;\n}\n\n/**\n * set initial values for fields\n * @param fields\n * @param values\n */\nexport function setInitialValues(fields: Field[], values: any) {\n  return fields.map((field) => ({\n    ...field,\n    ...values && values[field.name] !== undefined && {\n      defaultValue: values[field.name],\n    },\n  }));\n}\n\n/**\n * parse fields (with options), return a name-field map\n * @param config\n */\nexport function parseFields(config?: LabelConfig) {\n  const map: { [fieldName: string]: FieldConfig } = {};\n  (config?.fields || []).forEach((field) => {\n    const { name, label, type, valueType, options = [] } = field;\n    const newField: FieldConfig = { name, type, label };\n    if (type === FieldControlType.RADIO || type === FieldControlType.SELECT || type === FieldControlType.CHECKBOX) {\n      // has options\n      newField.options = formUtils.parseOptions(options, valueType);\n    }\n    map[name] = newField;\n  });\n  return map;\n}\n\n/**\n * get upper shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUpperShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let upperShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order > targetShape.order) { // upper\n      if (!upperShape) {\n        upperShape = shape;\n      } else if (upperShape.order > shape.order) {\n        upperShape = shape;\n      }\n    }\n  }\n  return upperShape;\n}\n\n/**\n * get under shape for target shape\n * @param targetShape\n * @param shapes\n */\nexport function getUnderShape(targetShape: Shape<ShapeData>, shapes: Shape<ShapeData>[]) {\n  let underShape;\n  for (let i = 0; i < shapes.length; i += 1) {\n    const shape = shapes[i];\n    if (shape.order < targetShape.order) { // under\n      if (!underShape) {\n        underShape = shape;\n      } else if (underShape.order < shape.order) {\n        underShape = shape;\n      }\n    }\n  }\n  return underShape;\n}\n\n/**\n * precise shape data by shape type\n * @param shapeType\n * @param shapeData\n */\nexport function preciseShapeByType(shapeType: ShapeType, shapeData: ShapeData) {\n  switch (shapeType) {\n    case ShapeType.RECTANGLE: {\n      const { rotation } = shapeData as RectangleData;\n      preciseData(shapeData);\n      if (rotation !== undefined) {\n        (shapeData as RectangleData).rotation = rotation;\n      }\n      break;\n    }\n    case ShapeType.POLYGON:\n    case ShapeType.LINE:\n    case ShapeType.DOT:\n      preciseData(shapeData);\n      break;\n    default:\n  }\n}\n\n/**\n * precise data\n * @param data\n */\nexport function preciseData(data: any) {\n  if (Array.isArray(data)) {\n    // array\n    data.forEach((item, i) => {\n      if (typeof item === 'number') {\n        data[i] = precise(item);\n      } else {\n        preciseData(item);\n      }\n    });\n  } else if (typeof data === 'object' && data !== null) {\n    // object\n    const allKeys = Object.keys(data);\n    allKeys.forEach((key) => {\n      const keyData = data[key];\n      if (typeof keyData === 'number') {\n        data[key] = precise(keyData);\n      } else {\n        preciseData(keyData);\n      }\n    });\n  }\n}\n\n/**\n * get field option label\n * @param value\n * @param options\n */\nexport function getFieldOptionLabel(value: FieldValue, options: FieldOption[]) {\n  const option = options.find((o) => o.value === value);\n  return option?.label || `${value}`;\n}\n\n/**\n * get field display label\n * @param value\n * @param field\n */\nexport function getFieldDisplayLabel(fieldValue: FieldValue | FieldValue[], field?: FieldConfig) {\n  let displayValue = '';\n  if (fieldValue !== undefined && fieldValue !== null) {\n    if (field?.options) {\n      displayValue = Array.isArray(fieldValue)\n        ? `${fieldValue.map((v) => getFieldOptionLabel(v, field.options!))}`\n        : getFieldOptionLabel(fieldValue, field.options);\n    } else {\n      displayValue = `${fieldValue}`;\n    }\n  }\n  return displayValue;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}