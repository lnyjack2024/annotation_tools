{"ast":null,"code":"import { cloneDeep } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { notification } from 'antd';\nimport { makeAutoObservable, observable, toJS } from 'mobx';\nimport { parseTextgrid } from 'praatio';\nimport audioBufferToWav from 'audiobuffer-to-wav';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport AnalyseStore from './AnalyseStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport { loadInstancesFromResult } from '../utils';\nimport i18n from '../locales';\nimport { ReviewResult, PraatAnnotationType, AnnotationType } from '../types';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, TOOL_MODE } from '../../../utils/tool-mode';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in labeling mode\n   */\n  get isLabeling() {\n    return this.jobProxy.toolMode === TOOL_MODE.LABELING;\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy.toolMode);\n  }\n  constructor() {\n    this.ontology = void 0;\n    this.undo = void 0;\n    this.analyse = void 0;\n    this.setting = void 0;\n    this.review = void 0;\n    this.instance = void 0;\n    this.urls = [];\n    /**\n     * job proxy\n     */\n    this.jobProxy = void 0;\n    /**\n     * initial data copy\n     */\n    this.initialData = null;\n    /**\n     * is tool initialized\n     */\n    this.initialized = false;\n    /**\n     * check missing character\n     */\n    this.checkMissingCharacter = false;\n    /**\n     * get instance statistics\n     */\n    this.getInstanceStatistics = () => {\n      const {\n        categories\n      } = this.ontology;\n      const {\n        placement: {\n          duration\n        }\n      } = this.analyse;\n      const data = {\n        elements: [],\n        categories: categories.map(({\n          className\n        }) => className),\n        shapes: new Set(),\n        summary: {},\n        duration: duration * 1000,\n        // file duration\n        approvedWordCount: 0,\n        rejectedWordCount: 0,\n        approvedCharCount: 0,\n        rejectedCharCount: 0,\n        wordCount: 0,\n        charCount: 0\n      };\n      const instancesList = Object.values(this.instance.instances).filter(v => !!v);\n      for (let i = 0; i < instancesList.length; i += 1) {\n        const {\n          id,\n          category,\n          shapeType,\n          start,\n          end,\n          text\n        } = instancesList[i];\n        const charCount = text ? text.length : 0;\n        const wordCount = text && text.indexOf(' ') >= 0 ? text.split(' ').length : charCount;\n        const key = `${shapeType}_${category}`;\n        if (!data.summary[key]) {\n          data.summary[key] = {\n            ids: [id],\n            category,\n            shape: shapeType,\n            wordCount,\n            charCount\n          };\n        } else {\n          data.summary[key].wordCount += wordCount;\n          data.summary[key].charCount += charCount;\n          data.summary[key].ids.push(id);\n        }\n        data.elements.push({\n          id,\n          category,\n          start: start * 1000,\n          ...(end && {\n            end: end * 1000\n          }),\n          text\n        });\n        data.shapes.add(shapeType);\n        data.wordCount += wordCount;\n        data.charCount += charCount;\n        const review = this.review.getReview(id);\n        if (review && review.result === ReviewResult.REJECT) {\n          data.rejectedCharCount += charCount;\n          data.rejectedWordCount += wordCount;\n        } else {\n          data.approvedCharCount += charCount;\n          data.approvedWordCount += wordCount;\n        }\n      }\n      return {\n        ...data,\n        shapes: Array.from(data.shapes)\n      };\n    };\n    /**\n     * save file\n     * @param file\n     */\n    this.saveFile = file => this.jobProxy.saveFile(file);\n    makeAutoObservable(this, {\n      urls: observable,\n      initialized: observable\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.analyse = new AnalyseStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n  }\n  async init(payload) {\n    // init urls\n    try {\n      if (!payload.audio) {\n        throw new Error();\n      }\n      await this.parseAudio(payload.audio.split(','));\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('AUDIO_LOAD_ERROR')\n      });\n      this.setting.setLoading(false);\n    }\n    // init job proxy\n    this.jobProxy = payload.jobProxy;\n\n    // init common stores\n    try {\n      this.ontology.init(payload);\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR')\n      });\n    }\n    this.setting.init(payload);\n\n    // load result & init instances\n    try {\n      await this.loadResult(payload.ontology, payload.review_from);\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR')\n      });\n    }\n    // load & init reviews\n    try {\n      await this.loadReviews(payload);\n    } catch (error) {\n      notification.error({\n        message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR')\n      });\n    }\n    this.initialized = true;\n    this.checkMissingCharacter = payload.check_missing_character === 'true' || payload.check_missing_character === true;\n  }\n  async parseAudio(audios) {\n    const urls = [];\n    for (let i = 0; i < audios.length; i += 1) {\n      const audio = audios[i];\n      const format = audio.split('.').pop();\n      if ((format === null || format === void 0 ? void 0 : format.toLocaleLowerCase()) === 'mp3') {\n        const audioCtx = new AudioContext();\n        // eslint-disable-next-line no-await-in-loop\n        const arrayBuffer = await fetch(audio).then(data => data.arrayBuffer());\n        // eslint-disable-next-line no-await-in-loop\n        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);\n        const wav = audioBufferToWav(audioBuffer);\n        const blob = new Blob([wav], {\n          type: 'audio/wav'\n        });\n        urls.push(window.URL.createObjectURL(blob));\n      } else {\n        urls.push(audio);\n      }\n    }\n    this.urls = urls;\n  }\n\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology, reviewFrom) {\n    const savedResult = await this.jobProxy.loadSavedResult();\n    let reviewFromResult;\n    if (reviewFrom) {\n      const foramt = reviewFrom.split('.').pop();\n      if ((foramt === null || foramt === void 0 ? void 0 : foramt.toLocaleLowerCase()) === 'textgrid') {\n        reviewFromResult = await this.loadTextGrid(reviewFrom, ontology);\n      } else {\n        reviewFromResult = await this.jobProxy.loadReviewFrom();\n      }\n    }\n    // copy initial data\n    if (reviewFromResult) {\n      this.initialData = cloneDeep({\n        instances: reviewFromResult.instances\n      });\n    }\n    const result = savedResult || reviewFromResult;\n    // load instance\n    this.instance.init((result === null || result === void 0 ? void 0 : result.instances) ? loadInstancesFromResult(result === null || result === void 0 ? void 0 : result.instances, ontology) : []);\n    if (!result) {\n      return;\n    }\n    if (result.auditId) {\n      this.jobProxy.setAuditId(result.auditId);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  loadTextGrid(url, ontology) {\n    return new Promise((resolve, reject) => {\n      fetch(url).then(res => res.arrayBuffer()).then(async arrayBuffer => {\n        var _tg;\n        let tg;\n        try {\n          tg = parseTextgrid(Buffer.from(arrayBuffer));\n        } catch (error) {\n          notification.error({\n            message: i18n.translate('TEXTGRID_LOAD_ERROR')\n          });\n        }\n        const instances = [];\n        if (((_tg = tg) === null || _tg === void 0 ? void 0 : _tg.tierDict) && ontology) {\n          ontology.forEach((o, n) => {\n            var _tierData$entryList;\n            const tierData = tg.tierDict[o.class_name];\n            if ((tierData === null || tierData === void 0 ? void 0 : tierData.tierType) && PraatAnnotationType[o.type.toLocaleLowerCase()] === (tierData === null || tierData === void 0 ? void 0 : tierData.tierType) && ((_tierData$entryList = tierData.entryList) === null || _tierData$entryList === void 0 ? void 0 : _tierData$entryList.length) > 0) {\n              const isSegment = o.type === AnnotationType.SEGMENT;\n              const tierInstances = tierData.entryList.map(entry => ({\n                id: uuidv4(),\n                start: entry[0],\n                ...(isSegment && {\n                  end: entry[1]\n                }),\n                shapeType: o.type,\n                category: o.class_name,\n                categoryIndex: n,\n                text: isSegment ? entry[2] : entry[1]\n              })).sort((a, b) => a.start - b.start);\n              if (isSegment) {\n                if (tierInstances[0].start > 0) {\n                  tierInstances.unshift({\n                    id: uuidv4(),\n                    start: 0,\n                    end: tierInstances[0].start,\n                    shapeType: o.type,\n                    category: o.class_name,\n                    categoryIndex: n\n                  });\n                }\n                if (tierInstances[tierInstances.length - 1].end < tierData.maxTimestamp) {\n                  tierInstances.push({\n                    id: uuidv4(),\n                    start: tierInstances[tierInstances.length - 1].end,\n                    end: tierData.maxTimestamp,\n                    shapeType: o.type,\n                    category: o.class_name,\n                    categoryIndex: n\n                  });\n                }\n              }\n              instances.push(...tierInstances);\n            }\n          });\n        }\n        resolve({\n          instances\n        });\n      }).catch(error => {\n        console.log('load textgrid error: ', error);\n        resolve(false);\n      });\n    });\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const newInstances = Object.values(toJS(this.instance.instances)).map(({\n      id,\n      start,\n      end,\n      shapeType,\n      category,\n      text\n    }) => ({\n      id,\n      start,\n      end,\n      shapeType,\n      category,\n      text\n    }));\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy.saveResultStat(statData);\n    return this.jobProxy.saveResult({\n      auditId: this.jobProxy.auditId,\n      instances: newInstances,\n      statistics\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload) {\n    this.review.init(payload.jobProxy.toolMode, payload.issue_types);\n    const reviews = await this.jobProxy.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews() {\n    const {\n      reviewsResult\n    } = this.review;\n    return this.jobProxy.saveReviews(reviewsResult);\n  }\n}\nconst rootStore = new RootStore();\nexport default rootStore;","map":{"version":3,"names":["cloneDeep","v4","uuidv4","notification","makeAutoObservable","observable","toJS","parseTextgrid","audioBufferToWav","OntologyStore","UndoStore","AnalyseStore","SettingsStore","ReviewsStore","InstanceStore","loadInstancesFromResult","i18n","ReviewResult","PraatAnnotationType","AnnotationType","isAnnotationReadonly","isReviewEditable","isRework","isPreview","TOOL_MODE","RootStore","readonly","jobProxy","toolMode","reviewable","isLabeling","LABELING","constructor","ontology","undo","analyse","setting","review","instance","urls","initialData","initialized","checkMissingCharacter","getInstanceStatistics","categories","placement","duration","data","elements","map","className","shapes","Set","summary","approvedWordCount","rejectedWordCount","approvedCharCount","rejectedCharCount","wordCount","charCount","instancesList","Object","values","instances","filter","v","i","length","id","category","shapeType","start","end","text","indexOf","split","key","ids","shape","push","add","getReview","result","REJECT","Array","from","saveFile","file","init","payload","audio","Error","parseAudio","error","message","translate","setLoading","loadResult","review_from","loadReviews","check_missing_character","audios","format","pop","toLocaleLowerCase","audioCtx","AudioContext","arrayBuffer","fetch","then","audioBuffer","decodeAudioData","wav","blob","Blob","type","window","URL","createObjectURL","reviewFrom","savedResult","loadSavedResult","reviewFromResult","foramt","loadTextGrid","loadReviewFrom","auditId","setAuditId","url","Promise","resolve","reject","res","_tg","tg","Buffer","tierDict","forEach","o","n","_tierData$entryList","tierData","class_name","tierType","entryList","isSegment","SEGMENT","tierInstances","entry","categoryIndex","sort","a","b","unshift","maxTimestamp","catch","console","log","saveResult","submit","newInstances","statData","statistics","saveResultStat","issue_types","reviews","setInitialData","saveReviews","reviewsResult","rootStore"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/store/RootStore.ts"],"sourcesContent":["import { cloneDeep } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { notification } from 'antd';\nimport { makeAutoObservable, observable, toJS } from 'mobx';\nimport { parseTextgrid } from 'praatio';\nimport audioBufferToWav from 'audiobuffer-to-wav';\nimport OntologyStore from './OntologyStore';\nimport UndoStore from './UndoStore';\nimport AnalyseStore from './AnalyseStore';\nimport SettingsStore from './SettingsStore';\nimport ReviewsStore from './ReviewsStore';\nimport InstanceStore from './InstanceStore';\nimport { loadInstancesFromResult } from '../utils';\nimport i18n from '../locales';\nimport { Payload, Statistic, InstanceItem, Ontology, ReviewResult, Instance, PraatAnnotationType, AnnotationType } from '../types';\nimport JobProxy from '../../../libs/JobProxy';\nimport { isAnnotationReadonly, isReviewEditable, isRework, isPreview, TOOL_MODE } from '../../../utils/tool-mode';\n\n/**\n * root store\n * @class\n */\nclass RootStore {\n  ontology: OntologyStore;\n\n  undo: UndoStore;\n\n  analyse: AnalyseStore;\n\n  setting: SettingsStore;\n\n  review: ReviewsStore;\n\n  instance: InstanceStore;\n\n  urls: string[] = [];\n\n  /**\n   * job proxy\n   */\n  jobProxy?: JobProxy;\n\n  /**\n   * initial data copy\n   */\n  initialData: any = null;\n\n  /**\n   * is tool initialized\n   */\n  initialized = false;\n\n  /**\n   * check missing character\n   */\n  checkMissingCharacter = false;\n\n  /**\n   * is tool readonly (annotate not allowed)\n   */\n  get readonly() {\n    return isAnnotationReadonly(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool review enabled\n   */\n  get reviewable() {\n    return isReviewEditable(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in labeling mode\n   */\n  get isLabeling() {\n    return this.jobProxy!.toolMode === TOOL_MODE.LABELING;\n  }\n\n  /**\n   * is tool in rework mode\n   */\n  get isRework() {\n    return isRework(this.jobProxy!.toolMode);\n  }\n\n  /**\n   * is tool in preview mode\n   */\n  get isPreview() {\n    return isPreview(this.jobProxy!.toolMode);\n  }\n\n  constructor() {\n    makeAutoObservable(this, {\n      urls: observable,\n      initialized: observable,\n    });\n    this.ontology = new OntologyStore(this);\n    this.undo = new UndoStore(this);\n    this.analyse = new AnalyseStore(this);\n    this.setting = new SettingsStore(this);\n    this.review = new ReviewsStore(this);\n    this.instance = new InstanceStore(this);\n  }\n\n  async init(payload: Payload) {\n    // init urls\n    try {\n      if (!payload.audio) {\n        throw new Error();\n      }\n      await this.parseAudio(payload.audio.split(','));\n    } catch (error) {\n      notification.error({ message: i18n.translate('AUDIO_LOAD_ERROR') });\n      this.setting.setLoading(false);\n    }\n    // init job proxy\n    this.jobProxy = payload.jobProxy;\n\n    // init common stores\n    try {\n      this.ontology.init(payload);\n    } catch (error) {\n      notification.error({ message: i18n.translate('ANNOTATION_CONFIG_ONTOLOGY_ERROR') });\n    }\n    this.setting.init(payload);\n\n    // load result & init instances\n    try {\n      await this.loadResult(payload.ontology, payload.review_from);\n    } catch (error) {\n      notification.error({ message: i18n.translate('ANNOTATION_LOAD_RESULT_ERROR') });\n    }\n    // load & init reviews\n    try {\n      await this.loadReviews(payload);\n    } catch (error) {\n      notification.error({ message: i18n.translate('ANNOTATION_LOAD_REVIEW_ERROR') });\n    }\n    this.initialized = true;\n    this.checkMissingCharacter = payload.check_missing_character === 'true' || payload.check_missing_character === true;\n  }\n\n  async parseAudio(audios: string[]) {\n    const urls: string[] = [];\n    for (let i = 0; i < audios.length; i += 1) {\n      const audio = audios[i];\n      const format = audio.split('.').pop();\n      if (format?.toLocaleLowerCase() === 'mp3') {\n        const audioCtx = new AudioContext();\n        // eslint-disable-next-line no-await-in-loop\n        const arrayBuffer = await fetch(audio).then((data) => data.arrayBuffer());\n        // eslint-disable-next-line no-await-in-loop\n        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);\n        const wav = audioBufferToWav(audioBuffer);\n        const blob = new Blob([wav], { type: 'audio/wav' });\n        urls.push(window.URL.createObjectURL(blob));\n      } else {\n        urls.push(audio);\n      }\n    }\n    this.urls = urls;\n  }\n\n  /**\n   * load annotation result\n   */\n  async loadResult(ontology: Ontology[], reviewFrom?: string) {\n    const savedResult = await this.jobProxy!.loadSavedResult();\n    let reviewFromResult;\n    if (reviewFrom) {\n      const foramt = reviewFrom.split('.').pop();\n      if (foramt?.toLocaleLowerCase() === 'textgrid') {\n        reviewFromResult = await this.loadTextGrid(reviewFrom, ontology);\n      } else {\n        reviewFromResult = await this.jobProxy!.loadReviewFrom();\n      }\n    }\n    // copy initial data\n    if (reviewFromResult) {\n      this.initialData = cloneDeep({\n        instances: reviewFromResult.instances,\n      });\n    }\n    const result = savedResult || reviewFromResult;\n    // load instance\n    this.instance.init(result?.instances ? loadInstancesFromResult(result?.instances, ontology) : []);\n    if (!result) {\n      return;\n    }\n    if (result.auditId) {\n      this.jobProxy!.setAuditId(result.auditId);\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  loadTextGrid(url: string, ontology: Ontology[]) {\n    return new Promise((resolve, reject) => {\n      fetch(url)\n        .then((res) => res.arrayBuffer())\n        .then(async (arrayBuffer) => {\n          let tg: any;\n          try {\n            tg = parseTextgrid(Buffer.from(arrayBuffer));\n          } catch (error) {\n            notification.error({ message: i18n.translate('TEXTGRID_LOAD_ERROR') });\n          }\n          const instances: Instance[] = [];\n          if (tg?.tierDict && ontology) {\n            ontology.forEach((o, n) => {\n              const tierData = tg.tierDict[o.class_name];\n              if (\n                tierData?.tierType &&\n                PraatAnnotationType[o.type.toLocaleLowerCase()] === tierData?.tierType &&\n                tierData.entryList?.length > 0\n              ) {\n                const isSegment = o.type === AnnotationType.SEGMENT;\n                const tierInstances = tierData.entryList.map((entry: (string | number)[]) => ({\n                  id: uuidv4(),\n                  start: entry[0] as number,\n                  ...(isSegment && {\n                    end: entry[1] as number,\n                  }),\n                  shapeType: o.type,\n                  category: o.class_name,\n                  categoryIndex: n,\n                  text: (isSegment ? entry[2] : entry[1]) as string\n                })).sort((a : Instance, b: Instance) => a.start - b.start);\n                if (isSegment) {\n                  if (tierInstances[0].start > 0) {\n                    tierInstances.unshift({\n                      id: uuidv4(),\n                      start: 0,\n                      end: tierInstances[0].start,\n                      shapeType: o.type,\n                      category: o.class_name,\n                      categoryIndex: n,\n                    });\n                  }\n                  if (tierInstances[tierInstances.length - 1].end < tierData.maxTimestamp) {\n                    tierInstances.push({\n                      id: uuidv4(),\n                      start: tierInstances[tierInstances.length - 1].end,\n                      end: tierData.maxTimestamp,\n                      shapeType: o.type,\n                      category: o.class_name,\n                      categoryIndex: n,\n                    });\n                  }\n                }\n                instances.push(...tierInstances);\n              }\n            });\n          }\n          resolve({ instances });\n        }).catch((error) => {\n          console.log('load textgrid error: ', error);\n          resolve(false);\n        });\n    });\n  }\n\n  /**\n   * save annotation result\n   */\n  async saveResult(submit = false) {\n    const newInstances: InstanceItem[] = Object.values(toJS(this.instance.instances))\n      .map(({ id, start, end, shapeType, category, text }) => ({ id, start, end, shapeType, category, text }));\n    const statData = this.getInstanceStatistics();\n    const statistics = await this.jobProxy!.saveResultStat(statData);\n    return this.jobProxy!.saveResult({\n      auditId: this.jobProxy!.auditId,\n      instances: newInstances,\n      statistics,\n    }, submit);\n  }\n\n  /**\n   * load reviews result\n   * @param payload\n   */\n  async loadReviews(payload: Payload) {\n    this.review.init(payload.jobProxy.toolMode, payload.issue_types);\n    const reviews = await this.jobProxy!.loadReviews();\n    this.review.setInitialData(reviews);\n  }\n\n  /**\n   * save review result\n   */\n  async saveReviews() {\n    const { reviewsResult } = this.review;\n    return this.jobProxy!.saveReviews(reviewsResult);\n  }\n\n  /**\n   * get instance statistics\n   */\n  getInstanceStatistics = () => {\n    const { categories } = this.ontology;\n    const { placement: { duration } } = this.analyse;\n    const data: Statistic = {\n      elements: [],\n      categories: categories.map(({ className }) => className),\n      shapes: new Set(),\n      summary: {},\n      duration: duration * 1000, // file duration\n      approvedWordCount: 0,\n      rejectedWordCount: 0,\n      approvedCharCount: 0,\n      rejectedCharCount: 0,\n      wordCount: 0,\n      charCount: 0,\n    };\n\n    const instancesList = Object.values(this.instance.instances).filter((v) => !!v);\n    for (let i = 0; i < instancesList.length; i += 1) {\n      const { id, category, shapeType, start, end, text } = instancesList[i];\n      const charCount = text ? text.length : 0;\n      const wordCount = text && text.indexOf(' ') >= 0 ? text.split(' ').length : charCount;\n      const key = `${shapeType}_${category}`;\n      if (!data.summary[key]) {\n        data.summary[key] = {\n          ids: [id],\n          category,\n          shape: shapeType,\n          wordCount,\n          charCount,\n        };\n      } else {\n        data.summary[key].wordCount += wordCount;\n        data.summary[key].charCount += charCount;\n        data.summary[key].ids.push(id);\n      }\n      data.elements.push({\n        id,\n        category,\n        start: start * 1000,\n        ...end && {\n          end: end * 1000\n        },\n        text\n      });\n      data.shapes.add(shapeType);\n      data.wordCount += wordCount;\n      data.charCount += charCount;\n      const review = this.review.getReview(id);\n      if (review && review.result === ReviewResult.REJECT) {\n        data.rejectedCharCount += charCount;\n        data.rejectedWordCount += wordCount;\n      } else {\n        data.approvedCharCount += charCount;\n        data.approvedWordCount += wordCount;\n      }\n    }\n\n    return {\n      ...data,\n      shapes: Array.from(data.shapes),\n    };\n  };\n\n  /**\n   * save file\n   * @param file\n   */\n  saveFile = (file: File) => this.jobProxy!.saveFile(file);\n}\n\nconst rootStore = new RootStore();\nexport type RootStoreType = typeof rootStore;\nexport default rootStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}