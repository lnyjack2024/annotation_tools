{"ast":null,"code":"var _jsxFileName = \"/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/components/TierPannel/index.tsx\";\nimport React from 'react';\nimport { cloneDeep, debounce } from 'lodash';\nimport { makeObservable, reaction } from 'mobx';\nimport { Point, Container } from 'pixi.js';\nimport { observer } from 'mobx-react';\nimport cx from 'classnames';\nimport rootStore from '../../store/RootStore';\nimport ShapeFactory, { ShapeType } from '../../common/shapes/ShapeFactory';\nimport { hitTesting } from '../../utils';\nimport i18n from '../../locales';\nimport { AnnotationType, ReviewResult } from '../../types';\nimport Cursor from '../../../common/Cursor';\nimport './index.scss';\nexport class Tier extends React.Component {\n  constructor(props) {\n    super(props);\n    /**\n     * application dom container\n     */\n    this.container = void 0;\n    this.hoveredShape = void 0;\n    this.hoveredControl = void 0;\n    /**\n     * selected Tier\n     */\n    this.selectedTier = null;\n    /**\n    * view container\n    */\n    this.viewContainer = new Container();\n    /**\n    * tier container map\n    */\n    this.tierContainerMap = {};\n    /**\n    * add bar map\n    */\n    this.addBarMap = {};\n    /**\n    * add bar container\n    */\n    this.addContainer = new Container();\n    /**\n    * reaction disposer\n    */\n    this.reactionDisposers = [];\n    /**\n    * selected Shape\n    */\n    this.selectedShape = null;\n    /**\n     * same start time shape\n     */\n    this.sameStartShapes = [];\n    /**\n    * shape map\n    */\n    this.shapeMap = {};\n    this.resizeDebounced = void 0;\n    /**\n     * canvas dom mouse down\n     * @param event\n     */\n    this.handleMouseDown = id => {\n      var _this$hoveredShape;\n      const hoveredShape = id === ((_this$hoveredShape = this.hoveredShape) === null || _this$hoveredShape === void 0 ? void 0 : _this$hoveredShape.id) ? this.hoveredShape : this.shapeMap[id];\n      const {\n        getInstanceById,\n        setSelectedInstance,\n        selectedInstanceId\n      } = rootStore.instance;\n      const {\n        placement: {\n          atlasWidth,\n          atlasHeight\n        }\n      } = rootStore.analyse;\n      const {\n        isEnabled,\n        drawMode\n      } = rootStore.review;\n      if (hoveredShape) {\n        const {\n          category,\n          start,\n          end,\n          startX,\n          endX\n        } = hoveredShape;\n        if (id !== selectedInstanceId) {\n          setSelectedInstance(getInstanceById(id));\n          this.selectTier(category, this.tierContainerMap[category]);\n        }\n        if (end !== undefined) {\n          rootStore.analyse.setSelectedRegion({\n            start,\n            end\n          });\n        } else {\n          rootStore.analyse.setSelectedTime(start);\n        }\n        if (rootStore.analyse.isPlaying) {\n          rootStore.analyse.handlePlay();\n        }\n        const review = rootStore.review.getReview(id);\n        if (isEnabled && !drawMode || review) {\n          const positionX = Math.min(endX || startX, atlasWidth) + 190;\n          localStorage.setItem(rootStore.setting.reviewId, JSON.stringify({\n            x: positionX - atlasWidth / 2,\n            y: atlasHeight\n          }));\n          rootStore.setting.setReviewVisible(true);\n        }\n      }\n    };\n    /**\n     * canvas dom mouse move\n     * @param event\n     */\n    this.handleMouseMove = async event => {\n      const currentPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n      const localPoint = this.mapStageToLocalPosition(currentPoint);\n      const intersection = await hitTesting(currentPoint, localPoint, this.props.app.stage.children);\n      this.setHoveredShape(intersection === null || intersection === void 0 ? void 0 : intersection.shape);\n    };\n    /**\n     * canvas dom mouse leave\n     * @param event\n     */\n    this.handleMouseLeave = event => {\n      if (this.hoveredShape) {\n        this.hoveredShape.hovered = false;\n      }\n    };\n    /**\n     * set hovered control\n     * @param shape\n     */\n    this.setHoveredControl = shape => {\n      var _shape$control, _this$hoveredControl;\n      if (!rootStore.review.drawMode) return;\n      if (this.hoveredControl && this.hoveredControl === shape.control) {\n        this.hoveredControl = undefined;\n      } else if ((_shape$control = shape.control) === null || _shape$control === void 0 ? void 0 : _shape$control.hovered) {\n        this.hoveredControl = shape.control;\n      }\n      const {\n        prev\n      } = this.getPrevShape(shape.category, shape.start);\n      const cursor = ((_this$hoveredControl = this.hoveredControl) === null || _this$hoveredControl === void 0 ? void 0 : _this$hoveredControl.cursor) || Cursor.POINTER;\n      this.props.app.view.style.cursor = cursor;\n      shape.instance.cursor = cursor;\n      if (prev) prev.instance.cursor = cursor;\n    };\n    /**\n     * resize\n     */\n    this.resizeTier = () => {\n      const {\n        placement: {\n          atlasWidth\n        },\n        annotationPanelHeight\n      } = rootStore.analyse;\n      this.props.app.renderer.resize(atlasWidth, annotationPanelHeight);\n      this.props.app.render();\n      this.props.app.renderer.backgroundColor = 0xF6F7F9;\n      this.props.app.stage.removeChildren();\n      this.props.app.stage.addChild(this.viewContainer);\n      this.viewContainer.sortableChildren = true;\n      this.initContainer();\n      this.redrawShapes();\n    };\n    this.selectTier = (className, ctx) => {\n      var _this$selectedTier;\n      if (`tier_${(_this$selectedTier = this.selectedTier) === null || _this$selectedTier === void 0 ? void 0 : _this$selectedTier.id}` !== ctx.id) {\n        rootStore.ontology.selectCategory(className);\n        if (this.selectedTier) {\n          this.selectedTier.selected = false;\n        }\n        this.selectedTier = ctx;\n        this.selectedTier.selected = true;\n      }\n    };\n    this.redrawShapes = () => {\n      this.updateShapes(rootStore.instance.instances);\n    };\n    this.handleAddShape = (className, time) => {\n      if (this.selectedTier && this.selectedTier.category !== className) {\n        this.selectedTier.selected = false;\n      }\n      this.selectedTier = this.tierContainerMap[className];\n      this.selectedTier.selected = true;\n      rootStore.instance.addInstance(className, time);\n    };\n    this.positionListener = start => {\n      rootStore.analyse.setSelectedTime(start);\n    };\n    this.handleMoveShape = shapes => {\n      const updatedInstances = {};\n      shapes.forEach(({\n        id,\n        start,\n        end\n      }) => {\n        const instance = rootStore.instance.getInstanceById(id);\n        if (instance && (instance.start !== start || instance.end !== end)) {\n          updatedInstances[id] = {\n            ...instance,\n            start,\n            end\n          };\n        }\n      });\n      rootStore.instance.setUpdatedInstances(updatedInstances);\n    };\n    /**\n     * update shapes\n     */\n    this.updateShapes = updatedInstances => {\n      const {\n        atlasWidth\n      } = rootStore.analyse.placement;\n      if (atlasWidth > 0) {\n        const ids = Object.keys(updatedInstances);\n        if (ids.length > 0) {\n          Object.keys(updatedInstances).forEach(id => {\n            const instance = updatedInstances[id];\n            if (instance) {\n              const {\n                start,\n                end,\n                category,\n                categoryIndex,\n                text\n              } = instance;\n              if (this.shapeMap[id]) {\n                this.updateShape(id, start, end, text);\n              } else {\n                this.createShape(id, category, categoryIndex, start, text, end);\n              }\n            } else {\n              this.removeShape(id);\n            }\n          });\n          rootStore.instance.setUpdatedInstances({});\n          if (rootStore.review.drawMode) {\n            this.getCanAddTiers();\n          }\n        }\n      }\n    };\n    /**\n     * update shape\n     * @param id\n     * @param startTime\n     * @param endTime\n     */\n    this.updateShape = (id, startTime, endTime, text) => {\n      const shape = this.shapeMap[id];\n      if (shape) {\n        if (shape.end === endTime && shape.start === startTime) {\n          if (text !== shape.text) {\n            shape.text = text;\n          } else {\n            shape.normalize();\n          }\n        } else {\n          shape.start = startTime;\n          if (endTime && shape.shapeType === AnnotationType.SEGMENT) {\n            shape.end = endTime;\n          }\n        }\n      }\n    };\n    /**\n     * remove shape\n     * @param id\n     */\n    this.removeShape = id => {\n      const shape = this.shapeMap[id];\n      if (shape) {\n        shape.destroy();\n        delete this.shapeMap[id];\n      }\n    };\n    this.initReviews = () => {\n      const {\n        reviewsResult,\n        customWarnings\n      } = rootStore.review;\n      const keys = Object.keys(rootStore.instance.instances);\n      keys.forEach(key => {\n        let review;\n        const warning = customWarnings.find(({\n          id\n        }) => id === key);\n        if (warning) {\n          review = {\n            instanceId: warning.id,\n            result: ReviewResult.REJECT\n          };\n        } else {\n          review = reviewsResult.find(({\n            instanceId\n          }) => instanceId === key);\n        }\n        this.drawReview(key, review);\n      });\n    };\n    this.drawReview = (id, review) => {\n      if (id && this.shapeMap[id]) {\n        this.shapeMap[id].reviewResult = review ? review.result : undefined;\n      }\n    };\n    /**\n     * create shape\n     * @param id\n     * @param className tier category\n     * @param index tier number\n     * @param startTime start time\n     * @param endTime end time\n     */\n    this.createShape = (id, className, index, startTime, text, endTime) => {\n      const category = rootStore.ontology.getCategory(className);\n      if (startTime !== undefined && (category === null || category === void 0 ? void 0 : category.className)) {\n        var _rootStore$review$upd;\n        const shapeType = category.type;\n        const shape = ShapeFactory.getShape(shapeType, {\n          id,\n          app: this.props.app,\n          start: startTime,\n          end: endTime,\n          text,\n          container: this.viewContainer,\n          shapeType,\n          category: className,\n          categoryIndex: index,\n          reviewResult: (_rootStore$review$upd = rootStore.review.updatedReviews[id]) === null || _rootStore$review$upd === void 0 ? void 0 : _rootStore$review$upd.result,\n          selectShape: this.handleMouseDown,\n          moveShape: this.handleMoveShape,\n          positionListener: this.positionListener,\n          getPrevShape: this.getPrevShape,\n          getSameAndAdjoinTimeShapes: this.getSameAndAdjoinTimeShapes,\n          dblclick: this.props.focusForm,\n          handleControlHoverChange: this.setHoveredControl\n        });\n        this.shapeMap[shape.id] = shape;\n        if (rootStore.instance.selectedInstanceId === id) {\n          this.setSelectedShape(id);\n          this.selectTier(className, this.tierContainerMap[className]);\n        }\n      }\n    };\n    this.getPrevShape = (category, start) => {\n      const {\n        prevInstance,\n        nextInstance\n      } = rootStore.instance.getAdjoinInstances(category, start);\n      const adjoinShapes = {\n        prev: undefined,\n        next: undefined\n      };\n      if (prevInstance) {\n        adjoinShapes.prev = this.shapeMap[prevInstance.id];\n      }\n      if (nextInstance) {\n        adjoinShapes.next = this.shapeMap[nextInstance.id];\n      }\n      return adjoinShapes;\n    };\n    this.getSameAndAdjoinTimeShapes = time => {\n      const sameTimeShapes = this.shapes.filter(shape => shape.start === time);\n      const adjoinTimeShapes = sameTimeShapes.map(({\n        category,\n        start\n      }) => this.getPrevShape(category, start));\n      return {\n        sameTimeShapes,\n        adjoinTimeShapes\n      };\n    };\n    this.container = React.createRef();\n\n    // set interactive\n    this.props.app.stage.interactive = this.props.interactive !== false;\n    makeObservable(this, {});\n  }\n  get shapes() {\n    return Object.values(this.shapeMap);\n  }\n  async componentDidMount() {\n    if (this.container.current) {\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n      this.props.app.stage.sortableChildren = true;\n      this.reactionDisposers.push(reaction(() => this.selectedTime, () => {\n        this.getCanAddTiers();\n      }));\n      this.reactionDisposers.push(reaction(() => this.resizeShapes, () => {\n        if (!this.resizeDebounced) {\n          this.resizeDebounced = debounce(this.resizeTier, 100);\n        }\n        this.resizeDebounced();\n      }));\n      this.reactionDisposers.push(reaction(() => rootStore.ontology.canAddTiers, () => {\n        this.initAddBar();\n      }));\n      this.reactionDisposers.push(reaction(() => rootStore.instance.updatedInstances, () => {\n        this.updateShapes(rootStore.instance.updatedInstances);\n      }));\n      this.reactionDisposers.push(reaction(() => rootStore.review.updatedReviews, () => {\n        this.initReviews();\n      }));\n      this.reactionDisposers.push(reaction(() => rootStore.review.drawMode, () => {\n        this.redrawShapes();\n      }));\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get selectedTime() {\n    return {\n      time: rootStore.analyse.selectedTime,\n      region: rootStore.analyse.selectedRegion,\n      drawMode: rootStore.review.drawMode\n    };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get resizeShapes() {\n    return {\n      placement: rootStore.analyse.placement,\n      displayBuffer: rootStore.analyse.displayBuffer\n    };\n  }\n  componentDidUpdate(prevProps) {\n    if (JSON.stringify(prevProps.selectedInstance) !== JSON.stringify(this.props.selectedInstance)) {\n      var _this$props$selectedI;\n      this.setSelectedShape((_this$props$selectedI = this.props.selectedInstance) === null || _this$props$selectedI === void 0 ? void 0 : _this$props$selectedI.id);\n    }\n  }\n  componentWillUnmount() {\n    this.reactionDisposers.forEach(disposer => disposer());\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x, y) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n  initContainer() {\n    this.tierContainerMap = {};\n    const {\n      categories\n    } = rootStore.ontology;\n    const {\n      tierHeight,\n      placement: {\n        atlasWidth\n      }\n    } = rootStore.analyse;\n    categories.forEach((category, i) => {\n      const container = ShapeFactory.getShape(ShapeType.TIER_CONTAINER, {\n        id: `tier_${category.className}`,\n        index: i,\n        width: atlasWidth,\n        container: this.viewContainer,\n        height: tierHeight,\n        category: category.className,\n        app: this.props.app,\n        selected: i === 0,\n        onSelected: this.selectTier\n      });\n      this.tierContainerMap[category.className] = container;\n      if (i === 0) {\n        this.selectedTier = container;\n      }\n    });\n    this.addContainer.zIndex = 999;\n    this.props.app.stage.addChild(this.addContainer);\n  }\n  initAddBar() {\n    const {\n      analyse: {\n        selectedTime,\n        selectedRegion,\n        displayBuffer,\n        placement,\n        tierHeight\n      },\n      ontology: {\n        canAddTiers\n      }\n    } = rootStore;\n    const {\n      atlasWidth,\n      duration\n    } = placement;\n    const tiers = Object.entries(canAddTiers);\n    this.addContainer.removeChildren();\n    if ((selectedTime || selectedRegion) && tiers.length > 0) {\n      const {\n        start,\n        precent\n      } = displayBuffer;\n      const visibleStartTime = start * duration;\n      const colWidth = atlasWidth / (precent * duration);\n      const createAddBar = (x, index, type, className, time, endX) => {\n        ShapeFactory.getShape(ShapeType.ADD_BAR, {\n          x,\n          endX,\n          index,\n          type,\n          time,\n          height: tierHeight,\n          category: className,\n          container: this.addContainer,\n          app: this.props.app,\n          onAdd: this.handleAddShape\n        });\n      };\n      tiers.forEach(([className, {\n        index,\n        type,\n        size,\n        first,\n        second\n      }]) => {\n        const {\n          start: startTime = selectedTime,\n          end: endTime\n        } = size || {};\n        let x = (startTime - visibleStartTime) * colWidth;\n        let endX;\n        if (endTime !== undefined && endTime !== startTime) {\n          endX = (endTime - visibleStartTime) * colWidth;\n        }\n        if (type === AnnotationType.TIMING) {\n          if (first && x > 0 && x < atlasWidth) createAddBar(x, index, type, className, [startTime]);\n          if (second && endX !== undefined && endX > 0 && endX < atlasWidth) createAddBar(endX, index, type, className, [endTime]);\n        } else if (type === AnnotationType.SEGMENT) {\n          if (x <= 0 && (endX === undefined || endX <= 0) || x >= atlasWidth && (endX === undefined || endX >= atlasWidth)) return;\n          x = Math.max(0, x);\n          endX = startTime !== endTime && endX !== undefined ? Math.min(endX, atlasWidth) : undefined;\n          createAddBar(x, index, type, className, [first ? startTime : undefined, second ? endTime : undefined], endX);\n        }\n      });\n    }\n  }\n  getCanAddTiers() {\n    if (!rootStore.review.drawMode) {\n      this.addContainer.removeChildren();\n      return;\n    }\n    const {\n      selectedTime,\n      displayBuffer,\n      placement,\n      selectedRegion\n    } = rootStore.analyse;\n    const {\n      enableCategories: defaultEnableCategories\n    } = rootStore.ontology;\n    const {\n      start,\n      precent\n    } = displayBuffer;\n    const {\n      atlasWidth,\n      duration\n    } = placement;\n    const visibleStartTime = start * duration;\n    const colWidth = atlasWidth / (precent * duration);\n    const enableCategories = cloneDeep(defaultEnableCategories);\n    if (selectedRegion || selectedTime) {\n      const {\n        start: first = selectedTime,\n        end: second = selectedTime\n      } = selectedRegion || {};\n      const firstX = (first - visibleStartTime) * colWidth;\n      const secondX = (second - visibleStartTime) * colWidth;\n      Object.keys(enableCategories).forEach(key => {\n        if (selectedRegion === null || secondX - firstX <= 5) {\n          enableCategories[key].second = false;\n        }\n        enableCategories[key].size = {\n          start: first,\n          end: second\n        };\n        if (firstX - 0 <= 5 || atlasWidth - firstX <= 5) {\n          enableCategories[key].first = false;\n        }\n        if (secondX - 0 <= 5 || atlasWidth - secondX <= 5) {\n          enableCategories[key].second = false;\n        }\n      });\n      Object.values(this.shapeMap).forEach(({\n        startX,\n        category,\n        start: sStart\n      }) => {\n        const enableCategory = enableCategories[category];\n        if (enableCategory) {\n          let nearLeft = Math.abs(firstX - startX) <= 5;\n          const nearRight = Math.abs(secondX - startX) <= 5;\n          // The selected region is cut off by shape\n          if (startX > firstX && startX < secondX && enableCategory.type === AnnotationType.SEGMENT) {\n            enableCategory.first = false;\n            nearLeft = true;\n          }\n          if (enableCategory.size) {\n            if (nearLeft) {\n              enableCategory.first = false;\n              if (sStart > enableCategory.size.start) enableCategory.size.start = sStart;\n            }\n            if (nearRight) {\n              enableCategory.second = false;\n              if (sStart < enableCategory.size.end) enableCategory.size.end = sStart;\n            }\n          }\n          if (nearLeft && nearRight || !enableCategory.first && !enableCategory.second) {\n            delete enableCategories[category];\n          }\n        }\n      });\n      rootStore.ontology.setCanAddTiers(enableCategories);\n    } else {\n      rootStore.ontology.setCanAddTiers({});\n    }\n  }\n  /**\n   * set selected shape\n   * @param shape\n   */\n  setSelectedShape(id) {\n    if (this.selectedShape) {\n      this.selectedShape.selected = false;\n    }\n    const shape = this.shapeMap[id || ''];\n    if (shape) {\n      this.selectedShape = shape;\n      this.selectedShape.selected = true;\n    }\n    this.drawSameStartShape(shape === null || shape === void 0 ? void 0 : shape.start);\n  }\n\n  /**\n   * redraw shape control\n   * @param start start time\n   */\n  drawSameStartShape(start) {\n    if (this.sameStartShapes.length > 0) {\n      this.sameStartShapes.forEach(s => {\n        s.selectedStart = false;\n      });\n    }\n    if (start !== undefined) {\n      const sameStartShapes = [];\n      this.shapes.forEach(s => {\n        var _this$selectedShape;\n        if (s.start === start && s.id !== ((_this$selectedShape = this.selectedShape) === null || _this$selectedShape === void 0 ? void 0 : _this$selectedShape.id)) {\n          s.selectedStart = true;\n          sameStartShapes.push(s);\n        }\n      });\n      this.sameStartShapes = sameStartShapes;\n    }\n  }\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point) {\n    return this.props.app.stage.toLocal(point);\n  }\n\n  /**\n   * check if the point is in the stage\n   * @param point\n   */\n  isPointInStage(point) {\n    const {\n      x,\n      y\n    } = this.getStagePosition();\n    const {\n      width,\n      height\n    } = this.getStageSize();\n    return point.x >= x && point.x <= x + width && point.y >= y && point.y <= y + height;\n  }\n\n  /**\n   * get stage size\n   */\n  getStageSize() {\n    return {\n      width: this.props.app.stage.width,\n      height: this.props.app.stage.height\n    };\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.props.app.stage.x,\n      y: this.props.app.stage.y\n    };\n  }\n  render() {\n    const {\n      analyse: {\n        placement,\n        annotationPanelHeight\n      },\n      ontology: {\n        categories,\n        selectedCategoryName\n      },\n      instance: {\n        selectedInstance,\n        selectedNumber,\n        categoryInstancesMap\n      }\n    } = rootStore;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tier-container\",\n      style: {\n        height: `${annotationPanelHeight}px`,\n        padding: `0 ${placement.margin}px`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 704,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"canvas-container\",\n      ref: this.container,\n      onMouseMove: this.handleMouseMove,\n      onMouseLeave: this.handleMouseLeave,\n      onContextMenu: e => e.preventDefault(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 708,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tier-categories\",\n      style: {\n        width: `${placement.margin}px`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 715,\n        columnNumber: 9\n      }\n    }, categories.map(({\n      className,\n      displayName,\n      type\n    }) => {\n      var _categoryInstancesMap;\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: cx('tier-categories-item', {\n          active: selectedCategoryName === className\n        }),\n        key: className,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 717,\n          columnNumber: 13\n        }\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"item-category\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 723,\n          columnNumber: 15\n        }\n      }, displayName), /*#__PURE__*/React.createElement(\"div\", {\n        className: \"item-info\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 724,\n          columnNumber: 15\n        }\n      }, /*#__PURE__*/React.createElement(\"span\", {\n        className: \"item-info-number\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 725,\n          columnNumber: 17\n        }\n      }, (selectedInstance === null || selectedInstance === void 0 ? void 0 : selectedInstance.category) === className ? `${selectedNumber}/` : '', ((_categoryInstancesMap = categoryInstancesMap[className]) === null || _categoryInstancesMap === void 0 ? void 0 : _categoryInstancesMap.length) || 0), /*#__PURE__*/React.createElement(\"span\", {\n        className: \"item-info-type\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 729,\n          columnNumber: 17\n        }\n      }, i18n.translate(type === AnnotationType.TIMING ? 'TIER_TIMING' : 'TIER_SEGMENT'))));\n    })));\n  }\n}\nexport default observer(Tier);","map":{"version":3,"names":["React","cloneDeep","debounce","makeObservable","reaction","Point","Container","observer","cx","rootStore","ShapeFactory","ShapeType","hitTesting","i18n","AnnotationType","ReviewResult","Cursor","Tier","Component","constructor","props","container","hoveredShape","hoveredControl","selectedTier","viewContainer","tierContainerMap","addBarMap","addContainer","reactionDisposers","selectedShape","sameStartShapes","shapeMap","resizeDebounced","handleMouseDown","id","_this$hoveredShape","getInstanceById","setSelectedInstance","selectedInstanceId","instance","placement","atlasWidth","atlasHeight","analyse","isEnabled","drawMode","review","category","start","end","startX","endX","selectTier","undefined","setSelectedRegion","setSelectedTime","isPlaying","handlePlay","getReview","positionX","Math","min","localStorage","setItem","setting","reviewId","JSON","stringify","x","y","setReviewVisible","handleMouseMove","event","currentPoint","mapScreenToStagePosition","clientX","clientY","localPoint","mapStageToLocalPosition","intersection","app","stage","children","setHoveredShape","shape","handleMouseLeave","hovered","setHoveredControl","_shape$control","_this$hoveredControl","control","prev","getPrevShape","cursor","POINTER","view","style","resizeTier","annotationPanelHeight","renderer","resize","render","backgroundColor","removeChildren","addChild","sortableChildren","initContainer","redrawShapes","className","ctx","_this$selectedTier","ontology","selectCategory","selected","updateShapes","instances","handleAddShape","time","addInstance","positionListener","handleMoveShape","shapes","updatedInstances","forEach","setUpdatedInstances","ids","Object","keys","length","categoryIndex","text","updateShape","createShape","removeShape","getCanAddTiers","startTime","endTime","normalize","shapeType","SEGMENT","destroy","initReviews","reviewsResult","customWarnings","key","warning","find","instanceId","result","REJECT","drawReview","reviewResult","index","getCategory","_rootStore$review$upd","type","getShape","updatedReviews","selectShape","moveShape","getSameAndAdjoinTimeShapes","dblclick","focusForm","handleControlHoverChange","setSelectedShape","prevInstance","nextInstance","getAdjoinInstances","adjoinShapes","next","sameTimeShapes","filter","adjoinTimeShapes","map","createRef","interactive","values","componentDidMount","current","appendChild","push","selectedTime","resizeShapes","canAddTiers","initAddBar","region","selectedRegion","displayBuffer","componentDidUpdate","prevProps","selectedInstance","_this$props$selectedI","componentWillUnmount","disposer","point","plugins","interaction","mapPositionToPoint","categories","tierHeight","i","TIER_CONTAINER","width","height","onSelected","zIndex","duration","tiers","entries","precent","visibleStartTime","colWidth","createAddBar","ADD_BAR","onAdd","size","first","second","TIMING","max","enableCategories","defaultEnableCategories","firstX","secondX","sStart","enableCategory","nearLeft","abs","nearRight","setCanAddTiers","drawSameStartShape","s","selectedStart","_this$selectedShape","toLocal","isPointInStage","getStagePosition","getStageSize","selectedCategoryName","selectedNumber","categoryInstancesMap","createElement","padding","margin","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref","onMouseMove","onMouseLeave","onContextMenu","e","preventDefault","displayName","_categoryInstancesMap","active","translate"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/phonetic-transcription/components/TierPannel/index.tsx"],"sourcesContent":["import React from 'react';\nimport { cloneDeep, debounce, DebouncedFunc } from 'lodash';\nimport { makeObservable, IReactionDisposer, reaction } from 'mobx';\nimport { Application, Point, Container } from 'pixi.js';\nimport { observer } from 'mobx-react';\nimport cx from 'classnames';\nimport TierContainer from '../../common/shapes/TierContainer';\nimport AddBar from '../../common/controls/AddBar';\nimport Shape from '../../common/shapes/Shape';\nimport ControlBar from '../../common/controls/ControlBar';\nimport rootStore from '../../store/RootStore';\nimport ShapeFactory, { ShapeType } from '../../common/shapes/ShapeFactory';\nimport { hitTesting } from '../../utils';\nimport i18n from '../../locales';\nimport { Instance, AnnotationType, Review, ReviewResult } from '../../types';\nimport Cursor from '../../../common/Cursor';\nimport './index.scss';\n\ninterface TierProps {\n  app: Application;\n  interactive: boolean;\n  selectedInstance: Instance | null;\n  focusForm: () => void;\n}\nexport class Tier extends React.Component<TierProps> {\n  /**\n   * application dom container\n   */\n  container: React.RefObject<HTMLDivElement>;\n\n  hoveredShape?: Shape<unknown>;\n\n  hoveredControl?: ControlBar;\n\n  /**\n   * selected Tier\n   */\n  selectedTier: TierContainer | null = null;\n\n  /**\n  * view container\n  */\n  viewContainer = new Container();\n\n  /**\n  * tier container map\n  */\n  tierContainerMap: { [category: string]: TierContainer } = {};\n\n  /**\n  * add bar map\n  */\n  addBarMap: { [category: string]: AddBar } = {};\n\n  /**\n  * add bar container\n  */\n  addContainer = new Container();\n\n  /**\n  * reaction disposer\n  */\n  reactionDisposers: IReactionDisposer[] = [];\n\n  /**\n  * selected Shape\n  */\n  selectedShape: Shape<unknown> | null = null;\n\n  /**\n   * same start time shape\n   */\n  sameStartShapes: Shape<unknown>[] = [];\n\n  /**\n  * shape map\n  */\n  shapeMap: {[id: string]: Shape<unknown>} = {};\n\n  resizeDebounced?: DebouncedFunc<any>;\n\n  constructor(props: TierProps) {\n    super(props);\n    this.container = React.createRef();\n\n    // set interactive\n    this.props.app.stage.interactive = this.props.interactive !== false;\n\n    makeObservable(this, {});\n  }\n\n  get shapes() {\n    return Object.values(this.shapeMap);\n  }\n\n  async componentDidMount() {\n    if (this.container.current) {\n      // setup view\n      this.container.current.appendChild(this.props.app.view);\n      this.props.app.stage.sortableChildren = true;\n\n      this.reactionDisposers.push(reaction(\n        () => this.selectedTime,\n        () => {\n          this.getCanAddTiers();\n        },\n      ));\n\n      this.reactionDisposers.push(reaction(\n        () => this.resizeShapes,\n        () => {\n          if (!this.resizeDebounced) {\n            this.resizeDebounced = debounce(this.resizeTier, 100);\n          }\n          this.resizeDebounced();\n        },\n      ));\n\n      this.reactionDisposers.push(reaction(\n        () => rootStore.ontology.canAddTiers,\n        () => {\n          this.initAddBar();\n        },\n      ));\n\n      this.reactionDisposers.push(reaction(\n        () => rootStore.instance.updatedInstances,\n        () => {\n          this.updateShapes(rootStore.instance.updatedInstances);\n        }\n      ));\n\n      this.reactionDisposers.push(reaction(\n        () => rootStore.review.updatedReviews,\n        () => {\n          this.initReviews();\n        }\n      ));\n\n      this.reactionDisposers.push(reaction(\n        () => rootStore.review.drawMode,\n        () => {\n          this.redrawShapes();\n        }\n      ));\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get selectedTime() {\n    return {\n      time: rootStore.analyse.selectedTime,\n      region: rootStore.analyse.selectedRegion,\n      drawMode: rootStore.review.drawMode,\n    };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  get resizeShapes() {\n    return {\n      placement: rootStore.analyse.placement,\n      displayBuffer: rootStore.analyse.displayBuffer,\n    };\n  }\n\n  componentDidUpdate(prevProps: TierProps) {\n    if (JSON.stringify(prevProps.selectedInstance) !== JSON.stringify(this.props.selectedInstance)) {\n      this.setSelectedShape(this.props.selectedInstance?.id);\n    }\n  }\n\n  componentWillUnmount() {\n    this.reactionDisposers.forEach((disposer) => disposer());\n  }\n\n  /**\n   * map screen position to stage position as a PIXI point\n   * @param x screen position x\n   * @param y screen position y\n   */\n  mapScreenToStagePosition(x: number, y: number) {\n    const point = new Point();\n    this.props.app.renderer.plugins.interaction.mapPositionToPoint(point, x, y);\n    return point;\n  }\n\n  /**\n   * canvas dom mouse down\n   * @param event\n   */\n  handleMouseDown = (id: string) => {\n    const hoveredShape = id === this.hoveredShape?.id ? this.hoveredShape : this.shapeMap[id];\n    const { getInstanceById, setSelectedInstance, selectedInstanceId } = rootStore.instance;\n    const { placement: { atlasWidth, atlasHeight } } = rootStore.analyse;\n    const { isEnabled, drawMode } = rootStore.review;\n    if (hoveredShape) {\n      const { category, start, end, startX, endX } = hoveredShape;\n      if (id !== selectedInstanceId) {\n        setSelectedInstance(getInstanceById(id));\n        this.selectTier(category, this.tierContainerMap[category]);\n      }\n      if (end !== undefined) {\n        rootStore.analyse.setSelectedRegion({ start, end });\n      } else {\n        rootStore.analyse.setSelectedTime(start);\n      }\n      if (rootStore.analyse.isPlaying) {\n        rootStore.analyse.handlePlay();\n      }\n      const review = rootStore.review.getReview(id);\n      if ((isEnabled && !drawMode) || review) {\n        const positionX = Math.min((endX || startX), atlasWidth) + 190;\n        localStorage.setItem(rootStore.setting.reviewId, JSON.stringify({ x: positionX - (atlasWidth / 2), y: atlasHeight }));\n        rootStore.setting.setReviewVisible(true);\n      }\n    }\n  };\n\n  /**\n   * canvas dom mouse move\n   * @param event\n   */\n  handleMouseMove = async (event: React.MouseEvent) => {\n    const currentPoint = this.mapScreenToStagePosition(event.clientX, event.clientY);\n\n    const localPoint = this.mapStageToLocalPosition(currentPoint);\n    const intersection = await hitTesting(currentPoint, localPoint, this.props.app.stage.children);\n    this.setHoveredShape(intersection?.shape as unknown as Shape<unknown>);\n  };\n\n  /**\n   * canvas dom mouse leave\n   * @param event\n   */\n  handleMouseLeave = (event: React.MouseEvent) => {\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = false;\n    }\n  };\n\n  /**\n   * set hovered shape\n   * @param shape\n   */\n  setHoveredShape(shape?: Shape<unknown>) {\n    if (shape === this.hoveredShape) {\n      return;\n    }\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = false;\n    }\n    this.hoveredShape = shape;\n    if (this.hoveredShape) {\n      this.hoveredShape.hovered = true;\n    }\n  }\n\n  /**\n   * set hovered control\n   * @param shape\n   */\n  setHoveredControl = (shape: Shape<unknown>) => {\n    if (!rootStore.review.drawMode) return;\n    if (this.hoveredControl && this.hoveredControl === shape.control) {\n      this.hoveredControl = undefined;\n    } else if (shape.control?.hovered) {\n      this.hoveredControl = shape.control;\n    }\n    const { prev } = this.getPrevShape(shape.category, shape.start);\n    const cursor = this.hoveredControl?.cursor || Cursor.POINTER;\n    this.props.app.view.style.cursor = cursor;\n    shape.instance.cursor = cursor;\n    if (prev) prev.instance.cursor = cursor;\n  };\n\n  /**\n   * resize\n   */\n  resizeTier = () => {\n    const { placement: { atlasWidth }, annotationPanelHeight } = rootStore.analyse;\n    this.props.app.renderer.resize(atlasWidth, annotationPanelHeight);\n    this.props.app.render();\n    this.props.app.renderer.backgroundColor = 0xF6F7F9;\n    this.props.app.stage.removeChildren();\n    this.props.app.stage.addChild(this.viewContainer);\n    this.viewContainer.sortableChildren = true;\n\n    this.initContainer();\n    this.redrawShapes();\n  };\n\n  initContainer() {\n    this.tierContainerMap = {};\n    const { categories } = rootStore.ontology;\n    const { tierHeight, placement: { atlasWidth } } = rootStore.analyse;\n    categories.forEach((category, i) => {\n      const container = ShapeFactory.getShape(ShapeType.TIER_CONTAINER, {\n        id: `tier_${category.className}`,\n        index: i,\n        width: atlasWidth,\n        container: this.viewContainer,\n        height: tierHeight,\n        category: category.className,\n        app: this.props.app,\n        selected: i === 0,\n        onSelected: this.selectTier,\n      }) as TierContainer;\n      this.tierContainerMap[category.className] = container;\n      if (i === 0) {\n        this.selectedTier = container;\n      }\n    });\n    this.addContainer.zIndex = 999;\n    this.props.app.stage.addChild(this.addContainer);\n  }\n\n  selectTier = (className: string, ctx: TierContainer) => {\n    if (`tier_${this.selectedTier?.id}` !== ctx.id) {\n      rootStore.ontology.selectCategory(className);\n      if (this.selectedTier) {\n        this.selectedTier.selected = false;\n      }\n      this.selectedTier = ctx;\n      this.selectedTier.selected = true;\n    }\n  };\n\n  initAddBar() {\n    const {\n      analyse: { selectedTime, selectedRegion, displayBuffer, placement, tierHeight },\n      ontology: { canAddTiers },\n    } = rootStore;\n    const { atlasWidth, duration } = placement;\n    const tiers = Object.entries(canAddTiers);\n    this.addContainer.removeChildren();\n    if ((selectedTime || selectedRegion) && tiers.length > 0) {\n      const { start, precent } = displayBuffer;\n      const visibleStartTime = start * duration;\n      const colWidth = atlasWidth / (precent * duration);\n      const createAddBar = (x: number, index: number, type: AnnotationType, className: string, time: (number | undefined)[], endX?: number) => {\n        ShapeFactory.getShape(ShapeType.ADD_BAR, {\n          x,\n          endX,\n          index,\n          type,\n          time,\n          height: tierHeight,\n          category: className,\n          container: this.addContainer,\n          app: this.props.app,\n          onAdd: this.handleAddShape\n        });\n      };\n      tiers.forEach(([className, { index, type, size, first, second }]) => {\n        const { start: startTime = selectedTime, end: endTime } = size || {};\n        let x = (startTime! - visibleStartTime) * colWidth;\n        let endX: undefined | number;\n        if (endTime !== undefined && endTime !== startTime) {\n          endX = (endTime - visibleStartTime) * colWidth;\n        }\n        if (type === AnnotationType.TIMING) {\n          if (first && x > 0 && x < atlasWidth) createAddBar(x, index, type, className, [startTime!]);\n          if (second && endX !== undefined && endX > 0 && endX < atlasWidth) createAddBar(endX, index, type, className, [endTime!]);\n        } else if (type === AnnotationType.SEGMENT) {\n          if (\n            (x <= 0 && (endX === undefined || endX <= 0)) ||\n            (x >= atlasWidth && (endX === undefined || endX >= atlasWidth))\n          ) return;\n          x = Math.max(0, x);\n          endX = startTime !== endTime && endX !== undefined ? Math.min(endX, atlasWidth) : undefined;\n          createAddBar(x, index, type, className, [first ? startTime! : undefined, second ? endTime : undefined], endX);\n        }\n      });\n    }\n  }\n\n  redrawShapes = () => {\n    this.updateShapes(rootStore.instance.instances);\n  };\n\n  handleAddShape = (className: string, time: number | number[]) => {\n    if (this.selectedTier && this.selectedTier.category !== className) {\n      this.selectedTier.selected = false;\n    }\n    this.selectedTier = this.tierContainerMap[className];\n    this.selectedTier.selected = true;\n    rootStore.instance.addInstance(className, time);\n  };\n\n  positionListener = (start: number) => {\n    rootStore.analyse.setSelectedTime(start);\n  };\n\n  handleMoveShape = (shapes: { id: string; start: number; end?: number; }[]) => {\n    const updatedInstances:{[id: string]: Instance} = {};\n    shapes.forEach(({ id, start, end }) => {\n      const instance = rootStore.instance.getInstanceById(id);\n      if (instance && (instance.start !== start || instance.end !== end)) {\n        updatedInstances[id] = {\n          ...instance,\n          start,\n          end\n        };\n      }\n    });\n    rootStore.instance.setUpdatedInstances(updatedInstances);\n  };\n\n  getCanAddTiers() {\n    if (!rootStore.review.drawMode) {\n      this.addContainer.removeChildren();\n      return;\n    }\n    const { selectedTime, displayBuffer, placement, selectedRegion } = rootStore.analyse;\n    const { enableCategories: defaultEnableCategories } = rootStore.ontology;\n    const { start, precent } = displayBuffer;\n    const { atlasWidth, duration } = placement;\n    const visibleStartTime = start * duration;\n    const colWidth = atlasWidth / (precent * duration);\n    const enableCategories = cloneDeep(defaultEnableCategories);\n    if (selectedRegion || selectedTime) {\n      const { start: first = selectedTime!, end: second = selectedTime! } = selectedRegion || {};\n      const firstX = (first - visibleStartTime) * colWidth;\n      const secondX = (second - visibleStartTime) * colWidth;\n      Object.keys(enableCategories).forEach((key) => {\n        if (selectedRegion === null || (secondX - firstX) <= 5) {\n          enableCategories[key].second = false;\n        }\n        enableCategories[key].size = { start: first, end: second };\n        if ((firstX - 0 <= 5) || (atlasWidth - firstX <= 5)) {\n          enableCategories[key].first = false;\n        }\n        if ((secondX - 0 <= 5) || (atlasWidth - secondX <= 5)) {\n          enableCategories[key].second = false;\n        }\n      });\n      Object.values(this.shapeMap).forEach(({ startX, category, start: sStart }) => {\n        const enableCategory = enableCategories[category];\n        if (enableCategory) {\n          let nearLeft = Math.abs(firstX - startX) <= 5;\n          const nearRight = Math.abs(secondX - startX) <= 5;\n          // The selected region is cut off by shape\n          if (startX > firstX && startX < secondX && enableCategory.type === AnnotationType.SEGMENT) {\n            enableCategory.first = false;\n            nearLeft = true;\n          }\n          if (enableCategory.size) {\n            if (nearLeft) {\n              enableCategory.first = false;\n              if (sStart > enableCategory.size.start) enableCategory.size.start = sStart;\n            }\n            if (nearRight) {\n              enableCategory.second = false;\n              if (sStart < enableCategory.size.end) enableCategory.size.end = sStart;\n            }\n          }\n          if ((nearLeft && nearRight) || (!enableCategory.first && !enableCategory.second)) {\n            delete enableCategories[category];\n          }\n        }\n      });\n      rootStore.ontology.setCanAddTiers(enableCategories);\n    } else {\n      rootStore.ontology.setCanAddTiers({});\n    }\n  }\n\n  /**\n   * update shapes\n   */\n  updateShapes = (updatedInstances: {[id:string]: Instance | null}) => {\n    const { atlasWidth } = rootStore.analyse.placement;\n    if (atlasWidth > 0) {\n      const ids = Object.keys(updatedInstances);\n      if (ids.length > 0) {\n        Object.keys(updatedInstances).forEach((id) => {\n          const instance = updatedInstances[id];\n          if (instance) {\n            const { start, end, category, categoryIndex, text } = instance;\n            if (this.shapeMap[id]) {\n              this.updateShape(id, start, end, text);\n            } else {\n              this.createShape(id, category, categoryIndex, start, text, end);\n            }\n          } else {\n            this.removeShape(id);\n          }\n        });\n        rootStore.instance.setUpdatedInstances({});\n        if (rootStore.review.drawMode) {\n          this.getCanAddTiers();\n        }\n      }\n    }\n  };\n\n  /**\n   * update shape\n   * @param id\n   * @param startTime\n   * @param endTime\n   */\n  updateShape = (id: string, startTime: number, endTime?: number, text?: string) => {\n    const shape = this.shapeMap[id];\n    if (shape) {\n      if (shape.end === endTime && shape.start === startTime) {\n        if (text !== shape.text) {\n          shape.text = text;\n        } else {\n          shape.normalize();\n        }\n      } else {\n        shape.start = startTime;\n        if (endTime && shape.shapeType === AnnotationType.SEGMENT) {\n          shape.end = endTime;\n        }\n      }\n    }\n  };\n\n  /**\n   * remove shape\n   * @param id\n   */\n  removeShape = (id: string) => {\n    const shape = this.shapeMap[id];\n    if (shape) {\n      shape.destroy();\n      delete this.shapeMap[id];\n    }\n  };\n\n  initReviews = () => {\n    const { reviewsResult, customWarnings } = rootStore.review;\n    const keys = Object.keys(rootStore.instance.instances);\n    keys.forEach((key) => {\n      let review: Review | undefined;\n      const warning = customWarnings.find(({ id }) => id === key);\n      if (warning) {\n        review = {\n          instanceId: warning.id,\n          result: ReviewResult.REJECT\n        };\n      } else {\n        review = reviewsResult.find(({ instanceId }) => instanceId === key);\n      }\n      this.drawReview(key, review);\n    });\n  };\n\n  drawReview = (id: string, review?: Review) => {\n    if (id && this.shapeMap[id]) {\n      this.shapeMap[id].reviewResult = review ? review.result : undefined;\n    }\n  };\n\n  /**\n   * set selected shape\n   * @param shape\n   */\n  setSelectedShape(id?: string) {\n    if (this.selectedShape) {\n      this.selectedShape.selected = false;\n    }\n    const shape = this.shapeMap[id || ''];\n    if (shape) {\n      this.selectedShape = shape;\n      this.selectedShape.selected = true;\n    }\n    this.drawSameStartShape(shape?.start);\n  }\n\n  /**\n   * redraw shape control\n   * @param start start time\n   */\n  drawSameStartShape(start?: number) {\n    if (this.sameStartShapes.length > 0) {\n      this.sameStartShapes.forEach((s) => {\n        s.selectedStart = false;\n      });\n    }\n    if (start !== undefined) {\n      const sameStartShapes: Shape<unknown>[] = [];\n      this.shapes.forEach((s) => {\n        if (s.start === start && s.id !== this.selectedShape?.id) {\n          s.selectedStart = true;\n          sameStartShapes.push(s);\n        }\n      });\n      this.sameStartShapes = sameStartShapes;\n    }\n  }\n\n  /**\n   * create shape\n   * @param id\n   * @param className tier category\n   * @param index tier number\n   * @param startTime start time\n   * @param endTime end time\n   */\n  createShape = (id: string, className: string, index: number, startTime: number, text?: string, endTime?: number) => {\n    const category = rootStore.ontology.getCategory(className);\n    if (startTime !== undefined && category?.className) {\n      const shapeType = category.type;\n      const shape = ShapeFactory.getShape(shapeType as unknown as ShapeType, {\n        id,\n        app: this.props.app,\n        start: startTime,\n        end: endTime!,\n        text,\n        container: this.viewContainer,\n        shapeType,\n        category: className,\n        categoryIndex: index,\n        reviewResult: rootStore.review.updatedReviews[id]?.result,\n        selectShape: this.handleMouseDown,\n        moveShape: this.handleMoveShape,\n        positionListener: this.positionListener,\n        getPrevShape: this.getPrevShape,\n        getSameAndAdjoinTimeShapes: this.getSameAndAdjoinTimeShapes,\n        dblclick: this.props.focusForm,\n        handleControlHoverChange: this.setHoveredControl,\n      }) as Shape<unknown>;\n      this.shapeMap[shape.id] = shape;\n      if (rootStore.instance.selectedInstanceId === id) {\n        this.setSelectedShape(id);\n        this.selectTier(className, this.tierContainerMap[className]);\n      }\n    }\n  };\n\n  getPrevShape = (category: string, start: number) => {\n    const { prevInstance, nextInstance } = rootStore.instance.getAdjoinInstances(category, start);\n    const adjoinShapes: { prev: Shape<unknown> | undefined; next: Shape<unknown> | undefined; } = {\n      prev: undefined,\n      next: undefined,\n    };\n    if (prevInstance) {\n      adjoinShapes.prev = this.shapeMap[prevInstance.id];\n    }\n    if (nextInstance) {\n      adjoinShapes.next = this.shapeMap[nextInstance.id];\n    }\n    return adjoinShapes;\n  };\n\n  getSameAndAdjoinTimeShapes = (time: number) => {\n    const sameTimeShapes = this.shapes.filter((shape) => shape.start === time);\n    const adjoinTimeShapes = sameTimeShapes\n      .map(({ category, start }) => this.getPrevShape(category, start));\n    return {\n      sameTimeShapes,\n      adjoinTimeShapes,\n    };\n  };\n\n  /**\n   * map stage position to local posistion as a PIXI point\n   * @param point\n   */\n  mapStageToLocalPosition(point: Point) {\n    return this.props.app.stage.toLocal(point);\n  }\n\n  /**\n   * check if the point is in the stage\n   * @param point\n   */\n  isPointInStage(point: Point) {\n    const { x, y } = this.getStagePosition();\n    const { width, height } = this.getStageSize();\n    return point.x >= x && point.x <= x + width && point.y >= y && point.y <= y + height;\n  }\n\n  /**\n   * get stage size\n   */\n  getStageSize() {\n    return {\n      width: this.props.app.stage.width,\n      height: this.props.app.stage.height,\n    };\n  }\n\n  /**\n   * get stage position\n   */\n  getStagePosition() {\n    return {\n      x: this.props.app.stage.x,\n      y: this.props.app.stage.y,\n    };\n  }\n\n  render() {\n    const {\n      analyse: { placement, annotationPanelHeight },\n      ontology: { categories, selectedCategoryName },\n      instance: { selectedInstance, selectedNumber, categoryInstancesMap },\n    } = rootStore;\n    return (\n      <div\n        className=\"tier-container\"\n        style={{ height: `${annotationPanelHeight}px`, padding: `0 ${placement.margin}px` }}\n      >\n        <div\n          className=\"canvas-container\"\n          ref={this.container}\n          onMouseMove={this.handleMouseMove}\n          onMouseLeave={this.handleMouseLeave}\n          onContextMenu={(e) => e.preventDefault()}\n        />\n        <div className=\"tier-categories\" style={{ width: `${placement.margin}px` }}>\n          {categories.map(({ className, displayName, type }) => (\n            <div\n              className={cx('tier-categories-item', {\n                active: selectedCategoryName === className\n              })}\n              key={className}\n            >\n              <div className=\"item-category\">{displayName}</div>\n              <div className=\"item-info\">\n                <span className=\"item-info-number\">\n                  {selectedInstance?.category === className ? `${selectedNumber}/` : ''}\n                  {categoryInstancesMap[className]?.length || 0}\n                </span>\n                <span className=\"item-info-type\">{i18n.translate(type === AnnotationType.TIMING ? 'TIER_TIMING' : 'TIER_SEGMENT')}</span>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default observer(Tier);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}