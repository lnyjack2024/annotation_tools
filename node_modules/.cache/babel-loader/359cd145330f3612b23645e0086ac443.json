{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport createIntervalTree from '../vendor/intervalTree';\n/*:: type RenderCallback = (index: number, left: number, top: number) => void;*/\n// Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\nvar PositionCache = /*#__PURE__*/function () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n    // Tracks the height of each column\n    _defineProperty(this, \"_columnSizeMap\", {});\n    // Store tops and bottoms of each cell for fast intersection lookup.\n    _defineProperty(this, \"_intervalTree\", createIntervalTree());\n    // Maps cell index to x coordinates for quick lookup.\n    _defineProperty(this, \"_leftMap\", {});\n  }\n  return _createClass(PositionCache, [{\n    key: \"estimateTotalHeight\",\n    value: function estimateTotalHeight(cellCount /*: number*/, columnCount /*: number*/, defaultCellHeight /*: number*/) /*: number*/{\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    }\n\n    // Render all cells visible within the viewport range defined.\n  }, {\n    key: \"range\",\n    value: function range(scrollTop /*: number*/, clientHeight /*: number*/, renderCallback /*: RenderCallback*/) /*: void*/{\n      var _this = this;\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          top = _ref2[0],\n          _ = _ref2[1],\n          index = _ref2[2];\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(index /*: number*/, left /*: number*/, top /*: number*/, height /*: number*/) /*: void*/{\n      this._intervalTree.insert([top, top + height, index]);\n      this._leftMap[index] = left;\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: \"count\",\n    get: function get() /*: number*/{\n      return this._intervalTree.count;\n    }\n  }, {\n    key: \"shortestColumnSize\",\n    get: function get() /*: number*/{\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i /*: any*/];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n      return size;\n    }\n  }, {\n    key: \"tallestColumnSize\",\n    get: function get() /*: number*/{\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i /*: any*/];\n        size = Math.max(size, height);\n      }\n      return size;\n    }\n  }]);\n}();\nexport { PositionCache as default };","map":{"version":3,"names":["_slicedToArray","_classCallCheck","_createClass","_defineProperty","createIntervalTree","PositionCache","key","value","estimateTotalHeight","cellCount","columnCount","defaultCellHeight","unmeasuredCellCount","count","tallestColumnSize","Math","ceil","range","scrollTop","clientHeight","renderCallback","_this","_intervalTree","queryInterval","_ref","_ref2","top","_","index","_leftMap","setPosition","left","height","insert","columnSizeMap","_columnSizeMap","columnHeight","undefined","max","get","size","i","min","default"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/react-virtualized/dist/es/Masonry/PositionCache.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport createIntervalTree from '../vendor/intervalTree';\n/*:: type RenderCallback = (index: number, left: number, top: number) => void;*/\n// Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\nvar PositionCache = /*#__PURE__*/function () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n    // Tracks the height of each column\n    _defineProperty(this, \"_columnSizeMap\", {});\n    // Store tops and bottoms of each cell for fast intersection lookup.\n    _defineProperty(this, \"_intervalTree\", createIntervalTree());\n    // Maps cell index to x coordinates for quick lookup.\n    _defineProperty(this, \"_leftMap\", {});\n  }\n  return _createClass(PositionCache, [{\n    key: \"estimateTotalHeight\",\n    value: function estimateTotalHeight(cellCount /*: number*/, columnCount /*: number*/, defaultCellHeight /*: number*/) /*: number*/{\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    }\n\n    // Render all cells visible within the viewport range defined.\n  }, {\n    key: \"range\",\n    value: function range(scrollTop /*: number*/, clientHeight /*: number*/, renderCallback /*: RenderCallback*/) /*: void*/{\n      var _this = this;\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          top = _ref2[0],\n          _ = _ref2[1],\n          index = _ref2[2];\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(index /*: number*/, left /*: number*/, top /*: number*/, height /*: number*/) /*: void*/{\n      this._intervalTree.insert([top, top + height, index]);\n      this._leftMap[index] = left;\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: \"count\",\n    get: function get() /*: number*/{\n      return this._intervalTree.count;\n    }\n  }, {\n    key: \"shortestColumnSize\",\n    get: function get() /*: number*/{\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[(i /*: any*/)];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n      return size;\n    }\n  }, {\n    key: \"tallestColumnSize\",\n    get: function get() /*: number*/{\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[(i /*: any*/)];\n        size = Math.max(size, height);\n      }\n      return size;\n    }\n  }]);\n}();\nexport { PositionCache as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}