{"ast":null,"code":"import { Base64 } from 'js-base64';\nimport { cloneDeep } from 'lodash';\nimport * as toWav from 'audiobuffer-to-wav';\nimport { notification } from 'antd';\nimport { createSegment } from './segmentController';\nimport { defaultColor, translate, tagType, SegmentMode } from '../../constants';\nimport { store, lawToWav } from '../../../../utils';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nconst decode = str => {\n  try {\n    return JSON.parse(Base64.decode(str));\n  } catch (e) {\n    return null;\n  }\n};\nconst AUDIO_KEY_ATTRIBUTE = 'audio_key_attribute';\nconst AUDIO_ROLE_ATTRIBUTE = 'role';\nexport const handleLawToWav = (alawUrl, tail, index) => new Promise(async (resolve, reject) => {\n  try {\n    const buffer = await fetch(alawUrl).then(res => res.arrayBuffer());\n    const audioBuffer = lawToWav(buffer, tail);\n    const wav = toWav(audioBuffer);\n    const blob = new Blob([wav], {\n      type: 'audio/wav'\n    });\n    resolve(window.URL.createObjectURL(blob));\n  } catch (error) {\n    notification.error({\n      message: `${translate('AUDIO_ERROR')} ${index + 1}`\n    });\n    return false;\n  }\n});\nconst parseVideos = (audio, result) => new Promise(async (resolve, reject) => {\n  const {\n    audios = []\n  } = result || {};\n  const array = audio.split(',');\n  const videos = [];\n  const videoTypes = 'asf,avi,wmv,mkv,mp4,mov,rm,3gp,flv,mpg,rmvb,mpeg'.split(',');\n  for (let index = 0; index < array.length; index += 1) {\n    const src = array[index];\n    let video = src;\n    if (video) {\n      const tail = video.split('.').pop();\n      if ((tail === 'alaw' || tail === 'ulaw') && index === 0) {\n        video = await handleLawToWav(src, tail, index);\n      }\n      if (video) {\n        const savedAudio = audios[index];\n        videos.push({\n          url: video,\n          source: src,\n          loaded: tail !== 'alaw' && tail !== 'ulaw' ? true : index === 0,\n          ready: false,\n          zoom: 1,\n          speed: 1,\n          checked: !index,\n          type: videoTypes.indexOf(tail) < 0 ? 'none-video' : 'video',\n          ...(savedAudio && savedAudio.duration && {\n            duration: savedAudio.duration\n          }),\n          ...(savedAudio && savedAudio.attributes !== undefined && {\n            attributes: cloneDeep(savedAudio.attributes),\n            originAttributes: cloneDeep(savedAudio.attributes) // save original saved attributes\n          })\n        });\n      }\n    }\n  }\n  resolve(videos);\n});\nconst parseLableConfig = labelConfig => {\n  try {\n    const keys = [AUDIO_KEY_ATTRIBUTE, AUDIO_ROLE_ATTRIBUTE];\n    const obj = decode(labelConfig) || {\n      fields: []\n    };\n    obj.fields = obj.fields || [];\n    obj.fields.forEach(value => {\n      // if (value.type.toUpperCase() !== 'RADIO'\n      //     && value.type.toUpperCase() !== 'TEXTAREA'\n      //     && value.type.toUpperCase() !== 'TEXT') {\n      //   throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE_TYPE')}: ${value.type}`);\n      // }\n      if (value.name && keys.indexOf(value.name.toLowerCase()) >= 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ATTRIBUTE_NAME')}: ${value.name}`);\n      }\n      keys.push(value.name.toLowerCase());\n    });\n    return obj;\n  } catch (error) {\n    notification.error({\n      message: error.message\n    });\n    return {\n      fields: []\n    };\n  }\n};\nconst parseOntology = (ontology = []) => {\n  try {\n    const newOntology = new Map();\n    newOntology.set('none', defaultColor.darkGray);\n    ontology.forEach((value, index) => {\n      if (!newOntology.has(value.class_name)) newOntology.set(value.class_name, value.display_color);else throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ONTOLOGY')}: ${value.class_name}`);\n    });\n    return newOntology;\n  } catch (error) {\n    notification.error({\n      message: error.message\n    });\n    return new Map();\n  }\n};\nconst parseResults = (results, unitId, videos, ontology, lineConfig, segmentConfig, segmentMode) => {\n  // eslint-disable-next-line no-param-reassign\n  // console.log(store.getStorage('long-audio', 'review_from'));\n  const cache = store.getStorage('long-audio', unitId);\n  results = cache && cache.results ? cache.results : results;\n  if (!results || !results.length) results = [];\n  videos.forEach((video, index) => {\n    if (!results[index] || !results[index].length) {\n      if (segmentMode === SegmentMode.individual) {\n        results[index] = [];\n      } else {\n        results[index] = [createSegment(0, null, segmentConfig, lineConfig)];\n      }\n    }\n  });\n  return results;\n};\nconst parseKeyAttribute = config => {\n  const options = [];\n  if (config && typeof config === 'string') {\n    try {\n      // e.g. valid:a,b,c|invalid:x,y,z\n      const splits = config.split('|');\n      splits.forEach(s => {\n        const parts = s.split(':');\n        if (parts.length !== 2) {\n          throw new Error('invalid config');\n        }\n        const part1 = parts[0].toLowerCase();\n        const part2 = parts[1];\n        if (part1 === 'valid' || part1 === 'invalid') {\n          const values = part2.split(',').filter(p => p.trim().length > 0);\n          values.forEach(v => {\n            options.push({\n              value: v,\n              label: v,\n              isValid: part1 === 'valid'\n            });\n          });\n        } else {\n          throw new Error('invalid config');\n        }\n      });\n    } catch (e) {\n      notification.error({\n        message: `${translate('PAYLOAD_ERROR_INVALID_KEY_ATTRIBUTE')} ${config}`\n      });\n    }\n  }\n  return {\n    name: AUDIO_KEY_ATTRIBUTE,\n    label: `${translate('KEY_ATTRIBUTE_FILED_NAME')}`,\n    type: 'RADIO',\n    options\n  };\n};\nconst parseMinLength = length => {\n  const min = Number.parseFloat(length);\n  return Number.isNaN(min) ? 0.05 : min;\n};\nexport const parseSegments = (state, data) => {\n  const {\n    videoIndex,\n    segments\n  } = data;\n  const results = [...state.results];\n  results[videoIndex] = segments;\n  return {\n    ...state,\n    results\n  };\n};\nexport const parseTagGroup = data => {\n  try {\n    const tagGroup = decode(data) || [];\n    const shortcuts = {};\n    tagGroup.forEach(group => {\n      if (!group.tags) {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(group)}`);\n      }\n      if (group.type === tagType.tag) {\n        group.tags.forEach(tag => {\n          if (typeof tag.prefix !== 'string' || typeof tag.suffix !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else if (group.type === tagType.standalone) {\n        group.tags.forEach(tag => {\n          if (typeof tag.text !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_TYPE')} ${group.type}`);\n      }\n    });\n    return tagGroup;\n  } catch (error) {\n    notification.error({\n      message: error.message\n    });\n    return [];\n  }\n};\nexport const setWordTimestamps = (state, data) => ({\n  ...state,\n  wordTimestamps: data.wordTimestamps\n});\nexport const initPayload = (state, data) => new Promise(async (resolve, reject) => {\n  var _data$word_timestamps;\n  const videos = await parseVideos(data.audio, data.result);\n  const ontology = parseOntology(data.ontology);\n  const globalConfig = parseLableConfig(data.global_config);\n  if (globalConfig && Array.isArray(globalConfig.fields) && globalConfig.fields.length > 0) {\n    const defaultValues = {};\n    globalConfig.fields.forEach(f => {\n      if (f.defaultValue !== undefined) {\n        defaultValues[f.name] = f.defaultValue;\n      }\n    });\n    if (Object.keys(defaultValues).length > 0) {\n      // has default values\n      videos.forEach(video => {\n        video.defaultAttributes = cloneDeep(defaultValues); // save default attributes\n        if (!isAnnotationReadonly(data.mode)) {\n          // update attributes if not readonly\n          if (!video.attributes) {\n            video.attributes = {};\n          }\n          Object.keys(defaultValues).forEach(key => {\n            if (video.attributes[key] === undefined) {\n              video.attributes[key] = defaultValues[key];\n            }\n          });\n        }\n      });\n    }\n  }\n  const invalidAnnotatable = data.invalid_annotatable !== 'false' && data.invalid_annotatable !== false;\n  const annotateDisabled = !invalidAnnotatable && videos[state.currentVideo].attributes && videos[state.currentVideo].attributes.is_valid === 'invalid';\n  const segmentConfig = parseLableConfig(data.label_config_segment);\n  const lineConfig = parseLableConfig(data.label_config);\n  const issueTypes = data.issue_types ? data.issue_types.split(',') : ['issue type'];\n  const segmentMode = Object.values(SegmentMode).includes(data.segment_mode) ? data.segment_mode : SegmentMode.continuous;\n  const results = parseResults(data.review_from, data.unit_id, videos, ontology, lineConfig, segmentConfig, segmentMode);\n  const tagGroup = parseTagGroup(data.tag_group);\n  const jobId = data.job_id;\n  const autoTranscription = data.auto_transcription || false;\n  const autoTranscriptionLanguage = data.auto_transcription_language;\n  const autoTranscriptionEndpoint = data.auto_transcription_endpoint || 'ms';\n  const overlap = data.overlap === 'true' || data.overlap === true;\n  const keyAttribute = parseKeyAttribute(data.key_attribute);\n  const client = data.client || '';\n  const wordTimestampUrls = ((_data$word_timestamps = data.word_timestamps) === null || _data$word_timestamps === void 0 ? void 0 : _data$word_timestamps.split(',')) || [];\n  const minLength = parseMinLength(data.min_length);\n  let spaceLine = 0;\n  if (data.space_line) {\n    const num = Number(data.space_line);\n    if (!Number.isNaN(num) && num > 0) {\n      spaceLine = num;\n    }\n  }\n  const measurements = [];\n  if (data.measurement_box) {\n    data.measurement_box.split(',').forEach(item => {\n      const size = Number(item);\n      if (!Number.isNaN(size) && size > 0 && !measurements.includes(size)) {\n        measurements.push(size);\n      }\n    });\n  }\n  const segmentOverlap = data.segment_overlap !== 'false' && data.segment_overlap !== false;\n  let adjustmentStep = 0.1;\n  if (data.adjustment_step) {\n    const num = Number(data.adjustment_step);\n    if (!Number.isNaN(num) && num > 0) {\n      adjustmentStep = num;\n    }\n  }\n  const customCheck = (data.custom_check || '').split(',').map(i => i.trim()).filter(i => !!i);\n  const submitCheck = data.submit_check === 'true' || data.submit_check === true;\n  const disableSegment = data.disable_segment === 'true' || data.disable_segment === true;\n  console.log('init', data);\n  const newState = {\n    videos,\n    ontology,\n    results,\n    globalConfig,\n    invalidAnnotatable,\n    annotateDisabled,\n    segmentConfig,\n    lineConfig,\n    issueTypes,\n    unitId: data.unit_id,\n    toolMode: data.mode,\n    reviews: data._reviews,\n    tagGroup,\n    jobId,\n    autoTranscription,\n    autoTranscriptionLanguage,\n    autoTranscriptionEndpoint,\n    overlap,\n    keyAttribute,\n    client,\n    wordTimestampUrls,\n    minSegmentLength: minLength,\n    segmentMode,\n    currentSegment: segmentMode === SegmentMode.individual ? -1 : 0,\n    spaceLine,\n    measurements,\n    segmentOverlap,\n    adjustmentStep,\n    customCheck,\n    submitCheck,\n    disableSegment\n  };\n  resolve(newState);\n});\nexport const initPayloadState = (state, data) => ({\n  ...state,\n  ...data\n});\nexport const saveData = state => {\n  const data = {\n    results: state.results,\n    videos: state.videos\n  };\n  store.setStorage('long-audio', state.unitId, data);\n};\nexport const setVideoLoaded = (state, data) => {\n  const videos = [...state.videos];\n  videos.forEach((v, i) => {\n    v.url = data.videos[i].url;\n    v.loaded = true;\n  });\n  return {\n    ...state,\n    videos,\n    isLoadedAlaw: true\n  };\n};\nexport const setLoading = (state, data) => ({\n  ...state,\n  loading: data\n});\nexport const setVideoValid = (state, data) => {\n  const {\n    index\n  } = data;\n  const videos = [...state.videos];\n  videos[index] = {\n    ...state.videos[index]\n  };\n  videos[index].ready = true;\n  return {\n    ...state,\n    videos\n  };\n};\nexport const setVideoAttributes = (state, data) => {\n  const {\n    index,\n    attributes\n  } = data;\n  const {\n    videos\n  } = state;\n  videos[index].attributes = {\n    ...videos[index].attributes,\n    ...attributes\n  };\n  return {\n    ...state,\n    annotateDisabled: !state.invalidAnnotatable && videos[index].attributes && videos[index].attributes.is_valid === 'invalid'\n  };\n};","map":{"version":3,"names":["Base64","cloneDeep","toWav","notification","createSegment","defaultColor","translate","tagType","SegmentMode","store","lawToWav","isAnnotationReadonly","decode","str","JSON","parse","e","AUDIO_KEY_ATTRIBUTE","AUDIO_ROLE_ATTRIBUTE","handleLawToWav","alawUrl","tail","index","Promise","resolve","reject","buffer","fetch","then","res","arrayBuffer","audioBuffer","wav","blob","Blob","type","window","URL","createObjectURL","error","message","parseVideos","audio","result","audios","array","split","videos","videoTypes","length","src","video","pop","savedAudio","push","url","source","loaded","ready","zoom","speed","checked","indexOf","duration","attributes","undefined","originAttributes","parseLableConfig","labelConfig","keys","obj","fields","forEach","value","name","toLowerCase","Error","parseOntology","ontology","newOntology","Map","set","darkGray","has","class_name","display_color","parseResults","results","unitId","lineConfig","segmentConfig","segmentMode","cache","getStorage","individual","parseKeyAttribute","config","options","splits","s","parts","part1","part2","values","filter","p","trim","v","label","isValid","parseMinLength","min","Number","parseFloat","isNaN","parseSegments","state","data","videoIndex","segments","parseTagGroup","tagGroup","shortcuts","group","tags","stringify","tag","prefix","suffix","shortcut","standalone","text","setWordTimestamps","wordTimestamps","initPayload","_data$word_timestamps","globalConfig","global_config","Array","isArray","defaultValues","f","defaultValue","Object","defaultAttributes","mode","key","invalidAnnotatable","invalid_annotatable","annotateDisabled","currentVideo","is_valid","label_config_segment","label_config","issueTypes","issue_types","includes","segment_mode","continuous","review_from","unit_id","tag_group","jobId","job_id","autoTranscription","auto_transcription","autoTranscriptionLanguage","auto_transcription_language","autoTranscriptionEndpoint","auto_transcription_endpoint","overlap","keyAttribute","key_attribute","client","wordTimestampUrls","word_timestamps","minLength","min_length","spaceLine","space_line","num","measurements","measurement_box","item","size","segmentOverlap","segment_overlap","adjustmentStep","adjustment_step","customCheck","custom_check","map","i","submitCheck","submit_check","disableSegment","disable_segment","console","log","newState","toolMode","reviews","_reviews","minSegmentLength","currentSegment","initPayloadState","saveData","setStorage","setVideoLoaded","isLoadedAlaw","setLoading","loading","setVideoValid","setVideoAttributes"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/redux/reducer/connectController.js"],"sourcesContent":["import { Base64 } from 'js-base64';\nimport { cloneDeep } from 'lodash';\nimport * as toWav from 'audiobuffer-to-wav';\nimport { notification } from 'antd';\nimport { createSegment } from './segmentController';\nimport { defaultColor, translate, tagType, SegmentMode } from '../../constants';\nimport { store, lawToWav } from '../../../../utils';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\n\nconst decode = (str) => {\n  try { return JSON.parse(Base64.decode(str)); } catch (e) { return null; }\n};\n\nconst AUDIO_KEY_ATTRIBUTE = 'audio_key_attribute';\nconst AUDIO_ROLE_ATTRIBUTE = 'role';\n\nexport const handleLawToWav = (alawUrl, tail, index) => new Promise(async (resolve, reject) => {\n  try {\n    const buffer = await fetch(alawUrl).then((res) => res.arrayBuffer());\n    const audioBuffer = lawToWav(buffer, tail);\n    const wav = toWav(audioBuffer);\n    const blob = new Blob([wav], { type: 'audio/wav' });\n    resolve(window.URL.createObjectURL(blob));\n  } catch (error) {\n    notification.error({ message: `${translate('AUDIO_ERROR')} ${index + 1}` });\n    return false;\n  }\n});\n\nconst parseVideos = (audio, result) => new Promise(async (resolve, reject) => {\n  const { audios = [] } = result || {};\n  const array = audio.split(',');\n  const videos = [];\n  const videoTypes = 'asf,avi,wmv,mkv,mp4,mov,rm,3gp,flv,mpg,rmvb,mpeg'.split(',');\n  for (let index = 0; index < array.length; index += 1) {\n    const src = array[index];\n    let video = src;\n    if (video) {\n      const tail = video.split('.').pop();\n      if ((tail === 'alaw' || tail === 'ulaw') && index === 0) {\n        video = await handleLawToWav(src, tail, index);\n      }\n      if (video) {\n        const savedAudio = audios[index];\n        videos.push({\n          url: video,\n          source: src,\n          loaded: (tail !== 'alaw' && tail !== 'ulaw') ? true : index === 0,\n          ready: false,\n          zoom: 1,\n          speed: 1,\n          checked: !index,\n          type: videoTypes.indexOf(tail) < 0 ? 'none-video' : 'video',\n          ...savedAudio && savedAudio.duration && {\n            duration: savedAudio.duration\n          },\n          ...savedAudio && savedAudio.attributes !== undefined && {\n            attributes: cloneDeep(savedAudio.attributes),\n            originAttributes: cloneDeep(savedAudio.attributes), // save original saved attributes\n          },\n        });\n      }\n    }\n  }\n  resolve(videos);\n});\n\nconst parseLableConfig = (labelConfig) => {\n  try {\n    const keys = [AUDIO_KEY_ATTRIBUTE, AUDIO_ROLE_ATTRIBUTE];\n    const obj = decode(labelConfig) || { fields: [] };\n    obj.fields = obj.fields || [];\n    obj.fields.forEach((value) => {\n      // if (value.type.toUpperCase() !== 'RADIO'\n      //     && value.type.toUpperCase() !== 'TEXTAREA'\n      //     && value.type.toUpperCase() !== 'TEXT') {\n      //   throw new Error(`${translate('PAYLOAD_ERROR_INVALID_ATTRIBUTE_TYPE')}: ${value.type}`);\n      // }\n      if (value.name && keys.indexOf(value.name.toLowerCase()) >= 0) {\n        throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ATTRIBUTE_NAME')}: ${value.name}`);\n      }\n      keys.push(value.name.toLowerCase());\n    });\n    return obj;\n  } catch (error) {\n    notification.error({ message: error.message });\n    return { fields: [] };\n  }\n};\n\nconst parseOntology = (ontology = []) => {\n  try {\n    const newOntology = new Map();\n    newOntology.set('none', defaultColor.darkGray);\n    ontology.forEach((value, index) => {\n      if (!newOntology.has(value.class_name)) newOntology.set(value.class_name, value.display_color);\n      else throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATED_ONTOLOGY')}: ${value.class_name}`);\n    });\n    return newOntology;\n  } catch (error) {\n    notification.error({ message: error.message });\n    return new Map();\n  }\n};\n\nconst parseResults = (results, unitId, videos, ontology, lineConfig, segmentConfig, segmentMode) => {\n  // eslint-disable-next-line no-param-reassign\n  // console.log(store.getStorage('long-audio', 'review_from'));\n  const cache = store.getStorage('long-audio', unitId);\n  results = cache && cache.results ? cache.results : results;\n  if (!results || !results.length) results = [];\n  videos.forEach((video, index) => {\n    if (!results[index] || !results[index].length) {\n      if (segmentMode === SegmentMode.individual) {\n        results[index] = [];\n      } else {\n        results[index] = [createSegment(0, null, segmentConfig, lineConfig)];\n      }\n    }\n  });\n  return results;\n};\n\nconst parseKeyAttribute = (config) => {\n  const options = [];\n  if (config && typeof config === 'string') {\n    try {\n      // e.g. valid:a,b,c|invalid:x,y,z\n      const splits = config.split('|');\n      splits.forEach((s) => {\n        const parts = s.split(':');\n        if (parts.length !== 2) {\n          throw new Error('invalid config');\n        }\n        const part1 = parts[0].toLowerCase();\n        const part2 = parts[1];\n        if (part1 === 'valid' || part1 === 'invalid') {\n          const values = part2.split(',').filter((p) => p.trim().length > 0);\n          values.forEach((v) => {\n            options.push({\n              value: v,\n              label: v,\n              isValid: part1 === 'valid'\n            });\n          });\n        } else {\n          throw new Error('invalid config');\n        }\n      });\n    } catch (e) {\n      notification.error({ message: `${translate('PAYLOAD_ERROR_INVALID_KEY_ATTRIBUTE')} ${config}` });\n    }\n  }\n\n  return {\n    name: AUDIO_KEY_ATTRIBUTE,\n    label: `${translate('KEY_ATTRIBUTE_FILED_NAME')}`,\n    type: 'RADIO',\n    options,\n  };\n};\n\nconst parseMinLength = (length) => {\n  const min = Number.parseFloat(length);\n  return Number.isNaN(min) ? 0.05 : min;\n};\n\nexport const parseSegments = (state, data) => {\n  const { videoIndex, segments } = data;\n  const results = [...state.results];\n  results[videoIndex] = segments;\n  return {\n    ...state,\n    results,\n  };\n};\n\nexport const parseTagGroup = (data) => {\n  try {\n    const tagGroup = decode(data) || [];\n    const shortcuts = {};\n    tagGroup.forEach((group) => {\n      if (!group.tags) {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(group)}`);\n      }\n      if (group.type === tagType.tag) {\n        group.tags.forEach((tag) => {\n          if (typeof tag.prefix !== 'string' || typeof tag.suffix !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else if (group.type === tagType.standalone) {\n        group.tags.forEach((tag) => {\n          if (typeof tag.text !== 'string') {\n            throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_CONFIG')} ${JSON.stringify(tag)}`);\n          }\n          if (shortcuts[tag.shortcut]) {\n            throw new Error(`${translate('PAYLOAD_ERROR_DUPLICATE_SHORTCUT')} ${tag.shortcut}`);\n          } else {\n            shortcuts[tag.shortcut] = tag.shortcut;\n          }\n        });\n      } else {\n        throw new Error(`${translate('PAYLOAD_ERROR_INVALID_TAG_TYPE')} ${group.type}`);\n      }\n    });\n    return tagGroup;\n  } catch (error) {\n    notification.error({ message: error.message });\n    return [];\n  }\n};\n\nexport const setWordTimestamps = (state, data) => ({\n  ...state,\n  wordTimestamps: data.wordTimestamps,\n});\n\nexport const initPayload = (state, data) => new Promise(async (resolve, reject) => {\n  const videos = await parseVideos(data.audio, data.result);\n  const ontology = parseOntology(data.ontology);\n  const globalConfig = parseLableConfig(data.global_config);\n  if (globalConfig && Array.isArray(globalConfig.fields) && globalConfig.fields.length > 0) {\n    const defaultValues = {};\n    globalConfig.fields.forEach((f) => {\n      if (f.defaultValue !== undefined) {\n        defaultValues[f.name] = f.defaultValue;\n      }\n    });\n    if (Object.keys(defaultValues).length > 0) { // has default values\n      videos.forEach((video) => {\n        video.defaultAttributes = cloneDeep(defaultValues); // save default attributes\n        if (!isAnnotationReadonly(data.mode)) {\n          // update attributes if not readonly\n          if (!video.attributes) {\n            video.attributes = {};\n          }\n          Object.keys(defaultValues).forEach((key) => {\n            if (video.attributes[key] === undefined) {\n              video.attributes[key] = defaultValues[key];\n            }\n          });\n        }\n      });\n    }\n  }\n  const invalidAnnotatable = data.invalid_annotatable !== 'false' && data.invalid_annotatable !== false;\n  const annotateDisabled = !invalidAnnotatable && videos[state.currentVideo].attributes && videos[state.currentVideo].attributes.is_valid === 'invalid';\n  const segmentConfig = parseLableConfig(data.label_config_segment);\n  const lineConfig = parseLableConfig(data.label_config);\n  const issueTypes = data.issue_types ? data.issue_types.split(',') : ['issue type'];\n  const segmentMode = Object.values(SegmentMode).includes(data.segment_mode) ? data.segment_mode : SegmentMode.continuous;\n  const results = parseResults(data.review_from, data.unit_id, videos, ontology, lineConfig, segmentConfig, segmentMode);\n  const tagGroup = parseTagGroup(data.tag_group);\n  const jobId = data.job_id;\n  const autoTranscription = data.auto_transcription || false;\n  const autoTranscriptionLanguage = data.auto_transcription_language;\n  const autoTranscriptionEndpoint = data.auto_transcription_endpoint || 'ms';\n  const overlap = data.overlap === 'true' || data.overlap === true;\n  const keyAttribute = parseKeyAttribute(data.key_attribute);\n  const client = data.client || '';\n  const wordTimestampUrls = data.word_timestamps?.split(',') || [];\n  const minLength = parseMinLength(data.min_length);\n  let spaceLine = 0;\n  if (data.space_line) {\n    const num = Number(data.space_line);\n    if (!Number.isNaN(num) && num > 0) {\n      spaceLine = num;\n    }\n  }\n  const measurements = [];\n  if (data.measurement_box) {\n    data.measurement_box.split(',').forEach((item) => {\n      const size = Number(item);\n      if (!Number.isNaN(size) && size > 0 && !measurements.includes(size)) {\n        measurements.push(size);\n      }\n    });\n  }\n  const segmentOverlap = data.segment_overlap !== 'false' && data.segment_overlap !== false;\n  let adjustmentStep = 0.1;\n  if (data.adjustment_step) {\n    const num = Number(data.adjustment_step);\n    if (!Number.isNaN(num) && num > 0) {\n      adjustmentStep = num;\n    }\n  }\n  const customCheck = (data.custom_check || '').split(',').map((i) => i.trim()).filter((i) => !!i);\n  const submitCheck = data.submit_check === 'true' || data.submit_check === true;\n  const disableSegment = data.disable_segment === 'true' || data.disable_segment === true;\n  console.log('init', data);\n  const newState = {\n    videos,\n    ontology,\n    results,\n    globalConfig,\n    invalidAnnotatable,\n    annotateDisabled,\n    segmentConfig,\n    lineConfig,\n    issueTypes,\n    unitId: data.unit_id,\n    toolMode: data.mode,\n    reviews: data._reviews,\n    tagGroup,\n    jobId,\n    autoTranscription,\n    autoTranscriptionLanguage,\n    autoTranscriptionEndpoint,\n    overlap,\n    keyAttribute,\n    client,\n    wordTimestampUrls,\n    minSegmentLength: minLength,\n    segmentMode,\n    currentSegment: segmentMode === SegmentMode.individual ? -1 : 0,\n    spaceLine,\n    measurements,\n    segmentOverlap,\n    adjustmentStep,\n    customCheck,\n    submitCheck,\n    disableSegment,\n  };\n  resolve(newState);\n});\n\nexport const initPayloadState = (state, data) => ({\n  ...state,\n  ...data,\n});\n\nexport const saveData = (state) => {\n  const data = {\n    results: state.results,\n    videos: state.videos,\n  };\n  store.setStorage('long-audio', state.unitId, data);\n};\n\nexport const setVideoLoaded = (state, data) => {\n  const videos = [...state.videos];\n  videos.forEach((v, i) => {\n    v.url = data.videos[i].url;\n    v.loaded = true;\n  });\n  return {\n    ...state,\n    videos,\n    isLoadedAlaw: true,\n  };\n};\n\nexport const setLoading = (state, data) => ({\n  ...state,\n  loading: data,\n});\n\nexport const setVideoValid = (state, data) => {\n  const { index } = data;\n  const videos = [...state.videos];\n  videos[index] = { ...state.videos[index] };\n  videos[index].ready = true;\n  return {\n    ...state,\n    videos,\n  };\n};\n\nexport const setVideoAttributes = (state, data) => {\n  const { index, attributes } = data;\n  const { videos } = state;\n  videos[index].attributes = { ...videos[index].attributes, ...attributes };\n\n  return {\n    ...state,\n    annotateDisabled: !state.invalidAnnotatable && videos[index].attributes && videos[index].attributes.is_valid === 'invalid',\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}