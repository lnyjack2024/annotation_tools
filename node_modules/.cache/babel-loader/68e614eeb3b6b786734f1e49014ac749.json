{"ast":null,"code":"import { v4 as uuid } from 'uuid';\nimport { notification } from 'antd';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { translate, triggerForm, StyleConfigMode, getConfigColor, SegmentMode } from '../../constants';\nexport const createSegment = (start, end, segmentConfig, lineConfig) => {\n  start = Number.isNaN(parseFloat(start)) ? 0 : start;\n  end = Number.isNaN(parseFloat(end)) ? null : end;\n  const defaultValues = {};\n  segmentConfig.fields.forEach(value => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    id: uuid(),\n    start,\n    end,\n    qaChecked: undefined,\n    qaComment: '',\n    qaReason: null,\n    qaWorkerName: null,\n    attributes: defaultValues,\n    content: [createLine('none', lineConfig)]\n  };\n};\nexport const createLine = (role, lineConfig) => {\n  const defaultValues = {};\n  lineConfig.fields.forEach(value => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    role: role || 'none',\n    text: '',\n    attributes: defaultValues\n  };\n};\nexport const getVideoContainer = (state, data) => {\n  const {\n    videoContainer\n  } = data;\n  const {\n    wavesurfers\n  } = state;\n  wavesurfers.getVideoContainer(videoContainer);\n  return state;\n};\nexport const getAudioContainer = (state, data) => {\n  const {\n    waveform,\n    timeline,\n    audioContainer,\n    minimap\n  } = data;\n  const {\n    wavesurfers\n  } = state;\n  wavesurfers.getAudioContainer(waveform, timeline, audioContainer, minimap);\n  return state;\n};\nexport const segmentDeepClone = (results, videoIndex, segmentIndex) => {\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments[segmentIndex] = {\n    ...segments[segmentIndex]\n  };\n  const segment = segments[segmentIndex];\n  return segment;\n};\nconst lineDeepClone = (results, videoIndex, segmentIndex, lineIndex) => {\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const {\n    content\n  } = segment;\n  content[lineIndex] = {\n    ...content[lineIndex]\n  };\n  const line = content[lineIndex];\n  return line;\n};\nexport const setLineText = (state, data) => {\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    lineIndex,\n    text\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.text = text;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setLineRole = (state, data) => {\n  const {\n    lineIndex,\n    role,\n    actionType\n  } = data;\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment,\n    wavesurfers\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map(value => value.role);\n  if (roles.indexOf(role) >= 0) return state;\n  const prevRole = line.role;\n  line.role = role;\n  let timer = setTimeout(() => {\n    clearTimeout(timer);\n    timer = null;\n    wavesurfers.setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole, actionType);\n  }, 0);\n  return {\n    ...state,\n    results\n  };\n};\nexport const setLineCategory = (state, data) => {\n  const {\n    lineIndex,\n    key,\n    value\n  } = data;\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.attributes = {\n    ...line.attributes\n  };\n  const {\n    attributes\n  } = line;\n  attributes[key] = value;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setLineAttributes = (state, data) => {\n  var _styleConfig$groups;\n  const {\n    videoIndex,\n    segmentIndex,\n    lineIndex,\n    attributes\n  } = data;\n  const {\n    styleConfig,\n    wavesurfers\n  } = state;\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.attributes = {\n    ...attributes\n  };\n  if ((styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.mode) === StyleConfigMode.line && (styleConfig === null || styleConfig === void 0 ? void 0 : (_styleConfig$groups = styleConfig.groups) === null || _styleConfig$groups === void 0 ? void 0 : _styleConfig$groups.length) > 0) {\n    const color = getConfigColor(attributes, styleConfig.groups);\n    wavesurfers.setSegmentColor(videoIndex, segmentIndex, [lineIndex], color);\n  }\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentType = (state, data) => {\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    value\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.type = value;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentCategory = (state, data) => {\n  let {\n    videoIndex,\n    segmentIndex\n  } = data;\n  const {\n    key,\n    value\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.attributes = {\n    ...segment.attributes\n  };\n  const {\n    attributes\n  } = segment;\n  attributes[key] = value;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentAttributes = (state, data) => {\n  var _styleConfig$groups2;\n  const results = [...state.results];\n  const {\n    styleConfig,\n    wavesurfers\n  } = state;\n  const {\n    videoIndex,\n    segmentIndex,\n    attributes\n  } = data;\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.attributes = {\n    ...attributes\n  };\n  if ((styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.mode) === StyleConfigMode.segment && (styleConfig === null || styleConfig === void 0 ? void 0 : (_styleConfig$groups2 = styleConfig.groups) === null || _styleConfig$groups2 === void 0 ? void 0 : _styleConfig$groups2.length) > 0) {\n    const color = getConfigColor(attributes, styleConfig.groups);\n    const lines = Array(segment.content.length).fill(0).map((v, i) => i);\n    wavesurfers.setSegmentColor(videoIndex, segmentIndex, lines, color);\n  }\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentTimestamp = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let {\n    videoIndex,\n    segmentIndex,\n    start,\n    end\n  } = data;\n  const {\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  if (start !== undefined && start !== null) segment.start = start;\n  if (end !== undefined && end !== null) segment.end = end;\n  return {\n    ...state,\n    results\n  };\n};\nexport const moveSegmentInBatch = (state, data) => {\n  let {\n    videoIndex\n  } = data;\n  const {\n    min,\n    max,\n    step\n  } = data;\n  const {\n    currentVideo /* , results */\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.forEach((segment, i) => {\n    segments[i] = {\n      ...segments[i]\n    };\n    if (segments[i].start > min) {\n      segments[i].start = segments[i].start + step < min ? min : segments[i].start + step;\n    }\n    if (segments[i].end < max) {\n      segments[i].end = segments[i].end + step > max ? max : segments[i].end + step;\n    }\n  });\n  // segments[segmentIndex] = { ...segments[segmentIndex] };\n  // const segment = segments[segmentIndex];\n  // return segment;\n\n  // results[videoIndex] = results[videoIndex].map((segment) => {\n  //   const newSegment = segmentDeepClone()//deepClone(segment);\n  //   if (newSegment.start > min) {\n  //     newSegment.start = newSegment.start + step < min ? min : newSegment.start + step;\n  //   }\n  //   if (newSegment.end < max) {\n  //     newSegment.end = newSegment.end + step > max ? max : newSegment.end + step;\n  //   }\n  //   return newSegment;\n  // });\n  return {\n    ...state,\n    results\n  };\n};\nconst deepClone = item => JSON.parse(JSON.stringify(item));\nexport const mergeSegmentBackward = (state, data) => {\n  let {\n    videoIndex\n  } = data;\n  const {\n    segmentIndex\n  } = data;\n  const {\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = results[videoIndex][segmentIndex];\n  const prevSegment = results[videoIndex][segmentIndex - 1];\n  const prevRoles = [];\n  prevSegment.content.forEach(line => {\n    prevRoles.push(line.role);\n  });\n  nextSegment.content.forEach(line => {\n    if (prevRoles.indexOf(line.role) >= 0) {\n      const i = prevRoles.indexOf(line.role);\n      prevSegment.content[i].text += line.text;\n    } else if (line.role !== 'none') prevSegment.content.push(line);\n  });\n  results[videoIndex].splice(segmentIndex, 1);\n  return {\n    ...state,\n    results\n  };\n};\nexport const splitSegmentForward = (state, data) => {\n  const {\n    segmentIndex,\n    start,\n    end,\n    prevRules,\n    nextRules\n  } = data;\n  let {\n    videoIndex\n  } = data;\n  const {\n    segmentConfig,\n    lineConfig,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = createSegment(start, end, segmentConfig, lineConfig);\n  results[videoIndex].splice(segmentIndex + 1, 0, nextSegment);\n  if (prevRules && nextRules) {\n    const prevSegment = results[videoIndex][segmentIndex];\n    prevSegment.content = [];\n    nextSegment.content = [];\n    prevRules.forEach(rule => prevSegment.content.push(createLine(rule.role, lineConfig)));\n    nextRules.forEach(rule => nextSegment.content.push(createLine(rule.role, lineConfig)));\n  }\n  return {\n    ...state,\n    results\n  };\n};\nexport const pushLine = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let {\n    segmentIndex,\n    role,\n    lineIndex,\n    videoIndex,\n    deleteContent,\n    actionType\n  } = data;\n  const {\n    wavesurfers,\n    lineConfig,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const {\n    content,\n    start,\n    end\n  } = segment;\n  lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? content.length : lineIndex;\n  wavesurfers.insertLine({\n    role,\n    videoIndex,\n    segmentIndex,\n    lineIndex,\n    start,\n    end\n  });\n  data.lineIndex = lineIndex;\n  if (actionType !== 'history') wavesurfers.addHistory('pushLine', data);\n  content.push(deleteContent || createLine(role, lineConfig));\n  return {\n    ...state,\n    results\n  };\n};\nexport const deleteLine = (state, data) => {\n  const {\n    segmentIndex,\n    lineIndex,\n    actionType\n  } = data;\n  let {\n    videoIndex\n  } = data;\n  const {\n    wavesurfers,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const deleteContent = segment.content.splice(lineIndex, 1);\n  wavesurfers.deleteLine(data);\n  if (actionType !== 'history') wavesurfers.addHistory('deleteLine', {\n    ...data,\n    deleteContent: deleteContent[0]\n  });\n  return {\n    ...state,\n    results\n  };\n};\nexport const toppingLine = (state, data) => {\n  const {\n    segmentIndex,\n    lineIndex\n  } = data;\n  let {\n    videoIndex\n  } = data;\n  const {\n    wavesurfers,\n    currentVideo\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const line = JSON.parse(JSON.stringify(segment.content[lineIndex]));\n  segment.content.splice(lineIndex, 1);\n  segment.content.unshift(line);\n  wavesurfers.toppingLine(data);\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentQAState = (state, data) => {\n  const {\n    qaChecked\n  } = data;\n  let {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaChecked = qaChecked;\n  segment.qaWorkerName = state.workerName;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentQAComment = (state, data) => {\n  const {\n    qaComment\n  } = data;\n  let {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaComment = qaComment;\n  segment.qaWorkerName = state.workerName;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentQAReason = (state, data) => {\n  const {\n    qaReason\n  } = data;\n  let {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const {\n    currentVideo,\n    currentSegment\n  } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaReason = qaReason;\n  segment.qaWorkerName = state.workerName;\n  return {\n    ...state,\n    results\n  };\n};\nexport const removeSegment = (state, data) => {\n  const {\n    segmentIndex,\n    videoIndex\n  } = data;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.splice(segmentIndex, 1);\n  return {\n    ...state,\n    results\n  };\n};\nexport const appendSegment = (state, data) => {\n  const {\n    segment,\n    segmentIndex,\n    videoIndex: vIndex\n  } = data;\n  const {\n    segmentOverlap,\n    segmentMode\n  } = state;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  const currentIndex = results[videoIndex].findIndex(seg => seg.id === segment.id);\n  if (currentIndex >= 0) {\n    results[videoIndex].splice(currentIndex, 1, segment);\n  } else if (segmentIndex !== undefined) {\n    results[videoIndex].splice(segmentIndex, 0, segment);\n  } else {\n    results[videoIndex].push(segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  if (segmentMode === SegmentMode.continuous || segmentMode === SegmentMode.individual && !segmentOverlap) {\n    const prevSegment = results[videoIndex][index - 1];\n    const nextSegment = results[videoIndex][index + 1];\n    if (prevSegment && segment.start < prevSegment.end) {\n      segment.start = prevSegment.end;\n    }\n    if (nextSegment && segment.end > nextSegment.start) {\n      segment.end = nextSegment.start;\n    }\n  }\n  return {\n    ...state,\n    results,\n    currentSegment: index\n  };\n};\nexport const updateSegment = (state, data) => {\n  const {\n    segment,\n    videoIndex: vIndex\n  } = data;\n  const {\n    segmentOverlap,\n    segmentMode\n  } = state;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  const segmentIndex = results[videoIndex].findIndex(seg => seg.id === segment.id);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1, segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  if (segmentMode === SegmentMode.continuous || segmentMode === SegmentMode.individual && !segmentOverlap) {\n    const prevSegment = results[videoIndex][index - 1];\n    const nextSegment = results[videoIndex][index + 1];\n    if (prevSegment && segment.start < prevSegment.end) {\n      segment.start = prevSegment.end;\n    }\n    if (nextSegment && segment.end > nextSegment.start) {\n      segment.end = nextSegment.start;\n    }\n  }\n  return {\n    ...state,\n    results,\n    currentSegment: index\n  };\n};\nexport const deleteSegment = (state, data) => {\n  const {\n    segmentIndex,\n    videoIndex: vIndex\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1);\n  }\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegments = (state, data) => {\n  const {\n    videoIndex,\n    segments = []\n  } = data;\n  const results = deepClone(state.results);\n  results[videoIndex] = segments;\n  return {\n    ...state,\n    results\n  };\n};\nexport const updateLineRole = (state, data) => {\n  const {\n    videoIndex: vIndex,\n    segmentIndex: sIndex,\n    lineIndex,\n    role\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n  const results = deepClone(state.results);\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map(value => value.role);\n  if (roles.indexOf(role) >= 0) {\n    return state;\n  }\n  line.role = role;\n  return {\n    ...state,\n    results\n  };\n};\nexport const setSegmentStartEnd = (state, data) => {\n  const {\n    videoIndex: vIndex,\n    segmentIndex: sIndex,\n    start,\n    end\n  } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n  const results = deepClone(state.results);\n  const segment = results[videoIndex][segmentIndex];\n  segment.start = start;\n  segment.end = end;\n  state.wavesurfers.setSegmentStartEnd(videoIndex, segmentIndex, start, end);\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return {\n    ...state,\n    results,\n    currentSegment: index\n  };\n};\nexport const verifyCurrentForm = (state, action) => {\n  if (isAnnotationReadonly(state.toolMode)) return true;\n  const {\n    results,\n    segmentConfig,\n    currentVideo,\n    currentSegment,\n    keyAttribute,\n    lineConfig\n  } = state;\n  const currentValues = results[currentVideo][currentSegment];\n  if (currentSegment < 0) return true;\n  const updatedSegment = triggerForm({\n    ...segmentConfig,\n    fields: [...segmentConfig.fields, ...keyAttribute.options]\n  }, currentValues.attributes);\n  // add segment default values\n  currentValues.attributes = updatedSegment.updatedValues;\n  const segmentFields = updatedSegment.updatedFields;\n  const segmentFieldIndex = segmentFields.findIndex(v => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n  const lineIndex = [];\n  let lineFields = [];\n  for (let i = 0; i < ((_currentValues$conten = currentValues.content) === null || _currentValues$conten === void 0 ? void 0 : _currentValues$conten.length); i += 1) {\n    var _currentValues$conten;\n    const line = currentValues.content[i];\n    const updatedLine = triggerForm(lineConfig, line.attributes);\n    // add line default values\n    line.attributes = updatedLine.updatedValues;\n    lineFields = updatedLine.updatedFields;\n    const index = lineFields.findIndex(v => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n    if (index >= 0) lineIndex.push(index);\n  }\n  if (segmentFieldIndex < 0 && lineIndex.length === 0) return {\n    result: true,\n    data: currentValues\n  };\n  const err = `Item ${currentVideo + 1}-Segment ${currentSegment + 1}: ${translate('DATA_ERROR_REQUIRED')} ${(segmentFields[segmentFieldIndex] || lineFields[lineIndex[0]]).label}`;\n  if (action !== 'nohint') {\n    notification.error({\n      message: err\n    });\n  }\n  return {\n    result: false,\n    error: err\n  };\n};\nexport const isInput = () => document.activeElement.tagName === 'INPUT' && (document.activeElement.type === 'text' || document.activeElement.type === 'number') || document.activeElement.tagName === 'TEXTAREA';","map":{"version":3,"names":["v4","uuid","notification","isAnnotationReadonly","translate","triggerForm","StyleConfigMode","getConfigColor","SegmentMode","createSegment","start","end","segmentConfig","lineConfig","Number","isNaN","parseFloat","defaultValues","fields","forEach","value","defaultValue","name","id","qaChecked","undefined","qaComment","qaReason","qaWorkerName","attributes","content","createLine","role","text","getVideoContainer","state","data","videoContainer","wavesurfers","getAudioContainer","waveform","timeline","audioContainer","minimap","segmentDeepClone","results","videoIndex","segmentIndex","segments","segment","lineDeepClone","lineIndex","line","setLineText","currentVideo","currentSegment","parseInt","setLineRole","actionType","roles","map","indexOf","prevRole","timer","setTimeout","clearTimeout","setLineColor","setLineCategory","key","setLineAttributes","_styleConfig$groups","styleConfig","mode","groups","length","color","setSegmentColor","setSegmentType","type","setSegmentCategory","setSegmentAttributes","_styleConfig$groups2","lines","Array","fill","v","i","setSegmentTimestamp","moveSegmentInBatch","min","max","step","deepClone","item","JSON","parse","stringify","mergeSegmentBackward","nextSegment","prevSegment","prevRoles","push","splice","splitSegmentForward","prevRules","nextRules","rule","pushLine","deleteContent","insertLine","addHistory","deleteLine","toppingLine","unshift","setSegmentQAState","workerName","setSegmentQAComment","setSegmentQAReason","removeSegment","appendSegment","vIndex","segmentOverlap","segmentMode","currentIndex","findIndex","seg","sort","a","b","index","continuous","individual","updateSegment","deleteSegment","setSegments","updateLineRole","sIndex","setSegmentStartEnd","verifyCurrentForm","action","toolMode","keyAttribute","currentValues","updatedSegment","options","updatedValues","segmentFields","updatedFields","segmentFieldIndex","required","readonly","visible","lineFields","_currentValues$conten","updatedLine","result","err","label","error","message","isInput","document","activeElement","tagName"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/long-audio/redux/reducer/segmentController.js"],"sourcesContent":["import { v4 as uuid } from 'uuid';\nimport { notification } from 'antd';\nimport { isAnnotationReadonly } from '../../../../utils/tool-mode';\nimport { translate, triggerForm, StyleConfigMode, getConfigColor, SegmentMode } from '../../constants';\n\nexport const createSegment = (start, end, segmentConfig, lineConfig) => {\n  start = Number.isNaN(parseFloat(start)) ? 0 : start;\n  end = Number.isNaN(parseFloat(end)) ? null : end;\n  const defaultValues = {};\n  segmentConfig.fields.forEach((value) => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    id: uuid(),\n    start,\n    end,\n    qaChecked: undefined,\n    qaComment: '',\n    qaReason: null,\n    qaWorkerName: null,\n    attributes: defaultValues,\n    content: [createLine('none', lineConfig)],\n  };\n};\n\nexport const createLine = (role, lineConfig) => {\n  const defaultValues = {};\n  lineConfig.fields.forEach((value) => {\n    if (value.defaultValue) defaultValues[value.name] = value.defaultValue;\n  });\n  return {\n    role: role || 'none',\n    text: '',\n    attributes: defaultValues,\n  };\n};\n\nexport const getVideoContainer = (state, data) => {\n  const { videoContainer } = data;\n  const { wavesurfers } = state;\n  wavesurfers.getVideoContainer(videoContainer);\n  return state;\n};\n\nexport const getAudioContainer = (state, data) => {\n  const { waveform, timeline, audioContainer, minimap } = data;\n  const { wavesurfers } = state;\n  wavesurfers.getAudioContainer(waveform, timeline, audioContainer, minimap);\n  return state;\n};\n\nexport const segmentDeepClone = (results, videoIndex, segmentIndex) => {\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments[segmentIndex] = { ...segments[segmentIndex] };\n  const segment = segments[segmentIndex];\n  return segment;\n};\n\nconst lineDeepClone = (results, videoIndex, segmentIndex, lineIndex) => {\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const { content } = segment;\n  content[lineIndex] = { ...content[lineIndex] };\n  const line = content[lineIndex];\n  return line;\n};\n\nexport const setLineText = (state, data) => {\n  let { videoIndex, segmentIndex } = data;\n  const { lineIndex, text } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.text = text;\n  return { ...state, results };\n};\n\nexport const setLineRole = (state, data) => {\n  const { lineIndex, role, actionType } = data;\n  let { videoIndex, segmentIndex } = data;\n  const { currentVideo, currentSegment, wavesurfers } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map((value) => value.role);\n  if (roles.indexOf(role) >= 0) return state;\n  const prevRole = line.role;\n  line.role = role;\n  let timer = setTimeout(() => {\n    clearTimeout(timer);\n    timer = null;\n    wavesurfers.setLineColor(videoIndex, segmentIndex, lineIndex, role, prevRole, actionType);\n  }, 0);\n  return { ...state, results };\n};\n\nexport const setLineCategory = (state, data) => {\n  const { lineIndex, key, value } = data;\n  let { videoIndex, segmentIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.attributes = { ...line.attributes };\n  const { attributes } = line;\n  attributes[key] = value;\n  return { ...state, results };\n};\n\nexport const setLineAttributes = (state, data) => {\n  const { videoIndex, segmentIndex, lineIndex, attributes } = data;\n  const { styleConfig, wavesurfers } = state;\n  const results = [...state.results];\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  line.attributes = { ...attributes };\n  if (styleConfig?.mode === StyleConfigMode.line && styleConfig?.groups?.length > 0) {\n    const color = getConfigColor(attributes, styleConfig.groups);\n    wavesurfers.setSegmentColor(videoIndex, segmentIndex, [lineIndex], color);\n  }\n  return { ...state, results };\n};\n\nexport const setSegmentType = (state, data) => {\n  let { videoIndex, segmentIndex } = data;\n  const { value } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  // const segmentIndex\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.type = value;\n  return { ...state, results };\n};\n\nexport const setSegmentCategory = (state, data) => {\n  let { videoIndex, segmentIndex } = data;\n  const { key, value } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.attributes = { ...segment.attributes };\n  const { attributes } = segment;\n  attributes[key] = value;\n  return { ...state, results };\n};\n\nexport const setSegmentAttributes = (state, data) => {\n  const results = [...state.results];\n  const { styleConfig, wavesurfers } = state;\n  const { videoIndex, segmentIndex, attributes } = data;\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.attributes = { ...attributes };\n  if (styleConfig?.mode === StyleConfigMode.segment && styleConfig?.groups?.length > 0) {\n    const color = getConfigColor(attributes, styleConfig.groups);\n    const lines = Array(segment.content.length).fill(0).map((v, i) => i);\n    wavesurfers.setSegmentColor(videoIndex, segmentIndex, lines, color);\n  }\n  return { ...state, results };\n};\n\nexport const setSegmentTimestamp = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let { videoIndex, segmentIndex, start, end } = data;\n  const { currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  if (start !== undefined && start !== null) segment.start = start;\n  if (end !== undefined && end !== null) segment.end = end;\n  return { ...state, results };\n};\n\nexport const moveSegmentInBatch = (state, data) => {\n  let { videoIndex } = data;\n  const { min, max, step } = data;\n  const { currentVideo/* , results */ } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.forEach((segment, i) => {\n    segments[i] = { ...segments[i] };\n    if (segments[i].start > min) {\n      segments[i].start = segments[i].start + step < min ? min : segments[i].start + step;\n    }\n    if (segments[i].end < max) {\n      segments[i].end = segments[i].end + step > max ? max : segments[i].end + step;\n    }\n  });\n  // segments[segmentIndex] = { ...segments[segmentIndex] };\n  // const segment = segments[segmentIndex];\n  // return segment;\n\n  // results[videoIndex] = results[videoIndex].map((segment) => {\n  //   const newSegment = segmentDeepClone()//deepClone(segment);\n  //   if (newSegment.start > min) {\n  //     newSegment.start = newSegment.start + step < min ? min : newSegment.start + step;\n  //   }\n  //   if (newSegment.end < max) {\n  //     newSegment.end = newSegment.end + step > max ? max : newSegment.end + step;\n  //   }\n  //   return newSegment;\n  // });\n  return { ...state, results };\n};\n\nconst deepClone = (item) => JSON.parse(JSON.stringify(item));\n\nexport const mergeSegmentBackward = (state, data) => {\n  let { videoIndex } = data;\n  const { segmentIndex } = data;\n  const { currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = results[videoIndex][segmentIndex];\n  const prevSegment = results[videoIndex][segmentIndex - 1];\n  const prevRoles = [];\n  prevSegment.content.forEach((line) => {\n    prevRoles.push(line.role);\n  });\n  nextSegment.content.forEach((line) => {\n    if (prevRoles.indexOf(line.role) >= 0) {\n      const i = prevRoles.indexOf(line.role);\n      prevSegment.content[i].text += line.text;\n    } else if (line.role !== 'none') prevSegment.content.push(line);\n  });\n  results[videoIndex].splice(segmentIndex, 1);\n  return { ...state, results };\n};\n\nexport const splitSegmentForward = (state, data) => {\n  const { segmentIndex, start, end, prevRules, nextRules } = data;\n  let { videoIndex } = data;\n  const { segmentConfig, lineConfig, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  results[videoIndex] = deepClone(results[videoIndex]);\n  const nextSegment = createSegment(start, end, segmentConfig, lineConfig);\n  results[videoIndex].splice(segmentIndex + 1, 0, nextSegment);\n  if (prevRules && nextRules) {\n    const prevSegment = results[videoIndex][segmentIndex];\n    prevSegment.content = [];\n    nextSegment.content = [];\n    prevRules.forEach((rule) => prevSegment.content.push(createLine(rule.role, lineConfig)));\n    nextRules.forEach((rule) => nextSegment.content.push(createLine(rule.role, lineConfig)));\n  }\n  return { ...state, results };\n};\n\nexport const pushLine = (state, data) => {\n  // eslint-disable-next-line prefer-const\n  let { segmentIndex, role, lineIndex, videoIndex, deleteContent, actionType } = data;\n  const { wavesurfers, lineConfig, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const { content, start, end } = segment;\n  lineIndex = Number.isNaN(parseInt(lineIndex, 10)) ? content.length : lineIndex;\n  wavesurfers.insertLine({ role, videoIndex, segmentIndex, lineIndex, start, end });\n  data.lineIndex = lineIndex;\n  if (actionType !== 'history') wavesurfers.addHistory('pushLine', data);\n  content.push(deleteContent || createLine(role, lineConfig));\n  return { ...state, results };\n};\n\nexport const deleteLine = (state, data) => {\n  const { segmentIndex, lineIndex, actionType } = data;\n  let { videoIndex } = data;\n  const { wavesurfers, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const deleteContent = segment.content.splice(lineIndex, 1);\n  wavesurfers.deleteLine(data);\n  if (actionType !== 'history') wavesurfers.addHistory('deleteLine', { ...data, deleteContent: deleteContent[0] });\n  return {\n    ...state,\n    results,\n  };\n};\n\nexport const toppingLine = (state, data) => {\n  const { segmentIndex, lineIndex } = data;\n  let { videoIndex } = data;\n  const { wavesurfers, currentVideo } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.content = [...segment.content];\n  const line = JSON.parse(JSON.stringify(segment.content[lineIndex]));\n  segment.content.splice(lineIndex, 1);\n  segment.content.unshift(line);\n  wavesurfers.toppingLine(data);\n\n  return { ...state, results };\n};\n\nexport const setSegmentQAState = (state, data) => {\n  const { qaChecked } = data;\n  let { segmentIndex, videoIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaChecked = qaChecked;\n  segment.qaWorkerName = state.workerName;\n  return { ...state, results };\n};\n\nexport const setSegmentQAComment = (state, data) => {\n  const { qaComment } = data;\n  let { segmentIndex, videoIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaComment = qaComment;\n  segment.qaWorkerName = state.workerName;\n  return { ...state, results };\n};\n\nexport const setSegmentQAReason = (state, data) => {\n  const { qaReason } = data;\n  let { segmentIndex, videoIndex } = data;\n  const { currentVideo, currentSegment } = state;\n  videoIndex = Number.isNaN(parseInt(videoIndex, 10)) ? currentVideo : videoIndex;\n  segmentIndex = Number.isNaN(parseInt(segmentIndex, 10)) ? currentSegment : segmentIndex;\n\n  const results = [...state.results];\n  const segment = segmentDeepClone(results, videoIndex, segmentIndex);\n  segment.qaReason = qaReason;\n  segment.qaWorkerName = state.workerName;\n  return { ...state, results };\n};\n\nexport const removeSegment = (state, data) => {\n  const { segmentIndex, videoIndex } = data;\n  const results = [...state.results];\n  results[videoIndex] = [...results[videoIndex]];\n  const segments = results[videoIndex];\n  segments.splice(segmentIndex, 1);\n  return { ...state, results };\n};\n\nexport const appendSegment = (state, data) => {\n  const { segment, segmentIndex, videoIndex: vIndex } = data;\n  const { segmentOverlap, segmentMode } = state;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  const currentIndex = results[videoIndex].findIndex((seg) => seg.id === segment.id);\n  if (currentIndex >= 0) {\n    results[videoIndex].splice(currentIndex, 1, segment);\n  } else if (segmentIndex !== undefined) {\n    results[videoIndex].splice(segmentIndex, 0, segment);\n  } else {\n    results[videoIndex].push(segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  if (segmentMode === SegmentMode.continuous || (segmentMode === SegmentMode.individual && !segmentOverlap)) {\n    const prevSegment = results[videoIndex][index - 1];\n    const nextSegment = results[videoIndex][index + 1];\n    if (prevSegment && segment.start < prevSegment.end) {\n      segment.start = prevSegment.end;\n    }\n    if (nextSegment && segment.end > nextSegment.start) {\n      segment.end = nextSegment.start;\n    }\n  }\n  return { ...state, results, currentSegment: index };\n};\n\nexport const updateSegment = (state, data) => {\n  const { segment, videoIndex: vIndex } = data;\n  const { segmentOverlap, segmentMode } = state;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  const segmentIndex = results[videoIndex].findIndex((seg) => seg.id === segment.id);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1, segment);\n  }\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  if (segmentMode === SegmentMode.continuous || (segmentMode === SegmentMode.individual && !segmentOverlap)) {\n    const prevSegment = results[videoIndex][index - 1];\n    const nextSegment = results[videoIndex][index + 1];\n    if (prevSegment && segment.start < prevSegment.end) {\n      segment.start = prevSegment.end;\n    }\n    if (nextSegment && segment.end > nextSegment.start) {\n      segment.end = nextSegment.start;\n    }\n  }\n  return { ...state, results, currentSegment: index };\n};\n\nexport const deleteSegment = (state, data) => {\n  const { segmentIndex, videoIndex: vIndex } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const results = deepClone(state.results);\n  if (segmentIndex >= 0) {\n    results[videoIndex].splice(segmentIndex, 1);\n  }\n  return { ...state, results };\n};\n\nexport const setSegments = (state, data) => {\n  const { videoIndex, segments = [] } = data;\n  const results = deepClone(state.results);\n  results[videoIndex] = segments;\n  return { ...state, results };\n};\n\nexport const updateLineRole = (state, data) => {\n  const { videoIndex: vIndex, segmentIndex: sIndex, lineIndex, role } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n\n  const results = deepClone(state.results);\n  const line = lineDeepClone(results, videoIndex, segmentIndex, lineIndex);\n  const segment = results[videoIndex][segmentIndex];\n  const roles = segment.content.map((value) => value.role);\n  if (roles.indexOf(role) >= 0) {\n    return state;\n  }\n  line.role = role;\n  return { ...state, results };\n};\n\nexport const setSegmentStartEnd = (state, data) => {\n  const { videoIndex: vIndex, segmentIndex: sIndex, start, end } = data;\n  const videoIndex = Number.isNaN(parseInt(vIndex, 10)) ? state.currentVideo : vIndex;\n  const segmentIndex = Number.isNaN(parseInt(sIndex, 10)) ? state.currentSegment : sIndex;\n  const results = deepClone(state.results);\n  const segment = results[videoIndex][segmentIndex];\n  segment.start = start;\n  segment.end = end;\n  state.wavesurfers.setSegmentStartEnd(videoIndex, segmentIndex, start, end);\n  results[videoIndex].sort((a, b) => a.start - b.start);\n  const index = results[videoIndex].indexOf(segment);\n  return { ...state, results, currentSegment: index };\n};\n\nexport const verifyCurrentForm = (state, action) => {\n  if (isAnnotationReadonly(state.toolMode)) return true;\n  const { results, segmentConfig, currentVideo, currentSegment, keyAttribute, lineConfig } = state;\n  const currentValues = results[currentVideo][currentSegment];\n  if (currentSegment < 0) return true;\n  const updatedSegment = triggerForm({\n    ...segmentConfig,\n    fields: [...segmentConfig.fields, ...keyAttribute.options]\n  }, currentValues.attributes);\n  // add segment default values\n  currentValues.attributes = updatedSegment.updatedValues;\n  const segmentFields = updatedSegment.updatedFields;\n  const segmentFieldIndex = segmentFields.findIndex((v) => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n\n  const lineIndex = [];\n  let lineFields = [];\n  for (let i = 0; i < currentValues.content?.length; i += 1) {\n    const line = currentValues.content[i];\n    const updatedLine = triggerForm(lineConfig, line.attributes);\n    // add line default values\n    line.attributes = updatedLine.updatedValues;\n    lineFields = updatedLine.updatedFields;\n    const index = lineFields.findIndex((v) => v.required === true && v.readonly !== true && v.visible !== false && (v.defaultValue === undefined || v.defaultValue === ''));\n    if (index >= 0) lineIndex.push(index);\n  }\n  if (segmentFieldIndex < 0 && lineIndex.length === 0) return { result: true, data: currentValues };\n  const err = `Item ${currentVideo + 1}-Segment ${currentSegment + 1}: ${translate('DATA_ERROR_REQUIRED')} ${(segmentFields[segmentFieldIndex] || lineFields[lineIndex[0]]).label}`;\n  if (action !== 'nohint') {\n    notification.error({ message: err });\n  }\n  return { result: false, error: err };\n};\n\nexport const isInput = () => (document.activeElement.tagName === 'INPUT' && (document.activeElement.type === 'text' || document.activeElement.type === 'number')) || document.activeElement.tagName === 'TEXTAREA';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}