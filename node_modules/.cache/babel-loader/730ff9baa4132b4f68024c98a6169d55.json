{"ast":null,"code":"/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image metadata handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise, DataView, Uint8Array, ArrayBuffer */\n\n;\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var global = loadImage.global;\n  var originalTransform = loadImage.transform;\n  var blobSlice = global.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n  var bufferSlice = global.ArrayBuffer && ArrayBuffer.prototype.slice || function (begin, end) {\n    // Polyfill for IE10, which does not support ArrayBuffer.slice\n    // eslint-disable-next-line no-param-reassign\n    end = end || this.byteLength - begin;\n    var arr1 = new Uint8Array(this, begin, end);\n    var arr2 = new Uint8Array(end);\n    arr2.set(arr1);\n    return arr2.buffer;\n  };\n  var metaDataParsers = {\n    jpeg: {\n      0xffe1: [],\n      // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  };\n\n  /**\n   * Parses image metadata and calls the callback with an object argument\n   * with the following property:\n   * - imageHead: The complete image head as ArrayBuffer\n   * The options argument accepts an object and supports the following\n   * properties:\n   * - maxMetaDataSize: Defines the maximum number of bytes to parse.\n   * - disableImageHead: Disables creating the imageHead property.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} [callback] Callback function\n   * @param {object} [options] Parsing options\n   * @param {object} [data] Result data object\n   * @returns {Promise<object>|undefined} Returns Promise if no callback given.\n   */\n  function parseMetaData(file, callback, options, data) {\n    var that = this;\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {undefined} Undefined\n     */\n    function executor(resolve, reject) {\n      if (!(global.DataView && blobSlice && file && file.size >= 12 && file.type === 'image/jpeg')) {\n        // Nothing to parse\n        return resolve(data);\n      }\n      // 256 KiB should contain all EXIF/ICC/IPTC segments:\n      var maxMetaDataSize = options.maxMetaDataSize || 262144;\n      if (!loadImage.readFile(blobSlice.call(file, 0, maxMetaDataSize), function (buffer) {\n        // Note on endianness:\n        // Since the marker and length bytes in JPEG files are always\n        // stored in big endian order, we can leave the endian parameter\n        // of the DataView methods undefined, defaulting to big endian.\n        var dataView = new DataView(buffer);\n        // Check for the JPEG marker (0xffd8):\n        if (dataView.getUint16(0) !== 0xffd8) {\n          return reject(new Error('Invalid JPEG file: Missing JPEG marker.'));\n        }\n        var offset = 2;\n        var maxOffset = dataView.byteLength - 4;\n        var headLength = offset;\n        var markerBytes;\n        var markerLength;\n        var parsers;\n        var i;\n        while (offset < maxOffset) {\n          markerBytes = dataView.getUint16(offset);\n          // Search for APPn (0xffeN) and COM (0xfffe) markers,\n          // which contain application-specific metadata like\n          // Exif, ICC and IPTC data and text comments:\n          if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n            // The marker bytes (2) are always followed by\n            // the length bytes (2), indicating the length of the\n            // marker segment, which includes the length bytes,\n            // but not the marker bytes, so we add 2:\n            markerLength = dataView.getUint16(offset + 2) + 2;\n            if (offset + markerLength > dataView.byteLength) {\n              // eslint-disable-next-line no-console\n              console.log('Invalid JPEG metadata: Invalid segment size.');\n              break;\n            }\n            parsers = metaDataParsers.jpeg[markerBytes];\n            if (parsers && !options.disableMetaDataParsers) {\n              for (i = 0; i < parsers.length; i += 1) {\n                parsers[i].call(that, dataView, offset, markerLength, data, options);\n              }\n            }\n            offset += markerLength;\n            headLength = offset;\n          } else {\n            // Not an APPn or COM marker, probably safe to\n            // assume that this is the end of the metadata\n            break;\n          }\n        }\n        // Meta length must be longer than JPEG marker (2)\n        // plus APPn marker (2), followed by length bytes (2):\n        if (!options.disableImageHead && headLength > 6) {\n          data.imageHead = bufferSlice.call(buffer, 0, headLength);\n        }\n        resolve(data);\n      }, reject, 'readAsArrayBuffer')) {\n        // No support for the FileReader interface, nothing to parse\n        resolve(data);\n      }\n    }\n    options = options || {}; // eslint-disable-line no-param-reassign\n    if (global.Promise && typeof callback !== 'function') {\n      options = callback || {}; // eslint-disable-line no-param-reassign\n      data = options; // eslint-disable-line no-param-reassign\n      return new Promise(executor);\n    }\n    data = data || {}; // eslint-disable-line no-param-reassign\n    return executor(callback, callback);\n  }\n\n  /**\n   * Replaces the head of a JPEG Blob\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} oldHead Old JPEG head\n   * @param {ArrayBuffer} newHead New JPEG head\n   * @returns {Blob} Combined Blob\n   */\n  function replaceJPEGHead(blob, oldHead, newHead) {\n    if (!blob || !oldHead || !newHead) return null;\n    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {\n      type: 'image/jpeg'\n    });\n  }\n\n  /**\n   * Replaces the image head of a JPEG blob with the given one.\n   * Returns a Promise or calls the callback with the new Blob.\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} head New JPEG head\n   * @param {Function} [callback] Callback function\n   * @returns {Promise<Blob|null>|undefined} Combined Blob\n   */\n  function replaceHead(blob, head, callback) {\n    var options = {\n      maxMetaDataSize: 1024,\n      disableMetaDataParsers: true\n    };\n    if (!callback && global.Promise) {\n      return parseMetaData(blob, options).then(function (data) {\n        return replaceJPEGHead(blob, data.imageHead, head);\n      });\n    }\n    parseMetaData(blob, function (data) {\n      callback(replaceJPEGHead(blob, data.imageHead, head));\n    }, options);\n  }\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.requiresMetaData(options)) {\n      data = data || {}; // eslint-disable-line no-param-reassign\n      parseMetaData(file, function (result) {\n        if (result !== data) {\n          // eslint-disable-next-line no-console\n          if (global.console) console.log(result);\n          result = data; // eslint-disable-line no-param-reassign\n        }\n        originalTransform.call(loadImage, img, options, callback, file, result);\n      }, options, data);\n    } else {\n      originalTransform.apply(loadImage, arguments);\n    }\n  };\n  loadImage.blobSlice = blobSlice;\n  loadImage.bufferSlice = bufferSlice;\n  loadImage.replaceHead = replaceHead;\n  loadImage.parseMetaData = parseMetaData;\n  loadImage.metaDataParsers = metaDataParsers;\n});","map":{"version":3,"names":["factory","define","amd","module","exports","require","window","loadImage","global","originalTransform","transform","blobSlice","Blob","prototype","slice","webkitSlice","mozSlice","bufferSlice","ArrayBuffer","begin","end","byteLength","arr1","Uint8Array","arr2","set","buffer","metaDataParsers","jpeg","parseMetaData","file","callback","options","data","that","executor","resolve","reject","DataView","size","type","maxMetaDataSize","readFile","call","dataView","getUint16","Error","offset","maxOffset","headLength","markerBytes","markerLength","parsers","i","console","log","disableMetaDataParsers","length","disableImageHead","imageHead","Promise","replaceJPEGHead","blob","oldHead","newHead","replaceHead","head","then","img","requiresMetaData","result","apply","arguments"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/node_modules/blueimp-load-image/js/load-image-meta.js"],"sourcesContent":["/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image metadata handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise, DataView, Uint8Array, ArrayBuffer */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n  var originalTransform = loadImage.transform\n\n  var blobSlice =\n    global.Blob &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  var bufferSlice =\n    (global.ArrayBuffer && ArrayBuffer.prototype.slice) ||\n    function (begin, end) {\n      // Polyfill for IE10, which does not support ArrayBuffer.slice\n      // eslint-disable-next-line no-param-reassign\n      end = end || this.byteLength - begin\n      var arr1 = new Uint8Array(this, begin, end)\n      var arr2 = new Uint8Array(end)\n      arr2.set(arr1)\n      return arr2.buffer\n    }\n\n  var metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  /**\n   * Parses image metadata and calls the callback with an object argument\n   * with the following property:\n   * - imageHead: The complete image head as ArrayBuffer\n   * The options argument accepts an object and supports the following\n   * properties:\n   * - maxMetaDataSize: Defines the maximum number of bytes to parse.\n   * - disableImageHead: Disables creating the imageHead property.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} [callback] Callback function\n   * @param {object} [options] Parsing options\n   * @param {object} [data] Result data object\n   * @returns {Promise<object>|undefined} Returns Promise if no callback given.\n   */\n  function parseMetaData(file, callback, options, data) {\n    var that = this\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {undefined} Undefined\n     */\n    function executor(resolve, reject) {\n      if (\n        !(\n          global.DataView &&\n          blobSlice &&\n          file &&\n          file.size >= 12 &&\n          file.type === 'image/jpeg'\n        )\n      ) {\n        // Nothing to parse\n        return resolve(data)\n      }\n      // 256 KiB should contain all EXIF/ICC/IPTC segments:\n      var maxMetaDataSize = options.maxMetaDataSize || 262144\n      if (\n        !loadImage.readFile(\n          blobSlice.call(file, 0, maxMetaDataSize),\n          function (buffer) {\n            // Note on endianness:\n            // Since the marker and length bytes in JPEG files are always\n            // stored in big endian order, we can leave the endian parameter\n            // of the DataView methods undefined, defaulting to big endian.\n            var dataView = new DataView(buffer)\n            // Check for the JPEG marker (0xffd8):\n            if (dataView.getUint16(0) !== 0xffd8) {\n              return reject(\n                new Error('Invalid JPEG file: Missing JPEG marker.')\n              )\n            }\n            var offset = 2\n            var maxOffset = dataView.byteLength - 4\n            var headLength = offset\n            var markerBytes\n            var markerLength\n            var parsers\n            var i\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific metadata like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid JPEG metadata: Invalid segment size.')\n                  break\n                }\n                parsers = metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the metadata\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              data.imageHead = bufferSlice.call(buffer, 0, headLength)\n            }\n            resolve(data)\n          },\n          reject,\n          'readAsArrayBuffer'\n        )\n      ) {\n        // No support for the FileReader interface, nothing to parse\n        resolve(data)\n      }\n    }\n    options = options || {} // eslint-disable-line no-param-reassign\n    if (global.Promise && typeof callback !== 'function') {\n      options = callback || {} // eslint-disable-line no-param-reassign\n      data = options // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    data = data || {} // eslint-disable-line no-param-reassign\n    return executor(callback, callback)\n  }\n\n  /**\n   * Replaces the head of a JPEG Blob\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} oldHead Old JPEG head\n   * @param {ArrayBuffer} newHead New JPEG head\n   * @returns {Blob} Combined Blob\n   */\n  function replaceJPEGHead(blob, oldHead, newHead) {\n    if (!blob || !oldHead || !newHead) return null\n    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {\n      type: 'image/jpeg'\n    })\n  }\n\n  /**\n   * Replaces the image head of a JPEG blob with the given one.\n   * Returns a Promise or calls the callback with the new Blob.\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} head New JPEG head\n   * @param {Function} [callback] Callback function\n   * @returns {Promise<Blob|null>|undefined} Combined Blob\n   */\n  function replaceHead(blob, head, callback) {\n    var options = { maxMetaDataSize: 1024, disableMetaDataParsers: true }\n    if (!callback && global.Promise) {\n      return parseMetaData(blob, options).then(function (data) {\n        return replaceJPEGHead(blob, data.imageHead, head)\n      })\n    }\n    parseMetaData(\n      blob,\n      function (data) {\n        callback(replaceJPEGHead(blob, data.imageHead, head))\n      },\n      options\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.requiresMetaData(options)) {\n      data = data || {} // eslint-disable-line no-param-reassign\n      parseMetaData(\n        file,\n        function (result) {\n          if (result !== data) {\n            // eslint-disable-next-line no-console\n            if (global.console) console.log(result)\n            result = data // eslint-disable-line no-param-reassign\n          }\n          originalTransform.call(\n            loadImage,\n            img,\n            options,\n            callback,\n            file,\n            result\n          )\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n\n  loadImage.blobSlice = blobSlice\n  loadImage.bufferSlice = bufferSlice\n  loadImage.replaceHead = replaceHead\n  loadImage.parseMetaData = parseMetaData\n  loadImage.metaDataParsers = metaDataParsers\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}