{"ast":null,"code":"import { makeAutoObservable } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport FrameData from './FrameData';\nimport { getLastKeyFrames, getNextKeyFrames, getShapeFromFrames, predictShapeData } from '../utils';\n/**\n * camera data\n * @class\n */\nexport default class CameraData {\n  /**\n   * shape frame status (keyframe or not)\n   * @getter\n   */\n  get frameStatus() {\n    const status = {};\n    Object.values(this.frames).forEach(({\n      frameIndex,\n      isKeyFrame\n    }) => {\n      status[frameIndex] = isKeyFrame;\n    });\n    return status;\n  }\n\n  /**\n   * no frame\n   * @getter\n   */\n  get isEmpty() {\n    return Object.keys(this.frames).length <= 0;\n  }\n  constructor({\n    camera,\n    frames = []\n  }) {\n    /**\n     * camera name\n     * @member\n     */\n    this.camera = void 0;\n    /**\n     * shape frame data\n     * @member\n     */\n    this.frames = {};\n    /**\n     * instance item related relationships\n     * @member\n     */\n    this.relationships = [];\n    makeAutoObservable(this, {\n      camera: false,\n      isEmpty: false\n    }, {\n      autoBind: true\n    });\n    this.camera = camera;\n    frames.forEach(frame => this.createFrameFromData(frame));\n  }\n\n  /**\n   * create frame from structured frame data\n   * @param frameData\n   */\n  createFrameFromData({\n    frameIndex,\n    isKeyFrame,\n    shapeType,\n    shape,\n    order,\n    attributes,\n    isOCR,\n    OCRText,\n    isFormula,\n    formulaText\n  }) {\n    const frame = new FrameData({\n      frameIndex,\n      isKeyFrame,\n      shapeType,\n      shape,\n      order,\n      attributes,\n      isOCR,\n      OCRText,\n      isFormula,\n      formulaText\n    });\n    this.frames[frameIndex] = frame;\n  }\n\n  /**\n   * update frames from structured data\n   * @param frames\n   */\n  updateFramesFromData(frames) {\n    const prevFrames = {};\n    const currFrames = {};\n    frames.forEach(({\n      frameIndex,\n      isKeyFrame,\n      shapeType,\n      shape,\n      order,\n      attributes,\n      isOCR,\n      OCRText,\n      isFormula,\n      formulaText\n    }, i) => {\n      if (this.frames[frameIndex] && !prevFrames[frameIndex]) {\n        prevFrames[frameIndex] = this.frames[frameIndex].toJSON();\n      }\n      this.createFrameFromData({\n        frameIndex,\n        isKeyFrame,\n        shapeType,\n        shape,\n        order,\n        attributes,\n        isOCR,\n        OCRText,\n        isFormula,\n        formulaText\n      });\n      const isRangeStart = i === 0 || i > 0 && frames[i].frameIndex - frames[i - 1].frameIndex > 1;\n      const isRangeEnd = i === frames.length - 1 || i < frames.length - 1 && frames[i + 1].frameIndex - frames[i].frameIndex > 1;\n      if (isRangeStart || isRangeEnd) {\n        this.frames[frameIndex].isKeyFrame = true;\n        if (isRangeStart && this.frames[frameIndex - 1]) {\n          if (!prevFrames[frameIndex - 1]) {\n            prevFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n          }\n          this.frames[frameIndex - 1].isKeyFrame = true;\n          currFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n        }\n        if (isRangeEnd && this.frames[frameIndex + 1]) {\n          if (!prevFrames[frameIndex + 1]) {\n            prevFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n          }\n          this.frames[frameIndex + 1].isKeyFrame = true;\n          currFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n        }\n      }\n      currFrames[frameIndex] = this.frames[frameIndex].toJSON();\n    });\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * set attributes in frame\n   * @param frames\n   * @param attributes with ocr text\n   */\n  setAttributes(frames, {\n    attributes,\n    OCRText,\n    formulaText\n  }) {\n    const prevState = [];\n    const currState = [];\n    frames.forEach(frameIndex => {\n      if (this.frames[frameIndex]) {\n        prevState.push(this.frames[frameIndex].toJSON());\n        if (attributes) {\n          this.frames[frameIndex].attributes = cloneDeep(attributes);\n        }\n        if (this.frames[frameIndex].isOCR) {\n          this.frames[frameIndex].OCRText = OCRText;\n        }\n        if (this.frames[frameIndex].isFormula) {\n          this.frames[frameIndex].formulaText = formulaText;\n        }\n        currState.push(this.frames[frameIndex].toJSON());\n      }\n    });\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * add shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param isOCR\n   * @param isFormula\n   */\n  addShape(frameIndex, interpolation, shapeType, shapeData, order, isOCR, isFormula, attributes) {\n    this.createFrameFromData({\n      frameIndex,\n      isKeyFrame: true,\n      shapeType,\n      shape: shapeData,\n      order,\n      isOCR,\n      isFormula,\n      attributes\n    });\n    const keyFrame = this.getNearestKeyFrame(frameIndex);\n    if (keyFrame >= 0) {\n      this.frames[frameIndex].attributes = cloneDeep(this.frames[keyFrame].attributes);\n      if (isOCR === undefined) {\n        this.frames[frameIndex].isOCR = this.frames[keyFrame].isOCR;\n        this.frames[frameIndex].OCRText = this.frames[keyFrame].OCRText;\n      }\n      if (isFormula === undefined) {\n        this.frames[frameIndex].isFormula = this.frames[keyFrame].isFormula;\n        this.frames[frameIndex].formulaText = this.frames[keyFrame].formulaText;\n      }\n    }\n    let prevState = [];\n    let currState = [this.frames[frameIndex].toJSON()];\n    if (interpolation) {\n      const affectedState = this.interpolate(frameIndex, true);\n      prevState = [...prevState, ...affectedState.prevState];\n      currState = [...currState, ...affectedState.currState];\n    }\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * update shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(frameIndex, interpolation, shapeType, shapeData, order, attributes) {\n    if (this.frames[frameIndex]) {\n      // update\n      let prevState = [this.frames[frameIndex].toJSON()];\n      this.frames[frameIndex].isKeyFrame = true;\n      this.frames[frameIndex].shapeType = shapeType;\n      this.frames[frameIndex].shape = shapeData;\n      if (order !== undefined) {\n        this.frames[frameIndex].order = order;\n      }\n      if (attributes) {\n        this.frames[frameIndex].attributes = cloneDeep(attributes);\n      }\n      let currState = [this.frames[frameIndex].toJSON()];\n      if (interpolation) {\n        const affectedState = this.interpolate(frameIndex);\n        prevState = [...prevState, ...affectedState.prevState];\n        currState = [...currState, ...affectedState.currState];\n      }\n      return this.formatChangedState(prevState, currState);\n    }\n\n    // add\n    return this.addShape(frameIndex, interpolation, shapeType, shapeData, order, undefined, undefined, attributes);\n  }\n\n  /**\n   * predict shape\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(frameIndex, imageBounds, useNearest = false) {\n    let shapeInfo = predictShapeData(frameIndex, this.frames, imageBounds);\n    if (useNearest && !shapeInfo) {\n      const nearestFrame = this.getNearestKeyFrame(frameIndex);\n      if (nearestFrame >= 0) {\n        const {\n          shapeType,\n          shape\n        } = this.frames[nearestFrame];\n        shapeInfo = {\n          shapeType,\n          shape\n        };\n      }\n    }\n    return shapeInfo;\n  }\n\n  /**\n   * interpolation\n   * @param frameIndex\n   * @param shouldInsert\n   */\n  interpolate(frameIndex, shouldInsert = false) {\n    const prevState = [];\n    const currState = [];\n    const {\n      shapeType\n    } = this.frames[frameIndex];\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    const updateFrameData = (frame, shape, insert, frameData) => {\n      if (this.frames[frame]) {\n        prevState.push(this.frames[frame].toJSON());\n        this.frames[frame].isKeyFrame = false;\n        this.frames[frame].shape = shape;\n        this.frames[frame].shapeType = shapeType;\n        currState.push(this.frames[frame].toJSON());\n      } else if (insert) {\n        this.createFrameFromData({\n          frameIndex: frame,\n          isKeyFrame: false,\n          shapeType,\n          shape,\n          ...(frameData && frameData.attributes && {\n            attributes: frameData.attributes\n          }),\n          ...(frameData && frameData.isOCR && {\n            isOCR: true,\n            OCRText: frameData.OCRText\n          }),\n          ...(frameData && frameData.isFormula && {\n            isFormula: true,\n            formulaText: frameData.formulaText\n          })\n        });\n        currState.push(this.frames[frame].toJSON());\n      }\n    };\n    if (lastKeyFrame !== undefined && this.frames[lastKeyFrame].shapeType === shapeType) {\n      for (let i = lastKeyFrame + 1; i < frameIndex; i += 1) {\n        const {\n          shape\n        } = getShapeFromFrames(this.frames, lastKeyFrame, frameIndex, lastKeyFrame, i);\n        updateFrameData(i, shape, shouldInsert, this.frames[lastKeyFrame]);\n      }\n    }\n    if (nextKeyFrame !== undefined && this.frames[nextKeyFrame].shapeType === shapeType) {\n      for (let i = frameIndex + 1; i < nextKeyFrame; i += 1) {\n        const {\n          shape\n        } = getShapeFromFrames(this.frames, frameIndex, nextKeyFrame, frameIndex, i);\n        updateFrameData(i, shape, false);\n      }\n    }\n    return {\n      prevState,\n      currState\n    };\n  }\n\n  /**\n   * remove from frames\n   * @param frames\n   */\n  remove(frames) {\n    const prevFrames = {};\n    const currFrames = {};\n    for (let i = 0; i < frames.length; i += 1) {\n      const deleteFrame = frames[i];\n      const prevFrame = deleteFrame - 1;\n      const nextFrame = deleteFrame + 1;\n\n      // delete\n      if (this.frames[deleteFrame] && !prevFrames[deleteFrame]) {\n        prevFrames[deleteFrame] = this.frames[deleteFrame].toJSON();\n      }\n      delete this.frames[deleteFrame];\n      delete currFrames[deleteFrame];\n\n      // set prev & next frame to key frame\n      if (this.frames[prevFrame]) {\n        if (!prevFrames[prevFrame]) {\n          prevFrames[prevFrame] = this.frames[prevFrame].toJSON();\n        }\n        this.frames[prevFrame].isKeyFrame = true;\n        currFrames[prevFrame] = this.frames[prevFrame].toJSON();\n      }\n      if (this.frames[nextFrame]) {\n        if (!prevFrames[nextFrame]) {\n          prevFrames[nextFrame] = this.frames[nextFrame].toJSON();\n        }\n        this.frames[nextFrame].isKeyFrame = true;\n        currFrames[nextFrame] = this.frames[nextFrame].toJSON();\n      }\n    }\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * get nearest key frame index\n   * @param frameIndex\n   */\n  getNearestKeyFrame(frameIndex) {\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    if (lastKeyFrame !== undefined) {\n      return lastKeyFrame;\n    }\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    if (nextKeyFrame !== undefined) {\n      return nextKeyFrame;\n    }\n    return -1;\n  }\n\n  /**\n   * add relationship\n   * @param relationship\n   */\n  addRelationship(relationship) {\n    this.relationships.push(relationship);\n  }\n\n  /**\n   * remove relationship\n   * @param relationship\n   */\n  removeRelationship(relationship) {\n    const index = this.relationships.findIndex(r => r.id === relationship.id);\n    if (index >= 0) {\n      this.relationships.splice(index, 1);\n    }\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON() {\n    return {\n      camera: this.camera,\n      frames: Object.values(this.frames).map(frame => frame.toJSON())\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState, currState) {\n    return {\n      ...(prevState.length > 0 && {\n        prevState: {\n          camera: this.camera,\n          frames: [...prevState]\n        }\n      }),\n      ...(currState.length > 0 && {\n        currState: {\n          camera: this.camera,\n          frames: [...currState]\n        }\n      })\n    };\n  }\n}","map":{"version":3,"names":["makeAutoObservable","cloneDeep","FrameData","getLastKeyFrames","getNextKeyFrames","getShapeFromFrames","predictShapeData","CameraData","frameStatus","status","Object","values","frames","forEach","frameIndex","isKeyFrame","isEmpty","keys","length","constructor","camera","relationships","autoBind","frame","createFrameFromData","shapeType","shape","order","attributes","isOCR","OCRText","isFormula","formulaText","updateFramesFromData","prevFrames","currFrames","i","toJSON","isRangeStart","isRangeEnd","formatChangedState","setAttributes","prevState","currState","push","addShape","interpolation","shapeData","keyFrame","getNearestKeyFrame","undefined","affectedState","interpolate","updateShape","predictShape","imageBounds","useNearest","shapeInfo","nearestFrame","shouldInsert","lastKeyFrame","nextKeyFrame","updateFrameData","insert","frameData","remove","deleteFrame","prevFrame","nextFrame","addRelationship","relationship","removeRelationship","index","findIndex","r","id","splice","map"],"sources":["/Users/qzheng/Documents/webroot/annotation_tools/src/components/video-tracking2/model/CameraData.ts"],"sourcesContent":["import { makeAutoObservable } from 'mobx';\nimport { cloneDeep } from 'lodash';\nimport FrameData from './FrameData';\nimport Relationship from './Relationship';\nimport { getLastKeyFrames, getNextKeyFrames, getShapeFromFrames, predictShapeData } from '../utils';\nimport { CameraData as ICameraData, FrameData as IFrameData } from '../types';\nimport { ShapeData, ShapeType } from '../../common/shapes/types';\n\ninterface ChangedState {\n  prevState?: ICameraData;\n  currState?: ICameraData;\n}\n\n/**\n * camera data\n * @class\n */\nexport default class CameraData {\n  /**\n   * camera name\n   * @member\n   */\n  camera: string;\n\n  /**\n   * shape frame data\n   * @member\n   */\n  frames: { [frameIndex: number]: FrameData } = {};\n\n  /**\n   * instance item related relationships\n   * @member\n   */\n  relationships: Relationship[] = [];\n\n  /**\n   * shape frame status (keyframe or not)\n   * @getter\n   */\n  get frameStatus() {\n    const status: {[frameIndex: number]: boolean} = {};\n    Object.values(this.frames).forEach(({ frameIndex, isKeyFrame }) => {\n      status[frameIndex] = isKeyFrame;\n    });\n    return status;\n  }\n\n  /**\n   * no frame\n   * @getter\n   */\n  get isEmpty() {\n    return Object.keys(this.frames).length <= 0;\n  }\n\n  constructor({ camera, frames = [] }: ICameraData) {\n    makeAutoObservable(this, {\n      camera: false,\n      isEmpty: false,\n    }, {\n      autoBind: true,\n    });\n\n    this.camera = camera;\n    frames.forEach((frame) => this.createFrameFromData(frame));\n  }\n\n  /**\n   * create frame from structured frame data\n   * @param frameData\n   */\n  createFrameFromData({ frameIndex, isKeyFrame, shapeType, shape, order, attributes, isOCR, OCRText, isFormula, formulaText }: IFrameData) {\n    const frame = new FrameData({\n      frameIndex,\n      isKeyFrame,\n      shapeType,\n      shape,\n      order,\n      attributes,\n      isOCR,\n      OCRText,\n      isFormula,\n      formulaText,\n    });\n    this.frames[frameIndex] = frame;\n  }\n\n  /**\n   * update frames from structured data\n   * @param frames\n   */\n  updateFramesFromData(frames: IFrameData[]) {\n    const prevFrames: { [frameIndex: number]: IFrameData } = {};\n    const currFrames: { [frameIndex: number]: IFrameData } = {};\n    frames.forEach(({ frameIndex, isKeyFrame, shapeType, shape, order, attributes, isOCR, OCRText, isFormula, formulaText }, i) => {\n      if (this.frames[frameIndex] && !prevFrames[frameIndex]) {\n        prevFrames[frameIndex] = this.frames[frameIndex].toJSON();\n      }\n      this.createFrameFromData({ frameIndex, isKeyFrame, shapeType, shape, order, attributes, isOCR, OCRText, isFormula, formulaText });\n\n      const isRangeStart = i === 0 || (i > 0 && frames[i].frameIndex - frames[i - 1].frameIndex > 1);\n      const isRangeEnd = i === frames.length - 1 || (i < frames.length - 1 && frames[i + 1].frameIndex - frames[i].frameIndex > 1);\n      if (isRangeStart || isRangeEnd) {\n        this.frames[frameIndex].isKeyFrame = true;\n        if (isRangeStart && this.frames[frameIndex - 1]) {\n          if (!prevFrames[frameIndex - 1]) {\n            prevFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n          }\n          this.frames[frameIndex - 1].isKeyFrame = true;\n          currFrames[frameIndex - 1] = this.frames[frameIndex - 1].toJSON();\n        }\n        if (isRangeEnd && this.frames[frameIndex + 1]) {\n          if (!prevFrames[frameIndex + 1]) {\n            prevFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n          }\n          this.frames[frameIndex + 1].isKeyFrame = true;\n          currFrames[frameIndex + 1] = this.frames[frameIndex + 1].toJSON();\n        }\n      }\n\n      currFrames[frameIndex] = this.frames[frameIndex].toJSON();\n    });\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * set attributes in frame\n   * @param frames\n   * @param attributes with ocr text\n   */\n  setAttributes(frames: number[], { attributes, OCRText, formulaText }: { attributes?: any; OCRText?: string; formulaText?: string }) {\n    const prevState: IFrameData[] = [];\n    const currState: IFrameData[] = [];\n    frames.forEach((frameIndex) => {\n      if (this.frames[frameIndex]) {\n        prevState.push(this.frames[frameIndex].toJSON());\n        if (attributes) {\n          this.frames[frameIndex].attributes = cloneDeep(attributes);\n        }\n        if (this.frames[frameIndex].isOCR) {\n          this.frames[frameIndex].OCRText = OCRText;\n        }\n        if (this.frames[frameIndex].isFormula) {\n          this.frames[frameIndex].formulaText = formulaText;\n        }\n        currState.push(this.frames[frameIndex].toJSON());\n      }\n    });\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * add shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param isOCR\n   * @param isFormula\n   */\n  addShape(frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, isOCR?: boolean, isFormula?: boolean, attributes?: any): ChangedState {\n    this.createFrameFromData({\n      frameIndex,\n      isKeyFrame: true,\n      shapeType,\n      shape: shapeData,\n      order,\n      isOCR,\n      isFormula,\n      attributes,\n    });\n\n    const keyFrame = this.getNearestKeyFrame(frameIndex);\n    if (keyFrame >= 0) {\n      this.frames[frameIndex].attributes = cloneDeep(this.frames[keyFrame].attributes);\n      if (isOCR === undefined) {\n        this.frames[frameIndex].isOCR = this.frames[keyFrame].isOCR;\n        this.frames[frameIndex].OCRText = this.frames[keyFrame].OCRText;\n      }\n      if (isFormula === undefined) {\n        this.frames[frameIndex].isFormula = this.frames[keyFrame].isFormula;\n        this.frames[frameIndex].formulaText = this.frames[keyFrame].formulaText;\n      }\n    }\n\n    let prevState: IFrameData[] = [];\n    let currState: IFrameData[] = [this.frames[frameIndex].toJSON()];\n    if (interpolation) {\n      const affectedState = this.interpolate(frameIndex, true);\n      prevState = [...prevState, ...affectedState.prevState];\n      currState = [...currState, ...affectedState.currState];\n    }\n    return this.formatChangedState(prevState, currState);\n  }\n\n  /**\n   * update shape in frame\n   * @param frameIndex\n   * @param interpolation\n   * @param shapeType\n   * @param shapeData\n   * @param order\n   * @param attributes\n   */\n  updateShape(frameIndex: number, interpolation: boolean, shapeType: ShapeType, shapeData: ShapeData, order?: number, attributes?: any) {\n    if (this.frames[frameIndex]) {\n      // update\n      let prevState: IFrameData[] = [this.frames[frameIndex].toJSON()];\n      this.frames[frameIndex].isKeyFrame = true;\n      this.frames[frameIndex].shapeType = shapeType;\n      this.frames[frameIndex].shape = shapeData;\n      if (order !== undefined) {\n        this.frames[frameIndex].order = order;\n      }\n      if (attributes) {\n        this.frames[frameIndex].attributes = cloneDeep(attributes);\n      }\n      let currState: IFrameData[] = [this.frames[frameIndex].toJSON()];\n\n      if (interpolation) {\n        const affectedState = this.interpolate(frameIndex);\n        prevState = [...prevState, ...affectedState.prevState];\n        currState = [...currState, ...affectedState.currState];\n      }\n      return this.formatChangedState(prevState, currState);\n    }\n\n    // add\n    return this.addShape(frameIndex, interpolation, shapeType, shapeData, order, undefined, undefined, attributes);\n  }\n\n  /**\n   * predict shape\n   * @param frameIndex\n   * @param imageBounds\n   * @param useNearest\n   */\n  predictShape(frameIndex: number, imageBounds?: { top: number; right: number; bottom: number; left: number }, useNearest = false) {\n    let shapeInfo = predictShapeData(frameIndex, this.frames, imageBounds);\n    if (useNearest && !shapeInfo) {\n      const nearestFrame = this.getNearestKeyFrame(frameIndex);\n      if (nearestFrame >= 0) {\n        const { shapeType, shape } = this.frames[nearestFrame];\n        shapeInfo = { shapeType, shape };\n      }\n    }\n    return shapeInfo;\n  }\n\n  /**\n   * interpolation\n   * @param frameIndex\n   * @param shouldInsert\n   */\n  interpolate(frameIndex: number, shouldInsert = false) {\n    const prevState: IFrameData[] = [];\n    const currState: IFrameData[] = [];\n\n    const { shapeType } = this.frames[frameIndex];\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    const updateFrameData = (frame: number, shape: ShapeData, insert: boolean, frameData?: FrameData) => {\n      if (this.frames[frame]) {\n        prevState.push(this.frames[frame].toJSON());\n        this.frames[frame].isKeyFrame = false;\n        this.frames[frame].shape = shape;\n        this.frames[frame].shapeType = shapeType;\n        currState.push(this.frames[frame].toJSON());\n      } else if (insert) {\n        this.createFrameFromData({\n          frameIndex: frame,\n          isKeyFrame: false,\n          shapeType,\n          shape,\n          ...(frameData && frameData.attributes && { attributes: frameData.attributes }),\n          ...(frameData && frameData.isOCR && { isOCR: true, OCRText: frameData.OCRText }),\n          ...(frameData && frameData.isFormula && { isFormula: true, formulaText: frameData.formulaText }),\n        });\n        currState.push(this.frames[frame].toJSON());\n      }\n    };\n\n    if (lastKeyFrame !== undefined && this.frames[lastKeyFrame].shapeType === shapeType) {\n      for (let i = lastKeyFrame + 1; i < frameIndex; i += 1) {\n        const { shape } = getShapeFromFrames(this.frames, lastKeyFrame, frameIndex, lastKeyFrame, i);\n        updateFrameData(i, shape, shouldInsert, this.frames[lastKeyFrame]);\n      }\n    }\n    if (nextKeyFrame !== undefined && this.frames[nextKeyFrame].shapeType === shapeType) {\n      for (let i = frameIndex + 1; i < nextKeyFrame; i += 1) {\n        const { shape } = getShapeFromFrames(this.frames, frameIndex, nextKeyFrame, frameIndex, i);\n        updateFrameData(i, shape, false);\n      }\n    }\n\n    return { prevState, currState };\n  }\n\n  /**\n   * remove from frames\n   * @param frames\n   */\n  remove(frames: number[]) {\n    const prevFrames: { [frameIndex: number]: IFrameData } = {};\n    const currFrames: { [frameIndex: number]: IFrameData } = {};\n    for (let i = 0; i < frames.length; i += 1) {\n      const deleteFrame = frames[i];\n      const prevFrame = deleteFrame - 1;\n      const nextFrame = deleteFrame + 1;\n\n      // delete\n      if (this.frames[deleteFrame] && !prevFrames[deleteFrame]) {\n        prevFrames[deleteFrame] = this.frames[deleteFrame].toJSON();\n      }\n      delete this.frames[deleteFrame];\n      delete currFrames[deleteFrame];\n\n      // set prev & next frame to key frame\n      if (this.frames[prevFrame]) {\n        if (!prevFrames[prevFrame]) {\n          prevFrames[prevFrame] = this.frames[prevFrame].toJSON();\n        }\n        this.frames[prevFrame].isKeyFrame = true;\n        currFrames[prevFrame] = this.frames[prevFrame].toJSON();\n      }\n      if (this.frames[nextFrame]) {\n        if (!prevFrames[nextFrame]) {\n          prevFrames[nextFrame] = this.frames[nextFrame].toJSON();\n        }\n        this.frames[nextFrame].isKeyFrame = true;\n        currFrames[nextFrame] = this.frames[nextFrame].toJSON();\n      }\n    }\n    return this.formatChangedState(Object.values(prevFrames), Object.values(currFrames));\n  }\n\n  /**\n   * get nearest key frame index\n   * @param frameIndex\n   */\n  getNearestKeyFrame(frameIndex: number) {\n    const [lastKeyFrame] = getLastKeyFrames(1, frameIndex, this.frames);\n    if (lastKeyFrame !== undefined) {\n      return lastKeyFrame;\n    }\n    const [nextKeyFrame] = getNextKeyFrames(1, frameIndex, this.frames);\n    if (nextKeyFrame !== undefined) {\n      return nextKeyFrame;\n    }\n    return -1;\n  }\n\n  /**\n   * add relationship\n   * @param relationship\n   */\n  addRelationship(relationship: Relationship) {\n    this.relationships.push(relationship);\n  }\n\n  /**\n   * remove relationship\n   * @param relationship\n   */\n  removeRelationship(relationship: Relationship) {\n    const index = this.relationships.findIndex((r) => r.id === relationship.id);\n    if (index >= 0) {\n      this.relationships.splice(index, 1);\n    }\n  }\n\n  /**\n   * return structured data\n   */\n  toJSON(): ICameraData {\n    return {\n      camera: this.camera,\n      frames: Object.values(this.frames).map((frame) => frame.toJSON()),\n    };\n  }\n\n  /**\n   * format changed state\n   * @param prevState\n   * @param currState\n   */\n  formatChangedState(prevState: IFrameData[], currState: IFrameData[]): ChangedState {\n    return {\n      ...prevState.length > 0 && {\n        prevState: { camera: this.camera, frames: [...prevState] },\n      },\n      ...currState.length > 0 && {\n        currState: { camera: this.camera, frames: [...currState] },\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}