function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import pinyin from 'pinyin-match';
import { cloneDeep } from 'lodash';
import { FieldControlType, FieldValueType, ConditionType, FieldOperatorType, AggregationOperatorType, OptionType } from '../types';
export var isContained = function isContained(value, options) {
  if (Array.isArray(value)) {
    for (var index = 0; index < value.length; index += 1) {
      var valueItem = value[index];

      if (!isContained(valueItem, options)) {
        return false;
      }
    }

    return true;
  }

  return !!options.find(function (i) {
    return i.value === value;
  });
};
/**
 * options contained value for nested structures
 * @param values
 * @param options
 */

export function isContainedForNested(values, options) {
  if (values === void 0) {
    values = [];
  }

  var result = values.reduce(function (preVal, currVal) {
    var _preVal$options;

    if (!preVal.isContained || !preVal.options || preVal.options.length < 1) {
      return preVal;
    }

    var option = (_preVal$options = preVal.options) == null ? void 0 : _preVal$options.find(function (o) {
      return o.value === currVal;
    });

    if (option) {
      // eslint-disable-next-line no-param-reassign
      preVal.isContained = true;

      if (option.children && option.children.length > 0) {
        // eslint-disable-next-line no-param-reassign
        preVal.options = option.children;
      }
    } else {
      // eslint-disable-next-line no-param-reassign
      preVal.isContained = false;
    }

    return preVal;
  }, {
    options: options,
    isContained: true
  });
  return result.isContained;
}
export function checkValueIsContained(defaultValue, field) {
  switch (field.type) {
    case FieldControlType.CASCADER:
      return Array.isArray(defaultValue) && isContainedForNested(defaultValue, field.options || []);

    case FieldControlType.CHECKBOX:
    case FieldControlType.RADIO:
    case FieldControlType.SELECT:
      return isContained(defaultValue, field.options || []);

    default:
      return true;
  }
}
/**
 * get supported valueType array by field control type
 * @param type field control type
 */

export function getSupportedValueTypesByControlType(type) {
  if (type === FieldControlType.SWITCH) {
    return [FieldValueType.BOOLEAN];
  }

  if (type === FieldControlType.TEXTAREA) {
    return [FieldValueType.STRING];
  }

  return [FieldValueType.STRING, FieldValueType.NUMBER];
}
/**
 * parse field value by field value type
 * @param value field value
 * @param type field value type
 */

export function praseValueByValueType(value, type) {
  var _val;

  var val = value;

  if (typeof val === 'string' && val.startsWith('[') && val.endsWith(']')) {
    // try to parse as an array string, such as [1,2] or ["A", "B"]
    try {
      val = JSON.parse(val);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.log("Parse as array string failed. Value is: " + value);
    }
  } // continue


  if (typeof val === 'object' && Array.isArray(val)) {
    // if default value is an array
    return val.map(function (v) {
      return praseValueByValueType(v, type);
    });
  }

  if (type === FieldValueType.BOOLEAN) {
    if (typeof val === 'boolean') return val;
    if (typeof val === 'string') return val === 'true';
    if (typeof val === 'number') return !!val;
    return false;
  }

  if (type === FieldValueType.NUMBER) {
    var num = parseFloat(val);
    return Number.isNaN(num) ? undefined : num;
  }

  return (_val = val) == null ? void 0 : _val.toString();
}
/**
 * parse field option item's value and label
 * parse the option value to right value type if necessary
 * @param options initial field options
 * @param type field value type
 */

export function parseOptions(options, type) {
  if (options === void 0) {
    options = [];
  }

  return options.map(function (option) {
    var value;
    var label;
    var group;
    var disabled;
    var desc;
    var referenceUrl;
    var children;

    if (typeof option === 'string' || typeof option === 'number' || typeof option === 'boolean') {
      value = praseValueByValueType(option, type);
      label = option == null ? void 0 : option.toString();
    } else {
      var _ref;

      value = praseValueByValueType(option.value, type);
      label = (_ref = option.label || option.value) == null ? void 0 : _ref.toString();

      if (option.group) {
        group = option.group.toString();
      }

      disabled = option.disabled;
      desc = option.desc;
      referenceUrl = option.referenceUrl;
      children = option.children;

      if (children && children.length > 0) {
        children = parseOptions(children, type);
      }
    }

    disabled = disabled === true || disabled === 'true';
    return {
      value: value,
      label: label,
      group: group,
      disabled: disabled,
      desc: desc,
      referenceUrl: referenceUrl,
      children: children
    };
  });
}
/**
 * parse fields including field validation, value parse, option value parse...
 * @param initialFields
 */

export function parseFormFields(initialFields) {
  var fields = [];
  var initialValues = {};
  initialFields.forEach(function (field) {
    if (field.name !== undefined && field.type !== undefined && Object.values(FieldControlType).includes(field.type)) {
      var supportedValueTypes = getSupportedValueTypesByControlType(field.type);
      var valueType = supportedValueTypes[0];

      if (field.valueType !== undefined && supportedValueTypes.includes(field.valueType)) {
        // if valueType provided and is right
        valueType = field.valueType;
      } else if (field.valueType === undefined) {
        // if valueType not provided, try to get valueType form defaultValue or options
        var item;

        if (field.options !== undefined && field.options.length > 0) {
          item = typeof field.options[0] === 'object' ? field.options[0].value : field.options[0];
        } else if (field.defaultValue !== undefined) {
          item = field.defaultValue;
        }

        if (item !== undefined) {
          var optionValueType = typeof item;

          if (supportedValueTypes.includes(optionValueType)) {
            valueType = optionValueType;
          }
        }
      }

      var newField = {
        name: field.name,
        label: field.label || field.name,
        type: field.type,
        valueType: valueType,
        visible: field.visible !== undefined ? !!field.visible : true,
        required: field.required !== undefined ? !!field.required : false,
        mode: field.mode,
        clickStopPropagation: field == null ? void 0 : field.clickStopPropagation,
        // FIXME: if field is readonly with required and empty defaultValue
        readonly: field.readonly !== undefined ? !!field.readonly : false,
        isRTL: field.isRTL,
        optionType: field.optionType || OptionType.DEFAULT,
        validator: field.validator
      };

      if (field.options !== undefined && Array.isArray(field.options) && field.options.length > 0) {
        newField.options = parseOptions(field.options, valueType);
        newField.optionSearchable = field.optionSearchable !== undefined ? !!field.optionSearchable : false;
        newField.optionFoldable = field.optionFoldable !== undefined ? !!field.optionFoldable : false;
      }

      var defaultValue = praseValueByValueType(field.defaultValue, valueType);

      if (defaultValue !== undefined) {
        var isContain = checkValueIsContained(defaultValue, newField);

        if (isContain) {
          newField.defaultValue = defaultValue;
          initialValues[field.name] = defaultValue;
        }
      }

      fields.push(newField);
    }
  });
  return {
    fields: fields,
    initialValues: initialValues
  };
}
/**
 * get all related fields from condition
 * @param condition the condition should be parsed
 * @param conditions all conditions
 */

export function getFieldsFromCondition(condition, allConditions) {
  var fields = [];

  if (condition.type === ConditionType.AGGREGATION && condition.conditions !== undefined && Array.isArray(condition.conditions) && condition.conditions.length > 0) {
    fields = condition.conditions.reduce(function (acc, cid) {
      var currCondition = allConditions.find(function (c) {
        return c.id === cid;
      });
      return acc.concat(currCondition ? getFieldsFromCondition(currCondition, allConditions) : []);
    }, []);
  } else if (condition.type === ConditionType.FIELD && condition.field !== undefined) {
    fields.push(condition.field);
  }

  return fields;
}
/**
 * compare value and condition value and check is pass the condition
 * @param value origin value, user input
 * @param conditionValue condition defined value
 * @param operator field condtion operator
 */

export function isValuePassCondition(checkValue, conditionValue, operator) {
  var cValue = conditionValue;

  if (typeof conditionValue !== 'string') {
    cValue = conditionValue.toString();
  } else if (operator !== FieldOperatorType.START && operator !== FieldOperatorType.END) {
    cValue = conditionValue.split(',').sort().toString();
  }

  var value = checkValue;

  if (Array.isArray(checkValue) && operator !== FieldOperatorType.START && operator !== FieldOperatorType.END) {
    value = cloneDeep(checkValue).sort();
  }

  switch (operator) {
    case FieldOperatorType.EQUAL:
      return value.toString() === cValue;

    case FieldOperatorType.NOT_EQUAL:
      return value.toString() !== cValue;

    case FieldOperatorType.GREATER:
      {
        var conditionNum = parseFloat(cValue);
        return Number.isNaN(conditionNum) ? false : value > conditionNum;
      }

    case FieldOperatorType.GREATER_EQUAL:
      {
        var _conditionNum = parseFloat(cValue);

        return Number.isNaN(_conditionNum) ? false : value >= _conditionNum;
      }

    case FieldOperatorType.LESS:
      {
        var _conditionNum2 = parseFloat(cValue);

        return Number.isNaN(_conditionNum2) ? false : value < _conditionNum2;
      }

    case FieldOperatorType.LESS_EQUAL:
      {
        var _conditionNum3 = parseFloat(cValue);

        return Number.isNaN(_conditionNum3) ? false : value <= _conditionNum3;
      }

    case FieldOperatorType.CONTAINS:
      if (typeof value === 'object' && Array.isArray(value)) {
        return value.some(function (v) {
          return v.toString() === cValue;
        });
      }

      return value.toString().includes(cValue);

    case FieldOperatorType.START:
      if (typeof value === 'object' && Array.isArray(value)) {
        var _value$;

        return ((_value$ = value[0]) == null ? void 0 : _value$.toString()) === cValue;
      }

      return value.toString().startsWith(cValue);

    case FieldOperatorType.END:
      if (typeof value === 'object' && Array.isArray(value)) {
        var _value;

        return ((_value = value[value.length - 1]) == null ? void 0 : _value.toString()) === cValue;
      }

      return value.toString().endsWith(cValue);

    default:
      return false;
  }
}
/**
 * check whether values pass the condition
 * @param condition check condition
 * @param allConditions all conditions, used to find any nest condition
 * @param allValues all values, used to check the field value in any condition
 */

export function checkCondition(condition, allConditions, allValues) {
  if (condition.type === ConditionType.AGGREGATION && condition.conditions !== undefined && Array.isArray(condition.conditions) && condition.conditions.length > 0) {
    var passRes = condition.conditions.map(function (cid) {
      var currCondition = allConditions.find(function (c) {
        return c.id === cid;
      });
      return currCondition ? checkCondition(currCondition, allConditions, allValues) : false;
    });
    var operator = condition.operator;

    if (operator === AggregationOperatorType.AND) {
      return passRes.every(function (i) {
        return i;
      });
    }

    if (operator === AggregationOperatorType.OR) {
      return passRes.some(function (i) {
        return i;
      });
    }
  } else if (condition.type === ConditionType.FIELD && condition.field !== undefined && allValues[condition.field] !== undefined) {
    return isValuePassCondition(allValues[condition.field], condition.value, condition.operator);
  }

  return false;
}
/**
 * calc col span value for options based on the container
 * @param containerWidth
 * @param avgOptionLength
 */

export function getColSpanForOptions(containerWidth, options) {
  // eslint-disable-next-line no-control-regex
  var optionLengths = options.map(function (o) {
    return (o.label || o.value).toString().replace(/[^\x00-\xff]/g, '01').length;
  });
  optionLengths.sort(function (a, b) {
    return a - b;
  });
  var avgLength = optionLengths[Math.floor(optionLengths.length * 0.75)]; // use 75% length

  var colSpans = [1, 2, 3, 4, 6, 8, 12, 24];
  var cols = containerWidth / ((avgLength + 12) / 2 * 14);

  if (options.length < cols) {
    cols = options.length;
  }

  var span = colSpans[0];

  for (var i = 1; i < colSpans.length; i += 1) {
    if (colSpans[i] > cols) {
      span = colSpans[colSpans.length - i];
      break;
    }
  }

  return span;
}
/**
 * check if the target pass the filter rule
 * @param target target string
 * @param filter filter key
 */

export function textFilter(target, filter) {
  if (target === void 0) {
    target = '';
  }

  if (filter === void 0) {
    filter = '';
  }

  if (!filter) {
    // no filter key
    return true;
  }

  if (pinyin.match(target, filter) !== false) {
    // match chinese character
    return true;
  }

  var splits = target.split(' ').map(function (i) {
    return i[0].toUpperCase();
  }).join('');

  if (splits.indexOf(filter.toUpperCase()) >= 0) {
    // match english initials
    return true;
  }

  return target.toUpperCase().indexOf(filter.toUpperCase()) >= 0;
}
/**
 * trigger a rule
 * @param rule
 * @param allFields all fields
 * @param allValues all values
 * @param initialFields initial fields for default value
 * @param conditions all conditions
 * @param effects all effects
 * @returns { updatedFields, updatedValues } all updated fields and values
 */

export function ruleTrigger(rule, allFields, allValues, initialFields, conditions, effects) {
  var ruleCondition = conditions.find(function (c) {
    return c.id === rule.condition;
  });
  var ruleEffects = effects.filter(function (e) {
    return rule.effects.includes(e.id);
  });
  var updatedFields = [].concat(allFields);

  var updatedValues = _extends({}, allValues);

  if (ruleCondition) {
    // check if the values pass the condition
    var passed = checkCondition(ruleCondition, conditions, allValues);
    ruleEffects.forEach(function (effect) {
      var index = updatedFields.findIndex(function (f) {
        return f.name === effect.field;
      });

      if (index >= 0 && effect.attribute !== undefined) {
        if (effect.attribute === 'value') {
          // if passed, use effect's value
          if (passed) {
            var fieldValue = effect.value;
            var fieldParsedValue = praseValueByValueType(fieldValue, updatedFields[index].valueType);

            if (fieldParsedValue) {
              updatedValues[updatedFields[index].name] = fieldParsedValue;
            }
          }
        } else {
          // visible, required, readonly
          // if passed, use effect's value, otherwise, use initial setting
          var bool = effect.value.toString() === 'true';

          if (!passed) {
            bool = initialFields[index][effect.attribute] !== undefined ? !!initialFields[index][effect.attribute] : effect.attribute === 'visible';
          }

          updatedFields[index][effect.attribute] = bool;

          if (bool && effect.attribute === 'visible') {
            updatedValues[updatedFields[index].name] = bool ? praseValueByValueType(initialFields[index].defaultValue, updatedFields[index].valueType) : undefined;
          }
        }
      }
    });
  }

  return {
    updatedFields: updatedFields,
    updatedValues: updatedValues
  };
} // eslint-disable-next-line @typescript-eslint/no-explicit-any

export function validate(config, values, checkExtra) {
  if (checkExtra === void 0) {
    checkExtra = {
      check: false
    };
  }

  var configFields = config.fields,
      _config$conditions = config.conditions,
      conditions = _config$conditions === void 0 ? [] : _config$conditions,
      _config$effects = config.effects,
      effects = _config$effects === void 0 ? [] : _config$effects,
      _config$rules = config.rules,
      rules = _config$rules === void 0 ? [] : _config$rules;
  var fields = (configFields || []).map(function (field) {
    return _extends({}, field, values[field.name] !== undefined && {
      defaultValue: values[field.name]
    });
  });
  var parsedValue = parseFormFields(fields); // trigger rule effects

  var _rules$reduce = rules.reduce(function (acc, curr) {
    return ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fields, conditions, effects);
  }, {
    updatedFields: parsedValue.fields,
    updatedValues: parsedValue.initialValues
  }),
      updatedFields = _rules$reduce.updatedFields;

  var displayFields = updatedFields.filter(function (i) {
    return i.visible;
  });

  for (var i = 0; i < displayFields.length; i += 1) {
    var field = displayFields[i];
    var value = values[field.name];

    if (field.required && (value === undefined || value === null || value === '')) {
      return false;
    }

    if (field.validator) {
      var result = field.validator(value);

      if (result === false || (result == null ? void 0 : result.pass) === false) {
        return false;
      }
    }
  }

  if (checkExtra.check) {
    var ignoreFieldsSet = new Set(checkExtra.ignoreFields || []);

    if (Object.keys(values).filter(function (field) {
      return !ignoreFieldsSet.has(field);
    }).some(function (field) {
      return !displayFields.find(function (i) {
        return i.name === field;
      });
    })) {
      return false;
    }
  }

  return true;
}
export function parseDisplayValues(formConfig, values, reservedFields) {
  var configFields = formConfig.fields,
      _formConfig$condition = formConfig.conditions,
      conditions = _formConfig$condition === void 0 ? [] : _formConfig$condition,
      _formConfig$effects = formConfig.effects,
      effects = _formConfig$effects === void 0 ? [] : _formConfig$effects,
      _formConfig$rules = formConfig.rules,
      rules = _formConfig$rules === void 0 ? [] : _formConfig$rules;
  var fieldsWithValue = (configFields || []).map(function (field) {
    return _extends({}, field, values[field.name] !== undefined && {
      defaultValue: values[field.name]
    });
  });
  var parsedValue = parseFormFields(fieldsWithValue); // trigger rule effects

  var _rules$reduce2 = rules.reduce(function (acc, curr) {
    return ruleTrigger(curr, acc.updatedFields, acc.updatedValues, fieldsWithValue, conditions, effects);
  }, {
    updatedFields: parsedValue.fields,
    updatedValues: parsedValue.initialValues
  }),
      fields = _rules$reduce2.updatedFields;

  var displayValues = {};
  reservedFields == null ? void 0 : reservedFields.forEach(function (key) {
    displayValues[key] = values[key];
  });
  fields.filter(function (i) {
    return i.visible;
  }).forEach(function (_ref2) {
    var name = _ref2.name;
    displayValues[name] = values[name];
  });
  return displayValues;
}
export default {
  getSupportedValueTypesByControlType: getSupportedValueTypesByControlType,
  praseValueByValueType: praseValueByValueType,
  parseOptions: parseOptions,
  parseFormFields: parseFormFields,
  getFieldsFromCondition: getFieldsFromCondition,
  isValuePassCondition: isValuePassCondition,
  checkCondition: checkCondition,
  getColSpanForOptions: getColSpanForOptions,
  textFilter: textFilter,
  ruleTrigger: ruleTrigger,
  validate: validate,
  parseDisplayValues: parseDisplayValues
};
//# sourceMappingURL=index.js.map