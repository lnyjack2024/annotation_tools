/* eslint-disable @typescript-eslint/no-explicit-any */
import { getSupportedValueTypesByControlType, praseValueByValueType, parseOptions, parseFormFields, getFieldsFromCondition, isValuePassCondition, checkCondition } from './index';
import { FieldValueType, FieldControlType, ConditionType, FieldOperatorType, AggregationOperatorType } from '../types';
describe('test getSupportedValueTypesByControlType', function () {
  test('should return [STRING, NUMBER] as default', function () {
    var supportedTypes = getSupportedValueTypesByControlType(null);
    expect(supportedTypes.length).toBe(2);
    expect(supportedTypes).toContain(FieldValueType.STRING);
    expect(supportedTypes).toContain(FieldValueType.NUMBER);
  });
  test('should return [STRING, NUMBER] for checkbox control', function () {
    var supportedTypes = getSupportedValueTypesByControlType(FieldControlType.CHECKBOX);
    expect(supportedTypes.length).toBe(2);
    expect(supportedTypes).toContain(FieldValueType.STRING);
    expect(supportedTypes).toContain(FieldValueType.NUMBER);
  });
  test('should return [STRING, NUMBER] for radio control', function () {
    var supportedTypes = getSupportedValueTypesByControlType(FieldControlType.RADIO);
    expect(supportedTypes.length).toBe(2);
    expect(supportedTypes).toContain(FieldValueType.STRING);
    expect(supportedTypes).toContain(FieldValueType.NUMBER);
  });
  test('should return [STRING, NUMBER] for select control', function () {
    var supportedTypes = getSupportedValueTypesByControlType(FieldControlType.SELECT);
    expect(supportedTypes.length).toBe(2);
    expect(supportedTypes).toContain(FieldValueType.STRING);
    expect(supportedTypes).toContain(FieldValueType.NUMBER);
  });
  test('should return [BOOLEAN] for switch control', function () {
    var supportedTypes = getSupportedValueTypesByControlType(FieldControlType.SWITCH);
    expect(supportedTypes.length).toBe(1);
    expect(supportedTypes).toContain(FieldValueType.BOOLEAN);
  });
  test('should return [STRING, NUMBER] for text control', function () {
    var supportedTypes = getSupportedValueTypesByControlType(FieldControlType.TEXT);
    expect(supportedTypes.length).toBe(2);
    expect(supportedTypes).toContain(FieldValueType.STRING);
    expect(supportedTypes).toContain(FieldValueType.NUMBER);
  });
  test('should return [STRING] for textarea control', function () {
    var supportedTypes = getSupportedValueTypesByControlType(FieldControlType.TEXTAREA);
    expect(supportedTypes.length).toBe(1);
    expect(supportedTypes).toContain(FieldValueType.STRING);
  });
});
describe('test praseValueByValueType', function () {
  test('should return a string when value type is STRING', function () {
    var parsedValue1 = praseValueByValueType('abc', FieldValueType.STRING);
    expect(parsedValue1).toBe('abc');
    var parsedValue2 = praseValueByValueType(123, FieldValueType.STRING);
    expect(parsedValue2).toBe('123');
    var parsedValue3 = praseValueByValueType(true, FieldValueType.STRING);
    expect(parsedValue3).toBe('true');
  });
  test('should return undefined when no value passed in and value type is STRING', function () {
    var parsedValue = praseValueByValueType(undefined, FieldValueType.STRING);
    expect(parsedValue).toBe(undefined);
  });
  test('should return a number when value type is NUMBER', function () {
    var parsedValue1 = praseValueByValueType('123', FieldValueType.NUMBER);
    expect(parsedValue1).toBe(123);
    var parsedValue2 = praseValueByValueType(123, FieldValueType.NUMBER);
    expect(parsedValue2).toBe(123);
    var parsedValue3 = praseValueByValueType(true, FieldValueType.NUMBER);
    expect(parsedValue3).toBe(undefined);
  });
  test('should return undefined when no value passed in and value type is NUMBER', function () {
    var parsedValue = praseValueByValueType(undefined, FieldValueType.NUMBER);
    expect(parsedValue).toBe(undefined);
  });
  test('should return a boolean when value type is BOOLEAN', function () {
    var parsedValue1 = praseValueByValueType('true', FieldValueType.BOOLEAN);
    expect(parsedValue1).toBe(true);
    var parsedValue2 = praseValueByValueType('false', FieldValueType.BOOLEAN);
    expect(parsedValue2).toBe(false);
    var parsedValue3 = praseValueByValueType(123, FieldValueType.BOOLEAN);
    expect(parsedValue3).toBe(true);
    var parsedValue4 = praseValueByValueType(0, FieldValueType.BOOLEAN);
    expect(parsedValue4).toBe(false);
    var parsedValue5 = praseValueByValueType(true, FieldValueType.BOOLEAN);
    expect(parsedValue5).toBe(true);
    var parsedValue6 = praseValueByValueType(undefined, FieldValueType.BOOLEAN);
    expect(parsedValue6).toBe(false);
  });
  test('should return an array when the value passed in is an array', function () {
    var parsedValue1 = praseValueByValueType(['a', 'b', 'c'], FieldValueType.STRING);
    expect(parsedValue1.length).toBe(3);
    expect(parsedValue1).toContain('a');
    expect(parsedValue1).toContain('b');
    expect(parsedValue1).toContain('c');
    var parsedValue2 = praseValueByValueType([1, 2, 3], FieldValueType.NUMBER);
    expect(parsedValue2.length).toBe(3);
    expect(parsedValue2).toContain(1);
    expect(parsedValue2).toContain(2);
    expect(parsedValue2).toContain(3);
  });
  test('should return an array when the value passed in is like an array string', function () {
    var parsedValue1 = praseValueByValueType('["a", "b", "c"]', FieldValueType.STRING);
    expect(parsedValue1.length).toBe(3);
    expect(parsedValue1).toContain('a');
    expect(parsedValue1).toContain('b');
    expect(parsedValue1).toContain('c');
    var parsedValue2 = praseValueByValueType('[1, 2, 3]', FieldValueType.NUMBER);
    expect(parsedValue2.length).toBe(3);
    expect(parsedValue2).toContain(1);
    expect(parsedValue2).toContain(2);
    expect(parsedValue2).toContain(3);
  });
});
describe('test parseOptions', function () {
  test('should has label and value properties in each option', function () {
    var parsedOptions = parseOptions([1, 2, 3], FieldValueType.NUMBER);
    var hasLabel = parsedOptions.every(function (o) {
      return o.label !== undefined;
    });
    var hasValue = parsedOptions.every(function (o) {
      return o.value !== undefined;
    });
    expect(hasLabel).toBe(true);
    expect(hasValue).toBe(true);
  });
  test('should return default string labels for a non-structured array', function () {
    var parsedOptions = parseOptions([1, 2, 3], FieldValueType.NUMBER);
    var labelCheck = parsedOptions.every(function (o) {
      return o.label === o.value.toString();
    });
    expect(labelCheck).toBe(true);
  });
  test('should return string labels when label is not provided or is not a string', function () {
    var arr = [{
      label: 'a',
      value: 1
    }, {
      value: 2
    }, {
      label: 3,
      value: 3
    }];
    var parsedOptions = parseOptions(arr, FieldValueType.NUMBER);
    var labelCheck = parsedOptions.every(function (o, i) {
      return arr[i].label !== undefined ? o.label === arr[i].label.toString() : o.label === o.value.toString();
    });
    expect(labelCheck).toBe(true);
  });
});
describe('test parseFormFields', function () {
  test('should always return fields and initialValues', function () {
    var parsedFormFields = parseFormFields([]);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.initialValues).toBeDefined();
  });
  test('should not return field when name or type is not provided', function () {
    var fields = [{
      type: FieldControlType.TEXT
    }, {
      name: 'text'
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(0);
  });
  test('should not return field when control type is not supported', function () {
    var fields = [{
      name: 'text',
      type: 'unkown'
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(0);
  });
  test('should return a field with name, label, type, valueType, visible, required, readonly', function () {
    var fields = [{
      name: 'text',
      type: FieldControlType.TEXT
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(1);
    expect(parsedFormFields.fields[0].name).toBeDefined();
    expect(parsedFormFields.fields[0].label).toBeDefined();
    expect(parsedFormFields.fields[0].type).toBeDefined();
    expect(parsedFormFields.fields[0].valueType).toBeDefined();
    expect(parsedFormFields.fields[0].visible).toBeDefined();
    expect(parsedFormFields.fields[0].required).toBeDefined();
    expect(parsedFormFields.fields[0].readonly).toBeDefined();
  });
  test('should return default visible, required, readonly for each field', function () {
    var fields = [{
      name: 'text',
      type: FieldControlType.TEXT
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(1);
    expect(parsedFormFields.fields[0].visible).toBe(true);
    expect(parsedFormFields.fields[0].required).toBe(false);
    expect(parsedFormFields.fields[0].readonly).toBe(false);
  });
  test('should return default valueType when provided value type is not allowed', function () {
    var fields = [{
      name: 'f1',
      type: FieldControlType.TEXT,
      valueType: FieldValueType.BOOLEAN
    }, {
      name: 'f2',
      type: FieldControlType.SWITCH,
      valueType: FieldValueType.STRING
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(2);
    expect(parsedFormFields.fields[0].valueType).toBe(FieldValueType.STRING);
    expect(parsedFormFields.fields[1].valueType).toBe(FieldValueType.BOOLEAN);
  });
  test('should return right valueType from options when value type is not provided', function () {
    var fields = [{
      name: 'f1',
      type: FieldControlType.CHECKBOX,
      options: [1, 2, 3]
    }, {
      name: 'f2',
      type: FieldControlType.CHECKBOX,
      options: ['a', 'b', 'c']
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(2);
    expect(parsedFormFields.fields[0].valueType).toBe(FieldValueType.NUMBER);
    expect(parsedFormFields.fields[1].valueType).toBe(FieldValueType.STRING);
  });
  test('should return right valueType from defaultValue when value type is not provided', function () {
    var fields = [{
      name: 'f1',
      type: FieldControlType.TEXT,
      defaultValue: 123
    }, {
      name: 'f2',
      type: FieldControlType.TEXT,
      defaultValue: 'abc'
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(2);
    expect(parsedFormFields.fields[0].valueType).toBe(FieldValueType.NUMBER);
    expect(parsedFormFields.fields[1].valueType).toBe(FieldValueType.STRING);
  });
  test('should always return defaultValue for a switch control field', function () {
    var fields = [{
      name: 'switch',
      type: FieldControlType.SWITCH
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(1);
    expect(parsedFormFields.fields[0].defaultValue).toBe(false);
  });
  test('should return right defaultValue if provided', function () {
    var fields = [{
      name: 'f1',
      type: FieldControlType.TEXT,
      valueType: FieldValueType.NUMBER,
      defaultValue: '123'
    }, {
      name: 'f2',
      type: FieldControlType.SWITCH,
      valueType: FieldValueType.BOOLEAN,
      defaultValue: 'true'
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(2);
    expect(parsedFormFields.fields[0].defaultValue).toBe(123);
    expect(parsedFormFields.fields[1].defaultValue).toBe(true);
  });
  test('should return initialValues based on defaultValue', function () {
    var fields = [{
      name: 'f1',
      type: FieldControlType.TEXT,
      defaultValue: '123'
    }, {
      name: 'f2',
      type: FieldControlType.SWITCH,
      valueType: FieldValueType.BOOLEAN,
      defaultValue: 'true'
    }, {
      name: 'f3',
      type: FieldControlType.TEXTAREA
    }];
    var parsedFormFields = parseFormFields(fields);
    expect(parsedFormFields.fields).toBeDefined();
    expect(parsedFormFields.fields.length).toBe(3);
    expect(Object.keys(parsedFormFields.initialValues).length).toBe(2);
    expect(parsedFormFields.initialValues.f1).toBe(parsedFormFields.fields[0].defaultValue);
    expect(parsedFormFields.initialValues.f2).toBe(parsedFormFields.fields[1].defaultValue);
    expect(parsedFormFields.initialValues.f3).toBe(undefined);
  });
});
describe('test getFieldsFromCondition', function () {
  test('should return an empty array when condition type is invalid', function () {
    var condition = {
      type: 'unkown'
    };
    var fields = getFieldsFromCondition(condition, [condition]);
    expect(fields.length).toBe(0);
  });
  test('should return an empty array when condition field is not provided', function () {
    var condition = {
      type: ConditionType.FIELD
    };
    var fields = getFieldsFromCondition(condition, [condition]);
    expect(fields.length).toBe(0);
  });
  test('should return the field defined in the FIELD condition', function () {
    var condition = {
      type: ConditionType.FIELD,
      field: 'f1'
    };
    var fields = getFieldsFromCondition(condition, [condition]);
    expect(fields.length).toBe(1);
    expect(fields[0]).toBe('f1');
  });
  test('should return the fields defined in the AGGREGATION condition', function () {
    var condition1 = {
      id: 'c1',
      type: ConditionType.FIELD,
      field: 'f1'
    };
    var condition2 = {
      id: 'c2',
      type: ConditionType.FIELD,
      field: 'f2'
    };
    var condition3 = {
      id: 'c3',
      type: ConditionType.AGGREGATION,
      conditions: [condition1.id, condition2.id]
    };
    var fields = getFieldsFromCondition(condition3, [condition1, condition2, condition3]);
    expect(fields.length).toBe(2);
    expect(fields).toContain('f1');
    expect(fields).toContain('f2');
  });
});
describe('test isValuePassCondition', function () {
  test('should return FLASE when operator is invalid', function () {
    var res = isValuePassCondition('abc', 'abc', 'unkown');
    expect(res).toBe(false);
  });
  test('should return TRUE for "abc" and "abc" when operator is EQUAL', function () {
    var res = isValuePassCondition('abc', 'abc', FieldOperatorType.EQUAL);
    expect(res).toBe(true);
  });
  test('should return TRUE for 123 and "123" when operator is EQUAL', function () {
    var res = isValuePassCondition(123, '123', FieldOperatorType.EQUAL);
    expect(res).toBe(true);
  });
  test('should return TRUE for true and "true" when operator is EQUAL', function () {
    var res = isValuePassCondition(true, 'true', FieldOperatorType.EQUAL);
    expect(res).toBe(true);
  });
  test('should return FLASE for "abc" and "abc" when operator is NOT_EQUAL', function () {
    var res = isValuePassCondition('abc', 'abc', FieldOperatorType.NOT_EQUAL);
    expect(res).toBe(false);
  });
  test('should return FLASE for 123 and "123" when operator is NOT_EQUAL', function () {
    var res = isValuePassCondition(123, '123', FieldOperatorType.NOT_EQUAL);
    expect(res).toBe(false);
  });
  test('should return FLASE for true and "true" when operator is NOT_EQUAL', function () {
    var res = isValuePassCondition(true, 'true', FieldOperatorType.NOT_EQUAL);
    expect(res).toBe(false);
  });
  test('should return TRUE for 2 and 1 when operator is GREATER', function () {
    var res = isValuePassCondition(2, 1, FieldOperatorType.GREATER);
    expect(res).toBe(true);
  });
  test('should return FLASE for 2 and 1 when operator is LESS', function () {
    var res = isValuePassCondition(2, 1, FieldOperatorType.LESS);
    expect(res).toBe(false);
  });
  test('should return TRUE for 1 and 1 when operator is GREATER_EQUAL', function () {
    var res = isValuePassCondition(1, 1, FieldOperatorType.GREATER_EQUAL);
    expect(res).toBe(true);
  });
  test('should return TRUE for 1 and 1 when operator is LESS_EQUAL', function () {
    var res = isValuePassCondition(1, 1, FieldOperatorType.LESS_EQUAL);
    expect(res).toBe(true);
  });
  test('should return TRUE for "abc" and "abc" when operator is CONTAINS, START, END', function () {
    var res1 = isValuePassCondition('abc', 'abc', FieldOperatorType.CONTAINS);
    var res2 = isValuePassCondition('abc', 'abc', FieldOperatorType.START);
    var res3 = isValuePassCondition('abc', 'abc', FieldOperatorType.END);
    expect(res1).toBe(true);
    expect(res2).toBe(true);
    expect(res3).toBe(true);
  });
  test('should return TRUE for ["a"] and "a" when operator is CONTAINS, START, END', function () {
    var res1 = isValuePassCondition(['a'], 'a', FieldOperatorType.CONTAINS);
    var res2 = isValuePassCondition(['a'], 'a', FieldOperatorType.START);
    var res3 = isValuePassCondition(['a'], 'a', FieldOperatorType.END);
    expect(res1).toBe(true);
    expect(res2).toBe(true);
    expect(res3).toBe(true);
  });
});
describe('test checkCondition', function () {
  test('should return TRUE when condition pass', function () {
    var condition1 = {
      id: 'c1',
      type: ConditionType.FIELD,
      field: 'f1',
      value: 'a',
      operator: FieldOperatorType.EQUAL
    };
    var condition2 = {
      id: 'c2',
      type: ConditionType.FIELD,
      field: 'f2',
      value: 'b',
      operator: FieldOperatorType.EQUAL
    };
    var condition3 = {
      id: 'c3',
      type: ConditionType.AGGREGATION,
      conditions: [condition1.id, condition2.id],
      operator: AggregationOperatorType.AND
    };
    var values = {
      f1: 'a',
      f2: 'b'
    };
    var res = checkCondition(condition3, [condition1, condition2, condition3], values);
    expect(res).toBe(true);
  });
  test('should return FALSE when condition not pass', function () {
    var condition1 = {
      id: 'c1',
      type: ConditionType.FIELD,
      field: 'f1',
      value: 'a',
      operator: FieldOperatorType.EQUAL
    };
    var condition2 = {
      id: 'c2',
      type: ConditionType.FIELD,
      field: 'f2',
      value: 'b',
      operator: FieldOperatorType.EQUAL
    };
    var condition3 = {
      id: 'c3',
      type: ConditionType.AGGREGATION,
      conditions: [condition1.id, condition2.id],
      operator: AggregationOperatorType.OR
    };
    var values = {
      f1: 'aa',
      f2: 'bb'
    };
    var res = checkCondition(condition3, [condition1, condition2, condition3], values);
    expect(res).toBe(false);
  });
});
//# sourceMappingURL=index.test.js.map