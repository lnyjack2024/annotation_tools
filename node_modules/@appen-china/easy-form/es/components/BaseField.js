function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useMemo, useState, useEffect } from 'react';
import { ConfigProvider, Form, Input, InputNumber, Switch } from 'antd';
import { CloseCircleFilled, SearchOutlined } from '@ant-design/icons';
import RadioField from './RadioField';
import CheckboxField from './CheckboxField';
import ImageTextField from './ImageTextField';
import SelectField from './SelectField';
import { FieldControlType, FieldValueType, LayoutMode } from '../types';
import CascaderField from './CascaderField';

var BaseField = function BaseField(_ref) {
  var _field$options;

  var field = _ref.field,
      _ref$autoFocus = _ref.autoFocus,
      autoFocus = _ref$autoFocus === void 0 ? false : _ref$autoFocus,
      renderLabel = _ref.renderLabel,
      uploader = _ref.uploader,
      containerSize = _ref.containerSize,
      hideLabel = _ref.hideLabel,
      layoutMode = _ref.layoutMode;

  var _useState = useState(''),
      filterKey = _useState[0],
      setFilterKey = _useState[1];

  var _useState2 = useState(((_field$options = field.options) == null ? void 0 : _field$options.length) || 0),
      filterCount = _useState2[0],
      setFilterCount = _useState2[1];

  var _useState3 = useState(false),
      foldable = _useState3[0],
      setFoldable = _useState3[1];

  var _useState4 = useState(false),
      fold = _useState4[0],
      setFold = _useState4[1];

  useEffect(function () {
    var _field$options2;

    var canFold = field.optionFoldable && ((_field$options2 = field.options) == null ? void 0 : _field$options2.length) > 7;
    setFoldable(canFold);
    setFold(canFold);
  }, [field]);
  var extraProps = useMemo(function () {
    return _extends({}, field.type === FieldControlType.SWITCH && {
      valuePropName: 'checked'
    });
  }, [field.type]);
  var rules = useMemo(function () {
    return [].concat(field.required ? [{
      required: true,
      message: (field.label || field.name) + " is required."
    }] : [], field.validator && {}.toString.call(field.validator) === '[object Function]' ? [{
      validator: function validator(_, value) {
        if (!value) {
          return Promise.resolve();
        }

        var result = field.validator(value);

        if (typeof result === 'boolean' ? result : result.pass) {
          return Promise.resolve();
        }

        return Promise.reject(typeof result === 'boolean' ? 'Value is invalid.' : result.message);
      }
    }] : []);
  }, [field.required, field.validator]);

  var handleFold = function handleFold() {
    if (!fold) setFilterKey('');
    setFold(!fold);
  };

  var renderControl = function renderControl() {
    switch (field.type) {
      case FieldControlType.TEXT:
        if (field.valueType === FieldValueType.NUMBER) {
          return /*#__PURE__*/React.createElement(InputNumber, {
            autoFocus: autoFocus,
            disabled: field.readonly,
            style: {
              width: layoutMode === LayoutMode.COMPACT ? '112px' : '100%'
            },
            autoComplete: "off"
          });
        }

        return /*#__PURE__*/React.createElement(Input, {
          autoFocus: autoFocus,
          disabled: field.readonly,
          autoComplete: "off"
        });

      case FieldControlType.TEXTAREA:
        return /*#__PURE__*/React.createElement(Input.TextArea, _extends({
          autoFocus: autoFocus,
          disabled: field.readonly,
          rows: 3
        }, field.isRTL && {
          dir: 'rtl'
        }, {
          autoComplete: "off"
        }));

      case FieldControlType.SWITCH:
        return /*#__PURE__*/React.createElement(Switch, {
          autoFocus: autoFocus,
          disabled: field.readonly
        });

      case FieldControlType.CHECKBOX:
        return /*#__PURE__*/React.createElement(CheckboxField, {
          autoFocus: !field.optionSearchable && autoFocus,
          disabled: field.readonly,
          options: field.options,
          containerSize: containerSize,
          filterKey: filterKey,
          setFilterCount: setFilterCount
        });

      case FieldControlType.RADIO:
        return /*#__PURE__*/React.createElement(RadioField, {
          autoFocus: !field.optionSearchable && autoFocus,
          disabled: field.readonly,
          options: field.options,
          containerSize: containerSize,
          filterKey: filterKey,
          optionType: field.optionType,
          foldable: foldable,
          fold: fold,
          setFilterCount: setFilterCount,
          handleFold: handleFold
        });

      case FieldControlType.SELECT:
        return /*#__PURE__*/React.createElement(SelectField, {
          autoFocus: autoFocus,
          mode: field == null ? void 0 : field.mode,
          optionSearchable: field == null ? void 0 : field.optionSearchable,
          disabled: field.readonly,
          options: field == null ? void 0 : field.options,
          layoutMode: layoutMode,
          clickStopPropagation: field == null ? void 0 : field.clickStopPropagation
        });

      case FieldControlType.IMAGETEXT:
        return /*#__PURE__*/React.createElement(ImageTextField, {
          autoFocus: autoFocus,
          disabled: field.readonly,
          uploader: uploader
        });

      case FieldControlType.CASCADER:
        return /*#__PURE__*/React.createElement(CascaderField, {
          options: field == null ? void 0 : field.options,
          disabled: field.readonly,
          optionSearchable: field == null ? void 0 : field.optionSearchable,
          layoutMode: layoutMode,
          clickStopPropagation: field == null ? void 0 : field.clickStopPropagation
        });

      default:
        return null;
    }
  };

  var renderTitle = function renderTitle() {
    if (hideLabel) return null;
    var label = renderLabel ? renderLabel(field.label, field) : field.label;

    if (layoutMode !== LayoutMode.COMPACT && (field.type === FieldControlType.RADIO || field.type === FieldControlType.CHECKBOX) && field.optionSearchable && !fold) {
      return /*#__PURE__*/React.createElement("div", {
        className: "easyform-form-item-label-content"
      }, /*#__PURE__*/React.createElement("div", null, label), /*#__PURE__*/React.createElement(Input, {
        autoFocus: autoFocus,
        prefix: /*#__PURE__*/React.createElement(SearchOutlined, null),
        suffix: filterKey ? /*#__PURE__*/React.createElement(CloseCircleFilled, {
          style: {
            fontSize: 12
          },
          onClick: function onClick() {
            return setFilterKey('');
          }
        }) : null,
        value: filterKey,
        onChange: function onChange(e) {
          setFilterKey(e.target.value);
        },
        placeholder: "search...",
        style: {
          marginTop: 6,
          width: '100%',
          background: 'rgba(255, 255, 255, 0.04)'
        }
      }));
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "easyform-form-item-label-content"
    }, /*#__PURE__*/React.createElement("div", null, label));
  };

  if (!field.visible) {
    return null;
  }

  var formItemClassName = function formItemClassName() {
    if (layoutMode === LayoutMode.COMPACT && !hideLabel && (field.type === FieldControlType.SWITCH || field.type === FieldControlType.TEXT && field.valueType === FieldValueType.NUMBER)) {
      return 'easyform-form-item--inline';
    }

    return '';
  };

  return /*#__PURE__*/React.createElement(ConfigProvider, {
    direction: field.isRTL ? 'rtl' : 'ltr'
  }, /*#__PURE__*/React.createElement(Form.Item, _extends({
    className: formItemClassName(),
    validateFirst: true,
    name: field.name,
    label: renderTitle(),
    rules: rules
  }, extraProps), renderControl()));
};

export default BaseField;
//# sourceMappingURL=BaseField.js.map